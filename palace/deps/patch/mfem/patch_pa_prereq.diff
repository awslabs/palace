diff --git a/CHANGELOG b/CHANGELOG
index eb4f4e4bd..1026d6957 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -22,6 +22,10 @@ Version 4.5.3 (development)
   338. Added the tmop-metric-magnitude tool for tracking how metrics change
   under geometric perturbations.
 
+- Reorganized files for bilinear form, linear form, and nonlinear form integrators
+  in the fem/integ/ subdirectory.
+
+
 New and updated examples and miniapps
 -------------------------------------
 - Added a miniapp pmesh-fitting in miniapps/meshing for interface and boundary
@@ -53,6 +57,7 @@ Integrations, testing and documentation
 - Added an address sanitizer GitHub action for a serial build/test on Ubuntu,
   based on Clang/LLVM (https://clang.llvm.org/docs/AddressSanitizer.html).
 
+
 Version 4.5.2, released on March 23, 2023
 =========================================
 
diff --git a/CMakeLists.txt b/CMakeLists.txt
index 32112b549..9e46030ad 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -218,10 +218,7 @@ if (MFEM_USE_HIP)
 endif()
 
 # OpenMP
-if (MFEM_USE_OPENMP OR MFEM_USE_LEGACY_OPENMP)
-  if (NOT MFEM_THREAD_SAFE AND MFEM_USE_LEGACY_OPENMP)
-    message(FATAL_ERROR " *** MFEM_USE_LEGACY_OPENMP requires MFEM_THREAD_SAFE=ON.")
-  endif()
+if (MFEM_USE_OPENMP)
   find_package(OpenMP REQUIRED)
   set(OPENMP_LIBRARIES ${OpenMP_CXX_LIBRARIES})
   if(APPLE)
diff --git a/CONTRIBUTING.md b/CONTRIBUTING.md
index ba372df94..a6111c3e0 100644
--- a/CONTRIBUTING.md
+++ b/CONTRIBUTING.md
@@ -121,6 +121,7 @@ The MFEM source code has the following structure:
   ├── fem
   │   ├── ceed
   │   ├── fe
+  │   ├── integ
   │   ├── lor
   │   ├── moonolith
   │   ├── qinterp
diff --git a/INSTALL b/INSTALL
index cb092cc1b..e48618821 100644
--- a/INSTALL
+++ b/INSTALL
@@ -309,10 +309,6 @@ MFEM_THREAD_SAFE = YES/NO
    Use thread-safe implementation for some classes/methods. This comes at the
    cost of extra memory allocation and de-allocation.
 
-MFEM_USE_LEGACY_OPENMP = YES/NO
-   Enable (basic) experimental OpenMP support. Requires MFEM_THREAD_SAFE.
-   This option is deprecated.
-
 MFEM_USE_OPENMP = YES/NO
    Enable the OpenMP backend.
 
@@ -611,8 +607,8 @@ The specific libraries and their options are:
        http://math-atlas.sourceforge.net (ATLAS)
   Options: LAPACK_OPT (currently not used/needed), LAPACK_LIB.
 
-- OpenMP (optional), usually part of compiler, used when either MFEM_USE_OPENMP
-  or MFEM_USE_LEGACY_OPENMP is set to YES.
+- OpenMP (optional), usually part of compiler, used when MFEM_USE_OPENMP is set
+  to YES.
   Options: OPENMP_OPT, OPENMP_LIB.
 
 - High-resolution POSIX clocks: when using MFEM_TIMER_TYPE = 2, it may be
@@ -956,7 +952,6 @@ MFEM_USE_METIS - Set to ${MFEM_USE_MPI}, can be overwritten.
 MFEM_USE_LIBUNWIND
 MFEM_USE_LAPACK
 MFEM_THREAD_SAFE
-MFEM_USE_LEGACY_OPENMP
 MFEM_USE_OPENMP
 MFEM_USE_MEMALLOC
 MFEM_TIMER_TYPE - Set automatically, can be overwritten.
diff --git a/config/cmake/MFEMConfig.cmake.in b/config/cmake/MFEMConfig.cmake.in
index 9d5eef52f..43b6d0671 100644
--- a/config/cmake/MFEMConfig.cmake.in
+++ b/config/cmake/MFEMConfig.cmake.in
@@ -25,7 +25,6 @@ set(MFEM_USE_LIBUNWIND @MFEM_USE_LIBUNWIND@)
 set(MFEM_USE_LAPACK @MFEM_USE_LAPACK@)
 set(MFEM_THREAD_SAFE @MFEM_THREAD_SAFE@)
 set(MFEM_USE_OPENMP @MFEM_USE_OPENMP@)
-set(MFEM_USE_LEGACY_OPENMP @MFEM_USE_LEGACY_OPENMP@)
 set(MFEM_USE_MEMALLOC @MFEM_USE_MEMALLOC@)
 set(MFEM_TIMER_TYPE @MFEM_TIMER_TYPE@)
 set(MFEM_USE_SUNDIALS @MFEM_USE_SUNDIALS@)
diff --git a/config/cmake/config.hpp.in b/config/cmake/config.hpp.in
index 7e820088a..ba75ff79e 100644
--- a/config/cmake/config.hpp.in
+++ b/config/cmake/config.hpp.in
@@ -74,9 +74,6 @@
 // Enable the OpenMP backend.
 #cmakedefine MFEM_USE_OPENMP
 
-// [Deprecated] Enable experimental OpenMP support. Requires MFEM_THREAD_SAFE.
-#cmakedefine MFEM_USE_LEGACY_OPENMP
-
 // Internal MFEM option: enable group/batch allocation for some small objects.
 #cmakedefine MFEM_USE_MEMALLOC
 
diff --git a/config/cmake/modules/MfemCmakeUtilities.cmake b/config/cmake/modules/MfemCmakeUtilities.cmake
index 204b7d87f..9a629330b 100644
--- a/config/cmake/modules/MfemCmakeUtilities.cmake
+++ b/config/cmake/modules/MfemCmakeUtilities.cmake
@@ -843,16 +843,16 @@ function(mfem_export_mk_files)
   # Convert Boolean vars to YES/NO without writing the values to cache
   set(CONFIG_MK_BOOL_VARS MFEM_USE_MPI MFEM_USE_METIS MFEM_USE_METIS_5
       MFEM_DEBUG MFEM_USE_EXCEPTIONS MFEM_USE_ZLIB MFEM_USE_LIBUNWIND
-      MFEM_USE_LAPACK MFEM_THREAD_SAFE MFEM_USE_LEGACY_OPENMP MFEM_USE_OPENMP
-      MFEM_USE_MEMALLOC MFEM_USE_SUNDIALS MFEM_USE_SUITESPARSE
-      MFEM_USE_SUPERLU MFEM_USE_SUPERLU5 MFEM_USE_MUMPS MFEM_USE_STRUMPACK
-      MFEM_USE_GINKGO MFEM_USE_AMGX MFEM_USE_GNUTLS MFEM_USE_NETCDF
-      MFEM_USE_PETSC MFEM_USE_SLEPC MFEM_USE_MPFR MFEM_USE_SIDRE MFEM_USE_FMS
-      MFEM_USE_CONDUIT MFEM_USE_PUMI MFEM_USE_HIOP MFEM_USE_GSLIB MFEM_USE_CUDA
-      MFEM_USE_HIP MFEM_USE_RAJA MFEM_USE_OCCA MFEM_USE_CEED MFEM_USE_CALIPER
-      MFEM_USE_UMPIRE MFEM_USE_SIMD MFEM_USE_ADIOS2 MFEM_USE_MKL_CPARDISO
-      MFEM_USE_ADFORWARD MFEM_USE_CODIPACK MFEM_USE_BENCHMARK MFEM_USE_PARELAG
-      MFEM_USE_MOONOLITH MFEM_USE_ALGOIM MFEM_USE_ENZYME)
+      MFEM_USE_LAPACK MFEM_THREAD_SAFE MFEM_USE_OPENMP MFEM_USE_MEMALLOC
+      MFEM_USE_SUNDIALS MFEM_USE_SUITESPARSE MFEM_USE_SUPERLU MFEM_USE_SUPERLU5
+      MFEM_USE_MUMPS MFEM_USE_STRUMPACK MFEM_USE_GINKGO MFEM_USE_AMGX
+      MFEM_USE_GNUTLS MFEM_USE_NETCDF MFEM_USE_PETSC MFEM_USE_SLEPC
+      MFEM_USE_MPFR MFEM_USE_SIDRE MFEM_USE_FMS MFEM_USE_CONDUIT MFEM_USE_PUMI
+      MFEM_USE_HIOP MFEM_USE_GSLIB MFEM_USE_CUDA MFEM_USE_HIP MFEM_USE_RAJA
+      MFEM_USE_OCCA MFEM_USE_CEED MFEM_USE_CALIPER MFEM_USE_UMPIRE
+      MFEM_USE_SIMD MFEM_USE_ADIOS2 MFEM_USE_MKL_CPARDISO MFEM_USE_ADFORWARD
+      MFEM_USE_CODIPACK MFEM_USE_BENCHMARK MFEM_USE_PARELAG MFEM_USE_MOONOLITH
+      MFEM_USE_ALGOIM MFEM_USE_ENZYME)
   foreach(var ${CONFIG_MK_BOOL_VARS})
     if (${var})
       set(${var} YES)
diff --git a/config/config.hpp.in b/config/config.hpp.in
index 76145927b..d82bf192c 100644
--- a/config/config.hpp.in
+++ b/config/config.hpp.in
@@ -74,9 +74,6 @@
 // Enable the OpenMP backend.
 // #define MFEM_USE_OPENMP
 
-// [Deprecated] Enable experimental OpenMP support. Requires MFEM_THREAD_SAFE.
-// #define MFEM_USE_LEGACY_OPENMP
-
 // Internal MFEM option: enable group/batch allocation for some small objects.
 // #define MFEM_USE_MEMALLOC
 
diff --git a/config/config.mk.in b/config/config.mk.in
index baf5c2955..8858d01b8 100644
--- a/config/config.mk.in
+++ b/config/config.mk.in
@@ -24,7 +24,6 @@ MFEM_USE_ZLIB          = @MFEM_USE_ZLIB@
 MFEM_USE_LIBUNWIND     = @MFEM_USE_LIBUNWIND@
 MFEM_USE_LAPACK        = @MFEM_USE_LAPACK@
 MFEM_THREAD_SAFE       = @MFEM_THREAD_SAFE@
-MFEM_USE_LEGACY_OPENMP = @MFEM_USE_LEGACY_OPENMP@
 MFEM_USE_OPENMP        = @MFEM_USE_OPENMP@
 MFEM_USE_MEMALLOC      = @MFEM_USE_MEMALLOC@
 MFEM_TIMER_TYPE        = @MFEM_TIMER_TYPE@
diff --git a/config/defaults.cmake b/config/defaults.cmake
index d5104092b..a72be813f 100644
--- a/config/defaults.cmake
+++ b/config/defaults.cmake
@@ -28,7 +28,6 @@ option(MFEM_USE_LIBUNWIND "Enable backtrace for errors." OFF)
 option(MFEM_USE_LAPACK "Enable LAPACK usage" OFF)
 option(MFEM_THREAD_SAFE "Enable thread safety" OFF)
 option(MFEM_USE_OPENMP "Enable the OpenMP backend" OFF)
-option(MFEM_USE_LEGACY_OPENMP "Enable legacy OpenMP usage" OFF)
 option(MFEM_USE_MEMALLOC "Enable the internal MEMALLOC option." ON)
 option(MFEM_USE_SUNDIALS "Enable SUNDIALS usage" OFF)
 option(MFEM_USE_SUITESPARSE "Enable SuiteSparse usage" OFF)
diff --git a/config/defaults.mk b/config/defaults.mk
index ca5dc3c45..364627756 100644
--- a/config/defaults.mk
+++ b/config/defaults.mk
@@ -127,7 +127,6 @@ MFEM_USE_LIBUNWIND     = NO
 MFEM_USE_LAPACK        = NO
 MFEM_THREAD_SAFE       = NO
 MFEM_USE_OPENMP        = NO
-MFEM_USE_LEGACY_OPENMP = NO
 MFEM_USE_MEMALLOC      = YES
 MFEM_TIMER_TYPE        = $(if $(NOTMAC),2,4)
 MFEM_USE_SUNDIALS      = NO
diff --git a/fem/CMakeLists.txt b/fem/CMakeLists.txt
index 462ef72aa..6da0cfea3 100644
--- a/fem/CMakeLists.txt
+++ b/fem/CMakeLists.txt
@@ -13,28 +13,39 @@ set(SRCS
   bilinearform.cpp
   bilinearform_ext.cpp
   bilininteg.cpp
-  bilininteg_br2.cpp
-  bilininteg_convection_mf.cpp
-  bilininteg_convection_pa.cpp
-  bilininteg_convection_ea.cpp
-  bilininteg_dgtrace_pa.cpp
-  bilininteg_dgtrace_ea.cpp
-  bilininteg_diffusion_mf.cpp
-  bilininteg_diffusion_pa.cpp
-  bilininteg_diffusion_ea.cpp
-  bilininteg_divergence.cpp
-  bilininteg_hcurl.cpp
-  bilininteg_hdiv.cpp
-  bilininteg_vectorfe.cpp
-  bilininteg_gradient.cpp
-  bilininteg_mass_mf.cpp
-  bilininteg_mass_pa.cpp
-  bilininteg_mass_ea.cpp
-  bilininteg_transpose_ea.cpp
-  bilininteg_vecdiffusion.cpp
-  bilininteg_vecdiffusion_mf.cpp
-  bilininteg_vecmass.cpp
-  bilininteg_vecmass_mf.cpp
+  integ/bilininteg_br2.cpp
+  integ/bilininteg_convection_mf.cpp
+  integ/bilininteg_convection_pa.cpp
+  integ/bilininteg_convection_ea.cpp
+  integ/bilininteg_curlcurl_pa.cpp
+  integ/bilininteg_dgtrace_pa.cpp
+  integ/bilininteg_dgtrace_ea.cpp
+  integ/bilininteg_diffusion_mf.cpp
+  integ/bilininteg_diffusion_pa.cpp
+  integ/bilininteg_diffusion_ea.cpp
+  integ/bilininteg_divdiv_pa.cpp
+  integ/bilininteg_gradient_pa.cpp
+  integ/bilininteg_interp_pa.cpp
+  integ/bilininteg_mass_mf.cpp
+  integ/bilininteg_mass_pa.cpp
+  integ/bilininteg_mass_ea.cpp
+  integ/bilininteg_mixedcurl_pa.cpp
+  integ/bilininteg_mixedvecgrad_pa.cpp
+  integ/bilininteg_transpose_ea.cpp
+  integ/bilininteg_vecdiffusion_mf.cpp
+  integ/bilininteg_vecdiffusion_pa.cpp
+  integ/bilininteg_vecdiv_pa.cpp
+  integ/bilininteg_vecmass_mf.cpp
+  integ/bilininteg_vecmass_pa.cpp
+  integ/bilininteg_vectorfediv_pa.cpp
+  integ/bilininteg_vectorfemass_pa.cpp
+  integ/lininteg_boundary.cpp
+  integ/lininteg_boundary_flux.cpp
+  integ/lininteg_domain.cpp
+  integ/lininteg_domain_grad.cpp
+  integ/lininteg_domain_vectorfe.cpp
+  integ/nonlininteg_vecconvection_pa.cpp
+  integ/nonlininteg_vecconvection_mf.cpp
   coefficient.cpp
   complex_fem.cpp
   convergence.cpp
@@ -74,11 +85,6 @@ set(SRCS
   linearform.cpp
   linearform_ext.cpp
   lininteg.cpp
-  lininteg_boundary.cpp
-  lininteg_boundary_flux.cpp
-  lininteg_domain.cpp
-  lininteg_domain_grad.cpp
-  lininteg_vectorfe_domain.cpp
   lor/lor.cpp
   lor/lor_ads.cpp
   lor/lor_ams.cpp
@@ -91,8 +97,6 @@ set(SRCS
   nonlinearform_ext.cpp
   nonlininteg.cpp
   fespacehierarchy.cpp
-  nonlininteg_vectorconvection.cpp
-  nonlininteg_vectorconvection_mf.cpp
   qfunction.cpp
   qinterp/det.cpp
   qinterp/eval_by_nodes.cpp
@@ -143,7 +147,11 @@ set(HDRS
   bilinearform.hpp
   bilinearform_ext.hpp
   bilininteg.hpp
-  bilininteg_mass_pa.hpp
+  integ/bilininteg_diffusion_kernels.hpp
+  integ/bilininteg_hcurl_kernels.hpp
+  integ/bilininteg_hdiv_kernels.hpp
+  integ/bilininteg_hcurlhdiv_kernels.hpp
+  integ/bilininteg_mass_kernels.hpp
   coefficient.hpp
   complex_fem.hpp
   convergence.hpp
diff --git a/fem/bilinearform.cpp b/fem/bilinearform.cpp
index fad9717aa..a549d03a7 100644
--- a/fem/bilinearform.cpp
+++ b/fem/bilinearform.cpp
@@ -18,84 +18,31 @@
 namespace mfem
 {
 
-void BilinearForm::AllocMat()
-{
-   if (static_cond) { return; }
-
-   if (precompute_sparsity == 0 || fes->GetVDim() > 1)
-   {
-      mat = new SparseMatrix(height);
-      return;
-   }
-
-   const Table &elem_dof = fes->GetElementToDofTable();
-   Table dof_dof;
-
-   if (interior_face_integs.Size() > 0)
-   {
-      // the sparsity pattern is defined from the map: face->element->dof
-      Table face_dof, dof_face;
-      {
-         Table *face_elem = fes->GetMesh()->GetFaceToElementTable();
-         mfem::Mult(*face_elem, elem_dof, face_dof);
-         delete face_elem;
-      }
-      Transpose(face_dof, dof_face, height);
-      mfem::Mult(dof_face, face_dof, dof_dof);
-   }
-   else
-   {
-      // the sparsity pattern is defined from the map: element->dof
-      Table dof_elem;
-      Transpose(elem_dof, dof_elem, height);
-      mfem::Mult(dof_elem, elem_dof, dof_dof);
-   }
-
-   dof_dof.SortRows();
-
-   int *I = dof_dof.GetI();
-   int *J = dof_dof.GetJ();
-   double *data = Memory<double>(I[height]);
-
-   mat = new SparseMatrix(I, J, data, height, height, true, true, true);
-   *mat = 0.0;
-
-   dof_dof.LoseData();
-}
-
-BilinearForm::BilinearForm(FiniteElementSpace * f)
-   : Matrix (f->GetVSize())
+BilinearForm::BilinearForm(FiniteElementSpace *f)
+   : Matrix(f->GetVSize())
 {
    fes = f;
    sequence = f->GetSequence();
    mat = mat_e = NULL;
    extern_bfs = 0;
-   element_matrices = NULL;
    static_cond = NULL;
    hybridization = NULL;
-   precompute_sparsity = 0;
    diag_policy = DIAG_KEEP;
-
    assembly = AssemblyLevel::LEGACY;
-   batch = 1;
    ext = NULL;
 }
 
-BilinearForm::BilinearForm (FiniteElementSpace * f, BilinearForm * bf, int ps)
-   : Matrix (f->GetVSize())
+BilinearForm::BilinearForm(FiniteElementSpace *f, BilinearForm *bf)
+   : Matrix(f->GetVSize())
 {
    fes = f;
    sequence = f->GetSequence();
-   mat_e = NULL;
+   mat = mat_e = NULL;
    extern_bfs = 1;
-   element_matrices = NULL;
    static_cond = NULL;
    hybridization = NULL;
-   precompute_sparsity = ps;
    diag_policy = DIAG_KEEP;
-
    assembly = AssemblyLevel::LEGACY;
-   batch = 1;
    ext = NULL;
 
    // Copy the pointers to the integrators
@@ -108,8 +55,6 @@ BilinearForm::BilinearForm (FiniteElementSpace * f, BilinearForm * bf, int ps)
 
    boundary_face_integs = bf->boundary_face_integs;
    boundary_face_integs_marker = bf->boundary_face_integs_marker;
-
-   AllocMat();
 }
 
 void BilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
@@ -124,7 +69,7 @@ void BilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
       case AssemblyLevel::LEGACY:
          break;
       case AssemblyLevel::FULL:
-         SetDiagonalPolicy( DIAG_ONE ); // Only diagonal policy supported on device
+         SetDiagonalPolicy(DIAG_ONE); // Only diagonal policy supported on device
          ext = new FABilinearFormExtension(this);
          break;
       case AssemblyLevel::ELEMENT:
@@ -181,48 +126,71 @@ void BilinearForm::EnableHybridization(FiniteElementSpace *constr_space,
    hybridization->Init(ess_tdof_list);
 }
 
-void BilinearForm::UseSparsity(int *I, int *J, bool isSorted)
+double &BilinearForm::Elem(int i, int j)
 {
-   if (static_cond) { return; }
+   return mat->Elem(i,j);
+}
+
+const double &BilinearForm::Elem(int i, int j) const
+{
+   return mat->Elem(i,j);
+}
 
-   if (mat)
+void BilinearForm::Mult(const Vector &x, Vector &y) const
+{
+   if (ext)
    {
-      if (mat->Finalized() && mat->GetI() == I && mat->GetJ() == J)
-      {
-         return; // mat is already using the given sparsity
-      }
-      delete mat;
+      ext->Mult(x, y);
+   }
+   else
+   {
+      mat->Mult(x, y);
    }
-   height = width = fes->GetVSize();
-   mat = new SparseMatrix(I, J, NULL, height, width, false, true, isSorted);
 }
 
-void BilinearForm::UseSparsity(SparseMatrix &A)
+void BilinearForm::AddMult(const Vector &x, Vector &y, const double a) const
 {
-   MFEM_ASSERT(A.Height() == fes->GetVSize() && A.Width() == fes->GetVSize(),
-               "invalid matrix A dimensions: "
-               << A.Height() << " x " << A.Width());
-   MFEM_ASSERT(A.Finalized(), "matrix A must be Finalized");
-
-   UseSparsity(A.GetI(), A.GetJ(), A.ColumnsAreSorted());
+   if (ext)
+   {
+      ext->AddMult(x, y, a);
+   }
+   else
+   {
+      mat->AddMult(x, y, a);
+   }
 }
 
-double& BilinearForm::Elem (int i, int j)
+void BilinearForm::MultTranspose(const Vector &x, Vector &y) const
 {
-   return mat -> Elem(i,j);
+   if (ext)
+   {
+      ext->MultTranspose(x, y);
+   }
+   else
+   {
+      mat->MultTranspose(x, y);
+   }
 }
 
-const double& BilinearForm::Elem (int i, int j) const
+void BilinearForm::AddMultTranspose(const Vector &x, Vector &y,
+                                    const double a) const
 {
-   return mat -> Elem(i,j);
+   if (ext)
+   {
+      ext->AddMultTranspose(x, y, a);
+   }
+   else
+   {
+      mat->AddMultTranspose(x, y, a);
+   }
 }
 
-MatrixInverse * BilinearForm::Inverse() const
+MatrixInverse *BilinearForm::Inverse() const
 {
-   return mat -> Inverse();
+   return mat->Inverse();
 }
 
-void BilinearForm::Finalize (int skip_zeros)
+void BilinearForm::Finalize(int skip_zeros)
 {
    if (assembly == AssemblyLevel::LEGACY)
    {
@@ -246,22 +214,22 @@ void BilinearForm::AddDomainIntegrator(BilinearFormIntegrator *bfi,
    domain_integs_marker.Append(&elem_marker);
 }
 
-void BilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi)
+void BilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(NULL); // NULL marker means apply everywhere
 }
 
-void BilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi,
-                                          Array<int> &bdr_marker)
+void BilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi,
+                                         Array<int> &bdr_marker)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(&bdr_marker);
 }
 
-void BilinearForm::AddInteriorFaceIntegrator(BilinearFormIntegrator * bfi)
+void BilinearForm::AddInteriorFaceIntegrator(BilinearFormIntegrator *bfi)
 {
-   interior_face_integs.Append (bfi);
+   interior_face_integs.Append(bfi);
 }
 
 void BilinearForm::AddBdrFaceIntegrator(BilinearFormIntegrator *bfi)
@@ -278,55 +246,6 @@ void BilinearForm::AddBdrFaceIntegrator(BilinearFormIntegrator *bfi,
    boundary_face_integs_marker.Append(&bdr_marker);
 }
 
-void BilinearForm::ComputeElementMatrix(int i, DenseMatrix &elmat)
-{
-   if (element_matrices)
-   {
-      elmat.SetSize(element_matrices->SizeI(), element_matrices->SizeJ());
-      elmat = element_matrices->GetData(i);
-      return;
-   }
-
-   if (domain_integs.Size())
-   {
-      const FiniteElement &fe = *fes->GetFE(i);
-      ElementTransformation *eltrans = fes->GetElementTransformation(i);
-      domain_integs[0]->AssembleElementMatrix(fe, *eltrans, elmat);
-      for (int k = 1; k < domain_integs.Size(); k++)
-      {
-         domain_integs[k]->AssembleElementMatrix(fe, *eltrans, elemmat);
-         elmat += elemmat;
-      }
-   }
-   else
-   {
-      fes->GetElementVDofs(i, vdofs);
-      elmat.SetSize(vdofs.Size());
-      elmat = 0.0;
-   }
-}
-
-void BilinearForm::ComputeBdrElementMatrix(int i, DenseMatrix &elmat)
-{
-   if (boundary_integs.Size())
-   {
-      const FiniteElement &be = *fes->GetBE(i);
-      ElementTransformation *eltrans = fes->GetBdrElementTransformation(i);
-      boundary_integs[0]->AssembleElementMatrix(be, *eltrans, elmat);
-      for (int k = 1; k < boundary_integs.Size(); k++)
-      {
-         boundary_integs[k]->AssembleElementMatrix(be, *eltrans, elemmat);
-         elmat += elemmat;
-      }
-   }
-   else
-   {
-      fes->GetBdrElementVDofs(i, vdofs);
-      elmat.SetSize(vdofs.Size());
-      elmat = 0.0;
-   }
-}
-
 void BilinearForm::AssembleElementMatrix(
    int i, const DenseMatrix &elmat, int skip_zeros)
 {
@@ -345,7 +264,7 @@ void BilinearForm::AssembleElementMatrix(
    {
       if (mat == NULL)
       {
-         AllocMat();
+         mat = new SparseMatrix(height);
       }
       mat->AddSubMatrix(vdofs_, vdofs_, elmat, skip_zeros);
       if (hybridization)
@@ -373,7 +292,7 @@ void BilinearForm::AssembleBdrElementMatrix(
    {
       if (mat == NULL)
       {
-         AllocMat();
+         mat = new SparseMatrix(height);
       }
       mat->AddSubMatrix(vdofs_, vdofs_, elmat, skip_zeros);
       if (hybridization)
@@ -392,23 +311,14 @@ void BilinearForm::Assemble(int skip_zeros)
    }
 
    ElementTransformation *eltrans;
-   DofTransformation * doftrans;
-   Mesh *mesh = fes -> GetMesh();
-   DenseMatrix elmat, *elmat_p;
-
-   if (mat == NULL)
-   {
-      AllocMat();
-   }
+   DofTransformation *doftrans;
+   Mesh *mesh = fes->GetMesh();
+   DenseMatrix elmat;
 
-#ifdef MFEM_USE_LEGACY_OPENMP
-   int free_element_matrices = 0;
-   if (!element_matrices)
+   if (mat == NULL && !static_cond)
    {
-      ComputeElementMatrices();
-      free_element_matrices = 1;
+      mat = new SparseMatrix(height);
    }
-#endif
 
    if (domain_integs.Size())
    {
@@ -423,61 +333,49 @@ void BilinearForm::Assemble(int skip_zeros)
          }
       }
 
-      for (int i = 0; i < fes -> GetNE(); i++)
+      for (int i = 0; i < fes->GetNE(); i++)
       {
          int elem_attr = fes->GetMesh()->GetAttribute(i);
          doftrans = fes->GetElementVDofs(i, vdofs);
-         if (element_matrices)
-         {
-            elmat_p = &(*element_matrices)(i);
-         }
-         else
+         elmat.SetSize(0);
+         for (int k = 0; k < domain_integs.Size(); k++)
          {
-            elmat.SetSize(0);
-            for (int k = 0; k < domain_integs.Size(); k++)
+            if ( domain_integs_marker[k] == NULL ||
+                 (*(domain_integs_marker[k]))[elem_attr-1] == 1)
             {
-               if ( domain_integs_marker[k] == NULL ||
-                    (*(domain_integs_marker[k]))[elem_attr-1] == 1)
+               const FiniteElement &fe = *fes->GetFE(i);
+               eltrans = fes->GetElementTransformation(i);
+               domain_integs[k]->AssembleElementMatrix(fe, *eltrans, elemmat);
+               if (elmat.Size() == 0)
                {
-                  const FiniteElement &fe = *fes->GetFE(i);
-                  eltrans = fes->GetElementTransformation(i);
-                  domain_integs[k]->AssembleElementMatrix(fe, *eltrans, elemmat);
-                  if (elmat.Size() == 0)
-                  {
-                     elmat = elemmat;
-                  }
-                  else
-                  {
-                     elmat += elemmat;
-                  }
+                  elmat = elemmat;
+               }
+               else
+               {
+                  elmat += elemmat;
                }
             }
-            if (elmat.Size() == 0)
-            {
-               continue;
-            }
-            else
-            {
-               elmat_p = &elmat;
-            }
-            if (doftrans)
-            {
-               doftrans->TransformDual(elmat);
-            }
-            elmat_p = &elmat;
          }
-         if (static_cond)
+         if (elmat.Size() == 0)
          {
-            static_cond->AssembleMatrix(i, *elmat_p);
+            continue;
          }
-         else
+         if (doftrans)
          {
-            mat->AddSubMatrix(vdofs, vdofs, *elmat_p, skip_zeros);
+            doftrans->TransformDual(elmat);
+         }
+         if (!static_cond)
+         {
+            mat->AddSubMatrix(vdofs, vdofs, elmat, skip_zeros);
             if (hybridization)
             {
-               hybridization->AssembleMatrix(i, *elmat_p);
+               hybridization->AssembleMatrix(i, elmat);
             }
          }
+         else
+         {
+            static_cond->AssembleMatrix(i, elmat);
+         }
       }
    }
 
@@ -504,14 +402,14 @@ void BilinearForm::Assemble(int skip_zeros)
          }
       }
 
-      for (int i = 0; i < fes -> GetNBE(); i++)
+      for (int i = 0; i < fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
 
          const FiniteElement &be = *fes->GetBE(i);
-         doftrans = fes -> GetBdrElementVDofs (i, vdofs);
-         eltrans = fes -> GetBdrElementTransformation (i);
+         doftrans = fes->GetBdrElementVDofs(i, vdofs);
+         eltrans = fes->GetBdrElementTransformation(i);
          int k = 0;
          for (; k < boundary_integs.Size(); k++)
          {
@@ -534,18 +432,17 @@ void BilinearForm::Assemble(int skip_zeros)
          {
             doftrans->TransformDual(elmat);
          }
-         elmat_p = &elmat;
          if (!static_cond)
          {
-            mat->AddSubMatrix(vdofs, vdofs, *elmat_p, skip_zeros);
+            mat->AddSubMatrix(vdofs, vdofs, elmat, skip_zeros);
             if (hybridization)
             {
-               hybridization->AssembleBdrMatrix(i, *elmat_p);
+               hybridization->AssembleBdrMatrix(i, elmat);
             }
          }
          else
          {
-            static_cond->AssembleBdrMatrix(i, *elmat_p);
+            static_cond->AssembleBdrMatrix(i, elmat);
          }
       }
    }
@@ -558,19 +455,18 @@ void BilinearForm::Assemble(int skip_zeros)
       int nfaces = mesh->GetNumFaces();
       for (int i = 0; i < nfaces; i++)
       {
-         tr = mesh -> GetInteriorFaceTransformations (i);
+         tr = mesh->GetInteriorFaceTransformations(i);
          if (tr != NULL)
          {
-            fes -> GetElementVDofs (tr -> Elem1No, vdofs);
-            fes -> GetElementVDofs (tr -> Elem2No, vdofs2);
-            vdofs.Append (vdofs2);
+            fes->GetElementVDofs(tr->Elem1No, vdofs);
+            fes->GetElementVDofs(tr->Elem2No, vdofs2);
+            vdofs.Append(vdofs2);
             for (int k = 0; k < interior_face_integs.Size(); k++)
             {
-               interior_face_integs[k]->
-               AssembleFaceMatrix(*fes->GetFE(tr->Elem1No),
-                                  *fes->GetFE(tr->Elem2No),
-                                  *tr, elemmat);
-               mat -> AddSubMatrix (vdofs, vdofs, elemmat, skip_zeros);
+               interior_face_integs[k]->AssembleFaceMatrix(*fes->GetFE(tr->Elem1No),
+                                                           *fes->GetFE(tr->Elem2No),
+                                                           *tr, elemmat);
+               mat->AddSubMatrix(vdofs, vdofs, elemmat, skip_zeros);
             }
          }
       }
@@ -602,16 +498,16 @@ void BilinearForm::Assemble(int skip_zeros)
          }
       }
 
-      for (int i = 0; i < fes -> GetNBE(); i++)
+      for (int i = 0; i < fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
 
-         tr = mesh -> GetBdrFaceTransformations (i);
+         tr = mesh->GetBdrFaceTransformations(i);
          if (tr != NULL)
          {
-            fes -> GetElementVDofs (tr -> Elem1No, vdofs);
-            fe1 = fes -> GetFE (tr -> Elem1No);
+            fes->GetElementVDofs(tr->Elem1No, vdofs);
+            fe1 = fes->GetFE(tr->Elem1No);
             // The fe2 object is really a dummy and not used on the boundaries,
             // but we can't dereference a NULL pointer, and we don't want to
             // actually make a fake element.
@@ -622,20 +518,13 @@ void BilinearForm::Assemble(int skip_zeros)
                    (*boundary_face_integs_marker[k])[bdr_attr-1] == 0)
                { continue; }
 
-               boundary_face_integs[k] -> AssembleFaceMatrix (*fe1, *fe2, *tr,
-                                                              elemmat);
-               mat -> AddSubMatrix (vdofs, vdofs, elemmat, skip_zeros);
+               boundary_face_integs[k]->AssembleFaceMatrix(*fe1, *fe2, *tr,
+                                                           elemmat);
+               mat->AddSubMatrix(vdofs, vdofs, elemmat, skip_zeros);
             }
          }
       }
    }
-
-#ifdef MFEM_USE_LEGACY_OPENMP
-   if (free_element_matrices)
-   {
-      FreeElementMatrices();
-   }
-#endif
 }
 
 void BilinearForm::ConformingAssemble()
@@ -644,8 +533,9 @@ void BilinearForm::ConformingAssemble()
    // matrix which in turn will give rise to symmetric structure in the new
    // matrix. This ensures that subsequent calls to EliminateRowCol will work
    // correctly.
-   Finalize(0);
    MFEM_ASSERT(mat, "the BilinearForm is not assembled");
+   const int remove_zeros = 0;
+   Finalize(remove_zeros);
 
    const SparseMatrix *P = fes->GetConformingProlongation();
    if (!P) { return; } // conforming mesh
@@ -693,7 +583,6 @@ void BilinearForm::AssembleDiagonal(Vector &diag) const
       return;
    }
    // Here, we have extension, ext, and conforming prolongation, cP.
-
    // For an AMR mesh, a convergent diagonal is assembled with |P^T| d_l,
    // where |P^T| has the entry-wise absolute values of the conforming
    // prolongation transpose operator.
@@ -708,12 +597,26 @@ void BilinearForm::FormLinearSystem(const Array<int> &ess_tdof_list, Vector &x,
 {
    if (ext)
    {
-      ext->FormLinearSystem(ess_tdof_list, x, b, A, X, B, copy_interior);
+      Operator *oper;
+      ext->FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         delete oper;
+         FormSystemMatrix(ess_tdof_list, A);
+      }
+      else
+      {
+         A.Reset(oper);
+      }
       return;
    }
-   const SparseMatrix *P = fes->GetConformingProlongation();
+
+   // Finish the matrix assembly and perform BC elimination, storing the
+   // eliminated part of the matrix.
    FormSystemMatrix(ess_tdof_list, A);
 
+   const SparseMatrix *P = fes->GetConformingProlongation();
+
    // Transform the system and perform the elimination in B, based on the
    // essential BC values from x. Restrict the BC part of x in X, and set the
    // non-BC part to zero. Since there is no good initial guess for the Lagrange
@@ -776,7 +679,23 @@ void BilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
 {
    if (ext)
    {
-      ext->FormSystemMatrix(ess_tdof_list, A);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         // Always does `DIAG_ONE` policy to be consistent with
+         // `Operator::FormConstrainedSystemOperator`.
+         MFEM_VERIFY(diag_policy == DiagonalPolicy::DIAG_ONE,
+                     "Only DiagonalPolicy::DIAG_ONE supported with"
+                     " FABilinearFormExtension.");
+         ConformingAssemble();
+         mat->EliminateBC(ess_tdof_list, DiagonalPolicy::DIAG_ONE);
+         A.Reset(mat, false);
+      }
+      else
+      {
+         Operator *oper;
+         ext->FormSystemOperator(ess_tdof_list, oper);
+         A.Reset(oper);
+      }
       return;
    }
 
@@ -797,8 +716,7 @@ void BilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
    {
       if (!mat_e)
       {
-         const SparseMatrix *P = fes->GetConformingProlongation();
-         if (P) { ConformingAssemble(); }
+         ConformingAssemble();
          EliminateVDofs(ess_tdof_list, diag_policy);
          const int remove_zeros = 0;
          Finalize(remove_zeros);
@@ -872,48 +790,6 @@ void BilinearForm::RecoverFEMSolution(const Vector &X,
    }
 }
 
-void BilinearForm::ComputeElementMatrices()
-{
-   if (element_matrices || domain_integs.Size() == 0 || fes->GetNE() == 0)
-   {
-      return;
-   }
-
-   int num_elements = fes->GetNE();
-   int num_dofs_per_el = fes->GetFE(0)->GetDof() * fes->GetVDim();
-
-   element_matrices = new DenseTensor(num_dofs_per_el, num_dofs_per_el,
-                                      num_elements);
-
-   DenseMatrix tmp;
-   IsoparametricTransformation eltrans;
-
-#ifdef MFEM_USE_LEGACY_OPENMP
-   #pragma omp parallel for private(tmp,eltrans)
-#endif
-   for (int i = 0; i < num_elements; i++)
-   {
-      DenseMatrix elmat(element_matrices->GetData(i),
-                        num_dofs_per_el, num_dofs_per_el);
-      const FiniteElement &fe = *fes->GetFE(i);
-#ifdef MFEM_DEBUG
-      if (num_dofs_per_el != fe.GetDof()*fes->GetVDim())
-         mfem_error("BilinearForm::ComputeElementMatrices:"
-                    " all elements must have same number of dofs");
-#endif
-      fes->GetElementTransformation(i, &eltrans);
-
-      domain_integs[0]->AssembleElementMatrix(fe, eltrans, elmat);
-      for (int k = 1; k < domain_integs.Size(); k++)
-      {
-         // note: some integrators may not be thread-safe
-         domain_integs[k]->AssembleElementMatrix(fe, eltrans, tmp);
-         elmat += tmp;
-      }
-      elmat.ClearExternalData();
-   }
-}
-
 void BilinearForm::EliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
                                         const Vector &sol, Vector &rhs,
                                         DiagonalPolicy dpolicy)
@@ -949,8 +825,8 @@ void BilinearForm::EliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
    }
 }
 
-void BilinearForm::EliminateEssentialBCDiag (const Array<int> &bdr_attr_is_ess,
-                                             double value)
+void BilinearForm::EliminateEssentialBCDiag(const Array<int> &bdr_attr_is_ess,
+                                            double value)
 {
    Array<int> ess_dofs, conf_ess_dofs;
    fes->GetEssentialVDofs(bdr_attr_is_ess, ess_dofs);
@@ -976,11 +852,11 @@ void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
       int vdof = vdofs_[i];
       if ( vdof >= 0 )
       {
-         mat -> EliminateRowCol (vdof, sol(vdof), rhs, dpolicy);
+         mat->EliminateRowCol(vdof, sol(vdof), rhs, dpolicy);
       }
       else
       {
-         mat -> EliminateRowCol (-1-vdof, sol(-1-vdof), rhs, dpolicy);
+         mat->EliminateRowCol(-1-vdof, sol(-1-vdof), rhs, dpolicy);
       }
    }
 }
@@ -999,11 +875,11 @@ void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
       int vdof = vdofs_[i];
       if ( vdof >= 0 )
       {
-         mat -> EliminateRowCol (vdof, *mat_e, dpolicy);
+         mat->EliminateRowCol(vdof, *mat_e, dpolicy);
       }
       else
       {
-         mat -> EliminateRowCol (-1-vdof, *mat_e, dpolicy);
+         mat->EliminateRowCol(-1-vdof, *mat_e, dpolicy);
       }
    }
 }
@@ -1019,31 +895,31 @@ void BilinearForm::EliminateEssentialBCFromDofs(
    for (int i = 0; i < ess_dofs.Size(); i++)
       if (ess_dofs[i] < 0)
       {
-         mat -> EliminateRowCol (i, sol(i), rhs, dpolicy);
+         mat->EliminateRowCol(i, sol(i), rhs, dpolicy);
       }
 }
 
-void BilinearForm::EliminateEssentialBCFromDofs (const Array<int> &ess_dofs,
-                                                 DiagonalPolicy dpolicy)
+void BilinearForm::EliminateEssentialBCFromDofs(const Array<int> &ess_dofs,
+                                                DiagonalPolicy dpolicy)
 {
    MFEM_ASSERT(ess_dofs.Size() == height, "incorrect dof Array size");
 
    for (int i = 0; i < ess_dofs.Size(); i++)
       if (ess_dofs[i] < 0)
       {
-         mat -> EliminateRowCol (i, dpolicy);
+         mat->EliminateRowCol(i, dpolicy);
       }
 }
 
-void BilinearForm::EliminateEssentialBCFromDofsDiag (const Array<int> &ess_dofs,
-                                                     double value)
+void BilinearForm::EliminateEssentialBCFromDofsDiag(const Array<int> &ess_dofs,
+                                                    double value)
 {
    MFEM_ASSERT(ess_dofs.Size() == height, "incorrect dof Array size");
 
    for (int i = 0; i < ess_dofs.Size(); i++)
       if (ess_dofs[i] < 0)
       {
-         mat -> EliminateRowColDiag (i, value);
+         mat->EliminateRowColDiag(i, value);
       }
 }
 
@@ -1054,31 +930,6 @@ void BilinearForm::EliminateVDofsInRHS(
    mat->PartMult(vdofs_, x, b);
 }
 
-void BilinearForm::Mult(const Vector &x, Vector &y) const
-{
-   if (ext)
-   {
-      ext->Mult(x, y);
-   }
-   else
-   {
-      mat->Mult(x, y);
-   }
-}
-
-void BilinearForm::MultTranspose(const Vector & x, Vector & y) const
-{
-   if (ext)
-   {
-      ext->MultTranspose(x, y);
-   }
-   else
-   {
-      y = 0.0;
-      AddMultTranspose (x, y);
-   }
-}
-
 void BilinearForm::Update(FiniteElementSpace *nfes)
 {
    bool full_update;
@@ -1098,7 +949,6 @@ void BilinearForm::Update(FiniteElementSpace *nfes)
 
    delete mat_e;
    mat_e = NULL;
-   FreeElementMatrices();
    delete static_cond;
    static_cond = NULL;
 
@@ -1121,16 +971,10 @@ void BilinearForm::Update(FiniteElementSpace *nfes)
    if (ext) { ext->Update(); }
 }
 
-void BilinearForm::SetDiagonalPolicy(DiagonalPolicy policy)
-{
-   diag_policy = policy;
-}
-
 BilinearForm::~BilinearForm()
 {
    delete mat_e;
    delete mat;
-   delete element_matrices;
    delete static_cond;
    delete hybridization;
 
@@ -1148,9 +992,8 @@ BilinearForm::~BilinearForm()
    delete ext;
 }
 
-
-MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
-                                      FiniteElementSpace *te_fes)
+MixedBilinearForm::MixedBilinearForm(FiniteElementSpace *tr_fes,
+                                     FiniteElementSpace *te_fes)
    : Matrix(te_fes->GetVSize(), tr_fes->GetVSize())
 {
    trial_fes = tr_fes;
@@ -1162,9 +1005,9 @@ MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
    ext = NULL;
 }
 
-MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
-                                      FiniteElementSpace *te_fes,
-                                      MixedBilinearForm * mbf)
+MixedBilinearForm::MixedBilinearForm(FiniteElementSpace *tr_fes,
+                                     FiniteElementSpace *te_fes,
+                                     MixedBilinearForm *mbf)
    : Matrix(te_fes->GetVSize(), tr_fes->GetVSize())
 {
    trial_fes = tr_fes;
@@ -1173,6 +1016,8 @@ MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
    mat_e = NULL;
    extern_bfs = 1;
    ext = NULL;
+   assembly = AssemblyLevel::LEGACY;
+   ext = NULL;
 
    // Copy the pointers to the integrators
    domain_integs = mbf->domain_integs;
@@ -1182,9 +1027,6 @@ MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
 
    boundary_integs_marker = mbf->boundary_integs_marker;
    boundary_trace_face_integs_marker = mbf->boundary_trace_face_integs_marker;
-
-   assembly = AssemblyLevel::LEGACY;
-   ext = NULL;
 }
 
 void MixedBilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
@@ -1210,31 +1052,36 @@ void MixedBilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
          ext = new PAMixedBilinearFormExtension(this);
          break;
       case AssemblyLevel::NONE:
-         mfem_error("Matrix-free action not supported yet... stay tuned!");
-         // ext = new MFMixedBilinearFormExtension(this);
+         ext = new MFMixedBilinearFormExtension(this);
          break;
       default:
          mfem_error("Unknown assembly level");
    }
 }
 
-double & MixedBilinearForm::Elem (int i, int j)
+double &MixedBilinearForm::Elem(int i, int j)
 {
    return (*mat)(i, j);
 }
 
-const double & MixedBilinearForm::Elem (int i, int j) const
+const double &MixedBilinearForm::Elem(int i, int j) const
 {
    return (*mat)(i, j);
 }
 
-void MixedBilinearForm::Mult(const Vector & x, Vector & y) const
+void MixedBilinearForm::Mult(const Vector &x, Vector &y) const
 {
-   y = 0.0;
-   AddMult(x, y);
+   if (ext)
+   {
+      ext->Mult(x, y);
+   }
+   else
+   {
+      mat->Mult(x, y);
+   }
 }
 
-void MixedBilinearForm::AddMult(const Vector & x, Vector & y,
+void MixedBilinearForm::AddMult(const Vector &x, Vector &y,
                                 const double a) const
 {
    if (ext)
@@ -1247,13 +1094,19 @@ void MixedBilinearForm::AddMult(const Vector & x, Vector & y,
    }
 }
 
-void MixedBilinearForm::MultTranspose(const Vector & x, Vector & y) const
+void MixedBilinearForm::MultTranspose(const Vector &x, Vector &y) const
 {
-   y = 0.0;
-   AddMultTranspose(x, y);
+   if (ext)
+   {
+      ext->MultTranspose(x, y);
+   }
+   else
+   {
+      mat->MultTranspose(x, y);
+   }
 }
 
-void MixedBilinearForm::AddMultTranspose(const Vector & x, Vector & y,
+void MixedBilinearForm::AddMultTranspose(const Vector &x, Vector &y,
                                          const double a) const
 {
    if (ext)
@@ -1266,7 +1119,7 @@ void MixedBilinearForm::AddMultTranspose(const Vector & x, Vector & y,
    }
 }
 
-MatrixInverse * MixedBilinearForm::Inverse() const
+MatrixInverse *MixedBilinearForm::Inverse() const
 {
    if (assembly != AssemblyLevel::LEGACY)
    {
@@ -1276,15 +1129,15 @@ MatrixInverse * MixedBilinearForm::Inverse() const
    }
    else
    {
-      return mat -> Inverse ();
+      return mat->Inverse();
    }
 }
 
-void MixedBilinearForm::Finalize (int skip_zeros)
+void MixedBilinearForm::Finalize(int skip_zeros)
 {
    if (assembly == AssemblyLevel::LEGACY)
    {
-      mat -> Finalize (skip_zeros);
+      mat->Finalize(skip_zeros);
    }
 }
 
@@ -1300,27 +1153,27 @@ void MixedBilinearForm::GetBlocks(Array2D<SparseMatrix *> &blocks) const
    mat->GetBlocks(blocks);
 }
 
-void MixedBilinearForm::AddDomainIntegrator (BilinearFormIntegrator * bfi)
+void MixedBilinearForm::AddDomainIntegrator(BilinearFormIntegrator *bfi)
 {
-   domain_integs.Append (bfi);
+   domain_integs.Append(bfi);
 }
 
-void MixedBilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi)
+void MixedBilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(NULL); // NULL marker means apply everywhere
 }
 
-void MixedBilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi,
-                                               Array<int> &bdr_marker)
+void MixedBilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi,
+                                              Array<int> &bdr_marker)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(&bdr_marker);
 }
 
-void MixedBilinearForm::AddTraceFaceIntegrator (BilinearFormIntegrator * bfi)
+void MixedBilinearForm::AddTraceFaceIntegrator(BilinearFormIntegrator *bfi)
 {
-   trace_face_integs.Append (bfi);
+   trace_face_integs.Append(bfi);
 }
 
 void MixedBilinearForm::AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi)
@@ -1337,7 +1190,45 @@ void MixedBilinearForm::AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi,
    boundary_trace_face_integs_marker.Append(&bdr_marker);
 }
 
-void MixedBilinearForm::Assemble (int skip_zeros)
+void MixedBilinearForm::AssembleElementMatrix(
+   int i, const DenseMatrix &elmat, int skip_zeros)
+{
+   AssembleElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
+}
+
+void MixedBilinearForm::AssembleElementMatrix(
+   int i, const DenseMatrix &elmat, Array<int> &trial_vdofs_,
+   Array<int> &test_vdofs_, int skip_zeros)
+{
+   trial_fes->GetElementVDofs(i, trial_vdofs_);
+   test_fes->GetElementVDofs(i, test_vdofs_);
+   if (mat == NULL)
+   {
+      mat = new SparseMatrix(height, width);
+   }
+   mat->AddSubMatrix(test_vdofs_, trial_vdofs_, elmat, skip_zeros);
+}
+
+void MixedBilinearForm::AssembleBdrElementMatrix(
+   int i, const DenseMatrix &elmat, int skip_zeros)
+{
+   AssembleBdrElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
+}
+
+void MixedBilinearForm::AssembleBdrElementMatrix(
+   int i, const DenseMatrix &elmat, Array<int> &trial_vdofs_,
+   Array<int> &test_vdofs_, int skip_zeros)
+{
+   trial_fes->GetBdrElementVDofs(i, trial_vdofs_);
+   test_fes->GetBdrElementVDofs(i, test_vdofs_);
+   if (mat == NULL)
+   {
+      mat = new SparseMatrix(height, width);
+   }
+   mat->AddSubMatrix(test_vdofs_, trial_vdofs_, elmat, skip_zeros);
+}
+
+void MixedBilinearForm::Assemble(int skip_zeros)
 {
    if (ext)
    {
@@ -1346,12 +1237,11 @@ void MixedBilinearForm::Assemble (int skip_zeros)
    }
 
    ElementTransformation *eltrans;
-   DofTransformation * dom_dof_trans;
-   DofTransformation * ran_dof_trans;
+   DofTransformation *dom_dof_trans;
+   DofTransformation *ran_dof_trans;
+   Mesh *mesh = test_fes->GetMesh();
    DenseMatrix elmat;
 
-   Mesh *mesh = test_fes -> GetMesh();
-
    if (mat == NULL)
    {
       mat = new SparseMatrix(height, width);
@@ -1359,26 +1249,26 @@ void MixedBilinearForm::Assemble (int skip_zeros)
 
    if (domain_integs.Size())
    {
-      for (int i = 0; i < test_fes -> GetNE(); i++)
+      for (int i = 0; i < test_fes->GetNE(); i++)
       {
-         dom_dof_trans = trial_fes -> GetElementVDofs (i, trial_vdofs);
-         ran_dof_trans = test_fes  -> GetElementVDofs (i, test_vdofs);
-         eltrans = test_fes -> GetElementTransformation (i);
+         dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
+         ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
+         eltrans = test_fes->GetElementTransformation(i);
 
          elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
          elmat = 0.0;
          for (int k = 0; k < domain_integs.Size(); k++)
          {
-            domain_integs[k] -> AssembleElementMatrix2 (*trial_fes -> GetFE(i),
-                                                        *test_fes  -> GetFE(i),
-                                                        *eltrans, elemmat);
+            domain_integs[k]->AssembleElementMatrix2(*trial_fes->GetFE(i),
+                                                     *test_fes->GetFE(i),
+                                                     *eltrans, elemmat);
             elmat += elemmat;
          }
          if (ran_dof_trans || dom_dof_trans)
          {
             TransformDual(ran_dof_trans, dom_dof_trans, elmat);
          }
-         mat -> AddSubMatrix (test_vdofs, trial_vdofs, elmat, skip_zeros);
+         mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 
@@ -1405,14 +1295,14 @@ void MixedBilinearForm::Assemble (int skip_zeros)
          }
       }
 
-      for (int i = 0; i < test_fes -> GetNBE(); i++)
+      for (int i = 0; i < test_fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
 
-         dom_dof_trans = trial_fes -> GetBdrElementVDofs (i, trial_vdofs);
-         ran_dof_trans = test_fes  -> GetBdrElementVDofs (i, test_vdofs);
-         eltrans = test_fes -> GetBdrElementTransformation (i);
+         dom_dof_trans = trial_fes->GetBdrElementVDofs(i, trial_vdofs);
+         ran_dof_trans = test_fes->GetBdrElementVDofs(i, test_vdofs);
+         eltrans = test_fes->GetBdrElementTransformation(i);
 
          elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
          elmat = 0.0;
@@ -1421,16 +1311,16 @@ void MixedBilinearForm::Assemble (int skip_zeros)
             if (boundary_integs_marker[k] &&
                 (*boundary_integs_marker[k])[bdr_attr-1] == 0) { continue; }
 
-            boundary_integs[k]->AssembleElementMatrix2 (*trial_fes -> GetBE(i),
-                                                        *test_fes  -> GetBE(i),
-                                                        *eltrans, elemmat);
+            boundary_integs[k]->AssembleElementMatrix2(*trial_fes->GetBE(i),
+                                                       *test_fes->GetBE(i),
+                                                       *eltrans, elemmat);
             elmat += elemmat;
          }
          if (ran_dof_trans || dom_dof_trans)
          {
             TransformDual(ran_dof_trans, dom_dof_trans, elmat);
          }
-         mat -> AddSubMatrix (test_vdofs, trial_vdofs, elmat, skip_zeros);
+         mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 
@@ -1497,7 +1387,7 @@ void MixedBilinearForm::Assemble (int skip_zeros)
          }
       }
 
-      for (int i = 0; i < trial_fes -> GetNBE(); i++)
+      for (int i = 0; i < trial_fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
@@ -1530,6 +1420,37 @@ void MixedBilinearForm::Assemble (int skip_zeros)
    }
 }
 
+void MixedBilinearForm::ConformingAssemble()
+{
+   if (assembly != AssemblyLevel::LEGACY)
+   {
+      MFEM_WARNING("Conforming assemble not supported for this assembly level!");
+      return;
+   }
+
+   const int remove_zeros = 0;
+   Finalize(remove_zeros);
+
+   const SparseMatrix *test_P = test_fes->GetConformingProlongation();
+   if (test_P)
+   {
+      SparseMatrix *RA = mfem::TransposeMult(*test_P, *mat);
+      delete mat;
+      mat = RA;
+   }
+
+   const SparseMatrix *trial_P = trial_fes->GetConformingProlongation();
+   if (trial_P)
+   {
+      SparseMatrix *RAP = mfem::Mult(*mat, *trial_P);
+      delete mat;
+      mat = RAP;
+   }
+
+   height = mat->Height();
+   width = mat->Width();
+}
+
 void MixedBilinearForm::AssembleDiagonal_ADAt(const Vector &D,
                                               Vector &diag) const
 {
@@ -1578,259 +1499,119 @@ void MixedBilinearForm::AssembleDiagonal_ADAt(const Vector &D,
    }
 }
 
-void MixedBilinearForm::ConformingAssemble()
+void MixedBilinearForm::FormRectangularLinearSystem(
+   const Array<int> &trial_tdof_list,
+   const Array<int> &test_tdof_list,
+   Vector &x, Vector &b,
+   OperatorHandle &A,
+   Vector &X, Vector &B)
 {
-   if (assembly != AssemblyLevel::LEGACY)
+   if (ext)
    {
-      MFEM_WARNING("Conforming assemble not supported for this assembly level!");
+      Operator *oper;
+      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
+                                       x, b, oper, X, B);
+      A.Reset(oper);
       return;
    }
 
-   Finalize();
-
-   const SparseMatrix *P2 = test_fes->GetConformingProlongation();
-   if (P2)
-   {
-      SparseMatrix *R = Transpose(*P2);
-      SparseMatrix *RA = mfem::Mult(*R, *mat);
-      delete R;
-      delete mat;
-      mat = RA;
-   }
+   const Operator *Pi = this->GetProlongation();
+   const Operator *Po = this->GetOutputProlongation();
+   const Operator *Ri = this->GetRestriction();
+   InitTVectors(Po, Ri, Pi, x, b, X, B);
 
-   const SparseMatrix *P1 = trial_fes->GetConformingProlongation();
-   if (P1)
+   if (!mat_e)
    {
-      SparseMatrix *RAP = mfem::Mult(*mat, *P1);
-      delete mat;
-      mat = RAP;
+      // Set A = mat_e
+      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, A);
    }
+   // Eliminate essential BCs with B -= Ab xb
+   mat_e->AddMult(X, B, -1.0);
 
-   height = mat->Height();
-   width = mat->Width();
-}
-
-
-void MixedBilinearForm::ComputeElementMatrix(int i, DenseMatrix &elmat)
-{
-   if (domain_integs.Size())
-   {
-      const FiniteElement &trial_fe = *trial_fes->GetFE(i);
-      const FiniteElement &test_fe = *test_fes->GetFE(i);
-      ElementTransformation *eltrans = test_fes->GetElementTransformation(i);
-      domain_integs[0]->AssembleElementMatrix2(trial_fe, test_fe, *eltrans,
-                                               elmat);
-      for (int k = 1; k < domain_integs.Size(); k++)
-      {
-         domain_integs[k]->AssembleElementMatrix2(trial_fe, test_fe, *eltrans,
-                                                  elemmat);
-         elmat += elemmat;
-      }
-   }
-   else
-   {
-      trial_fes->GetElementVDofs(i, trial_vdofs);
-      test_fes->GetElementVDofs(i, test_vdofs);
-      elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
-      elmat = 0.0;
-   }
+   B.SetSubVector(test_tdof_list, 0.0);
 }
 
-void MixedBilinearForm::ComputeBdrElementMatrix(int i, DenseMatrix &elmat)
+void MixedBilinearForm::FormRectangularSystemMatrix(
+   const Array<int> &trial_tdof_list,
+   const Array<int> &test_tdof_list,
+   OperatorHandle &A)
 {
-   if (boundary_integs.Size())
-   {
-      const FiniteElement &trial_be = *trial_fes->GetBE(i);
-      const FiniteElement &test_be = *test_fes->GetBE(i);
-      ElementTransformation *eltrans = test_fes->GetBdrElementTransformation(i);
-      boundary_integs[0]->AssembleElementMatrix2(trial_be, test_be, *eltrans,
-                                                 elmat);
-      for (int k = 1; k < boundary_integs.Size(); k++)
-      {
-         boundary_integs[k]->AssembleElementMatrix2(trial_be, test_be, *eltrans,
-                                                    elemmat);
-         elmat += elemmat;
-      }
-   }
-   else
+   if (ext)
    {
-      trial_fes->GetBdrElementVDofs(i, trial_vdofs);
-      test_fes->GetBdrElementVDofs(i, test_vdofs);
-      elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
-      elmat = 0.0;
+      Operator *oper;
+      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, oper);
+      A.Reset(oper);
+      return;
    }
-}
 
-void MixedBilinearForm::AssembleElementMatrix(
-   int i, const DenseMatrix &elmat, int skip_zeros)
-{
-   AssembleElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
-}
+   ConformingAssemble();
 
-void MixedBilinearForm::AssembleElementMatrix(
-   int i, const DenseMatrix &elmat, Array<int> &trial_vdofs_,
-   Array<int> &test_vdofs_, int skip_zeros)
-{
-   trial_fes->GetElementVDofs(i, trial_vdofs_);
-   test_fes->GetElementVDofs(i, test_vdofs_);
-   if (mat == NULL)
-   {
-      mat = new SparseMatrix(height, width);
-   }
-   mat->AddSubMatrix(test_vdofs_, trial_vdofs_, elmat, skip_zeros);
-}
+   Array<int> ess_trial_tdof_marker, ess_test_tdof_marker;
+   FiniteElementSpace::ListToMarker(trial_tdof_list, trial_fes->GetTrueVSize(),
+                                    ess_trial_tdof_marker);
+   FiniteElementSpace::ListToMarker(test_tdof_list, test_fes->GetTrueVSize(),
+                                    ess_test_tdof_marker);
 
-void MixedBilinearForm::AssembleBdrElementMatrix(
-   int i, const DenseMatrix &elmat, int skip_zeros)
-{
-   AssembleBdrElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
-}
+   mat_e = new SparseMatrix(mat->Height(), mat->Width());
+   mat->EliminateCols(ess_trial_tdof_marker, *mat_e);
 
-void MixedBilinearForm::AssembleBdrElementMatrix(
-   int i, const DenseMatrix &elmat, Array<int> &trial_vdofs_,
-   Array<int> &test_vdofs_, int skip_zeros)
-{
-   trial_fes->GetBdrElementVDofs(i, trial_vdofs_);
-   test_fes->GetBdrElementVDofs(i, test_vdofs_);
-   if (mat == NULL)
+   for (int i = 0; i < test_tdof_list.Size(); i++)
    {
-      mat = new SparseMatrix(height, width);
+      mat->EliminateRow(test_tdof_list[i]);
    }
-   mat->AddSubMatrix(test_vdofs_, trial_vdofs_, elmat, skip_zeros);
+   mat_e->Finalize();
+   A.Reset(mat, false);
 }
 
-void MixedBilinearForm::EliminateTrialDofs (
+void MixedBilinearForm::EliminateTrialDofs(
    const Array<int> &bdr_attr_is_ess, const Vector &sol, Vector &rhs )
 {
    int i, j, k;
-   Array<int> tr_vdofs, cols_marker (trial_fes -> GetVSize());
+   Array<int> tr_vdofs, cols_marker(trial_fes->GetVSize());
 
    cols_marker = 0;
-   for (i = 0; i < trial_fes -> GetNBE(); i++)
-      if (bdr_attr_is_ess[trial_fes -> GetBdrAttribute (i)-1])
+   for (i = 0; i < trial_fes->GetNBE(); i++)
+      if (bdr_attr_is_ess[trial_fes->GetBdrAttribute(i)-1])
       {
-         trial_fes -> GetBdrElementVDofs (i, tr_vdofs);
+         trial_fes->GetBdrElementVDofs(i, tr_vdofs);
          for (j = 0; j < tr_vdofs.Size(); j++)
          {
-            if ( (k = tr_vdofs[j]) < 0 )
+            if ((k = tr_vdofs[j]) < 0)
             {
                k = -1-k;
             }
             cols_marker[k] = 1;
          }
       }
-   mat -> EliminateCols (cols_marker, &sol, &rhs);
+   mat->EliminateCols(cols_marker, &sol, &rhs);
 }
 
-void MixedBilinearForm::EliminateEssentialBCFromTrialDofs (
+void MixedBilinearForm::EliminateEssentialBCFromTrialDofs(
    const Array<int> &marked_vdofs, const Vector &sol, Vector &rhs)
 {
-   mat -> EliminateCols (marked_vdofs, &sol, &rhs);
+   mat->EliminateCols(marked_vdofs, &sol, &rhs);
 }
 
-void MixedBilinearForm::EliminateTestDofs (const Array<int> &bdr_attr_is_ess)
+void MixedBilinearForm::EliminateTestDofs(const Array<int> &bdr_attr_is_ess)
 {
    int i, j, k;
    Array<int> te_vdofs;
 
-   for (i = 0; i < test_fes -> GetNBE(); i++)
-      if (bdr_attr_is_ess[test_fes -> GetBdrAttribute (i)-1])
+   for (i = 0; i < test_fes->GetNBE(); i++)
+      if (bdr_attr_is_ess[test_fes->GetBdrAttribute(i)-1])
       {
-         test_fes -> GetBdrElementVDofs (i, te_vdofs);
+         test_fes->GetBdrElementVDofs(i, te_vdofs);
          for (j = 0; j < te_vdofs.Size(); j++)
          {
-            if ( (k = te_vdofs[j]) < 0 )
+            if ((k = te_vdofs[j]) < 0)
             {
                k = -1-k;
             }
-            mat -> EliminateRow (k);
+            mat->EliminateRow(k);
          }
       }
 }
 
-void MixedBilinearForm::FormRectangularSystemMatrix(
-   const Array<int> &trial_tdof_list,
-   const Array<int> &test_tdof_list,
-   OperatorHandle &A)
-
-{
-   if (ext)
-   {
-      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, A);
-      return;
-   }
-
-   const SparseMatrix *test_P = test_fes->GetConformingProlongation();
-   const SparseMatrix *trial_P = trial_fes->GetConformingProlongation();
-
-   mat->Finalize();
-
-   if (test_P && trial_P)
-   {
-      SparseMatrix *m = RAP(*test_P, *mat, *trial_P);
-      delete mat;
-      mat = m;
-   }
-   else if (test_P)
-   {
-      SparseMatrix *m = TransposeMult(*test_P, *mat);
-      delete mat;
-      mat = m;
-   }
-   else if (trial_P)
-   {
-      SparseMatrix *m = mfem::Mult(*mat, *trial_P);
-      delete mat;
-      mat = m;
-   }
-
-   Array<int> ess_trial_tdof_marker, ess_test_tdof_marker;
-   FiniteElementSpace::ListToMarker(trial_tdof_list, trial_fes->GetTrueVSize(),
-                                    ess_trial_tdof_marker);
-   FiniteElementSpace::ListToMarker(test_tdof_list, test_fes->GetTrueVSize(),
-                                    ess_test_tdof_marker);
-
-   mat_e = new SparseMatrix(mat->Height(), mat->Width());
-   mat->EliminateCols(ess_trial_tdof_marker, *mat_e);
-
-   for (int i=0; i<test_tdof_list.Size(); ++i)
-   {
-      mat->EliminateRow(test_tdof_list[i]);
-   }
-   mat_e->Finalize();
-   A.Reset(mat, false);
-}
-
-void MixedBilinearForm::FormRectangularLinearSystem(
-   const Array<int> &trial_tdof_list,
-   const Array<int> &test_tdof_list,
-   Vector &x, Vector &b,
-   OperatorHandle &A,
-   Vector &X, Vector &B)
-{
-   if (ext)
-   {
-      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
-                                       x, b, A, X, B);
-      return;
-   }
-
-   const Operator *Pi = this->GetProlongation();
-   const Operator *Po = this->GetOutputProlongation();
-   const Operator *Ri = this->GetRestriction();
-   InitTVectors(Po, Ri, Pi, x, b, X, B);
-
-   if (!mat_e)
-   {
-      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list,
-                                  A); // Set A = mat_e
-   }
-   // Eliminate essential BCs with B -= Ab xb
-   mat_e->AddMult(X, B, -1.0);
-
-   B.SetSubVector(test_tdof_list, 0.0);
-}
-
 void MixedBilinearForm::Update()
 {
    delete mat;
@@ -1895,66 +1676,97 @@ void DiscreteLinearOperator::Assemble(int skip_zeros)
       return;
    }
 
-   Array<int> dom_vdofs, ran_vdofs;
-   ElementTransformation *T;
-   DofTransformation * dom_dof_trans;
-   DofTransformation * ran_dof_trans;
-   const FiniteElement *dom_fe, *ran_fe;
-   DenseMatrix totelmat, elmat;
+   ElementTransformation *eltrans;
+   DofTransformation *dom_dof_trans;
+   DofTransformation *ran_dof_trans;
+   Mesh *mesh = test_fes->GetMesh();
+   DenseMatrix elmat;
 
    if (mat == NULL)
    {
       mat = new SparseMatrix(height, width);
    }
 
-   if (domain_integs.Size() > 0)
+   if (domain_integs.Size())
    {
       for (int i = 0; i < test_fes->GetNE(); i++)
       {
-         dom_dof_trans = trial_fes->GetElementVDofs(i, dom_vdofs);
-         ran_dof_trans = test_fes->GetElementVDofs(i, ran_vdofs);
-         T = test_fes->GetElementTransformation(i);
-         dom_fe = trial_fes->GetFE(i);
-         ran_fe = test_fes->GetFE(i);
-
-         domain_integs[0]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                  totelmat);
-         for (int j = 1; j < domain_integs.Size(); j++)
+         dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
+         ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
+         eltrans = test_fes->GetElementTransformation(i);
+
+         elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
+         elmat = 0.0;
+         for (int j = 0; j < domain_integs.Size(); j++)
          {
-            domain_integs[j]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                     elmat);
-            totelmat += elmat;
+            domain_integs[j]->AssembleElementMatrix2(*trial_fes->GetFE(i),
+                                                     *test_fes->GetFE(i),
+                                                     *eltrans, elemmat);
+            elmat += elemmat;
          }
          if (ran_dof_trans || dom_dof_trans)
          {
-            TransformPrimal(ran_dof_trans, dom_dof_trans, totelmat);
+            TransformPrimal(ran_dof_trans, dom_dof_trans, elmat);
          }
-         mat->SetSubMatrix(ran_vdofs, dom_vdofs, totelmat, skip_zeros);
+         mat->SetSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 
    if (trace_face_integs.Size())
    {
-      const int nfaces = test_fes->GetMesh()->GetNumFaces();
+      const int nfaces = mesh->GetNumFaces();
       for (int i = 0; i < nfaces; i++)
       {
-         trial_fes->GetFaceVDofs(i, dom_vdofs);
-         test_fes->GetFaceVDofs(i, ran_vdofs);
-         T = test_fes->GetMesh()->GetFaceTransformation(i);
-         dom_fe = trial_fes->GetFaceElement(i);
-         ran_fe = test_fes->GetFaceElement(i);
-
-         trace_face_integs[0]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                      totelmat);
-         for (int j = 1; j < trace_face_integs.Size(); j++)
+         trial_fes->GetFaceVDofs(i, trial_vdofs);
+         test_fes->GetFaceVDofs(i, test_vdofs);
+         eltrans = mesh->GetFaceTransformation(i);
+
+         elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
+         elmat = 0.0;
+         for (int j = 0; j < trace_face_integs.Size(); j++)
          {
-            trace_face_integs[j]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                         elmat);
-            totelmat += elmat;
+            trace_face_integs[j]->AssembleElementMatrix2(*trial_fes->GetFaceElement(i),
+                                                         *test_fes->GetFaceElement(i),
+                                                         *eltrans, elemmat);
+            elmat += elemmat;
          }
-         mat->SetSubMatrix(ran_vdofs, dom_vdofs, totelmat, skip_zeros);
+         mat->SetSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 }
 
+void DiscreteLinearOperator::FormDiscreteOperatorMatrix(OperatorHandle &A)
+{
+   if (ext)
+   {
+      Operator *oper;
+      ext->FormDiscreteOperator(oper);
+      A.Reset(oper);
+      return;
+   }
+
+   mat->Finalize();
+
+   const SparseMatrix *test_R = test_fes->GetConformingRestriction();
+   if (test_R)
+   {
+      SparseMatrix *RA = mfem::Mult(*test_R, *mat);
+      delete mat;
+      mat = RA;
+   }
+
+   const SparseMatrix *trial_P = trial_fes->GetConformingProlongation();
+   if (trial_P)
+   {
+      SparseMatrix *RAP = mfem::Mult(*mat, *trial_P);
+      delete mat;
+      mat = RAP;
+   }
+
+   height = mat->Height();
+   width = mat->Width();
+
+   A.Reset(mat, false);
+}
+
 }
diff --git a/fem/bilinearform.hpp b/fem/bilinearform.hpp
index b23df9280..b878b8d27 100644
--- a/fem/bilinearform.hpp
+++ b/fem/bilinearform.hpp
@@ -36,8 +36,6 @@ enum class AssemblyLevel
    /// is fully evaluated on the fly.
    /// This assembly level is ALWAYS performed on the host.
    LEGACY = 0,
-   /// @deprecated Use LEGACY instead.
-   LEGACYFULL = 0,
    /// Fully assembled form, i.e. a global sparse matrix in MFEM format. This
    /// assembly is compatible with device execution.
    FULL,
@@ -66,7 +64,7 @@ protected:
    SparseMatrix *mat;
 
    /** @brief Sparse Matrix \f$ M_e \f$ used to store the eliminations
-        from the b.c.  Owned.
+        from the b.c. Owned.
        \f$ M + M_e = M_{original} \f$ */
    SparseMatrix *mat_e;
 
@@ -75,11 +73,11 @@ protected:
 
    /// The assembly level of the form (full, partial, etc.)
    AssemblyLevel assembly;
-   /// Element batch size used in the form action (1, 8, num_elems, etc.)
-   int batch;
+
    /** @brief Extension for supporting Full Assembly (FA), Element Assembly (EA),
        Partial Assembly (PA), or Matrix Free assembly (MF). */
    BilinearFormExtension *ext;
+
    /** Indicates if the sparse matrix is sorted after assembly when using
        Full Assembly (FA). */
    bool sort_sparse_matrix = false;
@@ -113,11 +111,6 @@ protected:
    Array<BilinearFormIntegrator*> boundary_face_integs;
    Array<Array<int>*> boundary_face_integs_marker; ///< Entries are not owned.
 
-   DenseMatrix elemmat;
-   Array<int>  vdofs;
-
-   DenseTensor *element_matrices; ///< Owned.
-
    StaticCondensation *static_cond; ///< Owned.
    Hybridization *hybridization; ///< Owned.
 
@@ -126,31 +119,29 @@ protected:
        the constrained DoFs. */
    DiagonalPolicy diag_policy;
 
-   int precompute_sparsity;
-   // Allocate appropriate SparseMatrix and assign it to mat
-   void AllocMat();
-
-   void ConformingAssemble();
+   DenseMatrix elemmat;
+   Array<int>  vdofs;
 
    // may be used in the construction of derived classes
-   BilinearForm() : Matrix (0)
+   BilinearForm() : Matrix(0)
    {
-      fes = NULL; sequence = -1;
-      mat = mat_e = NULL; extern_bfs = 0; element_matrices = NULL;
-      static_cond = NULL; hybridization = NULL;
-      precompute_sparsity = 0;
+      fes = NULL;
+      sequence = -1;
+      mat = mat_e = NULL;
+      extern_bfs = 0;
+      static_cond = NULL;
+      hybridization = NULL;
       diag_policy = DIAG_KEEP;
       assembly = AssemblyLevel::LEGACY;
-      batch = 1;
       ext = NULL;
    }
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   BilinearForm(const BilinearForm &);
+   /// Copy construction is not supported.
+   BilinearForm(const BilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   BilinearForm &operator=(const BilinearForm &);
+   /// Copy assignment is not supported.
+   BilinearForm &operator=(const BilinearForm &) = delete;
 
 public:
    /// Creates bilinear form associated with FE space @a *f.
@@ -163,11 +154,8 @@ public:
        The pointer @a f is not owned by the newly constructed object.
 
        The integrators in @a bf are copied as pointers and they are not owned by
-       the newly constructed BilinearForm.
-
-       The optional parameter @a ps is used to initialize the internal flag
-       #precompute_sparsity, see UsePrecomputedSparsity() for details. */
-   BilinearForm(FiniteElementSpace *f, BilinearForm *bf, int ps = 0);
+       the newly constructed BilinearForm. */
+   BilinearForm(FiniteElementSpace *f, BilinearForm *bf);
 
    /// Get the size of the BilinearForm as a square matrix.
    int Size() const { return height; }
@@ -184,6 +172,18 @@ public:
        If used, this method must be called before assembly. */
    void SetAssemblyLevel(AssemblyLevel assembly_level);
 
+   /// Returns the assembly level
+   AssemblyLevel GetAssemblyLevel() const { return assembly; }
+
+   /// Sets diagonal policy used upon construction of the linear system.
+   /** Policies include:
+
+       - DIAG_ZERO (Set the diagonal values to zero)
+       - DIAG_ONE  (Set the diagonal values to one)
+       - DIAG_KEEP (Keep the diagonal values)
+   */
+   void SetDiagonalPolicy(DiagonalPolicy policy) { diag_policy = policy; }
+
    /** @brief Force the sparse matrix column indices to be sorted when using
        AssemblyLevel::FULL.
 
@@ -199,8 +199,16 @@ public:
       sort_sparse_matrix = enable_it;
    }
 
-   /// Returns the assembly level
-   AssemblyLevel GetAssemblyLevel() const { return assembly; }
+   /// Indicate that integrators are not owned by the BilinearForm
+   void UseExternalIntegrators() { extern_bfs = 1; }
+
+   /// Enable hybridization.
+   /** For details see the description for class
+       Hybridization in fem/hybridization.hpp. This method should be called
+       before assembly. */
+   void EnableHybridization(FiniteElementSpace *constr_space,
+                            BilinearFormIntegrator *constr_integ,
+                            const Array<int> &ess_tdof_list);
 
    Hybridization *GetHybridization() const { return hybridization; }
 
@@ -218,60 +226,6 @@ public:
    FiniteElementSpace *SCFESpace() const
    { return static_cond ? static_cond->GetTraceFESpace() : NULL; }
 
-   /// Enable hybridization.
-   /** For details see the description for class
-       Hybridization in fem/hybridization.hpp. This method should be called
-       before assembly. */
-   void EnableHybridization(FiniteElementSpace *constr_space,
-                            BilinearFormIntegrator *constr_integ,
-                            const Array<int> &ess_tdof_list);
-
-   /** @brief For scalar FE spaces, precompute the sparsity pattern of the matrix
-       (assuming dense element matrices) based on the types of integrators
-       present in the bilinear form. */
-   void UsePrecomputedSparsity(int ps = 1) { precompute_sparsity = ps; }
-
-   /** @brief Use the given CSR sparsity pattern to allocate the internal
-       SparseMatrix.
-
-       - The @a I and @a J arrays must define a square graph with size equal to
-         GetVSize() of the associated FiniteElementSpace.
-       - This method should be called after enabling static condensation or
-         hybridization, if used.
-       - In the case of static condensation, @a I and @a J are not used.
-       - The ownership of the arrays @a I and @a J remains with the caller. */
-   void UseSparsity(int *I, int *J, bool isSorted);
-
-   /// Use the sparsity of @a A to allocate the internal SparseMatrix.
-   void UseSparsity(SparseMatrix &A);
-
-   /// Pre-allocate the internal SparseMatrix before assembly.
-   /**  If the flag 'precompute sparsity'
-       is set, the matrix is allocated in CSR format (i.e.
-       finalized) and the entries are initialized with zeros. */
-   void AllocateMatrix() { if (mat == NULL) { AllocMat(); } }
-
-   /// Access all the integrators added with AddDomainIntegrator().
-   Array<BilinearFormIntegrator*> *GetDBFI() { return &domain_integs; }
-
-   /// Access all the integrators added with AddBoundaryIntegrator().
-   Array<BilinearFormIntegrator*> *GetBBFI() { return &boundary_integs; }
-   /** @brief Access all boundary markers added with AddBoundaryIntegrator().
-       If no marker was specified when the integrator was added, the
-       corresponding pointer (to Array<int>) will be NULL. */
-   Array<Array<int>*> *GetBBFI_Marker() { return &boundary_integs_marker; }
-
-   /// Access all integrators added with AddInteriorFaceIntegrator().
-   Array<BilinearFormIntegrator*> *GetFBFI() { return &interior_face_integs; }
-
-   /// Access all integrators added with AddBdrFaceIntegrator().
-   Array<BilinearFormIntegrator*> *GetBFBFI() { return &boundary_face_integs; }
-   /** @brief Access all boundary markers added with AddBdrFaceIntegrator().
-       If no marker was specified when the integrator was added, the
-       corresponding pointer (to Array<int>) will be NULL. */
-   Array<Array<int>*> *GetBFBFI_Marker()
-   { return &boundary_face_integs_marker; }
-
    /// Returns a reference to: \f$ M_{ij} \f$
    const double &operator()(int i, int j) { return (*mat)(i,j); }
 
@@ -284,42 +238,52 @@ public:
    /// Matrix vector multiplication:  \f$ y = M x \f$
    virtual void Mult(const Vector &x, Vector &y) const;
 
+   /// Add the matrix vector multiple to a vector:  \f$ y += a M x \f$
+   virtual void AddMult(const Vector &x, Vector &y,
+                        const double a = 1.0) const;
+
+   /// Matrix transpose vector multiplication:  \f$ y = M^T x \f$
+   virtual void MultTranspose(const Vector &x, Vector &y) const;
+
+   /// Add the matrix transpose vector multiplication:  \f$ y += a M^T x \f$
+   virtual void AddMultTranspose(const Vector &x, Vector &y,
+                                 const double a = 1.0) const;
+
    /** @brief Matrix vector multiplication with the original uneliminated
        matrix.  The original matrix is \f$ M + M_e \f$ so we have:
        \f$ y = M x + M_e x \f$ */
    void FullMult(const Vector &x, Vector &y) const
    { mat->Mult(x, y); mat_e->AddMult(x, y); }
 
-   /// Add the matrix vector multiple to a vector:  \f$ y += a M x \f$
-   virtual void AddMult(const Vector &x, Vector &y, const double a = 1.0) const
-   { mat -> AddMult (x, y, a); }
-
    /** @brief Add the original uneliminated matrix vector multiple to a vector.
        The original matrix is \f$ M + Me \f$ so we have:
        \f$ y += M x + M_e x \f$ */
    void FullAddMult(const Vector &x, Vector &y) const
    { mat->AddMult(x, y); mat_e->AddMult(x, y); }
 
-   /// Add the matrix transpose vector multiplication:  \f$ y += a M^T x \f$
-   virtual void AddMultTranspose(const Vector & x, Vector & y,
-                                 const double a = 1.0) const
-   { mat->AddMultTranspose(x, y, a); }
-
    /** @brief Add the original uneliminated matrix transpose vector
        multiple to a vector. The original matrix is \f$ M + M_e \f$
        so we have: \f$ y += M^T x + {M_e}^T x \f$ */
-   void FullAddMultTranspose(const Vector & x, Vector & y) const
+   void FullAddMultTranspose(const Vector &x, Vector &y) const
    { mat->AddMultTranspose(x, y); mat_e->AddMultTranspose(x, y); }
 
-   /// Matrix transpose vector multiplication:  \f$ y = M^T x \f$
-   virtual void MultTranspose(const Vector & x, Vector & y) const;
+   /// Compute inner product for full uneliminated matrix \f$ y^T M x + y^T M_e x \f$
+   double FullInnerProduct(const Vector &x, const Vector &y) const
+   { return mat->InnerProduct(x, y) + mat_e->InnerProduct(x, y); }
+
+   /// Returns a pointer to (approximation) of the matrix inverse:  \f$ M^{-1} \f$
+   virtual MatrixInverse *Inverse() const;
 
    /// Compute \f$ y^T M x \f$
    double InnerProduct(const Vector &x, const Vector &y) const
-   { return mat->InnerProduct (x, y); }
+   { return mat->InnerProduct(x, y); }
 
-   /// Returns a pointer to (approximation) of the matrix inverse:  \f$ M^{-1} \f$
-   virtual MatrixInverse *Inverse() const;
+   /// Sets all sparse values of \f$ M \f$ and \f$ M_e \f$ to 'a'.
+   void operator=(const double a)
+   {
+      if (mat != NULL) { *mat = a; }
+      if (mat_e != NULL) { *mat_e = a; }
+   }
 
    /// Finalizes the matrix initialization.
    virtual void Finalize(int skip_zeros = 1);
@@ -345,15 +309,7 @@ public:
    /** @brief Returns true if the sparse matrix is not null, false otherwise.
 
        @sa SpMat(). */
-   bool HasSpMat()
-   {
-      return mat != nullptr;
-   }
-
-
-   /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
-        to it.  Used for transferring ownership. */
-   SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
+   bool HasSpMat() const { return mat != nullptr; }
 
    /** @brief Returns a const reference to the sparse matrix of eliminated b.c.:
        \f$ M_e \f$
@@ -379,11 +335,31 @@ public:
         false otherwise.
 
         @sa SpMatElim(). */
-   bool HasSpMatElim()
+   bool HasSpMatElim()const { return mat_e != nullptr; }
+
+   /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
+        to it.  Used for transferring ownership. */
+   SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
+
+   /** Returns a const reference to the extension for assembly levels other
+    than AssemblyLevel::LEGACY. */
+   const BilinearFormExtension &Ext() const
    {
-      return mat_e != nullptr;
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
    }
 
+   /** Returns a reference to the extension for assembly levels other than
+       AssemblyLevel::LEGACY. */
+   BilinearFormExtension &Ext()
+   {
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
+   }
+
+   /// Returns true if the extension is not null, false otherwise.
+   bool HasExt() const { return ext != nullptr; }
+
    /// Adds new Domain Integrator. Assumes ownership of @a bfi.
    void AddDomainIntegrator(BilinearFormIntegrator *bfi);
    /// Adds new Domain Integrator restricted to certain elements specified by
@@ -416,16 +392,72 @@ public:
    void AddBdrFaceIntegrator(BilinearFormIntegrator *bfi,
                              Array<int> &bdr_marker);
 
-   /// Sets all sparse values of \f$ M \f$ and \f$ M_e \f$ to 'a'.
-   void operator=(const double a)
-   {
-      if (mat != NULL) { *mat = a; }
-      if (mat_e != NULL) { *mat_e = a; }
-   }
+   /// Access all the integrators added with AddDomainIntegrator().
+   Array<BilinearFormIntegrator*> *GetDBFI() { return &domain_integs; }
+
+   /// Access all the integrators added with AddBoundaryIntegrator().
+   Array<BilinearFormIntegrator*> *GetBBFI() { return &boundary_integs; }
+   /** @brief Access all boundary markers added with AddBoundaryIntegrator().
+       If no marker was specified when the integrator was added, the
+       corresponding pointer (to Array<int>) will be NULL. */
+   Array<Array<int>*> *GetBBFI_Marker() { return &boundary_integs_marker; }
+
+   /// Access all integrators added with AddInteriorFaceIntegrator().
+   Array<BilinearFormIntegrator*> *GetFBFI() { return &interior_face_integs; }
+
+   /// Access all integrators added with AddBdrFaceIntegrator().
+   Array<BilinearFormIntegrator*> *GetBFBFI() { return &boundary_face_integs; }
+   /** @brief Access all boundary markers added with AddBdrFaceIntegrator().
+       If no marker was specified when the integrator was added, the
+       corresponding pointer (to Array<int>) will be NULL. */
+   Array<Array<int>*> *GetBFBFI_Marker()
+   { return &boundary_face_integs_marker; }
+
+   /// Assemble the given element matrix
+   /** The element matrix @a elmat is assembled for the element @a i, i.e.
+       added to the system matrix. The flag @a skip_zeros skips the zero
+       elements of the matrix, unless they are breaking the symmetry of
+       the system matrix.
+   */
+   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
+                              int skip_zeros = 1);
+
+   /// Assemble the given element matrix
+   /** The element matrix @a elmat is assembled for the element @a i, i.e.
+       added to the system matrix. The vdofs of the element are returned
+       in @a vdofs. The flag @a skip_zeros skips the zero elements of the
+       matrix, unless they are breaking the symmetry of the system matrix.
+   */
+   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
+                              Array<int> &vdofs, int skip_zeros = 1);
+
+   /// Assemble the given boundary element matrix
+   /** The boundary element matrix @a elmat is assembled for the boundary
+       element @a i, i.e. added to the system matrix. The flag @a skip_zeros
+       skips the zero elements of the matrix, unless they are breaking the
+       symmetry of the system matrix.
+   */
+   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
+                                 int skip_zeros = 1);
+
+   /// Assemble the given boundary element matrix
+   /** The boundary element matrix @a elmat is assembled for the boundary
+       element @a i, i.e. added to the system matrix. The vdofs of the element
+       are returned in @a vdofs. The flag @a skip_zeros skips the zero elements
+       of the matrix, unless they are breaking the symmetry of the system matrix.
+   */
+   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
+                                 Array<int> &vdofs, int skip_zeros = 1);
 
    /// Assembles the form i.e. sums over all domain/bdr integrators.
    void Assemble(int skip_zeros = 1);
 
+   /** For a partially conforming FE space, complete the assembly process by
+       performing A := P^t A P where A is the internal sparse matrix; P is the
+       conforming prolongation matrices of the FE space. After this call the
+       BilinearForm becomes an operator on the conforming FE spaces. */
+   void ConformingAssemble();
+
    /** @brief Assemble the diagonal of the bilinear form into @a diag. Note that
        @a diag is a tdof Vector.
 
@@ -439,32 +471,20 @@ public:
 
    /// Get the finite element space prolongation operator.
    virtual const Operator *GetProlongation() const
-   { return fes->GetConformingProlongation(); }
+   { return fes->GetProlongationMatrix(); }
+
    /// Get the finite element space restriction operator
    virtual const Operator *GetRestriction() const
-   { return fes->GetConformingRestriction(); }
+   { return fes->GetRestrictionMatrix(); }
+
    /// Get the output finite element space prolongation matrix
    virtual const Operator *GetOutputProlongation() const
    { return GetProlongation(); }
-   /** @brief Returns the output fe space restriction matrix, transposed
 
-       Logically, this is the transpose of GetOutputRestriction, but in
-       practice it is convenient to have it in transposed form for
-       construction of RAP operators in matrix-free methods. */
-   virtual const Operator *GetOutputRestrictionTranspose() const
-   { return GetOutputProlongation(); }
    /// Get the output finite element space restriction matrix
    virtual const Operator *GetOutputRestriction() const
    { return GetRestriction(); }
 
-   /// @brief Compute serial RAP operator and store it in @a A as a SparseMatrix.
-   void SerialRAP(OperatorHandle &A)
-   {
-      MFEM_ASSERT(mat, "SerialRAP requires the SparseMatrix to be assembled.");
-      ConformingAssemble();
-      A.Reset(mat, false);
-   }
-
    /** @brief Form the linear system A X = B, corresponding to this bilinear
        form and the linear form @a b(.). */
    /** This method applies any necessary transformations to the linear system
@@ -541,59 +561,6 @@ public:
    */
    virtual void RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x);
 
-   /// Compute and store internally all element matrices.
-   void ComputeElementMatrices();
-
-   /// Free the memory used by the element matrices.
-   void FreeElementMatrices()
-   { delete element_matrices; element_matrices = NULL; }
-
-   /// Compute the element matrix of the given element
-   /** The element matrix is computed by calling the domain integrators
-       or the one stored internally by a prior call of ComputeElementMatrices()
-       is returned when available.
-   */
-   void ComputeElementMatrix(int i, DenseMatrix &elmat);
-
-   /// Compute the boundary element matrix of the given boundary element
-   void ComputeBdrElementMatrix(int i, DenseMatrix &elmat);
-
-   /// Assemble the given element matrix
-   /** The element matrix @a elmat is assembled for the element @a i, i.e.
-       added to the system matrix. The flag @a skip_zeros skips the zero
-       elements of the matrix, unless they are breaking the symmetry of
-       the system matrix.
-   */
-   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
-                              int skip_zeros = 1);
-
-   /// Assemble the given element matrix
-   /** The element matrix @a elmat is assembled for the element @a i, i.e.
-       added to the system matrix. The vdofs of the element are returned
-       in @a vdofs. The flag @a skip_zeros skips the zero elements of the
-       matrix, unless they are breaking the symmetry of the system matrix.
-   */
-   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
-                              Array<int> &vdofs, int skip_zeros = 1);
-
-   /// Assemble the given boundary element matrix
-   /** The boundary element matrix @a elmat is assembled for the boundary
-       element @a i, i.e. added to the system matrix. The flag @a skip_zeros
-       skips the zero elements of the matrix, unless they are breaking the
-       symmetry of the system matrix.
-   */
-   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
-                                 int skip_zeros = 1);
-
-   /// Assemble the given boundary element matrix
-   /** The boundary element matrix @a elmat is assembled for the boundary
-       element @a i, i.e. added to the system matrix. The vdofs of the element
-       are returned in @a vdofs. The flag @a skip_zeros skips the zero elements
-       of the matrix, unless they are breaking the symmetry of the system matrix.
-   */
-   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
-                                 Array<int> &vdofs, int skip_zeros = 1);
-
    /// Eliminate essential boundary DOFs from the system.
    /** The array @a bdr_attr_is_ess marks boundary attributes that constitute
        the essential part of the boundary. By default, the diagonal at the
@@ -645,34 +612,14 @@ public:
    void EliminateVDofsInRHS(const Array<int> &vdofs, const Vector &x,
                             Vector &b);
 
-   /// Compute inner product for full uneliminated matrix \f$ y^T M x + y^T M_e x \f$
-   double FullInnerProduct(const Vector &x, const Vector &y) const
-   { return mat->InnerProduct(x, y) + mat_e->InnerProduct(x, y); }
-
    /// Update the @a FiniteElementSpace and delete all data associated with the old one.
    virtual void Update(FiniteElementSpace *nfes = NULL);
 
-   /// (DEPRECATED) Return the FE space associated with the BilinearForm.
-   /** @deprecated Use FESpace() instead. */
-   MFEM_DEPRECATED FiniteElementSpace *GetFES() { return fes; }
-
    /// Return the FE space associated with the BilinearForm.
    FiniteElementSpace *FESpace() { return fes; }
    /// Read-only access to the associated FiniteElementSpace.
    const FiniteElementSpace *FESpace() const { return fes; }
 
-   /// Sets diagonal policy used upon construction of the linear system.
-   /** Policies include:
-
-       - DIAG_ZERO (Set the diagonal values to zero)
-       - DIAG_ONE  (Set the diagonal values to one)
-       - DIAG_KEEP (Keep the diagonal values)
-   */
-   void SetDiagonalPolicy(DiagonalPolicy policy);
-
-   /// Indicate that integrators are not owned by the BilinearForm
-   void UseExternalIntegrators() { extern_bfs = 1; }
-
    /// Destroys bilinear form.
    virtual ~BilinearForm();
 };
@@ -696,11 +643,12 @@ public:
 class MixedBilinearForm : public Matrix
 {
 protected:
-   SparseMatrix *mat; ///< Owned.
-   SparseMatrix *mat_e; ///< Owned.
+   /** Sparse matrices associated with the form and the eliminations from
+       the b.c. Owned. */
+   SparseMatrix *mat, *mat_e;
 
-   FiniteElementSpace *trial_fes, ///< Not owned
-                      *test_fes;  ///< Not owned
+   /// FE space on which the form lives. Not owned.
+   FiniteElementSpace *trial_fes, *test_fes;
 
    /// The form assembly level (full, partial, etc.)
    AssemblyLevel assembly;
@@ -733,11 +681,11 @@ protected:
    Array<int>  trial_vdofs, test_vdofs;
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   MixedBilinearForm(const MixedBilinearForm &);
+   /// Copy construction is not supported.
+   MixedBilinearForm(const MixedBilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   MixedBilinearForm &operator=(const MixedBilinearForm &);
+   /// Copy assignment is not supported.
+   MixedBilinearForm &operator=(const MixedBilinearForm &) = delete;
 
 public:
    /** @brief Construct a MixedBilinearForm on the given trial, @a tr_fes, and
@@ -760,6 +708,13 @@ public:
                      FiniteElementSpace *te_fes,
                      MixedBilinearForm *mbf);
 
+   /// Set the desired assembly level. The default is AssemblyLevel::LEGACY.
+   /** This method must be called before assembly. */
+   void SetAssemblyLevel(AssemblyLevel assembly_level);
+
+   /// Returns the assembly level
+   AssemblyLevel GetAssemblyLevel() const { return assembly; }
+
    /// Returns a reference to: \f$ M_{ij} \f$
    virtual double &Elem(int i, int j);
 
@@ -767,17 +722,21 @@ public:
    virtual const double &Elem(int i, int j) const;
 
    /// Matrix multiplication: \f$ y = M x \f$
-   virtual void Mult(const Vector & x, Vector & y) const;
+   virtual void Mult(const Vector &x, Vector &y) const;
 
-   virtual void AddMult(const Vector & x, Vector & y,
+   virtual void AddMult(const Vector &x, Vector &y,
                         const double a = 1.0) const;
 
-   virtual void MultTranspose(const Vector & x, Vector & y) const;
-   virtual void AddMultTranspose(const Vector & x, Vector & y,
+   virtual void MultTranspose(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTranspose(const Vector &x, Vector &y,
                                  const double a = 1.0) const;
 
    virtual MatrixInverse *Inverse() const;
 
+   /// Sets all sparse values of \f$ M \f$ to @a a.
+   void operator=(const double a) { *mat = a; }
+
    /// Finalizes the matrix initialization.
    virtual void Finalize(int skip_zeros = 1);
 
@@ -787,15 +746,45 @@ public:
    void GetBlocks(Array2D<SparseMatrix *> &blocks) const;
 
    /// Returns a const reference to the sparse matrix:  \f$ M \f$
-   const SparseMatrix &SpMat() const { return *mat; }
+   const SparseMatrix &SpMat() const
+   {
+      MFEM_VERIFY(mat, "mat is NULL and can't be dereferenced");
+      return *mat;
+   }
 
    /// Returns a reference to the sparse matrix:  \f$ M \f$
-   SparseMatrix &SpMat() { return *mat; }
+   SparseMatrix &SpMat()
+   {
+      MFEM_VERIFY(mat, "mat is NULL and can't be dereferenced");
+      return *mat;
+   }
+
+   /// Returns true if the sparse matrix is not null, false otherwise.
+   bool HasSpMat() const { return mat != nullptr; }
 
    /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
         to it.  Used for transferring ownership. */
    SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
 
+   /** Returns a const reference to the extension for assembly levels other
+    than AssemblyLevel::LEGACY. */
+   const MixedBilinearFormExtension &Ext() const
+   {
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
+   }
+
+   /** Returns a reference to the extension for assembly levels other than
+       AssemblyLevel::LEGACY. */
+   MixedBilinearFormExtension &Ext()
+   {
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
+   }
+
+   /// Returns true if the extension is not null, false otherwise.
+   bool HasExt() const { return ext != nullptr; }
+
    /// Adds a domain integrator. Assumes ownership of @a bfi.
    void AddDomainIntegrator(BilinearFormIntegrator *bfi);
 
@@ -803,8 +792,8 @@ public:
    void AddBoundaryIntegrator(BilinearFormIntegrator *bfi);
 
    /// Adds a boundary integrator. Assumes ownership of @a bfi.
-   void AddBoundaryIntegrator (BilinearFormIntegrator * bfi,
-                               Array<int> &bdr_marker);
+   void AddBoundaryIntegrator(BilinearFormIntegrator *bfi,
+                              Array<int> &bdr_marker);
 
    /** @brief Add a trace face integrator. Assumes ownership of @a bfi.
 
@@ -814,11 +803,11 @@ public:
    void AddTraceFaceIntegrator(BilinearFormIntegrator *bfi);
 
    /// Adds a boundary trace face integrator. Assumes ownership of @a bfi.
-   void AddBdrTraceFaceIntegrator (BilinearFormIntegrator * bfi);
+   void AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi);
 
    /// Adds a boundary trace face integrator. Assumes ownership of @a bfi.
-   void AddBdrTraceFaceIntegrator (BilinearFormIntegrator * bfi,
-                                   Array<int> &bdr_marker);
+   void AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi,
+                                  Array<int> &bdr_marker);
 
    /// Access all integrators added with AddDomainIntegrator().
    Array<BilinearFormIntegrator*> *GetDBFI() { return &domain_integs; }
@@ -842,48 +831,6 @@ public:
    Array<Array<int>*> *GetBTFBFI_Marker()
    { return &boundary_trace_face_integs_marker; }
 
-   /// Sets all sparse values of \f$ M \f$ to @a a.
-   void operator=(const double a) { *mat = a; }
-
-   /// Set the desired assembly level. The default is AssemblyLevel::LEGACY.
-   /** This method must be called before assembly. */
-   void SetAssemblyLevel(AssemblyLevel assembly_level);
-
-   void Assemble(int skip_zeros = 1);
-
-   /** @brief Assemble the diagonal of ADA^T into diag, where A is this mixed
-       bilinear form and D is a diagonal. */
-   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
-
-   /// Get the input finite element space prolongation matrix
-   virtual const Operator *GetProlongation() const
-   { return trial_fes->GetProlongationMatrix(); }
-
-   /// Get the input finite element space restriction matrix
-   virtual const Operator *GetRestriction() const
-   { return trial_fes->GetRestrictionMatrix(); }
-
-   /// Get the test finite element space prolongation matrix
-   virtual const Operator *GetOutputProlongation() const
-   { return test_fes->GetProlongationMatrix(); }
-
-   /// Get the test finite element space restriction matrix
-   virtual const Operator *GetOutputRestriction() const
-   { return test_fes->GetRestrictionMatrix(); }
-
-   /** For partially conforming trial and/or test FE spaces, complete the
-       assembly process by performing A := P2^t A P1 where A is the internal
-       sparse matrix; P1 and P2 are the conforming prolongation matrices of the
-       trial and test FE spaces, respectively. After this call the
-       MixedBilinearForm becomes an operator on the conforming FE spaces. */
-   void ConformingAssemble();
-
-   /// Compute the element matrix of the given element
-   void ComputeElementMatrix(int i, DenseMatrix &elmat);
-
-   /// Compute the boundary element matrix of the given boundary element
-   void ComputeBdrElementMatrix(int i, DenseMatrix &elmat);
-
    /// Assemble the given element matrix
    /** The element matrix @a elmat is assembled for the element @a i, i.e.
        added to the system matrix. The flag @a skip_zeros skips the zero
@@ -924,40 +871,34 @@ public:
                                  Array<int> &trial_vdofs, Array<int> &test_vdofs,
                                  int skip_zeros = 1);
 
-   void EliminateTrialDofs(const Array<int> &bdr_attr_is_ess,
-                           const Vector &sol, Vector &rhs);
+   void Assemble(int skip_zeros = 1);
 
-   void EliminateEssentialBCFromTrialDofs(const Array<int> &marked_vdofs,
-                                          const Vector &sol, Vector &rhs);
+   /** For partially conforming trial and/or test FE spaces, complete the
+       assembly process by performing A := P2^t A P1 where A is the internal
+       sparse matrix; P1 and P2 are the conforming prolongation matrices of the
+       trial and test FE spaces, respectively. After this call the
+       MixedBilinearForm becomes an operator on the conforming FE spaces. */
+   void ConformingAssemble();
 
-   virtual void EliminateTestDofs(const Array<int> &bdr_attr_is_ess);
+   /** @brief Assemble the diagonal of ADA^T into diag, where A is this mixed
+       bilinear form and D is a diagonal. */
+   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
 
-   /** @brief Return in @a A that is column-constrained.
+   /// Get the input finite element space prolongation matrix
+   virtual const Operator *GetProlongation() const
+   { return trial_fes->GetProlongationMatrix(); }
 
-      This returns the same operator as FormRectangularLinearSystem(), but does
-      without the transformations of the right-hand side. */
-   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
-                                            const Array<int> &test_tdof_list,
-                                            OperatorHandle &A);
+   /// Get the input finite element space restriction matrix
+   virtual const Operator *GetRestriction() const
+   { return trial_fes->GetRestrictionMatrix(); }
 
-   /** @brief Form the column-constrained linear system matrix A.
-       See FormRectangularSystemMatrix() for details.
+   /// Get the test finite element space prolongation matrix
+   virtual const Operator *GetOutputProlongation() const
+   { return test_fes->GetProlongationMatrix(); }
 
-       Version of the method FormRectangularSystemMatrix() where the system matrix is
-       returned in the variable @a A, of type OpType, holding a *reference* to
-       the system matrix (created with the method OpType::MakeRef()). The
-       reference will be invalidated when SetOperatorType(), Update(), or the
-       destructor is called. */
-   template <typename OpType>
-   void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
-                                    const Array<int> &test_tdof_list, OpType &A)
-   {
-      OperatorHandle Ah;
-      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, Ah);
-      OpType *A_ptr = Ah.Is<OpType>();
-      MFEM_VERIFY(A_ptr, "invalid OpType used");
-      A.MakeRef(*A_ptr);
-   }
+   /// Get the test finite element space restriction matrix
+   virtual const Operator *GetOutputRestriction() const
+   { return test_fes->GetRestrictionMatrix(); }
 
    /** @brief Form the linear system A X = B, corresponding to this mixed bilinear
        form and the linear form @a b(.).
@@ -992,6 +933,41 @@ public:
       A.MakeRef(*A_ptr);
    }
 
+   /** @brief Return in @a A that is column-constrained.
+
+      This returns the same operator as FormRectangularLinearSystem(), but does
+      without the transformations of the right-hand side. */
+   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
+                                            const Array<int> &test_tdof_list,
+                                            OperatorHandle &A);
+
+   /** @brief Form the column-constrained linear system matrix A.
+       See FormRectangularSystemMatrix() for details.
+
+       Version of the method FormRectangularSystemMatrix() where the system matrix is
+       returned in the variable @a A, of type OpType, holding a *reference* to
+       the system matrix (created with the method OpType::MakeRef()). The
+       reference will be invalidated when SetOperatorType(), Update(), or the
+       destructor is called. */
+   template <typename OpType>
+   void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
+                                    const Array<int> &test_tdof_list, OpType &A)
+   {
+      OperatorHandle Ah;
+      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, Ah);
+      OpType *A_ptr = Ah.Is<OpType>();
+      MFEM_VERIFY(A_ptr, "invalid OpType used");
+      A.MakeRef(*A_ptr);
+   }
+
+   void EliminateTrialDofs(const Array<int> &bdr_attr_is_ess,
+                           const Vector &sol, Vector &rhs);
+
+   void EliminateEssentialBCFromTrialDofs(const Array<int> &marked_vdofs,
+                                          const Vector &sol, Vector &rhs);
+
+   virtual void EliminateTestDofs(const Array<int> &bdr_attr_is_ess);
+
    void Update();
 
    /// Return the trial FE space associated with the BilinearForm.
@@ -1041,11 +1017,11 @@ public:
 class DiscreteLinearOperator : public MixedBilinearForm
 {
 private:
-   /// Copy construction is not supported; body is undefined.
-   DiscreteLinearOperator(const DiscreteLinearOperator &);
+   /// Copy construction is not supported.
+   DiscreteLinearOperator(const DiscreteLinearOperator &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   DiscreteLinearOperator &operator=(const DiscreteLinearOperator &);
+   /// Copy assignment is not supported.
+   DiscreteLinearOperator &operator=(const DiscreteLinearOperator &) = delete;
 
 public:
    /** @brief Construct a DiscreteLinearOperator on the given
@@ -1065,9 +1041,12 @@ public:
    { AddTraceFaceIntegrator(di); }
 
    /// Access all interpolators added with AddDomainInterpolator().
-   Array<BilinearFormIntegrator*> *GetDI() { return &domain_integs; }
+   Array<BilinearFormIntegrator*> *GetDI() { return GetDBFI(); }
+
+   /// Access all interpolators added with AddTraceFaceInterpolator().
+   Array<BilinearFormIntegrator*> *GetTFI() { return GetTFBFI(); }
 
-   /// Set the desired assembly level. The default is AssemblyLevel::FULL.
+   /// Set the desired assembly level. The default is AssemblyLevel::LEGACY.
    /** This method must be called before assembly. */
    void SetAssemblyLevel(AssemblyLevel assembly_level);
 
@@ -1075,10 +1054,26 @@ public:
        linear operator. */
    virtual void Assemble(int skip_zeros = 1);
 
-   /** @brief Get the output finite element space restriction matrix in
-       transposed form. */
-   virtual const Operator *GetOutputRestrictionTranspose() const
-   { return test_fes->GetRestrictionTransposeOperator(); }
+   /** @brief Return in @a A that is column-constrained. */
+   virtual void FormDiscreteOperatorMatrix(OperatorHandle &A);
+
+   /** @brief Form the column-constrained discrete linear operator matrix A.
+       See FormDiscreteOperatorMatrix() for details.
+
+       Version of the method FormDiscreteOperatorMatrix() where the discrete
+       operator matrix is returned in the variable @a A, of type OpType,
+       holding a *reference* to the discrete operator  matrix (created with the
+       method OpType::MakeRef()). The reference will be invalidated when
+       SetOperatorType(), Update(), or the destructor is called. */
+   template <typename OpType>
+   void FormDiscreteOperatorMatrix(OpType &A)
+   {
+      OperatorHandle Ah;
+      FormDiscreteOperatorMatrix(Ah);
+      OpType *A_ptr = Ah.Is<OpType>();
+      MFEM_VERIFY(A_ptr, "invalid OpType used");
+      A.MakeRef(*A_ptr);
+   }
 };
 
 }
diff --git a/fem/bilinearform_ext.cpp b/fem/bilinearform_ext.cpp
index 50c2cf198..90a1655f4 100644
--- a/fem/bilinearform_ext.cpp
+++ b/fem/bilinearform_ext.cpp
@@ -21,10 +21,10 @@
 namespace mfem
 {
 
+/// Base class for extensions to the BilinearForm class
 BilinearFormExtension::BilinearFormExtension(BilinearForm *form)
    : Operator(form->Size()), a(form)
 {
-   // empty
 }
 
 const Operator *BilinearFormExtension::GetProlongation() const
@@ -37,812 +37,1226 @@ const Operator *BilinearFormExtension::GetRestriction() const
    return a->GetRestriction();
 }
 
-// Data and methods for partially-assembled bilinear forms
+/// Data and methods for matrix-free bilinear forms
 MFBilinearFormExtension::MFBilinearFormExtension(BilinearForm *form)
-   : BilinearFormExtension(form),
-     trial_fes(a->FESpace()),
-     test_fes(a->FESpace())
+   : BilinearFormExtension(form)
 {
-   elem_restrict = NULL;
-   int_face_restrict_lex = NULL;
-   bdr_face_restrict_lex = NULL;
+   Update();
 }
 
-void MFBilinearFormExtension::Assemble()
+void MFBilinearFormExtension::SetupRestrictionOperators(const L2FaceValues m)
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
+   if (DeviceCanUseCeed()) { return; }
+   ElementDofOrdering ordering = UsesTensorBasis(*fes) ?
+                                 ElementDofOrdering::LEXICOGRAPHIC :
+                                 ElementDofOrdering::NATIVE;
+   elem_restrict = fes->GetElementRestriction(ordering);
+   if (elem_restrict)
+   {
+      local_x.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
+      local_y.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
+      local_y.UseDevice(true); // ensure 'local_y = 0.0' is done on device
+   }
+
+   // Construct face restriction operators only if the bilinear form has
+   // interior or boundary face integrators
+   if (int_face_restrict_lex == nullptr && a->GetFBFI()->Size() > 0)
+   {
+      int_face_restrict_lex = fes->GetFaceRestriction(
+                                 ElementDofOrdering::LEXICOGRAPHIC,
+                                 FaceType::Interior);
+      int_face_x.SetSize(int_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      int_face_y.SetSize(int_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      int_face_y.UseDevice(true);
+   }
+
+   const bool has_bdr_integs = (a->GetBFBFI()->Size() > 0 ||
+                                a->GetBBFI()->Size() > 0);
+   if (bdr_face_restrict_lex == nullptr && has_bdr_integs)
    {
-      integrators[i]->AssembleMF(*a->FESpace());
+      bdr_face_restrict_lex = fes->GetFaceRestriction(
+                                 ElementDofOrdering::LEXICOGRAPHIC,
+                                 FaceType::Boundary,
+                                 m);
+      bdr_face_x.SetSize(bdr_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      bdr_face_y.SetSize(bdr_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      bdr_face_y.UseDevice(true);
    }
 }
 
-void MFBilinearFormExtension::AssembleDiagonal(Vector &y) const
+void MFBilinearFormExtension::Assemble()
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
+
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
+   {
+      integ->AssembleMF(*fes);
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
+   {
+      integ->AssembleMFBoundary(*fes);
+   }
+
+   MFEM_VERIFY(a->GetFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in MFBilinearFormExtension");
+
+   MFEM_VERIFY(a->GetBFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in MFBilinearFormExtension");
+}
 
-   const int iSz = integrators.Size();
-   if (elem_restrict && !DeviceCanUseCeed())
+void MFBilinearFormExtension::AssembleDiagonal(Vector &diag) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (elem_restrict && integrators.Size() > 0)
    {
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AssembleDiagonalMF(localY);
+         integ->AssembleDiagonalMF(local_y);
       }
-      const ElementRestriction* H1elem_restrict =
-         dynamic_cast<const ElementRestriction*>(elem_restrict);
-      if (H1elem_restrict)
+      elem_restrict->MultTransposeUnsigned(local_y, diag);
+   }
+   else
+   {
+      diag.UseDevice(true); // typically this is a large vector, so store on device
+      diag = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         H1elem_restrict->MultTransposeUnsigned(localY, y);
+         integ->AssembleDiagonalMF(diag);
       }
-      else
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_face_restrict_lex && bdr_integrators.Size() > 0)
+   {
+      bdr_face_y = 0.0;
+      for (BilinearFormIntegrator *integ : bdr_integrators)
       {
-         elem_restrict->MultTranspose(localY, y);
+         integ->AssembleDiagonalMF(bdr_face_y);
       }
+      bdr_face_restrict_lex->AddMultTransposeUnsigned(bdr_face_y, diag);
    }
    else
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      for (BilinearFormIntegrator *integ : bdr_integrators)
       {
-         integrators[i]->AssembleDiagonalMF(y);
+         integ->AssembleDiagonalMF(diag);
       }
    }
 }
 
-void MFBilinearFormExtension::Update()
-{
-   FiniteElementSpace *fes = a->FESpace();
-   height = width = fes->GetVSize();
-   trial_fes = fes;
-   test_fes = fes;
-
-   elem_restrict = nullptr;
-   int_face_restrict_lex = nullptr;
-   bdr_face_restrict_lex = nullptr;
-}
-
-void MFBilinearFormExtension::FormSystemMatrix(const Array<int> &ess_tdof_list,
-                                               OperatorHandle &A)
-{
-   Operator *oper;
-   Operator::FormSystemOperator(ess_tdof_list, oper);
-   A.Reset(oper); // A will own oper
-}
-
-void MFBilinearFormExtension::FormLinearSystem(const Array<int> &ess_tdof_list,
-                                               Vector &x, Vector &b,
-                                               OperatorHandle &A,
-                                               Vector &X, Vector &B,
-                                               int copy_interior)
-{
-   Operator *oper;
-   Operator::FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
-   A.Reset(oper); // A will own oper
-}
-
 void MFBilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-   if (DeviceCanUseCeed() || !elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (elem_restrict && integrators.Size() > 0)
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultMF(x, y);
+         integ->AddMultMF(local_x, local_y);
       }
+      elem_restrict->MultTranspose(local_y, y);
    }
    else
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultMF(localX, localY);
+         integ->AddMultMF(x, y);
       }
-      elem_restrict->MultTranspose(localY, y);
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_face_restrict_lex && bdr_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         bdr_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            intFaceIntegrators[i]->AddMultMF(int_face_X, int_face_Y);
+            integ->AddMultMF(bdr_face_x, bdr_face_y);
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
       }
    }
-
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
+   else
    {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      for (BilinearFormIntegrator *integ : bdr_integrators)
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
-         {
-            bdrFaceIntegrators[i]->AddMultMF(bdr_face_X, bdr_face_Y);
-         }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
+         integ->AddMultMF(x, y);
       }
    }
 }
 
-void MFBilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
+void MFBilinearFormExtension::AddMult(const Vector &x, Vector &y,
+                                      const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-   if (elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (elem_restrict && integrators.Size() > 0)
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultMF(local_x, local_y);
+      }
+      if (c != 1.0)
       {
-         integrators[i]->AddMultTransposeMF(localX, localY);
+         local_y *= c;
       }
-      elem_restrict->MultTranspose(localY, y);
+      elem_restrict->AddMultTranspose(local_y, y);
    }
    else
    {
-      y.UseDevice(true);
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      if (c != 1.0 && integrators.Size() > 0)
       {
-         integrators[i]->AddMultTransposeMF(x, y);
+         temp_y.SetSize(y.Size());
+         temp_y.UseDevice(true);
+         temp_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultMF(x, temp_y);
+         }
+         y.Add(c, temp_y);
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultMF(x, y);
+         }
       }
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_face_restrict_lex && bdr_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         bdr_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultMF(bdr_face_x, bdr_face_y);
+         }
+         if (c != 1.0)
          {
-            intFaceIntegrators[i]->AddMultTransposeMF(int_face_X, int_face_Y);
+            bdr_face_y *= c;
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
       }
    }
-
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
+   else
    {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      if (c != 1.0 && bdr_integrators.Size() > 0)
+      {
+         temp_y.SetSize(y.Size());
+         temp_y.UseDevice(true);
+         temp_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultMF(x, temp_y);
+         }
+         y.Add(c, temp_y);
+      }
+      else
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            bdrFaceIntegrators[i]->AddMultTransposeMF(bdr_face_X, bdr_face_Y);
+            integ->AddMultMF(x, y);
          }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
       }
    }
 }
 
-// Data and methods for partially-assembled bilinear forms
-PABilinearFormExtension::PABilinearFormExtension(BilinearForm *form)
-   : BilinearFormExtension(form),
-     trial_fes(a->FESpace()),
-     test_fes(a->FESpace())
-{
-   elem_restrict = NULL;
-   int_face_restrict_lex = NULL;
-   bdr_face_restrict_lex = NULL;
-}
-
-void PABilinearFormExtension::SetupRestrictionOperators(const L2FaceValues m)
+void MFBilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 {
-   if ( Device::Allows(Backend::CEED_MASK) ) { return; }
-   ElementDofOrdering ordering = UsesTensorBasis(*a->FESpace())?
-                                 ElementDofOrdering::LEXICOGRAPHIC:
-                                 ElementDofOrdering::NATIVE;
-   elem_restrict = trial_fes->GetElementRestriction(ordering);
-   if (elem_restrict)
-   {
-      localX.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
-      localY.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
-      localY.UseDevice(true); // ensure 'localY = 0.0' is done on device
-   }
-
-   // Construct face restriction operators only if the bilinear form has
-   // interior or boundary face integrators
-   if (int_face_restrict_lex == NULL && a->GetFBFI()->Size() > 0)
-   {
-      int_face_restrict_lex = trial_fes->GetFaceRestriction(
-                                 ElementDofOrdering::LEXICOGRAPHIC,
-                                 FaceType::Interior);
-      int_face_X.SetSize(int_face_restrict_lex->Height(), Device::GetMemoryType());
-      int_face_Y.SetSize(int_face_restrict_lex->Height(), Device::GetMemoryType());
-      int_face_Y.UseDevice(true); // ensure 'int_face_Y = 0.0' is done on device
-   }
-
-   if (bdr_face_restrict_lex == NULL && a->GetBFBFI()->Size() > 0)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (elem_restrict && integrators.Size() > 0)
    {
-      bdr_face_restrict_lex = trial_fes->GetFaceRestriction(
-                                 ElementDofOrdering::LEXICOGRAPHIC,
-                                 FaceType::Boundary,
-                                 m);
-      bdr_face_X.SetSize(bdr_face_restrict_lex->Height(), Device::GetMemoryType());
-      bdr_face_Y.SetSize(bdr_face_restrict_lex->Height(), Device::GetMemoryType());
-      bdr_face_Y.UseDevice(true); // ensure 'faceBoundY = 0.0' is done on device
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposeMF(local_x, local_y);
+      }
+      elem_restrict->MultTranspose(local_y, y);
    }
-}
-
-void PABilinearFormExtension::Assemble()
-{
-   SetupRestrictionOperators(L2FaceValues::DoubleValued);
-
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
+   else
    {
-      integrators[i]->AssemblePA(*a->FESpace());
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposeMF(x, y);
+      }
    }
 
-   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
-               "Partial assembly does not support AddBoundaryIntegrator yet.");
-
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int intFaceIntegratorCount = intFaceIntegrators.Size();
-   for (int i = 0; i < intFaceIntegratorCount; ++i)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_face_restrict_lex && bdr_integrators.Size() > 0)
    {
-      intFaceIntegrators[i]->AssemblePAInteriorFaces(*a->FESpace());
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
+      {
+         bdr_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposeMF(bdr_face_x, bdr_face_y);
+         }
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+      }
    }
-
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int boundFaceIntegratorCount = bdrFaceIntegrators.Size();
-   for (int i = 0; i < boundFaceIntegratorCount; ++i)
+   else
    {
-      bdrFaceIntegrators[i]->AssemblePABoundaryFaces(*a->FESpace());
+      for (BilinearFormIntegrator *integ : bdr_integrators)
+      {
+         integ->AddMultTransposeMF(x, y);
+      }
    }
 }
 
-void PABilinearFormExtension::AssembleDiagonal(Vector &y) const
+void MFBilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
+                                               const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-   if (elem_restrict && !DeviceCanUseCeed())
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (elem_restrict && integrators.Size() > 0)
    {
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AssembleDiagonalPA(localY);
+         integ->AddMultTransposeMF(local_x, local_y);
       }
-      const ElementRestriction* H1elem_restrict =
-         dynamic_cast<const ElementRestriction*>(elem_restrict);
-      if (H1elem_restrict)
+      if (c != 1.0)
+      {
+         local_y *= c;
+      }
+      elem_restrict->AddMultTranspose(local_y, y);
+   }
+   else
+   {
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      if (c != 1.0 && integrators.Size() > 0)
       {
-         H1elem_restrict->MultTransposeUnsigned(localY, y);
+         temp_y.SetSize(y.Size());
+         temp_y.UseDevice(true);
+         temp_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposeMF(x, temp_y);
+         }
+         y.Add(c, temp_y);
       }
       else
       {
-         elem_restrict->MultTranspose(localY, y);
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposeMF(x, y);
+         }
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_face_restrict_lex && bdr_integrators.Size() > 0)
+   {
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
+      {
+         bdr_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposeMF(bdr_face_x, bdr_face_y);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_y *= c;
+         }
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
       }
    }
    else
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      if (c != 1.0 && bdr_integrators.Size() > 0)
+      {
+         temp_y.SetSize(y.Size());
+         temp_y.UseDevice(true);
+         temp_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposeMF(x, temp_y);
+         }
+         y.Add(c, temp_y);
+      }
+      else
       {
-         integrators[i]->AssembleDiagonalPA(y);
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposeMF(x, y);
+         }
       }
    }
 }
 
-void PABilinearFormExtension::Update()
+void MFBilinearFormExtension::Update()
 {
-   FiniteElementSpace *fes = a->FESpace();
+   fes = a->FESpace();
    height = width = fes->GetVSize();
-   trial_fes = fes;
-   test_fes = fes;
 
    elem_restrict = nullptr;
    int_face_restrict_lex = nullptr;
    bdr_face_restrict_lex = nullptr;
 }
 
-void PABilinearFormExtension::FormSystemMatrix(const Array<int> &ess_tdof_list,
-                                               OperatorHandle &A)
+/// Data and methods for partially-assembled bilinear forms
+PABilinearFormExtension::PABilinearFormExtension(BilinearForm *form)
+   : MFBilinearFormExtension(form)
 {
-   Operator *oper;
-   Operator::FormSystemOperator(ess_tdof_list, oper);
-   A.Reset(oper); // A will own oper
 }
 
-void PABilinearFormExtension::FormLinearSystem(const Array<int> &ess_tdof_list,
-                                               Vector &x, Vector &b,
-                                               OperatorHandle &A,
-                                               Vector &X, Vector &B,
-                                               int copy_interior)
+void PABilinearFormExtension::Assemble()
 {
-   Operator *oper;
-   Operator::FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
-   A.Reset(oper); // A will own oper
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
+
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
+   {
+      integ->AssemblePA(*fes);
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
+   {
+      integ->AssemblePABoundary(*fes);
+   }
+
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   for (BilinearFormIntegrator *integ : int_face_integrators)
+   {
+      integ->AssemblePAInteriorFaces(*fes);
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   for (BilinearFormIntegrator *integ : bdr_face_integrators)
+   {
+      integ->AssemblePABoundaryFaces(*fes);
+   }
 }
 
-void PABilinearFormExtension::Mult(const Vector &x, Vector &y) const
+void PABilinearFormExtension::AssembleDiagonal(Vector &diag) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-   if (DeviceCanUseCeed() || !elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (elem_restrict && integrators.Size() > 0)
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultPA(x, y);
+         integ->AssembleDiagonalPA(local_y);
       }
+      elem_restrict->MultTransposeUnsigned(local_y, diag);
    }
    else
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      diag.UseDevice(true); // typically this is a large vector, so store on device
+      diag = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultPA(localX, localY);
+         integ->AssembleDiagonalPA(diag);
       }
-      elem_restrict->MultTranspose(localY, y);
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_face_restrict_lex && bdr_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      bdr_face_y = 0.0;
+      for (BilinearFormIntegrator *integ : bdr_integrators)
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
-         {
-            intFaceIntegrators[i]->AddMultPA(int_face_X, int_face_Y);
-         }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+         integ->AssembleDiagonalPA(bdr_face_y);
       }
+      bdr_face_restrict_lex->AddMultTransposeUnsigned(bdr_face_y, diag);
    }
-
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
+   else
    {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      for (BilinearFormIntegrator *integ : bdr_integrators)
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
-         {
-            bdrFaceIntegrators[i]->AddMultPA(bdr_face_X, bdr_face_Y);
-         }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
+         integ->AssembleDiagonalPA(diag);
       }
    }
 }
 
-void PABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
+void PABilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-   if (elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (elem_restrict && integrators.Size() > 0)
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultTransposePA(localX, localY);
+         integ->AddMultPA(local_x, local_y);
       }
-      elem_restrict->MultTranspose(localY, y);
+      elem_restrict->MultTranspose(local_y, y);
    }
    else
    {
-      y.UseDevice(true);
+      y.UseDevice(true); // typically this is a large vector, so store on device
       y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultTransposePA(x, y);
+         integ->AddMultPA(x, y);
       }
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_restrict_lex && int_face_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      int_face_restrict_lex->Mult(x, int_face_x);
+      if (int_face_x.Size() > 0)
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         int_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : int_face_integrators)
          {
-            intFaceIntegrators[i]->AddMultTransposePA(int_face_X, int_face_Y);
+            integ->AddMultPA(int_face_x, int_face_y);
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+         int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+      }
+   }
+   else
+   {
+      for (BilinearFormIntegrator *integ : int_face_integrators)
+      {
+         integ->AddMultPA(x, y);
       }
    }
 
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_face_restrict_lex && (bdr_integrators.Size() > 0 ||
+                                 bdr_face_integrators.Size() > 0))
    {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
+         bdr_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultPA(bdr_face_x, bdr_face_y);
+         }
+         for (BilinearFormIntegrator *integ : bdr_face_integrators)
          {
-            bdrFaceIntegrators[i]->AddMultTransposePA(bdr_face_X, bdr_face_Y);
+            integ->AddMultPA(bdr_face_x, bdr_face_y);
          }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
       }
    }
-}
-
-// Data and methods for element-assembled bilinear forms
-EABilinearFormExtension::EABilinearFormExtension(BilinearForm *form)
-   : PABilinearFormExtension(form),
-     factorize_face_terms(false)
-{
-   if (form->FESpace()->IsDGSpace() && form->FESpace()->Conforming())
+   else
    {
-      factorize_face_terms = true;
+      for (BilinearFormIntegrator *integ : bdr_integrators)
+      {
+         integ->AddMultPA(x, y);
+      }
+      for (BilinearFormIntegrator *integ : bdr_face_integrators)
+      {
+         integ->AddMultPA(x, y);
+      }
    }
 }
 
-void EABilinearFormExtension::Assemble()
+void PABilinearFormExtension::AddMult(const Vector &x, Vector &y,
+                                      const double c) const
 {
-   SetupRestrictionOperators(L2FaceValues::SingleValued);
-
-   ne = trial_fes->GetMesh()->GetNE();
-   elemDofs = trial_fes->GetFE(0)->GetDof();
-
-   ea_data.SetSize(ne*elemDofs*elemDofs, Device::GetMemoryType());
-   ea_data.UseDevice(true);
-
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   if ( integratorCount == 0 )
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (elem_restrict && integrators.Size() > 0)
    {
-      ea_data = 0.0;
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultPA(local_x, local_y);
+      }
+      if (c != 1.0)
+      {
+         local_y *= c;
+      }
+      elem_restrict->AddMultTranspose(local_y, y);
    }
-   for (int i = 0; i < integratorCount; ++i)
+   else
    {
-      integrators[i]->AssembleEA(*a->FESpace(), ea_data, i);
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      if (c != 1.0 && integrators.Size() > 0)
+      {
+         temp_y.SetSize(y.Size());
+         temp_y.UseDevice(true);
+         temp_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultPA(x, temp_y);
+         }
+         y.Add(c, temp_y);
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultPA(x, y);
+         }
+      }
    }
 
-   faceDofs = trial_fes ->
-              GetTraceElement(0, trial_fes->GetMesh()->GetFaceGeometry(0)) ->
-              GetDof();
-
-   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
-               "Element assembly does not support AddBoundaryIntegrator yet.");
-
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int intFaceIntegratorCount = intFaceIntegrators.Size();
-   if (intFaceIntegratorCount>0)
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_restrict_lex && int_face_integrators.Size() > 0)
    {
-      nf_int = trial_fes->GetNFbyType(FaceType::Interior);
-      ea_data_int.SetSize(2*nf_int*faceDofs*faceDofs, Device::GetMemoryType());
-      ea_data_ext.SetSize(2*nf_int*faceDofs*faceDofs, Device::GetMemoryType());
+      int_face_restrict_lex->Mult(x, int_face_x);
+      if (int_face_x.Size() > 0)
+      {
+         int_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : int_face_integrators)
+         {
+            integ->AddMultPA(int_face_x, int_face_y);
+         }
+         if (c != 1.0)
+         {
+            int_face_y *= c;
+         }
+         int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+      }
    }
-   for (int i = 0; i < intFaceIntegratorCount; ++i)
+   else
    {
-      intFaceIntegrators[i]->AssembleEAInteriorFaces(*a->FESpace(),
-                                                     ea_data_int,
-                                                     ea_data_ext,
-                                                     i);
+      if (c != 1.0 && int_face_integrators.Size() > 0)
+      {
+         temp_y.SetSize(y.Size());
+         temp_y.UseDevice(true);
+         temp_y = 0.0;
+         for (BilinearFormIntegrator *integ : int_face_integrators)
+         {
+            integ->AddMultPA(x, temp_y);
+         }
+         y.Add(c, temp_y);
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : int_face_integrators)
+         {
+            integ->AddMultPA(x, y);
+         }
+      }
    }
 
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int boundFaceIntegratorCount = bdrFaceIntegrators.Size();
-   if (boundFaceIntegratorCount>0)
-   {
-      nf_bdr = trial_fes->GetNFbyType(FaceType::Boundary);
-      ea_data_bdr.SetSize(nf_bdr*faceDofs*faceDofs, Device::GetMemoryType());
-      ea_data_bdr = 0.0;
-   }
-   for (int i = 0; i < boundFaceIntegratorCount; ++i)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_face_restrict_lex && (bdr_integrators.Size() > 0 ||
+                                 bdr_face_integrators.Size() > 0))
    {
-      bdrFaceIntegrators[i]->AssembleEABoundaryFaces(*a->FESpace(),ea_data_bdr,i);
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
+      {
+         bdr_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultPA(bdr_face_x, bdr_face_y);
+         }
+         for (BilinearFormIntegrator *integ : bdr_face_integrators)
+         {
+            integ->AddMultPA(bdr_face_x, bdr_face_y);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_y *= c;
+         }
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+      }
    }
+   else
+   {
+      if (c != 1.0 && (bdr_integrators.Size() > 0 || bdr_face_integrators.Size() > 0))
+      {
+         temp_y.SetSize(y.Size());
+         temp_y.UseDevice(true);
+         temp_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultPA(x, temp_y);
+         }
+         for (BilinearFormIntegrator *integ : bdr_face_integrators)
+         {
+            integ->AddMultPA(x, temp_y);
+         }
+         y.Add(c, temp_y);
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultPA(x, y);
+         }
+         for (BilinearFormIntegrator *integ : bdr_face_integrators)
+         {
+            integ->AddMultPA(x, y);
+         }
+      }
+   }
+}
 
-   if (factorize_face_terms && int_face_restrict_lex)
+void PABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (elem_restrict && integrators.Size() > 0)
    {
-      auto restFint = dynamic_cast<const L2FaceRestriction*>(int_face_restrict_lex);
-      restFint->AddFaceMatricesToElementMatrices(ea_data_int, ea_data);
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposePA(local_x, local_y);
+      }
+      elem_restrict->MultTranspose(local_y, y);
    }
-   if (factorize_face_terms && bdr_face_restrict_lex)
+   else
+   {
+      y.UseDevice(true);
+      y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposePA(x, y);
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_restrict_lex && int_face_integrators.Size() > 0)
    {
-      auto restFbdr = dynamic_cast<const L2FaceRestriction*>(bdr_face_restrict_lex);
-      restFbdr->AddFaceMatricesToElementMatrices(ea_data_bdr, ea_data);
+      int_face_restrict_lex->Mult(x, int_face_x);
+      if (int_face_x.Size() > 0)
+      {
+         int_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : int_face_integrators)
+         {
+            integ->AddMultTransposePA(int_face_x, int_face_y);
+         }
+         int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+      }
+   }
+   else
+   {
+      for (BilinearFormIntegrator *integ : int_face_integrators)
+      {
+         integ->AddMultTransposePA(x, y);
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_face_restrict_lex && (bdr_integrators.Size() > 0 ||
+                                 bdr_face_integrators.Size() > 0))
+   {
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
+      {
+         bdr_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+         }
+         for (BilinearFormIntegrator *integ : bdr_face_integrators)
+         {
+            integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+         }
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+      }
+   }
+   else
+   {
+      for (BilinearFormIntegrator *integ : bdr_integrators)
+      {
+         integ->AddMultTransposePA(x, y);
+      }
+      for (BilinearFormIntegrator *integ : bdr_face_integrators)
+      {
+         integ->AddMultTransposePA(x, y);
+      }
    }
 }
 
-void EABilinearFormExtension::Mult(const Vector &x, Vector &y) const
+void PABilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
+                                               const double c) const
 {
-   // Apply the Element Restriction
-   const bool useRestrict = !DeviceCanUseCeed() && elem_restrict;
-   if (!useRestrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (elem_restrict && integrators.Size() > 0)
+   {
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposePA(local_x, local_y);
+      }
+      if (c != 1.0)
+      {
+         local_y *= c;
+      }
+      elem_restrict->AddMultTranspose(local_y, y);
+   }
+   else
    {
       y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
+      if (c != 1.0 && integrators.Size() > 0)
+      {
+         temp_y.SetSize(y.Size());
+         temp_y.UseDevice(true);
+         temp_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposePA(x, temp_y);
+         }
+         y.Add(c, temp_y);
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposePA(x, y);
+         }
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_restrict_lex && int_face_integrators.Size() > 0)
+   {
+      int_face_restrict_lex->Mult(x, int_face_x);
+      if (int_face_x.Size() > 0)
+      {
+         int_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : int_face_integrators)
+         {
+            integ->AddMultTransposePA(int_face_x, int_face_y);
+         }
+         if (c != 1.0)
+         {
+            int_face_y *= c;
+         }
+         int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+      }
    }
    else
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
+      if (c != 1.0 && int_face_integrators.Size() > 0)
+      {
+         temp_y.SetSize(y.Size());
+         temp_y.UseDevice(true);
+         temp_y = 0.0;
+         for (BilinearFormIntegrator *integ : int_face_integrators)
+         {
+            integ->AddMultTransposePA(x, temp_y);
+         }
+         y.Add(c, temp_y);
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : int_face_integrators)
+         {
+            integ->AddMultTransposePA(x, y);
+         }
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_face_restrict_lex && (bdr_integrators.Size() > 0 ||
+                                 bdr_face_integrators.Size() > 0))
+   {
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
+      {
+         bdr_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+         }
+         for (BilinearFormIntegrator *integ : bdr_face_integrators)
+         {
+            integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_y *= c;
+         }
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+      }
+   }
+   else
+   {
+      if (c != 1.0 && (bdr_integrators.Size() > 0 || bdr_face_integrators.Size() > 0))
+      {
+         temp_y.SetSize(y.Size());
+         temp_y.UseDevice(true);
+         temp_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposePA(x, temp_y);
+         }
+         for (BilinearFormIntegrator *integ : bdr_face_integrators)
+         {
+            integ->AddMultTransposePA(x, temp_y);
+         }
+         y.Add(c, temp_y);
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposePA(x, y);
+         }
+         for (BilinearFormIntegrator *integ : bdr_face_integrators)
+         {
+            integ->AddMultTransposePA(x, y);
+         }
+      }
+   }
+}
+
+/// Data and methods for element-assembled bilinear forms
+EABilinearFormExtension::EABilinearFormExtension(BilinearForm *form)
+   : PABilinearFormExtension(form),
+     factorize_face_terms(fes->IsDGSpace() && fes->Conforming())
+{
+}
+
+void EABilinearFormExtension::Assemble()
+{
+   SetupRestrictionOperators(L2FaceValues::SingleValued);
+
+   ne = fes->GetNE();
+   elem_dofs = fes->GetFE(0)->GetDof();
+
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
+   {
+      ea_data.SetSize(ne * elem_dofs * elem_dofs, Device::GetMemoryType());
+      ea_data.UseDevice(true);
+      ea_data = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AssembleEA(*fes, ea_data);
+      }
+   }
+
+   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
+               "Element assembly does not support AddBoundaryIntegrator yet.");
+
+   nf_int = fes->GetNFbyType(FaceType::Interior);
+   nf_bdr = fes->GetNFbyType(FaceType::Boundary);
+   face_dofs = fes->GetTraceElement(0,
+                                    fes->GetMesh()->GetFaceGeometry(0))->GetDof();
+
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
+   {
+      ea_data_int.SetSize(2 * nf_int * face_dofs * face_dofs,
+                          Device::GetMemoryType());
+      ea_data_ext.SetSize(2 * nf_int * face_dofs * face_dofs,
+                          Device::GetMemoryType());
+      ea_data_int = 0.0;
+      ea_data_ext = 0.0;
+      for (BilinearFormIntegrator *integ : int_face_integrators)
+      {
+         integ->AssembleEAInteriorFaces(*fes, ea_data_int, ea_data_ext);
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_face_integrators.Size() > 0)
+   {
+      ea_data_bdr.SetSize(nf_bdr * face_dofs * face_dofs, Device::GetMemoryType());
+      ea_data_bdr = 0.0;
+      for (BilinearFormIntegrator *integ : bdr_face_integrators)
+      {
+         integ->AssembleEABoundaryFaces(*fes, ea_data_bdr);
+      }
+   }
+
+   if (factorize_face_terms && int_face_restrict_lex)
+   {
+      auto l2_face_restrict = dynamic_cast<const L2FaceRestriction &>
+                              (*int_face_restrict_lex);
+      l2_face_restrict.AddFaceMatricesToElementMatrices(ea_data_int, ea_data);
    }
-   // Apply the Element Matrices
+   if (factorize_face_terms && bdr_face_restrict_lex)
    {
-      const int NDOFS = elemDofs;
-      auto X = Reshape(useRestrict?localX.Read():x.Read(), NDOFS, ne);
-      auto Y = Reshape(useRestrict?localY.ReadWrite():y.ReadWrite(), NDOFS, ne);
-      auto A = Reshape(ea_data.Read(), NDOFS, NDOFS, ne);
-      mfem::forall(ne*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
+      auto l2_face_restrict = dynamic_cast<const L2FaceRestriction &>
+                              (*bdr_face_restrict_lex);
+      l2_face_restrict.AddFaceMatricesToElementMatrices(ea_data_bdr, ea_data);
+   }
+}
+
+void EABilinearFormExtension::Mult(const Vector &x, Vector &y) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   auto Apply = [](const int nelem, const int ndofs, const Vector &data,
+                   const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, nelem);
+      auto Y = Reshape(y.ReadWrite(), ndofs, nelem);
+      auto A = Reshape(data.Read(), ndofs, ndofs, nelem);
+      mfem::forall(nelem * ndofs, [=] MFEM_HOST_DEVICE (int k)
       {
-         const int e = glob_j/NDOFS;
-         const int j = glob_j%NDOFS;
+         const int e = k / ndofs;
+         const int j = k % ndofs;
          double res = 0.0;
-         for (int i = 0; i < NDOFS; i++)
+         for (int i = 0; i < ndofs; i++)
          {
-            res += A(i, j, e)*X(i, e);
+            res += A(i, j, e) * X(i, e);
          }
          Y(j, e) += res;
       });
-      // Apply the Element Restriction transposed
-      if (useRestrict)
+   };
+   if (elem_restrict)
+   {
+      if (integrators.Size() > 0)
       {
-         elem_restrict->MultTranspose(localY, y);
+         elem_restrict->Mult(x, local_x);
+         local_y = 0.0;
+         Apply(ne, elem_dofs, ea_data, local_x, local_y);
+         elem_restrict->MultTranspose(local_y, y);
+      }
+      else
+      {
+         y = 0.0;
+      }
+   }
+   else
+   {
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      y = 0.0;
+      if (integrators.Size() > 0)
+      {
+         Apply(ne, elem_dofs, ea_data, x, y);
       }
    }
 
    // Treatment of interior faces
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
-   {
-      // Apply the Interior Face Restriction
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
-      {
-         int_face_Y = 0.0;
-         // Apply the interior face matrices
-         const int NDOFS = faceDofs;
-         auto X = Reshape(int_face_X.Read(), NDOFS, 2, nf_int);
-         auto Y = Reshape(int_face_Y.ReadWrite(), NDOFS, 2, nf_int);
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   auto ApplyIntFace = [](const int nface, const int ndofs, const Vector &data,
+                          const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 0, f) * X(i, 0, f);
+         }
+         Y(j, 0, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 1, f) * X(i, 1, f);
+         }
+         Y(j, 1, f) += res;
+      });
+   };
+   auto ApplyExtFace = [](const int nface, const int ndofs, const Vector &data,
+                          const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 0, f) * X(i, 0, f);
+         }
+         Y(j, 1, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 1, f) * X(i, 1, f);
+         }
+         Y(j, 0, f) += res;
+      });
+   };
+   if (int_face_restrict_lex && int_face_integrators.Size() > 0)
+   {
+      int_face_restrict_lex->Mult(x, int_face_x);
+      if (int_face_x.Size() > 0)
+      {
+         int_face_y = 0.0;
          if (!factorize_face_terms)
          {
-            auto A_int = Reshape(ea_data_int.Read(), NDOFS, NDOFS, 2, nf_int);
-            mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-            {
-               const int f = glob_j/NDOFS;
-               const int j = glob_j%NDOFS;
-               double res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(i, j, 0, f)*X(i, 0, f);
-               }
-               Y(j, 0, f) += res;
-               res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(i, j, 1, f)*X(i, 1, f);
-               }
-               Y(j, 1, f) += res;
-            });
-         }
-         auto A_ext = Reshape(ea_data_ext.Read(), NDOFS, NDOFS, 2, nf_int);
-         mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(i, j, 0, f)*X(i, 0, f);
-            }
-            Y(j, 1, f) += res;
-            res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(i, j, 1, f)*X(i, 1, f);
-            }
-            Y(j, 0, f) += res;
-         });
-         // Apply the Interior Face Restriction transposed
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+            ApplyIntFace(nf_int, face_dofs, ea_data_int, int_face_x, int_face_y);
+         }
+         ApplyExtFace(nf_int, face_dofs, ea_data_ext, int_face_x, int_face_y);
+         int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
       }
    }
 
    // Treatment of boundary faces
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (!factorize_face_terms && bdr_face_restrict_lex && bFISz>0)
-   {
-      // Apply the Boundary Face Restriction
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
-      {
-         bdr_face_Y = 0.0;
-         // Apply the boundary face matrices
-         const int NDOFS = faceDofs;
-         auto X = Reshape(bdr_face_X.Read(), NDOFS, nf_bdr);
-         auto Y = Reshape(bdr_face_Y.ReadWrite(), NDOFS, nf_bdr);
-         auto A = Reshape(ea_data_bdr.Read(), NDOFS, NDOFS, nf_bdr);
-         mfem::forall(nf_bdr*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A(i, j, f)*X(i, f);
-            }
-            Y(j, f) += res;
-         });
-         // Apply the Boundary Face Restriction transposed
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (!factorize_face_terms && bdr_face_restrict_lex &&
+       bdr_face_integrators.Size() > 0)
+   {
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
+      {
+         bdr_face_y = 0.0;
+         Apply(nf_bdr, face_dofs, ea_data_bdr, bdr_face_x, bdr_face_y);
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
       }
    }
 }
 
 void EABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 {
-   // Apply the Element Restriction
-   const bool useRestrict = !DeviceCanUseCeed() && elem_restrict;
-   if (!useRestrict)
-   {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-   }
-   else
-   {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-   }
-   // Apply the Element Matrices transposed
-   {
-      const int NDOFS = elemDofs;
-      auto X = Reshape(useRestrict?localX.Read():x.Read(), NDOFS, ne);
-      auto Y = Reshape(useRestrict?localY.ReadWrite():y.ReadWrite(), NDOFS, ne);
-      auto A = Reshape(ea_data.Read(), NDOFS, NDOFS, ne);
-      mfem::forall(ne*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   auto ApplyTranspose = [](const int nelem, const int ndofs, const Vector &data,
+                            const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, nelem);
+      auto Y = Reshape(y.ReadWrite(), ndofs, nelem);
+      auto A = Reshape(data.Read(), ndofs, ndofs, nelem);
+      mfem::forall(nelem * ndofs, [=] MFEM_HOST_DEVICE (int k)
       {
-         const int e = glob_j/NDOFS;
-         const int j = glob_j%NDOFS;
+         const int e = k / ndofs;
+         const int j = k % ndofs;
          double res = 0.0;
-         for (int i = 0; i < NDOFS; i++)
+         for (int i = 0; i < ndofs; i++)
          {
-            res += A(j, i, e)*X(i, e);
+            res += A(j, i, e) * X(i, e);
          }
          Y(j, e) += res;
       });
-      // Apply the Element Restriction transposed
-      if (useRestrict)
+   };
+   if (elem_restrict)
+   {
+      if (integrators.Size() > 0)
+      {
+         elem_restrict->Mult(x, local_x);
+         local_y = 0.0;
+         ApplyTranspose(ne, elem_dofs, ea_data, local_x, local_y);
+         elem_restrict->MultTranspose(local_y, y);
+      }
+      else
       {
-         elem_restrict->MultTranspose(localY, y);
+         y = 0.0;
+      }
+   }
+   else
+   {
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      y = 0.0;
+      if (integrators.Size() > 0)
+      {
+         ApplyTranspose(ne, elem_dofs, ea_data, x, y);
       }
    }
 
    // Treatment of interior faces
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
-   {
-      // Apply the Interior Face Restriction
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
-      {
-         int_face_Y = 0.0;
-         // Apply the interior face matrices transposed
-         const int NDOFS = faceDofs;
-         auto X = Reshape(int_face_X.Read(), NDOFS, 2, nf_int);
-         auto Y = Reshape(int_face_Y.ReadWrite(), NDOFS, 2, nf_int);
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   auto ApplyIntFaceTranspose = [](const int nface, const int ndofs,
+                                   const Vector &data, const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 0, f) * X(i, 0, f);
+         }
+         Y(j, 0, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 1, f) * X(i, 1, f);
+         }
+         Y(j, 1, f) += res;
+      });
+   };
+   auto ApplyExtFaceTranspose = [](const int nface, const int ndofs,
+                                   const Vector &data, const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 1, f) * X(i, 0, f);
+         }
+         Y(j, 1, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 0, f) * X(i, 1, f);
+         }
+         Y(j, 0, f) += res;
+      });
+   };
+   if (int_face_restrict_lex && int_face_integrators.Size() > 0)
+   {
+      int_face_restrict_lex->Mult(x, int_face_x);
+      if (int_face_x.Size() > 0)
+      {
+         int_face_y = 0.0;
          if (!factorize_face_terms)
          {
-            auto A_int = Reshape(ea_data_int.Read(), NDOFS, NDOFS, 2, nf_int);
-            mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-            {
-               const int f = glob_j/NDOFS;
-               const int j = glob_j%NDOFS;
-               double res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(j, i, 0, f)*X(i, 0, f);
-               }
-               Y(j, 0, f) += res;
-               res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(j, i, 1, f)*X(i, 1, f);
-               }
-               Y(j, 1, f) += res;
-            });
-         }
-         auto A_ext = Reshape(ea_data_ext.Read(), NDOFS, NDOFS, 2, nf_int);
-         mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(j, i, 1, f)*X(i, 0, f);
-            }
-            Y(j, 1, f) += res;
-            res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(j, i, 0, f)*X(i, 1, f);
-            }
-            Y(j, 0, f) += res;
-         });
-         // Apply the Interior Face Restriction transposed
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+            ApplyIntFaceTranspose(nf_int, face_dofs, ea_data_int, int_face_x, int_face_y);
+         }
+         ApplyExtFaceTranspose(nf_int, face_dofs, ea_data_ext, int_face_x, int_face_y);
+         int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
       }
    }
 
    // Treatment of boundary faces
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (!factorize_face_terms && bdr_face_restrict_lex && bFISz>0)
-   {
-      // Apply the Boundary Face Restriction
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
-      {
-         bdr_face_Y = 0.0;
-         // Apply the boundary face matrices transposed
-         const int NDOFS = faceDofs;
-         auto X = Reshape(bdr_face_X.Read(), NDOFS, nf_bdr);
-         auto Y = Reshape(bdr_face_Y.ReadWrite(), NDOFS, nf_bdr);
-         auto A = Reshape(ea_data_bdr.Read(), NDOFS, NDOFS, nf_bdr);
-         mfem::forall(nf_bdr*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A(j, i, f)*X(i, f);
-            }
-            Y(j, f) += res;
-         });
-         // Apply the Boundary Face Restriction transposed
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (!factorize_face_terms && bdr_face_restrict_lex &&
+       bdr_face_integrators.Size() > 0)
+   {
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
+      {
+         bdr_face_y = 0.0;
+         ApplyTranspose(nf_bdr, face_dofs, ea_data_bdr, bdr_face_x, bdr_face_y);
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
       }
    }
 }
 
-// Data and methods for fully-assembled bilinear forms
+/// Data and methods for fully-assembled bilinear forms
 FABilinearFormExtension::FABilinearFormExtension(BilinearForm *form)
    : EABilinearFormExtension(form),
      mat(a->mat)
 {
 #ifdef MFEM_USE_MPI
-   ParFiniteElementSpace *pfes = nullptr;
-   if ( a->GetFBFI()->Size()>0 &&
-        (pfes = dynamic_cast<ParFiniteElementSpace*>(form->FESpace())) )
+   const ParFiniteElementSpace *pfes = nullptr;
+   if (a->GetFBFI()->Size() > 0 &&
+       (pfes = dynamic_cast<const ParFiniteElementSpace *>(form->FESpace())))
    {
-      pfes->ExchangeFaceNbrData();
+      const_cast<ParFiniteElementSpace *>(pfes)->ExchangeFaceNbrData();
    }
 #endif
 }
@@ -850,20 +1264,20 @@ FABilinearFormExtension::FABilinearFormExtension(BilinearForm *form)
 void FABilinearFormExtension::Assemble()
 {
    EABilinearFormExtension::Assemble();
-   FiniteElementSpace &fes = *a->FESpace();
-   int width = fes.GetVSize();
-   int height = fes.GetVSize();
+
+   int width = fes->GetVSize();
+   int height = fes->GetVSize();
    bool keep_nbr_block = false;
 #ifdef MFEM_USE_MPI
-   ParFiniteElementSpace *pfes = nullptr;
-   if ( a->GetFBFI()->Size()>0 &&
-        (pfes = dynamic_cast<ParFiniteElementSpace*>(&fes)) )
+   const ParFiniteElementSpace *pfes = nullptr;
+   if (a->GetFBFI()->Size() > 0 &&
+       (pfes = dynamic_cast<const ParFiniteElementSpace *>(fes)))
    {
-      pfes->ExchangeFaceNbrData();
+      const_cast<ParFiniteElementSpace *>(pfes)->ExchangeFaceNbrData();
       width += pfes->GetFaceNbrVSize();
       dg_x.SetSize(width);
       ParBilinearForm *pb = nullptr;
-      if ((pb = dynamic_cast<ParBilinearForm*>(a)) && (pb->keep_nbr_block))
+      if ((pb = dynamic_cast<ParBilinearForm *>(a)) && pb->keep_nbr_block)
       {
          height += pfes->GetFaceNbrVSize();
          dg_y.SetSize(height);
@@ -873,15 +1287,14 @@ void FABilinearFormExtension::Assemble()
 #endif
    if (a->mat) // We reuse the sparse matrix memory
    {
-      if (fes.IsDGSpace())
+      if (fes->IsDGSpace())
       {
-         const L2ElementRestriction *restE =
-            static_cast<const L2ElementRestriction*>(elem_restrict);
-         const L2FaceRestriction *restF =
-            static_cast<const L2FaceRestriction*>(int_face_restrict_lex);
-         MFEM_VERIFY(
-            fes.Conforming(),
-            "Full Assembly not yet supported on NCMesh.");
+         const auto *restE =
+            static_cast<const L2ElementRestriction *>(elem_restrict);
+         const auto *restF =
+            static_cast<const L2FaceRestriction *>(int_face_restrict_lex);
+         MFEM_VERIFY(fes->Conforming(),
+                     "Full Assembly not yet supported on NCMesh.");
          // 1. Fill J and Data
          // 1.1 Fill J and Data with Elem ea_data
          restE->FillJAndData(ea_data, *mat);
@@ -897,8 +1310,8 @@ void FABilinearFormExtension::Assemble()
       }
       else
       {
-         const ElementRestriction &rest =
-            static_cast<const ElementRestriction&>(*elem_restrict);
+         const auto &rest =
+            static_cast<const ConformingElementRestriction&>(*elem_restrict);
          rest.FillJAndData(ea_data, *mat);
       }
    }
@@ -906,15 +1319,14 @@ void FABilinearFormExtension::Assemble()
    {
       mat = new SparseMatrix;
       mat->OverrideSize(height, width);
-      if (fes.IsDGSpace())
-      {
-         const L2ElementRestriction *restE =
-            static_cast<const L2ElementRestriction*>(elem_restrict);
-         const L2FaceRestriction *restF =
-            static_cast<const L2FaceRestriction*>(int_face_restrict_lex);
-         MFEM_VERIFY(
-            fes.Conforming(),
-            "Full Assembly not yet supported on NCMesh.");
+      if (fes->IsDGSpace())
+      {
+         const auto *restE =
+            static_cast<const L2ElementRestriction *>(elem_restrict);
+         const auto *restF =
+            static_cast<const L2FaceRestriction *>(int_face_restrict_lex);
+         MFEM_VERIFY(fes->Conforming(),
+                     "Full Assembly not yet supported on NCMesh.");
          // 1. Fill I
          mat->GetMemoryI().New(height+1, mat->GetMemoryI().GetMemoryType());
          //  1.1 Increment with restE
@@ -947,87 +1359,32 @@ void FABilinearFormExtension::Assemble()
          }
          I[0] = 0;
       }
-      else // continuous Galerkin case
+      else
       {
-         const ElementRestriction &rest =
-            static_cast<const ElementRestriction&>(*elem_restrict);
+         const auto &rest =
+            static_cast<const ConformingElementRestriction &>(*elem_restrict);
          rest.FillSparseMatrix(ea_data, *mat);
       }
       a->mat = mat;
    }
-   if ( a->sort_sparse_matrix )
+   if (a->sort_sparse_matrix)
    {
       a->mat->SortColumnIndices();
    }
 }
 
-
-void FABilinearFormExtension::RAP(OperatorHandle &A)
-{
-#ifdef MFEM_USE_MPI
-   if ( auto pa = dynamic_cast<ParBilinearForm*>(a) )
-   {
-      pa->ParallelRAP(*pa->mat, A);
-   }
-   else
-#endif
-   {
-      a->SerialRAP(A);
-   }
-}
-
-void FABilinearFormExtension::EliminateBC(const Array<int> &ess_dofs,
-                                          OperatorHandle &A)
-{
-   MFEM_VERIFY(a->diag_policy == DiagonalPolicy::DIAG_ONE,
-               "Only DiagonalPolicy::DIAG_ONE supported with"
-               " FABilinearFormExtension.");
-#ifdef MFEM_USE_MPI
-   if ( dynamic_cast<ParBilinearForm*>(a) )
-   {
-      A.As<HypreParMatrix>()->EliminateBC(ess_dofs,
-                                          DiagonalPolicy::DIAG_ONE);
-   }
-   else
-#endif
-   {
-      A.As<SparseMatrix>()->EliminateBC(ess_dofs,
-                                        DiagonalPolicy::DIAG_ONE);
-   }
-}
-
-void FABilinearFormExtension::FormSystemMatrix(const Array<int> &ess_dofs,
-                                               OperatorHandle &A)
-{
-   RAP(A);
-   EliminateBC(ess_dofs, A);
-}
-
-void FABilinearFormExtension::FormLinearSystem(const Array<int> &ess_tdof_list,
-                                               Vector &x, Vector &b,
-                                               OperatorHandle &A,
-                                               Vector &X, Vector &B,
-                                               int copy_interior)
-{
-   Operator *A_out;
-   Operator::FormLinearSystem(ess_tdof_list, x, b, A_out, X, B, copy_interior);
-   delete A_out;
-   FormSystemMatrix(ess_tdof_list, A);
-}
-
 void FABilinearFormExtension::DGMult(const Vector &x, Vector &y) const
 {
 #ifdef MFEM_USE_MPI
-   const ParFiniteElementSpace *pfes;
-   if ( (pfes = dynamic_cast<const ParFiniteElementSpace*>(test_fes)) )
+   if (const auto pfes = dynamic_cast<const ParFiniteElementSpace *>(fes))
    {
       // DG Prolongation
       ParGridFunction x_gf;
-      x_gf.MakeRef(const_cast<ParFiniteElementSpace*>(pfes),
-                   const_cast<Vector&>(x),0);
+      x_gf.MakeRef(const_cast<ParFiniteElementSpace *>(pfes),
+                   const_cast<Vector &>(x), 0);
       x_gf.ExchangeFaceNbrData();
       Vector &shared_x = x_gf.FaceNbrData();
-      const int local_size = a->FESpace()->GetVSize();
+      const int local_size = fes->GetVSize();
       auto dg_x_ptr = dg_x.Write();
       auto x_ptr = x.Read();
       mfem::forall(local_size, [=] MFEM_HOST_DEVICE (int i)
@@ -1040,8 +1397,8 @@ void FABilinearFormExtension::DGMult(const Vector &x, Vector &y) const
       {
          dg_x_ptr[local_size+i] = shared_x_ptr[i];
       });
-      ParBilinearForm *pform = nullptr;
-      if ((pform = dynamic_cast<ParBilinearForm*>(a)) && (pform->keep_nbr_block))
+      ParBilinearForm *pb = nullptr;
+      if ((pb = dynamic_cast<ParBilinearForm *>(a)) && pb->keep_nbr_block)
       {
          mat->Mult(dg_x, dg_y);
          // DG Restriction
@@ -1066,7 +1423,7 @@ void FABilinearFormExtension::DGMult(const Vector &x, Vector &y) const
 
 void FABilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   if ( a->GetFBFI()->Size()>0 )
+   if (a->GetFBFI()->Size() > 0)
    {
       DGMult(x, y);
    }
@@ -1079,16 +1436,15 @@ void FABilinearFormExtension::Mult(const Vector &x, Vector &y) const
 void FABilinearFormExtension::DGMultTranspose(const Vector &x, Vector &y) const
 {
 #ifdef MFEM_USE_MPI
-   const ParFiniteElementSpace *pfes;
-   if ( (pfes = dynamic_cast<const ParFiniteElementSpace*>(test_fes)) )
+   if (const auto pfes = dynamic_cast<const ParFiniteElementSpace *>(fes))
    {
       // DG Prolongation
       ParGridFunction x_gf;
-      x_gf.MakeRef(const_cast<ParFiniteElementSpace*>(pfes),
-                   const_cast<Vector&>(x),0);
+      x_gf.MakeRef(const_cast<ParFiniteElementSpace *>(pfes),
+                   const_cast<Vector &>(x), 0);
       x_gf.ExchangeFaceNbrData();
       Vector &shared_x = x_gf.FaceNbrData();
-      const int local_size = a->FESpace()->GetVSize();
+      const int local_size = fes->GetVSize();
       auto dg_x_ptr = dg_x.Write();
       auto x_ptr = x.Read();
       mfem::forall(local_size, [=] MFEM_HOST_DEVICE (int i)
@@ -1102,7 +1458,7 @@ void FABilinearFormExtension::DGMultTranspose(const Vector &x, Vector &y) const
          dg_x_ptr[local_size+i] = shared_x_ptr[i];
       });
       ParBilinearForm *pb = nullptr;
-      if ((pb = dynamic_cast<ParBilinearForm*>(a)) && (pb->keep_nbr_block))
+      if ((pb = dynamic_cast<ParBilinearForm *>(a)) && (pb->keep_nbr_block))
       {
          mat->MultTranspose(dg_x, dg_y);
          // DG Restriction
@@ -1127,7 +1483,7 @@ void FABilinearFormExtension::DGMultTranspose(const Vector &x, Vector &y) const
 
 void FABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 {
-   if ( a->GetFBFI()->Size()>0 )
+   if (a->GetFBFI()->Size() > 0)
    {
       DGMultTranspose(x, y);
    }
@@ -1138,10 +1494,10 @@ void FABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 }
 
 
+/// Base class for extensions to the MixedBilinearForm class
 MixedBilinearFormExtension::MixedBilinearFormExtension(MixedBilinearForm *form)
    : Operator(form->Height(), form->Width()), a(form)
 {
-   // empty
 }
 
 const Operator *MixedBilinearFormExtension::GetProlongation() const
@@ -1164,377 +1520,690 @@ const Operator *MixedBilinearFormExtension::GetOutputRestriction() const
    return a->GetOutputRestriction();
 }
 
-// Data and methods for partially-assembled bilinear forms
-
-PAMixedBilinearFormExtension::PAMixedBilinearFormExtension(
+/// Data and methods for matrix-free mixed bilinear forms
+MFMixedBilinearFormExtension::MFMixedBilinearFormExtension(
    MixedBilinearForm *form)
-   : MixedBilinearFormExtension(form),
-     trial_fes(form->TrialFESpace()),
-     test_fes(form->TestFESpace()),
-     elem_restrict_trial(NULL),
-     elem_restrict_test(NULL)
+   : MixedBilinearFormExtension(form)
 {
    Update();
 }
 
-void PAMixedBilinearFormExtension::Assemble()
+void MFMixedBilinearFormExtension::SetupRestrictionOperators(
+   const L2FaceValues m)
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
+   if (DeviceCanUseCeed()) { return; }
+   ElementDofOrdering trial_ordering = UsesTensorBasis(*trial_fes) ?
+                                       ElementDofOrdering::LEXICOGRAPHIC :
+                                       ElementDofOrdering::NATIVE;
+   ElementDofOrdering test_ordering = UsesTensorBasis(*test_fes) ?
+                                      ElementDofOrdering::LEXICOGRAPHIC :
+                                      ElementDofOrdering::NATIVE;
+   elem_restrict_trial = trial_fes->GetElementRestriction(trial_ordering);
+   elem_restrict_test = test_fes->GetElementRestriction(test_ordering);
+   if (elem_restrict_trial)
    {
-      integrators[i]->AssemblePA(*trial_fes, *test_fes);
+      local_trial.SetSize(elem_restrict_trial->Height(),
+                          Device::GetDeviceMemoryType());
+      local_trial.UseDevice(true); // ensure 'local_trial = 0.0' is done on device
+   }
+   if (elem_restrict_test)
+   {
+      local_test.SetSize(elem_restrict_test->Height(),
+                         Device::GetDeviceMemoryType());
+      local_test.UseDevice(true); // ensure 'local_test = 0.0' is done on device
+   }
+
+   // Construct face restriction operators only if the bilinear form has
+   // interior or boundary face integrators
+   if (a->GetTFBFI()->Size() > 0)
+   {
+      if (int_face_restrict_lex_trial == nullptr)
+      {
+         int_face_restrict_lex_trial = trial_fes->GetFaceRestriction(
+                                          ElementDofOrdering::LEXICOGRAPHIC,
+                                          FaceType::Interior);
+         int_face_trial.SetSize(int_face_restrict_lex_trial->Height(),
+                                Device::GetDeviceMemoryType());
+         int_face_trial.UseDevice(true);
+      }
+      if (int_face_restrict_lex_test == nullptr)
+      {
+         int_face_restrict_lex_test = test_fes->GetFaceRestriction(
+                                         ElementDofOrdering::LEXICOGRAPHIC,
+                                         FaceType::Interior);
+         int_face_test.SetSize(int_face_restrict_lex_test->Height(),
+                               Device::GetDeviceMemoryType());
+         int_face_test.UseDevice(true);
+      }
+   }
+
+   const bool has_bdr_integs = (a->GetBTFBFI()->Size() > 0 ||
+                                a->GetBBFI()->Size() > 0);
+   if (has_bdr_integs)
+   {
+      if (bdr_face_restrict_lex_trial == nullptr)
+      {
+         bdr_face_restrict_lex_trial = trial_fes->GetFaceRestriction(
+                                          ElementDofOrdering::LEXICOGRAPHIC,
+                                          FaceType::Boundary,
+                                          m);
+         bdr_face_trial.SetSize(bdr_face_restrict_lex_trial->Height(),
+                                Device::GetDeviceMemoryType());
+         bdr_face_trial.UseDevice(true);
+      }
+      if (bdr_face_restrict_lex_test == nullptr)
+      {
+         bdr_face_restrict_lex_test = test_fes->GetFaceRestriction(
+                                         ElementDofOrdering::LEXICOGRAPHIC,
+                                         FaceType::Boundary,
+                                         m);
+         bdr_face_test.SetSize(bdr_face_restrict_lex_test->Height(),
+                               Device::GetDeviceMemoryType());
+         bdr_face_test.UseDevice(true);
+      }
    }
-   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
-               "Partial assembly does not support AddBoundaryIntegrator yet.");
-   MFEM_VERIFY(a->GetTFBFI()->Size() == 0,
-               "Partial assembly does not support AddTraceFaceIntegrator yet.");
-   MFEM_VERIFY(a->GetBTFBFI()->Size() == 0,
-               "Partial assembly does not support AddBdrTraceFaceIntegrator yet.");
 }
 
-void PAMixedBilinearFormExtension::Update()
+void MFMixedBilinearFormExtension::Assemble()
 {
-   trial_fes = a->TrialFESpace();
-   test_fes  = a->TestFESpace();
-   height = test_fes->GetVSize();
-   width = trial_fes->GetVSize();
-   elem_restrict_trial = trial_fes->GetElementRestriction(
-                            ElementDofOrdering::LEXICOGRAPHIC);
-   elem_restrict_test  =  test_fes->GetElementRestriction(
-                             ElementDofOrdering::LEXICOGRAPHIC);
-   if (elem_restrict_trial)
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
+
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
    {
-      localTrial.UseDevice(true);
-      localTrial.SetSize(elem_restrict_trial->Height(),
-                         Device::GetMemoryType());
+      integ->AssembleMF(*trial_fes, *test_fes);
    }
-   if (elem_restrict_test)
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
    {
-      localTest.UseDevice(true); // ensure 'localY = 0.0' is done on device
-      localTest.SetSize(elem_restrict_test->Height(), Device::GetMemoryType());
+      integ->AssembleMFBoundary(*trial_fes, *test_fes);
    }
-}
 
-void PAMixedBilinearFormExtension::FormRectangularSystemOperator(
-   const Array<int> &trial_tdof_list,
-   const Array<int> &test_tdof_list,
-   OperatorHandle &A)
-{
-   Operator * oper;
-   Operator::FormRectangularSystemOperator(trial_tdof_list, test_tdof_list,
-                                           oper);
-   A.Reset(oper); // A will own oper
+   MFEM_VERIFY(a->GetTFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in MFMixedBilinearFormExtension");
+
+   MFEM_VERIFY(a->GetBTFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in MFMixedBilinearFormExtension");
 }
 
-void PAMixedBilinearFormExtension::FormRectangularLinearSystem(
-   const Array<int> &trial_tdof_list,
-   const Array<int> &test_tdof_list,
-   Vector &x, Vector &b,
-   OperatorHandle &A,
-   Vector &X, Vector &B)
+void MFMixedBilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   Operator *oper;
-   Operator::FormRectangularLinearSystem(trial_tdof_list, test_tdof_list, x, b,
-                                         oper, X, B);
-   A.Reset(oper); // A will own oper
+   y = 0.0;
+   AddMult(x, y);
 }
 
-void PAMixedBilinearFormExtension::SetupMultInputs(
-   const Operator *elem_restrict_x,
-   const Vector &x,
-   Vector &localX,
-   const Operator *elem_restrict_y,
-   Vector &y,
-   Vector &localY,
-   const double c) const
+void MFMixedBilinearFormExtension::AddMult(const Vector &x, Vector &y,
+                                           const double c) const
 {
-   // * G operation: localX = c*local(x)
-   if (elem_restrict_x)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (elem_restrict_trial && integrators.Size() > 0)
+   {
+      elem_restrict_trial->Mult(x, local_trial);
+   }
+   if (elem_restrict_test && integrators.Size() > 0)
    {
-      elem_restrict_x->Mult(x, localX);
+      local_test = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultMF(elem_restrict_trial ? local_trial : x, local_test);
+      }
       if (c != 1.0)
       {
-         localX *= c;
+         local_test *= c;
       }
+      elem_restrict_test->AddMultTranspose(local_test, y);
    }
    else
    {
-      if (c == 1.0)
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      if (c != 1.0 && integrators.Size() > 0)
       {
-         localX.SyncAliasMemory(x);
+         temp_test.SetSize(y.Size());
+         temp_test.UseDevice(true);
+         temp_test = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultMF(elem_restrict_trial ? local_trial : x, temp_test);
+         }
+         y.Add(c, temp_test);
       }
       else
       {
-         localX.Set(c, x);
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultMF(elem_restrict_trial ? local_trial : x, y);
+         }
       }
    }
-   if (elem_restrict_y)
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_face_restrict_lex_trial && bdr_integrators.Size() > 0)
+   {
+      bdr_face_restrict_lex_trial->Mult(x, bdr_face_trial);
+   }
+   if (bdr_face_restrict_lex_test && bdr_integrators.Size() > 0)
    {
-      localY = 0.0;
+      bdr_face_test = 0.0;
+      for (BilinearFormIntegrator *integ : bdr_integrators)
+      {
+         integ->AddMultMF(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                          bdr_face_test);
+      }
+      if (c != 1.0)
+      {
+         bdr_face_test *= c;
+      }
+      bdr_face_restrict_lex_test->AddMultTranspose(bdr_face_test, y);
    }
    else
    {
-      y.UseDevice(true);
-      localY.SyncAliasMemory(y);
+      if (c != 1.0 && bdr_integrators.Size() > 0)
+      {
+         temp_test.SetSize(y.Size());
+         temp_test.UseDevice(true);
+         temp_test = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultMF(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                             temp_test);
+         }
+         y.Add(c, temp_test);
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultMF(bdr_face_restrict_lex_trial ? bdr_face_trial : x, y);
+         }
+      }
    }
 }
 
-void PAMixedBilinearFormExtension::Mult(const Vector &x, Vector &y) const
+void MFMixedBilinearFormExtension::MultTranspose(const Vector &x,
+                                                 Vector &y) const
 {
    y = 0.0;
-   AddMult(x, y);
+   AddMultTranspose(x, y);
 }
 
-void PAMixedBilinearFormExtension::AddMult(const Vector &x, Vector &y,
-                                           const double c) const
+void MFMixedBilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
+                                                    const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // * G operation
-   SetupMultInputs(elem_restrict_trial, x, localTrial,
-                   elem_restrict_test, y, localTest, c);
-
-   // * B^TDB operation
-   for (int i = 0; i < iSz; ++i)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      integrators[i]->AddMultPA(localTrial, localTest);
+      if (elem_restrict_test)
+      {
+         elem_restrict_test->Mult(x, local_test);
+      }
+      if (elem_restrict_trial)
+      {
+         local_trial = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposeMF(elem_restrict_test ? local_test : x,
+                                      local_trial);
+         }
+         if (c != 1.0)
+         {
+            local_trial *= c;
+         }
+         elem_restrict_trial->AddMultTranspose(local_trial, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_trial.SetSize(y.Size());
+            temp_trial.UseDevice(true);
+            temp_trial = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(elem_restrict_test ? local_test : x,
+                                         temp_trial);
+            }
+            y.Add(c, temp_trial);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(elem_restrict_test ? local_test : x, y);
+            }
+         }
+      }
    }
 
-   // * G^T operation
-   if (elem_restrict_test)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_face_restrict_lex_test && bdr_integrators.Size() > 0)
+   {
+      bdr_face_restrict_lex_test->Mult(x, bdr_face_test);
+   }
+   if (bdr_face_restrict_lex_trial && bdr_integrators.Size() > 0)
+   {
+      bdr_face_trial = 0.0;
+      for (BilinearFormIntegrator *integ : bdr_integrators)
+      {
+         integ->AddMultTransposeMF(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                   bdr_face_trial);
+      }
+      if (c != 1.0)
+      {
+         bdr_face_trial *= c;
+      }
+      bdr_face_restrict_lex_trial->AddMultTranspose(bdr_face_trial, y);
+   }
+   else
    {
-      tempY.SetSize(y.Size());
-      elem_restrict_test->MultTranspose(localTest, tempY);
-      y += tempY;
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      if (c != 1.0 && bdr_integrators.Size() > 0)
+      {
+         temp_trial.SetSize(y.Size());
+         temp_trial.UseDevice(true);
+         temp_trial = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposeMF(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                      temp_trial);
+         }
+         y.Add(c, temp_trial);
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposeMF(bdr_face_restrict_lex_test ? bdr_face_test : x, y);
+         }
+      }
    }
 }
 
-void PAMixedBilinearFormExtension::MultTranspose(const Vector &x,
-                                                 Vector &y) const
+void MFMixedBilinearFormExtension::Update()
 {
-   y = 0.0;
-   AddMultTranspose(x, y);
+   trial_fes = a->TrialFESpace();
+   test_fes  = a->TestFESpace();
+   height = test_fes->GetVSize();
+   width  = trial_fes->GetVSize();
+
+   elem_restrict_trial = nullptr;
+   elem_restrict_test = nullptr;
+   int_face_restrict_lex_trial = nullptr;
+   int_face_restrict_lex_test = nullptr;
+   bdr_face_restrict_lex_trial = nullptr;
+   bdr_face_restrict_lex_test = nullptr;
 }
 
-void PAMixedBilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
-                                                    const double c) const
+/// Data and methods for partially-assembled mixed bilinear forms
+PAMixedBilinearFormExtension::PAMixedBilinearFormExtension(
+   MixedBilinearForm *form)
+   : MFMixedBilinearFormExtension(form)
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
+}
 
-   // * G operation
-   SetupMultInputs(elem_restrict_test, x, localTest,
-                   elem_restrict_trial, y, localTrial, c);
+void PAMixedBilinearFormExtension::Assemble()
+{
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
 
-   // * B^TD^TB operation
-   for (int i = 0; i < iSz; ++i)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
    {
-      integrators[i]->AddMultTransposePA(localTest, localTrial);
+      integ->AssemblePA(*trial_fes, *test_fes);
    }
 
-   // * G^T operation
-   if (elem_restrict_trial)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
    {
-      tempY.SetSize(y.Size());
-      elem_restrict_trial->MultTranspose(localTrial, tempY);
-      y += tempY;
+      integ->AssemblePABoundary(*trial_fes, *test_fes);
    }
+
+   MFEM_VERIFY(a->GetTFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in PAMixedBilinearFormExtension");
+
+   MFEM_VERIFY(a->GetBTFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in PAMixedBilinearFormExtension");
 }
 
 void PAMixedBilinearFormExtension::AssembleDiagonal_ADAt(const Vector &D,
                                                          Vector &diag) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (elem_restrict_trial && integrators.Size() > 0)
+   {
+      elem_restrict_trial->MultUnsigned(D, local_trial);
+   }
+   if (elem_restrict_test && integrators.Size() > 0)
+   {
+      local_test = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AssembleDiagonalPA_ADAt(elem_restrict_trial ? local_trial : D,
+                                        local_test);
+      }
+      elem_restrict_test->MultTransposeUnsigned(local_test, diag);
+   }
+   else
+   {
+      diag.UseDevice(true); // typically this is a large vector, so store on device
+      diag = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AssembleDiagonalPA_ADAt(elem_restrict_trial ? local_trial : D, diag);
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_face_restrict_lex_trial && bdr_integrators.Size() > 0)
+   {
+      bdr_face_restrict_lex_trial->MultUnsigned(D, bdr_face_trial);
+   }
+   if (bdr_face_restrict_lex_test && bdr_integrators.Size() > 0)
+   {
+      bdr_face_test = 0.0;
+      for (BilinearFormIntegrator *integ : bdr_integrators)
+      {
+         integ->AssembleDiagonalPA_ADAt(bdr_face_restrict_lex_trial ? bdr_face_trial : D,
+                                        bdr_face_test);
+      }
+      bdr_face_restrict_lex_test->AddMultTransposeUnsigned(bdr_face_test, diag);
+   }
+   else
+   {
+      for (BilinearFormIntegrator *integ : bdr_integrators)
+      {
+         integ->AssembleDiagonalPA_ADAt(bdr_face_restrict_lex_trial ? bdr_face_trial : D,
+                                        diag);
+      }
+   }
+}
 
-   const int iSz = integrators.Size();
+void PAMixedBilinearFormExtension::AddMult(const Vector &x, Vector &y,
+                                           const double c) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (elem_restrict_trial && integrators.Size() > 0)
+   {
+      elem_restrict_trial->Mult(x, local_trial);
+   }
+   if (elem_restrict_test && integrators.Size() > 0)
+   {
+      local_test = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultPA(elem_restrict_trial ? local_trial : x, local_test);
+      }
+      if (c != 1.0)
+      {
+         local_test *= c;
+      }
+      elem_restrict_test->AddMultTranspose(local_test, y);
+   }
+   else
+   {
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      if (c != 1.0 && integrators.Size() > 0)
+      {
+         temp_test.SetSize(y.Size());
+         temp_test.UseDevice(true);
+         temp_test = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultPA(elem_restrict_trial ? local_trial : x, temp_test);
+         }
+         y.Add(c, temp_test);
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultPA(elem_restrict_trial ? local_trial : x, y);
+         }
+      }
+   }
 
-   if (elem_restrict_trial)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_face_restrict_lex_trial && bdr_integrators.Size() > 0)
    {
-      const ElementRestriction* H1elem_restrict_trial =
-         dynamic_cast<const ElementRestriction*>(elem_restrict_trial);
-      if (H1elem_restrict_trial)
+      bdr_face_restrict_lex_trial->Mult(x, bdr_face_trial);
+   }
+   if (bdr_face_restrict_lex_test && bdr_integrators.Size() > 0)
+   {
+      bdr_face_test = 0.0;
+      for (BilinearFormIntegrator *integ : bdr_integrators)
+      {
+         integ->AddMultPA(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                          bdr_face_test);
+      }
+      if (c != 1.0)
+      {
+         bdr_face_test *= c;
+      }
+      bdr_face_restrict_lex_test->AddMultTranspose(bdr_face_test, y);
+   }
+   else
+   {
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      if (c != 1.0 && bdr_integrators.Size() > 0)
       {
-         H1elem_restrict_trial->MultUnsigned(D, localTrial);
+         temp_test.SetSize(y.Size());
+         temp_test.UseDevice(true);
+         temp_test = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultPA(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                             temp_test);
+         }
+         y.Add(c, temp_test);
       }
       else
       {
-         elem_restrict_trial->Mult(D, localTrial);
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultPA(bdr_face_restrict_lex_trial ? bdr_face_trial : x, y);
+         }
       }
    }
+}
 
-   if (elem_restrict_test)
+void PAMixedBilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
+                                                    const double c) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      localTest = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      if (elem_restrict_test)
+      {
+         elem_restrict_test->Mult(x, local_test);
+      }
+      if (elem_restrict_trial)
+      {
+         local_trial = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposePA(elem_restrict_test ? local_test : x,
+                                      local_trial);
+         }
+         if (c != 1.0)
+         {
+            local_trial *= c;
+         }
+         elem_restrict_trial->AddMultTranspose(local_trial, y);
+      }
+      else
       {
-         if (elem_restrict_trial)
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(localTrial, localTest);
+            temp_trial.SetSize(y.Size());
+            temp_trial.UseDevice(true);
+            temp_trial = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(elem_restrict_test ? local_test : x,
+                                         temp_trial);
+            }
+            y.Add(c, temp_trial);
          }
          else
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(D, localTest);
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(elem_restrict_test ? local_test : x, y);
+            }
          }
       }
-      const ElementRestriction* H1elem_restrict_test =
-         dynamic_cast<const ElementRestriction*>(elem_restrict_test);
-      if (H1elem_restrict_test)
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_face_restrict_lex_test && bdr_integrators.Size() > 0)
+   {
+      bdr_face_restrict_lex_test->Mult(x, bdr_face_test);
+   }
+   if (bdr_face_restrict_lex_trial && bdr_integrators.Size() > 0)
+   {
+      bdr_face_trial = 0.0;
+      for (BilinearFormIntegrator *integ : bdr_integrators)
       {
-         H1elem_restrict_test->MultTransposeUnsigned(localTest, diag);
+         integ->AddMultTransposePA(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                   bdr_face_trial);
       }
-      else
+      if (c != 1.0)
       {
-         elem_restrict_test->MultTranspose(localTest, diag);
+         bdr_face_trial *= c;
       }
+      bdr_face_restrict_lex_trial->AddMultTranspose(bdr_face_trial, y);
    }
    else
    {
-      diag.UseDevice(true); // typically this is a large vector, so store on device
-      diag = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      if (c != 1.0 && bdr_integrators.Size() > 0)
       {
-         if (elem_restrict_trial)
+         temp_trial.SetSize(y.Size());
+         temp_trial.UseDevice(true);
+         temp_trial = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(localTrial, diag);
+            integ->AddMultTransposePA(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                      temp_trial);
          }
-         else
+         y.Add(c, temp_trial);
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : integrators)
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(D, diag);
+            integ->AddMultTransposePA(bdr_face_restrict_lex_test ? bdr_face_test : x, y);
          }
       }
    }
 }
 
+/// Data and methods for partially-assembled discrete linear operators
 PADiscreteLinearOperatorExtension::PADiscreteLinearOperatorExtension(
    DiscreteLinearOperator *linop) :
    PAMixedBilinearFormExtension(linop)
 {
 }
 
-const
-Operator *PADiscreteLinearOperatorExtension::GetOutputRestrictionTranspose()
-const
-{
-   return a->GetOutputRestrictionTranspose();
-}
-
 void PADiscreteLinearOperatorExtension::Assemble()
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
-   {
-      integrators[i]->AssemblePA(*trial_fes, *test_fes);
-   }
+   PAMixedBilinearFormExtension::Assemble();
 
+   // Construct element vdof multiplicity (avoid use of elem_restrict_test
+   // because it might not exist for libCEED)
+   test_multiplicity.SetSize(height);
    test_multiplicity.UseDevice(true);
-   test_multiplicity.SetSize(elem_restrict_test->Width()); // l-vector
-   Vector ones(elem_restrict_test->Height()); // e-vector
-   ones = 1.0;
-
-   const ElementRestriction* elem_restrict =
-      dynamic_cast<const ElementRestriction*>(elem_restrict_test);
-   if (elem_restrict)
-   {
-      elem_restrict->MultTransposeUnsigned(ones, test_multiplicity);
-   }
-   else
-   {
-      mfem_error("A real ElementRestriction is required in this setting!");
+   test_multiplicity = 0.0;
+   Array<int> dofs;
+   for (int i = 0; i < test_fes->GetNE(); i++)
+   {
+      test_fes->GetElementVDofs(i, dofs);
+      const int ndofs = dofs.Size();
+      auto d_mult = test_multiplicity.HostReadWrite();
+      auto d_dofs = dofs.HostRead();
+      mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
+      {
+         const int j = d_dofs[i];
+         d_mult[(j >= 0) ? j : -1 - j] += 1.0;
+      });
    }
-
-   auto tm = test_multiplicity.ReadWrite();
-   mfem::forall(test_multiplicity.Size(), [=] MFEM_HOST_DEVICE (int i)
-   {
-      tm[i] = 1.0 / tm[i];
-   });
+   test_multiplicity.Reciprocal();
 }
 
-void PADiscreteLinearOperatorExtension::AddMult(
-   const Vector &x, Vector &y, const double c) const
+void PADiscreteLinearOperatorExtension::AddMult(const Vector &x, Vector &y,
+                                                const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // * G operation
-   SetupMultInputs(elem_restrict_trial, x, localTrial,
-                   elem_restrict_test, y, localTest, c);
-
-   // * B^TDB operation
-   for (int i = 0; i < iSz; ++i)
+   Array<BilinearFormIntegrator *> &interpolators = *a->GetDBFI();
+   temp_test.SetSize(y.Size());
+   temp_test.UseDevice(true);
+   if (elem_restrict_trial)
    {
-      integrators[i]->AddMultPA(localTrial, localTest);
+      elem_restrict_trial->Mult(x, local_trial);
    }
-
-   // do a kind of "set" rather than "add" in the below
-   // operation as compared to the BilinearForm case
-   // * G^T operation (kind of...)
-   const ElementRestriction* elem_restrict =
-      dynamic_cast<const ElementRestriction*>(elem_restrict_test);
-   if (elem_restrict)
+   if (elem_restrict_test)
    {
-      tempY.SetSize(y.Size());
-      elem_restrict->MultLeftInverse(localTest, tempY);
-      y += tempY;
+      local_test = 0.0;
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultPA(elem_restrict_trial ? local_trial : x, local_test);
+      }
+      elem_restrict_test->MultTranspose(local_test, temp_test);
    }
    else
    {
-      mfem_error("In this setting you need a real ElementRestriction!");
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultPA(elem_restrict_trial ? local_trial : x, temp_test);
+      }
    }
+   temp_test *= test_multiplicity;
+   y.Add(c, temp_test);
 }
 
-void PADiscreteLinearOperatorExtension::AddMultTranspose(
-   const Vector &x, Vector &y, const double c) const
+void PADiscreteLinearOperatorExtension::AddMultTranspose(const Vector &x,
+                                                         Vector &y,
+                                                         const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // do a kind of "set" rather than "add" in the below
-   // operation as compared to the BilinearForm case
-   // * G operation (kinda)
-   Vector xscaled(x);
-   MFEM_VERIFY(x.Size() == test_multiplicity.Size(), "Input vector of wrong size");
-   auto xs = xscaled.ReadWrite();
-   auto tm = test_multiplicity.Read();
-   mfem::forall(x.Size(), [=] MFEM_HOST_DEVICE (int i)
-   {
-      xs[i] *= tm[i];
-   });
-   SetupMultInputs(elem_restrict_test, xscaled, localTest,
-                   elem_restrict_trial, y, localTrial, c);
-
-   // * B^TD^TB operation
-   for (int i = 0; i < iSz; ++i)
+   Array<BilinearFormIntegrator *> &interpolators = *a->GetDBFI();
+   temp_test.SetSize(y.Size());
+   temp_test.UseDevice(true);
+   temp_test = x;
+   temp_test *= test_multiplicity;
+   if (elem_restrict_test)
    {
-      integrators[i]->AddMultTransposePA(localTest, localTrial);
+      elem_restrict_test->Mult(temp_test, local_test);
    }
-
-   // * G^T operation
    if (elem_restrict_trial)
    {
-      tempY.SetSize(y.Size());
-      elem_restrict_trial->MultTranspose(localTrial, tempY);
-      y += tempY;
+      local_trial = 0.0;
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test,
+                                    local_trial);
+      }
+      if (c != 1.0)
+      {
+         local_trial *= c;
+      }
+      elem_restrict_trial->AddMultTranspose(local_trial, y);
    }
    else
    {
-      mfem_error("Trial ElementRestriction not defined");
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      if (c != 1.0)
+      {
+         MFEM_ABORT("General coefficient case for PADiscreteLinearOperatorExtension::"
+                    "AddMultTranspose is not yet supported!");
+      }
+      else
+      {
+         for (BilinearFormIntegrator *interp : interpolators)
+         {
+            interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test, y);
+         }
+      }
    }
 }
 
-void PADiscreteLinearOperatorExtension::FormRectangularSystemOperator(
-   const Array<int>& ess1, const Array<int>& ess2, OperatorHandle &A)
-{
-   const Operator *Pi = this->GetProlongation();
-   const Operator *RoT = this->GetOutputRestrictionTranspose();
-   Operator *rap = SetupRAP(Pi, RoT);
-
-   RectangularConstrainedOperator *Arco
-      = new RectangularConstrainedOperator(rap, ess1, ess2, rap != this);
-
-   A.Reset(Arco);
-}
-
 } // namespace mfem
diff --git a/fem/bilinearform_ext.hpp b/fem/bilinearform_ext.hpp
index ef54dc71c..db26eb801 100644
--- a/fem/bilinearform_ext.hpp
+++ b/fem/bilinearform_ext.hpp
@@ -25,8 +25,8 @@ class DiscreteLinearOperator;
 
 /// Class extending the BilinearForm class to support different AssemblyLevels.
 /**  FA - Full Assembly
-     PA - Partial Assembly
      EA - Element Assembly
+     PA - Partial Assembly
      MF - Matrix Free
 */
 class BilinearFormExtension : public Operator
@@ -54,57 +54,59 @@ public:
       MFEM_ABORT("AssembleDiagonal not implemented for this assembly level!");
    }
 
-   virtual void FormSystemMatrix(const Array<int> &ess_tdof_list,
-                                 OperatorHandle &A) = 0;
-   virtual void FormLinearSystem(const Array<int> &ess_tdof_list,
-                                 Vector &x, Vector &b,
-                                 OperatorHandle &A, Vector &X, Vector &B,
-                                 int copy_interior = 0) = 0;
    virtual void Update() = 0;
 };
 
-/// Data and methods for partially-assembled bilinear forms
-class PABilinearFormExtension : public BilinearFormExtension
+/// Data and methods for matrix-free bilinear forms
+class MFBilinearFormExtension : public BilinearFormExtension
 {
 protected:
-   const FiniteElementSpace *trial_fes, *test_fes; // Not owned
-   mutable Vector localX, localY;
-   mutable Vector int_face_X, int_face_Y;
-   mutable Vector bdr_face_X, bdr_face_Y;
-   const Operator *elem_restrict; // Not owned
+   const FiniteElementSpace *fes; // Not owned
+   mutable Vector local_x, local_y, temp_y;
+   mutable Vector int_face_x, int_face_y;
+   mutable Vector bdr_face_x, bdr_face_y;
+   const ElementRestriction *elem_restrict; // Not owned
    const FaceRestriction *int_face_restrict_lex; // Not owned
    const FaceRestriction *bdr_face_restrict_lex; // Not owned
 
 public:
-   PABilinearFormExtension(BilinearForm*);
+   MFBilinearFormExtension(BilinearForm *form);
 
    void Assemble();
    void AssembleDiagonal(Vector &diag) const;
-   void FormSystemMatrix(const Array<int> &ess_tdof_list, OperatorHandle &A);
-   void FormLinearSystem(const Array<int> &ess_tdof_list,
-                         Vector &x, Vector &b,
-                         OperatorHandle &A, Vector &X, Vector &B,
-                         int copy_interior = 0);
    void Mult(const Vector &x, Vector &y) const;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
    void MultTranspose(const Vector &x, Vector &y) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
    void Update();
 
 protected:
    void SetupRestrictionOperators(const L2FaceValues m);
 };
 
+/// Data and methods for partially-assembled bilinear forms
+class PABilinearFormExtension : public MFBilinearFormExtension
+{
+public:
+   PABilinearFormExtension(BilinearForm *form);
+
+   void Assemble();
+   void AssembleDiagonal(Vector &diag) const;
+   void Mult(const Vector &x, Vector &y) const;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
+   void MultTranspose(const Vector &x, Vector &y) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
+};
+
 /// Data and methods for element-assembled bilinear forms
 class EABilinearFormExtension : public PABilinearFormExtension
 {
 protected:
-   int ne;
-   int elemDofs;
-   // The element matrices are stored row major
-   Vector ea_data;
-   int nf_int, nf_bdr;
-   int faceDofs;
+   const bool factorize_face_terms;
+   int ne, elem_dofs;
+   Vector ea_data;  // The element matrices are stored row major
+   int nf_int, nf_bdr, face_dofs;
    Vector ea_data_int, ea_data_ext, ea_data_bdr;
-   bool factorize_face_terms;
 
 public:
    EABilinearFormExtension(BilinearForm *form);
@@ -125,15 +127,6 @@ public:
    FABilinearFormExtension(BilinearForm *form);
 
    void Assemble();
-   void RAP(OperatorHandle &A);
-   /** @note Always does `DIAG_ONE` policy to be consistent with
-       `Operator::FormConstrainedSystemOperator`. */
-   void EliminateBC(const Array<int> &ess_dofs, OperatorHandle &A);
-   void FormSystemMatrix(const Array<int> &ess_tdof_list, OperatorHandle &A);
-   void FormLinearSystem(const Array<int> &ess_tdof_list,
-                         Vector &x, Vector &b,
-                         OperatorHandle &A, Vector &X, Vector &B,
-                         int copy_interior = 0);
    void Mult(const Vector &x, Vector &y) const;
    void MultTranspose(const Vector &x, Vector &y) const;
 
@@ -143,37 +136,10 @@ public:
    void DGMultTranspose(const Vector &x, Vector &y) const;
 };
 
-/// Data and methods for matrix-free bilinear forms
-class MFBilinearFormExtension : public BilinearFormExtension
-{
-protected:
-   const FiniteElementSpace *trial_fes, *test_fes; // Not owned
-   mutable Vector localX, localY;
-   mutable Vector int_face_X, int_face_Y;
-   mutable Vector bdr_face_X, bdr_face_Y;
-   const Operator *elem_restrict; // Not owned
-   const FaceRestriction *int_face_restrict_lex; // Not owned
-   const FaceRestriction *bdr_face_restrict_lex; // Not owned
-
-public:
-   MFBilinearFormExtension(BilinearForm *form);
-
-   void Assemble();
-   void AssembleDiagonal(Vector &diag) const;
-   void FormSystemMatrix(const Array<int> &ess_tdof_list, OperatorHandle &A);
-   void FormLinearSystem(const Array<int> &ess_tdof_list,
-                         Vector &x, Vector &b,
-                         OperatorHandle &A, Vector &X, Vector &B,
-                         int copy_interior = 0);
-   void Mult(const Vector &x, Vector &y) const;
-   void MultTranspose(const Vector &x, Vector &y) const;
-   void Update();
-};
-
 /// Class extending the MixedBilinearForm class to support different AssemblyLevels.
 /**  FA - Full Assembly
-     PA - Partial Assembly
      EA - Element Assembly
+     PA - Partial Assembly
      MF - Matrix Free
 */
 class MixedBilinearFormExtension : public Operator
@@ -185,7 +151,7 @@ public:
    MixedBilinearFormExtension(MixedBilinearForm *form);
 
    virtual MemoryClass GetMemoryClass() const
-   { return Device::GetMemoryClass(); }
+   { return Device::GetDeviceMemoryClass(); }
 
    /// Get the finite element space prolongation matrix
    virtual const Operator *GetProlongation() const;
@@ -199,101 +165,70 @@ public:
    /// Get the output finite element space restriction matrix
    virtual const Operator *GetOutputRestriction() const;
 
+   /// Assemble at the level given for the BilinearFormExtension subclass
    virtual void Assemble() = 0;
-   virtual void FormRectangularSystemOperator(const Array<int> &trial_tdof_list,
-                                              const Array<int> &test_tdof_list,
-                                              OperatorHandle &A) = 0;
-   virtual void FormRectangularLinearSystem(const Array<int> &trial_tdof_list,
-                                            const Array<int> &test_tdof_list,
-                                            Vector &x, Vector &b,
-                                            OperatorHandle &A, Vector &X, Vector &B) = 0;
 
-   virtual void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const = 0;
+   virtual void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const
+   {
+      MFEM_ABORT("AssembleDiagonal_ADAt not implemented for this assembly level!");
+   }
 
    virtual void Update() = 0;
 };
 
-/// Data and methods for partially-assembled mixed bilinear forms
-class PAMixedBilinearFormExtension : public MixedBilinearFormExtension
+/// Data and methods for matrix-free mixed bilinear forms
+class MFMixedBilinearFormExtension : public MixedBilinearFormExtension
 {
 protected:
    const FiniteElementSpace *trial_fes, *test_fes; // Not owned
-   mutable Vector localTrial, localTest, tempY;
-   const Operator *elem_restrict_trial; // Not owned
-   const Operator *elem_restrict_test;  // Not owned
-
-   /// Helper function to set up inputs/outputs for Mult or MultTranspose
-   void SetupMultInputs(const Operator *elem_restrict_x,
-                        const Vector &x, Vector &localX,
-                        const Operator *elem_restrict_y,
-                        Vector &y, Vector &localY, const double c) const;
+   mutable Vector local_trial, local_test, temp_trial, temp_test;
+   mutable Vector int_face_trial, int_face_test, int_face_y;
+   mutable Vector bdr_face_trial, bdr_face_test, bdr_face_y;
+   const ElementRestriction *elem_restrict_trial; // Not owned
+   const ElementRestriction *elem_restrict_test;  // Not owned
+   const FaceRestriction *int_face_restrict_lex_trial; // Not owned
+   const FaceRestriction *int_face_restrict_lex_test;  // Not owned
+   const FaceRestriction *bdr_face_restrict_lex_trial; // Not owned
+   const FaceRestriction *bdr_face_restrict_lex_test;  // Not owned
 
 public:
-   PAMixedBilinearFormExtension(MixedBilinearForm *form);
+   MFMixedBilinearFormExtension(MixedBilinearForm *form);
 
-   /// Partial assembly of all internal integrators
    void Assemble();
-   /**
-      @brief Setup OperatorHandle A to contain constrained linear operator
-
-      OperatorHandle A contains matrix-free constrained operator formed for RAP
-      system where ess_tdof_list are in trial space and eliminated from
-      "columns" of A.
-   */
-   void FormRectangularSystemOperator(const Array<int> &trial_tdof_list,
-                                      const Array<int> &test_tdof_list,
-                                      OperatorHandle &A);
-   /**
-      Setup OperatorHandle A to contain constrained linear operator and
-      eliminate columns corresponding to essential dofs from system,
-      updating RHS B vector with the results.
-   */
-   void FormRectangularLinearSystem(const Array<int> &trial_tdof_list,
-                                    const Array<int> &test_tdof_list,
-                                    Vector &x, Vector &b,
-                                    OperatorHandle &A, Vector &X, Vector &B);
-   /// y = A*x
    void Mult(const Vector &x, Vector &y) const;
-   /// y += c*A*x
-   void AddMult(const Vector &x, Vector &y, const double c=1.0) const;
-   /// y = A^T*x
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
    void MultTranspose(const Vector &x, Vector &y) const;
-   /// y += c*A^T*x
-   void AddMultTranspose(const Vector &x, Vector &y, const double c=1.0) const;
-   /// Assemble the diagonal of ADA^T for a diagonal vector D.
-   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
-
-   /// Update internals for when a new MixedBilinearForm is given to this class
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
    void Update();
+
+protected:
+   void SetupRestrictionOperators(const L2FaceValues m);
 };
 
+/// Data and methods for partially-assembled mixed bilinear forms
+class PAMixedBilinearFormExtension : public MFMixedBilinearFormExtension
+{
+public:
+   PAMixedBilinearFormExtension(MixedBilinearForm *form);
 
-/**
-   @brief Partial assembly extension for DiscreteLinearOperator
+   void Assemble();
+   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
+};
 
-   This acts very much like PAMixedBilinearFormExtension, but its
-   FormRectangularSystemOperator implementation emulates 'Set' rather than
-   'Add' in the assembly case.
-*/
+/// Data and methods for partially-assembled discrete linear operators
 class PADiscreteLinearOperatorExtension : public PAMixedBilinearFormExtension
 {
+private:
+   Vector test_multiplicity;
+
 public:
    PADiscreteLinearOperatorExtension(DiscreteLinearOperator *linop);
 
-   /// Partial assembly of all internal integrators
    void Assemble();
-
-   void AddMult(const Vector &x, Vector &y, const double c=1.0) const;
-
-   void AddMultTranspose(const Vector &x, Vector &y, const double c=1.0) const;
-
-   void FormRectangularSystemOperator(const Array<int>&, const Array<int>&,
-                                      OperatorHandle& A);
-
-   const Operator * GetOutputRestrictionTranspose() const;
-
-private:
-   Vector test_multiplicity;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
 };
 
 }
diff --git a/fem/bilininteg.cpp b/fem/bilininteg.cpp
index c552e9510..e6fc2a6ee 100644
--- a/fem/bilininteg.cpp
+++ b/fem/bilininteg.cpp
@@ -22,126 +22,162 @@ namespace mfem
 
 void BilinearFormIntegrator::AssemblePA(const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AssemblePA(fes)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePA(fes)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssemblePA(const FiniteElementSpace&,
                                         const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AssemblePA(fes, fes)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePA(fes, fes)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssemblePABoundary(const FiniteElementSpace&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePABoundary(fes)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssemblePABoundary(const FiniteElementSpace&,
+                                                const FiniteElementSpace&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePABoundary(fes, fes)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssemblePAInteriorFaces(const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AssemblePAInteriorFaces(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePAInteriorFaces(fes)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssemblePABoundaryFaces(const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AssemblePABoundaryFaces(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePABoundaryFaces(fes)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleDiagonalPA(Vector &)
+void BilinearFormIntegrator::AssembleDiagonalPA(Vector&)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleDiagonalPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalPA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                        Vector &emat,
-                                        const bool add)
+void BilinearFormIntegrator::AssembleDiagonalPA_ADAt(const Vector&, Vector&)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleEA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalPA_ADAt(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace
-                                                     &fes,
-                                                     Vector &ea_data_int,
-                                                     Vector &ea_data_ext,
-                                                     const bool add)
+void BilinearFormIntegrator::AddMultPA(const Vector&, Vector&) const
 {
-   mfem_error ("BilinearFormIntegrator::AssembleEAInteriorFaces(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::MultAssembled(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace
-                                                     &fes,
-                                                     Vector &ea_data_bdr,
-                                                     const bool add)
+void BilinearFormIntegrator::AddMultTransposePA(const Vector&, Vector&) const
 {
-   mfem_error ("BilinearFormIntegrator::AssembleEABoundaryFaces(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AddMultTransposePA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleDiagonalPA_ADAt(const Vector &, Vector &)
+void BilinearFormIntegrator::AssembleMF(const FiniteElementSpace&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalPA_ADAt(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMF(fes)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultPA(const Vector &, Vector &) const
+void BilinearFormIntegrator::AssembleMF(const FiniteElementSpace&,
+                                        const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::MultAssembled(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMF(fes, fes)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultTransposePA(const Vector &, Vector &) const
+void BilinearFormIntegrator::AssembleMFBoundary(const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AddMultTransposePA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMFBoundary(fes)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleMF(const FiniteElementSpace &fes)
+void BilinearFormIntegrator::AssembleMFBoundary(const FiniteElementSpace&,
+                                                const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMFBoundary(fes, fes)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultMF(const Vector &, Vector &) const
+void BilinearFormIntegrator::AssembleDiagonalMF(Vector&)
 {
-   mfem_error ("BilinearFormIntegrator::AddMultMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalMF(...)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AddMultMF(const Vector&, Vector&) const
+{
+   MFEM_ABORT("BilinearFormIntegrator::AddMultMF(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultTransposeMF(const Vector &, Vector &) const
+void BilinearFormIntegrator::AddMultTransposeMF(const Vector&, Vector&) const
 {
-   mfem_error ("BilinearFormIntegrator::AddMultTransposeMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AddMultTransposeMF(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleDiagonalMF(Vector &)
+void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace&,
+                                        Vector&)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleDiagonalMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEA(...)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace&,
+                                        const FiniteElementSpace&,
+                                        Vector&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleElementMatrix (
+void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &,
+                                                     Vector&,
+                                                     Vector&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEAInteriorFaces(...)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace&,
+                                                     Vector&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEABoundaryFaces(...)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans,
-   DenseMatrix &elmat )
+   DenseMatrix &elmat)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleElementMatrix(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleElementMatrix(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleElementMatrix2 (
+void BilinearFormIntegrator::AssembleElementMatrix2(
    const FiniteElement &el1, const FiniteElement &el2,
-   ElementTransformation &Trans, DenseMatrix &elmat )
+   ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleElementMatrix2(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleElementMatrix2(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleFaceMatrix (
+void BilinearFormIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleFaceMatrix(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleFaceMatrix(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleFaceMatrix(
@@ -191,30 +227,30 @@ void TransposeIntegrator::SetIntRule(const IntegrationRule *ir)
    bfi->SetIntRule(ir);
 }
 
-void TransposeIntegrator::AssembleElementMatrix (
+void TransposeIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleElementMatrix (el, Trans, bfi_elmat);
+   bfi->AssembleElementMatrix(el, Trans, bfi_elmat);
    // elmat = bfi_elmat^t
-   elmat.Transpose (bfi_elmat);
+   elmat.Transpose(bfi_elmat);
 }
 
-void TransposeIntegrator::AssembleElementMatrix2 (
+void TransposeIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleElementMatrix2 (test_fe, trial_fe, Trans, bfi_elmat);
+   bfi->AssembleElementMatrix2(test_fe, trial_fe, Trans, bfi_elmat);
    // elmat = bfi_elmat^t
-   elmat.Transpose (bfi_elmat);
+   elmat.Transpose(bfi_elmat);
 }
 
-void TransposeIntegrator::AssembleFaceMatrix (
+void TransposeIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleFaceMatrix (el1, el2, Trans, bfi_elmat);
+   bfi->AssembleFaceMatrix(el1, el2, Trans, bfi_elmat);
    // elmat = bfi_elmat^t
-   elmat.Transpose (bfi_elmat);
+   elmat.Transpose(bfi_elmat);
 }
 
 void LumpedIntegrator::SetIntRule(const IntegrationRule *ir)
@@ -223,10 +259,10 @@ void LumpedIntegrator::SetIntRule(const IntegrationRule *ir)
    bfi->SetIntRule(ir);
 }
 
-void LumpedIntegrator::AssembleElementMatrix (
+void LumpedIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleElementMatrix (el, Trans, elmat);
+   bfi->AssembleElementMatrix(el, Trans, elmat);
    elmat.Lump();
 }
 
@@ -316,6 +352,15 @@ void SumIntegrator::AssemblePA(const FiniteElementSpace& fes)
    }
 }
 
+void SumIntegrator::AssemblePA(const FiniteElementSpace& trial_fes,
+                               const FiniteElementSpace& test_fes)
+{
+   for (int i = 0; i < integrators.Size(); i++)
+   {
+      integrators[i]->AssemblePA(trial_fes, test_fes);
+   }
+}
+
 void SumIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    for (int i = 0; i < integrators.Size(); i++)
@@ -364,57 +409,63 @@ void SumIntegrator::AssembleMF(const FiniteElementSpace &fes)
    }
 }
 
-void SumIntegrator::AddMultMF(const Vector& x, Vector& y) const
+void SumIntegrator::AssembleMF(const FiniteElementSpace& trial_fes,
+                               const FiniteElementSpace& test_fes)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AddMultTransposeMF(x, y);
+      integrators[i]->AssembleMF(trial_fes, test_fes);
    }
 }
 
-void SumIntegrator::AddMultTransposeMF(const Vector &x, Vector &y) const
+void SumIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AddMultMF(x, y);
+      integrators[i]->AssembleDiagonalMF(diag);
    }
 }
 
-void SumIntegrator::AssembleDiagonalMF(Vector &diag)
+void SumIntegrator::AddMultMF(const Vector& x, Vector& y) const
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleDiagonalMF(diag);
+      integrators[i]->AddMultTransposeMF(x, y);
+   }
+}
+
+void SumIntegrator::AddMultTransposeMF(const Vector &x, Vector &y) const
+{
+   for (int i = 0; i < integrators.Size(); i++)
+   {
+      integrators[i]->AddMultMF(x, y);
    }
 }
 
-void SumIntegrator::AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                               const bool add)
+void SumIntegrator::AssembleEA(const FiniteElementSpace &fes, Vector &emat)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleEA(fes, emat, add);
+      integrators[i]->AssembleEA(fes, emat);
    }
 }
 
 void SumIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                             Vector &ea_data_int,
-                                            Vector &ea_data_ext,
-                                            const bool add)
+                                            Vector &ea_data_ext)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleEAInteriorFaces(fes,ea_data_int,ea_data_ext,add);
+      integrators[i]->AssembleEAInteriorFaces(fes, ea_data_int, ea_data_ext);
    }
 }
 
 void SumIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                            Vector &ea_data_bdr,
-                                            const bool add)
+                                            Vector &ea_data_bdr)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleEABoundaryFaces(fes, ea_data_bdr, add);
+      integrators[i]->AssembleEABoundaryFaces(fes, ea_data_bdr);
    }
 }
 
@@ -642,15 +693,15 @@ void MixedVectorIntegrator::AssembleElementMatrix2(
       {
          if (Q)
          {
-            w *= Q -> Eval (Trans, ip);
+            w *= Q->Eval(Trans, ip);
          }
          if (same_shapes)
          {
-            AddMult_a_AAt (w, test_shape, elmat);
+            AddMult_a_AAt(w, test_shape, elmat);
          }
          else
          {
-            AddMult_a_ABt (w, test_shape, trial_shape, elmat);
+            AddMult_a_ABt(w, test_shape, trial_shape, elmat);
          }
       }
    }
@@ -724,7 +775,7 @@ void MixedScalarVectorIntegrator::AssembleElementMatrix2(
       VQ->Eval(V, Trans, ip);
       V *= w;
 
-      if ( vdim == 2 && cross_2d )
+      if (vdim == 2 && cross_2d)
       {
          vtmp = V[0];
          V[0] = -V[1];
@@ -736,7 +787,6 @@ void MixedScalarVectorIntegrator::AssembleElementMatrix2(
    }
 }
 
-
 void GradientIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans,  DenseMatrix &elmat)
@@ -793,19 +843,18 @@ void GradientIntegrator::AssembleElementMatrix2(
    }
 }
 
-const IntegrationRule &GradientIntegrator::GetRule(const FiniteElement
-                                                   &trial_fe,
-                                                   const FiniteElement &test_fe,
-                                                   ElementTransformation &Trans)
+const IntegrationRule &GradientIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans)
 {
    int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
-void DiffusionIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void DiffusionIntegrator::AssembleElementMatrix(
+   const FiniteElement &el, ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    dim = el.GetDim();
@@ -1044,10 +1093,14 @@ void DiffusionIntegrator::AssembleElementVector(
    }
 }
 
-void DiffusionIntegrator::ComputeElementFlux
-( const FiniteElement &el, ElementTransformation &Trans,
-  Vector &u, const FiniteElement &fluxelem, Vector &flux, bool with_coef,
-  const IntegrationRule *ir)
+void DiffusionIntegrator::ComputeElementFlux(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   Vector &u,
+   const FiniteElement &fluxelem,
+   Vector &flux,
+   bool with_coef,
+   const IntegrationRule *ir)
 {
    int nd, spaceDim, fnd;
 
@@ -1087,7 +1140,7 @@ void DiffusionIntegrator::ComputeElementFlux
       ir = &fluxelem.GetNodes();
    }
    fnd = ir->GetNPoints();
-   flux.SetSize( fnd * spaceDim );
+   flux.SetSize(fnd * spaceDim);
 
    for (int i = 0; i < fnd; i++)
    {
@@ -1095,7 +1148,7 @@ void DiffusionIntegrator::ComputeElementFlux
       el.CalcDShape(ip, dshape);
       dshape.MultTranspose(u, vec);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       CalcInverse(Trans.Jacobian(), invdfdx);
       invdfdx.MultTranspose(vec, vecdxt);
 
@@ -1143,9 +1196,11 @@ void DiffusionIntegrator::ComputeElementFlux
    }
 }
 
-double DiffusionIntegrator::ComputeFluxEnergy
-( const FiniteElement &fluxelem, ElementTransformation &Trans,
-  Vector &flux, Vector* d_energy)
+double DiffusionIntegrator::ComputeFluxEnergy(
+   const FiniteElement &fluxelem,
+   ElementTransformation &Trans,
+   Vector &flux,
+   Vector* d_energy)
 {
    int nd = fluxelem.GetDof();
    dim = fluxelem.GetDim();
@@ -1220,7 +1275,8 @@ double DiffusionIntegrator::ComputeFluxEnergy
 }
 
 const IntegrationRule &DiffusionIntegrator::GetRule(
-   const FiniteElement &trial_fe, const FiniteElement &test_fe)
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe)
 {
    int order;
    if (trial_fe.Space() == FunctionSpace::Pk)
@@ -1232,7 +1288,6 @@ const IntegrationRule &DiffusionIntegrator::GetRule(
       // order = 2*el.GetOrder() - 2;  // <-- this seems to work fine too
       order = trial_fe.GetOrder() + test_fe.GetOrder() + trial_fe.GetDim() - 1;
    }
-
    if (trial_fe.Space() == FunctionSpace::rQk)
    {
       return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
@@ -1240,10 +1295,10 @@ const IntegrationRule &DiffusionIntegrator::GetRule(
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
-void MassIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void MassIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    // int dim = el.GetDim();
@@ -1252,8 +1307,8 @@ void MassIntegrator::AssembleElementMatrix
 #ifdef MFEM_THREAD_SAFE
    Vector shape;
 #endif
-   elmat.SetSize(nd);
    shape.SetSize(nd);
+   elmat.SetSize(nd);
 
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, Trans);
 
@@ -1261,14 +1316,14 @@ void MassIntegrator::AssembleElementMatrix
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
 
       el.CalcPhysShape(Trans, shape);
 
       w = Trans.Weight() * ip.weight;
       if (Q)
       {
-         w *= Q -> Eval(Trans, ip);
+         w *= Q->Eval(Trans, ip);
       }
 
       AddMult_a_VVt(w, shape, elmat);
@@ -1300,11 +1355,11 @@ void MassIntegrator::AssembleElementMatrix2(
       trial_fe.CalcShape(ip, shape);
       test_fe.CalcShape(ip, te_shape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       w = Trans.Weight() * ip.weight;
       if (Q)
       {
-         w *= Q -> Eval(Trans, ip);
+         w *= Q->Eval(Trans, ip);
       }
 
       te_shape *= w;
@@ -1326,7 +1381,6 @@ const IntegrationRule &MassIntegrator::GetRule(const FiniteElement &trial_fe,
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
 void BoundaryMassIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
@@ -1366,7 +1420,7 @@ void BoundaryMassIntegrator::AssembleFaceMatrix(
       w = Trans.Weight() * ip.weight;
       if (Q)
       {
-         w *= Q -> Eval(Trans, ip);
+         w *= Q->Eval(Trans, ip);
       }
 
       AddMult_a_VVt(w, shape, elmat);
@@ -1420,9 +1474,18 @@ void ConvectionIntegrator::AssembleElementMatrix(
    }
 }
 
+const IntegrationRule &ConvectionIntegrator::GetRule(
+   const FiniteElement &fe,
+   ElementTransformation &Trans)
+{
+   int order = Trans.OrderGrad(&fe) + Trans.Order() + fe.GetOrder();
+   return IntRules.Get(fe.GetGeomType(), order);
+}
 
 void GroupConvectionIntegrator::AssembleElementMatrix(
-   const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    int dim = el.GetDim();
@@ -1473,24 +1536,10 @@ void GroupConvectionIntegrator::AssembleElementMatrix(
    }
 }
 
-const IntegrationRule &ConvectionIntegrator::GetRule(
-   const FiniteElement &trial_fe, const FiniteElement &test_fe,
-   ElementTransformation &Trans)
-{
-   int order = Trans.OrderGrad(&trial_fe) + Trans.Order() + test_fe.GetOrder();
-
-   return IntRules.Get(trial_fe.GetGeomType(), order);
-}
-
-const IntegrationRule &ConvectionIntegrator::GetRule(
-   const FiniteElement &el, ElementTransformation &Trans)
-{
-   return GetRule(el,el,Trans);
-}
-
-void VectorMassIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void VectorMassIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    int spaceDim = Trans.GetSpaceDim();
@@ -1533,7 +1582,7 @@ void VectorMassIntegrator::AssembleElementMatrix
       const IntegrationPoint &ip = ir->IntPoint(s);
       el.CalcShape(ip, shape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       norm = ip.weight * Trans.Weight();
 
       MultVVt(shape, partelmat);
@@ -1790,7 +1839,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
                "At least one of the finite elements must be in H(Curl)");
 
    int curl_nd, vec_nd;
-   if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+   if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
    {
       curl_nd = trial_nd;
       vec_nd  = test_nd;
@@ -1829,7 +1878,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
       Trans.SetIntPoint(&ip);
       if (dim == 3)
       {
-         if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+         if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
          {
             trial_fe.CalcCurlShape(ip, curlshapeTrial);
             test_fe.CalcVShape(Trans, vshapeTest);
@@ -1843,7 +1892,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
       }
       else
       {
-         if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+         if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
          {
             trial_fe.CalcCurlShape(ip, curlshapeTrial_dFT);
             test_fe.CalcShape(ip, shapeTest);
@@ -1863,7 +1912,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
       }
       // Note: shapeTest points to the same data as vshapeTest
       vshapeTest *= w;
-      if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+      if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
       {
          AddMultABt(vshapeTest, curlshapeTrial_dFT, elmat);
       }
@@ -1874,7 +1923,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
    }
 }
 
-void DerivativeIntegrator::AssembleElementMatrix2 (
+void DerivativeIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe,
    const FiniteElement &test_fe,
    ElementTransformation &Trans,
@@ -1888,12 +1937,12 @@ void DerivativeIntegrator::AssembleElementMatrix2 (
    int i, l;
    double det;
 
-   elmat.SetSize (test_nd,trial_nd);
-   dshape.SetSize (trial_nd,dim);
+   elmat.SetSize(test_nd,trial_nd);
+   dshape.SetSize(trial_nd,dim);
    dshapedxt.SetSize(trial_nd, spaceDim);
    dshapedxi.SetSize(trial_nd);
    invdfdx.SetSize(dim, spaceDim);
-   shape.SetSize (test_nd);
+   shape.SetSize(test_nd);
 
    const IntegrationRule *ir = IntRule;
    if (ir == NULL)
@@ -1925,10 +1974,10 @@ void DerivativeIntegrator::AssembleElementMatrix2 (
 
       trial_fe.CalcDShape(ip, dshape);
 
-      Trans.SetIntPoint (&ip);
-      CalcInverse (Trans.Jacobian(), invdfdx);
+      Trans.SetIntPoint(&ip);
+      CalcInverse(Trans.Jacobian(), invdfdx);
       det = Trans.Weight();
-      Mult (dshape, invdfdx, dshapedxt);
+      Mult(dshape, invdfdx, dshapedxt);
 
       test_fe.CalcShape(ip, shape);
 
@@ -1938,13 +1987,14 @@ void DerivativeIntegrator::AssembleElementMatrix2 (
       }
 
       shape *= Q->Eval(Trans,ip) * det * ip.weight;
-      AddMultVWt (shape, dshapedxi, elmat);
+      AddMultVWt(shape, dshapedxi, elmat);
    }
 }
 
-void CurlCurlIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void CurlCurlIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    dim = el.GetDim();
@@ -1959,6 +2009,7 @@ void CurlCurlIntegrator::AssembleElementMatrix
    curlshape_dFt.SetSize(nd,dimc);
 #endif
    elmat.SetSize(nd);
+
    if (MQ) { M.SetSize(dimc); }
    if (DQ) { D.SetSize(dimc); }
 
@@ -1983,7 +2034,7 @@ void CurlCurlIntegrator::AssembleElementMatrix
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
 
       w = ip.weight * Trans.Weight();
       el.CalcPhysCurlShape(Trans, curlshape_dFt);
@@ -2090,10 +2141,10 @@ void CurlCurlIntegrator::AssembleElementMatrix2(const FiniteElement &trial_fe,
    }
 }
 
-void CurlCurlIntegrator
-::ComputeElementFlux(const FiniteElement &el, ElementTransformation &Trans,
-                     Vector &u, const FiniteElement &fluxelem, Vector &flux,
-                     bool with_coef, const IntegrationRule *ir)
+void CurlCurlIntegrator::ComputeElementFlux(
+   const FiniteElement &el, ElementTransformation &Trans,
+   Vector &u, const FiniteElement &fluxelem, Vector &flux,
+   bool with_coef, const IntegrationRule *ir)
 {
 #ifdef MFEM_THREAD_SAFE
    DenseMatrix projcurl;
@@ -2215,7 +2266,9 @@ double CurlCurlIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
 }
 
 void VectorCurlCurlIntegrator::AssembleElementMatrix(
-   const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int dim = el.GetDim();
    int dof = el.GetDof();
@@ -2405,7 +2458,6 @@ void MixedCurlIntegrator::AssembleElementMatrix2(
    }
 }
 
-
 void VectorFEMassIntegrator::AssembleElementMatrix(
    const FiniteElement &el,
    ElementTransformation &Trans,
@@ -2443,7 +2495,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix(
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
 
       el.CalcVShape(Trans, trial_vshape);
 
@@ -2465,9 +2517,9 @@ void VectorFEMassIntegrator::AssembleElementMatrix(
       {
          if (Q)
          {
-            w *= Q -> Eval (Trans, ip);
+            w *= Q->Eval (Trans, ip);
          }
-         AddMult_a_AAt (w, trial_vshape, elmat);
+         AddMult_a_AAt(w, trial_vshape, elmat);
       }
    }
 }
@@ -2512,7 +2564,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
       {
          const IntegrationPoint &ip = ir->IntPoint(i);
 
-         Trans.SetIntPoint (&ip);
+         Trans.SetIntPoint(&ip);
 
          trial_fe.CalcVShape(Trans, trial_vshape);
          test_fe.CalcShape(ip, shape);
@@ -2598,7 +2650,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
 #endif
       DenseMatrix tmp(test_vshape.Height(), K.Width());
 
-      elmat.SetSize (test_dof, trial_dof);
+      elmat.SetSize(test_dof, trial_dof);
 
       const IntegrationRule *ir = IntRule;
       if (ir == NULL)
@@ -2612,7 +2664,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
       {
          const IntegrationPoint &ip = ir->IntPoint(i);
 
-         Trans.SetIntPoint (&ip);
+         Trans.SetIntPoint(&ip);
 
          trial_fe.CalcVShape(Trans, trial_vshape);
          test_fe.CalcVShape(Trans, test_vshape);
@@ -2635,7 +2687,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
          {
             if (Q)
             {
-               w *= Q -> Eval (Trans, ip);
+               w *= Q->Eval (Trans, ip);
             }
             AddMult_a_ABt(w,test_vshape,trial_vshape,elmat);
          }
@@ -2643,7 +2695,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
    }
    else
    {
-      mfem_error("VectorFEMassIntegrator::AssembleElementMatrix2(...)\n"
+      MFEM_ABORT("VectorFEMassIntegrator::AssembleElementMatrix2(...)\n"
                  "   is not implemented for given trial and test bases.");
    }
 }
@@ -2659,42 +2711,42 @@ void VectorDivergenceIntegrator::AssembleElementMatrix2(
    int test_dof = test_fe.GetDof();
    double c;
 
-   dshape.SetSize (trial_dof, dim);
-   gshape.SetSize (trial_dof, dim);
-   Jadj.SetSize (dim);
-   divshape.SetSize (dim*trial_dof);
-   shape.SetSize (test_dof);
+   dshape.SetSize(trial_dof, dim);
+   gshape.SetSize(trial_dof, dim);
+   Jadj.SetSize(dim);
+   divshape.SetSize(dim*trial_dof);
+   shape.SetSize(test_dof);
 
-   elmat.SetSize (test_dof, dim*trial_dof);
+   elmat.SetSize(test_dof, dim*trial_dof);
 
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
                                                             Trans);
 
    elmat = 0.0;
 
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      trial_fe.CalcDShape (ip, dshape);
-      test_fe.CalcShape (ip, shape);
+      trial_fe.CalcDShape(ip, dshape);
+      test_fe.CalcShape(ip, shape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       CalcAdjugate(Trans.Jacobian(), Jadj);
 
-      Mult (dshape, Jadj, gshape);
+      Mult(dshape, Jadj, gshape);
 
       gshape.GradToDiv (divshape);
 
       c = ip.weight;
       if (Q)
       {
-         c *= Q -> Eval (Trans, ip);
+         c *= Q->Eval (Trans, ip);
       }
 
       // elmat += c * shape * divshape ^ t
       shape *= c;
-      AddMultVWt (shape, divshape, elmat);
+      AddMultVWt(shape, divshape, elmat);
    }
 }
 
@@ -2707,7 +2759,6 @@ const IntegrationRule &VectorDivergenceIntegrator::GetRule(
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
 void DivDivIntegrator::AssembleElementMatrix(
    const FiniteElement &el,
    ElementTransformation &Trans,
@@ -2731,23 +2782,22 @@ void DivDivIntegrator::AssembleElementMatrix(
    }
 
    elmat = 0.0;
-
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      el.CalcDivShape (ip, divshape);
+      el.CalcDivShape(ip, divshape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       c = ip.weight / Trans.Weight();
 
       if (Q)
       {
-         c *= Q -> Eval (Trans, ip);
+         c *= Q->Eval (Trans, ip);
       }
 
       // elmat += c * divshape * divshape ^ t
-      AddMult_a_VVt (c, divshape, elmat);
+      AddMult_a_VVt(c, divshape, elmat);
    }
 }
 
@@ -2779,20 +2829,19 @@ void DivDivIntegrator::AssembleElementMatrix2(
    }
 
    elmat = 0.0;
-
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
       trial_fe.CalcDivShape(ip,divshape);
       test_fe.CalcDivShape(ip,te_divshape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       c = ip.weight / Trans.Weight();
 
       if (Q)
       {
-         c *= Q -> Eval (Trans, ip);
+         c *= Q->Eval (Trans, ip);
       }
 
       te_divshape *= c;
@@ -2836,7 +2885,7 @@ void VectorDiffusionIntegrator::AssembleElementMatrix(
 
    elmat = 0.0;
 
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
 
       const IntegrationPoint &ip = ir->IntPoint(i);
@@ -2972,7 +3021,6 @@ void VectorDiffusionIntegrator::AssembleElementVector(
    }
 }
 
-
 void ElasticityIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
@@ -3003,7 +3051,7 @@ void ElasticityIntegrator::AssembleElementMatrix(
 
    elmat = 0.0;
 
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
@@ -3038,7 +3086,7 @@ void ElasticityIntegrator::AssembleElementMatrix(
             for (int k = 0; k < dof; k++)
                for (int l = 0; l < dof; l++)
                {
-                  elmat (dof*d+k, dof*d+l) += (M * w) * pelmat(k, l);
+                  elmat(dof*d+k, dof*d+l) += (M * w) * pelmat(k, l);
                }
          }
          for (int ii = 0; ii < dim; ii++)
@@ -3360,7 +3408,6 @@ void DGTraceIntegrator::AssembleFaceMatrix(const FiniteElement &el1,
    }
 }
 
-
 const IntegrationRule &DGTraceIntegrator::GetRule(
    Geometry::Type geom, int order, FaceElementTransformations &T)
 {
@@ -3603,8 +3650,6 @@ void DGDiffusionIntegrator::AssembleFaceMatrix(
    }
 }
 
-
-// static method
 void DGElasticityIntegrator::AssembleBlock(
    const int dim, const int row_ndofs, const int col_ndofs,
    const int row_offset, const int col_offset,
@@ -3827,7 +3872,6 @@ void DGElasticityIntegrator::AssembleFaceMatrix(
    }
 }
 
-
 void TraceJumpIntegrator::AssembleFaceMatrix(
    const FiniteElement &trial_face_fe, const FiniteElement &test_fe1,
    const FiniteElement &test_fe2, FaceElementTransformations &Trans,
@@ -4243,7 +4287,6 @@ void NormalInterpolator::AssembleElementMatrix2(
    }
 }
 
-
 namespace internal
 {
 
@@ -4284,7 +4327,6 @@ ScalarProductInterpolator::AssembleElementMatrix2(const FiniteElement &dom_fe,
    ran_fe.Project(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 void
 ScalarVectorProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
@@ -4319,7 +4361,6 @@ ScalarVectorProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 void
 VectorScalarProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
@@ -4357,7 +4398,6 @@ VectorScalarProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 void
 ScalarCrossProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
@@ -4453,7 +4493,6 @@ VectorCrossProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 namespace internal
 {
 
@@ -4483,8 +4522,7 @@ struct VDotVShapeCoefficient : public VectorCoefficient
 
 }
 
-void
-VectorInnerProductInterpolator::AssembleElementMatrix2(
+void VectorInnerProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
diff --git a/fem/bilininteg.hpp b/fem/bilininteg.hpp
index 11922cff0..209898714 100644
--- a/fem/bilininteg.hpp
+++ b/fem/bilininteg.hpp
@@ -27,7 +27,6 @@ constexpr int HCURL_MAX_Q1D = 5;
 #else
 constexpr int HCURL_MAX_Q1D = 6;
 #endif
-
 constexpr int HDIV_MAX_D1D = 5;
 constexpr int HDIV_MAX_Q1D = 6;
 
@@ -36,7 +35,7 @@ class BilinearFormIntegrator : public NonlinearFormIntegrator
 {
 protected:
    BilinearFormIntegrator(const IntegrationRule *ir = NULL)
-      : NonlinearFormIntegrator(ir) { }
+      : NonlinearFormIntegrator(ir) {}
 
 public:
    // TODO: add support for other assembly levels (in addition to PA) and their
@@ -51,8 +50,6 @@ public:
    // make sense for the action of the nonlinear operator (but they all make
    // sense for its Jacobian).
 
-   using NonlinearFormIntegrator::AssemblePA;
-
    /// Method defining partial assembly.
    /** The result of the partial assembly is stored internally so that it can be
        used later in the methods AddMultPA() and AddMultTransposePA(). */
@@ -61,6 +58,11 @@ public:
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssemblePABoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
    virtual void AssemblePAInteriorFaces(const FiniteElementSpace &fes);
 
    virtual void AssemblePABoundaryFaces(const FiniteElementSpace &fes);
@@ -89,20 +91,21 @@ public:
        called. */
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   /// Method defining element assembly.
-   /** The result of the element assembly is added to the @a emat Vector if
-       @a add is true. Otherwise, if @a add is false, we set @a emat. */
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add = true);
-   /** Used with BilinearFormIntegrators that have different spaces. */
-   // virtual void AssembleEA(const FiniteElementSpace &trial_fes,
-   //                         const FiniteElementSpace &test_fes,
-   //                         Vector &emat);
-
    /// Method defining matrix-free assembly.
    /** The result of fully matrix-free assembly is stored internally so that it
        can be used later in the methods AddMultMF() and AddMultTransposeMF(). */
    virtual void AssembleMF(const FiniteElementSpace &fes);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssembleMFBoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
+   /// Assemble diagonal and add it to Vector @a diag.
+   virtual void AssembleDiagonalMF(Vector &diag);
 
    /** Perform the action of integrator on the input @a x and add the result to
        the output @a y. Both @a x and @a y are E-vectors, i.e. they represent
@@ -120,17 +123,20 @@ public:
        called. */
    virtual void AddMultTransposeMF(const Vector &x, Vector &y) const;
 
-   /// Assemble diagonal and add it to Vector @a diag.
-   virtual void AssembleDiagonalMF(Vector &diag);
+   /// Method defining element assembly.
+   /** The result of the element assembly is added to the @a emat Vector. */
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssembleEA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes,
+                           Vector &emat);
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add = true);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add = true);
+                                        Vector &ea_data_bdr);
 
    /// Given a particular Finite Element computes the element matrix elmat.
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -234,7 +240,7 @@ public:
                                    Vector &u,
                                    const FiniteElement &fluxelem,
                                    Vector &flux, bool with_coef = true,
-                                   const IntegrationRule *ir = NULL) { }
+                                   const IntegrationRule *ir = NULL) {}
 
    /** @brief Virtual method required for Zienkiewicz-Zhu type error estimators.
 
@@ -260,7 +266,7 @@ public:
                                     Vector &flux, Vector *d_energy = NULL)
    { return 0.0; }
 
-   virtual ~BilinearFormIntegrator() { }
+   virtual ~BilinearFormIntegrator() {}
 };
 
 /** Wraps a given @a BilinearFormIntegrator and transposes the resulting element
@@ -268,13 +274,12 @@ public:
 class TransposeIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_bfi;
+   bool own_bfi;
    BilinearFormIntegrator *bfi;
-
    DenseMatrix bfi_elmat;
 
 public:
-   TransposeIntegrator (BilinearFormIntegrator *bfi_, int own_bfi_ = 1)
+   TransposeIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
    { bfi = bfi_; own_bfi = own_bfi_; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
@@ -294,12 +299,25 @@ public:
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-
-   virtual void AssemblePA(const FiniteElementSpace& fes)
+   virtual void AssemblePA(const FiniteElementSpace &fes)
    {
       bfi->AssemblePA(fes);
    }
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes)
+   {
+      bfi->AssemblePA(trial_fes, test_fes);
+   }
+
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes)
+   {
+      bfi->AssemblePABoundary(fes);
+   }
+   virtual void AssemblePABoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes)
+   {
+      bfi->AssemblePABoundary(trial_fes, test_fes);
+   }
 
    virtual void AssemblePAInteriorFaces(const FiniteElementSpace &fes)
    {
@@ -316,22 +334,20 @@ public:
       bfi->AddMultPA(x, y);
    }
 
-   virtual void AddMultPA(const Vector& x, Vector& y) const
+   virtual void AddMultPA(const Vector &x, Vector &y) const
    {
       bfi->AddMultTransposePA(x, y);
    }
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add);
+                                        Vector &ea_data_bdr);
 
    virtual ~TransposeIntegrator() { if (own_bfi) { delete bfi; } }
 };
@@ -339,11 +355,11 @@ public:
 class LumpedIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_bfi;
+   bool own_bfi;
    BilinearFormIntegrator *bfi;
 
 public:
-   LumpedIntegrator (BilinearFormIntegrator *bfi_, int own_bfi_ = 1)
+   LumpedIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
    { bfi = bfi_; own_bfi = own_bfi_; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
@@ -359,11 +375,11 @@ public:
 class InverseIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_integrator;
+   bool own_integrator;
    BilinearFormIntegrator *integrator;
 
 public:
-   InverseIntegrator(BilinearFormIntegrator *integ, int own_integ = 1)
+   InverseIntegrator(BilinearFormIntegrator *integ, bool own_integ = 1)
    { integrator = integ; own_integrator = own_integ; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
@@ -379,12 +395,12 @@ public:
 class SumIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_integrators;
+   bool own_integrators;
    mutable DenseMatrix elem_mat;
    Array<BilinearFormIntegrator*> integrators;
 
 public:
-   SumIntegrator(int own_integs = 1) { own_integrators = own_integs; }
+   SumIntegrator(bool own_integs = true) { own_integrators = own_integs; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
 
@@ -411,8 +427,9 @@ public:
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace& fes);
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
 
    virtual void AssembleDiagonalPA(Vector &diag);
 
@@ -422,27 +439,27 @@ public:
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   virtual void AddMultPA(const Vector& x, Vector& y) const;
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AssembleMF(const FiniteElementSpace &fes);
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposeMF(const Vector &x, Vector &y) const;
 
-   virtual void AssembleDiagonalMF(Vector &diag);
-
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add);
+                                        Vector &ea_data_bdr);
 
    virtual ~SumIntegrator();
 };
@@ -452,7 +469,6 @@ public:
 class MixedScalarIntegrator: public BilinearFormIntegrator
 {
 public:
-
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -474,44 +490,39 @@ protected:
    MixedScalarIntegrator(Coefficient &q) : same_calc_shape(false), Q(&q) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe, const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarIntegrator:  "
              "Trial and test spaces must both be scalar fields.";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     Vector & shape)
+                                     Vector &shape)
    { test_fe.CalcPhysShape(Trans, shape); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    { trial_fe.CalcPhysShape(Trans, shape); }
 
    Coefficient *Q;
 
 private:
-
 #ifndef MFEM_THREAD_SAFE
-   Vector test_shape;
-   Vector trial_shape;
+   Vector test_shape, trial_shape;
 #endif
-
 };
 
 /** An abstract class for integrating the inner product of two vector basis
@@ -519,7 +530,6 @@ private:
 class MixedVectorIntegrator: public BilinearFormIntegrator
 {
 public:
-
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -548,39 +558,38 @@ protected:
       : same_calc_shape(false), Q(NULL), VQ(NULL), DQ(NULL), MQ(&mq) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorIntegrator:  "
              "Trial and test spaces must both be vector fields";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return std::max(space_dim, test_fe.GetVDim()); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcVShape(Trans, shape); }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return std::max(space_dim, trial_fe.GetVDim()); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcVShape(Trans, shape); }
 
    int space_dim;
@@ -590,16 +599,10 @@ protected:
    MatrixCoefficient *MQ;
 
 private:
-
 #ifndef MFEM_THREAD_SAFE
-   Vector V;
-   Vector D;
-   DenseMatrix M;
-   DenseMatrix test_shape;
-   DenseMatrix trial_shape;
-   DenseMatrix shape_tmp;
+   Vector V, D;
+   DenseMatrix M, test_shape, trial_shape, shape_tmp;
 #endif
-
 };
 
 /** An abstract class for integrating the product of a scalar basis function and
@@ -608,7 +611,6 @@ private:
 class MixedScalarVectorIntegrator: public BilinearFormIntegrator
 {
 public:
-
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -625,14 +627,13 @@ public:
    { AssembleElementMatrix2(fe, fe, Trans, elmat); }
 
 protected:
-
    MixedScalarVectorIntegrator(VectorCoefficient &vq, bool transpose_ = false,
                                bool cross_2d_ = false)
       : VQ(&vq), transpose(transpose_), cross_2d(cross_2d_) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return ((transpose &&
                trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -643,9 +644,9 @@ protected:
              );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
-      if ( transpose )
+      if (transpose)
       {
          return "MixedScalarVectorIntegrator:  "
                 "Trial space must be a vector field "
@@ -659,23 +660,22 @@ protected:
       }
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return std::max(space_dim, vector_fe.GetVDim()); }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape_)
+                                  DenseMatrix &shape_)
    { vector_fe.CalcVShape(Trans, shape_); }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape_)
+                                 Vector &shape_)
    { scalar_fe.CalcPhysShape(Trans, shape_); }
 
    VectorCoefficient *VQ;
@@ -684,14 +684,12 @@ protected:
    bool cross_2d;  // In 2D use a cross product rather than a dot product
 
 private:
-
 #ifndef MFEM_THREAD_SAFE
    Vector V;
    DenseMatrix vshape;
    Vector      shape;
    Vector      vshape_tmp;
 #endif
-
 };
 
 /** Class for integrating the bilinear form a(u,v) := (Q u, v) in either 1D, 2D,
@@ -726,24 +724,24 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 1 && test_fe.GetDim() == 1 &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarDerivativeIntegrator:  "
              "Trial and test spaces must both be scalar fields in 1D "
              "and the trial space must implement CalcDShape.";
    }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       trial_fe.CalcPhysDShape(Trans, dshape);
@@ -761,15 +759,15 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 1 && test_fe.GetDim() == 1 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakDerivativeIntegrator:  "
              "Trial and test spaces must both be scalar fields in 1D "
@@ -777,9 +775,9 @@ protected:
              "map type \"VALUE\".";
    }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     Vector & shape)
+                                     Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       test_fe.CalcPhysDShape(Trans, dshape);
@@ -799,28 +797,28 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarDivergenceIntegrator:  "
              "Trial must be H(Div) and the test space must be a "
              "scalar field";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    { trial_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -835,14 +833,14 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorDivergenceIntegrator:  "
              "Trial must be H(Div) and the test space must be a "
@@ -851,14 +849,14 @@ protected:
 
    // Subtract one due to the divergence and add one for the coefficient
    // which is assumed to be at least linear.
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1 + 1; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -874,28 +872,28 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::DIV );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakGradientIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be H(Div)";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   virtual void CalcTestShape(const FiniteElement & test_fe,
+   virtual void CalcTestShape(const FiniteElement &test_fe,
                               ElementTransformation &Trans,
-                              Vector & shape)
+                              Vector &shape)
    {
       test_fe.CalcPhysDivShape(Trans, shape);
       shape *= -1.0;
@@ -914,29 +912,29 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCurlIntegrator:  "
              "Trial must be H(Curl) and the test space must be a "
              "scalar field";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       trial_fe.CalcPhysCurlShape(Trans, dshape);
@@ -946,7 +944,8 @@ protected:
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    // PA extension
@@ -970,24 +969,24 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCurlIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be H(Curl)";
    }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     Vector & shape)
+                                     Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       test_fe.CalcPhysCurlShape(Trans, dshape);
@@ -1028,14 +1027,14 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDotProductIntegrator:  "
              "Trial space must be a vector field "
@@ -1053,15 +1052,15 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::DIV );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakGradDotIntegrator:  "
              "Trial space must be a vector field "
@@ -1070,14 +1069,14 @@ public:
 
    // Subtract one due to the gradient and add one for the coefficient
    // which is assumed to be at least linear.
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1 + 1; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1090,8 +1089,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1099,19 +1098,19 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakDivCrossIntegrator:  "
              "Trial space must be a vector field in 3D "
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1130,8 +1129,8 @@ public:
       : MixedVectorIntegrator(mq) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
@@ -1139,15 +1138,15 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedGradGradIntegrator:  "
              "Trial and test spaces must both be scalar fields "
              "with a gradient operator.";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    {
       // Same as DiffusionIntegrator
@@ -1156,20 +1155,20 @@ public:
              trial_fe.GetOrder() + test_fe.GetOrder() + test_fe.GetDim() - 1;
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1182,8 +1181,8 @@ public:
       : MixedVectorIntegrator(vq, false) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
@@ -1191,27 +1190,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradGradIntegrator:  "
              "Trial and test spaces must both be scalar fields "
              "with a gradient operator.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1230,8 +1229,8 @@ public:
       : MixedVectorIntegrator(mq) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1240,27 +1239,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCurlCurlIntegrator"
              "Trial and test spaces must both be vector fields in 3D "
              "with a curl.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1273,8 +1272,8 @@ public:
       : MixedVectorIntegrator(vq, false) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && trial_fe.GetVDim() == 3 &&
               test_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
@@ -1284,27 +1283,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlCurlIntegrator:  "
              "Trial and test spaces must both be vector fields in 3D "
              "with a curl.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1317,8 +1316,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1327,27 +1326,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlGradIntegrator"
              "Trial space must be a vector field in 3D with a curl"
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1360,8 +1359,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
@@ -1370,27 +1369,27 @@ public:
               test_fe.GetDerivType() == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradCurlIntegrator"
              "Trial space must be a scalar field in 3D with a gradient"
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1404,8 +1403,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1413,19 +1412,19 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakCurlCrossIntegrator:  "
              "Trial space must be a vector field in 3D "
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1439,8 +1438,8 @@ public:
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1448,16 +1447,16 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCurlCrossIntegrator:  "
              "Trial space must be a vector field in 2D "
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       scalar_fe.CalcPhysCurlShape(Trans, dshape);
@@ -1474,8 +1473,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (test_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
@@ -1483,24 +1482,24 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradIntegrator:  "
              "Trial space must be a scalar field with a gradient operator"
              " and the test space must be a vector field both in 3D.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcVShape(Trans, shape); }
 };
 
@@ -1514,8 +1513,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1523,19 +1522,19 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlIntegrator:  "
              "Trial space must be a vector field in 3D with a curl "
              "and the test space must be a vector field";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1549,8 +1548,8 @@ public:
       : MixedScalarVectorIntegrator(vq, false, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1558,16 +1557,16 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlIntegrator:  "
              "Trial space must be a vector field in 2D with a curl "
              "and the test space must be a vector field";
    }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       scalar_fe.CalcPhysCurlShape(Trans, dshape); shape *= -1.0;
@@ -1583,8 +1582,8 @@ public:
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
@@ -1592,19 +1591,19 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCrossGradIntegrator:  "
              "Trial space must be a scalar field in 2D with a gradient "
              "and the test space must be a scalar field";
    }
 
-   inline int GetVDim(const FiniteElement & vector_fe)
+   inline int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1617,15 +1616,15 @@ public:
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCrossProductIntegrator:  "
              "Trial space must be a vector field in 2D "
@@ -1642,24 +1641,24 @@ public:
       : MixedScalarVectorIntegrator(vq, false, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCrossProductIntegrator:  "
              "Trial space must be a scalar field in 2D "
              "and the test space must be a vector field";
    }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1672,27 +1671,27 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDirectionalDerivativeIntegrator:  "
              "Trial space must be a scalar field with a gradient "
              "and the test space must be a scalar field";
    }
 
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1705,8 +1704,8 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
@@ -1714,24 +1713,24 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::DIV   );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedGradDivIntegrator:  "
              "Trial space must be a scalar field with a gradient"
              "and the test space must be a vector field with a divergence";
    }
 
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -1744,8 +1743,8 @@ public:
       : MixedScalarVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::DIV    &&
@@ -1754,24 +1753,24 @@ public:
              );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDivGradIntegrator:  "
              "Trial space must be a vector field with a divergence"
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -1784,27 +1783,27 @@ public:
       : MixedScalarVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD   );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakDivergenceIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline int GetVDim(const FiniteElement & vector_fe)
+   inline int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1825,40 +1824,40 @@ public:
    MixedVectorGradientIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorGradientIntegrator:  "
              "Trial spaces must be H1 and the test space must be a "
              "vector field in 2D or 3D";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    {
       trial_fe.CalcPhysDShape(Trans, shape);
    }
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
-private:
    DenseMatrix Jinv;
 
    // PA extension
@@ -1883,40 +1882,41 @@ public:
    MixedVectorCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorCurlIntegrator:  "
              "Trial space must be H(Curl) and the test space must be a "
              "vector field in 3D";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    {
       trial_fe.CalcPhysCurlShape(Trans, shape);
    }
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
 private:
    // PA extension
    Vector pa_data;
@@ -1942,40 +1942,41 @@ public:
    MixedVectorWeakCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorWeakCurlIntegrator:  "
              "Trial space must be vector field in 3D and the "
              "test space must be H(Curl)";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    {
       test_fe.CalcPhysCurlShape(Trans, shape);
    }
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
 private:
    // PA extension
    Vector pa_data;
@@ -2001,26 +2002,26 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorWeakDivergenceIntegrator:  "
              "Trial space must be vector field and the "
              "test space must be H1";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    {
       test_fe.CalcPhysDShape(Trans, shape);
       shape *= -1.0;
@@ -2043,6 +2044,7 @@ private:
    DenseMatrix gshape;
    DenseMatrix Jadj;
    DenseMatrix elmat_comp;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *trial_maps, *test_maps; ///< Not owned
@@ -2053,13 +2055,13 @@ private:
 public:
    GradientIntegrator() :
       Q{NULL}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
-   { }
+   {}
    GradientIntegrator(Coefficient *q_) :
       Q{q_}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
-   { }
+   {}
    GradientIntegrator(Coefficient &q) :
       Q{&q}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
-   { }
+   {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2071,6 +2073,7 @@ public:
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
@@ -2096,7 +2099,6 @@ private:
 #endif
 
    // PA extension
-   const FiniteElementSpace *fespace;
    const DofToQuad *maps;         ///< Not owned
    const GeometricFactors *geom;  ///< Not owned
    int dim, ne, dofs1D, quad1D;
@@ -2107,30 +2109,31 @@ public:
    /// Construct a diffusion integrator with coefficient Q = 1
    DiffusionIntegrator(const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(NULL), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) { }
+        Q(NULL), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a diffusion integrator with a scalar coefficient q
    DiffusionIntegrator(Coefficient &q, const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(&q), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) { }
+        Q(&q), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a diffusion integrator with a vector coefficient q
    DiffusionIntegrator(VectorCoefficient &q,
                        const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(NULL), VQ(&q), MQ(NULL), maps(NULL), geom(NULL) { }
+        Q(NULL), VQ(&q), MQ(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a diffusion integrator with a matrix coefficient q
    DiffusionIntegrator(MatrixCoefficient &q,
                        const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(NULL), VQ(NULL), MQ(&q), maps(NULL), geom(NULL) { }
+        Q(NULL), VQ(NULL), MQ(&q), maps(NULL), geom(NULL) {}
 
    /** Given a particular Finite Element computes the element stiffness matrix
        elmat. */
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    /** Given a trial and test Finite Element computes the element stiffness
        matrix elmat. */
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
@@ -2154,23 +2157,23 @@ public:
                                     Vector &flux, Vector *d_energy = NULL);
 
    using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+   virtual void AssembleDiagonalPA(Vector &diag);
 
-   virtual void AssemblePA(const FiniteElementSpace &fes);
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   virtual void AssembleDiagonalPA(Vector &diag);
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
 
    virtual void AssembleDiagonalMF(Vector &diag);
 
-   virtual void AddMultMF(const Vector&, Vector&) const;
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
                                          const FiniteElement &test_fe);
@@ -2183,55 +2186,62 @@ public:
 /** Class for local mass matrix assembling a(u,v) := (Q u, v) */
 class MassIntegrator: public BilinearFormIntegrator
 {
+private:
    friend class DGMassInverse;
+
 protected:
 #ifndef MFEM_THREAD_SAFE
    Vector shape, te_shape;
 #endif
    Coefficient *Q;
+
    // PA extension
-   const FiniteElementSpace *fespace;
    Vector pa_data;
-   const DofToQuad *maps;         ///< Not owned
-   const GeometricFactors *geom;  ///< Not owned
+   const DofToQuad *maps;                 ///< Not owned
+   const GeometricFactors *geom;          ///< Not owned
+   const FaceGeometricFactors *face_geom; ///< Not owned
    int dim, ne, nq, dofs1D, quad1D;
 
 public:
    MassIntegrator(const IntegrationRule *ir = NULL)
-      : BilinearFormIntegrator(ir), Q(NULL), maps(NULL), geom(NULL) { }
+      : BilinearFormIntegrator(ir), Q(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a mass integrator with coefficient q
    MassIntegrator(Coefficient &q, const IntegrationRule *ir = NULL)
-      : BilinearFormIntegrator(ir), Q(&q), maps(NULL), geom(NULL) { }
+      : BilinearFormIntegrator(ir), Q(&q), maps(NULL), geom(NULL) {}
 
    /** Given a particular Finite Element computes the element mass matrix
        elmat. */
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
    using BilinearFormIntegrator::AssemblePA;
-
-   virtual void AssembleMF(const FiniteElementSpace &fes);
-
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
 
    virtual void AssembleDiagonalPA(Vector &diag);
 
-   virtual void AssembleDiagonalMF(Vector &diag);
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   virtual void AddMultMF(const Vector&, Vector&) const;
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
 
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
+   virtual void AssembleDiagonalMF(Vector &diag);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
                                          const FiniteElement &test_fe,
@@ -2246,7 +2256,7 @@ public:
 class BoundaryMassIntegrator : public MassIntegrator
 {
 public:
-   BoundaryMassIntegrator(Coefficient &q) : MassIntegrator(q) { }
+   BoundaryMassIntegrator(Coefficient &q) : MassIntegrator(q) {}
 
    using BilinearFormIntegrator::AssembleFaceMatrix;
 
@@ -2262,6 +2272,7 @@ class ConvectionIntegrator : public BilinearFormIntegrator
 protected:
    VectorCoefficient *Q;
    double alpha;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;         ///< Not owned
@@ -2278,34 +2289,30 @@ public:
    ConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
       : Q(&q) { alpha = a; }
 
-   virtual void AssembleElementMatrix(const FiniteElement &,
-                                      ElementTransformation &,
-                                      DenseMatrix &);
+   virtual void AssembleElementMatrix(const FiniteElement &fes,
+                                      ElementTransformation &Trans,
+                                      DenseMatrix &elmat);
 
    using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+   virtual void AssembleDiagonalPA(Vector &diag);
 
-   virtual void AssemblePA(const FiniteElementSpace&);
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   virtual void AssembleDiagonalPA(Vector &diag);
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
 
    virtual void AssembleDiagonalMF(Vector &diag);
 
-   virtual void AddMultMF(const Vector&, Vector&) const;
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-
-   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   static const IntegrationRule &GetRule(const FiniteElement &el,
-                                         ElementTransformation &Trans);
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe,
+   static const IntegrationRule &GetRule(const FiniteElement &fe,
                                          ElementTransformation &Trans);
 
    bool SupportsCeed() const { return DeviceCanUseCeed(); }
@@ -2319,7 +2326,7 @@ class ConservativeConvectionIntegrator : public TransposeIntegrator
 {
 public:
    ConservativeConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
-      : TransposeIntegrator(new ConvectionIntegrator(q, -a)) { }
+      : TransposeIntegrator(new ConvectionIntegrator(q, -a)) {}
 };
 
 /// alpha (q . grad u, v) using the "group" FE discretization
@@ -2336,6 +2343,7 @@ private:
 public:
    GroupConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
       : Q(&q) { alpha = a; }
+
    virtual void AssembleElementMatrix(const FiniteElement &,
                                       ElementTransformation &,
                                       DenseMatrix &);
@@ -2357,6 +2365,7 @@ protected:
    Coefficient *Q;
    VectorCoefficient *VQ;
    MatrixCoefficient *MQ;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;         ///< Not owned
@@ -2366,21 +2375,21 @@ protected:
 public:
    /// Construct an integrator with coefficient 1.0
    VectorMassIntegrator()
-      : vdim(-1), Q_order(0), Q(NULL), VQ(NULL), MQ(NULL) { }
+      : vdim(-1), Q_order(0), Q(NULL), VQ(NULL), MQ(NULL) {}
    /** Construct an integrator with scalar coefficient q.  If possible, save
        memory by using a scalar integrator since the resulting matrix is block
        diagonal with the same diagonal block repeated. */
    VectorMassIntegrator(Coefficient &q, int qo = 0)
-      : vdim(-1), Q_order(qo), Q(&q), VQ(NULL), MQ(NULL) { }
+      : vdim(-1), Q_order(qo), Q(&q), VQ(NULL), MQ(NULL) {}
    VectorMassIntegrator(Coefficient &q, const IntegrationRule *ir)
       : BilinearFormIntegrator(ir), vdim(-1), Q_order(0), Q(&q), VQ(NULL),
-        MQ(NULL) { }
+        MQ(NULL) {}
    /// Construct an integrator with diagonal coefficient q
    VectorMassIntegrator(VectorCoefficient &q, int qo = 0)
-      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(&q), MQ(NULL) { }
+      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(&q), MQ(NULL) {}
    /// Construct an integrator with matrix coefficient q
    VectorMassIntegrator(MatrixCoefficient &q, int qo = 0)
-      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(NULL), MQ(&q) { }
+      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(NULL), MQ(&q) {}
 
    int GetVDim() const { return vdim; }
    void SetVDim(int vdim_) { vdim = vdim_; }
@@ -2388,21 +2397,29 @@ public:
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
-   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    bool SupportsCeed() const { return DeviceCanUseCeed(); }
 };
 
-
 /** Class for integrating (div u, p) where u is a vector field given by
     VectorFiniteElement through Piola transformation (for RT elements); p is
     scalar function given by FiniteElement through standard transformation.
@@ -2416,13 +2433,6 @@ class VectorFEDivergenceIntegrator : public BilinearFormIntegrator
 protected:
    Coefficient *Q;
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector divshape, shape;
@@ -2438,17 +2448,26 @@ private:
 public:
    VectorFEDivergenceIntegrator() { Q = NULL; }
    VectorFEDivergenceIntegrator(Coefficient &q) { Q = &q; }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
-                                      DenseMatrix &elmat) { }
+                                      DenseMatrix &elmat) {}
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
    virtual void AssembleDiagonalPA_ADAt(const Vector &D, Vector &diag);
-};
 
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+};
 
 /** Integrator for `(-Q u, grad v)` for Nedelec (`u`) and H1 (`v`) elements.
     This is equivalent to a weak divergence of the Nedelec basis functions. */
@@ -2468,9 +2487,11 @@ private:
 public:
    VectorFEWeakDivergenceIntegrator() { Q = NULL; }
    VectorFEWeakDivergenceIntegrator(Coefficient &q) { Q = &q; }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
-                                      DenseMatrix &elmat) { }
+                                      DenseMatrix &elmat) {}
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2494,9 +2515,11 @@ private:
 public:
    VectorFECurlIntegrator() { Q = NULL; }
    VectorFECurlIntegrator(Coefficient &q) { Q = &q; }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
-                                      DenseMatrix &elmat) { }
+                                      DenseMatrix &elmat) {}
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2515,11 +2538,13 @@ private:
    Vector shape, dshapedxi;
 
 public:
-   DerivativeIntegrator(Coefficient &q, int i) : Q(&q), xi(i) { }
+   DerivativeIntegrator(Coefficient &q, int i) : Q(&q), xi(i) {}
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat)
    { AssembleElementMatrix2(el,el,Trans,elmat); }
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2555,12 +2580,12 @@ public:
    CurlCurlIntegrator() { Q = NULL; DQ = NULL; MQ = NULL; }
    /// Construct a bilinear form integrator for Nedelec elements
    CurlCurlIntegrator(Coefficient &q, const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(&q), DQ(NULL), MQ(NULL) { }
+      BilinearFormIntegrator(ir), Q(&q), DQ(NULL), MQ(NULL) {}
    CurlCurlIntegrator(DiagonalMatrixCoefficient &dq,
                       const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(NULL), DQ(&dq), MQ(NULL) { }
+      BilinearFormIntegrator(ir), Q(NULL), DQ(&dq), MQ(NULL) {}
    CurlCurlIntegrator(MatrixCoefficient &mq, const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(NULL), DQ(NULL), MQ(&mq) { }
+      BilinearFormIntegrator(ir), Q(NULL), DQ(NULL), MQ(&mq) {}
 
    /* Given a particular Finite Element, compute the
       element curl-curl matrix elmat */
@@ -2585,8 +2610,10 @@ public:
 
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
-   virtual void AssembleDiagonalPA(Vector& diag);
 
    const Coefficient *GetCoefficient() const { return Q; }
 };
@@ -2606,7 +2633,7 @@ protected:
 public:
    VectorCurlCurlIntegrator() { Q = NULL; }
 
-   VectorCurlCurlIntegrator(Coefficient &q) : Q(&q) { }
+   VectorCurlCurlIntegrator(Coefficient &q) : Q(&q) {}
 
    /// Assemble an element matrix
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -2637,9 +2664,9 @@ private:
    DenseMatrix curlshape;
    DenseMatrix elmat_comp;
 public:
-   MixedCurlIntegrator() : Q{NULL} { }
-   MixedCurlIntegrator(Coefficient *q_) :  Q{q_} { }
-   MixedCurlIntegrator(Coefficient &q) :  Q{&q} { }
+   MixedCurlIntegrator() : Q{NULL} {}
+   MixedCurlIntegrator(Coefficient *q_) :  Q{q_} {}
+   MixedCurlIntegrator(Coefficient &q) :  Q{&q} {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2693,18 +2720,21 @@ public:
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &fes);
+   virtual void AssemblePA(const FiniteElementSpace &fes) { AssemblePA(fes, fes); }
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
-   virtual void AssembleDiagonalPA(Vector& diag);
 
    const Coefficient *GetCoefficient() const { return Q; }
 };
@@ -2722,6 +2752,7 @@ private:
    DenseMatrix dshape;
    DenseMatrix gshape;
    DenseMatrix Jadj;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *trial_maps, *test_maps; ///< Not owned
@@ -2735,10 +2766,10 @@ public:
    {  }
    VectorDivergenceIntegrator(Coefficient *q_) :
       Q(q_), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   { }
+   {}
    VectorDivergenceIntegrator(Coefficient &q) :
       Q(&q), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   { }
+   {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2750,6 +2781,7 @@ public:
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
@@ -2763,11 +2795,6 @@ class DivDivIntegrator: public BilinearFormIntegrator
 protected:
    Coefficient *Q;
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &fes);
-   virtual void AddMultPA(const Vector &x, Vector &y) const;
-   virtual void AssembleDiagonalPA(Vector& diag);
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector divshape, te_divshape;
@@ -2783,7 +2810,7 @@ private:
 public:
    DivDivIntegrator() { Q = NULL; }
    DivDivIntegrator(Coefficient &q, const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(&q) { }
+      BilinearFormIntegrator(ir), Q(&q) {}
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
@@ -2794,6 +2821,13 @@ public:
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2830,7 +2864,7 @@ private:
    Vector vcoeff;
 
 public:
-   VectorDiffusionIntegrator() { }
+   VectorDiffusionIntegrator() {}
 
    /** \brief Integrator with unit coefficient for caller-specified vector
        dimension.
@@ -2838,13 +2872,13 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(int vector_dimension)
-      : vdim(vector_dimension) { }
+      : vdim(vector_dimension) {}
 
    VectorDiffusionIntegrator(Coefficient &q)
-      : Q(&q) { }
+      : Q(&q) {}
 
    VectorDiffusionIntegrator(Coefficient &q, const IntegrationRule *ir)
-      : BilinearFormIntegrator(ir), Q(&q) { }
+      : BilinearFormIntegrator(ir), Q(&q) {}
 
    /** \brief Integrator with scalar coefficient for caller-specified vector
        dimension.
@@ -2855,7 +2889,7 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(Coefficient &q, int vector_dimension)
-      : Q(&q), vdim(vector_dimension) { }
+      : Q(&q), vdim(vector_dimension) {}
 
    /** \brief Integrator with \c VectorCoefficient. The vector dimension of the
        \c FiniteElementSpace is assumed to be the same as the dimension of the
@@ -2867,7 +2901,7 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(VectorCoefficient &vq)
-      : VQ(&vq), vdim(vq.GetVDim()) { }
+      : VQ(&vq), vdim(vq.GetVDim()) {}
 
    /** \brief Integrator with \c MatrixCoefficient. The vector dimension of the
        \c FiniteElementSpace is assumed to be the same as the dimension of the
@@ -2879,21 +2913,30 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(MatrixCoefficient& mq)
-      : MQ(&mq), vdim(mq.GetVDim()) { }
+      : MQ(&mq), vdim(mq.GetVDim()) {}
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementVector(const FiniteElement &el,
                                       ElementTransformation &Tr,
                                       const Vector &elfun, Vector &elvect);
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
-   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    bool SupportsCeed() const { return DeviceCanUseCeed(); }
 };
 
@@ -2988,6 +3031,7 @@ protected:
    Coefficient *rho;
    VectorCoefficient *u;
    double alpha, beta;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;             ///< Not owned
@@ -3016,24 +3060,20 @@ public:
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-
    virtual void AssemblePAInteriorFaces(const FiniteElementSpace &fes);
 
    virtual void AssemblePABoundaryFaces(const FiniteElementSpace &fes);
 
-   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace& fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace& fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add);
+                                        Vector &ea_data_bdr);
 
    static const IntegrationRule &GetRule(Geometry::Type geom, int order,
                                          FaceElementTransformations &T);
@@ -3056,14 +3096,14 @@ class NonconservativeDGTraceIntegrator : public TransposeIntegrator
 {
 public:
    NonconservativeDGTraceIntegrator(VectorCoefficient &u, double a)
-      : TransposeIntegrator(new DGTraceIntegrator(u, -a, 0.5*a)) { }
+      : TransposeIntegrator(new DGTraceIntegrator(u, -a, 0.5*a)) {}
 
    NonconservativeDGTraceIntegrator(VectorCoefficient &u, double a, double b)
-      : TransposeIntegrator(new DGTraceIntegrator(u, -a, b)) { }
+      : TransposeIntegrator(new DGTraceIntegrator(u, -a, b)) {}
 
    NonconservativeDGTraceIntegrator(Coefficient &rho, VectorCoefficient &u,
                                     double a, double b)
-      : TransposeIntegrator(new DGTraceIntegrator(rho, u, -a, b)) { }
+      : TransposeIntegrator(new DGTraceIntegrator(rho, u, -a, b)) {}
 };
 
 /** Integrator for the DG form:
@@ -3091,11 +3131,12 @@ protected:
 
 public:
    DGDiffusionIntegrator(const double s, const double k)
-      : Q(NULL), MQ(NULL), sigma(s), kappa(k) { }
+      : Q(NULL), MQ(NULL), sigma(s), kappa(k) {}
    DGDiffusionIntegrator(Coefficient &q, const double s, const double k)
-      : Q(&q), MQ(NULL), sigma(s), kappa(k) { }
+      : Q(&q), MQ(NULL), sigma(s), kappa(k) {}
    DGDiffusionIntegrator(MatrixCoefficient &q, const double s, const double k)
-      : Q(NULL), MQ(&q), sigma(s), kappa(k) { }
+      : Q(NULL), MQ(&q), sigma(s), kappa(k) {}
+
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
@@ -3227,11 +3268,11 @@ class DGElasticityIntegrator : public BilinearFormIntegrator
 {
 public:
    DGElasticityIntegrator(double alpha_, double kappa_)
-      : lambda(NULL), mu(NULL), alpha(alpha_), kappa(kappa_) { }
+      : lambda(NULL), mu(NULL), alpha(alpha_), kappa(kappa_) {}
 
    DGElasticityIntegrator(Coefficient &lambda_, Coefficient &mu_,
                           double alpha_, double kappa_)
-      : lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) { }
+      : lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) {}
 
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
@@ -3282,7 +3323,8 @@ private:
    Vector face_shape, shape1, shape2;
 
 public:
-   TraceJumpIntegrator() { }
+   TraceJumpIntegrator() {}
+
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
                                    const FiniteElement &test_fe1,
@@ -3301,7 +3343,8 @@ private:
    DenseMatrix shape1, shape2;
 
 public:
-   NormalTraceJumpIntegrator() { }
+   NormalTraceJumpIntegrator() {}
+
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
                                    const FiniteElement &test_fe1,
@@ -3393,8 +3436,7 @@ public:
 
 /** Abstract class to serve as a base for local interpolators to be used in the
     DiscreteLinearOperator class. */
-class DiscreteInterpolator : public BilinearFormIntegrator { };
-
+class DiscreteInterpolator : public BilinearFormIntegrator {};
 
 /** Class for constructing the gradient as a DiscreteLinearOperator from an
     H1-conforming space to an H(curl)-conforming space. The range space can be
@@ -3402,7 +3444,7 @@ class DiscreteInterpolator : public BilinearFormIntegrator { };
 class GradientInterpolator : public DiscreteInterpolator
 {
 public:
-   GradientInterpolator() : dofquad_fe(NULL) { }
+   GradientInterpolator() : dofquad_fe(NULL) {}
    virtual ~GradientInterpolator() { delete dofquad_fe; }
 
    virtual void AssembleElementMatrix2(const FiniteElement &h1_fe,
@@ -3411,17 +3453,17 @@ public:
                                        DenseMatrix &elmat)
    { nd_fe.ProjectGrad(h1_fe, Trans, elmat); }
 
-   using BilinearFormIntegrator::AssemblePA;
-
    /** @brief Setup method for PA data.
 
        @param[in] trial_fes   H1 Lagrange space
        @param[in] test_fes    H(curl) Nedelec space
     */
+   using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
 private:
@@ -3434,7 +3476,6 @@ private:
    int dim, ne, o_dofs1D, c_dofs1D;
 };
 
-
 /** Class for constructing the identity map as a DiscreteLinearOperator. This
     is the discrete embedding matrix when the domain space is a subspace of
     the range space. Otherwise, a dof projection matrix is constructed. */
@@ -3450,11 +3491,11 @@ public:
    { ran_fe.Project(dom_fe, Trans, elmat); }
 
    using BilinearFormIntegrator::AssemblePA;
-
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    virtual ~IdentityInterpolator() { delete dofquad_fe; }
@@ -3470,7 +3511,6 @@ private:
    Vector pa_data;
 };
 
-
 /** Class for constructing the (local) discrete curl matrix which can be used
     as an integrator in a DiscreteLinearOperator object to assemble the global
     discrete curl matrix. */
@@ -3484,7 +3524,6 @@ public:
    { ran_fe.ProjectCurl(dom_fe, Trans, elmat); }
 };
 
-
 /** Class for constructing the (local) discrete divergence matrix which can
     be used as an integrator in a DiscreteLinearOperator object to assemble
     the global discrete divergence matrix.
@@ -3503,7 +3542,6 @@ public:
    { ran_fe.ProjectDiv(dom_fe, Trans, elmat); }
 };
 
-
 /** A trace face interpolator class for interpolating the normal component of
     the domain space, e.g. vector H1, into the range space, e.g. the trace of
     RT which uses FiniteElement::INTEGRAL map type. */
@@ -3522,7 +3560,7 @@ public:
 class ScalarProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarProductInterpolator(Coefficient & sc) : Q(&sc) { }
+   ScalarProductInterpolator(Coefficient &sc) : Q(&sc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
@@ -3539,13 +3577,14 @@ protected:
 class ScalarVectorProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarVectorProductInterpolator(Coefficient & sc)
-      : Q(&sc) { }
+   ScalarVectorProductInterpolator(Coefficient &sc)
+      : Q(&sc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    Coefficient *Q;
 };
@@ -3556,13 +3595,14 @@ protected:
 class VectorScalarProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorScalarProductInterpolator(VectorCoefficient & vc)
-      : VQ(&vc) { }
+   VectorScalarProductInterpolator(VectorCoefficient &vc)
+      : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
@@ -3572,13 +3612,14 @@ protected:
 class ScalarCrossProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarCrossProductInterpolator(VectorCoefficient & vc)
-      : VQ(&vc) { }
+   ScalarCrossProductInterpolator(VectorCoefficient &vc)
+      : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &nd_fe,
                                        const FiniteElement &l2_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
@@ -3589,13 +3630,14 @@ protected:
 class VectorCrossProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorCrossProductInterpolator(VectorCoefficient & vc)
-      : VQ(&vc) { }
+   VectorCrossProductInterpolator(VectorCoefficient &vc)
+      : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &nd_fe,
                                        const FiniteElement &rt_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
@@ -3606,27 +3648,16 @@ protected:
 class VectorInnerProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorInnerProductInterpolator(VectorCoefficient & vc) : VQ(&vc) { }
+   VectorInnerProductInterpolator(VectorCoefficient &vc) : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &rt_fe,
                                        const FiniteElement &l2_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
 
-
-
-// PA Diffusion Assemble 2D kernel
-template<const int T_SDIM>
-void PADiffusionSetup2D(const int Q1D,
-                        const int coeffDim,
-                        const int NE,
-                        const Array<double> &w,
-                        const Vector &j,
-                        const Vector &c,
-                        Vector &d);
-
 }
 #endif
diff --git a/fem/bilininteg_hcurl.cpp b/fem/bilininteg_hcurl.cpp
deleted file mode 100644
index e8762a71e..000000000
--- a/fem/bilininteg_hcurl.cpp
+++ /dev/null
@@ -1,7764 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qspace.hpp"
-
-using namespace std;
-
-namespace mfem
-{
-
-void PAHcurlHdivSetup3D(const int Q1D,
-                        const int coeffDim,
-                        const int NE,
-                        const bool transpose,
-                        const Array<double> &w_,
-                        const Vector &j,
-                        Vector &coeff_,
-                        Vector &op);
-
-void PAHcurlMassApply2D(const int D1D,
-                        const int Q1D,
-                        const int NE,
-                        const bool symmetric,
-                        const Array<double> &bo,
-                        const Array<double> &bc,
-                        const Array<double> &bot,
-                        const Array<double> &bct,
-                        const Vector &pa_data,
-                        const Vector &x,
-                        Vector &y)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, symmetric ? 3 : 4, NE);
-   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            for (int c = 0; c < VDIM; ++c)
-            {
-               mass[qy][qx][c] = 0.0;
-            }
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-      {
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            double massX[MAX_Q1D];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               massX[qx] = 0.0;
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double t = X(dx + (dy * D1Dx) + osc, e);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-               }
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  mass[qy][qx][c] += massX[qx] * wy;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            const double O11 = op(qx,qy,0,e);
-            const double O21 = op(qx,qy,1,e);
-            const double O12 = symmetric ? O21 : op(qx,qy,2,e);
-            const double O22 = symmetric ? op(qx,qy,2,e) : op(qx,qy,3,e);
-            const double massX = mass[qy][qx][0];
-            const double massY = mass[qy][qx][1];
-            mass[qy][qx][0] = (O11*massX)+(O12*massY);
-            mass[qy][qx][1] = (O21*massX)+(O22*massY);
-         }
-      }
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-         {
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            double massX[MAX_D1D];
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               massX[dx] = 0.0;
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] += mass[qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  Y(dx + (dy * D1Dx) + osc, e) += massX[dx] * wy;
-               }
-            }
-
-            osc += D1Dx * D1Dy;
-         }  // loop c
-      }  // loop qy
-   }); // end of element loop
-}
-
-void PAHcurlMassAssembleDiagonal2D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const bool symmetric,
-                                   const Array<double> &bo,
-                                   const Array<double> &bc,
-                                   const Vector &pa_data,
-                                   Vector &diag)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, symmetric ? 3 : 4, NE);
-   auto D = Reshape(diag.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-      {
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         double mass[MAX_Q1D];
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               mass[qx] = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
-
-                  mass[qx] += wy * wy * ((c == 0) ? op(qx,qy,0,e) :
-                                         op(qx,qy,symmetric ? 2 : 3, e));
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  const double wx = ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-                  D(dx + (dy * D1Dx) + osc, e) += mass[qx] * wx * wx;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop c
-   }); // end of element loop
-}
-
-void PAHcurlMassAssembleDiagonal3D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const bool symmetric,
-                                   const Array<double> &bo,
-                                   const Array<double> &bc,
-                                   const Vector &pa_data,
-                                   Vector &diag)
-{
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
-   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         const int opc = (c == 0) ? 0 : ((c == 1) ? (symmetric ? 3 : 4) :
-                                         (symmetric ? 5 : 8));
-
-         double mass[MAX_Q1D];
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  mass[qx] = 0.0;
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
-
-                     for (int qz = 0; qz < Q1D; ++qz)
-                     {
-                        const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
-
-                        mass[qx] += wy * wy * wz * wz * op(qx,qy,qz,opc,e);
-                     }
-                  }
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-                     D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += mass[qx] * wx * wx;
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop c
-   }); // end of element loop
-}
-
-template<int T_D1D, int T_Q1D>
-void SmemPAHcurlMassAssembleDiagonal3D(const int D1D,
-                                       const int Q1D,
-                                       const int NE,
-                                       const bool symmetric,
-                                       const Array<double> &bo,
-                                       const Array<double> &bc,
-                                       const Vector &pa_data,
-                                       Vector &diag)
-{
-   MFEM_VERIFY(D1D <= HCURL_MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= HCURL_MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
-   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      constexpr int VDIM = 3;
-      constexpr int tD1D = T_D1D ? T_D1D : HCURL_MAX_D1D;
-      constexpr int tQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
-
-      MFEM_SHARED double sBo[tQ1D][tD1D];
-      MFEM_SHARED double sBc[tQ1D][tD1D];
-
-      double op3[3];
-      MFEM_SHARED double sop[3][tQ1D][tQ1D];
-
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               op3[0] = op(qx,qy,qz,0,e);
-               op3[1] = op(qx,qy,qz,symmetric ? 3 : 4,e);
-               op3[2] = op(qx,qy,qz,symmetric ? 5 : 8,e);
-            }
-         }
-      }
-
-      const int tidx = MFEM_THREAD_ID(x);
-      const int tidy = MFEM_THREAD_ID(y);
-      const int tidz = MFEM_THREAD_ID(z);
-
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               sBc[q][d] = Bc(q,d);
-               if (d < D1D-1)
-               {
-                  sBo[q][d] = Bo(q,d);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-
-      int osc = 0;
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         double dxyz = 0.0;
-
-         for (int qz=0; qz < Q1D; ++qz)
-         {
-            if (tidz == qz)
-            {
-               for (int i=0; i<3; ++i)
-               {
-                  sop[i][tidx][tidy] = op3[i];
-               }
-            }
-
-            MFEM_SYNC_THREAD;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               const double wz = ((c == 2) ? sBo[qz][dz] : sBc[qz][dz]);
-
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     for (int qy = 0; qy < Q1D; ++qy)
-                     {
-                        const double wy = ((c == 1) ? sBo[qy][dy] : sBc[qy][dy]);
-
-                        for (int qx = 0; qx < Q1D; ++qx)
-                        {
-                           const double wx = ((c == 0) ? sBo[qx][dx] : sBc[qx][dx]);
-                           dxyz += sop[c][qx][qy] * wx * wx * wy * wy * wz * wz;
-                        }
-                     }
-                  }
-               }
-            }
-
-            MFEM_SYNC_THREAD;
-         }  // qz loop
-
-         MFEM_FOREACH_THREAD(dz,z,D1Dz)
-         {
-            MFEM_FOREACH_THREAD(dy,y,D1Dy)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1Dx)
-               {
-                  D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += dxyz;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // c loop
-   }); // end of element loop
-}
-
-void PAHcurlMassApply3D(const int D1D,
-                        const int Q1D,
-                        const int NE,
-                        const bool symmetric,
-                        const Array<double> &bo,
-                        const Array<double> &bc,
-                        const Array<double> &bot,
-                        const Array<double> &bct,
-                        const Vector &pa_data,
-                        const Vector &x,
-                        Vector &y)
-{
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  mass[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double massXY[MAX_Q1D][MAX_Q1D];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massXY[qy][qx] = 0.0;
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     massXY[qy][qx] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(qx,qy,qz,0,e);
-               const double O12 = op(qx,qy,qz,1,e);
-               const double O13 = op(qx,qy,qz,2,e);
-               const double O21 = symmetric ? O12 : op(qx,qy,qz,3,e);
-               const double O22 = symmetric ? op(qx,qy,qz,3,e) : op(qx,qy,qz,4,e);
-               const double O23 = symmetric ? op(qx,qy,qz,4,e) : op(qx,qy,qz,5,e);
-               const double O31 = symmetric ? O13 : op(qx,qy,qz,6,e);
-               const double O32 = symmetric ? O23 : op(qx,qy,qz,7,e);
-               const double O33 = symmetric ? op(qx,qy,qz,5,e) : op(qx,qy,qz,8,e);
-               const double massX = mass[qz][qy][qx][0];
-               const double massY = mass[qz][qy][qx][1];
-               const double massZ = mass[qz][qy][qx][2];
-               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
-               mass[qz][qy][qx][1] = (O21*massX)+(O22*massY)+(O23*massZ);
-               mass[qz][qy][qx][2] = (O31*massX)+(O32*massY)+(O33*massZ);
-            }
-         }
-      }
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         double massXY[MAX_D1D][MAX_D1D];
-
-         osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massXY[dy][dx] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[MAX_D1D];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] = 0;
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massX[dx] += mass[qz][qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massXY[dy][dx] += massX[dx] * wy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = (c == 2) ? Bot(dz,qz) : Bct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += massXY[dy][dx] * wz;
-                  }
-               }
-            }
-
-            osc += D1Dx * D1Dy * D1Dz;
-         }  // loop c
-      }  // loop qz
-   }); // end of element loop
-}
-
-template<int T_D1D, int T_Q1D>
-void SmemPAHcurlMassApply3D(const int D1D,
-                            const int Q1D,
-                            const int NE,
-                            const bool symmetric,
-                            const Array<double> &bo,
-                            const Array<double> &bc,
-                            const Array<double> &bot,
-                            const Array<double> &bct,
-                            const Vector &pa_data,
-                            const Vector &x,
-                            Vector &y)
-{
-   MFEM_VERIFY(D1D <= HCURL_MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= HCURL_MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   const int dataSize = symmetric ? 6 : 9;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, dataSize, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      constexpr int VDIM = 3;
-      constexpr int tD1D = T_D1D ? T_D1D : HCURL_MAX_D1D;
-      constexpr int tQ1D = T_Q1D ? T_Q1D : HCURL_MAX_Q1D;
-
-      MFEM_SHARED double sBo[tQ1D][tD1D];
-      MFEM_SHARED double sBc[tQ1D][tD1D];
-
-      double op9[9];
-      MFEM_SHARED double sop[9*tQ1D*tQ1D];
-      MFEM_SHARED double mass[tQ1D][tQ1D][3];
-
-      MFEM_SHARED double sX[tD1D][tD1D][tD1D];
-
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               for (int i=0; i<dataSize; ++i)
-               {
-                  op9[i] = op(qx,qy,qz,i,e);
-               }
-            }
-         }
-      }
-
-      const int tidx = MFEM_THREAD_ID(x);
-      const int tidy = MFEM_THREAD_ID(y);
-      const int tidz = MFEM_THREAD_ID(z);
-
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               sBc[q][d] = Bc(q,d);
-               if (d < D1D-1)
-               {
-                  sBo[q][d] = Bo(q,d);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-
-      for (int qz=0; qz < Q1D; ++qz)
-      {
-         int osc = 0;
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  }
-               }
-            }
-            MFEM_SYNC_THREAD;
-
-            if (tidz == qz)
-            {
-               for (int i=0; i<dataSize; ++i)
-               {
-                  sop[i + (dataSize*tidx) + (dataSize*Q1D*tidy)] = op9[i];
-               }
-
-               MFEM_FOREACH_THREAD(qy,y,Q1D)
-               {
-                  MFEM_FOREACH_THREAD(qx,x,Q1D)
-                  {
-                     double u = 0.0;
-
-                     for (int dz = 0; dz < D1Dz; ++dz)
-                     {
-                        const double wz = (c == 2) ? sBo[qz][dz] : sBc[qz][dz];
-                        for (int dy = 0; dy < D1Dy; ++dy)
-                        {
-                           const double wy = (c == 1) ? sBo[qy][dy] : sBc[qy][dy];
-                           for (int dx = 0; dx < D1Dx; ++dx)
-                           {
-                              const double t = sX[dz][dy][dx];
-                              const double wx = (c == 0) ? sBo[qx][dx] : sBc[qx][dx];
-                              u += t * wx * wy * wz;
-                           }
-                        }
-                     }
-
-                     mass[qy][qx][c] = u;
-                  } // qx
-               } // qy
-            } // tidz == qz
-
-            osc += D1Dx * D1Dy * D1Dz;
-            MFEM_SYNC_THREAD;
-         } // c
-
-         MFEM_SYNC_THREAD;  // Sync mass[qy][qx][d] and sop
-
-         osc = 0;
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            double dxyz = 0.0;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               const double wz = (c == 2) ? sBo[qz][dz] : sBc[qz][dz];
-
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     for (int qy = 0; qy < Q1D; ++qy)
-                     {
-                        const double wy = (c == 1) ? sBo[qy][dy] : sBc[qy][dy];
-                        for (int qx = 0; qx < Q1D; ++qx)
-                        {
-                           const int os = (dataSize*qx) + (dataSize*Q1D*qy);
-                           const int id1 = os + ((c == 0) ? 0 : ((c == 1) ? (symmetric ? 1 : 3) :
-                                                                 (symmetric ? 2 : 6))); // O11, O21, O31
-                           const int id2 = os + ((c == 0) ? 1 : ((c == 1) ? (symmetric ? 3 : 4) :
-                                                                 (symmetric ? 4 : 7))); // O12, O22, O32
-                           const int id3 = os + ((c == 0) ? 2 : ((c == 1) ? (symmetric ? 4 : 5) :
-                                                                 (symmetric ? 5 : 8))); // O13, O23, O33
-
-                           const double m_c = (sop[id1] * mass[qy][qx][0]) + (sop[id2] * mass[qy][qx][1]) +
-                                              (sop[id3] * mass[qy][qx][2]);
-
-                           const double wx = (c == 0) ? sBo[qx][dx] : sBc[qx][dx];
-                           dxyz += m_c * wx * wy * wz;
-                        }
-                     }
-                  }
-               }
-            }
-
-            MFEM_SYNC_THREAD;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += dxyz;
-                  }
-               }
-            }
-
-            osc += D1Dx * D1Dy * D1Dz;
-         } // c loop
-      } // qz
-   }); // end of element loop
-}
-
-// PA H(curl) curl-curl assemble 2D kernel
-static void PACurlCurlSetup2D(const int Q1D,
-                              const int NE,
-                              const Array<double> &w,
-                              const Vector &j,
-                              Vector &coeff,
-                              Vector &op)
-{
-   const int NQ = Q1D*Q1D;
-   auto W = w.Read();
-   auto J = Reshape(j.Read(), NQ, 2, 2, NE);
-   auto C = Reshape(coeff.Read(), NQ, NE);
-   auto y = Reshape(op.Write(), NQ, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int q = 0; q < NQ; ++q)
-      {
-         const double J11 = J(q,0,0,e);
-         const double J21 = J(q,1,0,e);
-         const double J12 = J(q,0,1,e);
-         const double J22 = J(q,1,1,e);
-         const double detJ = (J11*J22)-(J21*J12);
-         y(q,e) = W[q] * C(q,e) / detJ;
-      }
-   });
-}
-
-// PA H(curl) curl-curl assemble 3D kernel
-static void PACurlCurlSetup3D(const int Q1D,
-                              const int coeffDim,
-                              const int NE,
-                              const Array<double> &w,
-                              const Vector &j,
-                              Vector &coeff,
-                              Vector &op)
-{
-   const int NQ = Q1D*Q1D*Q1D;
-   const bool symmetric = (coeffDim != 9);
-   auto W = w.Read();
-   auto J = Reshape(j.Read(), NQ, 3, 3, NE);
-   auto C = Reshape(coeff.Read(), coeffDim, NQ, NE);
-   auto y = Reshape(op.Write(), NQ, symmetric ? 6 : 9, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int q = 0; q < NQ; ++q)
-      {
-         const double J11 = J(q,0,0,e);
-         const double J21 = J(q,1,0,e);
-         const double J31 = J(q,2,0,e);
-         const double J12 = J(q,0,1,e);
-         const double J22 = J(q,1,1,e);
-         const double J32 = J(q,2,1,e);
-         const double J13 = J(q,0,2,e);
-         const double J23 = J(q,1,2,e);
-         const double J33 = J(q,2,2,e);
-         const double detJ = J11 * (J22 * J33 - J32 * J23) -
-                             J21 * (J12 * J33 - J32 * J13) +
-                             J31 * (J12 * J23 - J22 * J13);
-
-         const double c_detJ = W[q] / detJ;
-
-         if (coeffDim == 6 || coeffDim == 9) // Matrix coefficient version
-         {
-            // Set y to the 6 or 9 entries of J^T M J / det
-            const double M11 = C(0, q, e);
-            const double M12 = C(1, q, e);
-            const double M13 = C(2, q, e);
-            const double M21 = (!symmetric) ? C(3, q, e) : M12;
-            const double M22 = (!symmetric) ? C(4, q, e) : C(3, q, e);
-            const double M23 = (!symmetric) ? C(5, q, e) : C(4, q, e);
-            const double M31 = (!symmetric) ? C(6, q, e) : M13;
-            const double M32 = (!symmetric) ? C(7, q, e) : M23;
-            const double M33 = (!symmetric) ? C(8, q, e) : C(5, q, e);
-
-            // First compute R = MJ
-            const double R11 = M11*J11 + M12*J21 + M13*J31;
-            const double R12 = M11*J12 + M12*J22 + M13*J32;
-            const double R13 = M11*J13 + M12*J23 + M13*J33;
-            const double R21 = M21*J11 + M22*J21 + M23*J31;
-            const double R22 = M21*J12 + M22*J22 + M23*J32;
-            const double R23 = M21*J13 + M22*J23 + M23*J33;
-            const double R31 = M31*J11 + M32*J21 + M33*J31;
-            const double R32 = M31*J12 + M32*J22 + M33*J32;
-            const double R33 = M31*J13 + M32*J23 + M33*J33;
-
-            // Now set y to J^T R / det
-            y(q,0,e) = c_detJ * (J11*R11 + J21*R21 + J31*R31); // 1,1
-            const double Y12 = c_detJ * (J11*R12 + J21*R22 + J31*R32);
-            y(q,1,e) = Y12; // 1,2
-            y(q,2,e) = c_detJ * (J11*R13 + J21*R23 + J31*R33); // 1,3
-
-            const double Y21 = c_detJ * (J12*R11 + J22*R21 + J32*R31);
-            const double Y22 = c_detJ * (J12*R12 + J22*R22 + J32*R32);
-            const double Y23 = c_detJ * (J12*R13 + J22*R23 + J32*R33);
-
-            const double Y33 = c_detJ * (J13*R13 + J23*R23 + J33*R33);
-
-            y(q,3,e) = symmetric ? Y22 : Y21; // 2,2 or 2,1
-            y(q,4,e) = symmetric ? Y23 : Y22; // 2,3 or 2,2
-            y(q,5,e) = symmetric ? Y33 : Y23; // 3,3 or 2,3
-
-            if (!symmetric)
-            {
-               y(q,6,e) = c_detJ * (J13*R11 + J23*R21 + J33*R31); // 3,1
-               y(q,7,e) = c_detJ * (J13*R12 + J23*R22 + J33*R32); // 3,2
-               y(q,8,e) = Y33; // 3,3
-            }
-         }
-         else  // Vector or scalar coefficient version
-         {
-            // Set y to the 6 entries of J^T D J / det^2
-            const double D1 = C(0, q, e);
-            const double D2 = coeffDim == 3 ? C(1, q, e) : D1;
-            const double D3 = coeffDim == 3 ? C(2, q, e) : D1;
-
-            y(q,0,e) = c_detJ * (D1*J11*J11 + D2*J21*J21 + D3*J31*J31); // 1,1
-            y(q,1,e) = c_detJ * (D1*J11*J12 + D2*J21*J22 + D3*J31*J32); // 1,2
-            y(q,2,e) = c_detJ * (D1*J11*J13 + D2*J21*J23 + D3*J31*J33); // 1,3
-            y(q,3,e) = c_detJ * (D1*J12*J12 + D2*J22*J22 + D3*J32*J32); // 2,2
-            y(q,4,e) = c_detJ * (D1*J12*J13 + D2*J22*J23 + D3*J32*J33); // 2,3
-            y(q,5,e) = c_detJ * (D1*J13*J13 + D2*J23*J23 + D3*J33*J33); // 3,3
-         }
-      }
-   });
-}
-
-// PA H(curl)-L2 assemble 2D kernel
-static void PACurlL2Setup2D(const int Q1D,
-                            const int NE,
-                            const Array<double> &w,
-                            Vector &coeff,
-                            Vector &op)
-{
-   const int NQ = Q1D*Q1D;
-   auto W = w.Read();
-   auto C = Reshape(coeff.Read(), NQ, NE);
-   auto y = Reshape(op.Write(), NQ, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int q = 0; q < NQ; ++q)
-      {
-         y(q,e) = W[q] * C(q,e);
-      }
-   });
-}
-
-void CurlCurlIntegrator::AssemblePA(const FiniteElementSpace &fes)
-{
-   // Assumes tensor-product elements
-   Mesh *mesh = fes.GetMesh();
-   const FiniteElement *fel = fes.GetFE(0);
-
-   const VectorTensorFiniteElement *el =
-      dynamic_cast<const VectorTensorFiniteElement*>(fel);
-   MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*el, *el,
-                                                     *mesh->GetElementTransformation(0));
-
-   const int dims = el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   ne = fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(qs, CoefficientStorage::SYMMETRIC);
-   if (Q) { coeff.Project(*Q); }
-   else if (MQ) { coeff.ProjectTranspose(*MQ); }
-   else if (DQ) { coeff.Project(*DQ); }
-   else { coeff.SetConstant(1.0); }
-
-   const int coeff_dim = coeff.GetVDim();
-   symmetric = (coeff_dim != dim*dim);
-   const int sym_dims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-   const int ndata = (dim == 2) ? 1 : (symmetric ? sym_dims : dim*dim);
-   pa_data.SetSize(ndata * nq * ne, Device::GetMemoryType());
-
-   if (el->GetDerivType() != mfem::FiniteElement::CURL)
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
-
-   if (dim == 3)
-   {
-      PACurlCurlSetup3D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J, coeff,
-                        pa_data);
-   }
-   else
-   {
-      PACurlCurlSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
-   }
-}
-
-static void PACurlCurlApply2D(const int D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &bo,
-                              const Array<double> &bot,
-                              const Array<double> &gc,
-                              const Array<double> &gct,
-                              const Vector &pa_data,
-                              const Vector &x,
-                              Vector &y)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto Gct = Reshape(gct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
-   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double curl[MAX_Q1D][MAX_Q1D];
-
-      // curl[qy][qx] will be computed as du_y/dx - du_x/dy
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            curl[qy][qx] = 0.0;
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-      {
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            double gradX[MAX_Q1D];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               gradX[qx] = 0;
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double t = X(dx + (dy * D1Dx) + osc, e);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  gradX[qx] += t * ((c == 0) ? Bo(qx,dx) : Gc(qx,dx));
-               }
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const double wy = (c == 0) ? -Gc(qy,dy) : Bo(qy,dy);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  curl[qy][qx] += gradX[qx] * wy;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            curl[qy][qx] *= op(qx,qy,e);
-         }
-      }
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-         {
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            double gradX[MAX_D1D];
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               gradX[dx] = 0.0;
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradX[dx] += curl[qy][qx] * ((c == 0) ? Bot(dx,qx) : Gct(dx,qx));
-               }
-            }
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               const double wy = (c == 0) ? -Gct(dy,qy) : Bot(dy,qy);
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  Y(dx + (dy * D1Dx) + osc, e) += gradX[dx] * wy;
-               }
-            }
-
-            osc += D1Dx * D1Dy;
-         }  // loop c
-      }  // loop qy
-   }); // end of element loop
-}
-
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void PACurlCurlApply3D(const int D1D,
-                              const int Q1D,
-                              const bool symmetric,
-                              const int NE,
-                              const Array<double> &bo,
-                              const Array<double> &bc,
-                              const Array<double> &bot,
-                              const Array<double> &bct,
-                              const Array<double> &gc,
-                              const Array<double> &gct,
-                              const Vector &pa_data,
-                              const Vector &x,
-                              Vector &y)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
-   // (\nabla\times u) \cdot (\nabla\times v) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{v}
-   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1D, Q1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto Gct = Reshape(gct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, (symmetric ? 6 : 9), NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double curl[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-      // curl[qz][qy][qx] will be computed as the vector curl at each quadrature point.
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  curl[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      // We treat x, y, z components separately for optimization specific to each.
-
-      int osc = 0;
-
-      {
-         // x component
-         const int D1Dz = D1D;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D - 1;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double gradXY[MAX_Q1D][MAX_Q1D][2];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradXY[qy][qx][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * Bo(qx,dx);
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = Bc(qy,dy);
-                  const double wDy = Gc(qy,dy);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     gradXY[qy][qx][0] += wx * wDy;
-                     gradXY[qy][qx][1] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = Bc(qz,dz);
-               const double wDz = Gc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                     curl[qz][qy][qx][1] += gradXY[qy][qx][1] * wDz; // (u_0)_{x_2}
-                     curl[qz][qy][qx][2] -= gradXY[qy][qx][0] * wz;  // -(u_0)_{x_1}
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      {
-         // y component
-         const int D1Dz = D1D;
-         const int D1Dy = D1D - 1;
-         const int D1Dx = D1D;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double gradXY[MAX_Q1D][MAX_Q1D][2];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradXY[qy][qx][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               double massY[MAX_Q1D];
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  massY[qy] = 0.0;
-               }
-
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     massY[qy] += t * Bo(qy,dy);
-                  }
-               }
-
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  const double wx = Bc(qx,dx);
-                  const double wDx = Gc(qx,dx);
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wy = massY[qy];
-                     gradXY[qy][qx][0] += wDx * wy;
-                     gradXY[qy][qx][1] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = Bc(qz,dz);
-               const double wDz = Gc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                     curl[qz][qy][qx][0] -= gradXY[qy][qx][1] * wDz; // -(u_1)_{x_2}
-                     curl[qz][qy][qx][2] += gradXY[qy][qx][0] * wz;  // (u_1)_{x_0}
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      {
-         // z component
-         const int D1Dz = D1D - 1;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D;
-
-         for (int dx = 0; dx < D1Dx; ++dx)
-         {
-            double gradYZ[MAX_Q1D][MAX_Q1D][2];
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradYZ[qz][qy][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massZ[MAX_Q1D];
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  massZ[qz] = 0.0;
-               }
-
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     massZ[qz] += t * Bo(qz,dz);
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = Bc(qy,dy);
-                  const double wDy = Gc(qy,dy);
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     const double wz = massZ[qz];
-                     gradYZ[qz][qy][0] += wz * wy;
-                     gradYZ[qz][qy][1] += wz * wDy;
-                  }
-               }
-            }
-
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double wx = Bc(qx,dx);
-               const double wDx = Gc(qx,dx);
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-                     curl[qz][qy][qx][0] += gradYZ[qz][qy][1] * wx;  // (u_2)_{x_1}
-                     curl[qz][qy][qx][1] -= gradYZ[qz][qy][0] * wDx; // -(u_2)_{x_0}
-                  }
-               }
-            }
-         }
-      }
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(qx,qy,qz,0,e);
-               const double O12 = op(qx,qy,qz,1,e);
-               const double O13 = op(qx,qy,qz,2,e);
-               const double O21 = symmetric ? O12 : op(qx,qy,qz,3,e);
-               const double O22 = symmetric ? op(qx,qy,qz,3,e) : op(qx,qy,qz,4,e);
-               const double O23 = symmetric ? op(qx,qy,qz,4,e) : op(qx,qy,qz,5,e);
-               const double O31 = symmetric ? O13 : op(qx,qy,qz,6,e);
-               const double O32 = symmetric ? O23 : op(qx,qy,qz,7,e);
-               const double O33 = symmetric ? op(qx,qy,qz,5,e) : op(qx,qy,qz,8,e);
-
-               const double c1 = (O11 * curl[qz][qy][qx][0]) + (O12 * curl[qz][qy][qx][1]) +
-                                 (O13 * curl[qz][qy][qx][2]);
-               const double c2 = (O21 * curl[qz][qy][qx][0]) + (O22 * curl[qz][qy][qx][1]) +
-                                 (O23 * curl[qz][qy][qx][2]);
-               const double c3 = (O31 * curl[qz][qy][qx][0]) + (O32 * curl[qz][qy][qx][1]) +
-                                 (O33 * curl[qz][qy][qx][2]);
-
-               curl[qz][qy][qx][0] = c1;
-               curl[qz][qy][qx][1] = c2;
-               curl[qz][qy][qx][2] = c3;
-            }
-         }
-      }
-
-      // x component
-      osc = 0;
-      {
-         const int D1Dz = D1D;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D - 1;
-
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            double gradXY12[MAX_D1D][MAX_D1D];
-            double gradXY21[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradXY12[dy][dx] = 0.0;
-                  gradXY21[dy][dx] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[MAX_D1D][2];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  for (int n = 0; n < 2; ++n)
-                  {
-                     massX[dx][n] = 0.0;
-                  }
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     const double wx = Bot(dx,qx);
-
-                     massX[dx][0] += wx * curl[qz][qy][qx][1];
-                     massX[dx][1] += wx * curl[qz][qy][qx][2];
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = Bct(dy,qy);
-                  const double wDy = Gct(dy,qy);
-
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     gradXY21[dy][dx] += massX[dx][0] * wy;
-                     gradXY12[dy][dx] += massX[dx][1] * wDy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = Bct(dz,qz);
-               const double wDz = Gct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                     // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (gradXY21[dy][dx] * wDz) - (gradXY12[dy][dx] * wz);
-                  }
-               }
-            }
-         }  // loop qz
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      // y component
-      {
-         const int D1Dz = D1D;
-         const int D1Dy = D1D - 1;
-         const int D1Dx = D1D;
-
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            double gradXY02[MAX_D1D][MAX_D1D];
-            double gradXY20[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradXY02[dy][dx] = 0.0;
-                  gradXY20[dy][dx] = 0.0;
-               }
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               double massY[MAX_D1D][2];
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  massY[dy][0] = 0.0;
-                  massY[dy][1] = 0.0;
-               }
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int dy = 0; dy < D1Dy; ++dy)
-                  {
-                     const double wy = Bot(dy,qy);
-
-                     massY[dy][0] += wy * curl[qz][qy][qx][2];
-                     massY[dy][1] += wy * curl[qz][qy][qx][0];
-                  }
-               }
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double wx = Bct(dx,qx);
-                  const double wDx = Gct(dx,qx);
-
-                  for (int dy = 0; dy < D1Dy; ++dy)
-                  {
-                     gradXY02[dy][dx] += massY[dy][0] * wDx;
-                     gradXY20[dy][dx] += massY[dy][1] * wx;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = Bct(dz,qz);
-               const double wDz = Gct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                     // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (-gradXY20[dy][dx] * wDz) + (gradXY02[dy][dx] * wz);
-                  }
-               }
-            }
-         }  // loop qz
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      // z component
-      {
-         const int D1Dz = D1D - 1;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D;
-
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            double gradYZ01[MAX_D1D][MAX_D1D];
-            double gradYZ10[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  gradYZ01[dz][dy] = 0.0;
-                  gradYZ10[dz][dy] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massZ[MAX_D1D][2];
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  for (int n = 0; n < 2; ++n)
-                  {
-                     massZ[dz][n] = 0.0;
-                  }
-               }
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     const double wz = Bot(dz,qz);
-
-                     massZ[dz][0] += wz * curl[qz][qy][qx][0];
-                     massZ[dz][1] += wz * curl[qz][qy][qx][1];
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = Bct(dy,qy);
-                  const double wDy = Gct(dy,qy);
-
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     gradYZ01[dz][dy] += wy * massZ[dz][1];
-                     gradYZ10[dz][dy] += wDy * massZ[dz][0];
-                  }
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double wx = Bct(dx,qx);
-               const double wDx = Gct(dx,qx);
-
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-                     // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (gradYZ10[dz][dy] * wx) - (gradYZ01[dz][dy] * wDx);
-                  }
-               }
-            }
-         }  // loop qx
-      }
-   }); // end of element loop
-}
-
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void SmemPACurlCurlApply3D(const int D1D,
-                                  const int Q1D,
-                                  const bool symmetric,
-                                  const int NE,
-                                  const Array<double> &bo,
-                                  const Array<double> &bc,
-                                  const Array<double> &bot,
-                                  const Array<double> &bct,
-                                  const Array<double> &gc,
-                                  const Array<double> &gct,
-                                  const Vector &pa_data,
-                                  const Vector &x,
-                                  Vector &y)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
-   // (\nabla\times u) \cdot (\nabla\times v) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{v}
-   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   const int s = symmetric ? 6 : 9;
-
-   auto device_kernel = [=] MFEM_DEVICE (int e)
-   {
-      constexpr int VDIM = 3;
-
-      MFEM_SHARED double sBo[MAX_D1D][MAX_Q1D];
-      MFEM_SHARED double sBc[MAX_D1D][MAX_Q1D];
-      MFEM_SHARED double sGc[MAX_D1D][MAX_Q1D];
-
-      double ope[9];
-      MFEM_SHARED double sop[9][MAX_Q1D][MAX_Q1D];
-      MFEM_SHARED double curl[MAX_Q1D][MAX_Q1D][3];
-
-      MFEM_SHARED double sX[MAX_D1D][MAX_D1D][MAX_D1D];
-
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               for (int i=0; i<s; ++i)
-               {
-                  ope[i] = op(qx,qy,qz,i,e);
-               }
-            }
-         }
-      }
-
-      const int tidx = MFEM_THREAD_ID(x);
-      const int tidy = MFEM_THREAD_ID(y);
-      const int tidz = MFEM_THREAD_ID(z);
-
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               sBc[d][q] = Bc(q,d);
-               sGc[d][q] = Gc(q,d);
-               if (d < D1D-1)
-               {
-                  sBo[d][q] = Bo(q,d);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-
-      for (int qz=0; qz < Q1D; ++qz)
-      {
-         if (tidz == qz)
-         {
-            MFEM_FOREACH_THREAD(qy,y,Q1D)
-            {
-               MFEM_FOREACH_THREAD(qx,x,Q1D)
-               {
-                  for (int i=0; i<3; ++i)
-                  {
-                     curl[qy][qx][i] = 0.0;
-                  }
-               }
-            }
-         }
-
-         int osc = 0;
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  }
-               }
-            }
-            MFEM_SYNC_THREAD;
-
-            if (tidz == qz)
-            {
-               if (c == 0)
-               {
-                  for (int i=0; i<s; ++i)
-                  {
-                     sop[i][tidx][tidy] = ope[i];
-                  }
-               }
-
-               MFEM_FOREACH_THREAD(qy,y,Q1D)
-               {
-                  MFEM_FOREACH_THREAD(qx,x,Q1D)
-                  {
-                     double u = 0.0;
-                     double v = 0.0;
-
-                     // We treat x, y, z components separately for optimization specific to each.
-                     if (c == 0) // x component
-                     {
-                        // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-
-                        for (int dz = 0; dz < D1Dz; ++dz)
-                        {
-                           const double wz = sBc[dz][qz];
-                           const double wDz = sGc[dz][qz];
-
-                           for (int dy = 0; dy < D1Dy; ++dy)
-                           {
-                              const double wy = sBc[dy][qy];
-                              const double wDy = sGc[dy][qy];
-
-                              for (int dx = 0; dx < D1Dx; ++dx)
-                              {
-                                 const double wx = sX[dz][dy][dx] * sBo[dx][qx];
-                                 u += wx * wDy * wz;
-                                 v += wx * wy * wDz;
-                              }
-                           }
-                        }
-
-                        curl[qy][qx][1] += v; // (u_0)_{x_2}
-                        curl[qy][qx][2] -= u;  // -(u_0)_{x_1}
-                     }
-                     else if (c == 1)  // y component
-                     {
-                        // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-
-                        for (int dz = 0; dz < D1Dz; ++dz)
-                        {
-                           const double wz = sBc[dz][qz];
-                           const double wDz = sGc[dz][qz];
-
-                           for (int dy = 0; dy < D1Dy; ++dy)
-                           {
-                              const double wy = sBo[dy][qy];
-
-                              for (int dx = 0; dx < D1Dx; ++dx)
-                              {
-                                 const double t = sX[dz][dy][dx];
-                                 const double wx = t * sBc[dx][qx];
-                                 const double wDx = t * sGc[dx][qx];
-
-                                 u += wDx * wy * wz;
-                                 v += wx * wy * wDz;
-                              }
-                           }
-                        }
-
-                        curl[qy][qx][0] -= v; // -(u_1)_{x_2}
-                        curl[qy][qx][2] += u; // (u_1)_{x_0}
-                     }
-                     else // z component
-                     {
-                        // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-                        for (int dz = 0; dz < D1Dz; ++dz)
-                        {
-                           const double wz = sBo[dz][qz];
-
-                           for (int dy = 0; dy < D1Dy; ++dy)
-                           {
-                              const double wy = sBc[dy][qy];
-                              const double wDy = sGc[dy][qy];
-
-                              for (int dx = 0; dx < D1Dx; ++dx)
-                              {
-                                 const double t = sX[dz][dy][dx];
-                                 const double wx = t * sBc[dx][qx];
-                                 const double wDx = t * sGc[dx][qx];
-
-                                 u += wDx * wy * wz;
-                                 v += wx * wDy * wz;
-                              }
-                           }
-                        }
-
-                        curl[qy][qx][0] += v; // (u_2)_{x_1}
-                        curl[qy][qx][1] -= u; // -(u_2)_{x_0}
-                     }
-                  } // qx
-               } // qy
-            } // tidz == qz
-
-            osc += D1Dx * D1Dy * D1Dz;
-            MFEM_SYNC_THREAD;
-         } // c
-
-         double dxyz1 = 0.0;
-         double dxyz2 = 0.0;
-         double dxyz3 = 0.0;
-
-         MFEM_FOREACH_THREAD(dz,z,D1D)
-         {
-            const double wcz = sBc[dz][qz];
-            const double wcDz = sGc[dz][qz];
-            const double wz = (dz < D1D-1) ? sBo[dz][qz] : 0.0;
-
-            MFEM_FOREACH_THREAD(dy,y,D1D)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1D)
-               {
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wcy = sBc[dy][qy];
-                     const double wcDy = sGc[dy][qy];
-                     const double wy = (dy < D1D-1) ? sBo[dy][qy] : 0.0;
-
-                     for (int qx = 0; qx < Q1D; ++qx)
-                     {
-                        const double O11 = sop[0][qx][qy];
-                        const double O12 = sop[1][qx][qy];
-                        const double O13 = sop[2][qx][qy];
-                        const double O21 = symmetric ? O12 : sop[3][qx][qy];
-                        const double O22 = symmetric ? sop[3][qx][qy] : sop[4][qx][qy];
-                        const double O23 = symmetric ? sop[4][qx][qy] : sop[5][qx][qy];
-                        const double O31 = symmetric ? O13 : sop[6][qx][qy];
-                        const double O32 = symmetric ? O23 : sop[7][qx][qy];
-                        const double O33 = symmetric ? sop[5][qx][qy] : sop[8][qx][qy];
-
-                        const double c1 = (O11 * curl[qy][qx][0]) + (O12 * curl[qy][qx][1]) +
-                                          (O13 * curl[qy][qx][2]);
-                        const double c2 = (O21 * curl[qy][qx][0]) + (O22 * curl[qy][qx][1]) +
-                                          (O23 * curl[qy][qx][2]);
-                        const double c3 = (O31 * curl[qy][qx][0]) + (O32 * curl[qy][qx][1]) +
-                                          (O33 * curl[qy][qx][2]);
-
-                        const double wcx = sBc[dx][qx];
-                        const double wDx = sGc[dx][qx];
-
-                        if (dx < D1D-1)
-                        {
-                           // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                           // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
-                           const double wx = sBo[dx][qx];
-                           dxyz1 += (wx * c2 * wcy * wcDz) - (wx * c3 * wcDy * wcz);
-                        }
-
-                        // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                        // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
-                        dxyz2 += (-wy * c1 * wcx * wcDz) + (wy * c3 * wDx * wcz);
-
-                        // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-                        // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
-                        dxyz3 += (wcDy * wz * c1 * wcx) - (wcy * wz * c2 * wDx);
-                     } // qx
-                  } // qy
-               } // dx
-            } // dy
-         } // dz
-
-         MFEM_SYNC_THREAD;
-
-         MFEM_FOREACH_THREAD(dz,z,D1D)
-         {
-            MFEM_FOREACH_THREAD(dy,y,D1D)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1D)
-               {
-                  if (dx < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * D1D)) * (D1D-1)), e) += dxyz1;
-                  }
-                  if (dy < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * (D1D-1))) * D1D) + ((D1D-1)*D1D*D1D), e) += dxyz2;
-                  }
-                  if (dz < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * D1D)) * D1D) + (2*(D1D-1)*D1D*D1D), e) += dxyz3;
-                  }
-               }
-            }
-         }
-      } // qz
-   }; // end of element loop
-
-   auto host_kernel = [&] MFEM_LAMBDA (int)
-   {
-      MFEM_ABORT_KERNEL("This kernel should only be used on GPU.");
-   };
-
-   ForallWrap<3>(true, NE, device_kernel, host_kernel, Q1D, Q1D, Q1D);
-}
-
-static void PACurlL2Apply2D(const int D1D,
-                            const int D1Dtest,
-                            const int Q1D,
-                            const int NE,
-                            const Array<double> &bo,
-                            const Array<double> &bot,
-                            const Array<double> &bt,
-                            const Array<double> &gc,
-                            const Vector &pa_data,
-                            const Vector &x, // trial = H(curl)
-                            Vector &y)  // test = L2 or H1
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-   const int H1 = (D1Dtest == D1D);
-
-   MFEM_VERIFY(y.Size() == NE*D1Dtest*D1Dtest, "Test vector of wrong dimension");
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bt = Reshape(bt.Read(), D1D, Q1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
-   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), D1Dtest, D1Dtest, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double curl[MAX_Q1D][MAX_Q1D];
-
-      // curl[qy][qx] will be computed as du_y/dx - du_x/dy
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            curl[qy][qx] = 0.0;
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-      {
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            double gradX[MAX_Q1D];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               gradX[qx] = 0;
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double t = X(dx + (dy * D1Dx) + osc, e);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  gradX[qx] += t * ((c == 0) ? Bo(qx,dx) : Gc(qx,dx));
-               }
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const double wy = (c == 0) ? -Gc(qy,dy) : Bo(qy,dy);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  curl[qy][qx] += gradX[qx] * wy;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            curl[qy][qx] *= op(qx,qy,e);
-         }
-      }
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         double sol_x[MAX_D1D];
-         for (int dx = 0; dx < D1Dtest; ++dx)
-         {
-            sol_x[dx] = 0.0;
-         }
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            const double s = curl[qy][qx];
-            for (int dx = 0; dx < D1Dtest; ++dx)
-            {
-               sol_x[dx] += s * ((H1 == 1) ? Bt(dx,qx) : Bot(dx,qx));
-            }
-         }
-         for (int dy = 0; dy < D1Dtest; ++dy)
-         {
-            const double wy = (H1 == 1) ? Bt(dy,qy) : Bot(dy,qy);
-
-            for (int dx = 0; dx < D1Dtest; ++dx)
-            {
-               Y(dx,dy,e) += sol_x[dx] * wy;
-            }
-         }
-      }  // loop qy
-   }); // end of element loop
-}
-
-static void PACurlL2ApplyTranspose2D(const int D1D,
-                                     const int D1Dtest,
-                                     const int Q1D,
-                                     const int NE,
-                                     const Array<double> &bo,
-                                     const Array<double> &bot,
-                                     const Array<double> &b,
-                                     const Array<double> &gct,
-                                     const Vector &pa_data,
-                                     const Vector &x, // trial = H(curl)
-                                     Vector &y)  // test = L2 or H1
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-   const int H1 = (D1Dtest == D1D);
-
-   MFEM_VERIFY(x.Size() == NE*D1Dtest*D1Dtest, "Test vector of wrong dimension");
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto B = Reshape(b.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Gct = Reshape(gct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
-   auto X = Reshape(x.Read(), D1Dtest, D1Dtest, NE);
-   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D];
-
-      // Zero-order term in L2 or H1 test space
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            mass[qy][qx] = 0.0;
-         }
-      }
-
-      for (int dy = 0; dy < D1Dtest; ++dy)
-      {
-         double sol_x[MAX_Q1D];
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            sol_x[qy] = 0.0;
-         }
-         for (int dx = 0; dx < D1Dtest; ++dx)
-         {
-            const double s = X(dx,dy,e);
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               sol_x[qx] += s * ((H1 == 1) ? B(qx,dx) : Bo(qx,dx));
-            }
-         }
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            const double d2q = (H1 == 1) ? B(qy,dy) : Bo(qy,dy);
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               mass[qy][qx] += d2q * sol_x[qx];
-            }
-         }
-      }
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            mass[qy][qx] *= op(qx,qy,e);
-         }
-      }
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         int osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-         {
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            double gradX[MAX_D1D];
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               gradX[dx] = 0.0;
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradX[dx] += mass[qy][qx] * ((c == 0) ? Bot(dx,qx) : Gct(dx,qx));
-               }
-            }
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               const double wy = (c == 0) ? -Gct(dy,qy) : Bot(dy,qy);
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  Y(dx + (dy * D1Dx) + osc, e) += gradX[dx] * wy;
-               }
-            }
-
-            osc += D1Dx * D1Dy;
-         }  // loop c
-      }  // loop qy
-   }); // end of element loop
-}
-
-void CurlCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      if (Device::Allows(Backend::DEVICE_MASK))
-      {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
-         {
-            case 0x23: return SmemPACurlCurlApply3D<2,3>(dofs1D, quad1D, symmetric, ne,
-                                                            mapsO->B, mapsC->B, mapsO->Bt,
-                                                            mapsC->Bt, mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x34: return SmemPACurlCurlApply3D<3,4>(dofs1D, quad1D, symmetric, ne,
-                                                            mapsO->B, mapsC->B, mapsO->Bt,
-                                                            mapsC->Bt, mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x45: return SmemPACurlCurlApply3D<4,5>(dofs1D, quad1D, symmetric, ne,
-                                                            mapsO->B,
-                                                            mapsC->B, mapsO->Bt,
-                                                            mapsC->Bt, mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x56: return SmemPACurlCurlApply3D<5,6>(dofs1D, quad1D, symmetric, ne,
-                                                            mapsO->B, mapsC->B, mapsO->Bt,
-                                                            mapsC->Bt, mapsC->G, mapsC->Gt, pa_data, x, y);
-            default: return SmemPACurlCurlApply3D(dofs1D, quad1D, symmetric, ne, mapsO->B,
-                                                     mapsC->B, mapsO->Bt, mapsC->Bt,
-                                                     mapsC->G, mapsC->Gt, pa_data, x, y);
-         }
-      }
-      else
-         PACurlCurlApply3D(dofs1D, quad1D, symmetric, ne, mapsO->B, mapsC->B, mapsO->Bt,
-                           mapsC->Bt, mapsC->G, mapsC->Gt, pa_data, x, y);
-   }
-   else if (dim == 2)
-   {
-      PACurlCurlApply2D(dofs1D, quad1D, ne, mapsO->B, mapsO->Bt,
-                        mapsC->G, mapsC->Gt, pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-static void PACurlCurlAssembleDiagonal2D(const int D1D,
-                                         const int Q1D,
-                                         const int NE,
-                                         const Array<double> &bo,
-                                         const Array<double> &gc,
-                                         const Vector &pa_data,
-                                         Vector &diag)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
-   auto D = Reshape(diag.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-      {
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         double t[MAX_Q1D];
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               t[qx] = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 1) ? Bo(qy,dy) : -Gc(qy,dy);
-                  t[qx] += wy * wy * op(qx,qy,e);
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  const double wx = ((c == 0) ? Bo(qx,dx) : Gc(qx,dx));
-                  D(dx + (dy * D1Dx) + osc, e) += t[qx] * wx * wx;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop c
-   }); // end of element loop
-}
-
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void PACurlCurlAssembleDiagonal3D(const int D1D,
-                                         const int Q1D,
-                                         const bool symmetric,
-                                         const int NE,
-                                         const Array<double> &bo,
-                                         const Array<double> &bc,
-                                         const Array<double> &go,
-                                         const Array<double> &gc,
-                                         const Vector &pa_data,
-                                         Vector &diag)
-{
-   constexpr static int VDIM = 3;
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Go = Reshape(go.Read(), Q1D, D1D-1);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, (symmetric ? 6 : 9), NE);
-   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   const int s = symmetric ? 6 : 9;
-   const int i11 = 0;
-   const int i12 = 1;
-   const int i13 = 2;
-   const int i21 = symmetric ? i12 : 3;
-   const int i22 = symmetric ? 3 : 4;
-   const int i23 = symmetric ? 4 : 5;
-   const int i31 = symmetric ? i13 : 6;
-   const int i32 = symmetric ? i23 : 7;
-   const int i33 = symmetric ? 5 : 8;
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
-      // (\nabla\times u) \cdot (\nabla\times u) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{u}
-      // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-      // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-      // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-      // For each c, we will keep 9 arrays for derivatives multiplied by the 9 entries of the 3x3 matrix (dF^T C dF),
-      // which may be non-symmetric depending on a possibly non-symmetric matrix coefficient.
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         double zt[MAX_Q1D][MAX_Q1D][MAX_D1D][9][3];
-
-         // z contraction
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  for (int i=0; i<s; ++i)
-                  {
-                     for (int d=0; d<3; ++d)
-                     {
-                        zt[qx][qy][dz][i][d] = 0.0;
-                     }
-                  }
-
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     const double wz = ((c == 2) ? Bo(qz,dz) : Bc(qz,dz));
-                     const double wDz = ((c == 2) ? Go(qz,dz) : Gc(qz,dz));
-
-                     for (int i=0; i<s; ++i)
-                     {
-                        zt[qx][qy][dz][i][0] += wz * wz * op(qx,qy,qz,i,e);
-                        zt[qx][qy][dz][i][1] += wDz * wz * op(qx,qy,qz,i,e);
-                        zt[qx][qy][dz][i][2] += wDz * wDz * op(qx,qy,qz,i,e);
-                     }
-                  }
-               }
-            }
-         }  // end of z contraction
-
-         double yt[MAX_Q1D][MAX_D1D][MAX_D1D][9][3][3];
-
-         // y contraction
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int i=0; i<s; ++i)
-                  {
-                     for (int d=0; d<3; ++d)
-                        for (int j=0; j<3; ++j)
-                        {
-                           yt[qx][dy][dz][i][d][j] = 0.0;
-                        }
-                  }
-
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wy = ((c == 1) ? Bo(qy,dy) : Bc(qy,dy));
-                     const double wDy = ((c == 1) ? Go(qy,dy) : Gc(qy,dy));
-
-                     for (int i=0; i<s; ++i)
-                     {
-                        for (int d=0; d<3; ++d)
-                        {
-                           yt[qx][dy][dz][i][d][0] += wy * wy * zt[qx][qy][dz][i][d];
-                           yt[qx][dy][dz][i][d][1] += wDy * wy * zt[qx][qy][dz][i][d];
-                           yt[qx][dy][dz][i][d][2] += wDy * wDy * zt[qx][qy][dz][i][d];
-                        }
-                     }
-                  }
-               }
-            }
-         }  // end of y contraction
-
-         // x contraction
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-                     const double wDx = ((c == 0) ? Go(qx,dx) : Gc(qx,dx));
-
-                     // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
-                     // (\nabla\times u) \cdot (\nabla\times u) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{u}
-                     // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                     // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                     // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-                     /*
-                       const double O11 = op(q,0,e);
-                       const double O12 = op(q,1,e);
-                       const double O13 = op(q,2,e);
-                       const double O22 = op(q,3,e);
-                       const double O23 = op(q,4,e);
-                       const double O33 = op(q,5,e);
-                     */
-
-                     if (c == 0)
-                     {
-                        // (u_0)_{x_2} (O22 (u_0)_{x_2} - O23 (u_0)_{x_1}) - (u_0)_{x_1} (O32 (u_0)_{x_2} - O33 (u_0)_{x_1})
-                        const double sumy = yt[qx][dy][dz][i22][2][0] - yt[qx][dy][dz][i23][1][1]
-                                            - yt[qx][dy][dz][i32][1][1] + yt[qx][dy][dz][i33][0][2];
-
-                        D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += sumy * wx * wx;
-                     }
-                     else if (c == 1)
-                     {
-                        // (u_1)_{x_2} (O11 (u_1)_{x_2} - O13 (u_1)_{x_0}) + (u_1)_{x_0} (-O31 (u_1)_{x_2} + O33 (u_1)_{x_0})
-                        const double d = (yt[qx][dy][dz][i11][2][0] * wx * wx)
-                                         - ((yt[qx][dy][dz][i13][1][0] + yt[qx][dy][dz][i31][1][0]) * wDx * wx)
-                                         + (yt[qx][dy][dz][i33][0][0] * wDx * wDx);
-
-                        D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += d;
-                     }
-                     else
-                     {
-                        // (u_2)_{x_1} (O11 (u_2)_{x_1} - O12 (u_2)_{x_0}) - (u_2)_{x_0} (O21 (u_2)_{x_1} - O22 (u_2)_{x_0})
-                        const double d = (yt[qx][dy][dz][i11][0][2] * wx * wx)
-                                         - ((yt[qx][dy][dz][i12][0][1] + yt[qx][dy][dz][i21][0][1]) * wDx * wx)
-                                         + (yt[qx][dy][dz][i22][0][0] * wDx * wDx);
-
-                        D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += d;
-                     }
-                  }
-               }
-            }
-         }  // end of x contraction
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop c
-   }); // end of element loop
-}
-
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void SmemPACurlCurlAssembleDiagonal3D(const int D1D,
-                                             const int Q1D,
-                                             const bool symmetric,
-                                             const int NE,
-                                             const Array<double> &bo,
-                                             const Array<double> &bc,
-                                             const Array<double> &go,
-                                             const Array<double> &gc,
-                                             const Vector &pa_data,
-                                             Vector &diag)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Go = Reshape(go.Read(), Q1D, D1D-1);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, (symmetric ? 6 : 9), NE);
-   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   const int s = symmetric ? 6 : 9;
-   const int i11 = 0;
-   const int i12 = 1;
-   const int i13 = 2;
-   const int i21 = symmetric ? i12 : 3;
-   const int i22 = symmetric ? 3 : 4;
-   const int i23 = symmetric ? 4 : 5;
-   const int i31 = symmetric ? i13 : 6;
-   const int i32 = symmetric ? i23 : 7;
-   const int i33 = symmetric ? 5 : 8;
-
-   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
-      // (\nabla\times u) \cdot (\nabla\times u) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{u}
-      // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-      // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-      // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-      constexpr int VDIM = 3;
-
-      MFEM_SHARED double sBo[MAX_Q1D][MAX_D1D];
-      MFEM_SHARED double sBc[MAX_Q1D][MAX_D1D];
-      MFEM_SHARED double sGo[MAX_Q1D][MAX_D1D];
-      MFEM_SHARED double sGc[MAX_Q1D][MAX_D1D];
-
-      double ope[9];
-      MFEM_SHARED double sop[9][MAX_Q1D][MAX_Q1D];
-
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               for (int i=0; i<s; ++i)
-               {
-                  ope[i] = op(qx,qy,qz,i,e);
-               }
-            }
-         }
-      }
-
-      const int tidx = MFEM_THREAD_ID(x);
-      const int tidy = MFEM_THREAD_ID(y);
-      const int tidz = MFEM_THREAD_ID(z);
-
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               sBc[q][d] = Bc(q,d);
-               sGc[q][d] = Gc(q,d);
-               if (d < D1D-1)
-               {
-                  sBo[q][d] = Bo(q,d);
-                  sGo[q][d] = Go(q,d);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-
-      int osc = 0;
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         double dxyz = 0.0;
-
-         for (int qz=0; qz < Q1D; ++qz)
-         {
-            if (tidz == qz)
-            {
-               for (int i=0; i<s; ++i)
-               {
-                  sop[i][tidx][tidy] = ope[i];
-               }
-            }
-
-            MFEM_SYNC_THREAD;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               const double wz = ((c == 2) ? sBo[qz][dz] : sBc[qz][dz]);
-               const double wDz = ((c == 2) ? sGo[qz][dz] : sGc[qz][dz]);
-
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     for (int qy = 0; qy < Q1D; ++qy)
-                     {
-                        const double wy = ((c == 1) ? sBo[qy][dy] : sBc[qy][dy]);
-                        const double wDy = ((c == 1) ? sGo[qy][dy] : sGc[qy][dy]);
-
-                        for (int qx = 0; qx < Q1D; ++qx)
-                        {
-                           const double wx = ((c == 0) ? sBo[qx][dx] : sBc[qx][dx]);
-                           const double wDx = ((c == 0) ? sGo[qx][dx] : sGc[qx][dx]);
-
-                           if (c == 0)
-                           {
-                              // (u_0)_{x_2} (O22 (u_0)_{x_2} - O23 (u_0)_{x_1}) - (u_0)_{x_1} (O32 (u_0)_{x_2} - O33 (u_0)_{x_1})
-
-                              // (u_0)_{x_2} O22 (u_0)_{x_2}
-                              dxyz += sop[i22][qx][qy] * wx * wx * wy * wy * wDz * wDz;
-
-                              // -(u_0)_{x_2} O23 (u_0)_{x_1} - (u_0)_{x_1} O32 (u_0)_{x_2}
-                              dxyz += -(sop[i23][qx][qy] + sop[i32][qx][qy]) * wx * wx * wDy * wy * wDz * wz;
-
-                              // (u_0)_{x_1} O33 (u_0)_{x_1}
-                              dxyz += sop[i33][qx][qy] * wx * wx * wDy * wDy * wz * wz;
-                           }
-                           else if (c == 1)
-                           {
-                              // (u_1)_{x_2} (O11 (u_1)_{x_2} - O13 (u_1)_{x_0}) + (u_1)_{x_0} (-O31 (u_1)_{x_2} + O33 (u_1)_{x_0})
-
-                              // (u_1)_{x_2} O11 (u_1)_{x_2}
-                              dxyz += sop[i11][qx][qy] * wx * wx * wy * wy * wDz * wDz;
-
-                              // -(u_1)_{x_2} O13 (u_1)_{x_0} - (u_1)_{x_0} O31 (u_1)_{x_2}
-                              dxyz += -(sop[i13][qx][qy] + sop[i31][qx][qy]) * wDx * wx * wy * wy * wDz * wz;
-
-                              // (u_1)_{x_0} O33 (u_1)_{x_0})
-                              dxyz += sop[i33][qx][qy] * wDx * wDx * wy * wy * wz * wz;
-                           }
-                           else
-                           {
-                              // (u_2)_{x_1} (O11 (u_2)_{x_1} - O12 (u_2)_{x_0}) - (u_2)_{x_0} (O21 (u_2)_{x_1} - O22 (u_2)_{x_0})
-
-                              // (u_2)_{x_1} O11 (u_2)_{x_1}
-                              dxyz += sop[i11][qx][qy] * wx * wx * wDy * wDy * wz * wz;
-
-                              // -(u_2)_{x_1} O12 (u_2)_{x_0} - (u_2)_{x_0} O21 (u_2)_{x_1}
-                              dxyz += -(sop[i12][qx][qy] + sop[i21][qx][qy]) * wDx * wx * wDy * wy * wz * wz;
-
-                              // (u_2)_{x_0} O22 (u_2)_{x_0}
-                              dxyz += sop[i22][qx][qy] * wDx * wDx * wy * wy * wz * wz;
-                           }
-                        }
-                     }
-                  }
-               }
-            }
-
-            MFEM_SYNC_THREAD;
-         }  // qz loop
-
-         MFEM_FOREACH_THREAD(dz,z,D1Dz)
-         {
-            MFEM_FOREACH_THREAD(dy,y,D1Dy)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1Dx)
-               {
-                  D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += dxyz;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // c loop
-   }); // end of element loop
-}
-
-void CurlCurlIntegrator::AssembleDiagonalPA(Vector& diag)
-{
-   if (dim == 3)
-   {
-      if (Device::Allows(Backend::DEVICE_MASK))
-      {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
-         {
-            case 0x23: return SmemPACurlCurlAssembleDiagonal3D<2,3>(dofs1D, quad1D,
-                                                                       symmetric, ne,
-                                                                       mapsO->B, mapsC->B,
-                                                                       mapsO->G, mapsC->G,
-                                                                       pa_data, diag);
-            case 0x34: return SmemPACurlCurlAssembleDiagonal3D<3,4>(dofs1D, quad1D,
-                                                                       symmetric, ne,
-                                                                       mapsO->B, mapsC->B,
-                                                                       mapsO->G, mapsC->G,
-                                                                       pa_data, diag);
-            case 0x45: return SmemPACurlCurlAssembleDiagonal3D<4,5>(dofs1D, quad1D,
-                                                                       symmetric, ne,
-                                                                       mapsO->B, mapsC->B,
-                                                                       mapsO->G, mapsC->G,
-                                                                       pa_data, diag);
-            case 0x56: return SmemPACurlCurlAssembleDiagonal3D<5,6>(dofs1D, quad1D,
-                                                                       symmetric, ne,
-                                                                       mapsO->B, mapsC->B,
-                                                                       mapsO->G, mapsC->G,
-                                                                       pa_data, diag);
-            default: return SmemPACurlCurlAssembleDiagonal3D(dofs1D, quad1D, symmetric, ne,
-                                                                mapsO->B, mapsC->B,
-                                                                mapsO->G, mapsC->G,
-                                                                pa_data, diag);
-         }
-      }
-      else
-         PACurlCurlAssembleDiagonal3D(dofs1D, quad1D, symmetric, ne,
-                                      mapsO->B, mapsC->B,
-                                      mapsO->G, mapsC->G,
-                                      pa_data, diag);
-   }
-   else if (dim == 2)
-   {
-      PACurlCurlAssembleDiagonal2D(dofs1D, quad1D, ne,
-                                   mapsO->B, mapsC->G, pa_data, diag);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-// Apply to x corresponding to DOFs in H^1 (trial), whose gradients are
-// integrated against H(curl) test functions corresponding to y.
-void PAHcurlH1Apply3D(const int D1D,
-                      const int Q1D,
-                      const int NE,
-                      const Array<double> &bc,
-                      const Array<double> &gc,
-                      const Array<double> &bot,
-                      const Array<double> &bct,
-                      const Vector &pa_data,
-                      const Vector &x,
-                      Vector &y)
-{
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   constexpr static int VDIM = 3;
-
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
-   auto X = Reshape(x.Read(), D1D, D1D, D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  mass[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      for (int dz = 0; dz < D1D; ++dz)
-      {
-         double gradXY[MAX_Q1D][MAX_Q1D][3];
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               gradXY[qy][qx][0] = 0.0;
-               gradXY[qy][qx][1] = 0.0;
-               gradXY[qy][qx][2] = 0.0;
-            }
-         }
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            double gradX[MAX_Q1D][2];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               gradX[qx][0] = 0.0;
-               gradX[qx][1] = 0.0;
-            }
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               const double s = X(dx,dy,dz,e);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  gradX[qx][0] += s * Bc(qx,dx);
-                  gradX[qx][1] += s * Gc(qx,dx);
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const double wy  = Bc(qy,dy);
-               const double wDy = Gc(qy,dy);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  const double wx  = gradX[qx][0];
-                  const double wDx = gradX[qx][1];
-                  gradXY[qy][qx][0] += wDx * wy;
-                  gradXY[qy][qx][1] += wx * wDy;
-                  gradXY[qy][qx][2] += wx * wy;
-               }
-            }
-         }
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            const double wz  = Bc(qz,dz);
-            const double wDz = Gc(qz,dz);
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  mass[qz][qy][qx][0] += gradXY[qy][qx][0] * wz;
-                  mass[qz][qy][qx][1] += gradXY[qy][qx][1] * wz;
-                  mass[qz][qy][qx][2] += gradXY[qy][qx][2] * wDz;
-               }
-            }
-         }
-      }
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(qx,qy,qz,0,e);
-               const double O12 = op(qx,qy,qz,1,e);
-               const double O13 = op(qx,qy,qz,2,e);
-               const double O22 = op(qx,qy,qz,3,e);
-               const double O23 = op(qx,qy,qz,4,e);
-               const double O33 = op(qx,qy,qz,5,e);
-               const double massX = mass[qz][qy][qx][0];
-               const double massY = mass[qz][qy][qx][1];
-               const double massZ = mass[qz][qy][qx][2];
-               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
-               mass[qz][qy][qx][1] = (O12*massX)+(O22*massY)+(O23*massZ);
-               mass[qz][qy][qx][2] = (O13*massX)+(O23*massY)+(O33*massZ);
-            }
-         }
-      }
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         double massXY[MAX_D1D][MAX_D1D];
-
-         int osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massXY[dy][dx] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[MAX_D1D];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] = 0;
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massX[dx] += mass[qz][qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massXY[dy][dx] += massX[dx] * wy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = (c == 2) ? Bot(dz,qz) : Bct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += massXY[dy][dx] * wz;
-                  }
-               }
-            }
-
-            osc += D1Dx * D1Dy * D1Dz;
-         }  // loop c
-      }  // loop qz
-   }); // end of element loop
-}
-
-// Apply to x corresponding to DOFs in H(curl), integrated
-// against gradients of H^1 functions corresponding to y.
-void PAHcurlH1ApplyTranspose3D(const int D1D,
-                               const int Q1D,
-                               const int NE,
-                               const Array<double> &bc,
-                               const Array<double> &bo,
-                               const Array<double> &bct,
-                               const Array<double> &gct,
-                               const Vector &pa_data,
-                               const Vector &x,
-                               Vector &y)
-{
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   constexpr static int VDIM = 3;
-
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bt = Reshape(bct.Read(), D1D, Q1D);
-   auto Gt = Reshape(gct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), D1D, D1D, D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  mass[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double massXY[MAX_Q1D][MAX_Q1D];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massXY[qy][qx] = 0.0;
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     massXY[qy][qx] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(qx,qy,qz,0,e);
-               const double O12 = op(qx,qy,qz,1,e);
-               const double O13 = op(qx,qy,qz,2,e);
-               const double O22 = op(qx,qy,qz,3,e);
-               const double O23 = op(qx,qy,qz,4,e);
-               const double O33 = op(qx,qy,qz,5,e);
-               const double massX = mass[qz][qy][qx][0];
-               const double massY = mass[qz][qy][qx][1];
-               const double massZ = mass[qz][qy][qx][2];
-               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
-               mass[qz][qy][qx][1] = (O12*massX)+(O22*massY)+(O23*massZ);
-               mass[qz][qy][qx][2] = (O13*massX)+(O23*massY)+(O33*massZ);
-            }
-         }
-      }
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         double gradXY[MAX_D1D][MAX_D1D][3];
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               gradXY[dy][dx][0] = 0;
-               gradXY[dy][dx][1] = 0;
-               gradXY[dy][dx][2] = 0;
-            }
-         }
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            double gradX[MAX_D1D][3];
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               gradX[dx][0] = 0;
-               gradX[dx][1] = 0;
-               gradX[dx][2] = 0;
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double gX = mass[qz][qy][qx][0];
-               const double gY = mass[qz][qy][qx][1];
-               const double gZ = mass[qz][qy][qx][2];
-               for (int dx = 0; dx < D1D; ++dx)
-               {
-                  const double wx  = Bt(dx,qx);
-                  const double wDx = Gt(dx,qx);
-                  gradX[dx][0] += gX * wDx;
-                  gradX[dx][1] += gY * wx;
-                  gradX[dx][2] += gZ * wx;
-               }
-            }
-            for (int dy = 0; dy < D1D; ++dy)
-            {
-               const double wy  = Bt(dy,qy);
-               const double wDy = Gt(dy,qy);
-               for (int dx = 0; dx < D1D; ++dx)
-               {
-                  gradXY[dy][dx][0] += gradX[dx][0] * wy;
-                  gradXY[dy][dx][1] += gradX[dx][1] * wDy;
-                  gradXY[dy][dx][2] += gradX[dx][2] * wy;
-               }
-            }
-         }
-         for (int dz = 0; dz < D1D; ++dz)
-         {
-            const double wz  = Bt(dz,qz);
-            const double wDz = Gt(dz,qz);
-            for (int dy = 0; dy < D1D; ++dy)
-            {
-               for (int dx = 0; dx < D1D; ++dx)
-               {
-                  Y(dx,dy,dz,e) +=
-                     ((gradXY[dy][dx][0] * wz) +
-                      (gradXY[dy][dx][1] * wz) +
-                      (gradXY[dy][dx][2] * wDz));
-               }
-            }
-         }
-      }  // loop qz
-   }); // end of element loop
-}
-
-// Apply to x corresponding to DOFs in H^1 (trial), whose gradients are
-// integrated against H(curl) test functions corresponding to y.
-void PAHcurlH1Apply2D(const int D1D,
-                      const int Q1D,
-                      const int NE,
-                      const Array<double> &bc,
-                      const Array<double> &gc,
-                      const Array<double> &bot,
-                      const Array<double> &bct,
-                      const Vector &pa_data,
-                      const Vector &x,
-                      Vector &y)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, 3, NE);
-   auto X = Reshape(x.Read(), D1D, D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            for (int c = 0; c < VDIM; ++c)
-            {
-               mass[qy][qx][c] = 0.0;
-            }
-         }
-      }
-
-      for (int dy = 0; dy < D1D; ++dy)
-      {
-         double gradX[MAX_Q1D][2];
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            gradX[qx][0] = 0.0;
-            gradX[qx][1] = 0.0;
-         }
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            const double s = X(dx,dy,e);
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               gradX[qx][0] += s * Bc(qx,dx);
-               gradX[qx][1] += s * Gc(qx,dx);
-            }
-         }
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            const double wy  = Bc(qy,dy);
-            const double wDy = Gc(qy,dy);
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double wx  = gradX[qx][0];
-               const double wDx = gradX[qx][1];
-               mass[qy][qx][0] += wDx * wy;
-               mass[qy][qx][1] += wx * wDy;
-            }
-         }
-      }
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            const double O11 = op(qx,qy,0,e);
-            const double O12 = op(qx,qy,1,e);
-            const double O22 = op(qx,qy,2,e);
-            const double massX = mass[qy][qx][0];
-            const double massY = mass[qy][qx][1];
-            mass[qy][qx][0] = (O11*massX)+(O12*massY);
-            mass[qy][qx][1] = (O12*massX)+(O22*massY);
-         }
-      }
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         int osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-         {
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            double massX[MAX_D1D];
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               massX[dx] = 0;
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] += mass[qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  Y(dx + (dy * D1Dx) + osc, e) += massX[dx] * wy;
-               }
-            }
-
-            osc += D1Dx * D1Dy;
-         }  // loop c
-      }
-   }); // end of element loop
-}
-
-// Apply to x corresponding to DOFs in H(curl), integrated
-// against gradients of H^1 functions corresponding to y.
-void PAHcurlH1ApplyTranspose2D(const int D1D,
-                               const int Q1D,
-                               const int NE,
-                               const Array<double> &bc,
-                               const Array<double> &bo,
-                               const Array<double> &bct,
-                               const Array<double> &gct,
-                               const Vector &pa_data,
-                               const Vector &x,
-                               Vector &y)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bt = Reshape(bct.Read(), D1D, Q1D);
-   auto Gt = Reshape(gct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, 3, NE);
-   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), D1D, D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            for (int c = 0; c < VDIM; ++c)
-            {
-               mass[qy][qx][c] = 0.0;
-            }
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-      {
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            double massX[MAX_Q1D];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               massX[qx] = 0.0;
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double t = X(dx + (dy * D1Dx) + osc, e);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-               }
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  mass[qy][qx][c] += massX[qx] * wy;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            const double O11 = op(qx,qy,0,e);
-            const double O12 = op(qx,qy,1,e);
-            const double O22 = op(qx,qy,2,e);
-            const double massX = mass[qy][qx][0];
-            const double massY = mass[qy][qx][1];
-            mass[qy][qx][0] = (O11*massX)+(O12*massY);
-            mass[qy][qx][1] = (O12*massX)+(O22*massY);
-         }
-      }
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         double gradX[MAX_D1D][2];
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            gradX[dx][0] = 0;
-            gradX[dx][1] = 0;
-         }
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            const double gX = mass[qy][qx][0];
-            const double gY = mass[qy][qx][1];
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               const double wx  = Bt(dx,qx);
-               const double wDx = Gt(dx,qx);
-               gradX[dx][0] += gX * wDx;
-               gradX[dx][1] += gY * wx;
-            }
-         }
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            const double wy  = Bt(dy,qy);
-            const double wDy = Gt(dy,qy);
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               Y(dx,dy,e) += ((gradX[dx][0] * wy) + (gradX[dx][1] * wDy));
-            }
-         }
-      }
-   }); // end of element loop
-}
-
-// PA H(curl) Mass Assemble 3D kernel
-void PAHcurlL2Setup(const int NQ,
-                    const int coeffDim,
-                    const int NE,
-                    const Array<double> &w,
-                    Vector &coeff,
-                    Vector &op)
-{
-   auto W = w.Read();
-   auto C = Reshape(coeff.Read(), coeffDim, NQ, NE);
-   auto y = Reshape(op.Write(), coeffDim, NQ, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int q = 0; q < NQ; ++q)
-      {
-         for (int c=0; c<coeffDim; ++c)
-         {
-            y(c,q,e) = W[q] * C(c,q,e);
-         }
-      }
-   });
-}
-
-void MixedScalarCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                           const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *fel = trial_fes.GetFE(0); // In H(curl)
-   const FiniteElement *eltest = test_fes.GetFE(0); // In scalar space
-
-   const VectorTensorFiniteElement *el =
-      dynamic_cast<const VectorTensorFiniteElement*>(fel);
-   MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   if (el->GetDerivType() != mfem::FiniteElement::CURL)
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*eltest, *eltest,
-                                                     *mesh->GetElementTransformation(0));
-
-   const int dims = el->GetDim();
-   MFEM_VERIFY(dims == 2, "");
-
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2, "");
-
-   ne = test_fes.GetNE();
-   mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   if (el->GetOrder() == eltest->GetOrder())
-   {
-      dofs1Dtest = dofs1D;
-   }
-   else
-   {
-      dofs1Dtest = dofs1D - 1;
-   }
-
-   pa_data.SetSize(nq * ne, Device::GetMemoryType());
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
-
-   if (dim == 2)
-   {
-      PACurlL2Setup2D(quad1D, ne, ir->GetWeights(), coeff, pa_data);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-void MixedScalarCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 2)
-   {
-      PACurlL2Apply2D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B, mapsO->Bt,
-                      mapsC->Bt, mapsC->G, pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-void MixedScalarCurlIntegrator::AddMultTransposePA(const Vector &x,
-                                                   Vector &y) const
-{
-   if (dim == 2)
-   {
-      PACurlL2ApplyTranspose2D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B, mapsO->Bt,
-                               mapsC->B, mapsC->Gt, pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-void MixedVectorCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                           const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with vector test and trial spaces.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const VectorTensorFiniteElement *trial_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 3, "");
-
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
-
-   ne = trial_fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &trial_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   mapsCtest = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsOtest = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-   dofs1Dtest = mapsCtest->ndof;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   testType = test_el->GetDerivType();
-   trialType = trial_el->GetDerivType();
-
-   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-   coeffDim = (DQ ? 3 : 1);
-
-   const bool curlSpaces = (testType == mfem::FiniteElement::CURL &&
-                            trialType == mfem::FiniteElement::CURL);
-
-   const int ndata = curlSpaces ? (coeffDim == 1 ? 1 : 9) : symmDims;
-   pa_data.SetSize(ndata * nq * ne, Device::GetMemoryType());
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(qs, CoefficientStorage::FULL);
-   if (Q) { coeff.Project(*Q); }
-   else if (DQ) { coeff.Project(*DQ); }
-   else { coeff.SetConstant(1.0); }
-
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
-   {
-      if (coeffDim == 1)
-      {
-         PAHcurlL2Setup(nq, coeffDim, ne, ir->GetWeights(), coeff, pa_data);
-      }
-      else
-      {
-         PAHcurlHdivSetup3D(quad1D, coeffDim, ne, false, ir->GetWeights(),
-                            geom->J, coeff, pa_data);
-      }
-   }
-   else if (testType == mfem::FiniteElement::DIV &&
-            trialType == mfem::FiniteElement::CURL && dim == 3 &&
-            test_fel->GetOrder() == trial_fel->GetOrder())
-   {
-      PACurlCurlSetup3D(quad1D, coeffDim, ne, ir->GetWeights(), geom->J, coeff,
-                        pa_data);
-   }
-   else
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
-}
-
-// Apply to x corresponding to DOFs in H(curl) (trial), whose curl is
-// integrated against H(curl) test functions corresponding to y.
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void PAHcurlL2Apply3D(const int D1D,
-                             const int Q1D,
-                             const int coeffDim,
-                             const int NE,
-                             const Array<double> &bo,
-                             const Array<double> &bc,
-                             const Array<double> &bot,
-                             const Array<double> &bct,
-                             const Array<double> &gc,
-                             const Vector &pa_data,
-                             const Vector &x,
-                             Vector &y)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   // Using u = dF^{-T} \hat{u} and (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
-   // (\nabla\times u) \cdot v = 1/det(dF) \hat{\nabla}\times\hat{u}^T dF^T dF^{-T} \hat{v}
-   // = 1/det(dF) \hat{\nabla}\times\hat{u}^T \hat{v}
-   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1D, Q1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double curl[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-      // curl[qz][qy][qx] will be computed as the vector curl at each quadrature point.
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  curl[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      // We treat x, y, z components separately for optimization specific to each.
-
-      int osc = 0;
-
-      {
-         // x component
-         const int D1Dz = D1D;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D - 1;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double gradXY[MAX_Q1D][MAX_Q1D][2];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradXY[qy][qx][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * Bo(qx,dx);
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = Bc(qy,dy);
-                  const double wDy = Gc(qy,dy);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     gradXY[qy][qx][0] += wx * wDy;
-                     gradXY[qy][qx][1] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = Bc(qz,dz);
-               const double wDz = Gc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                     curl[qz][qy][qx][1] += gradXY[qy][qx][1] * wDz; // (u_0)_{x_2}
-                     curl[qz][qy][qx][2] -= gradXY[qy][qx][0] * wz;  // -(u_0)_{x_1}
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      {
-         // y component
-         const int D1Dz = D1D;
-         const int D1Dy = D1D - 1;
-         const int D1Dx = D1D;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double gradXY[MAX_Q1D][MAX_Q1D][2];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradXY[qy][qx][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               double massY[MAX_Q1D];
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  massY[qy] = 0.0;
-               }
-
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     massY[qy] += t * Bo(qy,dy);
-                  }
-               }
-
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  const double wx = Bc(qx,dx);
-                  const double wDx = Gc(qx,dx);
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wy = massY[qy];
-                     gradXY[qy][qx][0] += wDx * wy;
-                     gradXY[qy][qx][1] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = Bc(qz,dz);
-               const double wDz = Gc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                     curl[qz][qy][qx][0] -= gradXY[qy][qx][1] * wDz; // -(u_1)_{x_2}
-                     curl[qz][qy][qx][2] += gradXY[qy][qx][0] * wz;  // (u_1)_{x_0}
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      {
-         // z component
-         const int D1Dz = D1D - 1;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D;
-
-         for (int dx = 0; dx < D1Dx; ++dx)
-         {
-            double gradYZ[MAX_Q1D][MAX_Q1D][2];
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradYZ[qz][qy][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massZ[MAX_Q1D];
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  massZ[qz] = 0.0;
-               }
-
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     massZ[qz] += t * Bo(qz,dz);
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = Bc(qy,dy);
-                  const double wDy = Gc(qy,dy);
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     const double wz = massZ[qz];
-                     gradYZ[qz][qy][0] += wz * wy;
-                     gradYZ[qz][qy][1] += wz * wDy;
-                  }
-               }
-            }
-
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double wx = Bc(qx,dx);
-               const double wDx = Gc(qx,dx);
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-                     curl[qz][qy][qx][0] += gradYZ[qz][qy][1] * wx;  // (u_2)_{x_1}
-                     curl[qz][qy][qx][1] -= gradYZ[qz][qy][0] * wDx; // -(u_2)_{x_0}
-                  }
-               }
-            }
-         }
-      }
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(0,qx,qy,qz,e);
-               if (coeffDim == 1)
-               {
-                  for (int c = 0; c < VDIM; ++c)
-                  {
-                     curl[qz][qy][qx][c] *= O11;
-                  }
-               }
-               else
-               {
-                  const double O21 = op(1,qx,qy,qz,e);
-                  const double O31 = op(2,qx,qy,qz,e);
-                  const double O12 = op(3,qx,qy,qz,e);
-                  const double O22 = op(4,qx,qy,qz,e);
-                  const double O32 = op(5,qx,qy,qz,e);
-                  const double O13 = op(6,qx,qy,qz,e);
-                  const double O23 = op(7,qx,qy,qz,e);
-                  const double O33 = op(8,qx,qy,qz,e);
-                  const double curlX = curl[qz][qy][qx][0];
-                  const double curlY = curl[qz][qy][qx][1];
-                  const double curlZ = curl[qz][qy][qx][2];
-                  curl[qz][qy][qx][0] = (O11*curlX)+(O12*curlY)+(O13*curlZ);
-                  curl[qz][qy][qx][1] = (O21*curlX)+(O22*curlY)+(O23*curlZ);
-                  curl[qz][qy][qx][2] = (O31*curlX)+(O32*curlY)+(O33*curlZ);
-               }
-            }
-         }
-      }
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         double massXY[MAX_D1D][MAX_D1D];
-
-         osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massXY[dy][dx] = 0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[MAX_D1D];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] = 0.0;
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massX[dx] += curl[qz][qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
-                  }
-               }
-
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massXY[dy][dx] += massX[dx] * wy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = (c == 2) ? Bot(dz,qz) : Bct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += massXY[dy][dx] * wz;
-                  }
-               }
-            }
-
-            osc += D1Dx * D1Dy * D1Dz;
-         }  // loop c
-      }  // loop qz
-   }); // end of element loop
-}
-
-// Apply to x corresponding to DOFs in H(curl) (trial), whose curl is
-// integrated against H(curl) test functions corresponding to y.
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void SmemPAHcurlL2Apply3D(const int D1D,
-                                 const int Q1D,
-                                 const int coeffDim,
-                                 const int NE,
-                                 const Array<double> &bo,
-                                 const Array<double> &bc,
-                                 const Array<double> &gc,
-                                 const Vector &pa_data,
-                                 const Vector &x,
-                                 Vector &y)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   auto device_kernel = [=] MFEM_DEVICE (int e)
-   {
-      constexpr int VDIM = 3;
-      constexpr int maxCoeffDim = 9;
-
-      MFEM_SHARED double sBo[MAX_D1D][MAX_Q1D];
-      MFEM_SHARED double sBc[MAX_D1D][MAX_Q1D];
-      MFEM_SHARED double sGc[MAX_D1D][MAX_Q1D];
-
-      double opc[maxCoeffDim];
-      MFEM_SHARED double sop[maxCoeffDim][MAX_Q1D][MAX_Q1D];
-      MFEM_SHARED double curl[MAX_Q1D][MAX_Q1D][3];
-
-      MFEM_SHARED double sX[MAX_D1D][MAX_D1D][MAX_D1D];
-
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               for (int i=0; i<coeffDim; ++i)
-               {
-                  opc[i] = op(i,qx,qy,qz,e);
-               }
-            }
-         }
-      }
-
-      const int tidx = MFEM_THREAD_ID(x);
-      const int tidy = MFEM_THREAD_ID(y);
-      const int tidz = MFEM_THREAD_ID(z);
-
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               sBc[d][q] = Bc(q,d);
-               sGc[d][q] = Gc(q,d);
-               if (d < D1D-1)
-               {
-                  sBo[d][q] = Bo(q,d);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-
-      for (int qz=0; qz < Q1D; ++qz)
-      {
-         if (tidz == qz)
-         {
-            MFEM_FOREACH_THREAD(qy,y,Q1D)
-            {
-               MFEM_FOREACH_THREAD(qx,x,Q1D)
-               {
-                  for (int i=0; i<3; ++i)
-                  {
-                     curl[qy][qx][i] = 0.0;
-                  }
-               }
-            }
-         }
-
-         int osc = 0;
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  }
-               }
-            }
-            MFEM_SYNC_THREAD;
-
-            if (tidz == qz)
-            {
-               if (c == 0)
-               {
-                  for (int i=0; i<coeffDim; ++i)
-                  {
-                     sop[i][tidx][tidy] = opc[i];
-                  }
-               }
-
-               MFEM_FOREACH_THREAD(qy,y,Q1D)
-               {
-                  MFEM_FOREACH_THREAD(qx,x,Q1D)
-                  {
-                     double u = 0.0;
-                     double v = 0.0;
-
-                     // We treat x, y, z components separately for optimization specific to each.
-                     if (c == 0) // x component
-                     {
-                        // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-
-                        for (int dz = 0; dz < D1Dz; ++dz)
-                        {
-                           const double wz = sBc[dz][qz];
-                           const double wDz = sGc[dz][qz];
-
-                           for (int dy = 0; dy < D1Dy; ++dy)
-                           {
-                              const double wy = sBc[dy][qy];
-                              const double wDy = sGc[dy][qy];
-
-                              for (int dx = 0; dx < D1Dx; ++dx)
-                              {
-                                 const double wx = sX[dz][dy][dx] * sBo[dx][qx];
-                                 u += wx * wDy * wz;
-                                 v += wx * wy * wDz;
-                              }
-                           }
-                        }
-
-                        curl[qy][qx][1] += v; // (u_0)_{x_2}
-                        curl[qy][qx][2] -= u;  // -(u_0)_{x_1}
-                     }
-                     else if (c == 1)  // y component
-                     {
-                        // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-
-                        for (int dz = 0; dz < D1Dz; ++dz)
-                        {
-                           const double wz = sBc[dz][qz];
-                           const double wDz = sGc[dz][qz];
-
-                           for (int dy = 0; dy < D1Dy; ++dy)
-                           {
-                              const double wy = sBo[dy][qy];
-
-                              for (int dx = 0; dx < D1Dx; ++dx)
-                              {
-                                 const double t = sX[dz][dy][dx];
-                                 const double wx = t * sBc[dx][qx];
-                                 const double wDx = t * sGc[dx][qx];
-
-                                 u += wDx * wy * wz;
-                                 v += wx * wy * wDz;
-                              }
-                           }
-                        }
-
-                        curl[qy][qx][0] -= v; // -(u_1)_{x_2}
-                        curl[qy][qx][2] += u; // (u_1)_{x_0}
-                     }
-                     else // z component
-                     {
-                        // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-                        for (int dz = 0; dz < D1Dz; ++dz)
-                        {
-                           const double wz = sBo[dz][qz];
-
-                           for (int dy = 0; dy < D1Dy; ++dy)
-                           {
-                              const double wy = sBc[dy][qy];
-                              const double wDy = sGc[dy][qy];
-
-                              for (int dx = 0; dx < D1Dx; ++dx)
-                              {
-                                 const double t = sX[dz][dy][dx];
-                                 const double wx = t * sBc[dx][qx];
-                                 const double wDx = t * sGc[dx][qx];
-
-                                 u += wDx * wy * wz;
-                                 v += wx * wDy * wz;
-                              }
-                           }
-                        }
-
-                        curl[qy][qx][0] += v; // (u_2)_{x_1}
-                        curl[qy][qx][1] -= u; // -(u_2)_{x_0}
-                     }
-                  } // qx
-               } // qy
-            } // tidz == qz
-
-            osc += D1Dx * D1Dy * D1Dz;
-            MFEM_SYNC_THREAD;
-         } // c
-
-         double dxyz1 = 0.0;
-         double dxyz2 = 0.0;
-         double dxyz3 = 0.0;
-
-         MFEM_FOREACH_THREAD(dz,z,D1D)
-         {
-            const double wcz = sBc[dz][qz];
-            const double wz = (dz < D1D-1) ? sBo[dz][qz] : 0.0;
-
-            MFEM_FOREACH_THREAD(dy,y,D1D)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1D)
-               {
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wcy = sBc[dy][qy];
-                     const double wy = (dy < D1D-1) ? sBo[dy][qy] : 0.0;
-
-                     for (int qx = 0; qx < Q1D; ++qx)
-                     {
-                        const double O11 = sop[0][qx][qy];
-                        double c1, c2, c3;
-                        if (coeffDim == 1)
-                        {
-                           c1 = O11 * curl[qy][qx][0];
-                           c2 = O11 * curl[qy][qx][1];
-                           c3 = O11 * curl[qy][qx][2];
-                        }
-                        else
-                        {
-                           const double O21 = sop[1][qx][qy];
-                           const double O31 = sop[2][qx][qy];
-                           const double O12 = sop[3][qx][qy];
-                           const double O22 = sop[4][qx][qy];
-                           const double O32 = sop[5][qx][qy];
-                           const double O13 = sop[6][qx][qy];
-                           const double O23 = sop[7][qx][qy];
-                           const double O33 = sop[8][qx][qy];
-                           c1 = (O11*curl[qy][qx][0])+(O12*curl[qy][qx][1])+(O13*curl[qy][qx][2]);
-                           c2 = (O21*curl[qy][qx][0])+(O22*curl[qy][qx][1])+(O23*curl[qy][qx][2]);
-                           c3 = (O31*curl[qy][qx][0])+(O32*curl[qy][qx][1])+(O33*curl[qy][qx][2]);
-                        }
-
-                        const double wcx = sBc[dx][qx];
-
-                        if (dx < D1D-1)
-                        {
-                           const double wx = sBo[dx][qx];
-                           dxyz1 += c1 * wx * wcy * wcz;
-                        }
-
-                        dxyz2 += c2 * wcx * wy * wcz;
-                        dxyz3 += c3 * wcx * wcy * wz;
-                     } // qx
-                  } // qy
-               } // dx
-            } // dy
-         } // dz
-
-         MFEM_SYNC_THREAD;
-
-         MFEM_FOREACH_THREAD(dz,z,D1D)
-         {
-            MFEM_FOREACH_THREAD(dy,y,D1D)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1D)
-               {
-                  if (dx < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * D1D)) * (D1D-1)), e) += dxyz1;
-                  }
-                  if (dy < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * (D1D-1))) * D1D) + ((D1D-1)*D1D*D1D), e) += dxyz2;
-                  }
-                  if (dz < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * D1D)) * D1D) + (2*(D1D-1)*D1D*D1D), e) += dxyz3;
-                  }
-               }
-            }
-         }
-      } // qz
-   }; // end of element loop
-
-   auto host_kernel = [&] MFEM_LAMBDA (int)
-   {
-      MFEM_ABORT_KERNEL("This kernel should only be used on GPU.");
-   };
-
-   ForallWrap<3>(true, NE, device_kernel, host_kernel, Q1D, Q1D, Q1D);
-}
-
-// Apply to x corresponding to DOFs in H(curl) (trial), whose curl is
-// integrated against H(div) test functions corresponding to y.
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void PAHcurlHdivApply3D(const int D1D,
-                               const int D1Dtest,
-                               const int Q1D,
-                               const int NE,
-                               const Array<double> &bo,
-                               const Array<double> &bc,
-                               const Array<double> &bot,
-                               const Array<double> &bct,
-                               const Array<double> &gc,
-                               const Vector &pa_data,
-                               const Vector &x,
-                               Vector &y)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   // Using Piola transformations (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u}
-   // for u in H(curl) and w = (1 / det (dF)) dF \hat{w} for w in H(div), we get
-   // (\nabla\times u) \cdot w = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{w}
-   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1Dtest-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1Dtest, Q1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1Dtest-1)*(D1Dtest-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double curl[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-      // curl[qz][qy][qx] will be computed as the vector curl at each quadrature point.
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  curl[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      // We treat x, y, z components separately for optimization specific to each.
-
-      int osc = 0;
-
-      {
-         // x component
-         const int D1Dz = D1D;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D - 1;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double gradXY[MAX_Q1D][MAX_Q1D][2];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradXY[qy][qx][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * Bo(qx,dx);
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = Bc(qy,dy);
-                  const double wDy = Gc(qy,dy);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     gradXY[qy][qx][0] += wx * wDy;
-                     gradXY[qy][qx][1] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = Bc(qz,dz);
-               const double wDz = Gc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                     curl[qz][qy][qx][1] += gradXY[qy][qx][1] * wDz; // (u_0)_{x_2}
-                     curl[qz][qy][qx][2] -= gradXY[qy][qx][0] * wz;  // -(u_0)_{x_1}
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      {
-         // y component
-         const int D1Dz = D1D;
-         const int D1Dy = D1D - 1;
-         const int D1Dx = D1D;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double gradXY[MAX_Q1D][MAX_Q1D][2];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradXY[qy][qx][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               double massY[MAX_Q1D];
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  massY[qy] = 0.0;
-               }
-
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     massY[qy] += t * Bo(qy,dy);
-                  }
-               }
-
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  const double wx = Bc(qx,dx);
-                  const double wDx = Gc(qx,dx);
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wy = massY[qy];
-                     gradXY[qy][qx][0] += wDx * wy;
-                     gradXY[qy][qx][1] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = Bc(qz,dz);
-               const double wDz = Gc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                     curl[qz][qy][qx][0] -= gradXY[qy][qx][1] * wDz; // -(u_1)_{x_2}
-                     curl[qz][qy][qx][2] += gradXY[qy][qx][0] * wz;  // (u_1)_{x_0}
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      {
-         // z component
-         const int D1Dz = D1D - 1;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D;
-
-         for (int dx = 0; dx < D1Dx; ++dx)
-         {
-            double gradYZ[MAX_Q1D][MAX_Q1D][2];
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int d = 0; d < 2; ++d)
-                  {
-                     gradYZ[qz][qy][d] = 0.0;
-                  }
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massZ[MAX_Q1D];
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  massZ[qz] = 0.0;
-               }
-
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     massZ[qz] += t * Bo(qz,dz);
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = Bc(qy,dy);
-                  const double wDy = Gc(qy,dy);
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     const double wz = massZ[qz];
-                     gradYZ[qz][qy][0] += wz * wy;
-                     gradYZ[qz][qy][1] += wz * wDy;
-                  }
-               }
-            }
-
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double wx = Bc(qx,dx);
-               const double wDx = Gc(qx,dx);
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qz = 0; qz < Q1D; ++qz)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-                     curl[qz][qy][qx][0] += gradYZ[qz][qy][1] * wx;  // (u_2)_{x_1}
-                     curl[qz][qy][qx][1] -= gradYZ[qz][qy][0] * wDx; // -(u_2)_{x_0}
-                  }
-               }
-            }
-         }
-      }
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(qx,qy,qz,0,e);
-               const double O12 = op(qx,qy,qz,1,e);
-               const double O13 = op(qx,qy,qz,2,e);
-               const double O22 = op(qx,qy,qz,3,e);
-               const double O23 = op(qx,qy,qz,4,e);
-               const double O33 = op(qx,qy,qz,5,e);
-
-               const double c1 = (O11 * curl[qz][qy][qx][0]) + (O12 * curl[qz][qy][qx][1]) +
-                                 (O13 * curl[qz][qy][qx][2]);
-               const double c2 = (O12 * curl[qz][qy][qx][0]) + (O22 * curl[qz][qy][qx][1]) +
-                                 (O23 * curl[qz][qy][qx][2]);
-               const double c3 = (O13 * curl[qz][qy][qx][0]) + (O23 * curl[qz][qy][qx][1]) +
-                                 (O33 * curl[qz][qy][qx][2]);
-
-               curl[qz][qy][qx][0] = c1;
-               curl[qz][qy][qx][1] = c2;
-               curl[qz][qy][qx][2] = c3;
-            }
-         }
-      }
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         double massXY[HCURL_MAX_D1D][HCURL_MAX_D1D];  // Assuming HDIV_MAX_D1D <= HCURL_MAX_D1D
-
-         osc = 0;
-
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1Dtest : D1Dtest - 1;
-            const int D1Dy = (c == 1) ? D1Dtest : D1Dtest - 1;
-            const int D1Dx = (c == 0) ? D1Dtest : D1Dtest - 1;
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massXY[dy][dx] = 0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[HCURL_MAX_D1D];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] = 0;
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massX[dx] += curl[qz][qy][qx][c] *
-                                  ((c == 0) ? Bct(dx,qx) : Bot(dx,qx));
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = (c == 1) ? Bct(dy,qy) : Bot(dy,qy);
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massXY[dy][dx] += massX[dx] * wy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = (c == 2) ? Bct(dz,qz) : Bot(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) +=
-                        massXY[dy][dx] * wz;
-                  }
-               }
-            }
-
-            osc += D1Dx * D1Dy * D1Dz;
-         }  // loop c
-      }  // loop qz
-   }); // end of element loop
-}
-
-// Apply to x corresponding to DOFs in H(div) (test), integrated against the
-// curl of H(curl) trial functions corresponding to y.
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void PAHcurlHdivApply3DTranspose(const int D1D,
-                                        const int D1Dtest,
-                                        const int Q1D,
-                                        const int NE,
-                                        const Array<double> &bo,
-                                        const Array<double> &bc,
-                                        const Array<double> &bot,
-                                        const Array<double> &bct,
-                                        const Array<double> &gct,
-                                        const Vector &pa_data,
-                                        const Vector &x,
-                                        Vector &y)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   // Using Piola transformations (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u}
-   // for u in H(curl) and w = (1 / det (dF)) dF \hat{w} for w in H(div), we get
-   // (\nabla\times u) \cdot w = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{w}
-   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1Dtest-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1Dtest, Q1D);
-   auto Gct = Reshape(gct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
-   auto X = Reshape(x.Read(), 3*(D1Dtest-1)*(D1Dtest-1)*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];  // Assuming HDIV_MAX_D1D <= HCURL_MAX_D1D
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  mass[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D : D1D - 1;
-         const int D1Dy = (c == 1) ? D1D : D1D - 1;
-         const int D1Dx = (c == 0) ? D1D : D1D - 1;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double massXY[HDIV_MAX_Q1D][HDIV_MAX_Q1D];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massXY[qy][qx] = 0.0;
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[HDIV_MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * ((c == 0) ? Bc(qx,dx) : Bo(qx,dx));
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 1) ? Bc(qy,dy) : Bo(qy,dy);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     massXY[qy][qx] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = (c == 2) ? Bc(qz,dz) : Bo(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(qx,qy,qz,0,e);
-               const double O12 = op(qx,qy,qz,1,e);
-               const double O13 = op(qx,qy,qz,2,e);
-               const double O22 = op(qx,qy,qz,3,e);
-               const double O23 = op(qx,qy,qz,4,e);
-               const double O33 = op(qx,qy,qz,5,e);
-               const double massX = mass[qz][qy][qx][0];
-               const double massY = mass[qz][qy][qx][1];
-               const double massZ = mass[qz][qy][qx][2];
-               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
-               mass[qz][qy][qx][1] = (O12*massX)+(O22*massY)+(O23*massZ);
-               mass[qz][qy][qx][2] = (O13*massX)+(O23*massY)+(O33*massZ);
-            }
-         }
-      }
-
-      // x component
-      osc = 0;
-      {
-         const int D1Dz = D1D;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D - 1;
-
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            double gradXY12[MAX_D1D][MAX_D1D];
-            double gradXY21[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradXY12[dy][dx] = 0.0;
-                  gradXY21[dy][dx] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[MAX_D1D][2];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  for (int n = 0; n < 2; ++n)
-                  {
-                     massX[dx][n] = 0.0;
-                  }
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     const double wx = Bot(dx,qx);
-
-                     massX[dx][0] += wx * mass[qz][qy][qx][1];
-                     massX[dx][1] += wx * mass[qz][qy][qx][2];
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = Bct(dy,qy);
-                  const double wDy = Gct(dy,qy);
-
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     gradXY21[dy][dx] += massX[dx][0] * wy;
-                     gradXY12[dy][dx] += massX[dx][1] * wDy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = Bct(dz,qz);
-               const double wDz = Gct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                     // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (gradXY21[dy][dx] * wDz) - (gradXY12[dy][dx] * wz);
-                  }
-               }
-            }
-         }  // loop qz
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      // y component
-      {
-         const int D1Dz = D1D;
-         const int D1Dy = D1D - 1;
-         const int D1Dx = D1D;
-
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            double gradXY02[MAX_D1D][MAX_D1D];
-            double gradXY20[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradXY02[dy][dx] = 0.0;
-                  gradXY20[dy][dx] = 0.0;
-               }
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               double massY[MAX_D1D][2];
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  massY[dy][0] = 0.0;
-                  massY[dy][1] = 0.0;
-               }
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int dy = 0; dy < D1Dy; ++dy)
-                  {
-                     const double wy = Bot(dy,qy);
-
-                     massY[dy][0] += wy * mass[qz][qy][qx][2];
-                     massY[dy][1] += wy * mass[qz][qy][qx][0];
-                  }
-               }
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double wx = Bct(dx,qx);
-                  const double wDx = Gct(dx,qx);
-
-                  for (int dy = 0; dy < D1Dy; ++dy)
-                  {
-                     gradXY02[dy][dx] += massY[dy][0] * wDx;
-                     gradXY20[dy][dx] += massY[dy][1] * wx;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = Bct(dz,qz);
-               const double wDz = Gct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                     // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (-gradXY20[dy][dx] * wDz) + (gradXY02[dy][dx] * wz);
-                  }
-               }
-            }
-         }  // loop qz
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      // z component
-      {
-         const int D1Dz = D1D - 1;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D;
-
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            double gradYZ01[MAX_D1D][MAX_D1D];
-            double gradYZ10[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  gradYZ01[dz][dy] = 0.0;
-                  gradYZ10[dz][dy] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massZ[MAX_D1D][2];
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  for (int n = 0; n < 2; ++n)
-                  {
-                     massZ[dz][n] = 0.0;
-                  }
-               }
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     const double wz = Bot(dz,qz);
-
-                     massZ[dz][0] += wz * mass[qz][qy][qx][0];
-                     massZ[dz][1] += wz * mass[qz][qy][qx][1];
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = Bct(dy,qy);
-                  const double wDy = Gct(dy,qy);
-
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     gradYZ01[dz][dy] += wy * massZ[dz][1];
-                     gradYZ10[dz][dy] += wDy * massZ[dz][0];
-                  }
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double wx = Bct(dx,qx);
-               const double wDx = Gct(dx,qx);
-
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-                     // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (gradYZ10[dz][dy] * wx) - (gradYZ01[dz][dy] * wDx);
-                  }
-               }
-            }
-         }  // loop qx
-      }
-   }); // end of element loop
-}
-
-void MixedVectorCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
-   {
-      const int ndata = coeffDim == 1 ? 1 : 9;
-
-      if (Device::Allows(Backend::DEVICE_MASK))
-      {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
-         {
-            case 0x23: return SmemPAHcurlL2Apply3D<2,3>(dofs1D, quad1D, ndata, ne,
-                                                           mapsO->B, mapsC->B,
-                                                           mapsC->G, pa_data, x, y);
-            case 0x34: return SmemPAHcurlL2Apply3D<3,4>(dofs1D, quad1D, ndata, ne,
-                                                           mapsO->B, mapsC->B,
-                                                           mapsC->G, pa_data, x, y);
-            case 0x45: return SmemPAHcurlL2Apply3D<4,5>(dofs1D, quad1D, ndata, ne,
-                                                           mapsO->B, mapsC->B,
-                                                           mapsC->G, pa_data, x, y);
-            case 0x56: return SmemPAHcurlL2Apply3D<5,6>(dofs1D, quad1D, ndata, ne,
-                                                           mapsO->B, mapsC->B,
-                                                           mapsC->G, pa_data, x, y);
-            default: return SmemPAHcurlL2Apply3D(dofs1D, quad1D, ndata, ne,
-                                                    mapsO->B, mapsC->B, mapsC->G,
-                                                    pa_data, x, y);
-         }
-      }
-      else
-         PAHcurlL2Apply3D(dofs1D, quad1D, ndata, ne, mapsO->B, mapsC->B,
-                          mapsO->Bt, mapsC->Bt, mapsC->G, pa_data, x, y);
-   }
-   else if (testType == mfem::FiniteElement::DIV &&
-            trialType == mfem::FiniteElement::CURL && dim == 3)
-      PAHcurlHdivApply3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
-                         mapsC->B, mapsOtest->Bt, mapsCtest->Bt, mapsC->G,
-                         pa_data, x, y);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension or space!");
-   }
-}
-
-void MixedVectorCurlIntegrator::AddMultTransposePA(const Vector &x,
-                                                   Vector &y) const
-{
-   if (testType == mfem::FiniteElement::DIV &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
-      PAHcurlHdivApply3DTranspose(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
-                                  mapsC->B, mapsOtest->Bt, mapsCtest->Bt,
-                                  mapsC->Gt, pa_data, x, y);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension or space!");
-   }
-}
-
-void MixedVectorWeakCurlIntegrator::AssemblePA(const FiniteElementSpace
-                                               &trial_fes,
-                                               const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with vector test and trial spaces.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const VectorTensorFiniteElement *trial_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 3, "");
-
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
-
-   ne = trial_fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   testType = test_el->GetDerivType();
-   trialType = trial_el->GetDerivType();
-
-   const bool curlSpaces = (testType == mfem::FiniteElement::CURL &&
-                            trialType == mfem::FiniteElement::CURL);
-
-   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-
-   coeffDim = DQ ? 3 : 1;
-   const int ndata = curlSpaces ? (DQ ? 9 : 1) : symmDims;
-
-   pa_data.SetSize(ndata * nq * ne, Device::GetMemoryType());
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(qs, CoefficientStorage::FULL);
-   if (Q) { coeff.Project(*Q); }
-   else if (DQ) { coeff.Project(*DQ); }
-   else { coeff.SetConstant(1.0); }
-
-   if (trialType == mfem::FiniteElement::CURL && dim == 3)
-   {
-      if (coeffDim == 1)
-      {
-         PAHcurlL2Setup(nq, coeffDim, ne, ir->GetWeights(), coeff, pa_data);
-      }
-      else
-      {
-         PAHcurlHdivSetup3D(quad1D, coeffDim, ne, false, ir->GetWeights(),
-                            geom->J, coeff, pa_data);
-      }
-   }
-   else if (trialType == mfem::FiniteElement::DIV && dim == 3 &&
-            test_el->GetOrder() == trial_el->GetOrder())
-   {
-      PACurlCurlSetup3D(quad1D, coeffDim, ne, ir->GetWeights(), geom->J, coeff,
-                        pa_data);
-   }
-   else
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
-}
-
-// Apply to x corresponding to DOFs in H(curl) (trial), integrated against curl
-// of H(curl) test functions corresponding to y.
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void PAHcurlL2Apply3DTranspose(const int D1D,
-                                      const int Q1D,
-                                      const int coeffDim,
-                                      const int NE,
-                                      const Array<double> &bo,
-                                      const Array<double> &bc,
-                                      const Array<double> &bot,
-                                      const Array<double> &bct,
-                                      const Array<double> &gct,
-                                      const Vector &pa_data,
-                                      const Vector &x,
-                                      Vector &y)
-{
-   // See PAHcurlL2Apply3D for comments.
-
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
-   auto Bct = Reshape(bct.Read(), D1D, Q1D);
-   auto Gct = Reshape(gct.Read(), D1D, Q1D);
-   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  mass[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double massXY[MAX_Q1D][MAX_Q1D];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massXY[qy][qx] = 0.0;
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     massXY[qy][qx] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(0,qx,qy,qz,e);
-               if (coeffDim == 1)
-               {
-                  for (int c = 0; c < VDIM; ++c)
-                  {
-                     mass[qz][qy][qx][c] *= O11;
-                  }
-               }
-               else
-               {
-                  const double O12 = op(1,qx,qy,qz,e);
-                  const double O13 = op(2,qx,qy,qz,e);
-                  const double O21 = op(3,qx,qy,qz,e);
-                  const double O22 = op(4,qx,qy,qz,e);
-                  const double O23 = op(5,qx,qy,qz,e);
-                  const double O31 = op(6,qx,qy,qz,e);
-                  const double O32 = op(7,qx,qy,qz,e);
-                  const double O33 = op(8,qx,qy,qz,e);
-                  const double massX = mass[qz][qy][qx][0];
-                  const double massY = mass[qz][qy][qx][1];
-                  const double massZ = mass[qz][qy][qx][2];
-                  mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
-                  mass[qz][qy][qx][1] = (O21*massX)+(O22*massY)+(O23*massZ);
-                  mass[qz][qy][qx][2] = (O31*massX)+(O32*massY)+(O33*massZ);
-               }
-            }
-         }
-      }
-
-      // x component
-      osc = 0;
-      {
-         const int D1Dz = D1D;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D - 1;
-
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            double gradXY12[MAX_D1D][MAX_D1D];
-            double gradXY21[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradXY12[dy][dx] = 0.0;
-                  gradXY21[dy][dx] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[MAX_D1D][2];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  for (int n = 0; n < 2; ++n)
-                  {
-                     massX[dx][n] = 0.0;
-                  }
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     const double wx = Bot(dx,qx);
-
-                     massX[dx][0] += wx * mass[qz][qy][qx][1];
-                     massX[dx][1] += wx * mass[qz][qy][qx][2];
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = Bct(dy,qy);
-                  const double wDy = Gct(dy,qy);
-
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     gradXY21[dy][dx] += massX[dx][0] * wy;
-                     gradXY12[dy][dx] += massX[dx][1] * wDy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = Bct(dz,qz);
-               const double wDz = Gct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
-                     // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (gradXY21[dy][dx] * wDz) - (gradXY12[dy][dx] * wz);
-                  }
-               }
-            }
-         }  // loop qz
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      // y component
-      {
-         const int D1Dz = D1D;
-         const int D1Dy = D1D - 1;
-         const int D1Dx = D1D;
-
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            double gradXY02[MAX_D1D][MAX_D1D];
-            double gradXY20[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  gradXY02[dy][dx] = 0.0;
-                  gradXY20[dy][dx] = 0.0;
-               }
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               double massY[MAX_D1D][2];
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  massY[dy][0] = 0.0;
-                  massY[dy][1] = 0.0;
-               }
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int dy = 0; dy < D1Dy; ++dy)
-                  {
-                     const double wy = Bot(dy,qy);
-
-                     massY[dy][0] += wy * mass[qz][qy][qx][2];
-                     massY[dy][1] += wy * mass[qz][qy][qx][0];
-                  }
-               }
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double wx = Bct(dx,qx);
-                  const double wDx = Gct(dx,qx);
-
-                  for (int dy = 0; dy < D1Dy; ++dy)
-                  {
-                     gradXY02[dy][dx] += massY[dy][0] * wDx;
-                     gradXY20[dy][dx] += massY[dy][1] * wx;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = Bct(dz,qz);
-               const double wDz = Gct(dz,qz);
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
-                     // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (-gradXY20[dy][dx] * wDz) + (gradXY02[dy][dx] * wz);
-                  }
-               }
-            }
-         }  // loop qz
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }
-
-      // z component
-      {
-         const int D1Dz = D1D - 1;
-         const int D1Dy = D1D;
-         const int D1Dx = D1D;
-
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            double gradYZ01[MAX_D1D][MAX_D1D];
-            double gradYZ10[MAX_D1D][MAX_D1D];
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  gradYZ01[dz][dy] = 0.0;
-                  gradYZ10[dz][dy] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massZ[MAX_D1D][2];
-               for (int dz = 0; dz < D1Dz; ++dz)
-               {
-                  for (int n = 0; n < 2; ++n)
-                  {
-                     massZ[dz][n] = 0.0;
-                  }
-               }
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     const double wz = Bot(dz,qz);
-
-                     massZ[dz][0] += wz * mass[qz][qy][qx][0];
-                     massZ[dz][1] += wz * mass[qz][qy][qx][1];
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = Bct(dy,qy);
-                  const double wDy = Gct(dy,qy);
-
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     gradYZ01[dz][dy] += wy * massZ[dz][1];
-                     gradYZ10[dz][dy] += wDy * massZ[dz][0];
-                  }
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double wx = Bct(dx,qx);
-               const double wDx = Gct(dx,qx);
-
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dz = 0; dz < D1Dz; ++dz)
-                  {
-                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
-                     // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
-                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
-                       e) += (gradYZ10[dz][dy] * wx) - (gradYZ01[dz][dy] * wDx);
-                  }
-               }
-            }
-         }  // loop qx
-      }
-   });
-}
-
-template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
-static void SmemPAHcurlL2Apply3DTranspose(const int D1D,
-                                          const int Q1D,
-                                          const int coeffDim,
-                                          const int NE,
-                                          const Array<double> &bo,
-                                          const Array<double> &bc,
-                                          const Array<double> &gc,
-                                          const Vector &pa_data,
-                                          const Vector &x,
-                                          Vector &y)
-{
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-
-   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(bc.Read(), Q1D, D1D);
-   auto Gc = Reshape(gc.Read(), Q1D, D1D);
-   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
-   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
-   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
-
-   auto device_kernel = [=] MFEM_DEVICE (int e)
-   {
-      constexpr int VDIM = 3;
-      constexpr int maxCoeffDim = 9;
-
-      MFEM_SHARED double sBo[MAX_D1D][MAX_Q1D];
-      MFEM_SHARED double sBc[MAX_D1D][MAX_Q1D];
-      MFEM_SHARED double sGc[MAX_D1D][MAX_Q1D];
-
-      double opc[maxCoeffDim];
-      MFEM_SHARED double sop[maxCoeffDim][MAX_Q1D][MAX_Q1D];
-      MFEM_SHARED double mass[MAX_Q1D][MAX_Q1D][3];
-
-      MFEM_SHARED double sX[MAX_D1D][MAX_D1D][MAX_D1D];
-
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               for (int i=0; i<coeffDim; ++i)
-               {
-                  opc[i] = op(i,qx,qy,qz,e);
-               }
-            }
-         }
-      }
-
-      const int tidx = MFEM_THREAD_ID(x);
-      const int tidy = MFEM_THREAD_ID(y);
-      const int tidz = MFEM_THREAD_ID(z);
-
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               sBc[d][q] = Bc(q,d);
-               sGc[d][q] = Gc(q,d);
-               if (d < D1D-1)
-               {
-                  sBo[d][q] = Bo(q,d);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-
-      for (int qz=0; qz < Q1D; ++qz)
-      {
-         if (tidz == qz)
-         {
-            MFEM_FOREACH_THREAD(qy,y,Q1D)
-            {
-               MFEM_FOREACH_THREAD(qx,x,Q1D)
-               {
-                  for (int i=0; i<3; ++i)
-                  {
-                     mass[qy][qx][i] = 0.0;
-                  }
-               }
-            }
-         }
-
-         int osc = 0;
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-         {
-            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
-            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
-            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
-
-            MFEM_FOREACH_THREAD(dz,z,D1Dz)
-            {
-               MFEM_FOREACH_THREAD(dy,y,D1Dy)
-               {
-                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
-                  {
-                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  }
-               }
-            }
-            MFEM_SYNC_THREAD;
-
-            if (tidz == qz)
-            {
-               if (c == 0)
-               {
-                  for (int i=0; i<coeffDim; ++i)
-                  {
-                     sop[i][tidx][tidy] = opc[i];
-                  }
-               }
-
-               MFEM_FOREACH_THREAD(qy,y,Q1D)
-               {
-                  MFEM_FOREACH_THREAD(qx,x,Q1D)
-                  {
-                     double u = 0.0;
-
-                     for (int dz = 0; dz < D1Dz; ++dz)
-                     {
-                        const double wz = (c == 2) ? sBo[dz][qz] : sBc[dz][qz];
-
-                        for (int dy = 0; dy < D1Dy; ++dy)
-                        {
-                           const double wy = (c == 1) ? sBo[dy][qy] : sBc[dy][qy];
-
-                           for (int dx = 0; dx < D1Dx; ++dx)
-                           {
-                              const double wx = sX[dz][dy][dx] * ((c == 0) ? sBo[dx][qx] : sBc[dx][qx]);
-                              u += wx * wy * wz;
-                           }
-                        }
-                     }
-
-                     mass[qy][qx][c] += u;
-                  } // qx
-               } // qy
-            } // tidz == qz
-
-            osc += D1Dx * D1Dy * D1Dz;
-            MFEM_SYNC_THREAD;
-         } // c
-
-         double dxyz1 = 0.0;
-         double dxyz2 = 0.0;
-         double dxyz3 = 0.0;
-
-         MFEM_FOREACH_THREAD(dz,z,D1D)
-         {
-            const double wcz = sBc[dz][qz];
-            const double wcDz = sGc[dz][qz];
-            const double wz = (dz < D1D-1) ? sBo[dz][qz] : 0.0;
-
-            MFEM_FOREACH_THREAD(dy,y,D1D)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1D)
-               {
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wcy = sBc[dy][qy];
-                     const double wcDy = sGc[dy][qy];
-                     const double wy = (dy < D1D-1) ? sBo[dy][qy] : 0.0;
-
-                     for (int qx = 0; qx < Q1D; ++qx)
-                     {
-                        const double O11 = sop[0][qx][qy];
-                        double c1, c2, c3;
-                        if (coeffDim == 1)
-                        {
-                           c1 = O11 * mass[qy][qx][0];
-                           c2 = O11 * mass[qy][qx][1];
-                           c3 = O11 * mass[qy][qx][2];
-                        }
-                        else
-                        {
-                           const double O12 = sop[1][qx][qy];
-                           const double O13 = sop[2][qx][qy];
-                           const double O21 = sop[3][qx][qy];
-                           const double O22 = sop[4][qx][qy];
-                           const double O23 = sop[5][qx][qy];
-                           const double O31 = sop[6][qx][qy];
-                           const double O32 = sop[7][qx][qy];
-                           const double O33 = sop[8][qx][qy];
-
-                           c1 = (O11*mass[qy][qx][0])+(O12*mass[qy][qx][1])+(O13*mass[qy][qx][2]);
-                           c2 = (O21*mass[qy][qx][0])+(O22*mass[qy][qx][1])+(O23*mass[qy][qx][2]);
-                           c3 = (O31*mass[qy][qx][0])+(O32*mass[qy][qx][1])+(O33*mass[qy][qx][2]);
-                        }
-
-                        const double wcx = sBc[dx][qx];
-                        const double wDx = sGc[dx][qx];
-
-                        if (dx < D1D-1)
-                        {
-                           const double wx = sBo[dx][qx];
-                           dxyz1 += (wx * c2 * wcy * wcDz) - (wx * c3 * wcDy * wcz);
-                        }
-
-                        dxyz2 += (-wy * c1 * wcx * wcDz) + (wy * c3 * wDx * wcz);
-
-                        dxyz3 += (wcDy * wz * c1 * wcx) - (wcy * wz * c2 * wDx);
-                     } // qx
-                  } // qy
-               } // dx
-            } // dy
-         } // dz
-
-         MFEM_SYNC_THREAD;
-
-         MFEM_FOREACH_THREAD(dz,z,D1D)
-         {
-            MFEM_FOREACH_THREAD(dy,y,D1D)
-            {
-               MFEM_FOREACH_THREAD(dx,x,D1D)
-               {
-                  if (dx < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * D1D)) * (D1D-1)), e) += dxyz1;
-                  }
-                  if (dy < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * (D1D-1))) * D1D) + ((D1D-1)*D1D*D1D), e) += dxyz2;
-                  }
-                  if (dz < D1D-1)
-                  {
-                     Y(dx + ((dy + (dz * D1D)) * D1D) + (2*(D1D-1)*D1D*D1D), e) += dxyz3;
-                  }
-               }
-            }
-         }
-      } // qz
-   }; // end of element loop
-
-   auto host_kernel = [&] MFEM_LAMBDA (int)
-   {
-      MFEM_ABORT_KERNEL("This kernel should only be used on GPU.");
-   };
-
-   ForallWrap<3>(true, NE, device_kernel, host_kernel, Q1D, Q1D, Q1D);
-}
-
-void MixedVectorWeakCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
-   {
-      const int ndata = coeffDim == 1 ? 1 : 9;
-      if (Device::Allows(Backend::DEVICE_MASK))
-      {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
-         {
-            case 0x23: return SmemPAHcurlL2Apply3DTranspose<2,3>(dofs1D, quad1D, ndata,
-                                                                    ne, mapsO->B, mapsC->B,
-                                                                    mapsC->G, pa_data, x, y);
-            case 0x34: return SmemPAHcurlL2Apply3DTranspose<3,4>(dofs1D, quad1D, ndata,
-                                                                    ne, mapsO->B, mapsC->B,
-                                                                    mapsC->G, pa_data, x, y);
-            case 0x45: return SmemPAHcurlL2Apply3DTranspose<4,5>(dofs1D, quad1D, ndata,
-                                                                    ne, mapsO->B, mapsC->B,
-                                                                    mapsC->G, pa_data, x, y);
-            case 0x56: return SmemPAHcurlL2Apply3DTranspose<5,6>(dofs1D, quad1D, ndata,
-                                                                    ne, mapsO->B, mapsC->B,
-                                                                    mapsC->G, pa_data, x, y);
-            default: return SmemPAHcurlL2Apply3DTranspose(dofs1D, quad1D, ndata, ne,
-                                                             mapsO->B, mapsC->B,
-                                                             mapsC->G, pa_data, x, y);
-         }
-      }
-      else
-         PAHcurlL2Apply3DTranspose(dofs1D, quad1D, ndata, ne, mapsO->B,
-                                   mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->Gt, pa_data, x, y);
-   }
-   else if (testType == mfem::FiniteElement::CURL &&
-            trialType == mfem::FiniteElement::DIV && dim == 3)
-   {
-      PAHcurlHdivApply3DTranspose(dofs1D, dofs1D, quad1D, ne, mapsO->B,
-                                  mapsC->B, mapsO->Bt, mapsC->Bt,
-                                  mapsC->Gt, pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension or space!");
-   }
-}
-
-void MixedVectorWeakCurlIntegrator::AddMultTransposePA(const Vector &x,
-                                                       Vector &y) const
-{
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::DIV && dim == 3)
-   {
-      PAHcurlHdivApply3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
-                         mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->G,
-                         pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension or space!");
-   }
-}
-
-// Apply to x corresponding to DOFs in H^1 (domain) the (topological) gradient
-// to get a dof in H(curl) (range). You can think of the range as the "test" space
-// and the domain as the "trial" space, but there's no integration.
-static void PAHcurlApplyGradient2D(const int c_dofs1D,
-                                   const int o_dofs1D,
-                                   const int NE,
-                                   const Array<double> &B_,
-                                   const Array<double> &G_,
-                                   const Vector &x_,
-                                   Vector &y_)
-{
-   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, NE);
-   auto y = Reshape(y_.ReadWrite(), 2 * c_dofs1D * o_dofs1D, NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[MAX_D1D][MAX_D1D];
-
-      // horizontal part
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            w[dx][ey] = 0.0;
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               w[dx][ey] += B(ey, dy) * x(dx, dy, e);
-            }
-         }
-      }
-
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            double s = 0.0;
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               s += G(ex, dx) * w[dx][ey];
-            }
-            const int local_index = ey*o_dofs1D + ex;
-            y(local_index, e) += s;
-         }
-      }
-
-      // vertical part
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            w[dx][ey] = 0.0;
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               w[dx][ey] += G(ey, dy) * x(dx, dy, e);
-            }
-         }
-      }
-
-      for (int ey = 0; ey < o_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            double s = 0.0;
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               s += B(ex, dx) * w[dx][ey];
-            }
-            const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
-            y(local_index, e) += s;
-         }
-      }
-   });
-}
-
-// Specialization of PAHcurlApplyGradient2D to the case where B is identity
-static void PAHcurlApplyGradient2DBId(const int c_dofs1D,
-                                      const int o_dofs1D,
-                                      const int NE,
-                                      const Array<double> &G_,
-                                      const Vector &x_,
-                                      Vector &y_)
-{
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, NE);
-   auto y = Reshape(y_.ReadWrite(), 2 * c_dofs1D * o_dofs1D, NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[MAX_D1D][MAX_D1D];
-
-      // horizontal part
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            const int dy = ey;
-            w[dx][ey] = x(dx, dy, e);
-         }
-      }
-
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            double s = 0.0;
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               s += G(ex, dx) * w[dx][ey];
-            }
-            const int local_index = ey*o_dofs1D + ex;
-            y(local_index, e) += s;
-         }
-      }
-
-      // vertical part
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            w[dx][ey] = 0.0;
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               w[dx][ey] += G(ey, dy) * x(dx, dy, e);
-            }
-         }
-      }
-
-      for (int ey = 0; ey < o_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            const int dx = ex;
-            const double s = w[dx][ey];
-            const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
-            y(local_index, e) += s;
-         }
-      }
-   });
-}
-
-static void PAHcurlApplyGradientTranspose2D(
-   const int c_dofs1D, const int o_dofs1D, const int NE,
-   const Array<double> &B_, const Array<double> &G_,
-   const Vector &x_, Vector &y_)
-{
-   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), 2 * c_dofs1D * o_dofs1D, NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[MAX_D1D][MAX_D1D];
-
-      // horizontal part (open x, closed y)
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            w[dy][ex] = 0.0;
-            for (int ey = 0; ey < c_dofs1D; ++ey)
-            {
-               const int local_index = ey*o_dofs1D + ex;
-               w[dy][ex] += B(ey, dy) * x(local_index, e);
-            }
-         }
-      }
-
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            double s = 0.0;
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               s += G(ex, dx) * w[dy][ex];
-            }
-            y(dx, dy, e) += s;
-         }
-      }
-
-      // vertical part (open y, closed x)
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            w[dy][ex] = 0.0;
-            for (int ey = 0; ey < o_dofs1D; ++ey)
-            {
-               const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
-               w[dy][ex] += G(ey, dy) * x(local_index, e);
-            }
-         }
-      }
-
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            double s = 0.0;
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               s += B(ex, dx) * w[dy][ex];
-            }
-            y(dx, dy, e) += s;
-         }
-      }
-   });
-}
-
-// Specialization of PAHcurlApplyGradientTranspose2D to the case where
-// B is identity
-static void PAHcurlApplyGradientTranspose2DBId(
-   const int c_dofs1D, const int o_dofs1D, const int NE,
-   const Array<double> &G_,
-   const Vector &x_, Vector &y_)
-{
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), 2 * c_dofs1D * o_dofs1D, NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[MAX_D1D][MAX_D1D];
-
-      // horizontal part (open x, closed y)
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            const int ey = dy;
-            const int local_index = ey*o_dofs1D + ex;
-            w[dy][ex] = x(local_index, e);
-         }
-      }
-
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            double s = 0.0;
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               s += G(ex, dx) * w[dy][ex];
-            }
-            y(dx, dy, e) += s;
-         }
-      }
-
-      // vertical part (open y, closed x)
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            w[dy][ex] = 0.0;
-            for (int ey = 0; ey < o_dofs1D; ++ey)
-            {
-               const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
-               w[dy][ex] += G(ey, dy) * x(local_index, e);
-            }
-         }
-      }
-
-      for (int dy = 0; dy < c_dofs1D; ++dy)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            const int ex = dx;
-            const double s = w[dy][ex];
-            y(dx, dy, e) += s;
-         }
-      }
-   });
-}
-
-static void PAHcurlApplyGradient3D(const int c_dofs1D,
-                                   const int o_dofs1D,
-                                   const int NE,
-                                   const Array<double> &B_,
-                                   const Array<double> &G_,
-                                   const Vector &x_,
-                                   Vector &y_)
-{
-   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
-   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
-
-      // ---
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-      // ---
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               w1[dx][dy][ez] = 0.0;
-               for (int dz = 0; dz < c_dofs1D; ++dz)
-               {
-                  w1[dx][dy][ez] += B(ez, dz) * x(dx, dy, dz, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               w2[dx][ey][ez] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w2[dx][ey][ez] += B(ey, dy) * w1[dx][dy][ez];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += G(ex, dx) * w2[dx][ey][ez];
-               }
-               const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-               y(local_index, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-      // ---
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               w1[dx][dy][ez] = 0.0;
-               for (int dz = 0; dz < c_dofs1D; ++dz)
-               {
-                  w1[dx][dy][ez] += B(ez, dz) * x(dx, dy, dz, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               w2[dx][ey][ez] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w2[dx][ey][ez] += G(ey, dy) * w1[dx][dy][ez];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += B(ex, dx) * w2[dx][ey][ez];
-               }
-               const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                       ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-               y(local_index, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-      // ---
-
-      // contract in z
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               w1[dx][dy][ez] = 0.0;
-               for (int dz = 0; dz < c_dofs1D; ++dz)
-               {
-                  w1[dx][dy][ez] += G(ez, dz) * x(dx, dy, dz, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               w2[dx][ey][ez] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w2[dx][ey][ez] += B(ey, dy) * w1[dx][dy][ez];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += B(ex, dx) * w2[dx][ey][ez];
-               }
-               const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                       ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-               y(local_index, e) += s;
-            }
-         }
-      }
-   });
-}
-
-// Specialization of PAHcurlApplyGradient3D to the case where
-static void PAHcurlApplyGradient3DBId(const int c_dofs1D,
-                                      const int o_dofs1D,
-                                      const int NE,
-                                      const Array<double> &G_,
-                                      const Vector &x_,
-                                      Vector &y_)
-{
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
-   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
-
-      // ---
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-      // ---
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               const int dz = ez;
-               w1[dx][dy][ez] = x(dx, dy, dz, e);
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               const int dy = ey;
-               w2[dx][ey][ez] = w1[dx][dy][ez];
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += G(ex, dx) * w2[dx][ey][ez];
-               }
-               const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-               y(local_index, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-      // ---
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               const int dz = ez;
-               w1[dx][dy][ez] = x(dx, dy, dz, e);
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               w2[dx][ey][ez] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w2[dx][ey][ez] += G(ey, dy) * w1[dx][dy][ez];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               const int dx = ex;
-               const double s = w2[dx][ey][ez];
-               const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                       ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-               y(local_index, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-      // ---
-
-      // contract in z
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               w1[dx][dy][ez] = 0.0;
-               for (int dz = 0; dz < c_dofs1D; ++dz)
-               {
-                  w1[dx][dy][ez] += G(ez, dz) * x(dx, dy, dz, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               const int dy = ey;
-               w2[dx][ey][ez] = w1[dx][dy][ez];
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               const int dx = ex;
-               const double s = w2[dx][ey][ez];
-               const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                       ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-               y(local_index, e) += s;
-            }
-         }
-      }
-   });
-}
-
-static void PAHcurlApplyGradientTranspose3D(
-   const int c_dofs1D, const int o_dofs1D, const int NE,
-   const Array<double> &B_, const Array<double> &G_,
-   const Vector &x_, Vector &y_)
-{
-   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
-      // ---
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-      // ---
-
-      // contract in z
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            for (int ey = 0; ey < c_dofs1D; ++ey)
-            {
-               w1[ex][ey][dz] = 0.0;
-               for (int ez = 0; ez < c_dofs1D; ++ez)
-               {
-                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-                  w1[ex][ey][dz] += B(ez, dz) * x(local_index, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               w2[ex][dy][dz] = 0.0;
-               for (int ey = 0; ey < c_dofs1D; ++ey)
-               {
-                  w2[ex][dy][dz] += B(ey, dy) * w1[ex][ey][dz];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               double s = 0.0;
-               for (int ex = 0; ex < o_dofs1D; ++ex)
-               {
-                  s += G(ex, dx) * w2[ex][dy][dz];
-               }
-               y(dx, dy, dz, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-      // ---
-
-      // contract in z
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            for (int ey = 0; ey < o_dofs1D; ++ey)
-            {
-               w1[ex][ey][dz] = 0.0;
-               for (int ez = 0; ez < c_dofs1D; ++ez)
-               {
-                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-                  w1[ex][ey][dz] += B(ez, dz) * x(local_index, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               w2[ex][dy][dz] = 0.0;
-               for (int ey = 0; ey < o_dofs1D; ++ey)
-               {
-                  w2[ex][dy][dz] += G(ey, dy) * w1[ex][ey][dz];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               double s = 0.0;
-               for (int ex = 0; ex < c_dofs1D; ++ex)
-               {
-                  s += B(ex, dx) * w2[ex][dy][dz];
-               }
-               y(dx, dy, dz, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-      // ---
-
-      // contract in z
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            for (int ey = 0; ey < c_dofs1D; ++ey)
-            {
-               w1[ex][ey][dz] = 0.0;
-               for (int ez = 0; ez < o_dofs1D; ++ez)
-               {
-                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-                  w1[ex][ey][dz] += G(ez, dz) * x(local_index, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               w2[ex][dy][dz] = 0.0;
-               for (int ey = 0; ey < c_dofs1D; ++ey)
-               {
-                  w2[ex][dy][dz] += B(ey, dy) * w1[ex][ey][dz];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               double s = 0.0;
-               for (int ex = 0; ex < c_dofs1D; ++ex)
-               {
-                  s += B(ex, dx) * w2[ex][dy][dz];
-               }
-               y(dx, dy, dz, e) += s;
-            }
-         }
-      }
-   });
-}
-
-// Specialization of PAHcurlApplyGradientTranspose3D to the case where
-static void PAHcurlApplyGradientTranspose3DBId(
-   const int c_dofs1D, const int o_dofs1D, const int NE,
-   const Array<double> &G_,
-   const Vector &x_, Vector &y_)
-{
-   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
-      // ---
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-      // ---
-
-      // contract in z
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            for (int ey = 0; ey < c_dofs1D; ++ey)
-            {
-               const int ez = dz;
-               const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-               w1[ex][ey][dz] = x(local_index, e);
-            }
-         }
-      }
-
-      // contract in y
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               const int ey = dy;
-               w2[ex][dy][dz] = w1[ex][ey][dz];
-            }
-         }
-      }
-
-      // contract in x
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               double s = 0.0;
-               for (int ex = 0; ex < o_dofs1D; ++ex)
-               {
-                  s += G(ex, dx) * w2[ex][dy][dz];
-               }
-               y(dx, dy, dz, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-      // ---
-
-      // contract in z
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            for (int ey = 0; ey < o_dofs1D; ++ey)
-            {
-               const int ez = dz;
-               const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                       ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-               w1[ex][ey][dz] = x(local_index, e);
-            }
-         }
-      }
-
-      // contract in y
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               w2[ex][dy][dz] = 0.0;
-               for (int ey = 0; ey < o_dofs1D; ++ey)
-               {
-                  w2[ex][dy][dz] += G(ey, dy) * w1[ex][ey][dz];
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               const int ex = dx;
-               double s = w2[ex][dy][dz];
-               y(dx, dy, dz, e) += s;
-            }
-         }
-      }
-
-      // ---
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-      // ---
-
-      // contract in z
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            for (int ey = 0; ey < c_dofs1D; ++ey)
-            {
-               w1[ex][ey][dz] = 0.0;
-               for (int ez = 0; ez < o_dofs1D; ++ez)
-               {
-                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-                  w1[ex][ey][dz] += G(ez, dz) * x(local_index, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               const int ey = dy;
-               w2[ex][dy][dz] = w1[ex][ey][dz];
-            }
-         }
-      }
-
-      // contract in x
-      for (int dz = 0; dz < c_dofs1D; ++dz)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               const int ex = dx;
-               double s = w2[ex][dy][dz];
-               y(dx, dy, dz, e) += s;
-            }
-         }
-      }
-   });
-}
-
-void GradientInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                      const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "Bad dimension!");
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "Bad dimension!");
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(),
-               "Orders do not match!");
-   ne = trial_fes.GetNE();
-
-   const int order = trial_el->GetOrder();
-   dofquad_fe = new H1_SegmentElement(order, trial_el->GetBasisType());
-   mfem::QuadratureFunctions1D qf1d;
-   mfem::IntegrationRule closed_ir;
-   closed_ir.SetSize(order + 1);
-   qf1d.GaussLobatto(order + 1, &closed_ir);
-   mfem::IntegrationRule open_ir;
-   open_ir.SetSize(order);
-   qf1d.GaussLegendre(order, &open_ir);
-
-   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
-   o_dofs1D = maps_O_C->nqpt;
-   if (trial_el->GetBasisType() == BasisType::GaussLobatto)
-   {
-      B_id = true;
-      c_dofs1D = maps_O_C->ndof;
-   }
-   else
-   {
-      B_id = false;
-      maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
-      c_dofs1D = maps_C_C->nqpt;
-   }
-}
-
-void GradientInterpolator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      if (B_id)
-      {
-         PAHcurlApplyGradient3DBId(c_dofs1D, o_dofs1D, ne,
-                                   maps_O_C->G, x, y);
-      }
-      else
-      {
-         PAHcurlApplyGradient3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                maps_O_C->G, x, y);
-      }
-   }
-   else if (dim == 2)
-   {
-      if (B_id)
-      {
-         PAHcurlApplyGradient2DBId(c_dofs1D, o_dofs1D, ne,
-                                   maps_O_C->G, x, y);
-      }
-      else
-      {
-         PAHcurlApplyGradient2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->G,
-                                x, y);
-      }
-   }
-   else
-   {
-      mfem_error("Bad dimension!");
-   }
-}
-
-void GradientInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      if (B_id)
-      {
-         PAHcurlApplyGradientTranspose3DBId(c_dofs1D, o_dofs1D, ne,
-                                            maps_O_C->G, x, y);
-      }
-      else
-      {
-         PAHcurlApplyGradientTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                         maps_O_C->G, x, y);
-      }
-   }
-   else if (dim == 2)
-   {
-      if (B_id)
-      {
-         PAHcurlApplyGradientTranspose2DBId(c_dofs1D, o_dofs1D, ne,
-                                            maps_O_C->G, x, y);
-      }
-      else
-      {
-         PAHcurlApplyGradientTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                         maps_O_C->G, x, y);
-      }
-   }
-   else
-   {
-      mfem_error("Bad dimension!");
-   }
-}
-
-static void PAHcurlVecH1IdentityApply3D(const int c_dofs1D,
-                                        const int o_dofs1D,
-                                        const int NE,
-                                        const Array<double> &Bclosed,
-                                        const Array<double> &Bopen,
-                                        const Vector &pa_data,
-                                        const Vector &x_,
-                                        Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
-   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-
-   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
-                     NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bo(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bo(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-
-      // contract in z
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bo(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-   });
-}
-
-static void PAHcurlVecH1IdentityApplyTranspose3D(const int c_dofs1D,
-                                                 const int o_dofs1D,
-                                                 const int NE,
-                                                 const Array<double> &Bclosed,
-                                                 const Array<double> &Bopen,
-                                                 const Vector &pa_data,
-                                                 const Vector &x_,
-                                                 Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
-
-   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
-                     NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < o_dofs1D; ++ex)
-               {
-                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bo(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < c_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < c_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < c_dofs1D; ++ex)
-               {
-                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < o_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bo(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < c_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-
-      // contract in x
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < c_dofs1D; ++ex)
-               {
-                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < c_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < o_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bo(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-   });
-}
-
-static void PAHcurlVecH1IdentityApply2D(const int c_dofs1D,
-                                        const int o_dofs1D,
-                                        const int NE,
-                                        const Array<double> &Bclosed,
-                                        const Array<double> &Bopen,
-                                        const Vector &pa_data,
-                                        const Vector &x_,
-                                        Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, 2, NE);
-   auto y = Reshape(y_.ReadWrite(), (2 * c_dofs1D * o_dofs1D), NE);
-
-   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[2][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y)
-
-      // contract in y
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               w[j][dx][ey] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w[j][dx][ey] += Bc(ey, dy) * x(dx, dy, j, e);
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += Bo(ex, dx) * w[j][dx][ey];
-               }
-               const int local_index = ey*o_dofs1D + ex;
-               y(local_index, e) += s * vk(j, local_index, e);
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x)
-
-      // contract in y
-      for (int ey = 0; ey < o_dofs1D; ++ey)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               w[j][dx][ey] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w[j][dx][ey] += Bo(ey, dy) * x(dx, dy, j, e);
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ey = 0; ey < o_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += Bc(ex, dx) * w[j][dx][ey];
-               }
-               const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-               y(local_index, e) += s * vk(j, local_index, e);
-            }
-         }
-      }
-   });
-}
-
-static void PAHcurlVecH1IdentityApplyTranspose2D(const int c_dofs1D,
-                                                 const int o_dofs1D,
-                                                 const int NE,
-                                                 const Array<double> &Bclosed,
-                                                 const Array<double> &Bopen,
-                                                 const Vector &pa_data,
-                                                 const Vector &x_,
-                                                 Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), (2 * c_dofs1D * o_dofs1D), NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, 2, NE);
-
-   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   //constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[2][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y)
-
-      // contract in x
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
-         }
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            const int local_index = ey*o_dofs1D + ex;
-            const double xd = x(local_index, e);
-
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<2; ++j)
-               {
-                  w[j][dx][ey] += Bo(ex, dx) * xd * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int ey = 0; ey < c_dofs1D; ++ey)
-               {
-                  s += w[j][dx][ey] * Bc(ey, dy);
-               }
-               y(dx, dy, j, e) += s;
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x)
-
-      // contract in x
-      for (int ey = 0; ey < o_dofs1D; ++ey)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
-         }
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-            const double xd = x(local_index, e);
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<2; ++j)
-               {
-                  w[j][dx][ey] += Bc(ex, dx) * xd * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int ey = 0; ey < o_dofs1D; ++ey)
-               {
-                  s += w[j][dx][ey] * Bo(ey, dy);
-               }
-               y(dx, dy, j, e) += s;
-            }
-         }
-      }
-   });
-}
-
-void IdentityInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                      const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
-
-   ne = trial_fes.GetNE();
-
-   const int order = trial_el->GetOrder();
-   dofquad_fe = new H1_SegmentElement(order);
-   mfem::QuadratureFunctions1D qf1d;
-   mfem::IntegrationRule closed_ir;
-   closed_ir.SetSize(order + 1);
-   qf1d.GaussLobatto(order + 1, &closed_ir);
-   mfem::IntegrationRule open_ir;
-   open_ir.SetSize(order);
-   qf1d.GaussLegendre(order, &open_ir);
-
-   maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
-   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
-
-   o_dofs1D = maps_O_C->nqpt;
-   c_dofs1D = maps_C_C->nqpt;
-   MFEM_VERIFY(maps_O_C->ndof == c_dofs1D &&
-               maps_C_C->ndof == c_dofs1D, "Discrepancy in the number of DOFs");
-
-   const int ndof_test = (dim == 3) ? 3 * c_dofs1D * c_dofs1D * o_dofs1D
-                         : 2 * c_dofs1D * o_dofs1D;
-
-   const IntegrationRule & Nodes = test_el->GetNodes();
-
-   pa_data.SetSize(dim * ndof_test * ne, Device::GetMemoryType());
-   auto op = Reshape(pa_data.HostWrite(), dim, ndof_test, ne);
-
-   const Array<int> &dofmap = test_el->GetDofMap();
-
-   if (dim == 3)
-   {
-      // Note that ND_HexahedronElement uses 6 vectors in tk rather than 3, with
-      // the last 3 having negative signs. Here the signs are all positive, as
-      // signs are applied in ElementRestriction.
-
-      const double tk[9] = { 1.,0.,0.,  0.,1.,0.,  0.,0.,1. };
-
-      for (int c=0; c<3; ++c)
-      {
-         for (int i=0; i<ndof_test/3; ++i)
-         {
-            const int d = (c*ndof_test/3) + i;
-            // ND_HexahedronElement sets dof2tk = (dofmap < 0) ? 3+c : c, but here
-            // no signs should be applied due to ElementRestriction.
-            const int dof2tk = c;
-            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
-
-            for (int e=0; e<ne; ++e)
-            {
-               double v[3];
-               ElementTransformation *tr = mesh->GetElementTransformation(e);
-               tr->SetIntPoint(&Nodes.IntPoint(id));
-               tr->Jacobian().Mult(tk + dof2tk*dim, v);
-
-               for (int j=0; j<3; ++j)
-               {
-                  op(j,d,e) = v[j];
-               }
-            }
-         }
-      }
-   }
-   else // 2D case
-   {
-      const double tk[4] = { 1.,0.,  0.,1. };
-      for (int c=0; c<2; ++c)
-      {
-         for (int i=0; i<ndof_test/2; ++i)
-         {
-            const int d = (c*ndof_test/2) + i;
-            // ND_QuadrilateralElement sets dof2tk = (dofmap < 0) ? 2+c : c, but here
-            // no signs should be applied due to ElementRestriction.
-            const int dof2tk = c;
-            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
-
-            for (int e=0; e<ne; ++e)
-            {
-               double v[2];
-               ElementTransformation *tr = mesh->GetElementTransformation(e);
-               tr->SetIntPoint(&Nodes.IntPoint(id));
-               tr->Jacobian().Mult(tk + dof2tk*dim, v);
-
-               for (int j=0; j<2; ++j)
-               {
-                  op(j,d,e) = v[j];
-               }
-            }
-         }
-      }
-   }
-}
-
-void IdentityInterpolator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      PAHcurlVecH1IdentityApply3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
-                                  pa_data, x, y);
-   }
-   else if (dim == 2)
-   {
-      PAHcurlVecH1IdentityApply2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
-                                  pa_data, x, y);
-   }
-   else
-   {
-      mfem_error("Bad dimension!");
-   }
-}
-
-void IdentityInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      PAHcurlVecH1IdentityApplyTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                           maps_O_C->B, pa_data, x, y);
-   }
-   else if (dim == 2)
-   {
-      PAHcurlVecH1IdentityApplyTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                           maps_O_C->B, pa_data, x, y);
-   }
-   else
-   {
-      mfem_error("Bad dimension!");
-   }
-}
-
-template void SmemPAHcurlMassAssembleDiagonal3D<0,0>(const int D1D,
-                                                     const int Q1D,
-                                                     const int NE,
-                                                     const bool symmetric,
-                                                     const Array<double> &bo,
-                                                     const Array<double> &bc,
-                                                     const Vector &pa_data,
-                                                     Vector &diag);
-
-template void SmemPAHcurlMassAssembleDiagonal3D<2,3>(const int D1D,
-                                                     const int Q1D,
-                                                     const int NE,
-                                                     const bool symmetric,
-                                                     const Array<double> &bo,
-                                                     const Array<double> &bc,
-                                                     const Vector &pa_data,
-                                                     Vector &diag);
-
-template void SmemPAHcurlMassAssembleDiagonal3D<3,4>(const int D1D,
-                                                     const int Q1D,
-                                                     const int NE,
-                                                     const bool symmetric,
-                                                     const Array<double> &bo,
-                                                     const Array<double> &bc,
-                                                     const Vector &pa_data,
-                                                     Vector &diag);
-
-template void SmemPAHcurlMassAssembleDiagonal3D<4,5>(const int D1D,
-                                                     const int Q1D,
-                                                     const int NE,
-                                                     const bool symmetric,
-                                                     const Array<double> &bo,
-                                                     const Array<double> &bc,
-                                                     const Vector &pa_data,
-                                                     Vector &diag);
-
-template void SmemPAHcurlMassAssembleDiagonal3D<5,6>(const int D1D,
-                                                     const int Q1D,
-                                                     const int NE,
-                                                     const bool symmetric,
-                                                     const Array<double> &bo,
-                                                     const Array<double> &bc,
-                                                     const Vector &pa_data,
-                                                     Vector &diag);
-
-template void SmemPAHcurlMassApply3D<0,0>(const int D1D,
-                                          const int Q1D,
-                                          const int NE,
-                                          const bool symmetric,
-                                          const Array<double> &bo,
-                                          const Array<double> &bc,
-                                          const Array<double> &bot,
-                                          const Array<double> &bct,
-                                          const Vector &pa_data,
-                                          const Vector &x,
-                                          Vector &y);
-
-template void SmemPAHcurlMassApply3D<2,3>(const int D1D,
-                                          const int Q1D,
-                                          const int NE,
-                                          const bool symmetric,
-                                          const Array<double> &bo,
-                                          const Array<double> &bc,
-                                          const Array<double> &bot,
-                                          const Array<double> &bct,
-                                          const Vector &pa_data,
-                                          const Vector &x,
-                                          Vector &y);
-
-template void SmemPAHcurlMassApply3D<3,4>(const int D1D,
-                                          const int Q1D,
-                                          const int NE,
-                                          const bool symmetric,
-                                          const Array<double> &bo,
-                                          const Array<double> &bc,
-                                          const Array<double> &bot,
-                                          const Array<double> &bct,
-                                          const Vector &pa_data,
-                                          const Vector &x,
-                                          Vector &y);
-
-template void SmemPAHcurlMassApply3D<4,5>(const int D1D,
-                                          const int Q1D,
-                                          const int NE,
-                                          const bool symmetric,
-                                          const Array<double> &bo,
-                                          const Array<double> &bc,
-                                          const Array<double> &bot,
-                                          const Array<double> &bct,
-                                          const Vector &pa_data,
-                                          const Vector &x,
-                                          Vector &y);
-
-template void SmemPAHcurlMassApply3D<5,6>(const int D1D,
-                                          const int Q1D,
-                                          const int NE,
-                                          const bool symmetric,
-                                          const Array<double> &bo,
-                                          const Array<double> &bc,
-                                          const Array<double> &bot,
-                                          const Array<double> &bct,
-                                          const Vector &pa_data,
-                                          const Vector &x,
-                                          Vector &y);
-
-} // namespace mfem
diff --git a/fem/bilininteg_mass_pa.cpp b/fem/bilininteg_mass_pa.cpp
deleted file mode 100644
index 06156d030..000000000
--- a/fem/bilininteg_mass_pa.cpp
+++ /dev/null
@@ -1,737 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qfunction.hpp"
-#include "ceed/integrators/mass/mass.hpp"
-#include "bilininteg_mass_pa.hpp"
-
-using namespace std;
-
-namespace mfem
-{
-
-// PA Mass Integrator
-
-// PA Mass Assemble kernel
-
-void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
-{
-   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
-                         Device::GetDeviceMemoryType() : pa_mt;
-
-   // Assuming the same element type
-   fespace = &fes;
-   Mesh *mesh = fes.GetMesh();
-   if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation *T0 = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T0);
-   if (DeviceCanUseCeed())
-   {
-      delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAMassIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PAMassIntegrator(fes, *ir, Q);
-      }
-      return;
-   }
-   int map_type = el.GetMapType();
-   dim = mesh->Dimension();
-   ne = fes.GetMesh()->GetNE();
-   nq = ir->GetNPoints();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::DETERMINANTS, mt);
-   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
-   dofs1D = maps->ndof;
-   quad1D = maps->nqpt;
-   pa_data.SetSize(ne*nq, mt);
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
-
-   if (dim==1) { MFEM_ABORT("Not supported yet... stay tuned!"); }
-   if (dim==2)
-   {
-      const int NE = ne;
-      const int Q1D = quad1D;
-      const bool const_c = coeff.Size() == 1;
-      const bool by_val = map_type == FiniteElement::VALUE;
-      const auto W = Reshape(ir->GetWeights().Read(), Q1D,Q1D);
-      const auto J = Reshape(geom->detJ.Read(), Q1D,Q1D,NE);
-      const auto C = const_c ? Reshape(coeff.Read(), 1,1,1) :
-                     Reshape(coeff.Read(), Q1D,Q1D,NE);
-      auto v = Reshape(pa_data.Write(), Q1D,Q1D, NE);
-      mfem::forall_2D(NE,Q1D,Q1D, [=] MFEM_HOST_DEVICE (int e)
-      {
-         MFEM_FOREACH_THREAD(qx,x,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qy,y,Q1D)
-            {
-               const double detJ = J(qx,qy,e);
-               const double coeff = const_c ? C(0,0,0) : C(qx,qy,e);
-               v(qx,qy,e) =  W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
-            }
-         }
-      });
-   }
-   if (dim==3)
-   {
-      const int NE = ne;
-      const int Q1D = quad1D;
-      const bool const_c = coeff.Size() == 1;
-      const bool by_val = map_type == FiniteElement::VALUE;
-      const auto W = Reshape(ir->GetWeights().Read(), Q1D,Q1D,Q1D);
-      const auto J = Reshape(geom->detJ.Read(), Q1D,Q1D,Q1D,NE);
-      const auto C = const_c ? Reshape(coeff.Read(), 1,1,1,1) :
-                     Reshape(coeff.Read(), Q1D,Q1D,Q1D,NE);
-      auto v = Reshape(pa_data.Write(), Q1D,Q1D,Q1D,NE);
-      mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-      {
-         MFEM_FOREACH_THREAD(qx,x,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qy,y,Q1D)
-            {
-               MFEM_FOREACH_THREAD(qz,z,Q1D)
-               {
-                  const double detJ = J(qx,qy,qz,e);
-                  const double coeff = const_c ? C(0,0,0,0) : C(qx,qy,qz,e);
-                  v(qx,qy,qz,e) = W(qx,qy,qz) * coeff * (by_val ? detJ : 1.0/detJ);
-               }
-            }
-         }
-      });
-   }
-}
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void PAMassAssembleDiagonal2D(const int NE,
-                                     const Array<double> &b,
-                                     const Vector &d,
-                                     Vector &y,
-                                     const int d1d = 0,
-                                     const int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   MFEM_VERIFY(D1D <= MAX_D1D, "");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
-   auto B = Reshape(b.Read(), Q1D, D1D);
-   auto D = Reshape(d.Read(), Q1D, Q1D, NE);
-   auto Y = Reshape(y.ReadWrite(), D1D, D1D, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-      double QD[MQ1][MD1];
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            QD[qx][dy] = 0.0;
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               QD[qx][dy] += B(qy, dy) * B(qy, dy) * D(qx, qy, e);
-            }
-         }
-      }
-      for (int dy = 0; dy < D1D; ++dy)
-      {
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               Y(dx,dy,e) += B(qx, dx) * B(qx, dx) * QD[qx][dy];
-            }
-         }
-      }
-   });
-}
-
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
-static void SmemPAMassAssembleDiagonal2D(const int NE,
-                                         const Array<double> &b_,
-                                         const Vector &d_,
-                                         Vector &y_,
-                                         const int d1d = 0,
-                                         const int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int NBZ = T_NBZ ? T_NBZ : 1;
-   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-   MFEM_VERIFY(D1D <= MD1, "");
-   MFEM_VERIFY(Q1D <= MQ1, "");
-   auto b = Reshape(b_.Read(), Q1D, D1D);
-   auto D = Reshape(d_.Read(), Q1D, Q1D, NE);
-   auto Y = Reshape(y_.ReadWrite(), D1D, D1D, NE);
-   mfem::forall_2D_batch(NE, Q1D, Q1D, NBZ, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int tidz = MFEM_THREAD_ID(z);
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      constexpr int NBZ = T_NBZ ? T_NBZ : 1;
-      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-      MFEM_SHARED double B[MQ1][MD1];
-      MFEM_SHARED double QDZ[NBZ][MQ1][MD1];
-      double (*QD)[MD1] = (double (*)[MD1])(QDZ + tidz);
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               B[q][d] = b(q,d);
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(dy,y,D1D)
-         {
-            QD[qx][dy] = 0.0;
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               QD[qx][dy] += B[qy][dy] * B[qy][dy] * D(qx, qy, e);
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(dy,y,D1D)
-      {
-         MFEM_FOREACH_THREAD(dx,x,D1D)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               // might need absolute values on next line
-               Y(dx,dy,e) += B[qx][dx] * B[qx][dx] * QD[qx][dy];
-            }
-         }
-      }
-   });
-}
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void PAMassAssembleDiagonal3D(const int NE,
-                                     const Array<double> &b,
-                                     const Vector &d,
-                                     Vector &y,
-                                     const int d1d = 0,
-                                     const int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   MFEM_VERIFY(D1D <= MAX_D1D, "");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
-   auto B = Reshape(b.Read(), Q1D, D1D);
-   auto D = Reshape(d.Read(), Q1D, Q1D, Q1D, NE);
-   auto Y = Reshape(y.ReadWrite(), D1D, D1D, D1D, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-      double QQD[MQ1][MQ1][MD1];
-      double QDD[MQ1][MD1][MD1];
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int dz = 0; dz < D1D; ++dz)
-            {
-               QQD[qx][qy][dz] = 0.0;
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  QQD[qx][qy][dz] += B(qz, dz) * B(qz, dz) * D(qx, qy, qz, e);
-               }
-            }
-         }
-      }
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         for (int dz = 0; dz < D1D; ++dz)
-         {
-            for (int dy = 0; dy < D1D; ++dy)
-            {
-               QDD[qx][dy][dz] = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  QDD[qx][dy][dz] += B(qy, dy) * B(qy, dy) * QQD[qx][qy][dz];
-               }
-            }
-         }
-      }
-      for (int dz = 0; dz < D1D; ++dz)
-      {
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               double t = 0.0;
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  t += B(qx, dx) * B(qx, dx) * QDD[qx][dy][dz];
-               }
-               Y(dx, dy, dz, e) += t;
-            }
-         }
-      }
-   });
-}
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void SmemPAMassAssembleDiagonal3D(const int NE,
-                                         const Array<double> &b_,
-                                         const Vector &d_,
-                                         Vector &y_,
-                                         const int d1d = 0,
-                                         const int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-   MFEM_VERIFY(D1D <= MD1, "");
-   MFEM_VERIFY(Q1D <= MQ1, "");
-   auto b = Reshape(b_.Read(), Q1D, D1D);
-   auto D = Reshape(d_.Read(), Q1D, Q1D, Q1D, NE);
-   auto Y = Reshape(y_.ReadWrite(), D1D, D1D, D1D, NE);
-   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int tidz = MFEM_THREAD_ID(z);
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-      MFEM_SHARED double B[MQ1][MD1];
-      MFEM_SHARED double QQD[MQ1][MQ1][MD1];
-      MFEM_SHARED double QDD[MQ1][MD1][MD1];
-      if (tidz == 0)
-      {
-         MFEM_FOREACH_THREAD(d,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(q,x,Q1D)
-            {
-               B[q][d] = b(q,d);
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(dz,z,D1D)
-            {
-               QQD[qx][qy][dz] = 0.0;
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  QQD[qx][qy][dz] += B[qz][dz] * B[qz][dz] * D(qx, qy, qz, e);
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(dz,z,D1D)
-         {
-            MFEM_FOREACH_THREAD(dy,y,D1D)
-            {
-               QDD[qx][dy][dz] = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  QDD[qx][dy][dz] += B[qy][dy] * B[qy][dy] * QQD[qx][qy][dz];
-               }
-            }
-         }
-      }
-      MFEM_SYNC_THREAD;
-      MFEM_FOREACH_THREAD(dz,z,D1D)
-      {
-         MFEM_FOREACH_THREAD(dy,y,D1D)
-         {
-            MFEM_FOREACH_THREAD(dx,x,D1D)
-            {
-               double t = 0.0;
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  t += B[qx][dx] * B[qx][dx] * QDD[qx][dy][dz];
-               }
-               Y(dx, dy, dz, e) += t;
-            }
-         }
-      }
-   });
-}
-
-static void PAMassAssembleDiagonal(const int dim, const int D1D,
-                                   const int Q1D, const int NE,
-                                   const Array<double> &B,
-                                   const Vector &D,
-                                   Vector &Y)
-{
-   if (dim == 2)
-   {
-      switch ((D1D << 4 ) | Q1D)
-      {
-         case 0x22: return SmemPAMassAssembleDiagonal2D<2,2,16>(NE,B,D,Y);
-         case 0x33: return SmemPAMassAssembleDiagonal2D<3,3,16>(NE,B,D,Y);
-         case 0x44: return SmemPAMassAssembleDiagonal2D<4,4,8>(NE,B,D,Y);
-         case 0x55: return SmemPAMassAssembleDiagonal2D<5,5,8>(NE,B,D,Y);
-         case 0x66: return SmemPAMassAssembleDiagonal2D<6,6,4>(NE,B,D,Y);
-         case 0x77: return SmemPAMassAssembleDiagonal2D<7,7,4>(NE,B,D,Y);
-         case 0x88: return SmemPAMassAssembleDiagonal2D<8,8,2>(NE,B,D,Y);
-         case 0x99: return SmemPAMassAssembleDiagonal2D<9,9,2>(NE,B,D,Y);
-         default:   return PAMassAssembleDiagonal2D(NE,B,D,Y,D1D,Q1D);
-      }
-   }
-   else if (dim == 3)
-   {
-      switch ((D1D << 4 ) | Q1D)
-      {
-         case 0x23: return SmemPAMassAssembleDiagonal3D<2,3>(NE,B,D,Y);
-         case 0x24: return SmemPAMassAssembleDiagonal3D<2,4>(NE,B,D,Y);
-         case 0x26: return SmemPAMassAssembleDiagonal3D<2,6>(NE,B,D,Y);
-         case 0x34: return SmemPAMassAssembleDiagonal3D<3,4>(NE,B,D,Y);
-         case 0x35: return SmemPAMassAssembleDiagonal3D<3,5>(NE,B,D,Y);
-         case 0x45: return SmemPAMassAssembleDiagonal3D<4,5>(NE,B,D,Y);
-         case 0x48: return SmemPAMassAssembleDiagonal3D<4,8>(NE,B,D,Y);
-         case 0x56: return SmemPAMassAssembleDiagonal3D<5,6>(NE,B,D,Y);
-         case 0x67: return SmemPAMassAssembleDiagonal3D<6,7>(NE,B,D,Y);
-         case 0x78: return SmemPAMassAssembleDiagonal3D<7,8>(NE,B,D,Y);
-         case 0x89: return SmemPAMassAssembleDiagonal3D<8,9>(NE,B,D,Y);
-         default:   return PAMassAssembleDiagonal3D(NE,B,D,Y,D1D,Q1D);
-      }
-   }
-   MFEM_ABORT("Unknown kernel.");
-}
-
-void MassIntegrator::AssembleDiagonalPA(Vector &diag)
-{
-   if (DeviceCanUseCeed())
-   {
-      ceedOp->GetDiagonal(diag);
-   }
-   else
-   {
-      PAMassAssembleDiagonal(dim, dofs1D, quad1D, ne, maps->B, pa_data, diag);
-   }
-}
-
-
-#ifdef MFEM_USE_OCCA
-// OCCA PA Mass Apply 2D kernel
-static void OccaPAMassApply2D(const int D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &B,
-                              const Array<double> &Bt,
-                              const Vector &D,
-                              const Vector &X,
-                              Vector &Y)
-{
-   occa::properties props;
-   props["defines/D1D"] = D1D;
-   props["defines/Q1D"] = Q1D;
-   const occa::memory o_B = OccaMemoryRead(B.GetMemory(), B.Size());
-   const occa::memory o_Bt = OccaMemoryRead(Bt.GetMemory(), Bt.Size());
-   const occa::memory o_D = OccaMemoryRead(D.GetMemory(), D.Size());
-   const occa::memory o_X = OccaMemoryRead(X.GetMemory(), X.Size());
-   occa::memory o_Y = OccaMemoryReadWrite(Y.GetMemory(), Y.Size());
-   const occa_id_t id = std::make_pair(D1D,Q1D);
-   if (!Device::Allows(Backend::OCCA_CUDA))
-   {
-      static occa_kernel_t OccaMassApply2D_cpu;
-      if (OccaMassApply2D_cpu.find(id) == OccaMassApply2D_cpu.end())
-      {
-         const occa::kernel MassApply2D_CPU =
-            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
-                                        "MassApply2D_CPU", props);
-         OccaMassApply2D_cpu.emplace(id, MassApply2D_CPU);
-      }
-      OccaMassApply2D_cpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
-   }
-   else
-   {
-      static occa_kernel_t OccaMassApply2D_gpu;
-      if (OccaMassApply2D_gpu.find(id) == OccaMassApply2D_gpu.end())
-      {
-         const occa::kernel MassApply2D_GPU =
-            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
-                                        "MassApply2D_GPU", props);
-         OccaMassApply2D_gpu.emplace(id, MassApply2D_GPU);
-      }
-      OccaMassApply2D_gpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
-   }
-}
-
-// OCCA PA Mass Apply 3D kernel
-static void OccaPAMassApply3D(const int D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &B,
-                              const Array<double> &Bt,
-                              const Vector &D,
-                              const Vector &X,
-                              Vector &Y)
-{
-   occa::properties props;
-   props["defines/D1D"] = D1D;
-   props["defines/Q1D"] = Q1D;
-   const occa::memory o_B = OccaMemoryRead(B.GetMemory(), B.Size());
-   const occa::memory o_Bt = OccaMemoryRead(Bt.GetMemory(), Bt.Size());
-   const occa::memory o_D = OccaMemoryRead(D.GetMemory(), D.Size());
-   const occa::memory o_X = OccaMemoryRead(X.GetMemory(), X.Size());
-   occa::memory o_Y = OccaMemoryReadWrite(Y.GetMemory(), Y.Size());
-   const occa_id_t id = std::make_pair(D1D,Q1D);
-   if (!Device::Allows(Backend::OCCA_CUDA))
-   {
-      static occa_kernel_t OccaMassApply3D_cpu;
-      if (OccaMassApply3D_cpu.find(id) == OccaMassApply3D_cpu.end())
-      {
-         const occa::kernel MassApply3D_CPU =
-            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
-                                        "MassApply3D_CPU", props);
-         OccaMassApply3D_cpu.emplace(id, MassApply3D_CPU);
-      }
-      OccaMassApply3D_cpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
-   }
-   else
-   {
-      static occa_kernel_t OccaMassApply3D_gpu;
-      if (OccaMassApply3D_gpu.find(id) == OccaMassApply3D_gpu.end())
-      {
-         const occa::kernel MassApply3D_GPU =
-            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
-                                        "MassApply3D_GPU", props);
-         OccaMassApply3D_gpu.emplace(id, MassApply3D_GPU);
-      }
-      OccaMassApply3D_gpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
-   }
-}
-#endif // MFEM_USE_OCCA
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void PAMassApply2D(const int NE,
-                          const Array<double> &b_,
-                          const Array<double> &bt_,
-                          const Vector &d_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
-{
-   MFEM_VERIFY(T_D1D ? T_D1D : d1d <= MAX_D1D, "");
-   MFEM_VERIFY(T_Q1D ? T_Q1D : q1d <= MAX_Q1D, "");
-
-   const auto B = b_.Read();
-   const auto Bt = bt_.Read();
-   const auto D = d_.Read();
-   const auto X = x_.Read();
-   auto Y = y_.ReadWrite();
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      internal::PAMassApply2D_Element(e, NE, B, Bt, D, X, Y, d1d, q1d);
-   });
-}
-
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
-static void SmemPAMassApply2D(const int NE,
-                              const Array<double> &b_,
-                              const Array<double> &bt_,
-                              const Vector &d_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0)
-{
-   MFEM_CONTRACT_VAR(bt_);
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int NBZ = T_NBZ ? T_NBZ : 1;
-   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-   MFEM_VERIFY(D1D <= MD1, "");
-   MFEM_VERIFY(Q1D <= MQ1, "");
-   const auto b = b_.Read();
-   const auto D = d_.Read();
-   const auto x = x_.Read();
-   auto Y = y_.ReadWrite();
-   mfem::forall_2D_batch(NE, Q1D, Q1D, NBZ, [=] MFEM_HOST_DEVICE (int e)
-   {
-      internal::SmemPAMassApply2D_Element<T_D1D,T_Q1D,T_NBZ>(e, NE, b, D, x, Y, d1d,
-                                                             q1d);
-   });
-}
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void PAMassApply3D(const int NE,
-                          const Array<double> &b_,
-                          const Array<double> &bt_,
-                          const Vector &d_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
-{
-   MFEM_VERIFY(T_D1D ? T_D1D : d1d <= MAX_D1D, "");
-   MFEM_VERIFY(T_Q1D ? T_Q1D : q1d <= MAX_Q1D, "");
-
-   const auto B = b_.Read();
-   const auto Bt = bt_.Read();
-   const auto D = d_.Read();
-   const auto X = x_.Read();
-   auto Y = y_.ReadWrite();
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      internal::PAMassApply3D_Element(e, NE, B, Bt, D, X, Y, d1d, q1d);
-   });
-}
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void SmemPAMassApply3D(const int NE,
-                              const Array<double> &b_,
-                              const Array<double> &bt_,
-                              const Vector &d_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0)
-{
-   MFEM_CONTRACT_VAR(bt_);
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int M1Q = T_Q1D ? T_Q1D : MAX_Q1D;
-   constexpr int M1D = T_D1D ? T_D1D : MAX_D1D;
-   MFEM_VERIFY(D1D <= M1D, "");
-   MFEM_VERIFY(Q1D <= M1Q, "");
-   auto b = b_.Read();
-   auto d = d_.Read();
-   auto x = x_.Read();
-   auto y = y_.ReadWrite();
-   mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      internal::SmemPAMassApply3D_Element<T_D1D,T_Q1D>(e, NE, b, d, x, y, d1d, q1d);
-   });
-}
-
-static void PAMassApply(const int dim,
-                        const int D1D,
-                        const int Q1D,
-                        const int NE,
-                        const Array<double> &B,
-                        const Array<double> &Bt,
-                        const Vector &D,
-                        const Vector &X,
-                        Vector &Y)
-{
-#ifdef MFEM_USE_OCCA
-   if (DeviceCanUseOcca())
-   {
-      if (dim == 2)
-      {
-         return OccaPAMassApply2D(D1D,Q1D,NE,B,Bt,D,X,Y);
-      }
-      if (dim == 3)
-      {
-         return OccaPAMassApply3D(D1D,Q1D,NE,B,Bt,D,X,Y);
-      }
-      MFEM_ABORT("OCCA PA Mass Apply unknown kernel!");
-   }
-#endif // MFEM_USE_OCCA
-   const int id = (D1D << 4) | Q1D;
-
-   if (dim == 2)
-   {
-      switch (id)
-      {
-         case 0x22: return SmemPAMassApply2D<2,2,16>(NE,B,Bt,D,X,Y);
-         case 0x24: return SmemPAMassApply2D<2,4,16>(NE,B,Bt,D,X,Y);
-         case 0x33: return SmemPAMassApply2D<3,3,16>(NE,B,Bt,D,X,Y);
-         case 0x34: return SmemPAMassApply2D<3,4,16>(NE,B,Bt,D,X,Y);
-         case 0x35: return SmemPAMassApply2D<3,5,16>(NE,B,Bt,D,X,Y);
-         case 0x36: return SmemPAMassApply2D<3,6,16>(NE,B,Bt,D,X,Y);
-         case 0x44: return SmemPAMassApply2D<4,4,8>(NE,B,Bt,D,X,Y);
-         case 0x46: return SmemPAMassApply2D<4,6,8>(NE,B,Bt,D,X,Y);
-         case 0x48: return SmemPAMassApply2D<4,8,4>(NE,B,Bt,D,X,Y);
-         case 0x55: return SmemPAMassApply2D<5,5,8>(NE,B,Bt,D,X,Y);
-         case 0x57: return SmemPAMassApply2D<5,7,8>(NE,B,Bt,D,X,Y);
-         case 0x58: return SmemPAMassApply2D<5,8,2>(NE,B,Bt,D,X,Y);
-         case 0x66: return SmemPAMassApply2D<6,6,4>(NE,B,Bt,D,X,Y);
-         case 0x77: return SmemPAMassApply2D<7,7,4>(NE,B,Bt,D,X,Y);
-         case 0x88: return SmemPAMassApply2D<8,8,2>(NE,B,Bt,D,X,Y);
-         case 0x99: return SmemPAMassApply2D<9,9,2>(NE,B,Bt,D,X,Y);
-         default:   return PAMassApply2D(NE,B,Bt,D,X,Y,D1D,Q1D);
-      }
-   }
-   else if (dim == 3)
-   {
-      switch (id)
-      {
-         case 0x22: return SmemPAMassApply3D<2,2>(NE,B,Bt,D,X,Y);
-         case 0x23: return SmemPAMassApply3D<2,3>(NE,B,Bt,D,X,Y);
-         case 0x24: return SmemPAMassApply3D<2,4>(NE,B,Bt,D,X,Y);
-         case 0x26: return SmemPAMassApply3D<2,6>(NE,B,Bt,D,X,Y);
-         case 0x34: return SmemPAMassApply3D<3,4>(NE,B,Bt,D,X,Y);
-         case 0x35: return SmemPAMassApply3D<3,5>(NE,B,Bt,D,X,Y);
-         case 0x36: return SmemPAMassApply3D<3,6>(NE,B,Bt,D,X,Y);
-         case 0x37: return SmemPAMassApply3D<3,7>(NE,B,Bt,D,X,Y);
-         case 0x45: return SmemPAMassApply3D<4,5>(NE,B,Bt,D,X,Y);
-         case 0x46: return SmemPAMassApply3D<4,6>(NE,B,Bt,D,X,Y);
-         case 0x48: return SmemPAMassApply3D<4,8>(NE,B,Bt,D,X,Y);
-         case 0x56: return SmemPAMassApply3D<5,6>(NE,B,Bt,D,X,Y);
-         case 0x58: return SmemPAMassApply3D<5,8>(NE,B,Bt,D,X,Y);
-         case 0x67: return SmemPAMassApply3D<6,7>(NE,B,Bt,D,X,Y);
-         case 0x78: return SmemPAMassApply3D<7,8>(NE,B,Bt,D,X,Y);
-         case 0x89: return SmemPAMassApply3D<8,9>(NE,B,Bt,D,X,Y);
-         case 0x9A: return SmemPAMassApply3D<9,10>(NE,B,Bt,D,X,Y);
-         default:   return PAMassApply3D(NE,B,Bt,D,X,Y,D1D,Q1D);
-      }
-   }
-   mfem::out << "Unknown kernel 0x" << std::hex << id << std::endl;
-   MFEM_ABORT("Unknown kernel.");
-}
-
-void MassIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (DeviceCanUseCeed())
-   {
-      ceedOp->AddMult(x, y);
-   }
-   else
-   {
-      PAMassApply(dim, dofs1D, quad1D, ne, maps->B, maps->Bt, pa_data, x, y);
-   }
-}
-
-void MassIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
-{
-   // Mass integrator is symmetric
-   AddMultPA(x, y);
-}
-
-} // namespace mfem
diff --git a/fem/bilininteg_mass_pa.hpp b/fem/bilininteg_mass_pa.hpp
deleted file mode 100644
index 73c8892e1..000000000
--- a/fem/bilininteg_mass_pa.hpp
+++ /dev/null
@@ -1,632 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-#ifndef MFEM_BILININTEG_MASS_PA_HPP
-#define MFEM_BILININTEG_MASS_PA_HPP
-
-#include "../config/config.hpp"
-#include "../general/forall.hpp"
-#include "../linalg/dtensor.hpp"
-
-namespace mfem
-{
-
-namespace internal
-{
-
-template <bool ACCUMULATE = true>
-MFEM_HOST_DEVICE inline
-void PAMassApply2D_Element(const int e,
-                           const int NE,
-                           const double *b_,
-                           const double *bt_,
-                           const double *d_,
-                           const double *x_,
-                           double *y_,
-                           const int d1d = 0,
-                           const int q1d = 0)
-{
-   const int D1D = d1d;
-   const int Q1D = q1d;
-   auto B = ConstDeviceMatrix(b_, Q1D, D1D);
-   auto Bt = ConstDeviceMatrix(bt_, D1D, Q1D);
-   auto D = ConstDeviceCube(d_, Q1D, Q1D, NE);
-   auto X = ConstDeviceCube(x_, D1D, D1D, NE);
-   auto Y = DeviceCube(y_, D1D, D1D, NE);
-
-   if (!ACCUMULATE)
-   {
-      for (int dy = 0; dy < D1D; ++dy)
-      {
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            Y(dx, dy, e) = 0.0;
-         }
-      }
-   }
-
-   constexpr int max_D1D = MAX_D1D;
-   constexpr int max_Q1D = MAX_Q1D;
-   double sol_xy[max_Q1D][max_Q1D];
-   for (int qy = 0; qy < Q1D; ++qy)
-   {
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         sol_xy[qy][qx] = 0.0;
-      }
-   }
-   for (int dy = 0; dy < D1D; ++dy)
-   {
-      double sol_x[max_Q1D];
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         sol_x[qy] = 0.0;
-      }
-      for (int dx = 0; dx < D1D; ++dx)
-      {
-         const double s = X(dx,dy,e);
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            sol_x[qx] += B(qx,dx)* s;
-         }
-      }
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         const double d2q = B(qy,dy);
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            sol_xy[qy][qx] += d2q * sol_x[qx];
-         }
-      }
-   }
-   for (int qy = 0; qy < Q1D; ++qy)
-   {
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         sol_xy[qy][qx] *= D(qx,qy,e);
-      }
-   }
-   for (int qy = 0; qy < Q1D; ++qy)
-   {
-      double sol_x[max_D1D];
-      for (int dx = 0; dx < D1D; ++dx)
-      {
-         sol_x[dx] = 0.0;
-      }
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         const double s = sol_xy[qy][qx];
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            sol_x[dx] += Bt(dx,qx) * s;
-         }
-      }
-      for (int dy = 0; dy < D1D; ++dy)
-      {
-         const double q2d = Bt(dy,qy);
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            Y(dx,dy,e) += q2d * sol_x[dx];
-         }
-      }
-   }
-}
-
-template<int T_D1D, int T_Q1D, int T_NBZ, bool ACCUMULATE = true>
-MFEM_HOST_DEVICE inline
-void SmemPAMassApply2D_Element(const int e,
-                               const int NE,
-                               const double *b_,
-                               const double *d_,
-                               const double *x_,
-                               double *y_,
-                               int d1d = 0,
-                               int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int NBZ = T_NBZ ? T_NBZ : 1;
-
-   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-   constexpr int MDQ = (MQ1 > MD1) ? MQ1 : MD1;
-
-   auto b = ConstDeviceMatrix(b_, Q1D, D1D);
-   auto D = ConstDeviceCube(d_, Q1D, Q1D, NE);
-   auto x = ConstDeviceCube(x_, D1D, D1D, NE);
-   auto Y = DeviceCube(y_, D1D, D1D, NE);
-
-   const int tidz = MFEM_THREAD_ID(z);
-
-   MFEM_SHARED double BBt[MQ1*MD1];
-   double (*B)[MD1] = (double (*)[MD1]) BBt;
-   double (*Bt)[MQ1] = (double (*)[MQ1]) BBt;
-   MFEM_SHARED double sm0[NBZ][MDQ*MDQ];
-   MFEM_SHARED double sm1[NBZ][MDQ*MDQ];
-   double (*X)[MD1] = (double (*)[MD1]) (sm0 + tidz);
-   double (*DQ)[MQ1] = (double (*)[MQ1]) (sm1 + tidz);
-   double (*QQ)[MQ1] = (double (*)[MQ1]) (sm0 + tidz);
-   double (*QD)[MD1] = (double (*)[MD1]) (sm1 + tidz);
-
-
-   MFEM_FOREACH_THREAD(dy,y,D1D)
-   {
-      MFEM_FOREACH_THREAD(dx,x,D1D)
-      {
-         X[dy][dx] = x(dx,dy,e);
-      }
-   }
-   if (tidz == 0)
-   {
-      MFEM_FOREACH_THREAD(dy,y,D1D)
-      {
-         MFEM_FOREACH_THREAD(q,x,Q1D)
-         {
-            B[q][dy] = b(q,dy);
-         }
-      }
-   }
-   MFEM_SYNC_THREAD;
-   MFEM_FOREACH_THREAD(dy,y,D1D)
-   {
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         double dq = 0.0;
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            dq += X[dy][dx] * B[qx][dx];
-         }
-         DQ[dy][qx] = dq;
-      }
-   }
-   MFEM_SYNC_THREAD;
-   MFEM_FOREACH_THREAD(qy,y,Q1D)
-   {
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         double qq = 0.0;
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            qq += DQ[dy][qx] * B[qy][dy];
-         }
-         QQ[qy][qx] = qq * D(qx, qy, e);
-      }
-   }
-   MFEM_SYNC_THREAD;
-   if (tidz == 0)
-   {
-      MFEM_FOREACH_THREAD(dy,y,D1D)
-      {
-         MFEM_FOREACH_THREAD(q,x,Q1D)
-         {
-            Bt[dy][q] = b(q,dy);
-         }
-      }
-   }
-   MFEM_SYNC_THREAD;
-   MFEM_FOREACH_THREAD(qy,y,Q1D)
-   {
-      MFEM_FOREACH_THREAD(dx,x,D1D)
-      {
-         double dq = 0.0;
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            dq += QQ[qy][qx] * Bt[dx][qx];
-         }
-         QD[qy][dx] = dq;
-      }
-   }
-   MFEM_SYNC_THREAD;
-   MFEM_FOREACH_THREAD(dy,y,D1D)
-   {
-      MFEM_FOREACH_THREAD(dx,x,D1D)
-      {
-         double dd = 0.0;
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            dd += (QD[qy][dx] * Bt[dy][qy]);
-         }
-         if (ACCUMULATE)
-         {
-            Y(dx, dy, e) += dd;
-         }
-         else
-         {
-            Y(dx, dy, e) = dd;
-         }
-      }
-   }
-}
-
-template <bool ACCUMULATE = true>
-MFEM_HOST_DEVICE inline
-void PAMassApply3D_Element(const int e,
-                           const int NE,
-                           const double *b_,
-                           const double *bt_,
-                           const double *d_,
-                           const double *x_,
-                           double *y_,
-                           const int d1d,
-                           const int q1d)
-{
-   const int D1D = d1d;
-   const int Q1D = q1d;
-   auto B = ConstDeviceMatrix(b_, Q1D, D1D);
-   auto Bt = ConstDeviceMatrix(bt_, D1D, Q1D);
-   auto D = DeviceTensor<4,const double>(d_, Q1D, Q1D, Q1D, NE);
-   auto X = DeviceTensor<4,const double>(x_, D1D, D1D, D1D, NE);
-   auto Y = DeviceTensor<4,double>(y_, D1D, D1D, D1D, NE);
-
-   if (!ACCUMULATE)
-   {
-      for (int dz = 0; dz < D1D; ++dz)
-      {
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               Y(dx, dy, dz, e) = 0.0;
-            }
-         }
-      }
-   }
-
-   constexpr int max_D1D = MAX_D1D;
-   constexpr int max_Q1D = MAX_Q1D;
-   double sol_xyz[max_Q1D][max_Q1D][max_Q1D];
-   for (int qz = 0; qz < Q1D; ++qz)
-   {
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            sol_xyz[qz][qy][qx] = 0.0;
-         }
-      }
-   }
-   for (int dz = 0; dz < D1D; ++dz)
-   {
-      double sol_xy[max_Q1D][max_Q1D];
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            sol_xy[qy][qx] = 0.0;
-         }
-      }
-      for (int dy = 0; dy < D1D; ++dy)
-      {
-         double sol_x[max_Q1D];
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            sol_x[qx] = 0;
-         }
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            const double s = X(dx,dy,dz,e);
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               sol_x[qx] += B(qx,dx) * s;
-            }
-         }
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            const double wy = B(qy,dy);
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               sol_xy[qy][qx] += wy * sol_x[qx];
-            }
-         }
-      }
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         const double wz = B(qz,dz);
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               sol_xyz[qz][qy][qx] += wz * sol_xy[qy][qx];
-            }
-         }
-      }
-   }
-   for (int qz = 0; qz < Q1D; ++qz)
-   {
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            sol_xyz[qz][qy][qx] *= D(qx,qy,qz,e);
-         }
-      }
-   }
-   for (int qz = 0; qz < Q1D; ++qz)
-   {
-      double sol_xy[max_D1D][max_D1D];
-      for (int dy = 0; dy < D1D; ++dy)
-      {
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            sol_xy[dy][dx] = 0;
-         }
-      }
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         double sol_x[max_D1D];
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            sol_x[dx] = 0;
-         }
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            const double s = sol_xyz[qz][qy][qx];
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               sol_x[dx] += Bt(dx,qx) * s;
-            }
-         }
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            const double wy = Bt(dy,qy);
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               sol_xy[dy][dx] += wy * sol_x[dx];
-            }
-         }
-      }
-      for (int dz = 0; dz < D1D; ++dz)
-      {
-         const double wz = Bt(dz,qz);
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               Y(dx,dy,dz,e) += wz * sol_xy[dy][dx];
-            }
-         }
-      }
-   }
-}
-
-template<int T_D1D, int T_Q1D, bool ACCUMULATE = true>
-MFEM_HOST_DEVICE inline
-void SmemPAMassApply3D_Element(const int e,
-                               const int NE,
-                               const double *b_,
-                               const double *d_,
-                               const double *x_,
-                               double *y_,
-                               const int d1d = 0,
-                               const int q1d = 0)
-{
-   constexpr int D1D = T_D1D ? T_D1D : d1d;
-   constexpr int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-   constexpr int MDQ = (MQ1 > MD1) ? MQ1 : MD1;
-
-   auto b = ConstDeviceMatrix(b_, Q1D, D1D);
-   auto d = DeviceTensor<4,const double>(d_, Q1D, Q1D, Q1D, NE);
-   auto x = DeviceTensor<4,const double>(x_, D1D, D1D, D1D, NE);
-   auto y = DeviceTensor<4,double>(y_, D1D, D1D, D1D, NE);
-
-   MFEM_SHARED double sDQ[MQ1*MD1];
-   double (*B)[MD1] = (double (*)[MD1]) sDQ;
-   double (*Bt)[MQ1] = (double (*)[MQ1]) sDQ;
-   MFEM_SHARED double sm0[MDQ*MDQ*MDQ];
-   MFEM_SHARED double sm1[MDQ*MDQ*MDQ];
-   double (*X)[MD1][MD1]   = (double (*)[MD1][MD1]) sm0;
-   double (*DDQ)[MD1][MQ1] = (double (*)[MD1][MQ1]) sm1;
-   double (*DQQ)[MQ1][MQ1] = (double (*)[MQ1][MQ1]) sm0;
-   double (*QQQ)[MQ1][MQ1] = (double (*)[MQ1][MQ1]) sm1;
-   double (*QQD)[MQ1][MD1] = (double (*)[MQ1][MD1]) sm0;
-   double (*QDD)[MD1][MD1] = (double (*)[MD1][MD1]) sm1;
-   MFEM_FOREACH_THREAD(dy,y,D1D)
-   {
-      MFEM_FOREACH_THREAD(dx,x,D1D)
-      {
-         MFEM_UNROLL(MD1)
-         for (int dz = 0; dz < D1D; ++dz)
-         {
-            X[dz][dy][dx] = x(dx,dy,dz,e);
-         }
-      }
-      MFEM_FOREACH_THREAD(dx,x,Q1D)
-      {
-         B[dx][dy] = b(dx,dy);
-      }
-   }
-   MFEM_SYNC_THREAD;
-   MFEM_FOREACH_THREAD(dy,y,D1D)
-   {
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         double u[D1D];
-         MFEM_UNROLL(MD1)
-         for (int dz = 0; dz < D1D; dz++)
-         {
-            u[dz] = 0;
-         }
-         MFEM_UNROLL(MD1)
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            MFEM_UNROLL(MD1)
-            for (int dz = 0; dz < D1D; ++dz)
-            {
-               u[dz] += X[dz][dy][dx] * B[qx][dx];
-            }
-         }
-         MFEM_UNROLL(MD1)
-         for (int dz = 0; dz < D1D; ++dz)
-         {
-            DDQ[dz][dy][qx] = u[dz];
-         }
-      }
-   }
-   MFEM_SYNC_THREAD;
-   MFEM_FOREACH_THREAD(qy,y,Q1D)
-   {
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         double u[D1D];
-         MFEM_UNROLL(MD1)
-         for (int dz = 0; dz < D1D; dz++)
-         {
-            u[dz] = 0;
-         }
-         MFEM_UNROLL(MD1)
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            MFEM_UNROLL(MD1)
-            for (int dz = 0; dz < D1D; dz++)
-            {
-               u[dz] += DDQ[dz][dy][qx] * B[qy][dy];
-            }
-         }
-         MFEM_UNROLL(MD1)
-         for (int dz = 0; dz < D1D; dz++)
-         {
-            DQQ[dz][qy][qx] = u[dz];
-         }
-      }
-   }
-   MFEM_SYNC_THREAD;
-   MFEM_FOREACH_THREAD(qy,y,Q1D)
-   {
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         double u[Q1D];
-         MFEM_UNROLL(MQ1)
-         for (int qz = 0; qz < Q1D; qz++)
-         {
-            u[qz] = 0;
-         }
-         MFEM_UNROLL(MD1)
-         for (int dz = 0; dz < D1D; ++dz)
-         {
-            MFEM_UNROLL(MQ1)
-            for (int qz = 0; qz < Q1D; qz++)
-            {
-               u[qz] += DQQ[dz][qy][qx] * B[qz][dz];
-            }
-         }
-         MFEM_UNROLL(MQ1)
-         for (int qz = 0; qz < Q1D; qz++)
-         {
-            QQQ[qz][qy][qx] = u[qz] * d(qx,qy,qz,e);
-         }
-      }
-   }
-   MFEM_SYNC_THREAD;
-   MFEM_FOREACH_THREAD(di,y,D1D)
-   {
-      MFEM_FOREACH_THREAD(q,x,Q1D)
-      {
-         Bt[di][q] = b(q,di);
-      }
-   }
-   MFEM_SYNC_THREAD;
-   MFEM_FOREACH_THREAD(qy,y,Q1D)
-   {
-      MFEM_FOREACH_THREAD(dx,x,D1D)
-      {
-         double u[Q1D];
-         MFEM_UNROLL(MQ1)
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            u[qz] = 0;
-         }
-         MFEM_UNROLL(MQ1)
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            MFEM_UNROLL(MQ1)
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               u[qz] += QQQ[qz][qy][qx] * Bt[dx][qx];
-            }
-         }
-         MFEM_UNROLL(MQ1)
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            QQD[qz][qy][dx] = u[qz];
-         }
-      }
-   }
-   MFEM_SYNC_THREAD;
-   MFEM_FOREACH_THREAD(dy,y,D1D)
-   {
-      MFEM_FOREACH_THREAD(dx,x,D1D)
-      {
-         double u[Q1D];
-         MFEM_UNROLL(MQ1)
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            u[qz] = 0;
-         }
-         MFEM_UNROLL(MQ1)
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            MFEM_UNROLL(MQ1)
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               u[qz] += QQD[qz][qy][dx] * Bt[dy][qy];
-            }
-         }
-         MFEM_UNROLL(MQ1)
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            QDD[qz][dy][dx] = u[qz];
-         }
-      }
-   }
-   MFEM_SYNC_THREAD;
-   MFEM_FOREACH_THREAD(dy,y,D1D)
-   {
-      MFEM_FOREACH_THREAD(dx,x,D1D)
-      {
-         double u[D1D];
-         MFEM_UNROLL(MD1)
-         for (int dz = 0; dz < D1D; ++dz)
-         {
-            u[dz] = 0;
-         }
-         MFEM_UNROLL(MQ1)
-         for (int qz = 0; qz < Q1D; ++qz)
-         {
-            MFEM_UNROLL(MD1)
-            for (int dz = 0; dz < D1D; ++dz)
-            {
-               u[dz] += QDD[qz][dy][dx] * Bt[dz][qz];
-            }
-         }
-         MFEM_UNROLL(MD1)
-         for (int dz = 0; dz < D1D; ++dz)
-         {
-            if (ACCUMULATE)
-            {
-               y(dx,dy,dz,e) += u[dz];
-            }
-            else
-            {
-               y(dx,dy,dz,e) = u[dz];
-            }
-         }
-      }
-   }
-   MFEM_SYNC_THREAD;
-}
-
-} // namespace internal
-
-} // namespace mfem
-
-#endif
diff --git a/fem/bilininteg_transpose_ea.cpp b/fem/bilininteg_transpose_ea.cpp
deleted file mode 100644
index bea53f1b3..000000000
--- a/fem/bilininteg_transpose_ea.cpp
+++ /dev/null
@@ -1,186 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-
-namespace mfem
-{
-
-void TransposeIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                     Vector &ea_data, const bool add)
-{
-   if (add)
-   {
-      Vector ea_data_tmp(ea_data.Size());
-      bfi->AssembleEA(fes, ea_data_tmp, false);
-      const int ne = fes.GetNE();
-      if (ne == 0) { return; }
-      const int dofs = fes.GetFE(0)->GetDof();
-      auto A = Reshape(ea_data_tmp.Read(), dofs, dofs, ne);
-      auto AT = Reshape(ea_data.ReadWrite(), dofs, dofs, ne);
-      mfem::forall(ne, [=] MFEM_HOST_DEVICE (int e)
-      {
-         for (int i = 0; i < dofs; i++)
-         {
-            for (int j = 0; j < dofs; j++)
-            {
-               const double a = A(i, j, e);
-               AT(j, i, e) += a;
-            }
-         }
-      });
-   }
-   else
-   {
-      bfi->AssembleEA(fes, ea_data, false);
-      const int ne = fes.GetNE();
-      if (ne == 0) { return; }
-      const int dofs = fes.GetFE(0)->GetDof();
-      auto A = Reshape(ea_data.ReadWrite(), dofs, dofs, ne);
-      mfem::forall(ne, [=] MFEM_HOST_DEVICE (int e)
-      {
-         for (int i = 0; i < dofs; i++)
-         {
-            for (int j = i+1; j < dofs; j++)
-            {
-               const double aij = A(i, j, e);
-               const double aji = A(j, i, e);
-               A(j, i, e) = aij;
-               A(i, j, e) = aji;
-            }
-         }
-      });
-   }
-}
-
-void TransposeIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
-                                                  Vector &ea_data_int,
-                                                  Vector &ea_data_ext,
-                                                  const bool add)
-{
-   const int nf = fes.GetNFbyType(FaceType::Interior);
-   if (nf == 0) { return; }
-   if (add)
-   {
-      Vector ea_data_int_tmp(ea_data_int.Size());
-      Vector ea_data_ext_tmp(ea_data_ext.Size());
-      bfi->AssembleEAInteriorFaces(fes, ea_data_int_tmp, ea_data_ext_tmp, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_int = Reshape(ea_data_int_tmp.Read(), faceDofs, faceDofs, 2, nf);
-      auto A_ext = Reshape(ea_data_ext_tmp.Read(), faceDofs, faceDofs, 2, nf);
-      auto AT_int = Reshape(ea_data_int.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      auto AT_ext = Reshape(ea_data_ext.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
-      {
-         for (int i = 0; i < faceDofs; i++)
-         {
-            for (int j = 0; j < faceDofs; j++)
-            {
-               const double a_int0 = A_int(i, j, 0, f);
-               const double a_int1 = A_int(i, j, 1, f);
-               const double a_ext0 = A_ext(i, j, 0, f);
-               const double a_ext1 = A_ext(i, j, 1, f);
-               AT_int(j, i, 0, f) += a_int0;
-               AT_int(j, i, 1, f) += a_int1;
-               AT_ext(j, i, 0, f) += a_ext1;
-               AT_ext(j, i, 1, f) += a_ext0;
-            }
-         }
-      });
-   }
-   else
-   {
-      bfi->AssembleEAInteriorFaces(fes, ea_data_int, ea_data_ext, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_int = Reshape(ea_data_int.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      auto A_ext = Reshape(ea_data_ext.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
-      {
-         for (int i = 0; i < faceDofs; i++)
-         {
-            for (int j = i+1; j < faceDofs; j++)
-            {
-               const double aij_int0 = A_int(i, j, 0, f);
-               const double aij_int1 = A_int(i, j, 1, f);
-               const double aji_int0 = A_int(j, i, 0, f);
-               const double aji_int1 = A_int(j, i, 1, f);
-               A_int(j, i, 0, f) = aij_int0;
-               A_int(j, i, 1, f) = aij_int1;
-               A_int(i, j, 0, f) = aji_int0;
-               A_int(i, j, 1, f) = aji_int1;
-            }
-         }
-         for (int i = 0; i < faceDofs; i++)
-         {
-            for (int j = 0; j < faceDofs; j++)
-            {
-               const double aij_ext0 = A_ext(i, j, 0, f);
-               const double aji_ext1 = A_ext(j, i, 1, f);
-               A_ext(j, i, 1, f) = aij_ext0;
-               A_ext(i, j, 0, f) = aji_ext1;
-            }
-         }
-      });
-   }
-}
-
-void TransposeIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace& fes,
-                                                  Vector &ea_data_bdr,
-                                                  const bool add)
-{
-   const int nf = fes.GetNFbyType(FaceType::Boundary);
-   if (nf == 0) { return; }
-   if (add)
-   {
-      Vector ea_data_bdr_tmp(ea_data_bdr.Size());
-      bfi->AssembleEABoundaryFaces(fes, ea_data_bdr_tmp, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_bdr = Reshape(ea_data_bdr_tmp.Read(), faceDofs, faceDofs, nf);
-      auto AT_bdr = Reshape(ea_data_bdr.ReadWrite(), faceDofs, faceDofs, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
-      {
-         for (int i = 0; i < faceDofs; i++)
-         {
-            for (int j = 0; j < faceDofs; j++)
-            {
-               const double a_bdr = A_bdr(i, j, f);
-               AT_bdr(j, i, f) += a_bdr;
-            }
-         }
-      });
-   }
-   else
-   {
-      bfi->AssembleEABoundaryFaces(fes, ea_data_bdr, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_bdr = Reshape(ea_data_bdr.ReadWrite(), faceDofs, faceDofs, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
-      {
-         for (int i = 0; i < faceDofs; i++)
-         {
-            for (int j = i+1; j < faceDofs; j++)
-            {
-               const double aij_bdr = A_bdr(i, j, f);
-               const double aji_bdr = A_bdr(j, i, f);
-               A_bdr(j, i, f) = aij_bdr;
-               A_bdr(i, j, f) = aji_bdr;
-            }
-         }
-      });
-   }
-}
-
-}
diff --git a/fem/bilininteg_vectorfe.cpp b/fem/bilininteg_vectorfe.cpp
deleted file mode 100644
index 4c2180cf5..000000000
--- a/fem/bilininteg_vectorfe.cpp
+++ /dev/null
@@ -1,1144 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "qspace.hpp"
-#include "gridfunc.hpp"
-
-namespace mfem
-{
-
-void PADiffusionSetup3D(const int Q1D,
-                        const int coeffDim,
-                        const int NE,
-                        const Array<double> &w,
-                        const Vector &j,
-                        const Vector &coeff_,
-                        Vector &op);
-
-void PAHcurlMassAssembleDiagonal2D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const bool symmetric,
-                                   const Array<double> &bo,
-                                   const Array<double> &bc,
-                                   const Vector &pa_data,
-                                   Vector &diag);
-
-void PAHcurlMassAssembleDiagonal3D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const bool symmetric,
-                                   const Array<double> &bo,
-                                   const Array<double> &bc,
-                                   const Vector &pa_data,
-                                   Vector &diag);
-
-template<int T_D1D = 0, int T_Q1D = 0>
-void SmemPAHcurlMassAssembleDiagonal3D(const int D1D,
-                                       const int Q1D,
-                                       const int NE,
-                                       const bool symmetric,
-                                       const Array<double> &bo,
-                                       const Array<double> &bc,
-                                       const Vector &pa_data,
-                                       Vector &diag);
-
-void PAHcurlMassApply2D(const int D1D,
-                        const int Q1D,
-                        const int NE,
-                        const bool symmetric,
-                        const Array<double> &bo,
-                        const Array<double> &bc,
-                        const Array<double> &bot,
-                        const Array<double> &bct,
-                        const Vector &pa_data,
-                        const Vector &x,
-                        Vector &y);
-
-void PAHcurlMassApply3D(const int D1D,
-                        const int Q1D,
-                        const int NE,
-                        const bool symmetric,
-                        const Array<double> &bo,
-                        const Array<double> &bc,
-                        const Array<double> &bot,
-                        const Array<double> &bct,
-                        const Vector &pa_data,
-                        const Vector &x,
-                        Vector &y);
-
-template<int T_D1D = 0, int T_Q1D = 0>
-void SmemPAHcurlMassApply3D(const int D1D,
-                            const int Q1D,
-                            const int NE,
-                            const bool symmetric,
-                            const Array<double> &bo,
-                            const Array<double> &bc,
-                            const Array<double> &bot,
-                            const Array<double> &bct,
-                            const Vector &pa_data,
-                            const Vector &x,
-                            Vector &y);
-
-void PAHdivSetup2D(const int Q1D,
-                   const int coeffDim,
-                   const int NE,
-                   const Array<double> &w,
-                   const Vector &j,
-                   Vector &coeff_,
-                   Vector &op);
-
-void PAHdivSetup3D(const int Q1D,
-                   const int coeffDim,
-                   const int NE,
-                   const Array<double> &w,
-                   const Vector &j,
-                   Vector &coeff_,
-                   Vector &op);
-
-void PAHcurlH1Apply2D(const int D1D,
-                      const int Q1D,
-                      const int NE,
-                      const Array<double> &bc,
-                      const Array<double> &gc,
-                      const Array<double> &bot,
-                      const Array<double> &bct,
-                      const Vector &pa_data,
-                      const Vector &x,
-                      Vector &y);
-
-void PAHcurlH1ApplyTranspose2D(const int D1D,
-                               const int Q1D,
-                               const int NE,
-                               const Array<double> &bc,
-                               const Array<double> &bo,
-                               const Array<double> &bct,
-                               const Array<double> &gct,
-                               const Vector &pa_data,
-                               const Vector &x,
-                               Vector &y);
-
-void PAHcurlH1Apply3D(const int D1D,
-                      const int Q1D,
-                      const int NE,
-                      const Array<double> &bc,
-                      const Array<double> &gc,
-                      const Array<double> &bot,
-                      const Array<double> &bct,
-                      const Vector &pa_data,
-                      const Vector &x,
-                      Vector &y);
-
-void PAHcurlH1ApplyTranspose3D(const int D1D,
-                               const int Q1D,
-                               const int NE,
-                               const Array<double> &bc,
-                               const Array<double> &bo,
-                               const Array<double> &bct,
-                               const Array<double> &gct,
-                               const Vector &pa_data,
-                               const Vector &x,
-                               Vector &y);
-
-void PAHdivMassAssembleDiagonal2D(const int D1D,
-                                  const int Q1D,
-                                  const int NE,
-                                  const bool symmetric,
-                                  const Array<double> &Bo_,
-                                  const Array<double> &Bc_,
-                                  const Vector &op_,
-                                  Vector &diag_);
-
-void PAHdivMassAssembleDiagonal3D(const int D1D,
-                                  const int Q1D,
-                                  const int NE,
-                                  const bool symmetric,
-                                  const Array<double> &Bo_,
-                                  const Array<double> &Bc_,
-                                  const Vector &op_,
-                                  Vector &diag_);
-
-void PAHdivMassApply(const int dim,
-                     const int D1D,
-                     const int Q1D,
-                     const int NE,
-                     const bool symmetric,
-                     const Array<double> &Bo,
-                     const Array<double> &Bc,
-                     const Array<double> &Bot,
-                     const Array<double> &Bct,
-                     const Vector &op,
-                     const Vector &x,
-                     Vector &y);
-
-void PAHcurlL2Setup(const int NQ,
-                    const int coeffDim,
-                    const int NE,
-                    const Array<double> &w,
-                    Vector &coeff_,
-                    Vector &op);
-
-// PA H(curl) x H(div) mass assemble 3D kernel, with factor
-// dF^{-1} C dF for a vector or matrix coefficient C.
-// If transpose, use dF^T C dF^{-T} for H(div) x H(curl).
-void PAHcurlHdivSetup3D(const int Q1D,
-                        const int coeffDim,
-                        const int NE,
-                        const bool transpose,
-                        const Array<double> &w_,
-                        const Vector &j,
-                        Vector &coeff_,
-                        Vector &op)
-{
-   const bool symmetric = (coeffDim != 9);
-   auto W = Reshape(w_.Read(), Q1D, Q1D, Q1D);
-   auto J = Reshape(j.Read(), Q1D, Q1D, Q1D, 3, 3, NE);
-   auto coeff = Reshape(coeff_.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
-   auto y = Reshape(op.Write(), 9, Q1D, Q1D, Q1D, NE);
-
-   const int i11 = 0;
-   const int i12 = transpose ? 3 : 1;
-   const int i13 = transpose ? 6 : 2;
-   const int i21 = transpose ? 1 : 3;
-   const int i22 = 4;
-   const int i23 = transpose ? 7 : 5;
-   const int i31 = transpose ? 2 : 6;
-   const int i32 = transpose ? 5 : 7;
-   const int i33 = 8;
-
-   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            MFEM_FOREACH_THREAD(qz,z,Q1D)
-            {
-               const double J11 = J(qx,qy,qz,0,0,e);
-               const double J21 = J(qx,qy,qz,1,0,e);
-               const double J31 = J(qx,qy,qz,2,0,e);
-               const double J12 = J(qx,qy,qz,0,1,e);
-               const double J22 = J(qx,qy,qz,1,1,e);
-               const double J32 = J(qx,qy,qz,2,1,e);
-               const double J13 = J(qx,qy,qz,0,2,e);
-               const double J23 = J(qx,qy,qz,1,2,e);
-               const double J33 = J(qx,qy,qz,2,2,e);
-               const double detJ = J11 * (J22 * J33 - J32 * J23) -
-                                   J21 * (J12 * J33 - J32 * J13) +
-                                   J31 * (J12 * J23 - J22 * J13);
-               const double w_detJ = W(qx,qy,qz) / detJ;
-               // adj(J)
-               const double A11 = (J22 * J33) - (J23 * J32);
-               const double A12 = (J32 * J13) - (J12 * J33);
-               const double A13 = (J12 * J23) - (J22 * J13);
-               const double A21 = (J31 * J23) - (J21 * J33);
-               const double A22 = (J11 * J33) - (J13 * J31);
-               const double A23 = (J21 * J13) - (J11 * J23);
-               const double A31 = (J21 * J32) - (J31 * J22);
-               const double A32 = (J31 * J12) - (J11 * J32);
-               const double A33 = (J11 * J22) - (J12 * J21);
-
-               if (coeffDim == 6 || coeffDim == 9) // Matrix coefficient version
-               {
-                  // First compute entries of R = M^T J
-                  const double M11 = (!symmetric) ? coeff(i11,qx,qy,qz,e) : coeff(0,qx,qy,qz,e);
-                  const double M12 = (!symmetric) ? coeff(i12,qx,qy,qz,e) : coeff(1,qx,qy,qz,e);
-                  const double M13 = (!symmetric) ? coeff(i13,qx,qy,qz,e) : coeff(2,qx,qy,qz,e);
-                  const double M21 = (!symmetric) ? coeff(i21,qx,qy,qz,e) : M12;
-                  const double M22 = (!symmetric) ? coeff(i22,qx,qy,qz,e) : coeff(3,qx,qy,qz,e);
-                  const double M23 = (!symmetric) ? coeff(i23,qx,qy,qz,e) : coeff(4,qx,qy,qz,e);
-                  const double M31 = (!symmetric) ? coeff(i31,qx,qy,qz,e) : M13;
-                  const double M32 = (!symmetric) ? coeff(i32,qx,qy,qz,e) : M23;
-                  const double M33 = (!symmetric) ? coeff(i33,qx,qy,qz,e) : coeff(5,qx,qy,qz,e);
-
-                  const double R11 = M11*J11 + M21*J21 + M31*J31;
-                  const double R12 = M11*J12 + M21*J22 + M31*J32;
-                  const double R13 = M11*J13 + M21*J23 + M31*J33;
-                  const double R21 = M12*J11 + M22*J21 + M32*J31;
-                  const double R22 = M12*J12 + M22*J22 + M32*J32;
-                  const double R23 = M12*J13 + M22*J23 + M32*J33;
-                  const double R31 = M13*J11 + M23*J21 + M33*J31;
-                  const double R32 = M13*J12 + M23*J22 + M33*J32;
-                  const double R33 = M13*J13 + M23*J23 + M33*J33;
-
-                  // y = (J^{-1} M^T J)^T
-                  y(i11,qx,qy,qz,e) = w_detJ * (A11*R11 + A12*R21 + A13*R31); // 1,1
-                  y(i21,qx,qy,qz,e) = w_detJ * (A11*R12 + A12*R22 + A13*R32); // 1,2
-                  y(i31,qx,qy,qz,e) = w_detJ * (A11*R13 + A12*R23 + A13*R33); // 1,3
-                  y(i12,qx,qy,qz,e) = w_detJ * (A21*R11 + A22*R21 + A23*R31); // 2,1
-                  y(i22,qx,qy,qz,e) = w_detJ * (A21*R12 + A22*R22 + A23*R32); // 2,2
-                  y(i32,qx,qy,qz,e) = w_detJ * (A21*R13 + A22*R23 + A23*R33); // 2,3
-                  y(i13,qx,qy,qz,e) = w_detJ * (A31*R11 + A32*R21 + A33*R31); // 3,1
-                  y(i23,qx,qy,qz,e) = w_detJ * (A31*R12 + A32*R22 + A33*R32); // 3,2
-                  y(i33,qx,qy,qz,e) = w_detJ * (A31*R13 + A32*R23 + A33*R33); // 3,3
-               }
-               else if (coeffDim == 3)  // Vector coefficient version
-               {
-                  const double D1 = coeff(0,qx,qy,qz,e);
-                  const double D2 = coeff(1,qx,qy,qz,e);
-                  const double D3 = coeff(2,qx,qy,qz,e);
-                  // detJ J^{-1} DJ = adj(J) DJ
-                  // transpose
-                  y(i11,qx,qy,qz,e) = w_detJ * (D1*A11*J11 + D2*A12*J21 + D3*A13*J31); // 1,1
-                  y(i21,qx,qy,qz,e) = w_detJ * (D1*A11*J12 + D2*A12*J22 + D3*A13*J32); // 1,2
-                  y(i31,qx,qy,qz,e) = w_detJ * (D1*A11*J13 + D2*A12*J23 + D3*A13*J33); // 1,3
-                  y(i12,qx,qy,qz,e) = w_detJ * (D1*A21*J11 + D2*A22*J21 + D3*A23*J31); // 2,1
-                  y(i22,qx,qy,qz,e) = w_detJ * (D1*A21*J12 + D2*A22*J22 + D3*A23*J32); // 2,2
-                  y(i32,qx,qy,qz,e) = w_detJ * (D1*A21*J13 + D2*A22*J23 + D3*A23*J33); // 2,3
-                  y(i13,qx,qy,qz,e) = w_detJ * (D1*A31*J11 + D2*A32*J21 + D3*A33*J31); // 3,1
-                  y(i23,qx,qy,qz,e) = w_detJ * (D1*A31*J12 + D2*A32*J22 + D3*A33*J32); // 3,2
-                  y(i33,qx,qy,qz,e) = w_detJ * (D1*A31*J13 + D2*A32*J23 + D3*A33*J33); // 3,3
-               }
-            }
-         }
-      }
-   });
-}
-
-// PA H(curl) x H(div) mass assemble 2D kernel, with factor
-// dF^{-1} C dF for a vector or matrix coefficient C.
-// If transpose, use dF^T C dF^{-T} for H(div) x H(curl).
-void PAHcurlHdivSetup2D(const int Q1D,
-                        const int coeffDim,
-                        const int NE,
-                        const bool transpose,
-                        const Array<double> &w_,
-                        const Vector &j,
-                        Vector &coeff_,
-                        Vector &op)
-{
-   const bool symmetric = (coeffDim != 4);
-   auto W = Reshape(w_.Read(), Q1D, Q1D);
-   auto J = Reshape(j.Read(), Q1D, Q1D, 2, 2, NE);
-   auto coeff = Reshape(coeff_.Read(), coeffDim, Q1D, Q1D, NE);
-   auto y = Reshape(op.Write(), 4, Q1D, Q1D, NE);
-
-   const int i11 = 0;
-   const int i12 = transpose ? 2 : 1;
-   const int i21 = transpose ? 1 : 2;
-   const int i22 = 3;
-
-   mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
-   {
-      MFEM_FOREACH_THREAD(qx,x,Q1D)
-      {
-         MFEM_FOREACH_THREAD(qy,y,Q1D)
-         {
-            const double J11 = J(qx,qy,0,0,e);
-            const double J21 = J(qx,qy,1,0,e);
-            const double J12 = J(qx,qy,0,1,e);
-            const double J22 = J(qx,qy,1,1,e);
-            const double w_detJ = W(qx,qy) / ((J11*J22) - (J21*J12));
-
-            if (coeffDim == 3 || coeffDim == 4) // Matrix coefficient version
-            {
-               // First compute entries of R = MJ
-               const double M11 = coeff(i11,qx,qy,e);
-               const double M12 = (!symmetric) ? coeff(i12,qx,qy,e) : coeff(1,qx,qy,e);
-               const double M21 = (!symmetric) ? coeff(i21,qx,qy,e) : M12;
-               const double M22 = (!symmetric) ? coeff(i22,qx,qy,e) : coeff(2,qx,qy,e);
-
-               // J^{-1} M^T
-               const double R11 = ( J22*M11 - J12*M12); // 1,1
-               const double R12 = ( J22*M21 - J12*M22); // 1,2
-               const double R21 = (-J21*M11 + J11*M12); // 2,1
-               const double R22 = (-J21*M21 + J11*M22); // 2,2
-
-               // (RJ)^T
-               y(i11,qx,qy,e) = w_detJ * (R11*J11 + R12*J21); // 1,1
-               y(i21,qx,qy,e) = w_detJ * (R11*J12 + R12*J22); // 1,2 (transpose)
-               y(i12,qx,qy,e) = w_detJ * (R21*J11 + R22*J21); // 2,1 (transpose)
-               y(i22,qx,qy,e) = w_detJ * (R21*J12 + R22*J22); // 2,2
-            }
-            else if (coeffDim == 2) // Vector coefficient version
-            {
-               const double D1 = coeff(0,qx,qy,e);
-               const double D2 = coeff(1,qx,qy,e);
-               const double R11 = D1*J11;
-               const double R12 = D1*J12;
-               const double R21 = D2*J21;
-               const double R22 = D2*J22;
-               y(i11,qx,qy,e) = w_detJ * ( J22*R11 - J12*R21); // 1,1
-               y(i21,qx,qy,e) = w_detJ * ( J22*R12 - J12*R22); // 1,2 (transpose)
-               y(i12,qx,qy,e) = w_detJ * (-J21*R11 + J11*R21); // 2,1 (transpose)
-               y(i22,qx,qy,e) = w_detJ * (-J21*R12 + J11*R22); // 2,2
-            }
-         }
-      }
-   });
-}
-
-// Mass operator for H(curl) and H(div) functions, using Piola transformations
-// u = dF^{-T} \hat{u} in H(curl), v = (1 / det dF) dF \hat{v} in H(div).
-void PAHcurlHdivMassApply3D(const int D1D,
-                            const int D1Dtest,
-                            const int Q1D,
-                            const int NE,
-                            const bool scalarCoeff,
-                            const bool trialHcurl,
-                            const bool transpose,
-                            const Array<double> &Bo_,
-                            const Array<double> &Bc_,
-                            const Array<double> &Bot_,
-                            const Array<double> &Bct_,
-                            const Vector &op_,
-                            const Vector &x_,
-                            Vector &y_)
-{
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
-   auto Bot = Reshape(Bot_.Read(), D1Dtest-1, Q1D);
-   auto Bct = Reshape(Bct_.Read(), D1Dtest, Q1D);
-   auto op = Reshape(op_.Read(), scalarCoeff ? 1 : 9, Q1D, Q1D, Q1D, NE);
-   auto x = Reshape(x_.Read(), 3*(D1D-1)*D1D*(trialHcurl ? D1D : D1D-1), NE);
-   auto y = Reshape(y_.ReadWrite(), 3*(D1Dtest-1)*D1Dtest*
-                    (trialHcurl ? D1Dtest-1 : D1Dtest), NE);
-
-   const int i12 = transpose ? 3 : 1;
-   const int i13 = transpose ? 6 : 2;
-   const int i21 = transpose ? 1 : 3;
-   const int i23 = transpose ? 7 : 5;
-   const int i31 = transpose ? 2 : 6;
-   const int i32 = transpose ? 5 : 7;
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int c = 0; c < VDIM; ++c)
-               {
-                  mass[qz][qy][qx][c] = 0.0;
-               }
-            }
-         }
-      }
-
-      int osc = 0;
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z trial components
-      {
-         const int D1Dz = trialHcurl ? ((c == 2) ? D1D - 1 : D1D) :
-                          ((c == 2) ? D1D : D1D - 1);
-         const int D1Dy = trialHcurl ? ((c == 1) ? D1D - 1 : D1D) :
-                          ((c == 1) ? D1D : D1D - 1);
-         const int D1Dx = trialHcurl ? ((c == 0) ? D1D - 1 : D1D) :
-                          ((c == 0) ? D1D : D1D - 1);
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            double massXY[MAX_Q1D][MAX_Q1D];
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massXY[qy][qx] = 0.0;
-               }
-            }
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               double massX[MAX_Q1D];
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] = 0.0;
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  const double t = x(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     massX[qx] += t * (trialHcurl ? ((c == 0) ? Bo(qx,dx) : Bc(qx,dx)) :
-                                       ((c == 0) ? Bc(qx,dx) : Bo(qx,dx)));
-                  }
-               }
-
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = trialHcurl ? ((c == 1) ? Bo(qy,dy) : Bc(qy,dy)) :
-                                    ((c == 1) ? Bc(qy,dy) : Bo(qy,dy));
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = massX[qx];
-                     massXY[qy][qx] += wx * wy;
-                  }
-               }
-            }
-
-            for (int qz = 0; qz < Q1D; ++qz)
-            {
-               const double wz = trialHcurl ? ((c == 2) ? Bo(qz,dz) : Bc(qz,dz)) :
-                                 ((c == 2) ? Bc(qz,dz) : Bo(qz,dz));
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
-                  }
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               const double O11 = op(0,qx,qy,qz,e);
-               const double O12 = scalarCoeff ? 0.0 : op(i12,qx,qy,qz,e);
-               const double O13 = scalarCoeff ? 0.0 : op(i13,qx,qy,qz,e);
-               const double O21 = scalarCoeff ? 0.0 : op(i21,qx,qy,qz,e);
-               const double O22 = scalarCoeff ? O11 : op(4,qx,qy,qz,e);
-               const double O23 = scalarCoeff ? 0.0 : op(i23,qx,qy,qz,e);
-               const double O31 = scalarCoeff ? 0.0 : op(i31,qx,qy,qz,e);
-               const double O32 = scalarCoeff ? 0.0 : op(i32,qx,qy,qz,e);
-               const double O33 = scalarCoeff ? O11 : op(8,qx,qy,qz,e);
-               const double massX = mass[qz][qy][qx][0];
-               const double massY = mass[qz][qy][qx][1];
-               const double massZ = mass[qz][qy][qx][2];
-               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
-               mass[qz][qy][qx][1] = (O21*massX)+(O22*massY)+(O23*massZ);
-               mass[qz][qy][qx][2] = (O31*massX)+(O32*massY)+(O33*massZ);
-            }
-         }
-      }
-
-      for (int qz = 0; qz < Q1D; ++qz)
-      {
-         double massXY[HDIV_MAX_D1D][HDIV_MAX_D1D];
-
-         osc = 0;
-         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z test components
-         {
-            const int D1Dz = trialHcurl ? ((c == 2) ? D1Dtest : D1Dtest - 1) :
-                             ((c == 2) ? D1Dtest - 1 : D1Dtest);
-            const int D1Dy = trialHcurl ? ((c == 1) ? D1Dtest : D1Dtest - 1) :
-                             ((c == 1) ? D1Dtest - 1 : D1Dtest);
-            const int D1Dx = trialHcurl ? ((c == 0) ? D1Dtest : D1Dtest - 1) :
-                             ((c == 0) ? D1Dtest - 1 : D1Dtest);
-
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massXY[dy][dx] = 0.0;
-               }
-            }
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               double massX[HDIV_MAX_D1D];
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] = 0.0;
-               }
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massX[dx] += mass[qz][qy][qx][c] * (trialHcurl ?
-                                                         ((c == 0) ? Bct(dx,qx) : Bot(dx,qx)) :
-                                                         ((c == 0) ? Bot(dx,qx) : Bct(dx,qx)));
-                  }
-               }
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  const double wy = trialHcurl ? ((c == 1) ? Bct(dy,qy) : Bot(dy,qy)) :
-                                    ((c == 1) ? Bot(dy,qy) : Bct(dy,qy));
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     massXY[dy][dx] += massX[dx] * wy;
-                  }
-               }
-            }
-
-            for (int dz = 0; dz < D1Dz; ++dz)
-            {
-               const double wz = trialHcurl ? ((c == 2) ? Bct(dz,qz) : Bot(dz,qz)) :
-                                 ((c == 2) ? Bot(dz,qz) : Bct(dz,qz));
-               for (int dy = 0; dy < D1Dy; ++dy)
-               {
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) +=
-                        massXY[dy][dx] * wz;
-                  }
-               }
-            }
-
-            osc += D1Dx * D1Dy * D1Dz;
-         }  // loop c
-      }  // loop qz
-   }); // end of element loop
-}
-
-// Mass operator for H(curl) and H(div) functions, using Piola transformations
-// u = dF^{-T} \hat{u} in H(curl), v = (1 / det dF) dF \hat{v} in H(div).
-void PAHcurlHdivMassApply2D(const int D1D,
-                            const int D1Dtest,
-                            const int Q1D,
-                            const int NE,
-                            const bool scalarCoeff,
-                            const bool trialHcurl,
-                            const bool transpose,
-                            const Array<double> &Bo_,
-                            const Array<double> &Bc_,
-                            const Array<double> &Bot_,
-                            const Array<double> &Bct_,
-                            const Vector &op_,
-                            const Vector &x_,
-                            Vector &y_)
-{
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
-   constexpr static int VDIM = 2;
-
-   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
-   auto Bot = Reshape(Bot_.Read(), D1Dtest-1, Q1D);
-   auto Bct = Reshape(Bct_.Read(), D1Dtest, Q1D);
-   auto op = Reshape(op_.Read(), scalarCoeff ? 1 : 4, Q1D, Q1D, NE);
-   auto x = Reshape(x_.Read(), 2*(D1D-1)*D1D, NE);
-   auto y = Reshape(y_.ReadWrite(), 2*(D1Dtest-1)*D1Dtest, NE);
-
-   const int i12 = transpose ? 2 : 1;
-   const int i21 = transpose ? 1 : 2;
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double mass[MAX_Q1D][MAX_Q1D][VDIM];
-
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            for (int c = 0; c < VDIM; ++c)
-            {
-               mass[qy][qx][c] = 0.0;
-            }
-         }
-      }
-
-      int osc = 0;
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y trial components
-      {
-         const int D1Dy = trialHcurl ? ((c == 1) ? D1D - 1 : D1D) :
-                          ((c == 1) ? D1D : D1D - 1);
-         const int D1Dx = trialHcurl ? ((c == 0) ? D1D - 1 : D1D) :
-                          ((c == 0) ? D1D : D1D - 1);
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            double massX[MAX_Q1D];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               massX[qx] = 0.0;
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               const double t = x(dx + (dy * D1Dx) + osc, e);
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  massX[qx] += t * (trialHcurl ? ((c == 0) ? Bo(qx,dx) : Bc(qx,dx)) :
-                                    ((c == 0) ? Bc(qx,dx) : Bo(qx,dx)));
-               }
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const double wy = trialHcurl ? ((c == 1) ? Bo(qy,dy) : Bc(qy,dy)) :
-                                 ((c == 1) ? Bc(qy,dy) : Bo(qy,dy));
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  mass[qy][qx][c] += massX[qx] * wy;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop (c) over components
-
-      // Apply D operator.
-      for (int qy = 0; qy < Q1D; ++qy)
-      {
-         for (int qx = 0; qx < Q1D; ++qx)
-         {
-            const double O11 = op(0,qx,qy,e);
-            const double O12 = scalarCoeff ? 0.0 : op(i12,qx,qy,e);
-            const double O21 = scalarCoeff ? 0.0 : op(i21,qx,qy,e);
-            const double O22 = scalarCoeff ? O11 : op(3,qx,qy,e);
-            const double massX = mass[qy][qx][0];
-            const double massY = mass[qy][qx][1];
-            mass[qy][qx][0] = (O11*massX)+(O12*massY);
-            mass[qy][qx][1] = (O21*massX)+(O22*massY);
-         }
-      }
-
-      osc = 0;
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y test components
-      {
-         const int D1Dy = trialHcurl ? ((c == 1) ? D1Dtest : D1Dtest - 1) :
-                          ((c == 1) ? D1Dtest - 1 : D1Dtest);
-         const int D1Dx = trialHcurl ? ((c == 0) ? D1Dtest : D1Dtest - 1) :
-                          ((c == 0) ? D1Dtest - 1 : D1Dtest);
-
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            double massX[HDIV_MAX_D1D];
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               massX[dx] = 0.0;
-            }
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  massX[dx] += mass[qy][qx][c] * (trialHcurl ?
-                                                  ((c == 0) ? Bct(dx,qx) : Bot(dx,qx)) :
-                                                  ((c == 0) ? Bot(dx,qx) : Bct(dx,qx)));
-               }
-            }
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               const double wy = trialHcurl ? ((c == 1) ? Bct(dy,qy) : Bot(dy,qy)) :
-                                 ((c == 1) ? Bot(dy,qy) : Bct(dy,qy));
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  y(dx + (dy * D1Dx) + osc, e) += massX[dx] * wy;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop c
-   }); // end of element loop
-}
-
-void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
-{
-   AssemblePA(fes, fes);
-}
-
-void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                        const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements
-   Mesh *mesh = trial_fes.GetMesh();
-
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const VectorTensorFiniteElement *trial_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-   nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   ne = trial_fes.GetNE();
-   MFEM_VERIFY(ne == test_fes.GetNE(),
-               "Different meshes for test and trial spaces");
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &trial_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   mapsCtest = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsOtest = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1Dtest = mapsCtest->ndof;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   trial_fetype = trial_el->GetDerivType();
-   test_fetype = test_el->GetDerivType();
-
-   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
-   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
-   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
-   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(qs, CoefficientStorage::SYMMETRIC);
-   if (Q) { coeff.Project(*Q); }
-   else if (MQ) { coeff.ProjectTranspose(*MQ); }
-   else if (DQ) { coeff.Project(*DQ); }
-   else { coeff.SetConstant(1.0); }
-
-   const int coeff_dim = coeff.GetVDim();
-   symmetric = (coeff_dim != dim*dim);
-
-   if ((trial_curl && test_div) || (trial_div && test_curl))
-      pa_data.SetSize((coeff_dim == 1 ? 1 : dim*dim) * nq * ne,
-                      Device::GetMemoryType());
-   else
-      pa_data.SetSize((symmetric ? symmDims : dims*dims) * nq * ne,
-                      Device::GetMemoryType());
-
-   if (trial_curl && test_curl && dim == 3)
-   {
-      PADiffusionSetup3D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
-                         coeff, pa_data);
-   }
-   else if (trial_curl && test_curl && dim == 2)
-   {
-      PADiffusionSetup2D<2>(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
-                            coeff, pa_data);
-   }
-   else if (trial_div && test_div && dim == 3)
-   {
-      PAHdivSetup3D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
-                    coeff, pa_data);
-   }
-   else if (trial_div && test_div && dim == 2)
-   {
-      PAHdivSetup2D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
-                    coeff, pa_data);
-   }
-   else if (((trial_curl && test_div) || (trial_div && test_curl)) &&
-            test_fel->GetOrder() == trial_fel->GetOrder())
-   {
-      if (coeff_dim == 1)
-      {
-         PAHcurlL2Setup(nq, coeff_dim, ne, ir->GetWeights(), coeff, pa_data);
-      }
-      else
-      {
-         const bool tr = (trial_div && test_curl);
-         if (dim == 3)
-            PAHcurlHdivSetup3D(quad1D, coeff_dim, ne, tr, ir->GetWeights(),
-                               geom->J, coeff, pa_data);
-         else
-            PAHcurlHdivSetup2D(quad1D, coeff_dim, ne, tr, ir->GetWeights(),
-                               geom->J, coeff, pa_data);
-      }
-   }
-   else
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
-}
-
-void VectorFEMassIntegrator::AssembleDiagonalPA(Vector& diag)
-{
-   if (dim == 3)
-   {
-      if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
-      {
-         if (Device::Allows(Backend::DEVICE_MASK))
-         {
-            const int ID = (dofs1D << 4) | quad1D;
-            switch (ID)
-            {
-               case 0x23: return SmemPAHcurlMassAssembleDiagonal3D<2,3>(dofs1D, quad1D, ne,
-                                                                           symmetric,
-                                                                           mapsO->B, mapsC->B, pa_data, diag);
-               case 0x34: return SmemPAHcurlMassAssembleDiagonal3D<3,4>(dofs1D, quad1D, ne,
-                                                                           symmetric,
-                                                                           mapsO->B, mapsC->B, pa_data, diag);
-               case 0x45: return SmemPAHcurlMassAssembleDiagonal3D<4,5>(dofs1D, quad1D, ne,
-                                                                           symmetric,
-                                                                           mapsO->B, mapsC->B, pa_data, diag);
-               case 0x56: return SmemPAHcurlMassAssembleDiagonal3D<5,6>(dofs1D, quad1D, ne,
-                                                                           symmetric,
-                                                                           mapsO->B, mapsC->B, pa_data, diag);
-               default: return SmemPAHcurlMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
-                                                                    mapsO->B, mapsC->B, pa_data, diag);
-            }
-         }
-         else
-            PAHcurlMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
-                                          mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else if (trial_fetype == mfem::FiniteElement::DIV &&
-               test_fetype == trial_fetype)
-      {
-         PAHdivMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
-                                      mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
-      }
-   }
-   else // 2D
-   {
-      if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
-      {
-         PAHcurlMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
-                                       mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else if (trial_fetype == mfem::FiniteElement::DIV &&
-               test_fetype == trial_fetype)
-      {
-         PAHdivMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
-                                      mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
-      }
-   }
-}
-
-void VectorFEMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
-   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
-   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
-   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
-
-   if (dim == 3)
-   {
-      if (trial_curl && test_curl)
-      {
-         if (Device::Allows(Backend::DEVICE_MASK))
-         {
-            const int ID = (dofs1D << 4) | quad1D;
-            switch (ID)
-            {
-               case 0x23: return SmemPAHcurlMassApply3D<2,3>(dofs1D, quad1D, ne, symmetric,
-                                                                mapsO->B,
-                                                                mapsC->B, mapsO->Bt,
-                                                                mapsC->Bt, pa_data, x, y);
-               case 0x34: return SmemPAHcurlMassApply3D<3,4>(dofs1D, quad1D, ne, symmetric,
-                                                                mapsO->B,
-                                                                mapsC->B, mapsO->Bt,
-                                                                mapsC->Bt, pa_data, x, y);
-               case 0x45: return SmemPAHcurlMassApply3D<4,5>(dofs1D, quad1D, ne, symmetric,
-                                                                mapsO->B,
-                                                                mapsC->B, mapsO->Bt,
-                                                                mapsC->Bt, pa_data, x, y);
-               case 0x56: return SmemPAHcurlMassApply3D<5,6>(dofs1D, quad1D, ne, symmetric,
-                                                                mapsO->B,
-                                                                mapsC->B, mapsO->Bt,
-                                                                mapsC->Bt, pa_data, x, y);
-               default: return SmemPAHcurlMassApply3D(dofs1D, quad1D, ne, symmetric, mapsO->B,
-                                                         mapsC->B,
-                                                         mapsO->Bt, mapsC->Bt, pa_data, x, y);
-            }
-         }
-         else
-            PAHcurlMassApply3D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B, mapsO->Bt,
-                               mapsC->Bt, pa_data, x, y);
-      }
-      else if (trial_div && test_div)
-      {
-         PAHdivMassApply(3, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B, mapsO->Bt,
-                         mapsC->Bt, pa_data, x, y);
-      }
-      else if (trial_curl && test_div)
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                true, false, mapsO->B, mapsC->B, mapsOtest->Bt,
-                                mapsCtest->Bt, pa_data, x, y);
-      }
-      else if (trial_div && test_curl)
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                false, false, mapsO->B, mapsC->B, mapsOtest->Bt,
-                                mapsCtest->Bt, pa_data, x, y);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
-      }
-   }
-   else // 2D
-   {
-      if (trial_curl && test_curl)
-      {
-         PAHcurlMassApply2D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
-                            mapsO->Bt, mapsC->Bt, pa_data, x, y);
-      }
-      else if (trial_div && test_div)
-      {
-         PAHdivMassApply(2, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B, mapsO->Bt,
-                         mapsC->Bt, pa_data, x, y);
-      }
-      else if ((trial_curl && test_div) || (trial_div && test_curl))
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                trial_curl, false, mapsO->B, mapsC->B,
-                                mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
-      }
-   }
-}
-
-void VectorFEMassIntegrator::AddMultTransposePA(const Vector &x,
-                                                Vector &y) const
-{
-   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
-   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
-   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
-   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
-
-   bool symmetricSpaces = true;
-
-   if (dim == 3 && ((trial_div && test_curl) || (trial_curl && test_div)))
-   {
-      const bool scalarCoeff = !(DQ || MQ);
-      PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                             trial_div, true, mapsO->B, mapsC->B, mapsOtest->Bt,
-                             mapsCtest->Bt, pa_data, x, y);
-      symmetricSpaces = false;
-   }
-   else if (dim == 2 && ((trial_curl && test_div) || (trial_div && test_curl)))
-   {
-      const bool scalarCoeff = !(DQ || MQ);
-      PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                             !trial_curl, true, mapsO->B, mapsC->B, mapsOtest->Bt,
-                             mapsCtest->Bt, pa_data, x, y);
-      symmetricSpaces = false;
-   }
-
-   if (symmetricSpaces)
-   {
-      if (MQ && dynamic_cast<SymmetricMatrixCoefficient*>(MQ) == NULL)
-      {
-         MFEM_ABORT("VectorFEMassIntegrator transpose not implemented for asymmetric MatrixCoefficient");
-      }
-
-      this->AddMultPA(x, y);
-   }
-}
-
-void MixedVectorGradientIntegrator::AssemblePA(const FiniteElementSpace
-                                               &trial_fes,
-                                               const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
-
-   ne = trial_fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   pa_data.SetSize(symmDims * nq * ne, Device::GetMemoryType());
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
-
-   // Use the same setup functions as VectorFEMassIntegrator.
-   if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 3)
-   {
-      PADiffusionSetup3D(quad1D, 1, ne, ir->GetWeights(), geom->J,
-                         coeff, pa_data);
-   }
-   else if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 2)
-   {
-      PADiffusionSetup2D<2>(quad1D, 1, ne, ir->GetWeights(), geom->J,
-                            coeff, pa_data);
-   }
-   else
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
-}
-
-void MixedVectorGradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-      PAHcurlH1Apply3D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
-                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
-   else if (dim == 2)
-      PAHcurlH1Apply2D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
-                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-void MixedVectorGradientIntegrator::AddMultTransposePA(const Vector &x,
-                                                       Vector &y) const
-{
-   if (dim == 3)
-      PAHcurlH1ApplyTranspose3D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
-                                mapsC->Bt, mapsC->Gt, pa_data, x, y);
-   else if (dim == 2)
-      PAHcurlH1ApplyTranspose2D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
-                                mapsC->Bt, mapsC->Gt, pa_data, x, y);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-} // namespace mfem
diff --git a/fem/ceed/interface/operator.cpp b/fem/ceed/interface/operator.cpp
index 8545ccaa8..745e474e5 100644
--- a/fem/ceed/interface/operator.cpp
+++ b/fem/ceed/interface/operator.cpp
@@ -46,7 +46,7 @@ void Operator::Mult(const mfem::Vector &x, mfem::Vector &y) const
    CeedScalar *y_ptr;
    CeedMemType mem;
    CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       x_ptr = x.Read();
       y_ptr = y.Write();
@@ -78,7 +78,7 @@ void Operator::AddMult(const mfem::Vector &x, mfem::Vector &y,
    CeedScalar *y_ptr;
    CeedMemType mem;
    CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       x_ptr = x.Read();
       y_ptr = y.ReadWrite();
@@ -107,7 +107,7 @@ void Operator::GetDiagonal(mfem::Vector &diag) const
    CeedScalar *d_ptr;
    CeedMemType mem;
    CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       d_ptr = diag.ReadWrite();
    }
diff --git a/fem/ceed/interface/operator.hpp b/fem/ceed/interface/operator.hpp
index cffea2fc7..9e4a4faaf 100644
--- a/fem/ceed/interface/operator.hpp
+++ b/fem/ceed/interface/operator.hpp
@@ -37,11 +37,12 @@ public:
    /// This class takes ownership of op and will delete it
    Operator(CeedOperator op);
 #endif
+
    void Mult(const mfem::Vector &x, mfem::Vector &y) const override;
    void AddMult(const mfem::Vector &x, mfem::Vector &y,
                 const double a = 1.0) const override;
    void GetDiagonal(mfem::Vector &diag) const;
-   using mfem::Operator::SetupRAP;
+
    virtual ~Operator()
    {
 #ifdef MFEM_USE_CEED
diff --git a/fem/ceed/interface/util.cpp b/fem/ceed/interface/util.cpp
index d122c2ab5..b65fd2197 100644
--- a/fem/ceed/interface/util.cpp
+++ b/fem/ceed/interface/util.cpp
@@ -217,7 +217,7 @@ const IntegrationRule & GetRule<ConvectionIntegrator>(
    const FiniteElement &test_fe,
    ElementTransformation &trans)
 {
-   return ConvectionIntegrator::GetRule(trial_fe, test_fe, trans);
+   return ConvectionIntegrator::GetRule(trial_fe, trans);
 }
 
 template <>
diff --git a/fem/ceed/solvers/algebraic.cpp b/fem/ceed/solvers/algebraic.cpp
index 2cc325dbc..280a19960 100644
--- a/fem/ceed/solvers/algebraic.cpp
+++ b/fem/ceed/solvers/algebraic.cpp
@@ -46,7 +46,7 @@ private:
    Array<int> ess_tdofs;
    const mfem::Operator *P;
    ceed::Operator *unconstrained_op;
-   mfem::ConstrainedOperator *constrained_op;
+   mfem::Operator *constrained_op;
 };
 
 ConstrainedOperator::ConstrainedOperator(
@@ -56,10 +56,8 @@ ConstrainedOperator::ConstrainedOperator(
    : ess_tdofs(ess_tdofs_), P(P_)
 {
    unconstrained_op = new ceed::Operator(oper);
-   mfem::Operator *rap = unconstrained_op->SetupRAP(P, P);
-   height = width = rap->Height();
-   bool own_rap = (rap != unconstrained_op);
-   constrained_op = new mfem::ConstrainedOperator(rap, ess_tdofs, own_rap);
+   unconstrained_op->FormSystemOperator(ess_tdofs, constrained_op);
+   height = width = constrained_op->Height();
 }
 
 ConstrainedOperator::ConstrainedOperator(CeedOperator oper,
@@ -535,7 +533,7 @@ void AlgebraicInterpolation::Mult(const mfem::Vector& x, mfem::Vector& y) const
    CeedScalar *out_ptr;
    CeedMemType mem;
    ierr = CeedGetPreferredMemType(internal::ceed, &mem); PCeedChk(ierr);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       in_ptr = x.Read();
       out_ptr = y.ReadWrite();
@@ -568,7 +566,7 @@ void AlgebraicInterpolation::MultTranspose(const mfem::Vector& x,
    ierr = CeedGetPreferredMemType(internal::ceed, &mem); PCeedChk(ierr);
    const CeedScalar *in_ptr;
    CeedScalar *out_ptr;
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       in_ptr = x.Read();
       out_ptr = y.ReadWrite();
@@ -808,15 +806,6 @@ ParAlgebraicCoarseSpace::ParAlgebraicCoarseSpace(
       }
    }
    R_mat->Finalize();
-
-   if (Device::Allows(Backend::DEVICE_MASK))
-   {
-      P = new DeviceConformingProlongationOperator(*gc, R_mat);
-   }
-   else
-   {
-      P = new ConformingProlongationOperator(lsize, *gc);
-   }
    P_mat = NULL;
 }
 
@@ -828,8 +817,8 @@ HypreParMatrix *ParAlgebraicCoarseSpace::GetProlongationHypreParMatrix()
    MFEM_VERIFY(pmesh != NULL, "");
    Array<HYPRE_BigInt> dof_offsets, tdof_offsets, tdof_nb_offsets;
    Array<HYPRE_BigInt> *offsets[2] = {&dof_offsets, &tdof_offsets};
-   int lsize = P->Height();
-   int ltsize = P->Width();
+   int ltsize = R_mat->Height();
+   int lsize = R_mat->Width();
    HYPRE_BigInt loc_sizes[2] = {lsize, ltsize};
    pmesh->GenerateOffsets(2, loc_sizes, offsets);
 
@@ -936,7 +925,6 @@ HypreParMatrix *ParAlgebraicCoarseSpace::GetProlongationHypreParMatrix()
 
 ParAlgebraicCoarseSpace::~ParAlgebraicCoarseSpace()
 {
-   delete P;
    delete R_mat;
    delete P_mat;
    delete gc;
diff --git a/fem/ceed/solvers/algebraic.hpp b/fem/ceed/solvers/algebraic.hpp
index 49cdbca98..8ede8324e 100644
--- a/fem/ceed/solvers/algebraic.hpp
+++ b/fem/ceed/solvers/algebraic.hpp
@@ -33,12 +33,13 @@ class AlgebraicCoarseSpace : public FiniteElementSpace
 public:
    AlgebraicCoarseSpace(FiniteElementSpace &fine_fes, CeedElemRestriction fine_er,
                         int order, int dim, int order_reduction_);
+   ~AlgebraicCoarseSpace();
+
    int GetOrderReduction() const { return order_reduction; }
    CeedElemRestriction GetCeedElemRestriction() const { return ceed_elem_restriction; }
    CeedBasis GetCeedCoarseToFine() const { return coarse_to_fine; }
    virtual const mfem::Operator *GetProlongationMatrix() const override { return NULL; }
    virtual const SparseMatrix *GetRestrictionMatrix() const override { return NULL; }
-   ~AlgebraicCoarseSpace();
 
 protected:
    int *dof_map;
@@ -64,16 +65,16 @@ public:
       int order_reduction_,
       GroupCommunicator *gc_fine
    );
-   virtual const mfem::Operator *GetProlongationMatrix() const override { return P; }
+   ~ParAlgebraicCoarseSpace();
+
+   virtual const mfem::Operator *GetProlongationMatrix() const override { return P_mat; }
    virtual const SparseMatrix *GetRestrictionMatrix() const override { return R_mat; }
    GroupCommunicator *GetGroupCommunicator() const { return gc; }
    HypreParMatrix *GetProlongationHypreParMatrix();
-   ~ParAlgebraicCoarseSpace();
 
 private:
-   SparseMatrix *R_mat;
    GroupCommunicator *gc;
-   ConformingProlongationOperator *P;
+   SparseMatrix *R_mat;
    HypreParMatrix *P_mat;
    Array<int> ldof_group, ldof_ltdof;
 };
@@ -92,14 +93,11 @@ public:
       Ceed ceed, CeedBasis basisctof,
       CeedElemRestriction erestrictu_coarse,
       CeedElemRestriction erestrictu_fine);
-
    ~AlgebraicInterpolation();
 
    virtual void Mult(const mfem::Vector& x, mfem::Vector& y) const;
-
    virtual void MultTranspose(const mfem::Vector& x, mfem::Vector& y) const;
 
-   using mfem::Operator::SetupRAP;
 private:
    int Initialize(Ceed ceed, CeedBasis basisctof,
                   CeedElemRestriction erestrictu_coarse,
@@ -127,11 +125,6 @@ public:
        The given space is a real (geometric) space, but the coarse spaces are
        constructed semi-algebraically with no mesh information. */
    AlgebraicSpaceHierarchy(FiniteElementSpace &fespace);
-   AlgebraicCoarseSpace& GetAlgebraicCoarseSpace(int level)
-   {
-      MFEM_ASSERT(level < GetNumLevels() - 1, "");
-      return static_cast<AlgebraicCoarseSpace&>(*fespaces[level]);
-   }
    ~AlgebraicSpaceHierarchy()
    {
       for (int i=0; i<R_tr.Size(); ++i)
@@ -144,6 +137,12 @@ public:
       }
    }
 
+   AlgebraicCoarseSpace& GetAlgebraicCoarseSpace(int level)
+   {
+      MFEM_ASSERT(level < GetNumLevels() - 1, "");
+      return static_cast<AlgebraicCoarseSpace&>(*fespaces[level]);
+   }
+
 private:
    CeedElemRestriction fine_er;
    Array<AlgebraicInterpolation*> ceed_interpolations;
@@ -200,6 +199,7 @@ public:
     */
    AlgebraicSolver(BilinearForm &form, const Array<int>& ess_tdofs);
    ~AlgebraicSolver();
+
    void Mult(const Vector& x, Vector& y) const;
    void SetOperator(const mfem::Operator& op);
 };
diff --git a/fem/coefficient.cpp b/fem/coefficient.cpp
index 46ad4cf4c..e47073e3f 100644
--- a/fem/coefficient.cpp
+++ b/fem/coefficient.cpp
@@ -144,8 +144,8 @@ double FunctionCoefficient::Eval(ElementTransformation & T,
    }
 }
 
-double GridFunctionCoefficient::Eval (ElementTransformation &T,
-                                      const IntegrationPoint &ip)
+double GridFunctionCoefficient::Eval(ElementTransformation &T,
+                                     const IntegrationPoint &ip)
 {
    Mesh *gf_mesh = GridF->FESpace()->GetMesh();
    if (T.mesh == gf_mesh)
@@ -623,12 +623,6 @@ void PWMatrixCoefficient::UpdateCoefficient(int attr, MatrixCoefficient & coef)
    MFEM_VERIFY(coef.GetWidth() == width,
                "PWMatrixCoefficient::UpdateCoefficient:  "
                "MatrixCoefficient has incompatible width.");
-   if (symmetric)
-   {
-      MFEM_VERIFY(coef.IsSymmetric(),
-                  "PWMatrixCoefficient::UpdateCoefficient:  "
-                  "MatrixCoefficient has incompatible symmetry.");
-   }
    pieces[attr] = &coef;
 }
 
@@ -680,68 +674,17 @@ void MatrixFunctionCoefficient::Eval(DenseMatrix &K, ElementTransformation &T,
 
    K.SetSize(height, width);
 
-   if (symmetric) // Use SymmFunction (deprecated version)
-   {
-      MFEM_VERIFY(height == width && SymmFunction,
-                  "MatrixFunctionCoefficient is not symmetric");
-
-      Vector Ksym((width * (width + 1)) / 2); // 1x1: 1, 2x2: 3, 3x3: 6
-
-      SymmFunction(transip, Ksym);
-
-      // Copy upper triangular values from Ksym to the full matrix K
-      int os = 0;
-      for (int i=0; i<height; ++i)
-      {
-         for (int j=i; j<width; ++j)
-         {
-            const double Kij = Ksym[j - i + os];
-            K(i,j) = Kij;
-            if (j != i) { K(j,i) = Kij; }
-         }
-
-         os += width - i;
-      }
-   }
-   else
+   if (Function)
    {
-      if (Function)
-      {
-         Function(transip, K);
-      }
-      else if (TDFunction)
-      {
-         TDFunction(transip, GetTime(), K);
-      }
-      else
-      {
-         K = mat;
-      }
+      Function(transip, K);
    }
-
-   if (Q)
+   else if (TDFunction)
    {
-      K *= Q->Eval(T, ip, GetTime());
+      TDFunction(transip, GetTime(), K);
    }
-}
-
-void MatrixFunctionCoefficient::EvalSymmetric(Vector &K,
-                                              ElementTransformation &T,
-                                              const IntegrationPoint &ip)
-{
-   MFEM_VERIFY(symmetric && height == width && SymmFunction,
-               "MatrixFunctionCoefficient is not symmetric");
-
-   double x[3];
-   Vector transip(x, 3);
-
-   T.Transform(ip, transip);
-
-   K.SetSize((width * (width + 1)) / 2); // 1x1: 1, 2x2: 3, 3x3: 6
-
-   if (SymmFunction)
+   else
    {
-      SymmFunction(transip, K);
+      K = mat;
    }
 
    if (Q)
@@ -782,7 +725,7 @@ void SymmetricMatrixCoefficient::Eval(DenseMatrix &K, ElementTransformation &T,
    Eval(mat, T, ip);
    for (int j = 0; j < width; ++j)
    {
-      for (int i = 0; i < height; ++ i)
+      for (int i = 0; i < height; ++i)
       {
          K(i, j) = mat(i, j);
       }
@@ -1782,3 +1725,4 @@ CoefficientVector::~CoefficientVector()
 }
 
 }
+
diff --git a/fem/coefficient.hpp b/fem/coefficient.hpp
index ada5b91a3..fc54fd2ef 100644
--- a/fem/coefficient.hpp
+++ b/fem/coefficient.hpp
@@ -106,7 +106,6 @@ private:
    Vector constants;
 
 public:
-
    /// Constructs a piecewise constant coefficient in NumOfSubD subdomains
    explicit PWConstCoefficient(int NumOfSubD = 0) : constants(NumOfSubD)
    { constants = 0.0; }
@@ -177,7 +176,6 @@ private:
                 const Array<Coefficient*> & coefs);
 
 public:
-
    /// Constructs a piecewise coefficient
    explicit PWCoefficient() {}
 
@@ -340,7 +338,6 @@ protected:
    double (*tdf)(double);
 
 public:
-
    /// Construct a unit delta function centered at (0.0,0.0,0.0)
    DeltaCoefficient()
    {
@@ -503,15 +500,16 @@ class VectorConstantCoefficient : public VectorCoefficient
 {
 private:
    Vector vec;
+
 public:
    /// Construct the coefficient with constant vector @a v.
    VectorConstantCoefficient(const Vector &v)
       : VectorCoefficient(v.Size()), vec(v) { }
-   using VectorCoefficient::Eval;
 
    ///  Evaluate the vector coefficient at @a ip.
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip) { V = vec; }
+   using VectorCoefficient::Eval;
 
    /// Return a reference to the constant vector in this class.
    const Vector& GetVec() const { return vec; }
@@ -561,7 +559,6 @@ private:
                 const Array<VectorCoefficient*> & coefs);
 
 public:
-
    /// Constructs a piecewise vector coefficient of dimension vd
    explicit PWVectorCoefficient(int vd): VectorCoefficient(vd) {}
 
@@ -629,10 +626,10 @@ public:
       : VectorCoefficient(dim), TDFunction(std::move(TDF)), Q(q)
    { }
 
-   using VectorCoefficient::Eval;
    /// Evaluate the vector coefficient at @a ip.
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    virtual ~VectorFunctionCoefficient() { }
 };
@@ -669,11 +666,11 @@ public:
    double Eval(int i, ElementTransformation &T, const IntegrationPoint &ip)
    { return Coeff[i] ? Coeff[i]->Eval(T, ip, GetTime()) : 0.0; }
 
-   using VectorCoefficient::Eval;
    /** @brief Evaluate the coefficient. Each element of vector V comes from the
        associated array of scalar coefficients. */
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    /// Destroys vector coefficient.
    virtual ~VectorArrayCoefficient();
@@ -728,7 +725,6 @@ protected:
    const GridFunction *GridFunc;
 
 public:
-
    /** @brief Construct the coefficient with a scalar grid function @a gf. The
        grid function is not owned by the coefficient. */
    GradientGridFunctionCoefficient(const GridFunction *gf);
@@ -769,10 +765,10 @@ public:
    /// Get the vector grid function.
    const GridFunction * GetGridFunction() const { return GridFunc; }
 
-   using VectorCoefficient::Eval;
    /// Evaluate the vector curl coefficient at @a ip.
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    virtual ~CurlGridFunctionCoefficient() { }
 };
@@ -861,12 +857,13 @@ public:
    virtual void EvalDelta(Vector &V, ElementTransformation &T,
                           const IntegrationPoint &ip);
 
-   using VectorCoefficient::Eval;
    /** @brief A VectorDeltaFunction cannot be evaluated. Calling this method
        will cause an MFEM error, terminating the application. */
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip)
    { mfem_error("VectorDeltaCoefficient::Eval"); }
+   using VectorCoefficient::Eval;
+
    virtual ~VectorDeltaCoefficient() { }
 };
 
@@ -908,16 +905,15 @@ class MatrixCoefficient
 protected:
    int height, width;
    double time;
-   bool symmetric;  // deprecated
 
 public:
    /// Construct a dim x dim matrix coefficient.
-   explicit MatrixCoefficient(int dim, bool symm=false)
-   { height = width = dim; time = 0.; symmetric = symm; }
+   explicit MatrixCoefficient(int dim)
+   { height = width = dim; time = 0.; }
 
    /// Construct a h x w matrix coefficient.
-   MatrixCoefficient(int h, int w, bool symm=false) :
-      height(h), width(w), time(0.), symmetric(symm) { }
+   MatrixCoefficient(int h, int w) :
+      height(h), width(w), time(0.) { }
 
    /// Set the time for time dependent coefficients
    virtual void SetTime(double t) { time = t; }
@@ -934,9 +930,6 @@ public:
    /// For backward compatibility get the width of the matrix.
    int GetVDim() const { return width; }
 
-   /** @deprecated Use SymmetricMatrixCoefficient instead */
-   bool IsSymmetric() const { return symmetric; }
-
    /** @brief Evaluate the matrix coefficient in the element described by @a T
        at the point @a ip, storing the result in @a K. */
    /** @note When this method is called, the caller must make sure that the
@@ -953,17 +946,6 @@ public:
    /// the width of the matrix.
    virtual void Project(QuadratureFunction &qf, bool transpose=false);
 
-   /// (DEPRECATED) Evaluate a symmetric matrix coefficient.
-   /** @brief Evaluate the upper triangular entries of the matrix coefficient
-       in the symmetric case, similarly to Eval. Matrix entry (i,j) is stored
-       in K[j - i + os_i] for 0 <= i <= j < width, os_0 = 0,
-       os_{i+1} = os_i + width - i. That is, K = {M(0,0), ..., M(0,w-1),
-       M(1,1), ..., M(1,w-1), ..., M(w-1,w-1) with w = width.
-       @deprecated Use Eval() instead. */
-   virtual void EvalSymmetric(Vector &K, ElementTransformation &T,
-                              const IntegrationPoint &ip)
-   { mfem_error("MatrixCoefficient::EvalSymmetric"); }
-
    virtual ~MatrixCoefficient() { }
 };
 
@@ -973,14 +955,17 @@ class MatrixConstantCoefficient : public MatrixCoefficient
 {
 private:
    DenseMatrix mat;
+
 public:
    ///Construct using matrix @a m for the constant.
    MatrixConstantCoefficient(const DenseMatrix &m)
       : MatrixCoefficient(m.Height(), m.Width()), mat(m) { }
-   using MatrixCoefficient::Eval;
+
    /// Evaluate the matrix coefficient at @a ip.
    virtual void Eval(DenseMatrix &M, ElementTransformation &T,
                      const IntegrationPoint &ip) { M = mat; }
+   using MatrixCoefficient::Eval;
+
    /// Return a reference to the constant matrix.
    const DenseMatrix& GetMatrix() { return mat; }
 };
@@ -1030,20 +1015,18 @@ private:
                 const Array<MatrixCoefficient*> & coefs);
 
 public:
-
    /// Constructs a piecewise matrix coefficient of dimension dim by dim
-   explicit PWMatrixCoefficient(int dim, bool symm = false)
-      : MatrixCoefficient(dim, symm) {}
+   explicit PWMatrixCoefficient(int dim)
+      : MatrixCoefficient(dim) {}
 
    /// Constructs a piecewise matrix coefficient of dimension h by w
-   explicit PWMatrixCoefficient(int h, int w, bool symm = false)
-      : MatrixCoefficient(h, w, symm) {}
+   explicit PWMatrixCoefficient(int h, int w)
+      : MatrixCoefficient(h, w) {}
 
    /// Construct the coefficient using arrays describing the pieces
    /** \param dim - size of the square matrix-valued result
        \param attr - an array of attribute numbers for each piece
        \param coefs - the corresponding array of MatrixCoefficient pointers
-       \param symm - true if the result will be symmetric, false otherwise
        Any missing attributes or NULL coefficient pointers will result in a
        zero matrix being returned.
 
@@ -1051,16 +1034,14 @@ public:
        transferred to this object.
    */
    PWMatrixCoefficient(int dim, const Array<int> & attr,
-                       const Array<MatrixCoefficient*> & coefs,
-                       bool symm=false)
-      : MatrixCoefficient(dim, symm) { InitMap(attr, coefs); }
+                       const Array<MatrixCoefficient*> & coefs)
+      : MatrixCoefficient(dim) { InitMap(attr, coefs); }
 
    /// Construct the coefficient using arrays describing the pieces
    /** \param h - height of the matrix-valued result
        \param w - width of the matrix-valued result
        \param attr - an array of attribute numbers for each piece
        \param coefs - the corresponding array of MatrixCoefficient pointers
-       \param symm - true if the result will be symmetric, false otherwise
        Any missing attributes or NULL coefficient pointers will result in a
        zero matrix being returned for that attribute.
 
@@ -1068,9 +1049,8 @@ public:
        transferred to this object.
    */
    PWMatrixCoefficient(int h, int w, const Array<int> & attr,
-                       const Array<MatrixCoefficient*> & coefs,
-                       bool symm=false)
-      : MatrixCoefficient(h, w, symm) { InitMap(attr, coefs); }
+                       const Array<MatrixCoefficient*> & coefs)
+      : MatrixCoefficient(h, w) { InitMap(attr, coefs); }
 
    /// Set the time for time dependent coefficients
    virtual void SetTime(double t);
@@ -1099,7 +1079,6 @@ class MatrixFunctionCoefficient : public MatrixCoefficient
 {
 private:
    std::function<void(const Vector &, DenseMatrix &)> Function;
-   std::function<void(const Vector &, Vector &)> SymmFunction;  // deprecated
    std::function<void(const Vector &, double, DenseMatrix &)> TDFunction;
 
    Coefficient *Q;
@@ -1123,28 +1102,6 @@ public:
       : MatrixCoefficient(m.Height(), m.Width()), Q(&q), mat(m)
    { }
 
-   /** @brief Define a time-independent symmetric square matrix coefficient from
-       a std function */
-   /** \param dim - the size of the matrix
-       \param SymmF - function used in EvalSymmetric
-       \param q - optional scalar Coefficient to scale the matrix coefficient
-       @deprecated Use another constructor without setting SymmFunction. */
-   MatrixFunctionCoefficient(int dim,
-                             std::function<void(const Vector &, Vector &)> SymmF,
-                             Coefficient *q = NULL)
-      : MatrixCoefficient(dim, true), SymmFunction(std::move(SymmF)), Q(q), mat(0)
-   { }
-
-   /// Define a time-dependent square matrix coefficient from a std function
-   /** \param dim - the size of the matrix
-       \param TDF - time-dependent function
-       \param q - optional scalar Coefficient to scale the matrix coefficient */
-   MatrixFunctionCoefficient(int dim,
-                             std::function<void(const Vector &, double, DenseMatrix &)> TDF,
-                             Coefficient *q = nullptr)
-      : MatrixCoefficient(dim), TDFunction(std::move(TDF)), Q(q)
-   { }
-
    /// Set the time for internally stored coefficients
    void SetTime(double t);
 
@@ -1152,11 +1109,6 @@ public:
    virtual void Eval(DenseMatrix &K, ElementTransformation &T,
                      const IntegrationPoint &ip);
 
-   /// (DEPRECATED) Evaluate the symmetric matrix coefficient at @a ip.
-   /** @deprecated Use Eval() instead. */
-   virtual void EvalSymmetric(Vector &K, ElementTransformation &T,
-                              const IntegrationPoint &ip);
-
    virtual ~MatrixFunctionCoefficient() { }
 };
 
@@ -1186,12 +1138,11 @@ public:
        can be overridden with the @a own parameter. */
    void Set(int i, int j, Coefficient * c, bool own=true);
 
-   using MatrixCoefficient::Eval;
-
    /// Evaluate coefficient located at (i,j) in the matrix using integration
    /// point @a ip.
    double Eval(int i, int j, ElementTransformation &T, const IntegrationPoint &ip)
    { return Coeff[i*width+j] ? Coeff[i*width+j] -> Eval(T, ip, GetTime()) : 0.0; }
+   using MatrixCoefficient::Eval;
 
    /// Evaluate the matrix coefficient @a ip.
    virtual void Eval(DenseMatrix &K, ElementTransformation &T,
@@ -1294,10 +1245,11 @@ class SymmetricMatrixCoefficient : public MatrixCoefficient
 protected:
    /// Internal matrix used when evaluating this coefficient as a DenseMatrix.
    DenseSymmetricMatrix mat;
+
 public:
    /// Construct a dim x dim matrix coefficient.
    explicit SymmetricMatrixCoefficient(int dimension)
-      : MatrixCoefficient(dimension, true) { }
+      : MatrixCoefficient(dimension) { }
 
    /// Get the size of the matrix.
    int GetSize() const { return height; }
@@ -1347,10 +1299,11 @@ public:
    ///Construct using matrix @a m for the constant.
    SymmetricMatrixConstantCoefficient(const DenseSymmetricMatrix &m)
       : SymmetricMatrixCoefficient(m.Height()), mat(m) { }
-   using SymmetricMatrixCoefficient::Eval;
+
    /// Evaluate the matrix coefficient at @a ip.
    virtual void Eval(DenseSymmetricMatrix &M, ElementTransformation &T,
                      const IntegrationPoint &ip) { M = mat; }
+   using SymmetricMatrixCoefficient::Eval;
 };
 
 
@@ -1398,10 +1351,10 @@ public:
    /// Set the time for internally stored coefficients
    void SetTime(double t);
 
-   using SymmetricMatrixCoefficient::Eval;
    /// Evaluate the matrix coefficient at @a ip.
    virtual void Eval(DenseSymmetricMatrix &K, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using SymmetricMatrixCoefficient::Eval;
 
    virtual ~SymmetricMatrixFunctionCoefficient() { }
 };
@@ -1548,6 +1501,7 @@ private:
 
    mutable Vector va;
    mutable Vector vb;
+
 public:
    /// Construct with the two vector coefficients.  Result is \f$ A \cdot B \f$.
    InnerProductCoefficient(VectorCoefficient &A, VectorCoefficient &B);
@@ -2120,9 +2074,9 @@ public:
 
    const QuadratureFunction& GetQuadFunction() const { return QuadF; }
 
-   using VectorCoefficient::Eval;
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    virtual void Project(QuadratureFunction &qf);
 
@@ -2186,6 +2140,7 @@ protected:
    int vdim; ///< Number of values per quadrature point.
    QuadratureSpaceBase &qs; ///< Associated QuadratureSpaceBase.
    QuadratureFunction *qf; ///< Internal QuadratureFunction (owned, may be NULL).
+
 public:
    /// Create an empty CoefficientVector.
    CoefficientVector(QuadratureSpaceBase &qs_,
@@ -2287,3 +2242,4 @@ double ComputeGlobalLpNorm(double p, VectorCoefficient &coeff, ParMesh &pmesh,
 }
 
 #endif
+
diff --git a/fem/dgmassinv.cpp b/fem/dgmassinv.cpp
index 88774b3ad..3cff5d05d 100644
--- a/fem/dgmassinv.cpp
+++ b/fem/dgmassinv.cpp
@@ -107,7 +107,7 @@ void DGMassInverse::Update()
 {
    M->Assemble();
    M->AssembleDiagonal(diag_inv);
-   internal::MakeReciprocal(diag_inv.Size(), diag_inv.ReadWrite());
+   diag_inv.Reciprocal();
 }
 
 DGMassInverse::~DGMassInverse()
diff --git a/fem/dgmassinv_kernels.hpp b/fem/dgmassinv_kernels.hpp
index c497621d4..e78a9bc98 100644
--- a/fem/dgmassinv_kernels.hpp
+++ b/fem/dgmassinv_kernels.hpp
@@ -12,9 +12,9 @@
 #ifndef MFEM_DGMASSINV_KERNELS_HPP
 #define MFEM_DGMASSINV_KERNELS_HPP
 
-#include "bilininteg_mass_pa.hpp"
 #include "../linalg/kernels.hpp"
 #include "kernels.hpp"
+#include "integ/bilininteg_mass_kernels.hpp"
 
 namespace mfem
 {
@@ -22,11 +22,6 @@ namespace mfem
 namespace internal
 {
 
-void MakeReciprocal(int n, double *x)
-{
-   mfem::forall(n, [=] MFEM_HOST_DEVICE (int i) { x[i] = 1.0/x[i]; });
-}
-
 template <int DIM, int D1D, int Q1D>
 MFEM_HOST_DEVICE inline
 void DGMassApply(const int e,
diff --git a/fem/fespace.cpp b/fem/fespace.cpp
index 29a1aa980..cb82c6008 100644
--- a/fem/fespace.cpp
+++ b/fem/fespace.cpp
@@ -428,15 +428,6 @@ void FiniteElementSpace::BuildFaceToDofTable() const
    face_dof = fc_dof;
 }
 
-void FiniteElementSpace::RebuildElementToDofTable()
-{
-   delete elem_dof;
-   delete elem_fos;
-   elem_dof = NULL;
-   elem_fos = NULL;
-   BuildElementToDofTable();
-}
-
 void FiniteElementSpace::ReorderElementToDofTable()
 {
    Array<int> dof_marker(ndofs);
@@ -1256,7 +1247,7 @@ int FiniteElementSpace::GetNConformingDofs() const
    return P ? (P->Width() / vdim) : ndofs;
 }
 
-const ElementRestrictionOperator *FiniteElementSpace::GetElementRestriction(
+const ElementRestriction *FiniteElementSpace::GetElementRestriction(
    ElementDofOrdering e_ordering) const
 {
    // Check if we have a discontinuous space using the FE collection:
@@ -1271,22 +1262,22 @@ const ElementRestrictionOperator *FiniteElementSpace::GetElementRestriction(
          // The output E-vector layout is: ND x VDIM x NE.
          L2E_nat.Reset(new L2ElementRestriction(*this));
       }
-      return L2E_nat.Is<ElementRestrictionOperator>();
+      return L2E_nat.Is<ElementRestriction>();
    }
    if (e_ordering == ElementDofOrdering::LEXICOGRAPHIC)
    {
       if (L2E_lex.Ptr() == NULL)
       {
-         L2E_lex.Reset(new ElementRestriction(*this, e_ordering));
+         L2E_lex.Reset(new ConformingElementRestriction(*this, e_ordering));
       }
-      return L2E_lex.Is<ElementRestrictionOperator>();
+      return L2E_lex.Is<ElementRestriction>();
    }
    // e_ordering == ElementDofOrdering::NATIVE
    if (L2E_nat.Ptr() == NULL)
    {
-      L2E_nat.Reset(new ElementRestriction(*this, e_ordering));
+      L2E_nat.Reset(new ConformingElementRestriction(*this, e_ordering));
    }
-   return L2E_nat.Is<ElementRestrictionOperator>();
+   return L2E_nat.Is<ElementRestriction>();
 }
 
 const FaceRestriction *FiniteElementSpace::GetFaceRestriction(
diff --git a/fem/fespace.hpp b/fem/fespace.hpp
index f777bf871..00b290c09 100644
--- a/fem/fespace.hpp
+++ b/fem/fespace.hpp
@@ -602,18 +602,6 @@ public:
    virtual const Operator *GetProlongationMatrix() const
    { return GetConformingProlongation(); }
 
-   /// Return an operator that performs the transpose of GetRestrictionOperator
-   /** The returned operator is owned by the FiniteElementSpace. In serial this
-       is the same as GetProlongationMatrix() */
-   virtual const Operator *GetRestrictionTransposeOperator() const
-   { return GetConformingProlongation(); }
-
-   /// An abstract operator that performs the same action as GetRestrictionMatrix
-   /** In some cases this is an optimized matrix-free implementation. The
-       returned operator is owned by the FiniteElementSpace. */
-   virtual const Operator *GetRestrictionOperator() const
-   { return GetConformingRestriction(); }
-
    /// The returned SparseMatrix is owned by the FiniteElementSpace.
    virtual const SparseMatrix *GetRestrictionMatrix() const
    { return GetConformingRestriction(); }
@@ -639,7 +627,7 @@ public:
        L2ElementRestriction class.
 
        The returned Operator is owned by the FiniteElementSpace. */
-   const ElementRestrictionOperator *GetElementRestriction(
+   const ElementRestriction *GetElementRestriction(
       ElementDofOrdering e_ordering) const;
 
    /// Return an Operator that converts L-vectors to E-vectors on each face.
@@ -1058,9 +1046,6 @@ public:
    void GetEdgeInteriorVDofs(int i, Array<int> &vdofs) const;
    /// @}
 
-   /// (@deprecated) Use the Update() method if the space or mesh changed.
-   MFEM_DEPRECATED void RebuildElementToDofTable();
-
    /** @brief Reorder the scalar DOFs based on the element ordering.
 
        The new ordering is constructed as follows: 1) loop over all elements as
diff --git a/fem/bilininteg_br2.cpp b/fem/integ/bilininteg_br2.cpp
similarity index 99%
rename from fem/bilininteg_br2.cpp
rename to fem/integ/bilininteg_br2.cpp
index dba87a8b5..159947029 100644
--- a/fem/bilininteg_br2.cpp
+++ b/fem/integ/bilininteg_br2.cpp
@@ -9,8 +9,8 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "bilininteg.hpp"
-#include "pfespace.hpp"
+#include "../bilininteg.hpp"
+#include "../pfespace.hpp"
 #include <algorithm>
 
 namespace mfem
diff --git a/fem/bilininteg_convection_ea.cpp b/fem/integ/bilininteg_convection_ea.cpp
similarity index 85%
rename from fem/bilininteg_convection_ea.cpp
rename to fem/integ/bilininteg_convection_ea.cpp
index 52e3b4e81..08422ce86 100644
--- a/fem/bilininteg_convection_ea.cpp
+++ b/fem/integ/bilininteg_convection_ea.cpp
@@ -9,9 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
 
 namespace mfem
 {
@@ -22,7 +22,6 @@ static void EAConvectionAssemble1D(const int NE,
                                    const Array<double> &g,
                                    const Vector &padata,
                                    Vector &eadata,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -55,14 +54,7 @@ static void EAConvectionAssemble1D(const int NE,
             {
                val += r_Bj[k1] * D(k1, e) * r_Gi[k1];
             }
-            if (add)
-            {
-               A(i1, j1, e) += val;
-            }
-            else
-            {
-               A(i1, j1, e) = val;
-            }
+            A(i1, j1, e) += val;
          }
       }
    });
@@ -74,7 +66,6 @@ static void EAConvectionAssemble2D(const int NE,
                                    const Array<double> &g,
                                    const Vector &padata,
                                    Vector &eadata,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -130,14 +121,7 @@ static void EAConvectionAssemble2D(const int NE,
                                * r_B[k1][j1]* r_B[k2][j2];
                      }
                   }
-                  if (add)
-                  {
-                     A(i1, i2, j1, j2, e) += val;
-                  }
-                  else
-                  {
-                     A(i1, i2, j1, j2, e) = val;
-                  }
+                  A(i1, i2, j1, j2, e) += val;
                }
             }
          }
@@ -151,7 +135,6 @@ static void EAConvectionAssemble3D(const int NE,
                                    const Array<double> &g,
                                    const Vector &padata,
                                    Vector &eadata,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -208,14 +191,7 @@ static void EAConvectionAssemble3D(const int NE,
                               }
                            }
                         }
-                        if (add)
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) += val;
-                        }
-                        else
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) = val;
-                        }
+                        A(i1, i2, i3, j1, j2, j3, e) += val;
                      }
                   }
                }
@@ -226,8 +202,7 @@ static void EAConvectionAssemble3D(const int NE,
 }
 
 void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                      Vector &ea_data,
-                                      const bool add)
+                                      Vector &ea_data)
 {
    AssemblePA(fes);
    ne = fes.GetMesh()->GetNE();
@@ -237,15 +212,15 @@ void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAConvectionAssemble1D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EAConvectionAssemble1D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EAConvectionAssemble1D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EAConvectionAssemble1D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EAConvectionAssemble1D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EAConvectionAssemble1D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EAConvectionAssemble1D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EAConvectionAssemble1D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EAConvectionAssemble1D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EAConvectionAssemble1D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EAConvectionAssemble1D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EAConvectionAssemble1D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EAConvectionAssemble1D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EAConvectionAssemble1D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EAConvectionAssemble1D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EAConvectionAssemble1D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EAConvectionAssemble1D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EAConvectionAssemble1D(ne,B,G,pa_data,ea_data,
                                                      dofs1D,quad1D);
       }
    }
@@ -253,15 +228,15 @@ void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAConvectionAssemble2D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EAConvectionAssemble2D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EAConvectionAssemble2D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EAConvectionAssemble2D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EAConvectionAssemble2D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EAConvectionAssemble2D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EAConvectionAssemble2D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EAConvectionAssemble2D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EAConvectionAssemble2D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EAConvectionAssemble2D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EAConvectionAssemble2D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EAConvectionAssemble2D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EAConvectionAssemble2D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EAConvectionAssemble2D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EAConvectionAssemble2D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EAConvectionAssemble2D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EAConvectionAssemble2D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EAConvectionAssemble2D(ne,B,G,pa_data,ea_data,
                                                      dofs1D,quad1D);
       }
    }
@@ -269,14 +244,14 @@ void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EAConvectionAssemble3D<2,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x34: return EAConvectionAssemble3D<3,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x45: return EAConvectionAssemble3D<4,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x56: return EAConvectionAssemble3D<5,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x67: return EAConvectionAssemble3D<6,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x78: return EAConvectionAssemble3D<7,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x89: return EAConvectionAssemble3D<8,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EAConvectionAssemble3D(ne,B,G,pa_data,ea_data,add,
+         case 0x23: return EAConvectionAssemble3D<2,3>(ne,B,G,pa_data,ea_data);
+         case 0x34: return EAConvectionAssemble3D<3,4>(ne,B,G,pa_data,ea_data);
+         case 0x45: return EAConvectionAssemble3D<4,5>(ne,B,G,pa_data,ea_data);
+         case 0x56: return EAConvectionAssemble3D<5,6>(ne,B,G,pa_data,ea_data);
+         case 0x67: return EAConvectionAssemble3D<6,7>(ne,B,G,pa_data,ea_data);
+         case 0x78: return EAConvectionAssemble3D<7,8>(ne,B,G,pa_data,ea_data);
+         case 0x89: return EAConvectionAssemble3D<8,9>(ne,B,G,pa_data,ea_data);
+         default:   return EAConvectionAssemble3D(ne,B,G,pa_data,ea_data,
                                                      dofs1D,quad1D);
       }
    }
diff --git a/fem/bilininteg_convection_mf.cpp b/fem/integ/bilininteg_convection_mf.cpp
similarity index 92%
rename from fem/bilininteg_convection_mf.cpp
rename to fem/integ/bilininteg_convection_mf.cpp
index 61520c135..bbaf82788 100644
--- a/fem/bilininteg_convection_mf.cpp
+++ b/fem/integ/bilininteg_convection_mf.cpp
@@ -9,12 +9,10 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "ceed/integrators/convection/convection.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/convection/convection.hpp"
 
 namespace mfem
 {
diff --git a/fem/bilininteg_convection_pa.cpp b/fem/integ/bilininteg_convection_pa.cpp
similarity index 90%
rename from fem/bilininteg_convection_pa.cpp
rename to fem/integ/bilininteg_convection_pa.cpp
index 48080ecdf..25928f002 100644
--- a/fem/bilininteg_convection_pa.cpp
+++ b/fem/integ/bilininteg_convection_pa.cpp
@@ -9,18 +9,15 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qfunction.hpp"
-#include "ceed/integrators/convection/convection.hpp"
-#include "quadinterpolator.hpp"
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../ceed/integrators/convection/convection.hpp"
 
 namespace mfem
 {
 
-// PA Convection Integrator
-
 // PA Convection Assemble 2D kernel
 static void PAConvectionSetup2D(const int NQ,
                                 const int NE,
@@ -115,38 +112,85 @@ static void PAConvectionSetup3D(const int NQ,
    });
 }
 
-static void PAConvectionSetup(const int dim,
-                              const int NQ,
-                              const int NE,
-                              const Array<double> &W,
-                              const Vector &J,
-                              const Vector &coeff,
-                              const double alpha,
-                              Vector &op)
+void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PAConvectionSetup"); }
-   if (dim == 2)
+   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
+                         Device::GetDeviceMemoryType() : pa_mt;
+   // Assumes tensor-product elements
+   Mesh *mesh = fes.GetMesh();
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &Trans = *fes.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
+   if (DeviceCanUseCeed())
    {
-      PAConvectionSetup2D(NQ, NE, W, J, coeff, alpha, op);
+      delete ceedOp;
+      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
+                         fes.IsVariableOrder();
+      if (mixed)
+      {
+         ceedOp = new ceed::MixedPAConvectionIntegrator(*this, fes, Q, alpha);
+      }
+      else
+      {
+         ceedOp = new ceed::PAConvectionIntegrator(fes, *ir, Q, alpha);
+      }
+      return;
    }
-   if (dim == 3)
+   const int dims = el.GetDim();
+   const int symmDims = dims;
+   nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   ne = fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS, mt);
+   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
+   dofs1D = maps->ndof;
+   quad1D = maps->nqpt;
+   pa_data.SetSize(symmDims * nq * ne, mt);
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector vel(*Q, qs, CoefficientStorage::COMPRESSED);
+
+   if (dim == 1)
    {
-      PAConvectionSetup3D(NQ, NE, W, J, coeff, alpha, op);
+      MFEM_ABORT("dim==1 not supported in ConvectionIntegrator::AssemblePA");
+   }
+   else if (dim == 2)
+   {
+      PAConvectionSetup2D(nq, ne, ir->GetWeights(), geom->J,
+                          vel, alpha, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PAConvectionSetup3D(nq, ne, ir->GetWeights(), geom->J,
+                          vel, alpha, pa_data);
+   }
+}
+
+void ConvectionIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
+   {
+      MFEM_ABORT("AssembleDiagonalPA not yet implemented for"
+                 " ConvectionIntegrator.");
    }
 }
 
 // PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApply2D(const int ne,
-                         const Array<double> &b,
-                         const Array<double> &g,
-                         const Array<double> &bt,
-                         const Array<double> &gt,
-                         const Vector &op_,
-                         const Vector &x_,
-                         Vector &y_,
-                         const int d1d = 0,
-                         const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApply2D(const int ne,
+                                const Array<double> &b,
+                                const Array<double> &g,
+                                const Array<double> &bt,
+                                const Array<double> &gt,
+                                const Vector &op_,
+                                const Vector &x_,
+                                Vector &y_,
+                                const int d1d = 0,
+                                const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -255,17 +299,17 @@ void PAConvectionApply2D(const int ne,
 }
 
 // Optimized PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPAConvectionApply2D(const int ne,
-                             const Array<double> &b,
-                             const Array<double> &g,
-                             const Array<double> &bt,
-                             const Array<double> &gt,
-                             const Vector &op_,
-                             const Vector &x_,
-                             Vector &y_,
-                             const int d1d = 0,
-                             const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPAConvectionApply2D(const int ne,
+                                    const Array<double> &b,
+                                    const Array<double> &g,
+                                    const Array<double> &bt,
+                                    const Array<double> &gt,
+                                    const Vector &op_,
+                                    const Vector &x_,
+                                    Vector &y_,
+                                    const int d1d = 0,
+                                    const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -383,17 +427,17 @@ void SmemPAConvectionApply2D(const int ne,
 }
 
 // PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApply3D(const int ne,
-                         const Array<double> &b,
-                         const Array<double> &g,
-                         const Array<double> &bt,
-                         const Array<double> &gt,
-                         const Vector &op_,
-                         const Vector &x_,
-                         Vector &y_,
-                         const int d1d = 0,
-                         const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApply3D(const int ne,
+                                const Array<double> &b,
+                                const Array<double> &g,
+                                const Array<double> &bt,
+                                const Array<double> &gt,
+                                const Vector &op_,
+                                const Vector &x_,
+                                Vector &y_,
+                                const int d1d = 0,
+                                const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -564,17 +608,17 @@ void PAConvectionApply3D(const int ne,
 }
 
 // Optimized PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void SmemPAConvectionApply3D(const int ne,
-                             const Array<double> &b,
-                             const Array<double> &g,
-                             const Array<double> &bt,
-                             const Array<double> &gt,
-                             const Vector &op_,
-                             const Vector &x_,
-                             Vector &y_,
-                             const int d1d = 0,
-                             const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void SmemPAConvectionApply3D(const int ne,
+                                    const Array<double> &b,
+                                    const Array<double> &g,
+                                    const Array<double> &bt,
+                                    const Array<double> &gt,
+                                    const Vector &op_,
+                                    const Vector &x_,
+                                    Vector &y_,
+                                    const int d1d = 0,
+                                    const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -768,17 +812,17 @@ void SmemPAConvectionApply3D(const int ne,
 }
 
 // PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApplyT2D(const int ne,
-                          const Array<double> &b,
-                          const Array<double> &g,
-                          const Array<double> &bt,
-                          const Array<double> &gt,
-                          const Vector &op_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApplyT2D(const int ne,
+                                 const Array<double> &b,
+                                 const Array<double> &g,
+                                 const Array<double> &bt,
+                                 const Array<double> &gt,
+                                 const Vector &op_,
+                                 const Vector &x_,
+                                 Vector &y_,
+                                 const int d1d = 0,
+                                 const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -883,17 +927,17 @@ void PAConvectionApplyT2D(const int ne,
 }
 
 // Optimized PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPAConvectionApplyT2D(const int ne,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &op_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPAConvectionApplyT2D(const int ne,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &op_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     const int d1d = 0,
+                                     const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -1006,17 +1050,17 @@ void SmemPAConvectionApplyT2D(const int ne,
 }
 
 // PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApplyT3D(const int ne,
-                          const Array<double> &b,
-                          const Array<double> &g,
-                          const Array<double> &bt,
-                          const Array<double> &gt,
-                          const Vector &op_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApplyT3D(const int ne,
+                                 const Array<double> &b,
+                                 const Array<double> &g,
+                                 const Array<double> &bt,
+                                 const Array<double> &gt,
+                                 const Vector &op_,
+                                 const Vector &x_,
+                                 Vector &y_,
+                                 const int d1d = 0,
+                                 const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -1182,17 +1226,17 @@ void PAConvectionApplyT3D(const int ne,
 }
 
 // Optimized PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void SmemPAConvectionApplyT3D(const int ne,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &op_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void SmemPAConvectionApplyT3D(const int ne,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &op_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     const int d1d = 0,
+                                     const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -1375,48 +1419,6 @@ void SmemPAConvectionApplyT3D(const int ne,
    });
 }
 
-void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
-{
-   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
-                         Device::GetDeviceMemoryType() : pa_mt;
-   // Assumes tensor-product elements
-   Mesh *mesh = fes.GetMesh();
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &Trans = *fes.GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
-   if (DeviceCanUseCeed())
-   {
-      delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAConvectionIntegrator(*this, fes, Q, alpha);
-      }
-      else
-      {
-         ceedOp = new ceed::PAConvectionIntegrator(fes, *ir, Q, alpha);
-      }
-      return;
-   }
-   const int dims = el.GetDim();
-   const int symmDims = dims;
-   nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   ne = fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS, mt);
-   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
-   dofs1D = maps->ndof;
-   quad1D = maps->nqpt;
-   pa_data.SetSize(symmDims * nq * ne, mt);
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector vel(*Q, qs, CoefficientStorage::COMPRESSED);
-
-   PAConvectionSetup(dim, nq, ne, ir->GetWeights(), geom->J,
-                     vel, alpha, pa_data);
-}
-
 static void PAConvectionApply(const int dim,
                               const int D1D,
                               const int Q1D,
@@ -1521,7 +1523,6 @@ static void PAConvectionApplyT(const int dim,
    MFEM_ABORT("Unknown kernel.");
 }
 
-// PA Convection Apply kernel
 void ConvectionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
@@ -1536,12 +1537,11 @@ void ConvectionIntegrator::AddMultPA(const Vector &x, Vector &y) const
    }
 }
 
-// PA Convection Apply transpose kernel
 void ConvectionIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      MFEM_ABORT("AddMultPA not yet implemented with libCEED for"
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
                  " ConvectionIntegrator.");
    }
    else
@@ -1552,17 +1552,4 @@ void ConvectionIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
    }
 }
 
-void ConvectionIntegrator::AssembleDiagonalPA(Vector &diag)
-{
-   if (DeviceCanUseCeed())
-   {
-      ceedOp->GetDiagonal(diag);
-   }
-   else
-   {
-      MFEM_ABORT("AssembleDiagonalPA not yet implemented for"
-                 " ConvectionIntegrator.");
-   }
-}
-
 } // namespace mfem
diff --git a/fem/integ/bilininteg_curlcurl_pa.cpp b/fem/integ/bilininteg_curlcurl_pa.cpp
new file mode 100644
index 000000000..3d12d978a
--- /dev/null
+++ b/fem/integ/bilininteg_curlcurl_pa.cpp
@@ -0,0 +1,208 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "bilininteg_hcurl_kernels.hpp"
+
+namespace mfem
+{
+
+void CurlCurlIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   // Assumes tensor-product elements
+   Mesh *mesh = fes.GetMesh();
+   const FiniteElement *fel = fes.GetFE(0);
+
+   const VectorTensorFiniteElement *el =
+      dynamic_cast<const VectorTensorFiniteElement*>(fel);
+   MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const IntegrationRule *ir
+      = IntRule ? IntRule : &MassIntegrator::GetRule(*el, *el,
+                                                     *mesh->GetElementTransformation(0));
+
+   const int dims = el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   ne = fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(qs, CoefficientStorage::SYMMETRIC);
+   if (Q) { coeff.Project(*Q); }
+   else if (MQ) { coeff.ProjectTranspose(*MQ); }
+   else if (DQ) { coeff.Project(*DQ); }
+   else { coeff.SetConstant(1.0); }
+
+   const int coeff_dim = coeff.GetVDim();
+   symmetric = (coeff_dim != dim*dim);
+   const int sym_dims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+   const int ndata = (dim == 2) ? 1 : (symmetric ? sym_dims : dim*dim);
+   pa_data.SetSize(ndata * nq * ne, Device::GetMemoryType());
+
+   if (el->GetDerivType() != mfem::FiniteElement::CURL)
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+
+   if (dim == 3)
+   {
+      internal::PACurlCurlSetup3D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
+                                  coeff, pa_data);
+   }
+   else
+   {
+      internal::PACurlCurlSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff,
+                                  pa_data);
+   }
+}
+
+void CurlCurlIntegrator::AssembleDiagonalPA(Vector& diag)
+{
+   if (dim == 3)
+   {
+      if (Device::Allows(Backend::DEVICE_MASK))
+      {
+         const int ID = (dofs1D << 4) | quad1D;
+         switch (ID)
+         {
+            case 0x23:
+               return internal::SmemPACurlCurlAssembleDiagonal3D<2,3>(
+                         dofs1D,
+                         quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B,
+                         mapsO->G, mapsC->G,
+                         pa_data, diag);
+            case 0x34:
+               return internal::SmemPACurlCurlAssembleDiagonal3D<3,4>(
+                         dofs1D,
+                         quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B,
+                         mapsO->G, mapsC->G,
+                         pa_data, diag);
+            case 0x45:
+               return internal::SmemPACurlCurlAssembleDiagonal3D<4,5>(
+                         dofs1D,
+                         quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B,
+                         mapsO->G, mapsC->G,
+                         pa_data, diag);
+            case 0x56:
+               return internal::SmemPACurlCurlAssembleDiagonal3D<5,6>(
+                         dofs1D,
+                         quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B,
+                         mapsO->G, mapsC->G,
+                         pa_data, diag);
+            default:
+               return internal::SmemPACurlCurlAssembleDiagonal3D(
+                         dofs1D, quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B,
+                         mapsO->G, mapsC->G,
+                         pa_data, diag);
+         }
+      }
+      else
+      {
+         internal::PACurlCurlAssembleDiagonal3D(dofs1D, quad1D, symmetric, ne,
+                                                mapsO->B, mapsC->B,
+                                                mapsO->G, mapsC->G,
+                                                pa_data, diag);
+      }
+   }
+   else if (dim == 2)
+   {
+      internal::PACurlCurlAssembleDiagonal2D(dofs1D, quad1D, ne,
+                                             mapsO->B, mapsC->G, pa_data, diag);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+void CurlCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+   {
+      if (Device::Allows(Backend::DEVICE_MASK))
+      {
+         const int ID = (dofs1D << 4) | quad1D;
+         switch (ID)
+         {
+            case 0x23:
+               return internal::SmemPACurlCurlApply3D<2,3>(
+                         dofs1D, quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                         mapsC->G, mapsC->Gt, pa_data, x, y);
+            case 0x34:
+               return internal::SmemPACurlCurlApply3D<3,4>(
+                         dofs1D, quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                         mapsC->G, mapsC->Gt, pa_data, x, y);
+            case 0x45:
+               return internal::SmemPACurlCurlApply3D<4,5>(
+                         dofs1D, quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                         mapsC->G, mapsC->Gt, pa_data, x, y);
+            case 0x56:
+               return internal::SmemPACurlCurlApply3D<5,6>(
+                         dofs1D, quad1D,
+                         symmetric, ne,
+                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                         mapsC->G, mapsC->Gt, pa_data, x, y);
+            default:
+               return internal::SmemPACurlCurlApply3D(
+                         dofs1D, quad1D, symmetric, ne,
+                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                         mapsC->G, mapsC->Gt, pa_data, x, y);
+         }
+      }
+      else
+      {
+         internal::PACurlCurlApply3D(dofs1D, quad1D, symmetric, ne, mapsO->B, mapsC->B,
+                                     mapsO->Bt, mapsC->Bt, mapsC->G, mapsC->Gt,
+                                     pa_data, x, y);
+      }
+   }
+   else if (dim == 2)
+   {
+      internal::PACurlCurlApply2D(dofs1D, quad1D, ne, mapsO->B, mapsO->Bt,
+                                  mapsC->G, mapsC->Gt, pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/bilininteg_dgtrace_ea.cpp b/fem/integ/bilininteg_dgtrace_ea.cpp
similarity index 75%
rename from fem/bilininteg_dgtrace_ea.cpp
rename to fem/integ/bilininteg_dgtrace_ea.cpp
index c40d2ff46..602c266ab 100644
--- a/fem/bilininteg_dgtrace_ea.cpp
+++ b/fem/integ/bilininteg_dgtrace_ea.cpp
@@ -9,9 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
 
 namespace mfem
 {
@@ -20,8 +20,7 @@ static void EADGTraceAssemble1DInt(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
                                    Vector &eadata_int,
-                                   Vector &eadata_ext,
-                                   const bool add)
+                                   Vector &eadata_ext)
 {
    auto D = Reshape(padata.Read(), 2, 2, NF);
    auto A_int = Reshape(eadata_int.ReadWrite(), 2, NF);
@@ -33,41 +32,23 @@ static void EADGTraceAssemble1DInt(const int NF,
       val_ext10 = D(1, 0, f);
       val_ext01 = D(0, 1, f);
       val_int1  = D(1, 1, f);
-      if (add)
-      {
-         A_int(0, f) += val_int0;
-         A_int(1, f) += val_int1;
-         A_ext(0, f) += val_ext01;
-         A_ext(1, f) += val_ext10;
-      }
-      else
-      {
-         A_int(0, f) = val_int0;
-         A_int(1, f) = val_int1;
-         A_ext(0, f) = val_ext01;
-         A_ext(1, f) = val_ext10;
-      }
+      A_int(0, f) += val_int0;
+      A_int(1, f) += val_int1;
+      A_ext(0, f) += val_ext01;
+      A_ext(1, f) += val_ext10;
    });
 }
 
 static void EADGTraceAssemble1DBdr(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
-                                   Vector &eadata_bdr,
-                                   const bool add)
+                                   Vector &eadata_bdr)
 {
    auto D = Reshape(padata.Read(), 2, 2, NF);
    auto A_bdr = Reshape(eadata_bdr.ReadWrite(), NF);
    mfem::forall(NF, [=] MFEM_HOST_DEVICE (int f)
    {
-      if (add)
-      {
-         A_bdr(f) += D(0, 0, f);
-      }
-      else
-      {
-         A_bdr(f) = D(0, 0, f);
-      }
+      A_bdr(f) += D(0, 0, f);
    });
 }
 
@@ -77,7 +58,6 @@ static void EADGTraceAssemble2DInt(const int NF,
                                    const Vector &padata,
                                    Vector &eadata_int,
                                    Vector &eadata_ext,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -108,20 +88,10 @@ static void EADGTraceAssemble2DInt(const int NF,
                val_ext10 += B(k1,i1) * B(k1,j1) * D(k1, 1, 0, f);
                val_int1  += B(k1,i1) * B(k1,j1) * D(k1, 1, 1, f);
             }
-            if (add)
-            {
-               A_int(i1, j1, 0, f) += val_int0;
-               A_int(i1, j1, 1, f) += val_int1;
-               A_ext(i1, j1, 0, f) += val_ext01;
-               A_ext(i1, j1, 1, f) += val_ext10;
-            }
-            else
-            {
-               A_int(i1, j1, 0, f) = val_int0;
-               A_int(i1, j1, 1, f) = val_int1;
-               A_ext(i1, j1, 0, f) = val_ext01;
-               A_ext(i1, j1, 1, f) = val_ext10;
-            }
+            A_int(i1, j1, 0, f) += val_int0;
+            A_int(i1, j1, 1, f) += val_int1;
+            A_ext(i1, j1, 0, f) += val_ext01;
+            A_ext(i1, j1, 1, f) += val_ext10;
          }
       }
    });
@@ -132,7 +102,6 @@ static void EADGTraceAssemble2DBdr(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
                                    Vector &eadata_bdr,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -156,14 +125,7 @@ static void EADGTraceAssemble2DBdr(const int NF,
             {
                val_bdr  += B(k1,i1) * B(k1,j1) * D(k1, 0, 0, f);
             }
-            if (add)
-            {
-               A_bdr(i1, j1, f) += val_bdr;
-            }
-            else
-            {
-               A_bdr(i1, j1, f) = val_bdr;
-            }
+            A_bdr(i1, j1, f) += val_bdr;
          }
       }
    });
@@ -175,7 +137,6 @@ static void EADGTraceAssemble3DInt(const int NF,
                                    const Vector &padata,
                                    Vector &eadata_int,
                                    Vector &eadata_ext,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -246,20 +207,10 @@ static void EADGTraceAssemble3DInt(const int NF,
                                     * s_D[k1][k2][1][0];
                      }
                   }
-                  if (add)
-                  {
-                     A_int(i1, i2, j1, j2, 0, f) += val_int0;
-                     A_int(i1, i2, j1, j2, 1, f) += val_int1;
-                     A_ext(i1, i2, j1, j2, 0, f) += val_ext01;
-                     A_ext(i1, i2, j1, j2, 1, f) += val_ext10;
-                  }
-                  else
-                  {
-                     A_int(i1, i2, j1, j2, 0, f) = val_int0;
-                     A_int(i1, i2, j1, j2, 1, f) = val_int1;
-                     A_ext(i1, i2, j1, j2, 0, f) = val_ext01;
-                     A_ext(i1, i2, j1, j2, 1, f) = val_ext10;
-                  }
+                  A_int(i1, i2, j1, j2, 0, f) += val_int0;
+                  A_int(i1, i2, j1, j2, 1, f) += val_int1;
+                  A_ext(i1, i2, j1, j2, 0, f) += val_ext01;
+                  A_ext(i1, i2, j1, j2, 1, f) += val_ext10;
                }
             }
          }
@@ -272,7 +223,6 @@ static void EADGTraceAssemble3DBdr(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
                                    Vector &eadata_bdr,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -330,14 +280,7 @@ static void EADGTraceAssemble3DBdr(const int NF,
                                    * s_D[k1][k2][0][0];
                      }
                   }
-                  if (add)
-                  {
-                     A_bdr(i1, i2, j1, j2, f) += val_bdr;
-                  }
-                  else
-                  {
-                     A_bdr(i1, i2, j1, j2, f) = val_bdr;
-                  }
+                  A_bdr(i1, i2, j1, j2, f) += val_bdr;
                }
             }
          }
@@ -347,8 +290,7 @@ static void EADGTraceAssemble3DBdr(const int NF,
 
 void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
                                                 Vector &ea_data_int,
-                                                Vector &ea_data_ext,
-                                                const bool add)
+                                                Vector &ea_data_ext)
 {
    SetupPA(fes, FaceType::Interior);
    nf = fes.GetNFbyType(FaceType::Interior);
@@ -356,7 +298,7 @@ void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
    const Array<double> &B = maps->B;
    if (dim == 1)
    {
-      return EADGTraceAssemble1DInt(nf,B,pa_data,ea_data_int,ea_data_ext,add);
+      return EADGTraceAssemble1DInt(nf,B,pa_data,ea_data_int,ea_data_ext);
    }
    else if (dim == 2)
    {
@@ -364,31 +306,31 @@ void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
       {
          case 0x22:
             return EADGTraceAssemble2DInt<2,2>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x33:
             return EADGTraceAssemble2DInt<3,3>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x44:
             return EADGTraceAssemble2DInt<4,4>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x55:
             return EADGTraceAssemble2DInt<5,5>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x66:
             return EADGTraceAssemble2DInt<6,6>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x77:
             return EADGTraceAssemble2DInt<7,7>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x88:
             return EADGTraceAssemble2DInt<8,8>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x99:
             return EADGTraceAssemble2DInt<9,9>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          default:
             return EADGTraceAssemble2DInt(nf,B,pa_data,ea_data_int,
-                                          ea_data_ext,add,dofs1D,quad1D);
+                                          ea_data_ext,dofs1D,quad1D);
       }
    }
    else if (dim == 3)
@@ -397,36 +339,35 @@ void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
       {
          case 0x23:
             return EADGTraceAssemble3DInt<2,3>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x34:
             return EADGTraceAssemble3DInt<3,4>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x45:
             return EADGTraceAssemble3DInt<4,5>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x56:
             return EADGTraceAssemble3DInt<5,6>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x67:
             return EADGTraceAssemble3DInt<6,7>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x78:
             return EADGTraceAssemble3DInt<7,8>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x89:
             return EADGTraceAssemble3DInt<8,9>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          default:
             return EADGTraceAssemble3DInt(nf,B,pa_data,ea_data_int,
-                                          ea_data_ext,add,dofs1D,quad1D);
+                                          ea_data_ext,dofs1D,quad1D);
       }
    }
    MFEM_ABORT("Unknown kernel.");
 }
 
 void DGTraceIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace& fes,
-                                                Vector &ea_data_bdr,
-                                                const bool add)
+                                                Vector &ea_data_bdr)
 {
    SetupPA(fes, FaceType::Boundary);
    nf = fes.GetNFbyType(FaceType::Boundary);
@@ -434,37 +375,37 @@ void DGTraceIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace& fes,
    const Array<double> &B = maps->B;
    if (dim == 1)
    {
-      return EADGTraceAssemble1DBdr(nf,B,pa_data,ea_data_bdr,add);
+      return EADGTraceAssemble1DBdr(nf,B,pa_data,ea_data_bdr);
    }
    else if (dim == 2)
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EADGTraceAssemble2DBdr<2,2>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x33: return EADGTraceAssemble2DBdr<3,3>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x44: return EADGTraceAssemble2DBdr<4,4>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x55: return EADGTraceAssemble2DBdr<5,5>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x66: return EADGTraceAssemble2DBdr<6,6>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x77: return EADGTraceAssemble2DBdr<7,7>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x88: return EADGTraceAssemble2DBdr<8,8>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x99: return EADGTraceAssemble2DBdr<9,9>(nf,B,pa_data,ea_data_bdr,add);
+         case 0x22: return EADGTraceAssemble2DBdr<2,2>(nf,B,pa_data,ea_data_bdr);
+         case 0x33: return EADGTraceAssemble2DBdr<3,3>(nf,B,pa_data,ea_data_bdr);
+         case 0x44: return EADGTraceAssemble2DBdr<4,4>(nf,B,pa_data,ea_data_bdr);
+         case 0x55: return EADGTraceAssemble2DBdr<5,5>(nf,B,pa_data,ea_data_bdr);
+         case 0x66: return EADGTraceAssemble2DBdr<6,6>(nf,B,pa_data,ea_data_bdr);
+         case 0x77: return EADGTraceAssemble2DBdr<7,7>(nf,B,pa_data,ea_data_bdr);
+         case 0x88: return EADGTraceAssemble2DBdr<8,8>(nf,B,pa_data,ea_data_bdr);
+         case 0x99: return EADGTraceAssemble2DBdr<9,9>(nf,B,pa_data,ea_data_bdr);
          default:
-            return EADGTraceAssemble2DBdr(nf,B,pa_data,ea_data_bdr,add,dofs1D,quad1D);
+            return EADGTraceAssemble2DBdr(nf,B,pa_data,ea_data_bdr,dofs1D,quad1D);
       }
    }
    else if (dim == 3)
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EADGTraceAssemble3DBdr<2,3>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x34: return EADGTraceAssemble3DBdr<3,4>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x45: return EADGTraceAssemble3DBdr<4,5>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x56: return EADGTraceAssemble3DBdr<5,6>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x67: return EADGTraceAssemble3DBdr<6,7>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x78: return EADGTraceAssemble3DBdr<7,8>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x89: return EADGTraceAssemble3DBdr<8,9>(nf,B,pa_data,ea_data_bdr,add);
+         case 0x23: return EADGTraceAssemble3DBdr<2,3>(nf,B,pa_data,ea_data_bdr);
+         case 0x34: return EADGTraceAssemble3DBdr<3,4>(nf,B,pa_data,ea_data_bdr);
+         case 0x45: return EADGTraceAssemble3DBdr<4,5>(nf,B,pa_data,ea_data_bdr);
+         case 0x56: return EADGTraceAssemble3DBdr<5,6>(nf,B,pa_data,ea_data_bdr);
+         case 0x67: return EADGTraceAssemble3DBdr<6,7>(nf,B,pa_data,ea_data_bdr);
+         case 0x78: return EADGTraceAssemble3DBdr<7,8>(nf,B,pa_data,ea_data_bdr);
+         case 0x89: return EADGTraceAssemble3DBdr<8,9>(nf,B,pa_data,ea_data_bdr);
          default:
-            return EADGTraceAssemble3DBdr(nf,B,pa_data,ea_data_bdr,add,dofs1D,quad1D);
+            return EADGTraceAssemble3DBdr(nf,B,pa_data,ea_data_bdr,dofs1D,quad1D);
       }
    }
    MFEM_ABORT("Unknown kernel.");
diff --git a/fem/bilininteg_dgtrace_pa.cpp b/fem/integ/bilininteg_dgtrace_pa.cpp
similarity index 90%
rename from fem/bilininteg_dgtrace_pa.cpp
rename to fem/integ/bilininteg_dgtrace_pa.cpp
index 6987d3455..f4b8d837c 100644
--- a/fem/bilininteg_dgtrace_pa.cpp
+++ b/fem/integ/bilininteg_dgtrace_pa.cpp
@@ -9,16 +9,15 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qfunction.hpp"
-#include "restriction.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../restriction.hpp"
 
 namespace mfem
 {
+
 // PA DG Trace Integrator
 static void PADGTraceSetup2D(const int Q1D,
                              const int NF,
@@ -111,30 +110,6 @@ static void PADGTraceSetup3D(const int Q1D,
    });
 }
 
-static void PADGTraceSetup(const int dim,
-                           const int D1D,
-                           const int Q1D,
-                           const int NF,
-                           const Array<double> &W,
-                           const Vector &det,
-                           const Vector &nor,
-                           const Vector &rho,
-                           const Vector &u,
-                           const double alpha,
-                           const double beta,
-                           Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PADGTraceSetup"); }
-   if (dim == 2)
-   {
-      PADGTraceSetup2D(Q1D, NF, W, det, nor, rho, u, alpha, beta, op);
-   }
-   if (dim == 3)
-   {
-      PADGTraceSetup3D(Q1D, NF, W, det, nor, rho, u, alpha, beta, op);
-   }
-}
-
 void DGTraceIntegrator::SetupPA(const FiniteElementSpace &fes, FaceType type)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
@@ -230,9 +205,21 @@ void DGTraceIntegrator::SetupPA(const FiniteElementSpace &fes, FaceType type)
       }
       MFEM_VERIFY(f_ind==nf, "Incorrect number of faces.");
    }
-   PADGTraceSetup(dim, dofs1D, quad1D, nf, ir->GetWeights(),
-                  geom->detJ, geom->normal, r, vel,
-                  alpha, beta, pa_data);
+
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in DGTraceIntegrator::SetupPA");
+   }
+   else if (dim == 2)
+   {
+      PADGTraceSetup2D(quad1D, nf, ir->GetWeights(), geom->detJ, geom->normal,
+                       r, vel, alpha, beta, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PADGTraceSetup3D(quad1D, nf, ir->GetWeights(), geom->detJ, geom->normal,
+                       r, vel, alpha, beta, pa_data);
+   }
 }
 
 void DGTraceIntegrator::AssemblePAInteriorFaces(const FiniteElementSpace& fes)
@@ -246,15 +233,15 @@ void DGTraceIntegrator::AssemblePABoundaryFaces(const FiniteElementSpace& fes)
 }
 
 // PA DGTrace Apply 2D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApply2D(const int NF,
-                      const Array<double> &b,
-                      const Array<double> &bt,
-                      const Vector &op_,
-                      const Vector &x_,
-                      Vector &y_,
-                      const int d1d = 0,
-                      const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApply2D(const int NF,
+                             const Array<double> &b,
+                             const Array<double> &bt,
+                             const Vector &op_,
+                             const Vector &x_,
+                             Vector &y_,
+                             const int d1d = 0,
+                             const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -337,15 +324,15 @@ void PADGTraceApply2D(const int NF,
 }
 
 // PA DGTrace Apply 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApply3D(const int NF,
-                      const Array<double> &b,
-                      const Array<double> &bt,
-                      const Vector &op_,
-                      const Vector &x_,
-                      Vector &y_,
-                      const int d1d = 0,
-                      const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApply3D(const int NF,
+                             const Array<double> &b,
+                             const Array<double> &bt,
+                             const Vector &op_,
+                             const Vector &x_,
+                             Vector &y_,
+                             const int d1d = 0,
+                             const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -482,15 +469,15 @@ void PADGTraceApply3D(const int NF,
 }
 
 // Optimized PA DGTrace Apply 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPADGTraceApply3D(const int NF,
-                          const Array<double> &b,
-                          const Array<double> &bt,
-                          const Vector &op_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPADGTraceApply3D(const int NF,
+                                 const Array<double> &b,
+                                 const Array<double> &bt,
+                                 const Vector &op_,
+                                 const Vector &x_,
+                                 Vector &y_,
+                                 const int d1d = 0,
+                                 const int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -647,15 +634,15 @@ static void PADGTraceApply(const int dim,
 }
 
 // PA DGTrace Apply 2D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApplyTranspose2D(const int NF,
-                               const Array<double> &b,
-                               const Array<double> &bt,
-                               const Vector &op_,
-                               const Vector &x_,
-                               Vector &y_,
-                               const int d1d = 0,
-                               const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApplyTranspose2D(const int NF,
+                                      const Array<double> &b,
+                                      const Array<double> &bt,
+                                      const Vector &op_,
+                                      const Vector &x_,
+                                      Vector &y_,
+                                      const int d1d = 0,
+                                      const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -743,15 +730,15 @@ void PADGTraceApplyTranspose2D(const int NF,
 }
 
 // PA DGTrace Apply Transpose 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApplyTranspose3D(const int NF,
-                               const Array<double> &b,
-                               const Array<double> &bt,
-                               const Vector &op_,
-                               const Vector &x_,
-                               Vector &y_,
-                               const int d1d = 0,
-                               const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApplyTranspose3D(const int NF,
+                                      const Array<double> &b,
+                                      const Array<double> &bt,
+                                      const Vector &op_,
+                                      const Vector &x_,
+                                      Vector &y_,
+                                      const int d1d = 0,
+                                      const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -899,15 +886,15 @@ void PADGTraceApplyTranspose3D(const int NF,
 }
 
 // Optimized PA DGTrace Apply Transpose 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPADGTraceApplyTranspose3D(const int NF,
-                                   const Array<double> &b,
-                                   const Array<double> &bt,
-                                   const Vector &op_,
-                                   const Vector &x_,
-                                   Vector &y_,
-                                   const int d1d = 0,
-                                   const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPADGTraceApplyTranspose3D(const int NF,
+                                          const Array<double> &b,
+                                          const Array<double> &bt,
+                                          const Vector &op_,
+                                          const Vector &x_,
+                                          Vector &y_,
+                                          const int d1d = 0,
+                                          const int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -1076,7 +1063,6 @@ static void PADGTraceApplyTranspose(const int dim,
    MFEM_ABORT("Unknown kernel.");
 }
 
-// PA DGTraceIntegrator Apply kernel
 void DGTraceIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    PADGTraceApply(dim, dofs1D, quad1D, nf,
diff --git a/fem/bilininteg_diffusion_ea.cpp b/fem/integ/bilininteg_diffusion_ea.cpp
similarity index 87%
rename from fem/bilininteg_diffusion_ea.cpp
rename to fem/integ/bilininteg_diffusion_ea.cpp
index c6b43053c..aa36233c4 100644
--- a/fem/bilininteg_diffusion_ea.cpp
+++ b/fem/integ/bilininteg_diffusion_ea.cpp
@@ -9,9 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
 
 namespace mfem
 {
@@ -22,7 +22,6 @@ static void EADiffusionAssemble1D(const int NE,
                                   const Array<double> &g,
                                   const Vector &padata,
                                   Vector &eadata,
-                                  const bool add,
                                   const int d1d = 0,
                                   const int q1d = 0)
 {
@@ -54,14 +53,7 @@ static void EADiffusionAssemble1D(const int NE,
             {
                val += r_Gj[k1] * D(k1, e) * r_Gi[k1];
             }
-            if (add)
-            {
-               A(i1, j1, e) += val;
-            }
-            else
-            {
-               A(i1, j1, e) = val;
-            }
+            A(i1, j1, e) += val;
          }
       }
    });
@@ -73,7 +65,6 @@ static void EADiffusionAssemble2D(const int NE,
                                   const Array<double> &g,
                                   const Vector &padata,
                                   Vector &eadata,
-                                  const bool add,
                                   const int d1d = 0,
                                   const int q1d = 0)
 {
@@ -129,14 +120,7 @@ static void EADiffusionAssemble2D(const int NE,
                                + gbi * D11 * gbj;
                      }
                   }
-                  if (add)
-                  {
-                     A(i1, i2, j1, j2, e) += val;
-                  }
-                  else
-                  {
-                     A(i1, i2, j1, j2, e) = val;
-                  }
+                  A(i1, i2, j1, j2, e) += val;
                }
             }
          }
@@ -150,7 +134,6 @@ static void EADiffusionAssemble3D(const int NE,
                                   const Array<double> &g,
                                   const Vector &padata,
                                   Vector &eadata,
-                                  const bool add,
                                   const int d1d = 0,
                                   const int q1d = 0)
 {
@@ -225,14 +208,7 @@ static void EADiffusionAssemble3D(const int NE,
                               }
                            }
                         }
-                        if (add)
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) += val;
-                        }
-                        else
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) = val;
-                        }
+                        A(i1, i2, i3, j1, j2, j3, e) += val;
                      }
                   }
                }
@@ -243,8 +219,7 @@ static void EADiffusionAssemble3D(const int NE,
 }
 
 void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                     Vector &ea_data,
-                                     const bool add)
+                                     Vector &ea_data)
 {
    AssemblePA(fes);
    ne = fes.GetMesh()->GetNE();
@@ -254,15 +229,15 @@ void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EADiffusionAssemble1D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EADiffusionAssemble1D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EADiffusionAssemble1D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EADiffusionAssemble1D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EADiffusionAssemble1D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EADiffusionAssemble1D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EADiffusionAssemble1D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EADiffusionAssemble1D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EADiffusionAssemble1D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EADiffusionAssemble1D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EADiffusionAssemble1D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EADiffusionAssemble1D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EADiffusionAssemble1D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EADiffusionAssemble1D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EADiffusionAssemble1D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EADiffusionAssemble1D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EADiffusionAssemble1D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EADiffusionAssemble1D(ne,B,G,pa_data,ea_data,
                                                     dofs1D,quad1D);
       }
    }
@@ -270,15 +245,15 @@ void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EADiffusionAssemble2D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EADiffusionAssemble2D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EADiffusionAssemble2D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EADiffusionAssemble2D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EADiffusionAssemble2D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EADiffusionAssemble2D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EADiffusionAssemble2D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EADiffusionAssemble2D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EADiffusionAssemble2D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EADiffusionAssemble2D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EADiffusionAssemble2D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EADiffusionAssemble2D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EADiffusionAssemble2D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EADiffusionAssemble2D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EADiffusionAssemble2D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EADiffusionAssemble2D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EADiffusionAssemble2D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EADiffusionAssemble2D(ne,B,G,pa_data,ea_data,
                                                     dofs1D,quad1D);
       }
    }
@@ -286,14 +261,14 @@ void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EADiffusionAssemble3D<2,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x34: return EADiffusionAssemble3D<3,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x45: return EADiffusionAssemble3D<4,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x56: return EADiffusionAssemble3D<5,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x67: return EADiffusionAssemble3D<6,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x78: return EADiffusionAssemble3D<7,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x89: return EADiffusionAssemble3D<8,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EADiffusionAssemble3D(ne,B,G,pa_data,ea_data,add,
+         case 0x23: return EADiffusionAssemble3D<2,3>(ne,B,G,pa_data,ea_data);
+         case 0x34: return EADiffusionAssemble3D<3,4>(ne,B,G,pa_data,ea_data);
+         case 0x45: return EADiffusionAssemble3D<4,5>(ne,B,G,pa_data,ea_data);
+         case 0x56: return EADiffusionAssemble3D<5,6>(ne,B,G,pa_data,ea_data);
+         case 0x67: return EADiffusionAssemble3D<6,7>(ne,B,G,pa_data,ea_data);
+         case 0x78: return EADiffusionAssemble3D<7,8>(ne,B,G,pa_data,ea_data);
+         case 0x89: return EADiffusionAssemble3D<8,9>(ne,B,G,pa_data,ea_data);
+         default:   return EADiffusionAssemble3D(ne,B,G,pa_data,ea_data,
                                                     dofs1D,quad1D);
       }
    }
diff --git a/fem/bilininteg_diffusion_pa.cpp b/fem/integ/bilininteg_diffusion_kernels.hpp
similarity index 85%
rename from fem/bilininteg_diffusion_pa.cpp
rename to fem/integ/bilininteg_diffusion_kernels.hpp
index 2d953952e..63bc52bd8 100644
--- a/fem/bilininteg_diffusion_pa.cpp
+++ b/fem/integ/bilininteg_diffusion_kernels.hpp
@@ -9,28 +9,29 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qfunction.hpp"
-#include "ceed/integrators/diffusion/diffusion.hpp"
+#ifndef MFEM_BILININTEG_DIFFUSION_KERNELS_HPP
+#define MFEM_BILININTEG_DIFFUSION_KERNELS_HPP
 
-using namespace std;
+#include "../../config/config.hpp"
+#include "../../general/forall.hpp"
+#include "../../linalg/dtensor.hpp"
 
 namespace mfem
 {
 
-// PA Diffusion Integrator
+namespace internal
+{
 
 // OCCA 2D Assemble kernel
 #ifdef MFEM_USE_OCCA
-static void OccaPADiffusionSetup2D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const Array<double> &W,
-                                   const Vector &J,
-                                   const Vector &C,
-                                   Vector &op)
+MFEM_HOST_DEVICE inline
+void OccaPADiffusionSetup2D(const int D1D,
+                            const int Q1D,
+                            const int NE,
+                            const Array<double> &W,
+                            const Vector &J,
+                            const Vector &C,
+                            Vector &op)
 {
    occa::properties props;
    props["defines/D1D"] = D1D;
@@ -52,13 +53,14 @@ static void OccaPADiffusionSetup2D(const int D1D,
    OccaDiffSetup2D_ker.at(id)(NE, o_W, o_J, o_C, o_op, const_c);
 }
 
-static void OccaPADiffusionSetup3D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const Array<double> &W,
-                                   const Vector &J,
-                                   const Vector &C,
-                                   Vector &op)
+MFEM_HOST_DEVICE inline
+void OccaPADiffusionSetup3D(const int D1D,
+                            const int Q1D,
+                            const int NE,
+                            const Array<double> &W,
+                            const Vector &J,
+                            const Vector &C,
+                            Vector &op)
 {
    occa::properties props;
    props["defines/D1D"] = D1D;
@@ -81,7 +83,19 @@ static void OccaPADiffusionSetup3D(const int D1D,
 }
 #endif // MFEM_USE_OCCA
 
+// PA Diffusion Assemble 2D kernel
+template<const int T_SDIM>
+MFEM_HOST_DEVICE inline
+void PADiffusionSetup2D(const int Q1D,
+                        const int coeffDim,
+                        const int NE,
+                        const Array<double> &w,
+                        const Vector &j,
+                        const Vector &c,
+                        Vector &d);
+
 template<>
+MFEM_HOST_DEVICE inline
 void PADiffusionSetup2D<2>(const int Q1D,
                            const int coeffDim,
                            const int NE,
@@ -149,6 +163,7 @@ void PADiffusionSetup2D<2>(const int Q1D,
 
 // PA Diffusion Assemble 2D kernel with 3D node coords
 template<>
+MFEM_HOST_DEVICE inline
 void PADiffusionSetup2D<3>(const int Q1D,
                            const int coeffDim,
                            const int NE,
@@ -194,6 +209,7 @@ void PADiffusionSetup2D<3>(const int Q1D,
 }
 
 // PA Diffusion Assemble 3D kernel
+MFEM_HOST_DEVICE inline
 void PADiffusionSetup3D(const int Q1D,
                         const int coeffDim,
                         const int NE,
@@ -314,16 +330,17 @@ void PADiffusionSetup3D(const int Q1D,
    });
 }
 
-static void PADiffusionSetup(const int dim,
-                             const int sdim,
-                             const int D1D,
-                             const int Q1D,
-                             const int coeffDim,
-                             const int NE,
-                             const Array<double> &W,
-                             const Vector &J,
-                             const Vector &C,
-                             Vector &D)
+MFEM_HOST_DEVICE inline
+void PADiffusionSetup(const int dim,
+                      const int sdim,
+                      const int D1D,
+                      const int Q1D,
+                      const int coeffDim,
+                      const int NE,
+                      const Array<double> &W,
+                      const Vector &J,
+                      const Vector &C,
+                      Vector &D)
 {
    if (dim == 1) { MFEM_ABORT("dim==1 not supported in PADiffusionSetup"); }
    if (dim == 2)
@@ -353,71 +370,16 @@ static void PADiffusionSetup(const int dim,
    }
 }
 
-void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
-{
-   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
-                         Device::GetDeviceMemoryType() : pa_mt;
-   // Assuming the same element type
-   fespace = &fes;
-   Mesh *mesh = fes.GetMesh();
-   if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
-   if (DeviceCanUseCeed())
-   {
-      delete ceedOp;
-      MFEM_VERIFY(!VQ && !MQ,
-                  "Only scalar coefficient supported for DiffusionIntegrator"
-                  " with libCEED");
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPADiffusionIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PADiffusionIntegrator(fes, *ir, Q);
-      }
-      return;
-   }
-   const int dims = el.GetDim();
-   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   ne = fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS, mt);
-   const int sdim = mesh->SpaceDimension();
-   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
-   dofs1D = maps->ndof;
-   quad1D = maps->nqpt;
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(qs, CoefficientStorage::COMPRESSED);
-
-   if (MQ) { coeff.ProjectTranspose(*MQ); }
-   else if (VQ) { coeff.Project(*VQ); }
-   else if (Q) { coeff.Project(*Q); }
-   else { coeff.SetConstant(1.0); }
-
-   const int coeff_dim = coeff.GetVDim();
-   symmetric = (coeff_dim != dims*dims);
-   const int pa_size = symmetric ? symmDims : dims*dims;
-
-   pa_data.SetSize(pa_size * nq * ne, mt);
-   PADiffusionSetup(dim, sdim, dofs1D, quad1D, coeff_dim, ne, ir->GetWeights(),
-                    geom->J, coeff, pa_data);
-}
-
 template<int T_D1D = 0, int T_Q1D = 0>
-static void PADiffusionDiagonal2D(const int NE,
-                                  const bool symmetric,
-                                  const Array<double> &b,
-                                  const Array<double> &g,
-                                  const Vector &d,
-                                  Vector &y,
-                                  const int d1d = 0,
-                                  const int q1d = 0)
+MFEM_HOST_DEVICE inline
+void PADiffusionDiagonal2D(const int NE,
+                           const bool symmetric,
+                           const Array<double> &b,
+                           const Array<double> &g,
+                           const Vector &d,
+                           Vector &y,
+                           const int d1d = 0,
+                           const int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -476,14 +438,15 @@ static void PADiffusionDiagonal2D(const int NE,
 
 // Shared memory PA Diffusion Diagonal 2D kernel
 template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
-static void SmemPADiffusionDiagonal2D(const int NE,
-                                      const bool symmetric,
-                                      const Array<double> &b_,
-                                      const Array<double> &g_,
-                                      const Vector &d_,
-                                      Vector &y_,
-                                      const int d1d = 0,
-                                      const int q1d = 0)
+MFEM_HOST_DEVICE inline
+void SmemPADiffusionDiagonal2D(const int NE,
+                               const bool symmetric,
+                               const Array<double> &b_,
+                               const Array<double> &g_,
+                               const Vector &d_,
+                               Vector &y_,
+                               const int d1d = 0,
+                               const int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -570,14 +533,15 @@ static void SmemPADiffusionDiagonal2D(const int NE,
 }
 
 template<int T_D1D = 0, int T_Q1D = 0>
-static void PADiffusionDiagonal3D(const int NE,
-                                  const bool symmetric,
-                                  const Array<double> &b,
-                                  const Array<double> &g,
-                                  const Vector &d,
-                                  Vector &y,
-                                  const int d1d = 0,
-                                  const int q1d = 0)
+MFEM_HOST_DEVICE inline
+void PADiffusionDiagonal3D(const int NE,
+                           const bool symmetric,
+                           const Array<double> &b,
+                           const Array<double> &g,
+                           const Vector &d,
+                           Vector &y,
+                           const int d1d = 0,
+                           const int q1d = 0)
 {
    constexpr int DIM = 3;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -671,14 +635,15 @@ static void PADiffusionDiagonal3D(const int NE,
 
 // Shared memory PA Diffusion Diagonal 3D kernel
 template<int T_D1D = 0, int T_Q1D = 0>
-static void SmemPADiffusionDiagonal3D(const int NE,
-                                      const bool symmetric,
-                                      const Array<double> &b_,
-                                      const Array<double> &g_,
-                                      const Vector &d_,
-                                      Vector &y_,
-                                      const int d1d = 0,
-                                      const int q1d = 0)
+MFEM_HOST_DEVICE inline
+void SmemPADiffusionDiagonal3D(const int NE,
+                               const bool symmetric,
+                               const Array<double> &b_,
+                               const Array<double> &g_,
+                               const Vector &d_,
+                               Vector &y_,
+                               const int d1d = 0,
+                               const int q1d = 0)
 {
    constexpr int DIM = 3;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -788,15 +753,16 @@ static void SmemPADiffusionDiagonal3D(const int NE,
    });
 }
 
-static void PADiffusionAssembleDiagonal(const int dim,
-                                        const int D1D,
-                                        const int Q1D,
-                                        const int NE,
-                                        const bool symm,
-                                        const Array<double> &B,
-                                        const Array<double> &G,
-                                        const Vector &D,
-                                        Vector &Y)
+MFEM_HOST_DEVICE inline
+void PADiffusionAssembleDiagonal(const int dim,
+                                 const int D1D,
+                                 const int Q1D,
+                                 const int NE,
+                                 const bool symm,
+                                 const Array<double> &B,
+                                 const Array<double> &G,
+                                 const Vector &D,
+                                 Vector &Y)
 {
    if (dim == 2)
    {
@@ -833,33 +799,19 @@ static void PADiffusionAssembleDiagonal(const int dim,
    MFEM_ABORT("Unknown kernel.");
 }
 
-void DiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
-{
-   if (DeviceCanUseCeed())
-   {
-      ceedOp->GetDiagonal(diag);
-   }
-   else
-   {
-      if (pa_data.Size()==0) { AssemblePA(*fespace); }
-      PADiffusionAssembleDiagonal(dim, dofs1D, quad1D, ne, symmetric,
-                                  maps->B, maps->G, pa_data, diag);
-   }
-}
-
-
 #ifdef MFEM_USE_OCCA
 // OCCA PA Diffusion Apply 2D kernel
-static void OccaPADiffusionApply2D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const Array<double> &B,
-                                   const Array<double> &G,
-                                   const Array<double> &Bt,
-                                   const Array<double> &Gt,
-                                   const Vector &D,
-                                   const Vector &X,
-                                   Vector &Y)
+MFEM_HOST_DEVICE inline
+void OccaPADiffusionApply2D(const int D1D,
+                            const int Q1D,
+                            const int NE,
+                            const Array<double> &B,
+                            const Array<double> &G,
+                            const Array<double> &Bt,
+                            const Array<double> &Gt,
+                            const Vector &D,
+                            const Vector &X,
+                            Vector &Y)
 {
    occa::properties props;
    props["defines/D1D"] = D1D;
@@ -899,16 +851,17 @@ static void OccaPADiffusionApply2D(const int D1D,
 }
 
 // OCCA PA Diffusion Apply 3D kernel
-static void OccaPADiffusionApply3D(const int D1D,
-                                   const int Q1D,
-                                   const int NE,
-                                   const Array<double> &B,
-                                   const Array<double> &G,
-                                   const Array<double> &Bt,
-                                   const Array<double> &Gt,
-                                   const Vector &D,
-                                   const Vector &X,
-                                   Vector &Y)
+MFEM_HOST_DEVICE inline
+void OccaPADiffusionApply3D(const int D1D,
+                            const int Q1D,
+                            const int NE,
+                            const Array<double> &B,
+                            const Array<double> &G,
+                            const Array<double> &Bt,
+                            const Array<double> &Gt,
+                            const Vector &D,
+                            const Vector &X,
+                            Vector &Y)
 {
    occa::properties props;
    props["defines/D1D"] = D1D;
@@ -950,17 +903,18 @@ static void OccaPADiffusionApply3D(const int D1D,
 
 // PA Diffusion Apply 2D kernel
 template<int T_D1D = 0, int T_Q1D = 0>
-static void PADiffusionApply2D(const int NE,
-                               const bool symmetric,
-                               const Array<double> &b_,
-                               const Array<double> &g_,
-                               const Array<double> &bt_,
-                               const Array<double> &gt_,
-                               const Vector &d_,
-                               const Vector &x_,
-                               Vector &y_,
-                               const int d1d = 0,
-                               const int q1d = 0)
+MFEM_HOST_DEVICE inline
+void PADiffusionApply2D(const int NE,
+                        const bool symmetric,
+                        const Array<double> &b_,
+                        const Array<double> &g_,
+                        const Array<double> &bt_,
+                        const Array<double> &gt_,
+                        const Vector &d_,
+                        const Vector &x_,
+                        Vector &y_,
+                        const int d1d = 0,
+                        const int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -1072,15 +1026,16 @@ static void PADiffusionApply2D(const int NE,
 
 // Shared memory PA Diffusion Apply 2D kernel
 template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
-static void SmemPADiffusionApply2D(const int NE,
-                                   const bool symmetric,
-                                   const Array<double> &b_,
-                                   const Array<double> &g_,
-                                   const Vector &d_,
-                                   const Vector &x_,
-                                   Vector &y_,
-                                   const int d1d = 0,
-                                   const int q1d = 0)
+MFEM_HOST_DEVICE inline
+void SmemPADiffusionApply2D(const int NE,
+                            const bool symmetric,
+                            const Array<double> &b_,
+                            const Array<double> &g_,
+                            const Vector &d_,
+                            const Vector &x_,
+                            Vector &y_,
+                            const int d1d = 0,
+                            const int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -1230,16 +1185,17 @@ static void SmemPADiffusionApply2D(const int NE,
 
 // PA Diffusion Apply 3D kernel
 template<int T_D1D = 0, int T_Q1D = 0>
-static void PADiffusionApply3D(const int NE,
-                               const bool symmetric,
-                               const Array<double> &b,
-                               const Array<double> &g,
-                               const Array<double> &bt,
-                               const Array<double> &gt,
-                               const Vector &d_,
-                               const Vector &x_,
-                               Vector &y_,
-                               int d1d = 0, int q1d = 0)
+MFEM_HOST_DEVICE inline
+void PADiffusionApply3D(const int NE,
+                        const bool symmetric,
+                        const Array<double> &b,
+                        const Array<double> &g,
+                        const Array<double> &bt,
+                        const Array<double> &gt,
+                        const Vector &d_,
+                        const Vector &x_,
+                        Vector &y_,
+                        int d1d = 0, int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -1422,15 +1378,16 @@ static void PADiffusionApply3D(const int NE,
 }
 
 template<int T_D1D = 0, int T_Q1D = 0>
-static void SmemPADiffusionApply3D(const int NE,
-                                   const bool symmetric,
-                                   const Array<double> &b_,
-                                   const Array<double> &g_,
-                                   const Vector &d_,
-                                   const Vector &x_,
-                                   Vector &y_,
-                                   const int d1d = 0,
-                                   const int q1d = 0)
+MFEM_HOST_DEVICE inline
+void SmemPADiffusionApply3D(const int NE,
+                            const bool symmetric,
+                            const Array<double> &b_,
+                            const Array<double> &g_,
+                            const Vector &d_,
+                            const Vector &x_,
+                            Vector &y_,
+                            const int d1d = 0,
+                            const int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -1643,18 +1600,19 @@ static void SmemPADiffusionApply3D(const int NE,
    });
 }
 
-static void PADiffusionApply(const int dim,
-                             const int D1D,
-                             const int Q1D,
-                             const int NE,
-                             const bool symm,
-                             const Array<double> &B,
-                             const Array<double> &G,
-                             const Array<double> &Bt,
-                             const Array<double> &Gt,
-                             const Vector &D,
-                             const Vector &X,
-                             Vector &Y)
+MFEM_HOST_DEVICE inline
+void PADiffusionApply(const int dim,
+                      const int D1D,
+                      const int Q1D,
+                      const int NE,
+                      const bool symm,
+                      const Array<double> &B,
+                      const Array<double> &G,
+                      const Array<double> &Bt,
+                      const Array<double> &Gt,
+                      const Vector &D,
+                      const Vector &X,
+                      Vector &Y)
 {
 #ifdef MFEM_USE_OCCA
    if (DeviceCanUseOcca())
@@ -1710,32 +1668,8 @@ static void PADiffusionApply(const int dim,
    MFEM_ABORT("Unknown kernel: 0x"<<std::hex << id << std::dec);
 }
 
-// PA Diffusion Apply kernel
-void DiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (DeviceCanUseCeed())
-   {
-      ceedOp->AddMult(x, y);
-   }
-   else
-   {
-      PADiffusionApply(dim, dofs1D, quad1D, ne, symmetric,
-                       maps->B, maps->G, maps->Bt, maps->Gt,
-                       pa_data, x, y);
-   }
-}
-
-void DiffusionIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
-{
-   if (symmetric)
-   {
-      AddMultPA(x, y);
-   }
-   else
-   {
-      MFEM_ABORT("DiffusionIntegrator::AddMultTransposePA only implemented in "
-                 "the symmetric case.")
-   }
-}
+} // namespace internal
 
 } // namespace mfem
+
+#endif
diff --git a/fem/bilininteg_diffusion_mf.cpp b/fem/integ/bilininteg_diffusion_mf.cpp
similarity index 91%
rename from fem/bilininteg_diffusion_mf.cpp
rename to fem/integ/bilininteg_diffusion_mf.cpp
index c6bd5c728..0896b8bf9 100644
--- a/fem/bilininteg_diffusion_mf.cpp
+++ b/fem/integ/bilininteg_diffusion_mf.cpp
@@ -9,12 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "ceed/integrators/diffusion/diffusion.hpp"
-
-using namespace std;
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/diffusion/diffusion.hpp"
 
 namespace mfem
 {
@@ -22,7 +19,6 @@ namespace mfem
 void DiffusionIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
diff --git a/fem/integ/bilininteg_diffusion_pa.cpp b/fem/integ/bilininteg_diffusion_pa.cpp
new file mode 100644
index 000000000..a966c8520
--- /dev/null
+++ b/fem/integ/bilininteg_diffusion_pa.cpp
@@ -0,0 +1,124 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../ceed/integrators/diffusion/diffusion.hpp"
+#include "bilininteg_diffusion_kernels.hpp"
+
+namespace mfem
+{
+
+void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
+                         Device::GetDeviceMemoryType() : pa_mt;
+   // Assuming the same element type
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   const FiniteElement &el = *fes.GetFE(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      MFEM_VERIFY(!VQ && !MQ,
+                  "Only scalar coefficient supported for DiffusionIntegrator"
+                  " with libCEED");
+      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
+                         fes.IsVariableOrder();
+      if (mixed)
+      {
+         ceedOp = new ceed::MixedPADiffusionIntegrator(*this, fes, Q);
+      }
+      else
+      {
+         ceedOp = new ceed::PADiffusionIntegrator(fes, *ir, Q);
+      }
+      return;
+   }
+   const int dims = el.GetDim();
+   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   ne = fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS, mt);
+   const int sdim = mesh->SpaceDimension();
+   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
+   dofs1D = maps->ndof;
+   quad1D = maps->nqpt;
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(qs, CoefficientStorage::COMPRESSED);
+
+   if (MQ) { coeff.ProjectTranspose(*MQ); }
+   else if (VQ) { coeff.Project(*VQ); }
+   else if (Q) { coeff.Project(*Q); }
+   else { coeff.SetConstant(1.0); }
+
+   const int coeff_dim = coeff.GetVDim();
+   symmetric = (coeff_dim != dims*dims);
+   const int pa_size = symmetric ? symmDims : dims*dims;
+
+   pa_data.SetSize(pa_size * nq * ne, mt);
+   internal::PADiffusionSetup(dim, sdim, dofs1D, quad1D, coeff_dim, ne,
+                              ir->GetWeights(), geom->J, coeff, pa_data);
+}
+
+void DiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
+   {
+      internal::PADiffusionAssembleDiagonal(dim, dofs1D, quad1D, ne, symmetric,
+                                            maps->B, maps->G, pa_data, diag);
+   }
+}
+
+void DiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      internal::PADiffusionApply(dim, dofs1D, quad1D, ne, symmetric,
+                                 maps->B, maps->G, maps->Bt, maps->Gt,
+                                 pa_data, x, y);
+   }
+}
+
+void DiffusionIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " DiffusionIntegrator.");
+   }
+   else
+   {
+      if (symmetric)
+      {
+         AddMultPA(x, y);
+      }
+      else
+      {
+         MFEM_ABORT("DiffusionIntegrator::AddMultTransposePA only implemented in "
+                    "the symmetric case.")
+      }
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_divdiv_pa.cpp b/fem/integ/bilininteg_divdiv_pa.cpp
new file mode 100644
index 000000000..8abf233a7
--- /dev/null
+++ b/fem/integ/bilininteg_divdiv_pa.cpp
@@ -0,0 +1,99 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license.  We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "bilininteg_hdiv_kernels.hpp"
+
+namespace mfem
+{
+
+void DivDivIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   // Assumes tensor-product elements
+   Mesh *mesh = fes.GetMesh();
+   const FiniteElement *fel = fes.GetFE(0);
+
+   const VectorTensorFiniteElement *el =
+      dynamic_cast<const VectorTensorFiniteElement*>(fel);
+   MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const IntegrationRule *ir = IntRule ? IntRule : &MassIntegrator::GetRule
+                               (*el, *el, *mesh->GetElementTransformation(0));
+
+   const int dims = el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   ne = fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   pa_data.SetSize(nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
+
+   if (el->GetDerivType() == mfem::FiniteElement::DIV && dim == 3)
+   {
+      internal::PADivDivSetup3D(quad1D, ne, ir->GetWeights(), geom->J, coeff,
+                                pa_data);
+   }
+   else if (el->GetDerivType() == mfem::FiniteElement::DIV && dim == 2)
+   {
+      internal::PADivDivSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff,
+                                pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
+void DivDivIntegrator::AssembleDiagonalPA(Vector& diag)
+{
+   if (dim == 3)
+   {
+      internal::PADivDivAssembleDiagonal3D(dofs1D, quad1D, ne,
+                                           mapsO->B, mapsC->G, pa_data, diag);
+   }
+   else
+   {
+      internal::PADivDivAssembleDiagonal2D(dofs1D, quad1D, ne,
+                                           mapsO->B, mapsC->G, pa_data, diag);
+   }
+}
+
+void DivDivIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+      internal::PADivDivApply3D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
+                                mapsO->Bt, mapsC->Gt, pa_data, x, y);
+   else if (dim == 2)
+      internal::PADivDivApply2D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
+                                mapsO->Bt, mapsC->Gt, pa_data, x, y);
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/bilininteg_gradient.cpp b/fem/integ/bilininteg_gradient_pa.cpp
similarity index 93%
rename from fem/bilininteg_gradient.cpp
rename to fem/integ/bilininteg_gradient_pa.cpp
index 73b9d1859..20ef4684d 100644
--- a/fem/bilininteg_gradient.cpp
+++ b/fem/integ/bilininteg_gradient_pa.cpp
@@ -9,18 +9,14 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qfunction.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
 
 namespace mfem
 {
 
-// PA Gradient Integrator
-
 /* Description of the *SetupND functions
    Inputs are as follows
    \b Q1D number of quadrature points in one dimension.
@@ -162,27 +158,6 @@ static void PAGradientSetup3D(const int Q1D,
    });
 }
 
-static void PAGradientSetup(const int dim,
-                            const int TR_D1D,
-                            const int TE_D1D,
-                            const int Q1D,
-                            const int NE,
-                            const Array<double> &W,
-                            const Vector &J,
-                            const Vector &COEFF,
-                            Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PAGradientSetup"); }
-   if (dim == 2)
-   {
-      PAGradientSetup2D(Q1D, NE, W, J, COEFF, op);
-   }
-   if (dim == 3)
-   {
-      PAGradientSetup3D(Q1D, NE, W, J, COEFF, op);
-   }
-}
-
 void GradientIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                     const FiniteElementSpace &test_fes)
 {
@@ -213,8 +188,18 @@ void GradientIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    QuadratureSpace qs(*mesh, *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
 
-   PAGradientSetup(dim, trial_dofs1D, test_dofs1D, quad1D,
-                   ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in GradientIntegrator::AssemblePA");
+   }
+   else if (dim == 2)
+   {
+      PAGradientSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PAGradientSetup3D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
 }
 
 // PA Gradient Apply 2D kernel
@@ -791,40 +776,21 @@ static void SmemPAGradientApply3D(const int NE,
    });
 }
 
-static void PAGradientApply(const int dim,
-                            const int TR_D1D,
-                            const int TE_D1D,
-                            const int Q1D,
-                            const int NE,
-                            const Array<double> &B,
-                            const Array<double> &G,
-                            const Array<double> &Bt,
-                            const Vector &op,
-                            const Vector &x,
-                            Vector &y,
-                            bool transpose=false)
+void GradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-
    if (dim == 2)
    {
-      return PAGradientApply2D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
+      return PAGradientApply2D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                               pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    if (dim == 3)
    {
-      return PAGradientApply3D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
+      return PAGradientApply3D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                               pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    MFEM_ABORT("Unknown kernel.");
 }
 
-// PA Gradient Apply kernel
-void GradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   PAGradientApply(dim, trial_dofs1D, test_dofs1D, quad1D, ne,
-                   trial_maps->B, trial_maps->G, test_maps->Bt, pa_data, x, y,
-                   false);
-}
-
-// PA Gradient Apply kernel
 void GradientIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
    MFEM_ABORT("PA Gradient AddMultTransposePA not implemented.");
diff --git a/fem/integ/bilininteg_hcurl_kernels.hpp b/fem/integ/bilininteg_hcurl_kernels.hpp
new file mode 100644
index 000000000..a1545f888
--- /dev/null
+++ b/fem/integ/bilininteg_hcurl_kernels.hpp
@@ -0,0 +1,3891 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_BILININTEG_HCURL_KERNELS_HPP
+#define MFEM_BILININTEG_HCURL_KERNELS_HPP
+
+#include "../../config/config.hpp"
+#include "../../general/forall.hpp"
+#include "../../linalg/dtensor.hpp"
+
+// Piola transformation in H(curl): w = dF^{-T} \hat{w}
+// curl w = (1 / det (dF)) dF \hat{curl} \hat{w}
+
+namespace mfem
+{
+
+namespace internal
+{
+
+MFEM_HOST_DEVICE inline
+void PAHcurlMassAssembleDiagonal2D(const int D1D,
+                                   const int Q1D,
+                                   const int NE,
+                                   const bool symmetric,
+                                   const Array<double> &bo,
+                                   const Array<double> &bc,
+                                   const Vector &pa_data,
+                                   Vector &diag)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, symmetric ? 3 : 4, NE);
+   auto D = Reshape(diag.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         double mass[MAX_Q1D];
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               mass[qx] = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
+
+                  mass[qx] += wy * wy * ((c == 0) ? op(qx,qy,0,e) :
+                                         op(qx,qy,symmetric ? 2 : 3, e));
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx = ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+                  D(dx + (dy * D1Dx) + osc, e) += mass[qx] * wx * wx;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop c
+   }); // end of element loop
+}
+
+MFEM_HOST_DEVICE inline
+void PAHcurlMassAssembleDiagonal3D(const int D1D,
+                                   const int Q1D,
+                                   const int NE,
+                                   const bool symmetric,
+                                   const Array<double> &bo,
+                                   const Array<double> &bc,
+                                   const Vector &pa_data,
+                                   Vector &diag)
+{
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
+   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         const int opc = (c == 0) ? 0 : ((c == 1) ? (symmetric ? 3 : 4) :
+                                         (symmetric ? 5 : 8));
+
+         double mass[MAX_Q1D];
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  mass[qx] = 0.0;
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
+
+                     for (int qz = 0; qz < Q1D; ++qz)
+                     {
+                        const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
+
+                        mass[qx] += wy * wy * wz * wz * op(qx,qy,qz,opc,e);
+                     }
+                  }
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+                     D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += mass[qx] * wx * wx;
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop c
+   }); // end of element loop
+}
+
+template<int T_D1D = HCURL_MAX_D1D, int T_Q1D = HCURL_MAX_Q1D>
+MFEM_HOST_DEVICE inline
+void SmemPAHcurlMassAssembleDiagonal3D(const int D1D,
+                                       const int Q1D,
+                                       const int NE,
+                                       const bool symmetric,
+                                       const Array<double> &bo,
+                                       const Array<double> &bc,
+                                       const Vector &pa_data,
+                                       Vector &diag)
+{
+   MFEM_VERIFY(D1D <= HCURL_MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= HCURL_MAX_Q1D, "Error: Q1D > MAX_Q1D");
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
+   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      constexpr int VDIM = 3;
+
+      MFEM_SHARED double sBo[T_Q1D][T_D1D];
+      MFEM_SHARED double sBc[T_Q1D][T_D1D];
+
+      double op3[3];
+      MFEM_SHARED double sop[3][T_Q1D][T_Q1D];
+
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               op3[0] = op(qx,qy,qz,0,e);
+               op3[1] = op(qx,qy,qz,symmetric ? 3 : 4,e);
+               op3[2] = op(qx,qy,qz,symmetric ? 5 : 8,e);
+            }
+         }
+      }
+
+      const int tidx = MFEM_THREAD_ID(x);
+      const int tidy = MFEM_THREAD_ID(y);
+      const int tidz = MFEM_THREAD_ID(z);
+
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               sBc[q][d] = Bc(q,d);
+               if (d < D1D-1)
+               {
+                  sBo[q][d] = Bo(q,d);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+
+      int osc = 0;
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         double dxyz = 0.0;
+
+         for (int qz=0; qz < Q1D; ++qz)
+         {
+            if (tidz == qz)
+            {
+               for (int i=0; i<3; ++i)
+               {
+                  sop[i][tidx][tidy] = op3[i];
+               }
+            }
+
+            MFEM_SYNC_THREAD;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               const double wz = ((c == 2) ? sBo[qz][dz] : sBc[qz][dz]);
+
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     for (int qy = 0; qy < Q1D; ++qy)
+                     {
+                        const double wy = ((c == 1) ? sBo[qy][dy] : sBc[qy][dy]);
+
+                        for (int qx = 0; qx < Q1D; ++qx)
+                        {
+                           const double wx = ((c == 0) ? sBo[qx][dx] : sBc[qx][dx]);
+                           dxyz += sop[c][qx][qy] * wx * wx * wy * wy * wz * wz;
+                        }
+                     }
+                  }
+               }
+            }
+
+            MFEM_SYNC_THREAD;
+         }  // qz loop
+
+         MFEM_FOREACH_THREAD(dz,z,D1Dz)
+         {
+            MFEM_FOREACH_THREAD(dy,y,D1Dy)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1Dx)
+               {
+                  D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += dxyz;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // c loop
+   }); // end of element loop
+}
+
+MFEM_HOST_DEVICE inline
+void PAHcurlMassApply2D(const int D1D,
+                        const int Q1D,
+                        const int NE,
+                        const bool symmetric,
+                        const Array<double> &bo,
+                        const Array<double> &bc,
+                        const Array<double> &bot,
+                        const Array<double> &bct,
+                        const Vector &pa_data,
+                        const Vector &x,
+                        Vector &y)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, symmetric ? 3 : 4, NE);
+   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            for (int c = 0; c < VDIM; ++c)
+            {
+               mass[qy][qx][c] = 0.0;
+            }
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            double massX[MAX_Q1D];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               massX[qx] = 0.0;
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double t = X(dx + (dy * D1Dx) + osc, e);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+               }
+            }
+
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  mass[qy][qx][c] += massX[qx] * wy;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            const double O11 = op(qx,qy,0,e);
+            const double O21 = op(qx,qy,1,e);
+            const double O12 = symmetric ? O21 : op(qx,qy,2,e);
+            const double O22 = symmetric ? op(qx,qy,2,e) : op(qx,qy,3,e);
+            const double massX = mass[qy][qx][0];
+            const double massY = mass[qy][qx][1];
+            mass[qy][qx][0] = (O11*massX)+(O12*massY);
+            mass[qy][qx][1] = (O21*massX)+(O22*massY);
+         }
+      }
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+         {
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            double massX[MAX_D1D];
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               massX[dx] = 0.0;
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] += mass[qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  Y(dx + (dy * D1Dx) + osc, e) += massX[dx] * wy;
+               }
+            }
+
+            osc += D1Dx * D1Dy;
+         }  // loop c
+      }  // loop qy
+   }); // end of element loop
+}
+
+MFEM_HOST_DEVICE inline
+void PAHcurlMassApply3D(const int D1D,
+                        const int Q1D,
+                        const int NE,
+                        const bool symmetric,
+                        const Array<double> &bo,
+                        const Array<double> &bc,
+                        const Array<double> &bot,
+                        const Array<double> &bct,
+                        const Vector &pa_data,
+                        const Vector &x,
+                        Vector &y)
+{
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  mass[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double massXY[MAX_Q1D][MAX_Q1D];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massXY[qy][qx] = 0.0;
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MAX_Q1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     massXY[qy][qx] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(qx,qy,qz,0,e);
+               const double O12 = op(qx,qy,qz,1,e);
+               const double O13 = op(qx,qy,qz,2,e);
+               const double O21 = symmetric ? O12 : op(qx,qy,qz,3,e);
+               const double O22 = symmetric ? op(qx,qy,qz,3,e) : op(qx,qy,qz,4,e);
+               const double O23 = symmetric ? op(qx,qy,qz,4,e) : op(qx,qy,qz,5,e);
+               const double O31 = symmetric ? O13 : op(qx,qy,qz,6,e);
+               const double O32 = symmetric ? O23 : op(qx,qy,qz,7,e);
+               const double O33 = symmetric ? op(qx,qy,qz,5,e) : op(qx,qy,qz,8,e);
+               const double massX = mass[qz][qy][qx][0];
+               const double massY = mass[qz][qy][qx][1];
+               const double massZ = mass[qz][qy][qx][2];
+               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
+               mass[qz][qy][qx][1] = (O21*massX)+(O22*massY)+(O23*massZ);
+               mass[qz][qy][qx][2] = (O31*massX)+(O32*massY)+(O33*massZ);
+            }
+         }
+      }
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         double massXY[MAX_D1D][MAX_D1D];
+
+         osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massXY[dy][dx] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[MAX_D1D];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] = 0;
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massX[dx] += mass[qz][qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massXY[dy][dx] += massX[dx] * wy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = (c == 2) ? Bot(dz,qz) : Bct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += massXY[dy][dx] * wz;
+                  }
+               }
+            }
+
+            osc += D1Dx * D1Dy * D1Dz;
+         }  // loop c
+      }  // loop qz
+   }); // end of element loop
+}
+
+template<int T_D1D = HCURL_MAX_D1D, int T_Q1D = HCURL_MAX_Q1D>
+MFEM_HOST_DEVICE inline
+void SmemPAHcurlMassApply3D(const int D1D,
+                            const int Q1D,
+                            const int NE,
+                            const bool symmetric,
+                            const Array<double> &bo,
+                            const Array<double> &bc,
+                            const Array<double> &bot,
+                            const Array<double> &bct,
+                            const Vector &pa_data,
+                            const Vector &x,
+                            Vector &y)
+{
+   MFEM_VERIFY(D1D <= HCURL_MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= HCURL_MAX_Q1D, "Error: Q1D > MAX_Q1D");
+
+   const int dataSize = symmetric ? 6 : 9;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, dataSize, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      constexpr int VDIM = 3;
+
+      MFEM_SHARED double sBo[T_Q1D][T_D1D];
+      MFEM_SHARED double sBc[T_Q1D][T_D1D];
+
+      double op9[9];
+      MFEM_SHARED double sop[9*T_Q1D*T_Q1D];
+      MFEM_SHARED double mass[T_Q1D][T_Q1D][3];
+
+      MFEM_SHARED double sX[T_D1D][T_D1D][T_D1D];
+
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               for (int i=0; i<dataSize; ++i)
+               {
+                  op9[i] = op(qx,qy,qz,i,e);
+               }
+            }
+         }
+      }
+
+      const int tidx = MFEM_THREAD_ID(x);
+      const int tidy = MFEM_THREAD_ID(y);
+      const int tidz = MFEM_THREAD_ID(z);
+
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               sBc[q][d] = Bc(q,d);
+               if (d < D1D-1)
+               {
+                  sBo[q][d] = Bo(q,d);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+
+      for (int qz=0; qz < Q1D; ++qz)
+      {
+         int osc = 0;
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  }
+               }
+            }
+            MFEM_SYNC_THREAD;
+
+            if (tidz == qz)
+            {
+               for (int i=0; i<dataSize; ++i)
+               {
+                  sop[i + (dataSize*tidx) + (dataSize*Q1D*tidy)] = op9[i];
+               }
+
+               MFEM_FOREACH_THREAD(qy,y,Q1D)
+               {
+                  MFEM_FOREACH_THREAD(qx,x,Q1D)
+                  {
+                     double u = 0.0;
+
+                     for (int dz = 0; dz < D1Dz; ++dz)
+                     {
+                        const double wz = (c == 2) ? sBo[qz][dz] : sBc[qz][dz];
+                        for (int dy = 0; dy < D1Dy; ++dy)
+                        {
+                           const double wy = (c == 1) ? sBo[qy][dy] : sBc[qy][dy];
+                           for (int dx = 0; dx < D1Dx; ++dx)
+                           {
+                              const double t = sX[dz][dy][dx];
+                              const double wx = (c == 0) ? sBo[qx][dx] : sBc[qx][dx];
+                              u += t * wx * wy * wz;
+                           }
+                        }
+                     }
+
+                     mass[qy][qx][c] = u;
+                  } // qx
+               } // qy
+            } // tidz == qz
+
+            osc += D1Dx * D1Dy * D1Dz;
+            MFEM_SYNC_THREAD;
+         } // c
+
+         MFEM_SYNC_THREAD;  // Sync mass[qy][qx][d] and sop
+
+         osc = 0;
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            double dxyz = 0.0;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               const double wz = (c == 2) ? sBo[qz][dz] : sBc[qz][dz];
+
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     for (int qy = 0; qy < Q1D; ++qy)
+                     {
+                        const double wy = (c == 1) ? sBo[qy][dy] : sBc[qy][dy];
+                        for (int qx = 0; qx < Q1D; ++qx)
+                        {
+                           const int os = (dataSize*qx) + (dataSize*Q1D*qy);
+                           const int id1 = os + ((c == 0) ? 0 : ((c == 1) ? (symmetric ? 1 : 3) :
+                                                                 (symmetric ? 2 : 6))); // O11, O21, O31
+                           const int id2 = os + ((c == 0) ? 1 : ((c == 1) ? (symmetric ? 3 : 4) :
+                                                                 (symmetric ? 4 : 7))); // O12, O22, O32
+                           const int id3 = os + ((c == 0) ? 2 : ((c == 1) ? (symmetric ? 4 : 5) :
+                                                                 (symmetric ? 5 : 8))); // O13, O23, O33
+
+                           const double m_c = (sop[id1] * mass[qy][qx][0]) + (sop[id2] * mass[qy][qx][1]) +
+                                              (sop[id3] * mass[qy][qx][2]);
+
+                           const double wx = (c == 0) ? sBo[qx][dx] : sBc[qx][dx];
+                           dxyz += m_c * wx * wy * wz;
+                        }
+                     }
+                  }
+               }
+            }
+
+            MFEM_SYNC_THREAD;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += dxyz;
+                  }
+               }
+            }
+
+            osc += D1Dx * D1Dy * D1Dz;
+         } // c loop
+      } // qz
+   }); // end of element loop
+}
+
+// PA H(curl) curl-curl assemble 2D kernel
+MFEM_HOST_DEVICE inline
+void PACurlCurlSetup2D(const int Q1D,
+                       const int NE,
+                       const Array<double> &w,
+                       const Vector &j,
+                       Vector &coeff,
+                       Vector &op)
+{
+   const int NQ = Q1D*Q1D;
+   auto W = w.Read();
+   auto J = Reshape(j.Read(), NQ, 2, 2, NE);
+   auto C = Reshape(coeff.Read(), NQ, NE);
+   auto y = Reshape(op.Write(), NQ, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      for (int q = 0; q < NQ; ++q)
+      {
+         const double J11 = J(q,0,0,e);
+         const double J21 = J(q,1,0,e);
+         const double J12 = J(q,0,1,e);
+         const double J22 = J(q,1,1,e);
+         const double detJ = (J11*J22)-(J21*J12);
+         y(q,e) = W[q] * C(q,e) / detJ;
+      }
+   });
+}
+
+// PA H(curl) curl-curl assemble 3D kernel
+MFEM_HOST_DEVICE inline
+void PACurlCurlSetup3D(const int Q1D,
+                       const int coeffDim,
+                       const int NE,
+                       const Array<double> &w,
+                       const Vector &j,
+                       Vector &coeff,
+                       Vector &op)
+{
+   const int NQ = Q1D*Q1D*Q1D;
+   const bool symmetric = (coeffDim != 9);
+   auto W = w.Read();
+   auto J = Reshape(j.Read(), NQ, 3, 3, NE);
+   auto C = Reshape(coeff.Read(), coeffDim, NQ, NE);
+   auto y = Reshape(op.Write(), NQ, symmetric ? 6 : 9, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      for (int q = 0; q < NQ; ++q)
+      {
+         const double J11 = J(q,0,0,e);
+         const double J21 = J(q,1,0,e);
+         const double J31 = J(q,2,0,e);
+         const double J12 = J(q,0,1,e);
+         const double J22 = J(q,1,1,e);
+         const double J32 = J(q,2,1,e);
+         const double J13 = J(q,0,2,e);
+         const double J23 = J(q,1,2,e);
+         const double J33 = J(q,2,2,e);
+         const double detJ = J11 * (J22 * J33 - J32 * J23) -
+                             J21 * (J12 * J33 - J32 * J13) +
+                             J31 * (J12 * J23 - J22 * J13);
+
+         const double c_detJ = W[q] / detJ;
+
+         if (coeffDim == 6 || coeffDim == 9) // Matrix coefficient version
+         {
+            // Set y to the 6 or 9 entries of J^T M J / det
+            const double M11 = C(0, q, e);
+            const double M12 = C(1, q, e);
+            const double M13 = C(2, q, e);
+            const double M21 = (!symmetric) ? C(3, q, e) : M12;
+            const double M22 = (!symmetric) ? C(4, q, e) : C(3, q, e);
+            const double M23 = (!symmetric) ? C(5, q, e) : C(4, q, e);
+            const double M31 = (!symmetric) ? C(6, q, e) : M13;
+            const double M32 = (!symmetric) ? C(7, q, e) : M23;
+            const double M33 = (!symmetric) ? C(8, q, e) : C(5, q, e);
+
+            // First compute R = MJ
+            const double R11 = M11*J11 + M12*J21 + M13*J31;
+            const double R12 = M11*J12 + M12*J22 + M13*J32;
+            const double R13 = M11*J13 + M12*J23 + M13*J33;
+            const double R21 = M21*J11 + M22*J21 + M23*J31;
+            const double R22 = M21*J12 + M22*J22 + M23*J32;
+            const double R23 = M21*J13 + M22*J23 + M23*J33;
+            const double R31 = M31*J11 + M32*J21 + M33*J31;
+            const double R32 = M31*J12 + M32*J22 + M33*J32;
+            const double R33 = M31*J13 + M32*J23 + M33*J33;
+
+            // Now set y to J^T R / det
+            y(q,0,e) = c_detJ * (J11*R11 + J21*R21 + J31*R31); // 1,1
+            const double Y12 = c_detJ * (J11*R12 + J21*R22 + J31*R32);
+            y(q,1,e) = Y12; // 1,2
+            y(q,2,e) = c_detJ * (J11*R13 + J21*R23 + J31*R33); // 1,3
+
+            const double Y21 = c_detJ * (J12*R11 + J22*R21 + J32*R31);
+            const double Y22 = c_detJ * (J12*R12 + J22*R22 + J32*R32);
+            const double Y23 = c_detJ * (J12*R13 + J22*R23 + J32*R33);
+
+            const double Y33 = c_detJ * (J13*R13 + J23*R23 + J33*R33);
+
+            y(q,3,e) = symmetric ? Y22 : Y21; // 2,2 or 2,1
+            y(q,4,e) = symmetric ? Y23 : Y22; // 2,3 or 2,2
+            y(q,5,e) = symmetric ? Y33 : Y23; // 3,3 or 2,3
+
+            if (!symmetric)
+            {
+               y(q,6,e) = c_detJ * (J13*R11 + J23*R21 + J33*R31); // 3,1
+               y(q,7,e) = c_detJ * (J13*R12 + J23*R22 + J33*R32); // 3,2
+               y(q,8,e) = Y33; // 3,3
+            }
+         }
+         else  // Vector or scalar coefficient version
+         {
+            // Set y to the 6 entries of J^T D J / det^2
+            const double D1 = C(0, q, e);
+            const double D2 = coeffDim == 3 ? C(1, q, e) : D1;
+            const double D3 = coeffDim == 3 ? C(2, q, e) : D1;
+
+            y(q,0,e) = c_detJ * (D1*J11*J11 + D2*J21*J21 + D3*J31*J31); // 1,1
+            y(q,1,e) = c_detJ * (D1*J11*J12 + D2*J21*J22 + D3*J31*J32); // 1,2
+            y(q,2,e) = c_detJ * (D1*J11*J13 + D2*J21*J23 + D3*J31*J33); // 1,3
+            y(q,3,e) = c_detJ * (D1*J12*J12 + D2*J22*J22 + D3*J32*J32); // 2,2
+            y(q,4,e) = c_detJ * (D1*J12*J13 + D2*J22*J23 + D3*J32*J33); // 2,3
+            y(q,5,e) = c_detJ * (D1*J13*J13 + D2*J23*J23 + D3*J33*J33); // 3,3
+         }
+      }
+   });
+}
+
+MFEM_HOST_DEVICE inline
+void PACurlCurlAssembleDiagonal2D(const int D1D,
+                                  const int Q1D,
+                                  const int NE,
+                                  const Array<double> &bo,
+                                  const Array<double> &gc,
+                                  const Vector &pa_data,
+                                  Vector &diag)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
+   auto D = Reshape(diag.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         double t[MAX_Q1D];
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               t[qx] = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 1) ? Bo(qy,dy) : -Gc(qy,dy);
+                  t[qx] += wy * wy * op(qx,qy,e);
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx = ((c == 0) ? Bo(qx,dx) : Gc(qx,dx));
+                  D(dx + (dy * D1Dx) + osc, e) += t[qx] * wx * wx;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop c
+   }); // end of element loop
+}
+
+template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
+MFEM_HOST_DEVICE inline
+void PACurlCurlAssembleDiagonal3D(const int D1D,
+                                  const int Q1D,
+                                  const bool symmetric,
+                                  const int NE,
+                                  const Array<double> &bo,
+                                  const Array<double> &bc,
+                                  const Array<double> &go,
+                                  const Array<double> &gc,
+                                  const Vector &pa_data,
+                                  Vector &diag)
+{
+   constexpr static int VDIM = 3;
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Go = Reshape(go.Read(), Q1D, D1D-1);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, (symmetric ? 6 : 9), NE);
+   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   const int s = symmetric ? 6 : 9;
+   const int i11 = 0;
+   const int i12 = 1;
+   const int i13 = 2;
+   const int i21 = symmetric ? i12 : 3;
+   const int i22 = symmetric ? 3 : 4;
+   const int i23 = symmetric ? 4 : 5;
+   const int i31 = symmetric ? i13 : 6;
+   const int i32 = symmetric ? i23 : 7;
+   const int i33 = symmetric ? 5 : 8;
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
+      // (\nabla\times u) \cdot (\nabla\times u) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{u}
+      // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+      // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+      // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+      // For each c, we will keep 9 arrays for derivatives multiplied by the 9 entries of the 3x3 matrix (dF^T C dF),
+      // which may be non-symmetric depending on a possibly non-symmetric matrix coefficient.
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         double zt[MAX_Q1D][MAX_Q1D][MAX_D1D][9][3];
+
+         // z contraction
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  for (int i=0; i<s; ++i)
+                  {
+                     for (int d=0; d<3; ++d)
+                     {
+                        zt[qx][qy][dz][i][d] = 0.0;
+                     }
+                  }
+
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     const double wz = ((c == 2) ? Bo(qz,dz) : Bc(qz,dz));
+                     const double wDz = ((c == 2) ? Go(qz,dz) : Gc(qz,dz));
+
+                     for (int i=0; i<s; ++i)
+                     {
+                        zt[qx][qy][dz][i][0] += wz * wz * op(qx,qy,qz,i,e);
+                        zt[qx][qy][dz][i][1] += wDz * wz * op(qx,qy,qz,i,e);
+                        zt[qx][qy][dz][i][2] += wDz * wDz * op(qx,qy,qz,i,e);
+                     }
+                  }
+               }
+            }
+         }  // end of z contraction
+
+         double yt[MAX_Q1D][MAX_D1D][MAX_D1D][9][3][3];
+
+         // y contraction
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int i=0; i<s; ++i)
+                  {
+                     for (int d=0; d<3; ++d)
+                        for (int j=0; j<3; ++j)
+                        {
+                           yt[qx][dy][dz][i][d][j] = 0.0;
+                        }
+                  }
+
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wy = ((c == 1) ? Bo(qy,dy) : Bc(qy,dy));
+                     const double wDy = ((c == 1) ? Go(qy,dy) : Gc(qy,dy));
+
+                     for (int i=0; i<s; ++i)
+                     {
+                        for (int d=0; d<3; ++d)
+                        {
+                           yt[qx][dy][dz][i][d][0] += wy * wy * zt[qx][qy][dz][i][d];
+                           yt[qx][dy][dz][i][d][1] += wDy * wy * zt[qx][qy][dz][i][d];
+                           yt[qx][dy][dz][i][d][2] += wDy * wDy * zt[qx][qy][dz][i][d];
+                        }
+                     }
+                  }
+               }
+            }
+         }  // end of y contraction
+
+         // x contraction
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+                     const double wDx = ((c == 0) ? Go(qx,dx) : Gc(qx,dx));
+
+                     // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
+                     // (\nabla\times u) \cdot (\nabla\times u) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{u}
+                     // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                     // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                     // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+                     /*
+                       const double O11 = op(q,0,e);
+                       const double O12 = op(q,1,e);
+                       const double O13 = op(q,2,e);
+                       const double O22 = op(q,3,e);
+                       const double O23 = op(q,4,e);
+                       const double O33 = op(q,5,e);
+                     */
+
+                     if (c == 0)
+                     {
+                        // (u_0)_{x_2} (O22 (u_0)_{x_2} - O23 (u_0)_{x_1}) - (u_0)_{x_1} (O32 (u_0)_{x_2} - O33 (u_0)_{x_1})
+                        const double sumy = yt[qx][dy][dz][i22][2][0] - yt[qx][dy][dz][i23][1][1]
+                                            - yt[qx][dy][dz][i32][1][1] + yt[qx][dy][dz][i33][0][2];
+
+                        D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += sumy * wx * wx;
+                     }
+                     else if (c == 1)
+                     {
+                        // (u_1)_{x_2} (O11 (u_1)_{x_2} - O13 (u_1)_{x_0}) + (u_1)_{x_0} (-O31 (u_1)_{x_2} + O33 (u_1)_{x_0})
+                        const double d = (yt[qx][dy][dz][i11][2][0] * wx * wx)
+                                         - ((yt[qx][dy][dz][i13][1][0] + yt[qx][dy][dz][i31][1][0]) * wDx * wx)
+                                         + (yt[qx][dy][dz][i33][0][0] * wDx * wDx);
+
+                        D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += d;
+                     }
+                     else
+                     {
+                        // (u_2)_{x_1} (O11 (u_2)_{x_1} - O12 (u_2)_{x_0}) - (u_2)_{x_0} (O21 (u_2)_{x_1} - O22 (u_2)_{x_0})
+                        const double d = (yt[qx][dy][dz][i11][0][2] * wx * wx)
+                                         - ((yt[qx][dy][dz][i12][0][1] + yt[qx][dy][dz][i21][0][1]) * wDx * wx)
+                                         + (yt[qx][dy][dz][i22][0][0] * wDx * wDx);
+
+                        D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += d;
+                     }
+                  }
+               }
+            }
+         }  // end of x contraction
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop c
+   }); // end of element loop
+}
+
+template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
+MFEM_HOST_DEVICE inline
+void SmemPACurlCurlAssembleDiagonal3D(const int D1D,
+                                      const int Q1D,
+                                      const bool symmetric,
+                                      const int NE,
+                                      const Array<double> &bo,
+                                      const Array<double> &bc,
+                                      const Array<double> &go,
+                                      const Array<double> &gc,
+                                      const Vector &pa_data,
+                                      Vector &diag)
+{
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Go = Reshape(go.Read(), Q1D, D1D-1);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, (symmetric ? 6 : 9), NE);
+   auto D = Reshape(diag.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   const int s = symmetric ? 6 : 9;
+   const int i11 = 0;
+   const int i12 = 1;
+   const int i13 = 2;
+   const int i21 = symmetric ? i12 : 3;
+   const int i22 = symmetric ? 3 : 4;
+   const int i23 = symmetric ? 4 : 5;
+   const int i31 = symmetric ? i13 : 6;
+   const int i32 = symmetric ? i23 : 7;
+   const int i33 = symmetric ? 5 : 8;
+
+   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
+      // (\nabla\times u) \cdot (\nabla\times u) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{u}
+      // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+      // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+      // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+      constexpr int VDIM = 3;
+
+      MFEM_SHARED double sBo[MAX_Q1D][MAX_D1D];
+      MFEM_SHARED double sBc[MAX_Q1D][MAX_D1D];
+      MFEM_SHARED double sGo[MAX_Q1D][MAX_D1D];
+      MFEM_SHARED double sGc[MAX_Q1D][MAX_D1D];
+
+      double ope[9];
+      MFEM_SHARED double sop[9][MAX_Q1D][MAX_Q1D];
+
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               for (int i=0; i<s; ++i)
+               {
+                  ope[i] = op(qx,qy,qz,i,e);
+               }
+            }
+         }
+      }
+
+      const int tidx = MFEM_THREAD_ID(x);
+      const int tidy = MFEM_THREAD_ID(y);
+      const int tidz = MFEM_THREAD_ID(z);
+
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               sBc[q][d] = Bc(q,d);
+               sGc[q][d] = Gc(q,d);
+               if (d < D1D-1)
+               {
+                  sBo[q][d] = Bo(q,d);
+                  sGo[q][d] = Go(q,d);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+
+      int osc = 0;
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         double dxyz = 0.0;
+
+         for (int qz=0; qz < Q1D; ++qz)
+         {
+            if (tidz == qz)
+            {
+               for (int i=0; i<s; ++i)
+               {
+                  sop[i][tidx][tidy] = ope[i];
+               }
+            }
+
+            MFEM_SYNC_THREAD;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               const double wz = ((c == 2) ? sBo[qz][dz] : sBc[qz][dz]);
+               const double wDz = ((c == 2) ? sGo[qz][dz] : sGc[qz][dz]);
+
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     for (int qy = 0; qy < Q1D; ++qy)
+                     {
+                        const double wy = ((c == 1) ? sBo[qy][dy] : sBc[qy][dy]);
+                        const double wDy = ((c == 1) ? sGo[qy][dy] : sGc[qy][dy]);
+
+                        for (int qx = 0; qx < Q1D; ++qx)
+                        {
+                           const double wx = ((c == 0) ? sBo[qx][dx] : sBc[qx][dx]);
+                           const double wDx = ((c == 0) ? sGo[qx][dx] : sGc[qx][dx]);
+
+                           if (c == 0)
+                           {
+                              // (u_0)_{x_2} (O22 (u_0)_{x_2} - O23 (u_0)_{x_1}) - (u_0)_{x_1} (O32 (u_0)_{x_2} - O33 (u_0)_{x_1})
+
+                              // (u_0)_{x_2} O22 (u_0)_{x_2}
+                              dxyz += sop[i22][qx][qy] * wx * wx * wy * wy * wDz * wDz;
+
+                              // -(u_0)_{x_2} O23 (u_0)_{x_1} - (u_0)_{x_1} O32 (u_0)_{x_2}
+                              dxyz += -(sop[i23][qx][qy] + sop[i32][qx][qy]) * wx * wx * wDy * wy * wDz * wz;
+
+                              // (u_0)_{x_1} O33 (u_0)_{x_1}
+                              dxyz += sop[i33][qx][qy] * wx * wx * wDy * wDy * wz * wz;
+                           }
+                           else if (c == 1)
+                           {
+                              // (u_1)_{x_2} (O11 (u_1)_{x_2} - O13 (u_1)_{x_0}) + (u_1)_{x_0} (-O31 (u_1)_{x_2} + O33 (u_1)_{x_0})
+
+                              // (u_1)_{x_2} O11 (u_1)_{x_2}
+                              dxyz += sop[i11][qx][qy] * wx * wx * wy * wy * wDz * wDz;
+
+                              // -(u_1)_{x_2} O13 (u_1)_{x_0} - (u_1)_{x_0} O31 (u_1)_{x_2}
+                              dxyz += -(sop[i13][qx][qy] + sop[i31][qx][qy]) * wDx * wx * wy * wy * wDz * wz;
+
+                              // (u_1)_{x_0} O33 (u_1)_{x_0})
+                              dxyz += sop[i33][qx][qy] * wDx * wDx * wy * wy * wz * wz;
+                           }
+                           else
+                           {
+                              // (u_2)_{x_1} (O11 (u_2)_{x_1} - O12 (u_2)_{x_0}) - (u_2)_{x_0} (O21 (u_2)_{x_1} - O22 (u_2)_{x_0})
+
+                              // (u_2)_{x_1} O11 (u_2)_{x_1}
+                              dxyz += sop[i11][qx][qy] * wx * wx * wDy * wDy * wz * wz;
+
+                              // -(u_2)_{x_1} O12 (u_2)_{x_0} - (u_2)_{x_0} O21 (u_2)_{x_1}
+                              dxyz += -(sop[i12][qx][qy] + sop[i21][qx][qy]) * wDx * wx * wDy * wy * wz * wz;
+
+                              // (u_2)_{x_0} O22 (u_2)_{x_0}
+                              dxyz += sop[i22][qx][qy] * wDx * wDx * wy * wy * wz * wz;
+                           }
+                        }
+                     }
+                  }
+               }
+            }
+
+            MFEM_SYNC_THREAD;
+         }  // qz loop
+
+         MFEM_FOREACH_THREAD(dz,z,D1Dz)
+         {
+            MFEM_FOREACH_THREAD(dy,y,D1Dy)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1Dx)
+               {
+                  D(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += dxyz;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // c loop
+   }); // end of element loop
+}
+
+MFEM_HOST_DEVICE inline
+void PACurlCurlApply2D(const int D1D,
+                       const int Q1D,
+                       const int NE,
+                       const Array<double> &bo,
+                       const Array<double> &bot,
+                       const Array<double> &gc,
+                       const Array<double> &gct,
+                       const Vector &pa_data,
+                       const Vector &x,
+                       Vector &y)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto Gct = Reshape(gct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
+   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double curl[MAX_Q1D][MAX_Q1D];
+
+      // curl[qy][qx] will be computed as du_y/dx - du_x/dy
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            curl[qy][qx] = 0.0;
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            double gradX[MAX_Q1D];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               gradX[qx] = 0;
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double t = X(dx + (dy * D1Dx) + osc, e);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  gradX[qx] += t * ((c == 0) ? Bo(qx,dx) : Gc(qx,dx));
+               }
+            }
+
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const double wy = (c == 0) ? -Gc(qy,dy) : Bo(qy,dy);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  curl[qy][qx] += gradX[qx] * wy;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            curl[qy][qx] *= op(qx,qy,e);
+         }
+      }
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+         {
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            double gradX[MAX_D1D];
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               gradX[dx] = 0.0;
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradX[dx] += curl[qy][qx] * ((c == 0) ? Bot(dx,qx) : Gct(dx,qx));
+               }
+            }
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               const double wy = (c == 0) ? -Gct(dy,qy) : Bot(dy,qy);
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  Y(dx + (dy * D1Dx) + osc, e) += gradX[dx] * wy;
+               }
+            }
+
+            osc += D1Dx * D1Dy;
+         }  // loop c
+      }  // loop qy
+   }); // end of element loop
+}
+
+template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
+MFEM_HOST_DEVICE inline
+void PACurlCurlApply3D(const int D1D,
+                       const int Q1D,
+                       const bool symmetric,
+                       const int NE,
+                       const Array<double> &bo,
+                       const Array<double> &bc,
+                       const Array<double> &bot,
+                       const Array<double> &bct,
+                       const Array<double> &gc,
+                       const Array<double> &gct,
+                       const Vector &pa_data,
+                       const Vector &x,
+                       Vector &y)
+{
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+   // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk),
+   // we get:
+   // (\nabla\times u) \cdot (\nabla\times v)
+   //     = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{v}
+   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1D, Q1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto Gct = Reshape(gct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, (symmetric ? 6 : 9), NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double curl[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
+      // curl[qz][qy][qx] will be computed as the vector curl at each quadrature point.
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  curl[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      // We treat x, y, z components separately for optimization specific to each.
+
+      int osc = 0;
+
+      {
+         // x component
+         const int D1Dz = D1D;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D - 1;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double gradXY[MAX_Q1D][MAX_Q1D][2];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradXY[qy][qx][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MAX_Q1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * Bo(qx,dx);
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = Bc(qy,dy);
+                  const double wDy = Gc(qy,dy);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     gradXY[qy][qx][0] += wx * wDy;
+                     gradXY[qy][qx][1] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = Bc(qz,dz);
+               const double wDz = Gc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                     curl[qz][qy][qx][1] += gradXY[qy][qx][1] * wDz; // (u_0)_{x_2}
+                     curl[qz][qy][qx][2] -= gradXY[qy][qx][0] * wz;  // -(u_0)_{x_1}
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      {
+         // y component
+         const int D1Dz = D1D;
+         const int D1Dy = D1D - 1;
+         const int D1Dx = D1D;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double gradXY[MAX_Q1D][MAX_Q1D][2];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradXY[qy][qx][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               double massY[MAX_Q1D];
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  massY[qy] = 0.0;
+               }
+
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     massY[qy] += t * Bo(qy,dy);
+                  }
+               }
+
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx = Bc(qx,dx);
+                  const double wDx = Gc(qx,dx);
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wy = massY[qy];
+                     gradXY[qy][qx][0] += wDx * wy;
+                     gradXY[qy][qx][1] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = Bc(qz,dz);
+               const double wDz = Gc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                     curl[qz][qy][qx][0] -= gradXY[qy][qx][1] * wDz; // -(u_1)_{x_2}
+                     curl[qz][qy][qx][2] += gradXY[qy][qx][0] * wz;  // (u_1)_{x_0}
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      {
+         // z component
+         const int D1Dz = D1D - 1;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D;
+
+         for (int dx = 0; dx < D1Dx; ++dx)
+         {
+            double gradYZ[MAX_Q1D][MAX_Q1D][2];
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradYZ[qz][qy][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massZ[MAX_Q1D];
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  massZ[qz] = 0.0;
+               }
+
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     massZ[qz] += t * Bo(qz,dz);
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = Bc(qy,dy);
+                  const double wDy = Gc(qy,dy);
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     const double wz = massZ[qz];
+                     gradYZ[qz][qy][0] += wz * wy;
+                     gradYZ[qz][qy][1] += wz * wDy;
+                  }
+               }
+            }
+
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double wx = Bc(qx,dx);
+               const double wDx = Gc(qx,dx);
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+                     curl[qz][qy][qx][0] += gradYZ[qz][qy][1] * wx;  // (u_2)_{x_1}
+                     curl[qz][qy][qx][1] -= gradYZ[qz][qy][0] * wDx; // -(u_2)_{x_0}
+                  }
+               }
+            }
+         }
+      }
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(qx,qy,qz,0,e);
+               const double O12 = op(qx,qy,qz,1,e);
+               const double O13 = op(qx,qy,qz,2,e);
+               const double O21 = symmetric ? O12 : op(qx,qy,qz,3,e);
+               const double O22 = symmetric ? op(qx,qy,qz,3,e) : op(qx,qy,qz,4,e);
+               const double O23 = symmetric ? op(qx,qy,qz,4,e) : op(qx,qy,qz,5,e);
+               const double O31 = symmetric ? O13 : op(qx,qy,qz,6,e);
+               const double O32 = symmetric ? O23 : op(qx,qy,qz,7,e);
+               const double O33 = symmetric ? op(qx,qy,qz,5,e) : op(qx,qy,qz,8,e);
+
+               const double c1 = (O11 * curl[qz][qy][qx][0]) + (O12 * curl[qz][qy][qx][1]) +
+                                 (O13 * curl[qz][qy][qx][2]);
+               const double c2 = (O21 * curl[qz][qy][qx][0]) + (O22 * curl[qz][qy][qx][1]) +
+                                 (O23 * curl[qz][qy][qx][2]);
+               const double c3 = (O31 * curl[qz][qy][qx][0]) + (O32 * curl[qz][qy][qx][1]) +
+                                 (O33 * curl[qz][qy][qx][2]);
+
+               curl[qz][qy][qx][0] = c1;
+               curl[qz][qy][qx][1] = c2;
+               curl[qz][qy][qx][2] = c3;
+            }
+         }
+      }
+
+      // x component
+      osc = 0;
+      {
+         const int D1Dz = D1D;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D - 1;
+
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            double gradXY12[MAX_D1D][MAX_D1D];
+            double gradXY21[MAX_D1D][MAX_D1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradXY12[dy][dx] = 0.0;
+                  gradXY21[dy][dx] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[MAX_D1D][2];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  for (int n = 0; n < 2; ++n)
+                  {
+                     massX[dx][n] = 0.0;
+                  }
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     const double wx = Bot(dx,qx);
+
+                     massX[dx][0] += wx * curl[qz][qy][qx][1];
+                     massX[dx][1] += wx * curl[qz][qy][qx][2];
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = Bct(dy,qy);
+                  const double wDy = Gct(dy,qy);
+
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     gradXY21[dy][dx] += massX[dx][0] * wy;
+                     gradXY12[dy][dx] += massX[dx][1] * wDy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = Bct(dz,qz);
+               const double wDz = Gct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                     // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (gradXY21[dy][dx] * wDz) - (gradXY12[dy][dx] * wz);
+                  }
+               }
+            }
+         }  // loop qz
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      // y component
+      {
+         const int D1Dz = D1D;
+         const int D1Dy = D1D - 1;
+         const int D1Dx = D1D;
+
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            double gradXY02[MAX_D1D][MAX_D1D];
+            double gradXY20[MAX_D1D][MAX_D1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradXY02[dy][dx] = 0.0;
+                  gradXY20[dy][dx] = 0.0;
+               }
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               double massY[MAX_D1D][2];
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  massY[dy][0] = 0.0;
+                  massY[dy][1] = 0.0;
+               }
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int dy = 0; dy < D1Dy; ++dy)
+                  {
+                     const double wy = Bot(dy,qy);
+
+                     massY[dy][0] += wy * curl[qz][qy][qx][2];
+                     massY[dy][1] += wy * curl[qz][qy][qx][0];
+                  }
+               }
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double wx = Bct(dx,qx);
+                  const double wDx = Gct(dx,qx);
+
+                  for (int dy = 0; dy < D1Dy; ++dy)
+                  {
+                     gradXY02[dy][dx] += massY[dy][0] * wDx;
+                     gradXY20[dy][dx] += massY[dy][1] * wx;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = Bct(dz,qz);
+               const double wDz = Gct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                     // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (-gradXY20[dy][dx] * wDz) + (gradXY02[dy][dx] * wz);
+                  }
+               }
+            }
+         }  // loop qz
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      // z component
+      {
+         const int D1Dz = D1D - 1;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D;
+
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            double gradYZ01[MAX_D1D][MAX_D1D];
+            double gradYZ10[MAX_D1D][MAX_D1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  gradYZ01[dz][dy] = 0.0;
+                  gradYZ10[dz][dy] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massZ[MAX_D1D][2];
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  for (int n = 0; n < 2; ++n)
+                  {
+                     massZ[dz][n] = 0.0;
+                  }
+               }
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     const double wz = Bot(dz,qz);
+
+                     massZ[dz][0] += wz * curl[qz][qy][qx][0];
+                     massZ[dz][1] += wz * curl[qz][qy][qx][1];
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = Bct(dy,qy);
+                  const double wDy = Gct(dy,qy);
+
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     gradYZ01[dz][dy] += wy * massZ[dz][1];
+                     gradYZ10[dz][dy] += wDy * massZ[dz][0];
+                  }
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double wx = Bct(dx,qx);
+               const double wDx = Gct(dx,qx);
+
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+                     // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (gradYZ10[dz][dy] * wx) - (gradYZ01[dz][dy] * wDx);
+                  }
+               }
+            }
+         }  // loop qx
+      }
+   }); // end of element loop
+}
+
+template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
+MFEM_HOST_DEVICE inline
+void SmemPACurlCurlApply3D(const int D1D,
+                           const int Q1D,
+                           const bool symmetric,
+                           const int NE,
+                           const Array<double> &bo,
+                           const Array<double> &bc,
+                           const Array<double> &bot,
+                           const Array<double> &bct,
+                           const Array<double> &gc,
+                           const Array<double> &gct,
+                           const Vector &pa_data,
+                           const Vector &x,
+                           Vector &y)
+{
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+   // Using (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get
+   // (\nabla\times u) \cdot (\nabla\times v) = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{\nabla}\times\hat{v}
+   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   const int s = symmetric ? 6 : 9;
+
+   auto device_kernel = [=] MFEM_DEVICE (int e)
+   {
+      constexpr int VDIM = 3;
+
+      MFEM_SHARED double sBo[MAX_D1D][MAX_Q1D];
+      MFEM_SHARED double sBc[MAX_D1D][MAX_Q1D];
+      MFEM_SHARED double sGc[MAX_D1D][MAX_Q1D];
+
+      double ope[9];
+      MFEM_SHARED double sop[9][MAX_Q1D][MAX_Q1D];
+      MFEM_SHARED double curl[MAX_Q1D][MAX_Q1D][3];
+
+      MFEM_SHARED double sX[MAX_D1D][MAX_D1D][MAX_D1D];
+
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               for (int i=0; i<s; ++i)
+               {
+                  ope[i] = op(qx,qy,qz,i,e);
+               }
+            }
+         }
+      }
+
+      const int tidx = MFEM_THREAD_ID(x);
+      const int tidy = MFEM_THREAD_ID(y);
+      const int tidz = MFEM_THREAD_ID(z);
+
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               sBc[d][q] = Bc(q,d);
+               sGc[d][q] = Gc(q,d);
+               if (d < D1D-1)
+               {
+                  sBo[d][q] = Bo(q,d);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+
+      for (int qz=0; qz < Q1D; ++qz)
+      {
+         if (tidz == qz)
+         {
+            MFEM_FOREACH_THREAD(qy,y,Q1D)
+            {
+               MFEM_FOREACH_THREAD(qx,x,Q1D)
+               {
+                  for (int i=0; i<3; ++i)
+                  {
+                     curl[qy][qx][i] = 0.0;
+                  }
+               }
+            }
+         }
+
+         int osc = 0;
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  }
+               }
+            }
+            MFEM_SYNC_THREAD;
+
+            if (tidz == qz)
+            {
+               if (c == 0)
+               {
+                  for (int i=0; i<s; ++i)
+                  {
+                     sop[i][tidx][tidy] = ope[i];
+                  }
+               }
+
+               MFEM_FOREACH_THREAD(qy,y,Q1D)
+               {
+                  MFEM_FOREACH_THREAD(qx,x,Q1D)
+                  {
+                     double u = 0.0;
+                     double v = 0.0;
+
+                     // We treat x, y, z components separately for optimization specific to each.
+                     if (c == 0) // x component
+                     {
+                        // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+
+                        for (int dz = 0; dz < D1Dz; ++dz)
+                        {
+                           const double wz = sBc[dz][qz];
+                           const double wDz = sGc[dz][qz];
+
+                           for (int dy = 0; dy < D1Dy; ++dy)
+                           {
+                              const double wy = sBc[dy][qy];
+                              const double wDy = sGc[dy][qy];
+
+                              for (int dx = 0; dx < D1Dx; ++dx)
+                              {
+                                 const double wx = sX[dz][dy][dx] * sBo[dx][qx];
+                                 u += wx * wDy * wz;
+                                 v += wx * wy * wDz;
+                              }
+                           }
+                        }
+
+                        curl[qy][qx][1] += v; // (u_0)_{x_2}
+                        curl[qy][qx][2] -= u;  // -(u_0)_{x_1}
+                     }
+                     else if (c == 1)  // y component
+                     {
+                        // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+
+                        for (int dz = 0; dz < D1Dz; ++dz)
+                        {
+                           const double wz = sBc[dz][qz];
+                           const double wDz = sGc[dz][qz];
+
+                           for (int dy = 0; dy < D1Dy; ++dy)
+                           {
+                              const double wy = sBo[dy][qy];
+
+                              for (int dx = 0; dx < D1Dx; ++dx)
+                              {
+                                 const double t = sX[dz][dy][dx];
+                                 const double wx = t * sBc[dx][qx];
+                                 const double wDx = t * sGc[dx][qx];
+
+                                 u += wDx * wy * wz;
+                                 v += wx * wy * wDz;
+                              }
+                           }
+                        }
+
+                        curl[qy][qx][0] -= v; // -(u_1)_{x_2}
+                        curl[qy][qx][2] += u; // (u_1)_{x_0}
+                     }
+                     else // z component
+                     {
+                        // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+                        for (int dz = 0; dz < D1Dz; ++dz)
+                        {
+                           const double wz = sBo[dz][qz];
+
+                           for (int dy = 0; dy < D1Dy; ++dy)
+                           {
+                              const double wy = sBc[dy][qy];
+                              const double wDy = sGc[dy][qy];
+
+                              for (int dx = 0; dx < D1Dx; ++dx)
+                              {
+                                 const double t = sX[dz][dy][dx];
+                                 const double wx = t * sBc[dx][qx];
+                                 const double wDx = t * sGc[dx][qx];
+
+                                 u += wDx * wy * wz;
+                                 v += wx * wDy * wz;
+                              }
+                           }
+                        }
+
+                        curl[qy][qx][0] += v; // (u_2)_{x_1}
+                        curl[qy][qx][1] -= u; // -(u_2)_{x_0}
+                     }
+                  } // qx
+               } // qy
+            } // tidz == qz
+
+            osc += D1Dx * D1Dy * D1Dz;
+            MFEM_SYNC_THREAD;
+         } // c
+
+         double dxyz1 = 0.0;
+         double dxyz2 = 0.0;
+         double dxyz3 = 0.0;
+
+         MFEM_FOREACH_THREAD(dz,z,D1D)
+         {
+            const double wcz = sBc[dz][qz];
+            const double wcDz = sGc[dz][qz];
+            const double wz = (dz < D1D-1) ? sBo[dz][qz] : 0.0;
+
+            MFEM_FOREACH_THREAD(dy,y,D1D)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1D)
+               {
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wcy = sBc[dy][qy];
+                     const double wcDy = sGc[dy][qy];
+                     const double wy = (dy < D1D-1) ? sBo[dy][qy] : 0.0;
+
+                     for (int qx = 0; qx < Q1D; ++qx)
+                     {
+                        const double O11 = sop[0][qx][qy];
+                        const double O12 = sop[1][qx][qy];
+                        const double O13 = sop[2][qx][qy];
+                        const double O21 = symmetric ? O12 : sop[3][qx][qy];
+                        const double O22 = symmetric ? sop[3][qx][qy] : sop[4][qx][qy];
+                        const double O23 = symmetric ? sop[4][qx][qy] : sop[5][qx][qy];
+                        const double O31 = symmetric ? O13 : sop[6][qx][qy];
+                        const double O32 = symmetric ? O23 : sop[7][qx][qy];
+                        const double O33 = symmetric ? sop[5][qx][qy] : sop[8][qx][qy];
+
+                        const double c1 = (O11 * curl[qy][qx][0]) + (O12 * curl[qy][qx][1]) +
+                                          (O13 * curl[qy][qx][2]);
+                        const double c2 = (O21 * curl[qy][qx][0]) + (O22 * curl[qy][qx][1]) +
+                                          (O23 * curl[qy][qx][2]);
+                        const double c3 = (O31 * curl[qy][qx][0]) + (O32 * curl[qy][qx][1]) +
+                                          (O33 * curl[qy][qx][2]);
+
+                        const double wcx = sBc[dx][qx];
+                        const double wDx = sGc[dx][qx];
+
+                        if (dx < D1D-1)
+                        {
+                           // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                           // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
+                           const double wx = sBo[dx][qx];
+                           dxyz1 += (wx * c2 * wcy * wcDz) - (wx * c3 * wcDy * wcz);
+                        }
+
+                        // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                        // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
+                        dxyz2 += (-wy * c1 * wcx * wcDz) + (wy * c3 * wDx * wcz);
+
+                        // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+                        // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
+                        dxyz3 += (wcDy * wz * c1 * wcx) - (wcy * wz * c2 * wDx);
+                     } // qx
+                  } // qy
+               } // dx
+            } // dy
+         } // dz
+
+         MFEM_SYNC_THREAD;
+
+         MFEM_FOREACH_THREAD(dz,z,D1D)
+         {
+            MFEM_FOREACH_THREAD(dy,y,D1D)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1D)
+               {
+                  if (dx < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * D1D)) * (D1D-1)), e) += dxyz1;
+                  }
+                  if (dy < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * (D1D-1))) * D1D) + ((D1D-1)*D1D*D1D), e) += dxyz2;
+                  }
+                  if (dz < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * D1D)) * D1D) + (2*(D1D-1)*D1D*D1D), e) += dxyz3;
+                  }
+               }
+            }
+         }
+      } // qz
+   }; // end of element loop
+
+   auto host_kernel = [&] MFEM_LAMBDA (int)
+   {
+      MFEM_ABORT_KERNEL("This kernel should only be used on GPU.");
+   };
+
+   ForallWrap<3>(true, NE, device_kernel, host_kernel, Q1D, Q1D, Q1D);
+}
+
+// PA H(curl)-L2 assemble 2D kernel
+MFEM_HOST_DEVICE inline
+void PAHcurlL2Setup2D(const int Q1D,
+                      const int NE,
+                      const Array<double> &w,
+                      Vector &coeff,
+                      Vector &op)
+{
+   const int NQ = Q1D*Q1D;
+   auto W = w.Read();
+   auto C = Reshape(coeff.Read(), NQ, NE);
+   auto y = Reshape(op.Write(), NQ, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      for (int q = 0; q < NQ; ++q)
+      {
+         y(q,e) = W[q] * C(q,e);
+      }
+   });
+}
+
+// PA H(curl) Mass Assemble 3D kernel
+MFEM_HOST_DEVICE inline
+void PAHcurlL2Setup3D(const int NQ,
+                      const int coeffDim,
+                      const int NE,
+                      const Array<double> &w,
+                      Vector &coeff,
+                      Vector &op)
+{
+   auto W = w.Read();
+   auto C = Reshape(coeff.Read(), coeffDim, NQ, NE);
+   auto y = Reshape(op.Write(), coeffDim, NQ, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      for (int q = 0; q < NQ; ++q)
+      {
+         for (int c=0; c<coeffDim; ++c)
+         {
+            y(c,q,e) = W[q] * C(c,q,e);
+         }
+      }
+   });
+}
+
+MFEM_HOST_DEVICE inline
+void PAHcurlL2Apply2D(const int D1D,
+                      const int D1Dtest,
+                      const int Q1D,
+                      const int NE,
+                      const Array<double> &bo,
+                      const Array<double> &bot,
+                      const Array<double> &bt,
+                      const Array<double> &gc,
+                      const Vector &pa_data,
+                      const Vector &x, // trial = H(curl)
+                      Vector &y)  // test = L2 or H1
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+   const int H1 = (D1Dtest == D1D);
+
+   MFEM_VERIFY(y.Size() == NE*D1Dtest*D1Dtest, "Test vector of wrong dimension");
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bt = Reshape(bt.Read(), D1D, Q1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
+   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), D1Dtest, D1Dtest, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double curl[MAX_Q1D][MAX_Q1D];
+
+      // curl[qy][qx] will be computed as du_y/dx - du_x/dy
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            curl[qy][qx] = 0.0;
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            double gradX[MAX_Q1D];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               gradX[qx] = 0;
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double t = X(dx + (dy * D1Dx) + osc, e);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  gradX[qx] += t * ((c == 0) ? Bo(qx,dx) : Gc(qx,dx));
+               }
+            }
+
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const double wy = (c == 0) ? -Gc(qy,dy) : Bo(qy,dy);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  curl[qy][qx] += gradX[qx] * wy;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            curl[qy][qx] *= op(qx,qy,e);
+         }
+      }
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         double sol_x[MAX_D1D];
+         for (int dx = 0; dx < D1Dtest; ++dx)
+         {
+            sol_x[dx] = 0.0;
+         }
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            const double s = curl[qy][qx];
+            for (int dx = 0; dx < D1Dtest; ++dx)
+            {
+               sol_x[dx] += s * ((H1 == 1) ? Bt(dx,qx) : Bot(dx,qx));
+            }
+         }
+         for (int dy = 0; dy < D1Dtest; ++dy)
+         {
+            const double wy = (H1 == 1) ? Bt(dy,qy) : Bot(dy,qy);
+
+            for (int dx = 0; dx < D1Dtest; ++dx)
+            {
+               Y(dx,dy,e) += sol_x[dx] * wy;
+            }
+         }
+      }  // loop qy
+   }); // end of element loop
+}
+
+MFEM_HOST_DEVICE inline
+void PAHcurlL2ApplyTranspose2D(const int D1D,
+                               const int D1Dtest,
+                               const int Q1D,
+                               const int NE,
+                               const Array<double> &bo,
+                               const Array<double> &bot,
+                               const Array<double> &b,
+                               const Array<double> &gct,
+                               const Vector &pa_data,
+                               const Vector &x, // trial = H(curl)
+                               Vector &y)  // test = L2 or H1
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+   const int H1 = (D1Dtest == D1D);
+
+   MFEM_VERIFY(x.Size() == NE*D1Dtest*D1Dtest, "Test vector of wrong dimension");
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto B = Reshape(b.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Gct = Reshape(gct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, NE);
+   auto X = Reshape(x.Read(), D1Dtest, D1Dtest, NE);
+   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D];
+
+      // Zero-order term in L2 or H1 test space
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            mass[qy][qx] = 0.0;
+         }
+      }
+
+      for (int dy = 0; dy < D1Dtest; ++dy)
+      {
+         double sol_x[MAX_Q1D];
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            sol_x[qy] = 0.0;
+         }
+         for (int dx = 0; dx < D1Dtest; ++dx)
+         {
+            const double s = X(dx,dy,e);
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               sol_x[qx] += s * ((H1 == 1) ? B(qx,dx) : Bo(qx,dx));
+            }
+         }
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            const double d2q = (H1 == 1) ? B(qy,dy) : Bo(qy,dy);
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               mass[qy][qx] += d2q * sol_x[qx];
+            }
+         }
+      }
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            mass[qy][qx] *= op(qx,qy,e);
+         }
+      }
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         int osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+         {
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            double gradX[MAX_D1D];
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               gradX[dx] = 0.0;
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradX[dx] += mass[qy][qx] * ((c == 0) ? Bot(dx,qx) : Gct(dx,qx));
+               }
+            }
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               const double wy = (c == 0) ? -Gct(dy,qy) : Bot(dy,qy);
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  Y(dx + (dy * D1Dx) + osc, e) += gradX[dx] * wy;
+               }
+            }
+
+            osc += D1Dx * D1Dy;
+         }  // loop c
+      }  // loop qy
+   }); // end of element loop
+}
+
+// Apply to x corresponding to DOFs in H(curl) (trial), whose curl is
+// integrated against H(curl) test functions corresponding to y.
+template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
+MFEM_HOST_DEVICE inline
+void PAHcurlL2Apply3D(const int D1D,
+                      const int Q1D,
+                      const int coeffDim,
+                      const int NE,
+                      const Array<double> &bo,
+                      const Array<double> &bc,
+                      const Array<double> &bot,
+                      const Array<double> &bct,
+                      const Array<double> &gc,
+                      const Vector &pa_data,
+                      const Vector &x,
+                      Vector &y)
+{
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+   // Using u = dF^{-T} \hat{u} and (\nabla\times u) F =
+   // 1/det(dF) dF \hat{\nabla}\times\hat{u} (p. 78 of Monk), we get:
+   // (\nabla\times u) \cdot v
+   //    = 1/det(dF) \hat{\nabla}\times\hat{u}^T dF^T dF^{-T} \hat{v}
+   //    = 1/det(dF) \hat{\nabla}\times\hat{u}^T \hat{v}
+   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1D, Q1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double curl[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
+      // curl[qz][qy][qx] will be computed as the vector curl at each quadrature point.
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  curl[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      // We treat x, y, z components separately for optimization specific to each.
+
+      int osc = 0;
+
+      {
+         // x component
+         const int D1Dz = D1D;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D - 1;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double gradXY[MAX_Q1D][MAX_Q1D][2];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradXY[qy][qx][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MAX_Q1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * Bo(qx,dx);
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = Bc(qy,dy);
+                  const double wDy = Gc(qy,dy);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     gradXY[qy][qx][0] += wx * wDy;
+                     gradXY[qy][qx][1] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = Bc(qz,dz);
+               const double wDz = Gc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                     curl[qz][qy][qx][1] += gradXY[qy][qx][1] * wDz; // (u_0)_{x_2}
+                     curl[qz][qy][qx][2] -= gradXY[qy][qx][0] * wz;  // -(u_0)_{x_1}
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      {
+         // y component
+         const int D1Dz = D1D;
+         const int D1Dy = D1D - 1;
+         const int D1Dx = D1D;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double gradXY[MAX_Q1D][MAX_Q1D][2];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradXY[qy][qx][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               double massY[MAX_Q1D];
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  massY[qy] = 0.0;
+               }
+
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     massY[qy] += t * Bo(qy,dy);
+                  }
+               }
+
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx = Bc(qx,dx);
+                  const double wDx = Gc(qx,dx);
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wy = massY[qy];
+                     gradXY[qy][qx][0] += wDx * wy;
+                     gradXY[qy][qx][1] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = Bc(qz,dz);
+               const double wDz = Gc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                     curl[qz][qy][qx][0] -= gradXY[qy][qx][1] * wDz; // -(u_1)_{x_2}
+                     curl[qz][qy][qx][2] += gradXY[qy][qx][0] * wz;  // (u_1)_{x_0}
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      {
+         // z component
+         const int D1Dz = D1D - 1;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D;
+
+         for (int dx = 0; dx < D1Dx; ++dx)
+         {
+            double gradYZ[MAX_Q1D][MAX_Q1D][2];
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradYZ[qz][qy][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massZ[MAX_Q1D];
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  massZ[qz] = 0.0;
+               }
+
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     massZ[qz] += t * Bo(qz,dz);
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = Bc(qy,dy);
+                  const double wDy = Gc(qy,dy);
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     const double wz = massZ[qz];
+                     gradYZ[qz][qy][0] += wz * wy;
+                     gradYZ[qz][qy][1] += wz * wDy;
+                  }
+               }
+            }
+
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double wx = Bc(qx,dx);
+               const double wDx = Gc(qx,dx);
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+                     curl[qz][qy][qx][0] += gradYZ[qz][qy][1] * wx;  // (u_2)_{x_1}
+                     curl[qz][qy][qx][1] -= gradYZ[qz][qy][0] * wDx; // -(u_2)_{x_0}
+                  }
+               }
+            }
+         }
+      }
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(0,qx,qy,qz,e);
+               if (coeffDim == 1)
+               {
+                  for (int c = 0; c < VDIM; ++c)
+                  {
+                     curl[qz][qy][qx][c] *= O11;
+                  }
+               }
+               else
+               {
+                  const double O21 = op(1,qx,qy,qz,e);
+                  const double O31 = op(2,qx,qy,qz,e);
+                  const double O12 = op(3,qx,qy,qz,e);
+                  const double O22 = op(4,qx,qy,qz,e);
+                  const double O32 = op(5,qx,qy,qz,e);
+                  const double O13 = op(6,qx,qy,qz,e);
+                  const double O23 = op(7,qx,qy,qz,e);
+                  const double O33 = op(8,qx,qy,qz,e);
+                  const double curlX = curl[qz][qy][qx][0];
+                  const double curlY = curl[qz][qy][qx][1];
+                  const double curlZ = curl[qz][qy][qx][2];
+                  curl[qz][qy][qx][0] = (O11*curlX)+(O12*curlY)+(O13*curlZ);
+                  curl[qz][qy][qx][1] = (O21*curlX)+(O22*curlY)+(O23*curlZ);
+                  curl[qz][qy][qx][2] = (O31*curlX)+(O32*curlY)+(O33*curlZ);
+               }
+            }
+         }
+      }
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         double massXY[MAX_D1D][MAX_D1D];
+
+         osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massXY[dy][dx] = 0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[MAX_D1D];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] = 0.0;
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massX[dx] += curl[qz][qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
+                  }
+               }
+
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massXY[dy][dx] += massX[dx] * wy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = (c == 2) ? Bot(dz,qz) : Bct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += massXY[dy][dx] * wz;
+                  }
+               }
+            }
+
+            osc += D1Dx * D1Dy * D1Dz;
+         }  // loop c
+      }  // loop qz
+   }); // end of element loop
+}
+
+// Apply to x corresponding to DOFs in H(curl) (trial), whose curl is
+// integrated against H(curl) test functions corresponding to y.
+template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
+MFEM_HOST_DEVICE inline
+void SmemPAHcurlL2Apply3D(const int D1D,
+                          const int Q1D,
+                          const int coeffDim,
+                          const int NE,
+                          const Array<double> &bo,
+                          const Array<double> &bc,
+                          const Array<double> &gc,
+                          const Vector &pa_data,
+                          const Vector &x,
+                          Vector &y)
+{
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   auto device_kernel = [=] MFEM_DEVICE (int e)
+   {
+      constexpr int VDIM = 3;
+      constexpr int maxCoeffDim = 9;
+
+      MFEM_SHARED double sBo[MAX_D1D][MAX_Q1D];
+      MFEM_SHARED double sBc[MAX_D1D][MAX_Q1D];
+      MFEM_SHARED double sGc[MAX_D1D][MAX_Q1D];
+
+      double opc[maxCoeffDim];
+      MFEM_SHARED double sop[maxCoeffDim][MAX_Q1D][MAX_Q1D];
+      MFEM_SHARED double curl[MAX_Q1D][MAX_Q1D][3];
+
+      MFEM_SHARED double sX[MAX_D1D][MAX_D1D][MAX_D1D];
+
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               for (int i=0; i<coeffDim; ++i)
+               {
+                  opc[i] = op(i,qx,qy,qz,e);
+               }
+            }
+         }
+      }
+
+      const int tidx = MFEM_THREAD_ID(x);
+      const int tidy = MFEM_THREAD_ID(y);
+      const int tidz = MFEM_THREAD_ID(z);
+
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               sBc[d][q] = Bc(q,d);
+               sGc[d][q] = Gc(q,d);
+               if (d < D1D-1)
+               {
+                  sBo[d][q] = Bo(q,d);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+
+      for (int qz=0; qz < Q1D; ++qz)
+      {
+         if (tidz == qz)
+         {
+            MFEM_FOREACH_THREAD(qy,y,Q1D)
+            {
+               MFEM_FOREACH_THREAD(qx,x,Q1D)
+               {
+                  for (int i=0; i<3; ++i)
+                  {
+                     curl[qy][qx][i] = 0.0;
+                  }
+               }
+            }
+         }
+
+         int osc = 0;
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  }
+               }
+            }
+            MFEM_SYNC_THREAD;
+
+            if (tidz == qz)
+            {
+               if (c == 0)
+               {
+                  for (int i=0; i<coeffDim; ++i)
+                  {
+                     sop[i][tidx][tidy] = opc[i];
+                  }
+               }
+
+               MFEM_FOREACH_THREAD(qy,y,Q1D)
+               {
+                  MFEM_FOREACH_THREAD(qx,x,Q1D)
+                  {
+                     double u = 0.0;
+                     double v = 0.0;
+
+                     // We treat x, y, z components separately for optimization specific to each.
+                     if (c == 0) // x component
+                     {
+                        // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+
+                        for (int dz = 0; dz < D1Dz; ++dz)
+                        {
+                           const double wz = sBc[dz][qz];
+                           const double wDz = sGc[dz][qz];
+
+                           for (int dy = 0; dy < D1Dy; ++dy)
+                           {
+                              const double wy = sBc[dy][qy];
+                              const double wDy = sGc[dy][qy];
+
+                              for (int dx = 0; dx < D1Dx; ++dx)
+                              {
+                                 const double wx = sX[dz][dy][dx] * sBo[dx][qx];
+                                 u += wx * wDy * wz;
+                                 v += wx * wy * wDz;
+                              }
+                           }
+                        }
+
+                        curl[qy][qx][1] += v; // (u_0)_{x_2}
+                        curl[qy][qx][2] -= u;  // -(u_0)_{x_1}
+                     }
+                     else if (c == 1)  // y component
+                     {
+                        // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+
+                        for (int dz = 0; dz < D1Dz; ++dz)
+                        {
+                           const double wz = sBc[dz][qz];
+                           const double wDz = sGc[dz][qz];
+
+                           for (int dy = 0; dy < D1Dy; ++dy)
+                           {
+                              const double wy = sBo[dy][qy];
+
+                              for (int dx = 0; dx < D1Dx; ++dx)
+                              {
+                                 const double t = sX[dz][dy][dx];
+                                 const double wx = t * sBc[dx][qx];
+                                 const double wDx = t * sGc[dx][qx];
+
+                                 u += wDx * wy * wz;
+                                 v += wx * wy * wDz;
+                              }
+                           }
+                        }
+
+                        curl[qy][qx][0] -= v; // -(u_1)_{x_2}
+                        curl[qy][qx][2] += u; // (u_1)_{x_0}
+                     }
+                     else // z component
+                     {
+                        // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+                        for (int dz = 0; dz < D1Dz; ++dz)
+                        {
+                           const double wz = sBo[dz][qz];
+
+                           for (int dy = 0; dy < D1Dy; ++dy)
+                           {
+                              const double wy = sBc[dy][qy];
+                              const double wDy = sGc[dy][qy];
+
+                              for (int dx = 0; dx < D1Dx; ++dx)
+                              {
+                                 const double t = sX[dz][dy][dx];
+                                 const double wx = t * sBc[dx][qx];
+                                 const double wDx = t * sGc[dx][qx];
+
+                                 u += wDx * wy * wz;
+                                 v += wx * wDy * wz;
+                              }
+                           }
+                        }
+
+                        curl[qy][qx][0] += v; // (u_2)_{x_1}
+                        curl[qy][qx][1] -= u; // -(u_2)_{x_0}
+                     }
+                  } // qx
+               } // qy
+            } // tidz == qz
+
+            osc += D1Dx * D1Dy * D1Dz;
+            MFEM_SYNC_THREAD;
+         } // c
+
+         double dxyz1 = 0.0;
+         double dxyz2 = 0.0;
+         double dxyz3 = 0.0;
+
+         MFEM_FOREACH_THREAD(dz,z,D1D)
+         {
+            const double wcz = sBc[dz][qz];
+            const double wz = (dz < D1D-1) ? sBo[dz][qz] : 0.0;
+
+            MFEM_FOREACH_THREAD(dy,y,D1D)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1D)
+               {
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wcy = sBc[dy][qy];
+                     const double wy = (dy < D1D-1) ? sBo[dy][qy] : 0.0;
+
+                     for (int qx = 0; qx < Q1D; ++qx)
+                     {
+                        const double O11 = sop[0][qx][qy];
+                        double c1, c2, c3;
+                        if (coeffDim == 1)
+                        {
+                           c1 = O11 * curl[qy][qx][0];
+                           c2 = O11 * curl[qy][qx][1];
+                           c3 = O11 * curl[qy][qx][2];
+                        }
+                        else
+                        {
+                           const double O21 = sop[1][qx][qy];
+                           const double O31 = sop[2][qx][qy];
+                           const double O12 = sop[3][qx][qy];
+                           const double O22 = sop[4][qx][qy];
+                           const double O32 = sop[5][qx][qy];
+                           const double O13 = sop[6][qx][qy];
+                           const double O23 = sop[7][qx][qy];
+                           const double O33 = sop[8][qx][qy];
+                           c1 = (O11*curl[qy][qx][0])+(O12*curl[qy][qx][1])+(O13*curl[qy][qx][2]);
+                           c2 = (O21*curl[qy][qx][0])+(O22*curl[qy][qx][1])+(O23*curl[qy][qx][2]);
+                           c3 = (O31*curl[qy][qx][0])+(O32*curl[qy][qx][1])+(O33*curl[qy][qx][2]);
+                        }
+
+                        const double wcx = sBc[dx][qx];
+
+                        if (dx < D1D-1)
+                        {
+                           const double wx = sBo[dx][qx];
+                           dxyz1 += c1 * wx * wcy * wcz;
+                        }
+
+                        dxyz2 += c2 * wcx * wy * wcz;
+                        dxyz3 += c3 * wcx * wcy * wz;
+                     } // qx
+                  } // qy
+               } // dx
+            } // dy
+         } // dz
+
+         MFEM_SYNC_THREAD;
+
+         MFEM_FOREACH_THREAD(dz,z,D1D)
+         {
+            MFEM_FOREACH_THREAD(dy,y,D1D)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1D)
+               {
+                  if (dx < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * D1D)) * (D1D-1)), e) += dxyz1;
+                  }
+                  if (dy < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * (D1D-1))) * D1D) + ((D1D-1)*D1D*D1D), e) += dxyz2;
+                  }
+                  if (dz < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * D1D)) * D1D) + (2*(D1D-1)*D1D*D1D), e) += dxyz3;
+                  }
+               }
+            }
+         }
+      } // qz
+   }; // end of element loop
+
+   auto host_kernel = [&] MFEM_LAMBDA (int)
+   {
+      MFEM_ABORT_KERNEL("This kernel should only be used on GPU.");
+   };
+
+   ForallWrap<3>(true, NE, device_kernel, host_kernel, Q1D, Q1D, Q1D);
+}
+
+// Apply to x corresponding to DOFs in H(curl) (trial), integrated against curl
+// of H(curl) test functions corresponding to y.
+template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
+MFEM_HOST_DEVICE inline
+void PAHcurlL2Apply3DTranspose(const int D1D,
+                               const int Q1D,
+                               const int coeffDim,
+                               const int NE,
+                               const Array<double> &bo,
+                               const Array<double> &bc,
+                               const Array<double> &bot,
+                               const Array<double> &bct,
+                               const Array<double> &gct,
+                               const Vector &pa_data,
+                               const Vector &x,
+                               Vector &y)
+{
+   // See PAHcurlL2Apply3D for comments.
+
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1D, Q1D);
+   auto Gct = Reshape(gct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  mass[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double massXY[MAX_Q1D][MAX_Q1D];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massXY[qy][qx] = 0.0;
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MAX_Q1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     massXY[qy][qx] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(0,qx,qy,qz,e);
+               if (coeffDim == 1)
+               {
+                  for (int c = 0; c < VDIM; ++c)
+                  {
+                     mass[qz][qy][qx][c] *= O11;
+                  }
+               }
+               else
+               {
+                  const double O12 = op(1,qx,qy,qz,e);
+                  const double O13 = op(2,qx,qy,qz,e);
+                  const double O21 = op(3,qx,qy,qz,e);
+                  const double O22 = op(4,qx,qy,qz,e);
+                  const double O23 = op(5,qx,qy,qz,e);
+                  const double O31 = op(6,qx,qy,qz,e);
+                  const double O32 = op(7,qx,qy,qz,e);
+                  const double O33 = op(8,qx,qy,qz,e);
+                  const double massX = mass[qz][qy][qx][0];
+                  const double massY = mass[qz][qy][qx][1];
+                  const double massZ = mass[qz][qy][qx][2];
+                  mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
+                  mass[qz][qy][qx][1] = (O21*massX)+(O22*massY)+(O23*massZ);
+                  mass[qz][qy][qx][2] = (O31*massX)+(O32*massY)+(O33*massZ);
+               }
+            }
+         }
+      }
+
+      // x component
+      osc = 0;
+      {
+         const int D1Dz = D1D;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D - 1;
+
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            double gradXY12[MAX_D1D][MAX_D1D];
+            double gradXY21[MAX_D1D][MAX_D1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradXY12[dy][dx] = 0.0;
+                  gradXY21[dy][dx] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[MAX_D1D][2];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  for (int n = 0; n < 2; ++n)
+                  {
+                     massX[dx][n] = 0.0;
+                  }
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     const double wx = Bot(dx,qx);
+
+                     massX[dx][0] += wx * mass[qz][qy][qx][1];
+                     massX[dx][1] += wx * mass[qz][qy][qx][2];
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = Bct(dy,qy);
+                  const double wDy = Gct(dy,qy);
+
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     gradXY21[dy][dx] += massX[dx][0] * wy;
+                     gradXY12[dy][dx] += massX[dx][1] * wDy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = Bct(dz,qz);
+               const double wDz = Gct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                     // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (gradXY21[dy][dx] * wDz) - (gradXY12[dy][dx] * wz);
+                  }
+               }
+            }
+         }  // loop qz
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      // y component
+      {
+         const int D1Dz = D1D;
+         const int D1Dy = D1D - 1;
+         const int D1Dx = D1D;
+
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            double gradXY02[MAX_D1D][MAX_D1D];
+            double gradXY20[MAX_D1D][MAX_D1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradXY02[dy][dx] = 0.0;
+                  gradXY20[dy][dx] = 0.0;
+               }
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               double massY[MAX_D1D][2];
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  massY[dy][0] = 0.0;
+                  massY[dy][1] = 0.0;
+               }
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int dy = 0; dy < D1Dy; ++dy)
+                  {
+                     const double wy = Bot(dy,qy);
+
+                     massY[dy][0] += wy * mass[qz][qy][qx][2];
+                     massY[dy][1] += wy * mass[qz][qy][qx][0];
+                  }
+               }
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double wx = Bct(dx,qx);
+                  const double wDx = Gct(dx,qx);
+
+                  for (int dy = 0; dy < D1Dy; ++dy)
+                  {
+                     gradXY02[dy][dx] += massY[dy][0] * wDx;
+                     gradXY20[dy][dx] += massY[dy][1] * wx;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = Bct(dz,qz);
+               const double wDz = Gct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                     // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (-gradXY20[dy][dx] * wDz) + (gradXY02[dy][dx] * wz);
+                  }
+               }
+            }
+         }  // loop qz
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      // z component
+      {
+         const int D1Dz = D1D - 1;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D;
+
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            double gradYZ01[MAX_D1D][MAX_D1D];
+            double gradYZ10[MAX_D1D][MAX_D1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  gradYZ01[dz][dy] = 0.0;
+                  gradYZ10[dz][dy] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massZ[MAX_D1D][2];
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  for (int n = 0; n < 2; ++n)
+                  {
+                     massZ[dz][n] = 0.0;
+                  }
+               }
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     const double wz = Bot(dz,qz);
+
+                     massZ[dz][0] += wz * mass[qz][qy][qx][0];
+                     massZ[dz][1] += wz * mass[qz][qy][qx][1];
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = Bct(dy,qy);
+                  const double wDy = Gct(dy,qy);
+
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     gradYZ01[dz][dy] += wy * massZ[dz][1];
+                     gradYZ10[dz][dy] += wDy * massZ[dz][0];
+                  }
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double wx = Bct(dx,qx);
+               const double wDx = Gct(dx,qx);
+
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+                     // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (gradYZ10[dz][dy] * wx) - (gradYZ01[dz][dy] * wDx);
+                  }
+               }
+            }
+         }  // loop qx
+      }
+   });
+}
+
+template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
+MFEM_HOST_DEVICE inline
+void SmemPAHcurlL2Apply3DTranspose(const int D1D,
+                                   const int Q1D,
+                                   const int coeffDim,
+                                   const int NE,
+                                   const Array<double> &bo,
+                                   const Array<double> &bc,
+                                   const Array<double> &gc,
+                                   const Vector &pa_data,
+                                   const Vector &x,
+                                   Vector &y)
+{
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   auto device_kernel = [=] MFEM_DEVICE (int e)
+   {
+      constexpr int VDIM = 3;
+      constexpr int maxCoeffDim = 9;
+
+      MFEM_SHARED double sBo[MAX_D1D][MAX_Q1D];
+      MFEM_SHARED double sBc[MAX_D1D][MAX_Q1D];
+      MFEM_SHARED double sGc[MAX_D1D][MAX_Q1D];
+
+      double opc[maxCoeffDim];
+      MFEM_SHARED double sop[maxCoeffDim][MAX_Q1D][MAX_Q1D];
+      MFEM_SHARED double mass[MAX_Q1D][MAX_Q1D][3];
+
+      MFEM_SHARED double sX[MAX_D1D][MAX_D1D][MAX_D1D];
+
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               for (int i=0; i<coeffDim; ++i)
+               {
+                  opc[i] = op(i,qx,qy,qz,e);
+               }
+            }
+         }
+      }
+
+      const int tidx = MFEM_THREAD_ID(x);
+      const int tidy = MFEM_THREAD_ID(y);
+      const int tidz = MFEM_THREAD_ID(z);
+
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               sBc[d][q] = Bc(q,d);
+               sGc[d][q] = Gc(q,d);
+               if (d < D1D-1)
+               {
+                  sBo[d][q] = Bo(q,d);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+
+      for (int qz=0; qz < Q1D; ++qz)
+      {
+         if (tidz == qz)
+         {
+            MFEM_FOREACH_THREAD(qy,y,Q1D)
+            {
+               MFEM_FOREACH_THREAD(qx,x,Q1D)
+               {
+                  for (int i=0; i<3; ++i)
+                  {
+                     mass[qy][qx][i] = 0.0;
+                  }
+               }
+            }
+         }
+
+         int osc = 0;
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            MFEM_FOREACH_THREAD(dz,z,D1Dz)
+            {
+               MFEM_FOREACH_THREAD(dy,y,D1Dy)
+               {
+                  MFEM_FOREACH_THREAD(dx,x,D1Dx)
+                  {
+                     sX[dz][dy][dx] = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  }
+               }
+            }
+            MFEM_SYNC_THREAD;
+
+            if (tidz == qz)
+            {
+               if (c == 0)
+               {
+                  for (int i=0; i<coeffDim; ++i)
+                  {
+                     sop[i][tidx][tidy] = opc[i];
+                  }
+               }
+
+               MFEM_FOREACH_THREAD(qy,y,Q1D)
+               {
+                  MFEM_FOREACH_THREAD(qx,x,Q1D)
+                  {
+                     double u = 0.0;
+
+                     for (int dz = 0; dz < D1Dz; ++dz)
+                     {
+                        const double wz = (c == 2) ? sBo[dz][qz] : sBc[dz][qz];
+
+                        for (int dy = 0; dy < D1Dy; ++dy)
+                        {
+                           const double wy = (c == 1) ? sBo[dy][qy] : sBc[dy][qy];
+
+                           for (int dx = 0; dx < D1Dx; ++dx)
+                           {
+                              const double wx = sX[dz][dy][dx] * ((c == 0) ? sBo[dx][qx] : sBc[dx][qx]);
+                              u += wx * wy * wz;
+                           }
+                        }
+                     }
+
+                     mass[qy][qx][c] += u;
+                  } // qx
+               } // qy
+            } // tidz == qz
+
+            osc += D1Dx * D1Dy * D1Dz;
+            MFEM_SYNC_THREAD;
+         } // c
+
+         double dxyz1 = 0.0;
+         double dxyz2 = 0.0;
+         double dxyz3 = 0.0;
+
+         MFEM_FOREACH_THREAD(dz,z,D1D)
+         {
+            const double wcz = sBc[dz][qz];
+            const double wcDz = sGc[dz][qz];
+            const double wz = (dz < D1D-1) ? sBo[dz][qz] : 0.0;
+
+            MFEM_FOREACH_THREAD(dy,y,D1D)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1D)
+               {
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wcy = sBc[dy][qy];
+                     const double wcDy = sGc[dy][qy];
+                     const double wy = (dy < D1D-1) ? sBo[dy][qy] : 0.0;
+
+                     for (int qx = 0; qx < Q1D; ++qx)
+                     {
+                        const double O11 = sop[0][qx][qy];
+                        double c1, c2, c3;
+                        if (coeffDim == 1)
+                        {
+                           c1 = O11 * mass[qy][qx][0];
+                           c2 = O11 * mass[qy][qx][1];
+                           c3 = O11 * mass[qy][qx][2];
+                        }
+                        else
+                        {
+                           const double O12 = sop[1][qx][qy];
+                           const double O13 = sop[2][qx][qy];
+                           const double O21 = sop[3][qx][qy];
+                           const double O22 = sop[4][qx][qy];
+                           const double O23 = sop[5][qx][qy];
+                           const double O31 = sop[6][qx][qy];
+                           const double O32 = sop[7][qx][qy];
+                           const double O33 = sop[8][qx][qy];
+
+                           c1 = (O11*mass[qy][qx][0])+(O12*mass[qy][qx][1])+(O13*mass[qy][qx][2]);
+                           c2 = (O21*mass[qy][qx][0])+(O22*mass[qy][qx][1])+(O23*mass[qy][qx][2]);
+                           c3 = (O31*mass[qy][qx][0])+(O32*mass[qy][qx][1])+(O33*mass[qy][qx][2]);
+                        }
+
+                        const double wcx = sBc[dx][qx];
+                        const double wDx = sGc[dx][qx];
+
+                        if (dx < D1D-1)
+                        {
+                           const double wx = sBo[dx][qx];
+                           dxyz1 += (wx * c2 * wcy * wcDz) - (wx * c3 * wcDy * wcz);
+                        }
+
+                        dxyz2 += (-wy * c1 * wcx * wcDz) + (wy * c3 * wDx * wcz);
+
+                        dxyz3 += (wcDy * wz * c1 * wcx) - (wcy * wz * c2 * wDx);
+                     } // qx
+                  } // qy
+               } // dx
+            } // dy
+         } // dz
+
+         MFEM_SYNC_THREAD;
+
+         MFEM_FOREACH_THREAD(dz,z,D1D)
+         {
+            MFEM_FOREACH_THREAD(dy,y,D1D)
+            {
+               MFEM_FOREACH_THREAD(dx,x,D1D)
+               {
+                  if (dx < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * D1D)) * (D1D-1)), e) += dxyz1;
+                  }
+                  if (dy < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * (D1D-1))) * D1D) + ((D1D-1)*D1D*D1D), e) += dxyz2;
+                  }
+                  if (dz < D1D-1)
+                  {
+                     Y(dx + ((dy + (dz * D1D)) * D1D) + (2*(D1D-1)*D1D*D1D), e) += dxyz3;
+                  }
+               }
+            }
+         }
+      } // qz
+   }; // end of element loop
+
+   auto host_kernel = [&] MFEM_LAMBDA (int)
+   {
+      MFEM_ABORT_KERNEL("This kernel should only be used on GPU.");
+   };
+
+   ForallWrap<3>(true, NE, device_kernel, host_kernel, Q1D, Q1D, Q1D);
+}
+
+} // namespace internal
+
+} // namespace mfem
+
+#endif
diff --git a/fem/integ/bilininteg_hcurlhdiv_kernels.hpp b/fem/integ/bilininteg_hcurlhdiv_kernels.hpp
new file mode 100644
index 000000000..c7165654a
--- /dev/null
+++ b/fem/integ/bilininteg_hcurlhdiv_kernels.hpp
@@ -0,0 +1,1303 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license.  We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_BILININTEG_HCURLHDIV_KERNELS_HPP
+#define MFEM_BILININTEG_HCURLHDIV_KERNELS_HPP
+
+#include "../../config/config.hpp"
+#include "../../general/forall.hpp"
+#include "../../linalg/dtensor.hpp"
+
+namespace mfem
+{
+
+namespace internal
+{
+
+// PA H(curl) x H(div) mass assemble 2D kernel, with factor
+// dF^{-1} C dF for a vector or matrix coefficient C.
+// If transpose, use dF^T C dF^{-T} for H(div) x H(curl).
+MFEM_HOST_DEVICE inline
+void PAHcurlHdivMassSetup2D(const int Q1D,
+                            const int coeffDim,
+                            const int NE,
+                            const bool transpose,
+                            const Array<double> &w_,
+                            const Vector &j,
+                            Vector &coeff_,
+                            Vector &op)
+{
+   const bool symmetric = (coeffDim != 4);
+   auto W = Reshape(w_.Read(), Q1D, Q1D);
+   auto J = Reshape(j.Read(), Q1D, Q1D, 2, 2, NE);
+   auto coeff = Reshape(coeff_.Read(), coeffDim, Q1D, Q1D, NE);
+   auto y = Reshape(op.Write(), 4, Q1D, Q1D, NE);
+
+   const int i11 = 0;
+   const int i12 = transpose ? 2 : 1;
+   const int i21 = transpose ? 1 : 2;
+   const int i22 = 3;
+
+   mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            const double J11 = J(qx,qy,0,0,e);
+            const double J21 = J(qx,qy,1,0,e);
+            const double J12 = J(qx,qy,0,1,e);
+            const double J22 = J(qx,qy,1,1,e);
+            const double w_detJ = W(qx,qy) / ((J11*J22) - (J21*J12));
+
+            if (coeffDim == 3 || coeffDim == 4) // Matrix coefficient version
+            {
+               // First compute entries of R = MJ
+               const double M11 = coeff(i11,qx,qy,e);
+               const double M12 = (!symmetric) ? coeff(i12,qx,qy,e) : coeff(1,qx,qy,e);
+               const double M21 = (!symmetric) ? coeff(i21,qx,qy,e) : M12;
+               const double M22 = (!symmetric) ? coeff(i22,qx,qy,e) : coeff(2,qx,qy,e);
+
+               // J^{-1} M^T
+               const double R11 = ( J22*M11 - J12*M12); // 1,1
+               const double R12 = ( J22*M21 - J12*M22); // 1,2
+               const double R21 = (-J21*M11 + J11*M12); // 2,1
+               const double R22 = (-J21*M21 + J11*M22); // 2,2
+
+               // (RJ)^T
+               y(i11,qx,qy,e) = w_detJ * (R11*J11 + R12*J21); // 1,1
+               y(i21,qx,qy,e) = w_detJ * (R11*J12 + R12*J22); // 1,2 (transpose)
+               y(i12,qx,qy,e) = w_detJ * (R21*J11 + R22*J21); // 2,1 (transpose)
+               y(i22,qx,qy,e) = w_detJ * (R21*J12 + R22*J22); // 2,2
+            }
+            else if (coeffDim == 2) // Vector coefficient version
+            {
+               const double D1 = coeff(0,qx,qy,e);
+               const double D2 = coeff(1,qx,qy,e);
+               const double R11 = D1*J11;
+               const double R12 = D1*J12;
+               const double R21 = D2*J21;
+               const double R22 = D2*J22;
+               y(i11,qx,qy,e) = w_detJ * ( J22*R11 - J12*R21); // 1,1
+               y(i21,qx,qy,e) = w_detJ * ( J22*R12 - J12*R22); // 1,2 (transpose)
+               y(i12,qx,qy,e) = w_detJ * (-J21*R11 + J11*R21); // 2,1 (transpose)
+               y(i22,qx,qy,e) = w_detJ * (-J21*R12 + J11*R22); // 2,2
+            }
+         }
+      }
+   });
+}
+
+// PA H(curl) x H(div) mass assemble 3D kernel, with factor
+// dF^{-1} C dF for a vector or matrix coefficient C.
+// If transpose, use dF^T C dF^{-T} for H(div) x H(curl).
+MFEM_HOST_DEVICE inline
+void PAHcurlHdivMassSetup3D(const int Q1D,
+                            const int coeffDim,
+                            const int NE,
+                            const bool transpose,
+                            const Array<double> &w_,
+                            const Vector &j,
+                            Vector &coeff_,
+                            Vector &op)
+{
+   const bool symmetric = (coeffDim != 9);
+   auto W = Reshape(w_.Read(), Q1D, Q1D, Q1D);
+   auto J = Reshape(j.Read(), Q1D, Q1D, Q1D, 3, 3, NE);
+   auto coeff = Reshape(coeff_.Read(), coeffDim, Q1D, Q1D, Q1D, NE);
+   auto y = Reshape(op.Write(), 9, Q1D, Q1D, Q1D, NE);
+
+   const int i11 = 0;
+   const int i12 = transpose ? 3 : 1;
+   const int i13 = transpose ? 6 : 2;
+   const int i21 = transpose ? 1 : 3;
+   const int i22 = 4;
+   const int i23 = transpose ? 7 : 5;
+   const int i31 = transpose ? 2 : 6;
+   const int i32 = transpose ? 5 : 7;
+   const int i33 = 8;
+
+   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qz,z,Q1D)
+            {
+               const double J11 = J(qx,qy,qz,0,0,e);
+               const double J21 = J(qx,qy,qz,1,0,e);
+               const double J31 = J(qx,qy,qz,2,0,e);
+               const double J12 = J(qx,qy,qz,0,1,e);
+               const double J22 = J(qx,qy,qz,1,1,e);
+               const double J32 = J(qx,qy,qz,2,1,e);
+               const double J13 = J(qx,qy,qz,0,2,e);
+               const double J23 = J(qx,qy,qz,1,2,e);
+               const double J33 = J(qx,qy,qz,2,2,e);
+               const double detJ = J11 * (J22 * J33 - J32 * J23) -
+                                   J21 * (J12 * J33 - J32 * J13) +
+                                   J31 * (J12 * J23 - J22 * J13);
+               const double w_detJ = W(qx,qy,qz) / detJ;
+               // adj(J)
+               const double A11 = (J22 * J33) - (J23 * J32);
+               const double A12 = (J32 * J13) - (J12 * J33);
+               const double A13 = (J12 * J23) - (J22 * J13);
+               const double A21 = (J31 * J23) - (J21 * J33);
+               const double A22 = (J11 * J33) - (J13 * J31);
+               const double A23 = (J21 * J13) - (J11 * J23);
+               const double A31 = (J21 * J32) - (J31 * J22);
+               const double A32 = (J31 * J12) - (J11 * J32);
+               const double A33 = (J11 * J22) - (J12 * J21);
+
+               if (coeffDim == 6 || coeffDim == 9) // Matrix coefficient version
+               {
+                  // First compute entries of R = M^T J
+                  const double M11 = (!symmetric) ? coeff(i11,qx,qy,qz,e) : coeff(0,qx,qy,qz,e);
+                  const double M12 = (!symmetric) ? coeff(i12,qx,qy,qz,e) : coeff(1,qx,qy,qz,e);
+                  const double M13 = (!symmetric) ? coeff(i13,qx,qy,qz,e) : coeff(2,qx,qy,qz,e);
+                  const double M21 = (!symmetric) ? coeff(i21,qx,qy,qz,e) : M12;
+                  const double M22 = (!symmetric) ? coeff(i22,qx,qy,qz,e) : coeff(3,qx,qy,qz,e);
+                  const double M23 = (!symmetric) ? coeff(i23,qx,qy,qz,e) : coeff(4,qx,qy,qz,e);
+                  const double M31 = (!symmetric) ? coeff(i31,qx,qy,qz,e) : M13;
+                  const double M32 = (!symmetric) ? coeff(i32,qx,qy,qz,e) : M23;
+                  const double M33 = (!symmetric) ? coeff(i33,qx,qy,qz,e) : coeff(5,qx,qy,qz,e);
+
+                  const double R11 = M11*J11 + M21*J21 + M31*J31;
+                  const double R12 = M11*J12 + M21*J22 + M31*J32;
+                  const double R13 = M11*J13 + M21*J23 + M31*J33;
+                  const double R21 = M12*J11 + M22*J21 + M32*J31;
+                  const double R22 = M12*J12 + M22*J22 + M32*J32;
+                  const double R23 = M12*J13 + M22*J23 + M32*J33;
+                  const double R31 = M13*J11 + M23*J21 + M33*J31;
+                  const double R32 = M13*J12 + M23*J22 + M33*J32;
+                  const double R33 = M13*J13 + M23*J23 + M33*J33;
+
+                  // y = (J^{-1} M^T J)^T
+                  y(i11,qx,qy,qz,e) = w_detJ * (A11*R11 + A12*R21 + A13*R31); // 1,1
+                  y(i21,qx,qy,qz,e) = w_detJ * (A11*R12 + A12*R22 + A13*R32); // 1,2
+                  y(i31,qx,qy,qz,e) = w_detJ * (A11*R13 + A12*R23 + A13*R33); // 1,3
+                  y(i12,qx,qy,qz,e) = w_detJ * (A21*R11 + A22*R21 + A23*R31); // 2,1
+                  y(i22,qx,qy,qz,e) = w_detJ * (A21*R12 + A22*R22 + A23*R32); // 2,2
+                  y(i32,qx,qy,qz,e) = w_detJ * (A21*R13 + A22*R23 + A23*R33); // 2,3
+                  y(i13,qx,qy,qz,e) = w_detJ * (A31*R11 + A32*R21 + A33*R31); // 3,1
+                  y(i23,qx,qy,qz,e) = w_detJ * (A31*R12 + A32*R22 + A33*R32); // 3,2
+                  y(i33,qx,qy,qz,e) = w_detJ * (A31*R13 + A32*R23 + A33*R33); // 3,3
+               }
+               else if (coeffDim == 3)  // Vector coefficient version
+               {
+                  const double D1 = coeff(0,qx,qy,qz,e);
+                  const double D2 = coeff(1,qx,qy,qz,e);
+                  const double D3 = coeff(2,qx,qy,qz,e);
+                  // detJ J^{-1} DJ = adj(J) DJ
+                  // transpose
+                  y(i11,qx,qy,qz,e) = w_detJ * (D1*A11*J11 + D2*A12*J21 + D3*A13*J31); // 1,1
+                  y(i21,qx,qy,qz,e) = w_detJ * (D1*A11*J12 + D2*A12*J22 + D3*A13*J32); // 1,2
+                  y(i31,qx,qy,qz,e) = w_detJ * (D1*A11*J13 + D2*A12*J23 + D3*A13*J33); // 1,3
+                  y(i12,qx,qy,qz,e) = w_detJ * (D1*A21*J11 + D2*A22*J21 + D3*A23*J31); // 2,1
+                  y(i22,qx,qy,qz,e) = w_detJ * (D1*A21*J12 + D2*A22*J22 + D3*A23*J32); // 2,2
+                  y(i32,qx,qy,qz,e) = w_detJ * (D1*A21*J13 + D2*A22*J23 + D3*A23*J33); // 2,3
+                  y(i13,qx,qy,qz,e) = w_detJ * (D1*A31*J11 + D2*A32*J21 + D3*A33*J31); // 3,1
+                  y(i23,qx,qy,qz,e) = w_detJ * (D1*A31*J12 + D2*A32*J22 + D3*A33*J32); // 3,2
+                  y(i33,qx,qy,qz,e) = w_detJ * (D1*A31*J13 + D2*A32*J23 + D3*A33*J33); // 3,3
+               }
+            }
+         }
+      }
+   });
+}
+
+// Mass operator for H(curl) and H(div) functions, using Piola transformations
+// u = dF^{-T} \hat{u} in H(curl), v = (1 / det dF) dF \hat{v} in H(div).
+MFEM_HOST_DEVICE inline
+void PAHcurlHdivMassApply2D(const int D1D,
+                            const int D1Dtest,
+                            const int Q1D,
+                            const int NE,
+                            const bool scalarCoeff,
+                            const bool trialHcurl,
+                            const bool transpose,
+                            const Array<double> &Bo_,
+                            const Array<double> &Bc_,
+                            const Array<double> &Bot_,
+                            const Array<double> &Bct_,
+                            const Vector &op_,
+                            const Vector &x_,
+                            Vector &y_)
+{
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+   constexpr static int VDIM = 2;
+
+   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
+   auto Bot = Reshape(Bot_.Read(), D1Dtest-1, Q1D);
+   auto Bct = Reshape(Bct_.Read(), D1Dtest, Q1D);
+   auto op = Reshape(op_.Read(), scalarCoeff ? 1 : 4, Q1D, Q1D, NE);
+   auto x = Reshape(x_.Read(), 2*(D1D-1)*D1D, NE);
+   auto y = Reshape(y_.ReadWrite(), 2*(D1Dtest-1)*D1Dtest, NE);
+
+   const int i12 = transpose ? 2 : 1;
+   const int i21 = transpose ? 1 : 2;
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            for (int c = 0; c < VDIM; ++c)
+            {
+               mass[qy][qx][c] = 0.0;
+            }
+         }
+      }
+
+      int osc = 0;
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y trial components
+      {
+         const int D1Dy = trialHcurl ? ((c == 1) ? D1D - 1 : D1D) :
+                          ((c == 1) ? D1D : D1D - 1);
+         const int D1Dx = trialHcurl ? ((c == 0) ? D1D - 1 : D1D) :
+                          ((c == 0) ? D1D : D1D - 1);
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            double massX[MAX_Q1D];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               massX[qx] = 0.0;
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double t = x(dx + (dy * D1Dx) + osc, e);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] += t * (trialHcurl ? ((c == 0) ? Bo(qx,dx) : Bc(qx,dx)) :
+                                    ((c == 0) ? Bc(qx,dx) : Bo(qx,dx)));
+               }
+            }
+
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const double wy = trialHcurl ? ((c == 1) ? Bo(qy,dy) : Bc(qy,dy)) :
+                                 ((c == 1) ? Bc(qy,dy) : Bo(qy,dy));
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  mass[qy][qx][c] += massX[qx] * wy;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            const double O11 = op(0,qx,qy,e);
+            const double O12 = scalarCoeff ? 0.0 : op(i12,qx,qy,e);
+            const double O21 = scalarCoeff ? 0.0 : op(i21,qx,qy,e);
+            const double O22 = scalarCoeff ? O11 : op(3,qx,qy,e);
+            const double massX = mass[qy][qx][0];
+            const double massY = mass[qy][qx][1];
+            mass[qy][qx][0] = (O11*massX)+(O12*massY);
+            mass[qy][qx][1] = (O21*massX)+(O22*massY);
+         }
+      }
+
+      osc = 0;
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y test components
+      {
+         const int D1Dy = trialHcurl ? ((c == 1) ? D1Dtest : D1Dtest - 1) :
+                          ((c == 1) ? D1Dtest - 1 : D1Dtest);
+         const int D1Dx = trialHcurl ? ((c == 0) ? D1Dtest : D1Dtest - 1) :
+                          ((c == 0) ? D1Dtest - 1 : D1Dtest);
+
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            double massX[HDIV_MAX_D1D];
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               massX[dx] = 0.0;
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] += mass[qy][qx][c] * (trialHcurl ?
+                                                  ((c == 0) ? Bct(dx,qx) : Bot(dx,qx)) :
+                                                  ((c == 0) ? Bot(dx,qx) : Bct(dx,qx)));
+               }
+            }
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               const double wy = trialHcurl ? ((c == 1) ? Bct(dy,qy) : Bot(dy,qy)) :
+                                 ((c == 1) ? Bot(dy,qy) : Bct(dy,qy));
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  y(dx + (dy * D1Dx) + osc, e) += massX[dx] * wy;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop c
+   }); // end of element loop
+}
+
+// Mass operator for H(curl) and H(div) functions, using Piola transformations
+// u = dF^{-T} \hat{u} in H(curl), v = (1 / det dF) dF \hat{v} in H(div).
+MFEM_HOST_DEVICE inline
+void PAHcurlHdivMassApply3D(const int D1D,
+                            const int D1Dtest,
+                            const int Q1D,
+                            const int NE,
+                            const bool scalarCoeff,
+                            const bool trialHcurl,
+                            const bool transpose,
+                            const Array<double> &Bo_,
+                            const Array<double> &Bc_,
+                            const Array<double> &Bot_,
+                            const Array<double> &Bct_,
+                            const Vector &op_,
+                            const Vector &x_,
+                            Vector &y_)
+{
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
+   auto Bot = Reshape(Bot_.Read(), D1Dtest-1, Q1D);
+   auto Bct = Reshape(Bct_.Read(), D1Dtest, Q1D);
+   auto op = Reshape(op_.Read(), scalarCoeff ? 1 : 9, Q1D, Q1D, Q1D, NE);
+   auto x = Reshape(x_.Read(), 3*(D1D-1)*D1D*(trialHcurl ? D1D : D1D-1), NE);
+   auto y = Reshape(y_.ReadWrite(), 3*(D1Dtest-1)*D1Dtest*
+                    (trialHcurl ? D1Dtest-1 : D1Dtest), NE);
+
+   const int i12 = transpose ? 3 : 1;
+   const int i13 = transpose ? 6 : 2;
+   const int i21 = transpose ? 1 : 3;
+   const int i23 = transpose ? 7 : 5;
+   const int i31 = transpose ? 2 : 6;
+   const int i32 = transpose ? 5 : 7;
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  mass[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      int osc = 0;
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z trial components
+      {
+         const int D1Dz = trialHcurl ? ((c == 2) ? D1D - 1 : D1D) :
+                          ((c == 2) ? D1D : D1D - 1);
+         const int D1Dy = trialHcurl ? ((c == 1) ? D1D - 1 : D1D) :
+                          ((c == 1) ? D1D : D1D - 1);
+         const int D1Dx = trialHcurl ? ((c == 0) ? D1D - 1 : D1D) :
+                          ((c == 0) ? D1D : D1D - 1);
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double massXY[MAX_Q1D][MAX_Q1D];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massXY[qy][qx] = 0.0;
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MAX_Q1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = x(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * (trialHcurl ? ((c == 0) ? Bo(qx,dx) : Bc(qx,dx)) :
+                                       ((c == 0) ? Bc(qx,dx) : Bo(qx,dx)));
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = trialHcurl ? ((c == 1) ? Bo(qy,dy) : Bc(qy,dy)) :
+                                    ((c == 1) ? Bc(qy,dy) : Bo(qy,dy));
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     massXY[qy][qx] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = trialHcurl ? ((c == 2) ? Bo(qz,dz) : Bc(qz,dz)) :
+                                 ((c == 2) ? Bc(qz,dz) : Bo(qz,dz));
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(0,qx,qy,qz,e);
+               const double O12 = scalarCoeff ? 0.0 : op(i12,qx,qy,qz,e);
+               const double O13 = scalarCoeff ? 0.0 : op(i13,qx,qy,qz,e);
+               const double O21 = scalarCoeff ? 0.0 : op(i21,qx,qy,qz,e);
+               const double O22 = scalarCoeff ? O11 : op(4,qx,qy,qz,e);
+               const double O23 = scalarCoeff ? 0.0 : op(i23,qx,qy,qz,e);
+               const double O31 = scalarCoeff ? 0.0 : op(i31,qx,qy,qz,e);
+               const double O32 = scalarCoeff ? 0.0 : op(i32,qx,qy,qz,e);
+               const double O33 = scalarCoeff ? O11 : op(8,qx,qy,qz,e);
+               const double massX = mass[qz][qy][qx][0];
+               const double massY = mass[qz][qy][qx][1];
+               const double massZ = mass[qz][qy][qx][2];
+               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
+               mass[qz][qy][qx][1] = (O21*massX)+(O22*massY)+(O23*massZ);
+               mass[qz][qy][qx][2] = (O31*massX)+(O32*massY)+(O33*massZ);
+            }
+         }
+      }
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         double massXY[HDIV_MAX_D1D][HDIV_MAX_D1D];
+
+         osc = 0;
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z test components
+         {
+            const int D1Dz = trialHcurl ? ((c == 2) ? D1Dtest : D1Dtest - 1) :
+                             ((c == 2) ? D1Dtest - 1 : D1Dtest);
+            const int D1Dy = trialHcurl ? ((c == 1) ? D1Dtest : D1Dtest - 1) :
+                             ((c == 1) ? D1Dtest - 1 : D1Dtest);
+            const int D1Dx = trialHcurl ? ((c == 0) ? D1Dtest : D1Dtest - 1) :
+                             ((c == 0) ? D1Dtest - 1 : D1Dtest);
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massXY[dy][dx] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[HDIV_MAX_D1D];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] = 0.0;
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massX[dx] += mass[qz][qy][qx][c] * (trialHcurl ?
+                                                         ((c == 0) ? Bct(dx,qx) : Bot(dx,qx)) :
+                                                         ((c == 0) ? Bot(dx,qx) : Bct(dx,qx)));
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = trialHcurl ? ((c == 1) ? Bct(dy,qy) : Bot(dy,qy)) :
+                                    ((c == 1) ? Bot(dy,qy) : Bct(dy,qy));
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massXY[dy][dx] += massX[dx] * wy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = trialHcurl ? ((c == 2) ? Bct(dz,qz) : Bot(dz,qz)) :
+                                 ((c == 2) ? Bot(dz,qz) : Bct(dz,qz));
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) +=
+                        massXY[dy][dx] * wz;
+                  }
+               }
+            }
+
+            osc += D1Dx * D1Dy * D1Dz;
+         }  // loop c
+      }  // loop qz
+   }); // end of element loop
+}
+
+// Apply to x corresponding to DOFs in H(curl) (trial), whose curl is
+// integrated against H(div) test functions corresponding to y.
+template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
+MFEM_HOST_DEVICE inline
+void PAHcurlHdivApply3D(const int D1D,
+                        const int D1Dtest,
+                        const int Q1D,
+                        const int NE,
+                        const Array<double> &bo,
+                        const Array<double> &bc,
+                        const Array<double> &bot,
+                        const Array<double> &bct,
+                        const Array<double> &gc,
+                        const Vector &pa_data,
+                        const Vector &x,
+                        Vector &y)
+{
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+   // Using Piola transformations (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u}
+   // for u in H(curl) and w = (1 / det (dF)) dF \hat{w} for w in H(div), we get
+   // (\nabla\times u) \cdot w = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{w}
+   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1Dtest-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1Dtest, Q1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1Dtest-1)*(D1Dtest-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double curl[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
+      // curl[qz][qy][qx] will be computed as the vector curl at each quadrature point.
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  curl[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      // We treat x, y, z components separately for optimization specific to each.
+
+      int osc = 0;
+
+      {
+         // x component
+         const int D1Dz = D1D;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D - 1;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double gradXY[MAX_Q1D][MAX_Q1D][2];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradXY[qy][qx][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MAX_Q1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * Bo(qx,dx);
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = Bc(qy,dy);
+                  const double wDy = Gc(qy,dy);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     gradXY[qy][qx][0] += wx * wDy;
+                     gradXY[qy][qx][1] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = Bc(qz,dz);
+               const double wDz = Gc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                     curl[qz][qy][qx][1] += gradXY[qy][qx][1] * wDz; // (u_0)_{x_2}
+                     curl[qz][qy][qx][2] -= gradXY[qy][qx][0] * wz;  // -(u_0)_{x_1}
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      {
+         // y component
+         const int D1Dz = D1D;
+         const int D1Dy = D1D - 1;
+         const int D1Dx = D1D;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double gradXY[MAX_Q1D][MAX_Q1D][2];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradXY[qy][qx][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               double massY[MAX_Q1D];
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  massY[qy] = 0.0;
+               }
+
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     massY[qy] += t * Bo(qy,dy);
+                  }
+               }
+
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx = Bc(qx,dx);
+                  const double wDx = Gc(qx,dx);
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wy = massY[qy];
+                     gradXY[qy][qx][0] += wDx * wy;
+                     gradXY[qy][qx][1] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = Bc(qz,dz);
+               const double wDz = Gc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                     curl[qz][qy][qx][0] -= gradXY[qy][qx][1] * wDz; // -(u_1)_{x_2}
+                     curl[qz][qy][qx][2] += gradXY[qy][qx][0] * wz;  // (u_1)_{x_0}
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      {
+         // z component
+         const int D1Dz = D1D - 1;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D;
+
+         for (int dx = 0; dx < D1Dx; ++dx)
+         {
+            double gradYZ[MAX_Q1D][MAX_Q1D][2];
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int d = 0; d < 2; ++d)
+                  {
+                     gradYZ[qz][qy][d] = 0.0;
+                  }
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massZ[MAX_Q1D];
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  massZ[qz] = 0.0;
+               }
+
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     massZ[qz] += t * Bo(qz,dz);
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = Bc(qy,dy);
+                  const double wDy = Gc(qy,dy);
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     const double wz = massZ[qz];
+                     gradYZ[qz][qy][0] += wz * wy;
+                     gradYZ[qz][qy][1] += wz * wDy;
+                  }
+               }
+            }
+
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double wx = Bc(qx,dx);
+               const double wDx = Gc(qx,dx);
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qz = 0; qz < Q1D; ++qz)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+                     curl[qz][qy][qx][0] += gradYZ[qz][qy][1] * wx;  // (u_2)_{x_1}
+                     curl[qz][qy][qx][1] -= gradYZ[qz][qy][0] * wDx; // -(u_2)_{x_0}
+                  }
+               }
+            }
+         }
+      }
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(qx,qy,qz,0,e);
+               const double O12 = op(qx,qy,qz,1,e);
+               const double O13 = op(qx,qy,qz,2,e);
+               const double O22 = op(qx,qy,qz,3,e);
+               const double O23 = op(qx,qy,qz,4,e);
+               const double O33 = op(qx,qy,qz,5,e);
+
+               const double c1 = (O11 * curl[qz][qy][qx][0]) + (O12 * curl[qz][qy][qx][1]) +
+                                 (O13 * curl[qz][qy][qx][2]);
+               const double c2 = (O12 * curl[qz][qy][qx][0]) + (O22 * curl[qz][qy][qx][1]) +
+                                 (O23 * curl[qz][qy][qx][2]);
+               const double c3 = (O13 * curl[qz][qy][qx][0]) + (O23 * curl[qz][qy][qx][1]) +
+                                 (O33 * curl[qz][qy][qx][2]);
+
+               curl[qz][qy][qx][0] = c1;
+               curl[qz][qy][qx][1] = c2;
+               curl[qz][qy][qx][2] = c3;
+            }
+         }
+      }
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         double massXY[HCURL_MAX_D1D][HCURL_MAX_D1D];  // Assuming HDIV_MAX_D1D <= HCURL_MAX_D1D
+
+         osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1Dtest : D1Dtest - 1;
+            const int D1Dy = (c == 1) ? D1Dtest : D1Dtest - 1;
+            const int D1Dx = (c == 0) ? D1Dtest : D1Dtest - 1;
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massXY[dy][dx] = 0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[HCURL_MAX_D1D];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] = 0;
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massX[dx] += curl[qz][qy][qx][c] *
+                                  ((c == 0) ? Bct(dx,qx) : Bot(dx,qx));
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = (c == 1) ? Bct(dy,qy) : Bot(dy,qy);
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massXY[dy][dx] += massX[dx] * wy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = (c == 2) ? Bct(dz,qz) : Bot(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) +=
+                        massXY[dy][dx] * wz;
+                  }
+               }
+            }
+
+            osc += D1Dx * D1Dy * D1Dz;
+         }  // loop c
+      }  // loop qz
+   }); // end of element loop
+}
+
+// Apply to x corresponding to DOFs in H(div) (test), integrated against the
+// curl of H(curl) trial functions corresponding to y.
+template<int MAX_D1D = HCURL_MAX_D1D, int MAX_Q1D = HCURL_MAX_Q1D>
+MFEM_HOST_DEVICE inline
+void PAHcurlHdivApply3DTranspose(const int D1D,
+                                 const int D1Dtest,
+                                 const int Q1D,
+                                 const int NE,
+                                 const Array<double> &bo,
+                                 const Array<double> &bc,
+                                 const Array<double> &bot,
+                                 const Array<double> &bct,
+                                 const Array<double> &gct,
+                                 const Vector &pa_data,
+                                 const Vector &x,
+                                 Vector &y)
+{
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+   // Using Piola transformations (\nabla\times u) F = 1/det(dF) dF \hat{\nabla}\times\hat{u}
+   // for u in H(curl) and w = (1 / det (dF)) dF \hat{w} for w in H(div), we get
+   // (\nabla\times u) \cdot w = 1/det(dF)^2 \hat{\nabla}\times\hat{u}^T dF^T dF \hat{w}
+   // If c = 0, \hat{\nabla}\times\hat{u} reduces to [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+   // If c = 1, \hat{\nabla}\times\hat{u} reduces to [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+   // If c = 2, \hat{\nabla}\times\hat{u} reduces to [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1Dtest-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1Dtest, Q1D);
+   auto Gct = Reshape(gct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
+   auto X = Reshape(x.Read(), 3*(D1Dtest-1)*(D1Dtest-1)*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];  // Assuming HDIV_MAX_D1D <= HCURL_MAX_D1D
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  mass[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D : D1D - 1;
+         const int D1Dy = (c == 1) ? D1D : D1D - 1;
+         const int D1Dx = (c == 0) ? D1D : D1D - 1;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double massXY[HDIV_MAX_Q1D][HDIV_MAX_Q1D];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massXY[qy][qx] = 0.0;
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[HDIV_MAX_Q1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * ((c == 0) ? Bc(qx,dx) : Bo(qx,dx));
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 1) ? Bc(qy,dy) : Bo(qy,dy);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     massXY[qy][qx] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = (c == 2) ? Bc(qz,dz) : Bo(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(qx,qy,qz,0,e);
+               const double O12 = op(qx,qy,qz,1,e);
+               const double O13 = op(qx,qy,qz,2,e);
+               const double O22 = op(qx,qy,qz,3,e);
+               const double O23 = op(qx,qy,qz,4,e);
+               const double O33 = op(qx,qy,qz,5,e);
+               const double massX = mass[qz][qy][qx][0];
+               const double massY = mass[qz][qy][qx][1];
+               const double massZ = mass[qz][qy][qx][2];
+               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
+               mass[qz][qy][qx][1] = (O12*massX)+(O22*massY)+(O23*massZ);
+               mass[qz][qy][qx][2] = (O13*massX)+(O23*massY)+(O33*massZ);
+            }
+         }
+      }
+
+      // x component
+      osc = 0;
+      {
+         const int D1Dz = D1D;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D - 1;
+
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            double gradXY12[MAX_D1D][MAX_D1D];
+            double gradXY21[MAX_D1D][MAX_D1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradXY12[dy][dx] = 0.0;
+                  gradXY21[dy][dx] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[MAX_D1D][2];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  for (int n = 0; n < 2; ++n)
+                  {
+                     massX[dx][n] = 0.0;
+                  }
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     const double wx = Bot(dx,qx);
+
+                     massX[dx][0] += wx * mass[qz][qy][qx][1];
+                     massX[dx][1] += wx * mass[qz][qy][qx][2];
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = Bct(dy,qy);
+                  const double wDy = Gct(dy,qy);
+
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     gradXY21[dy][dx] += massX[dx][0] * wy;
+                     gradXY12[dy][dx] += massX[dx][1] * wDy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = Bct(dz,qz);
+               const double wDz = Gct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [0, (u_0)_{x_2}, -(u_0)_{x_1}]
+                     // (u_0)_{x_2} * (op * curl)_1 - (u_0)_{x_1} * (op * curl)_2
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (gradXY21[dy][dx] * wDz) - (gradXY12[dy][dx] * wz);
+                  }
+               }
+            }
+         }  // loop qz
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      // y component
+      {
+         const int D1Dz = D1D;
+         const int D1Dy = D1D - 1;
+         const int D1Dx = D1D;
+
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            double gradXY02[MAX_D1D][MAX_D1D];
+            double gradXY20[MAX_D1D][MAX_D1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  gradXY02[dy][dx] = 0.0;
+                  gradXY20[dy][dx] = 0.0;
+               }
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               double massY[MAX_D1D][2];
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  massY[dy][0] = 0.0;
+                  massY[dy][1] = 0.0;
+               }
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int dy = 0; dy < D1Dy; ++dy)
+                  {
+                     const double wy = Bot(dy,qy);
+
+                     massY[dy][0] += wy * mass[qz][qy][qx][2];
+                     massY[dy][1] += wy * mass[qz][qy][qx][0];
+                  }
+               }
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double wx = Bct(dx,qx);
+                  const double wDx = Gct(dx,qx);
+
+                  for (int dy = 0; dy < D1Dy; ++dy)
+                  {
+                     gradXY02[dy][dx] += massY[dy][0] * wDx;
+                     gradXY20[dy][dx] += massY[dy][1] * wx;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = Bct(dz,qz);
+               const double wDz = Gct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [-(u_1)_{x_2}, 0, (u_1)_{x_0}]
+                     // -(u_1)_{x_2} * (op * curl)_0 + (u_1)_{x_0} * (op * curl)_2
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (-gradXY20[dy][dx] * wDz) + (gradXY02[dy][dx] * wz);
+                  }
+               }
+            }
+         }  // loop qz
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }
+
+      // z component
+      {
+         const int D1Dz = D1D - 1;
+         const int D1Dy = D1D;
+         const int D1Dx = D1D;
+
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            double gradYZ01[MAX_D1D][MAX_D1D];
+            double gradYZ10[MAX_D1D][MAX_D1D];
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  gradYZ01[dz][dy] = 0.0;
+                  gradYZ10[dz][dy] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massZ[MAX_D1D][2];
+               for (int dz = 0; dz < D1Dz; ++dz)
+               {
+                  for (int n = 0; n < 2; ++n)
+                  {
+                     massZ[dz][n] = 0.0;
+                  }
+               }
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     const double wz = Bot(dz,qz);
+
+                     massZ[dz][0] += wz * mass[qz][qy][qx][0];
+                     massZ[dz][1] += wz * mass[qz][qy][qx][1];
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = Bct(dy,qy);
+                  const double wDy = Gct(dy,qy);
+
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     gradYZ01[dz][dy] += wy * massZ[dz][1];
+                     gradYZ10[dz][dy] += wDy * massZ[dz][0];
+                  }
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double wx = Bct(dx,qx);
+               const double wDx = Gct(dx,qx);
+
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dz = 0; dz < D1Dz; ++dz)
+                  {
+                     // \hat{\nabla}\times\hat{u} is [(u_2)_{x_1}, -(u_2)_{x_0}, 0]
+                     // (u_2)_{x_1} * (op * curl)_0 - (u_2)_{x_0} * (op * curl)_1
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc,
+                       e) += (gradYZ10[dz][dy] * wx) - (gradYZ01[dz][dy] * wDx);
+                  }
+               }
+            }
+         }  // loop qx
+      }
+   }); // end of element loop
+}
+
+} // namespace internal
+
+} // namespace mfem
+
+#endif
diff --git a/fem/bilininteg_hdiv.cpp b/fem/integ/bilininteg_hdiv_kernels.hpp
similarity index 84%
rename from fem/bilininteg_hdiv.cpp
rename to fem/integ/bilininteg_hdiv_kernels.hpp
index 26e0ed973..cf083a2c6 100644
--- a/fem/bilininteg_hdiv.cpp
+++ b/fem/integ/bilininteg_hdiv_kernels.hpp
@@ -9,13 +9,12 @@
 // terms of the BSD-3 license.  We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qspace.hpp"
-
-using namespace std;
+#ifndef MFEM_BILININTEG_HDIV_KERNELS_HPP
+#define MFEM_BILININTEG_HDIV_KERNELS_HPP
 
+#include "../../config/config.hpp"
+#include "../../general/forall.hpp"
+#include "../../linalg/dtensor.hpp"
 
 // Piola transformation in H(div): w = (1 / det (dF)) dF \hat{w}
 // div w = (1 / det (dF)) \hat{div} \hat{w}
@@ -23,14 +22,18 @@ using namespace std;
 namespace mfem
 {
 
+namespace internal
+{
+
 // PA H(div) Mass Assemble 2D kernel
-void PAHdivSetup2D(const int Q1D,
-                   const int coeffDim,
-                   const int NE,
-                   const Array<double> &w,
-                   const Vector &j,
-                   Vector &coeff_,
-                   Vector &op)
+MFEM_HOST_DEVICE inline
+void PAHdivMassSetup2D(const int Q1D,
+                       const int coeffDim,
+                       const int NE,
+                       const Array<double> &w,
+                       const Vector &j,
+                       Vector &coeff_,
+                       Vector &op)
 {
    const bool symmetric = (coeffDim != 4);
    const int NQ = Q1D*Q1D;
@@ -88,13 +91,14 @@ void PAHdivSetup2D(const int Q1D,
 }
 
 // PA H(div) Mass Assemble 3D kernel
-void PAHdivSetup3D(const int Q1D,
-                   const int coeffDim,
-                   const int NE,
-                   const Array<double> &w,
-                   const Vector &j,
-                   Vector &coeff_,
-                   Vector &op)
+MFEM_HOST_DEVICE inline
+void PAHdivMassSetup3D(const int Q1D,
+                       const int coeffDim,
+                       const int NE,
+                       const Array<double> &w,
+                       const Vector &j,
+                       Vector &coeff_,
+                       Vector &op)
 {
    const bool symmetric = (coeffDim != 9);
    const int NQ = Q1D*Q1D*Q1D;
@@ -175,6 +179,134 @@ void PAHdivSetup3D(const int Q1D,
    });
 }
 
+MFEM_HOST_DEVICE inline
+void PAHdivMassAssembleDiagonal2D(const int D1D,
+                                  const int Q1D,
+                                  const int NE,
+                                  const bool symmetric,
+                                  const Array<double> &Bo_,
+                                  const Array<double> &Bc_,
+                                  const Vector &op_,
+                                  Vector &diag_)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_Q1D = HDIV_MAX_Q1D;
+
+   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, symmetric ? 3 : 4, NE);
+   auto diag = Reshape(diag_.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dx = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            double mass[MAX_Q1D];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               mass[qx] = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 1) ? Bc(qy,dy) : Bo(qy,dy);
+                  mass[qx] += wy*wy*((c == 0) ? op(qx,qy,0,e) : op(qx,qy,symmetric ? 2 : 3,e));
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               double val = 0.0;
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx = (c == 0) ? Bc(qx,dx) : Bo(qx,dx);
+                  val += mass[qx] * wx * wx;
+               }
+               diag(dx + (dy * D1Dx) + osc, e) += val;
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop (c) over components
+   }); // end of element loop
+}
+
+MFEM_HOST_DEVICE inline
+void PAHdivMassAssembleDiagonal3D(const int D1D,
+                                  const int Q1D,
+                                  const int NE,
+                                  const bool symmetric,
+                                  const Array<double> &Bo_,
+                                  const Array<double> &Bc_,
+                                  const Vector &op_,
+                                  Vector &diag_)
+{
+   MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
+   MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
+   auto diag = Reshape(diag_.ReadWrite(), 3*(D1D-1)*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D : D1D - 1;
+         const int D1Dy = (c == 1) ? D1D : D1D - 1;
+         const int D1Dx = (c == 0) ? D1D : D1D - 1;
+
+         const int opc = (c == 0) ? 0 : ((c == 1) ? (symmetric ? 3 : 4) :
+                                         (symmetric ? 5 : 8));
+
+         double mass[HDIV_MAX_Q1D];
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  mass[qx] = 0.0;
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wy = (c == 1) ? Bc(qy,dy) : Bo(qy,dy);
+                     for (int qz = 0; qz < Q1D; ++qz)
+                     {
+                        const double wz = (c == 2) ? Bc(qz,dz) : Bo(qz,dz);
+                        mass[qx] += wy * wy * wz * wz * op(qx,qy,qz,opc,e);
+                     }
+                  }
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  double val = 0.0;
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = (c == 0) ? Bc(qx,dx) : Bo(qx,dx);
+                     val += mass[qx] * wx * wx;
+                  }
+                  diag(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += val;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop c
+   }); // end of element loop
+}
+
+MFEM_HOST_DEVICE inline
 void PAHdivMassApply2D(const int D1D,
                        const int Q1D,
                        const int NE,
@@ -307,6 +439,7 @@ void PAHdivMassApply2D(const int D1D,
 }
 
 template<int T_D1D = 0, int T_Q1D = 0>
+MFEM_HOST_DEVICE inline
 void SmemPAHdivMassApply2D(const int NE,
                            const bool symmetric,
                            const Array<double> &Bo_,
@@ -475,131 +608,7 @@ void SmemPAHdivMassApply2D(const int NE,
    });
 }
 
-void PAHdivMassAssembleDiagonal2D(const int D1D,
-                                  const int Q1D,
-                                  const int NE,
-                                  const bool symmetric,
-                                  const Array<double> &Bo_,
-                                  const Array<double> &Bc_,
-                                  const Vector &op_,
-                                  Vector &diag_)
-{
-   constexpr static int VDIM = 2;
-   constexpr static int MAX_Q1D = HDIV_MAX_Q1D;
-
-   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, symmetric ? 3 : 4, NE);
-   auto diag = Reshape(diag_.ReadWrite(), 2*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
-      {
-         const int D1Dx = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 0) ? D1D - 1 : D1D;
-
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            double mass[MAX_Q1D];
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               mass[qx] = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 1) ? Bc(qy,dy) : Bo(qy,dy);
-                  mass[qx] += wy*wy*((c == 0) ? op(qx,qy,0,e) : op(qx,qy,symmetric ? 2 : 3,e));
-               }
-            }
-
-            for (int dx = 0; dx < D1Dx; ++dx)
-            {
-               double val = 0.0;
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  const double wx = (c == 0) ? Bc(qx,dx) : Bo(qx,dx);
-                  val += mass[qx] * wx * wx;
-               }
-               diag(dx + (dy * D1Dx) + osc, e) += val;
-            }
-         }
-
-         osc += D1Dx * D1Dy;
-      }  // loop (c) over components
-   }); // end of element loop
-}
-
-void PAHdivMassAssembleDiagonal3D(const int D1D,
-                                  const int Q1D,
-                                  const int NE,
-                                  const bool symmetric,
-                                  const Array<double> &Bo_,
-                                  const Array<double> &Bc_,
-                                  const Vector &op_,
-                                  Vector &diag_)
-{
-   MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
-   MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
-   constexpr static int VDIM = 3;
-
-   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   auto Bc = Reshape(Bc_.Read(), Q1D, D1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, symmetric ? 6 : 9, NE);
-   auto diag = Reshape(diag_.ReadWrite(), 3*(D1D-1)*(D1D-1)*D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-      {
-         const int D1Dz = (c == 2) ? D1D : D1D - 1;
-         const int D1Dy = (c == 1) ? D1D : D1D - 1;
-         const int D1Dx = (c == 0) ? D1D : D1D - 1;
-
-         const int opc = (c == 0) ? 0 : ((c == 1) ? (symmetric ? 3 : 4) :
-                                         (symmetric ? 5 : 8));
-
-         double mass[HDIV_MAX_Q1D];
-
-         for (int dz = 0; dz < D1Dz; ++dz)
-         {
-            for (int dy = 0; dy < D1Dy; ++dy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  mass[qx] = 0.0;
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     const double wy = (c == 1) ? Bc(qy,dy) : Bo(qy,dy);
-                     for (int qz = 0; qz < Q1D; ++qz)
-                     {
-                        const double wz = (c == 2) ? Bc(qz,dz) : Bo(qz,dz);
-                        mass[qx] += wy * wy * wz * wz * op(qx,qy,qz,opc,e);
-                     }
-                  }
-               }
-
-               for (int dx = 0; dx < D1Dx; ++dx)
-               {
-                  double val = 0.0;
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = (c == 0) ? Bc(qx,dx) : Bo(qx,dx);
-                     val += mass[qx] * wx * wx;
-                  }
-                  diag(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += val;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop c
-   }); // end of element loop
-}
-
+MFEM_HOST_DEVICE inline
 void PAHdivMassApply3D(const int D1D,
                        const int Q1D,
                        const int NE,
@@ -796,6 +805,7 @@ void PAHdivMassApply3D(const int D1D,
 }
 
 template<int T_D1D = 0, int T_Q1D = 0>
+MFEM_HOST_DEVICE inline
 void SmemPAHdivMassApply3D(const int NE,
                            const bool symmetric,
                            const Array<double> &Bo_,
@@ -1083,6 +1093,7 @@ void SmemPAHdivMassApply3D(const int NE,
    });
 }
 
+MFEM_HOST_DEVICE inline
 void PAHdivMassApply(const int dim,
                      const int D1D,
                      const int Q1D,
@@ -1127,13 +1138,14 @@ void PAHdivMassApply(const int dim,
 }
 
 // PA H(div) div-div assemble 2D kernel
-// NOTE: this is identical to PACurlCurlSetup3D
-static void PADivDivSetup2D(const int Q1D,
-                            const int NE,
-                            const Array<double> &w,
-                            const Vector &j,
-                            Vector &coeff_,
-                            Vector &op)
+// NOTE: this is identical to PACurlCurlSetup2D
+MFEM_HOST_DEVICE inline
+void PADivDivSetup2D(const int Q1D,
+                     const int NE,
+                     const Array<double> &w,
+                     const Vector &j,
+                     Vector &coeff_,
+                     Vector &op)
 {
    const int NQ = Q1D*Q1D;
    auto W = w.Read();
@@ -1154,12 +1166,13 @@ static void PADivDivSetup2D(const int Q1D,
    });
 }
 
-static void PADivDivSetup3D(const int Q1D,
-                            const int NE,
-                            const Array<double> &w,
-                            const Vector &j,
-                            Vector &coeff_,
-                            Vector &op)
+MFEM_HOST_DEVICE inline
+void PADivDivSetup3D(const int Q1D,
+                     const int NE,
+                     const Array<double> &w,
+                     const Vector &j,
+                     Vector &coeff_,
+                     Vector &op)
 {
    const int NQ = Q1D*Q1D*Q1D;
    auto W = w.Read();
@@ -1188,16 +1201,141 @@ static void PADivDivSetup3D(const int Q1D,
    });
 }
 
-static void PADivDivApply2D(const int D1D,
-                            const int Q1D,
-                            const int NE,
-                            const Array<double> &Bo_,
-                            const Array<double> &Gc_,
-                            const Array<double> &Bot_,
-                            const Array<double> &Gct_,
-                            const Vector &op_,
-                            const Vector &x_,
-                            Vector &y_)
+MFEM_HOST_DEVICE inline
+void PADivDivAssembleDiagonal2D(const int D1D,
+                                const int Q1D,
+                                const int NE,
+                                const Array<double> &Bo_,
+                                const Array<double> &Gc_,
+                                const Vector &op_,
+                                Vector &diag_)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_Q1D = HDIV_MAX_Q1D;
+
+   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   auto Gc = Reshape(Gc_.Read(), Q1D, D1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, NE);
+   auto diag = Reshape(diag_.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dx = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 0) ? D1D - 1 : D1D;
+
+         double div[MAX_Q1D];
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               div[qx] = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 0) ? Bo(qy,dy) : Gc(qy,dy);
+                  div[qx] += wy * wy * op(qx,qy,e);
+               }
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               double val = 0.0;
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx = (c == 0) ? Gc(qx,dx) : Bo(qx,dx);
+                  val += div[qx] * wx * wx;
+               }
+               diag(dx + (dy * D1Dx) + osc, e) += val;
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop c
+   });
+}
+
+MFEM_HOST_DEVICE inline
+void PADivDivAssembleDiagonal3D(const int D1D,
+                                const int Q1D,
+                                const int NE,
+                                const Array<double> &Bo_,
+                                const Array<double> &Gc_,
+                                const Vector &op_,
+                                Vector &diag_)
+{
+   MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
+   MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
+   constexpr static int VDIM = 3;
+
+   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
+   auto Gc = Reshape(Gc_.Read(), Q1D, D1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, NE);
+   auto diag = Reshape(diag_.ReadWrite(), 3*(D1D-1)*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D : D1D - 1;
+         const int D1Dy = (c == 1) ? D1D : D1D - 1;
+         const int D1Dx = (c == 0) ? D1D : D1D - 1;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double a[HDIV_MAX_Q1D];
+
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  a[qx] = 0.0;
+                  for (int qy = 0; qy < Q1D; ++qy)
+                  {
+                     const double wy = (c == 1) ? Gc(qy,dy) : Bo(qy,dy);
+
+                     for (int qz = 0; qz < Q1D; ++qz)
+                     {
+                        const double wz = (c == 2) ? Gc(qz,dz) : Bo(qz,dz);
+                        a[qx] += wy * wy * wz * wz * op(qx,qy,qz,e);
+                     }
+                  }
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  double val = 0.0;
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = (c == 0) ? Gc(qx,dx) : Bo(qx,dx);
+                     val += a[qx] * wx * wx;
+                  }
+                  diag(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += val;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop c
+   }); // end of element loop
+}
+
+MFEM_HOST_DEVICE inline
+void PADivDivApply2D(const int D1D,
+                     const int Q1D,
+                     const int NE,
+                     const Array<double> &Bo_,
+                     const Array<double> &Gc_,
+                     const Array<double> &Bot_,
+                     const Array<double> &Gct_,
+                     const Vector &op_,
+                     const Vector &x_,
+                     Vector &y_)
 {
    constexpr static int VDIM = 2;
    constexpr static int MAX_D1D = HDIV_MAX_D1D;
@@ -1307,16 +1445,17 @@ static void PADivDivApply2D(const int D1D,
    }); // end of element loop
 }
 
-static void PADivDivApply3D(const int D1D,
-                            const int Q1D,
-                            const int NE,
-                            const Array<double> &Bo_,
-                            const Array<double> &Gc_,
-                            const Array<double> &Bot_,
-                            const Array<double> &Gct_,
-                            const Vector &op_,
-                            const Vector &x_,
-                            Vector &y_)
+MFEM_HOST_DEVICE inline
+void PADivDivApply3D(const int D1D,
+                     const int Q1D,
+                     const int NE,
+                     const Array<double> &Bo_,
+                     const Array<double> &Gc_,
+                     const Array<double> &Bot_,
+                     const Array<double> &Gct_,
+                     const Vector &op_,
+                     const Vector &x_,
+                     Vector &y_)
 {
    MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
    MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
@@ -1483,332 +1622,280 @@ static void PADivDivApply3D(const int D1D,
    }); // end of element loop
 }
 
-void DivDivIntegrator::AssemblePA(const FiniteElementSpace &fes)
+// PA H(div)-L2 (div u, p) assemble 2D kernel
+MFEM_HOST_DEVICE inline
+void PAHdivL2Setup2D(const int Q1D,
+                     const int NE,
+                     const Array<double> &w,
+                     Vector &coeff_,
+                     Vector &op)
 {
-   // Assumes tensor-product elements
-   Mesh *mesh = fes.GetMesh();
-   const FiniteElement *fel = fes.GetFE(0);
-
-   const VectorTensorFiniteElement *el =
-      dynamic_cast<const VectorTensorFiniteElement*>(fel);
-   MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir = IntRule ? IntRule : &MassIntegrator::GetRule
-                               (*el, *el, *mesh->GetElementTransformation(0));
-
-   const int dims = el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   ne = fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   pa_data.SetSize(nq * ne, Device::GetMemoryType());
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
-
-   if (el->GetDerivType() == mfem::FiniteElement::DIV && dim == 3)
-   {
-      PADivDivSetup3D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
-   }
-   else if (el->GetDerivType() == mfem::FiniteElement::DIV && dim == 2)
-   {
-      PADivDivSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
-   }
-   else
+   const int NQ = Q1D*Q1D;
+   auto W = w.Read();
+   auto coeff = Reshape(coeff_.Read(), NQ, NE);
+   auto y = Reshape(op.Write(), NQ, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
-      MFEM_ABORT("Unknown kernel.");
-   }
+      for (int q = 0; q < NQ; ++q)
+      {
+         y(q,e) = W[q] * coeff(q,e);
+      }
+   });
 }
 
-void DivDivIntegrator::AddMultPA(const Vector &x, Vector &y) const
+MFEM_HOST_DEVICE inline
+void PAHdivL2Setup3D(const int Q1D,
+                     const int NE,
+                     const Array<double> &w,
+                     Vector &coeff_,
+                     Vector &op)
 {
-   if (dim == 3)
-      PADivDivApply3D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
-                      mapsO->Bt, mapsC->Gt, pa_data, x, y);
-   else if (dim == 2)
-      PADivDivApply2D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
-                      mapsO->Bt, mapsC->Gt, pa_data, x, y);
-   else
+   const int NQ = Q1D*Q1D*Q1D;
+   auto W = w.Read();
+   auto coeff = Reshape(coeff_.Read(), NQ, NE);
+   auto y = Reshape(op.Write(), NQ, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
-      MFEM_ABORT("Unsupported dimension!");
-   }
+      for (int q = 0; q < NQ; ++q)
+      {
+         y(q,e) = W[q] * coeff(q, e);
+      }
+   });
 }
 
-static void PADivDivAssembleDiagonal2D(const int D1D,
-                                       const int Q1D,
-                                       const int NE,
-                                       const Array<double> &Bo_,
-                                       const Array<double> &Gc_,
-                                       const Vector &op_,
-                                       Vector &diag_)
+MFEM_HOST_DEVICE inline
+void PAHdivL2AssembleDiagonal_ADAt_2D(const int D1D,
+                                      const int Q1D,
+                                      const int L2D1D,
+                                      const int NE,
+                                      const Array<double> &L2Bo_,
+                                      const Array<double> &Gct_,
+                                      const Array<double> &Bot_,
+                                      const Vector &op_,
+                                      const Vector &D_,
+                                      Vector &diag_)
 {
    constexpr static int VDIM = 2;
-   constexpr static int MAX_Q1D = HDIV_MAX_Q1D;
 
-   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   auto Gc = Reshape(Gc_.Read(), Q1D, D1D);
+   auto L2Bo = Reshape(L2Bo_.Read(), Q1D, L2D1D);
+   auto Gct = Reshape(Gct_.Read(), D1D, Q1D);
+   auto Bot = Reshape(Bot_.Read(), D1D-1, Q1D);
    auto op = Reshape(op_.Read(), Q1D, Q1D, NE);
-   auto diag = Reshape(diag_.ReadWrite(), 2*(D1D-1)*D1D, NE);
+   auto D = Reshape(D_.Read(), 2*(D1D-1)*D1D, NE);
+   auto diag = Reshape(diag_.ReadWrite(), L2D1D, L2D1D, NE);
 
    mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      for (int ry = 0; ry < L2D1D; ++ry)
       {
-         const int D1Dx = (c == 1) ? D1D - 1 : D1D;
-         const int D1Dy = (c == 0) ? D1D - 1 : D1D;
+         for (int rx = 0; rx < L2D1D; ++rx)
+         {
+            // Compute row (rx,ry), assuming all contributions are from
+            // a single element.
 
-         double div[MAX_Q1D];
+            double row[2*HDIV_MAX_D1D*(HDIV_MAX_D1D-1)];
+            double div[HDIV_MAX_Q1D][HDIV_MAX_Q1D];
 
-         for (int dy = 0; dy < D1Dy; ++dy)
-         {
-            for (int qx = 0; qx < Q1D; ++qx)
+            for (int i=0; i<2*D1D*(D1D - 1); ++i)
             {
-               div[qx] = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  const double wy = (c == 0) ? Bo(qy,dy) : Gc(qy,dy);
-                  div[qx] += wy * wy * op(qx,qy,e);
-               }
+               row[i] = 0;
             }
 
-            for (int dx = 0; dx < D1Dx; ++dx)
+            for (int qy = 0; qy < Q1D; ++qy)
             {
-               double val = 0.0;
                for (int qx = 0; qx < Q1D; ++qx)
                {
-                  const double wx = (c == 0) ? Gc(qx,dx) : Bo(qx,dx);
-                  val += div[qx] * wx * wx;
+                  div[qy][qx] = op(qx,qy,e) * L2Bo(qx,rx) * L2Bo(qy,ry);
                }
-               diag(dx + (dy * D1Dx) + osc, e) += val;
             }
-         }
 
-         osc += D1Dx * D1Dy;
-      }  // loop c
-   });
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               int osc = 0;
+               for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+               {
+                  const int D1Dy = (c == 1) ? D1D : D1D - 1;
+                  const int D1Dx = (c == 0) ? D1D : D1D - 1;
+
+                  double aX[HDIV_MAX_D1D];
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     aX[dx] = 0;
+                  }
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     for (int dx = 0; dx < D1Dx; ++dx)
+                     {
+                        aX[dx] += div[qy][qx] * ((c == 0) ? Gct(dx,qx) :
+                                                 Bot(dx,qx));
+                     }
+                  }
+
+                  for (int dy = 0; dy < D1Dy; ++dy)
+                  {
+                     const double wy = (c == 1) ? Gct(dy,qy) : Bot(dy,qy);
+
+                     for (int dx = 0; dx < D1Dx; ++dx)
+                     {
+                        row[dx + (dy * D1Dx) + osc] += aX[dx] * wy;
+                     }
+                  }
+
+                  osc += D1Dx * D1Dy;
+               }  // loop c
+            }  // loop qy
+
+            double val = 0.0;
+            for (int i=0; i<2*D1D*(D1D - 1); ++i)
+            {
+               val += row[i] * row[i] * D(i,e);
+            }
+            diag(rx,ry,e) += val;
+         }  // loop rx
+      }  // loop ry
+   }); // end of element loop
 }
 
-static void PADivDivAssembleDiagonal3D(const int D1D,
-                                       const int Q1D,
-                                       const int NE,
-                                       const Array<double> &Bo_,
-                                       const Array<double> &Gc_,
-                                       const Vector &op_,
-                                       Vector &diag_)
+MFEM_HOST_DEVICE inline
+void PAHdivL2AssembleDiagonal_ADAt_3D(const int D1D,
+                                      const int Q1D,
+                                      const int L2D1D,
+                                      const int NE,
+                                      const Array<double> &L2Bo_,
+                                      const Array<double> &Gct_,
+                                      const Array<double> &Bot_,
+                                      const Vector &op_,
+                                      const Vector &D_,
+                                      Vector &diag_)
 {
    MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
    MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
    constexpr static int VDIM = 3;
 
-   auto Bo = Reshape(Bo_.Read(), Q1D, D1D-1);
-   auto Gc = Reshape(Gc_.Read(), Q1D, D1D);
+   auto L2Bo = Reshape(L2Bo_.Read(), Q1D, L2D1D);
+   auto Gct = Reshape(Gct_.Read(), D1D, Q1D);
+   auto Bot = Reshape(Bot_.Read(), D1D-1, Q1D);
    auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, NE);
-   auto diag = Reshape(diag_.ReadWrite(), 3*(D1D-1)*(D1D-1)*D1D, NE);
+   auto D = Reshape(D_.Read(), 3*(D1D-1)*(D1D-1)*D1D, NE);
+   auto diag = Reshape(diag_.ReadWrite(), L2D1D, L2D1D, L2D1D, NE);
 
    mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
-      int osc = 0;
-
-      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      for (int rz = 0; rz < L2D1D; ++rz)
       {
-         const int D1Dz = (c == 2) ? D1D : D1D - 1;
-         const int D1Dy = (c == 1) ? D1D : D1D - 1;
-         const int D1Dx = (c == 0) ? D1D : D1D - 1;
-
-         for (int dz = 0; dz < D1Dz; ++dz)
+         for (int ry = 0; ry < L2D1D; ++ry)
          {
-            for (int dy = 0; dy < D1Dy; ++dy)
+            for (int rx = 0; rx < L2D1D; ++rx)
             {
-               double a[HDIV_MAX_Q1D];
+               // Compute row (rx,ry,rz), assuming all contributions are from
+               // a single element.
 
-               for (int qx = 0; qx < Q1D; ++qx)
+               double row[3*HDIV_MAX_D1D*(HDIV_MAX_D1D-1)*(HDIV_MAX_D1D-1)];
+               double div[HDIV_MAX_Q1D][HDIV_MAX_Q1D][HDIV_MAX_Q1D];
+
+               for (int i=0; i<3*D1D*(D1D - 1)*(D1D - 1); ++i)
+               {
+                  row[i] = 0;
+               }
+
+               for (int qz = 0; qz < Q1D; ++qz)
                {
-                  a[qx] = 0.0;
                   for (int qy = 0; qy < Q1D; ++qy)
                   {
-                     const double wy = (c == 1) ? Gc(qy,dy) : Bo(qy,dy);
-
-                     for (int qz = 0; qz < Q1D; ++qz)
+                     for (int qx = 0; qx < Q1D; ++qx)
                      {
-                        const double wz = (c == 2) ? Gc(qz,dz) : Bo(qz,dz);
-                        a[qx] += wy * wy * wz * wz * op(qx,qy,qz,e);
+                        div[qz][qy][qx] = op(qx,qy,qz,e) * L2Bo(qx,rx) *
+                                          L2Bo(qy,ry) * L2Bo(qz,rz);
                      }
                   }
                }
 
-               for (int dx = 0; dx < D1Dx; ++dx)
+               for (int qz = 0; qz < Q1D; ++qz)
                {
-                  double val = 0.0;
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     const double wx = (c == 0) ? Gc(qx,dx) : Bo(qx,dx);
-                     val += a[qx] * wx * wx;
-                  }
-                  diag(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += val;
-               }
-            }
-         }
-
-         osc += D1Dx * D1Dy * D1Dz;
-      }  // loop c
-   }); // end of element loop
-}
-
-void DivDivIntegrator::AssembleDiagonalPA(Vector& diag)
-{
-   if (dim == 3)
-   {
-      PADivDivAssembleDiagonal3D(dofs1D, quad1D, ne,
-                                 mapsO->B, mapsC->G, pa_data, diag);
-   }
-   else
-   {
-      PADivDivAssembleDiagonal2D(dofs1D, quad1D, ne,
-                                 mapsO->B, mapsC->G, pa_data, diag);
-   }
-}
-
-// PA H(div)-L2 (div u, p) assemble 2D kernel
-static void PADivL2Setup2D(const int Q1D,
-                           const int NE,
-                           const Array<double> &w,
-                           Vector &coeff_,
-                           Vector &op)
-{
-   const int NQ = Q1D*Q1D;
-   auto W = w.Read();
-   auto coeff = Reshape(coeff_.Read(), NQ, NE);
-   auto y = Reshape(op.Write(), NQ, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int q = 0; q < NQ; ++q)
-      {
-         y(q,e) = W[q] * coeff(q,e);
-      }
-   });
-}
-
-static void PADivL2Setup3D(const int Q1D,
-                           const int NE,
-                           const Array<double> &w,
-                           Vector &coeff_,
-                           Vector &op)
-{
-   const int NQ = Q1D*Q1D*Q1D;
-   auto W = w.Read();
-   auto coeff = Reshape(coeff_.Read(), NQ, NE);
-   auto y = Reshape(op.Write(), NQ, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int q = 0; q < NQ; ++q)
-      {
-         y(q,e) = W[q] * coeff(q, e);
-      }
-   });
-}
-
-void
-VectorFEDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                         const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with a vector test space and
-   // scalar trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const VectorTensorFiniteElement *trial_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const NodalTensorFiniteElement *test_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir = IntRule ? IntRule : &MassIntegrator::GetRule(
-                                  *trial_el, *trial_el,
-                                  *mesh->GetElementTransformation(0));
-
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder() + 1, "");
-
-   ne = trial_fes.GetNE();
-   mapsC = &trial_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   L2mapsO = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   L2dofs1D = L2mapsO->ndof;
+                  double aXY[HDIV_MAX_D1D][HDIV_MAX_D1D];
 
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-   if (dim == 2)
-   {
-      MFEM_VERIFY(nq == quad1D * quad1D, "");
-   }
-   else
-   {
-      MFEM_VERIFY(nq == quad1D * quad1D * quad1D, "");
-   }
+                  int osc = 0;
+                  for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+                  {
+                     const int D1Dz = (c == 2) ? D1D : D1D - 1;
+                     const int D1Dy = (c == 1) ? D1D : D1D - 1;
+                     const int D1Dx = (c == 0) ? D1D : D1D - 1;
 
-   pa_data.SetSize(nq * ne, Device::GetMemoryType());
+                     for (int dy = 0; dy < D1Dy; ++dy)
+                     {
+                        for (int dx = 0; dx < D1Dx; ++dx)
+                        {
+                           aXY[dy][dx] = 0;
+                        }
+                     }
+                     for (int qy = 0; qy < Q1D; ++qy)
+                     {
+                        double aX[HDIV_MAX_D1D];
+                        for (int dx = 0; dx < D1Dx; ++dx)
+                        {
+                           aX[dx] = 0;
+                        }
+                        for (int qx = 0; qx < Q1D; ++qx)
+                        {
+                           for (int dx = 0; dx < D1Dx; ++dx)
+                           {
+                              aX[dx] += div[qz][qy][qx] * ((c == 0) ? Gct(dx,qx)
+                                                           : Bot(dx,qx));
+                           }
+                        }
+                        for (int dy = 0; dy < D1Dy; ++dy)
+                        {
+                           const double wy = (c == 1) ? Gct(dy,qy) : Bot(dy,qy);
+                           for (int dx = 0; dx < D1Dx; ++dx)
+                           {
+                              aXY[dy][dx] += aX[dx] * wy;
+                           }
+                        }
+                     }
 
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
+                     for (int dz = 0; dz < D1Dz; ++dz)
+                     {
+                        const double wz = (c == 2) ? Gct(dz,qz) : Bot(dz,qz);
+                        for (int dy = 0; dy < D1Dy; ++dy)
+                        {
+                           for (int dx = 0; dx < D1Dx; ++dx)
+                           {
+                              row[dx + ((dy + (dz * D1Dy)) * D1Dx) + osc] +=
+                                 aXY[dy][dx] * wz;
+                           }
+                        }
+                     }
 
-   if (test_el->GetMapType() == FiniteElement::INTEGRAL)
-   {
-      const GeometricFactors *geom =
-         mesh->GetGeometricFactors(*ir, GeometricFactors::DETERMINANTS);
-      coeff /= geom->detJ;
-   }
+                     osc += D1Dx * D1Dy * D1Dz;
+                  }  // loop c
+               }  // loop qz
 
-   if (trial_el->GetDerivType() == mfem::FiniteElement::DIV && dim == 3)
-   {
-      PADivL2Setup3D(quad1D, ne, ir->GetWeights(), coeff, pa_data);
-   }
-   else if (trial_el->GetDerivType() == mfem::FiniteElement::DIV && dim == 2)
-   {
-      PADivL2Setup2D(quad1D, ne, ir->GetWeights(), coeff, pa_data);
-   }
-   else
-   {
-      MFEM_ABORT("Unknown kernel.");
-   }
+               double val = 0.0;
+               for (int i=0; i<3*D1D*(D1D - 1)*(D1D - 1); ++i)
+               {
+                  val += row[i] * row[i] * D(i,e);
+               }
+               diag(rx,ry,rz,e) += val;
+            }  // loop rx
+         }  // loop ry
+      }  // loop rz
+   }); // end of element loop
 }
 
 // Apply to x corresponding to DOFs in H(div) (trial), whose divergence is
 // integrated against L_2 test functions corresponding to y.
-static void PAHdivL2Apply3D(const int D1D,
-                            const int Q1D,
-                            const int L2D1D,
-                            const int NE,
-                            const Array<double> &Bo_,
-                            const Array<double> &Gc_,
-                            const Array<double> &L2Bot_,
-                            const Vector &op_,
-                            const Vector &x_,
-                            Vector &y_)
+MFEM_HOST_DEVICE inline
+void PAHdivL2Apply3D(const int D1D,
+                     const int Q1D,
+                     const int L2D1D,
+                     const int NE,
+                     const Array<double> &Bo_,
+                     const Array<double> &Gc_,
+                     const Array<double> &L2Bot_,
+                     const Vector &op_,
+                     const Vector &x_,
+                     Vector &y_)
 {
    MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
    MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
@@ -1962,16 +2049,17 @@ static void PAHdivL2Apply3D(const int D1D,
 
 // Apply to x corresponding to DOFs in H(div) (trial), whose divergence is
 // integrated against L_2 test functions corresponding to y.
-static void PAHdivL2Apply2D(const int D1D,
-                            const int Q1D,
-                            const int L2D1D,
-                            const int NE,
-                            const Array<double> &Bo_,
-                            const Array<double> &Gc_,
-                            const Array<double> &L2Bot_,
-                            const Vector &op_,
-                            const Vector &x_,
-                            Vector &y_)
+MFEM_HOST_DEVICE inline
+void PAHdivL2Apply2D(const int D1D,
+                     const int Q1D,
+                     const int L2D1D,
+                     const int NE,
+                     const Array<double> &Bo_,
+                     const Array<double> &Gc_,
+                     const Array<double> &L2Bot_,
+                     const Vector &op_,
+                     const Vector &x_,
+                     Vector &y_)
 {
    constexpr static int VDIM = 2;
    constexpr static int MAX_D1D = HDIV_MAX_D1D;
@@ -2068,16 +2156,17 @@ static void PAHdivL2Apply2D(const int D1D,
    }); // end of element loop
 }
 
-static void PAHdivL2ApplyTranspose3D(const int D1D,
-                                     const int Q1D,
-                                     const int L2D1D,
-                                     const int NE,
-                                     const Array<double> &L2Bo_,
-                                     const Array<double> &Gct_,
-                                     const Array<double> &Bot_,
-                                     const Vector &op_,
-                                     const Vector &x_,
-                                     Vector &y_)
+MFEM_HOST_DEVICE inline
+void PAHdivL2ApplyTranspose3D(const int D1D,
+                              const int Q1D,
+                              const int L2D1D,
+                              const int NE,
+                              const Array<double> &L2Bo_,
+                              const Array<double> &Gct_,
+                              const Array<double> &Bot_,
+                              const Vector &op_,
+                              const Vector &x_,
+                              Vector &y_)
 {
    MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
    MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
@@ -2230,16 +2319,17 @@ static void PAHdivL2ApplyTranspose3D(const int D1D,
    }); // end of element loop
 }
 
-static void PAHdivL2ApplyTranspose2D(const int D1D,
-                                     const int Q1D,
-                                     const int L2D1D,
-                                     const int NE,
-                                     const Array<double> &L2Bo_,
-                                     const Array<double> &Gct_,
-                                     const Array<double> &Bot_,
-                                     const Vector &op_,
-                                     const Vector &x_,
-                                     Vector &y_)
+MFEM_HOST_DEVICE inline
+void PAHdivL2ApplyTranspose2D(const int D1D,
+                              const int Q1D,
+                              const int L2D1D,
+                              const int NE,
+                              const Array<double> &L2Bo_,
+                              const Array<double> &Gct_,
+                              const Array<double> &Bot_,
+                              const Vector &op_,
+                              const Vector &x_,
+                              Vector &y_)
 {
    constexpr static int VDIM = 2;
    constexpr static int MAX_D1D = HDIV_MAX_D1D;
@@ -2336,265 +2426,8 @@ static void PAHdivL2ApplyTranspose2D(const int D1D,
    }); // end of element loop
 }
 
-void VectorFEDivergenceIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-      PAHdivL2Apply3D(dofs1D, quad1D, L2dofs1D, ne, mapsO->B, mapsC->G,
-                      L2mapsO->Bt, pa_data, x, y);
-   else if (dim == 2)
-      PAHdivL2Apply2D(dofs1D, quad1D, L2dofs1D, ne, mapsO->B, mapsC->G,
-                      L2mapsO->Bt, pa_data, x, y);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-void VectorFEDivergenceIntegrator::AddMultTransposePA(const Vector &x,
-                                                      Vector &y) const
-{
-   if (dim == 3)
-      PAHdivL2ApplyTranspose3D(dofs1D, quad1D, L2dofs1D, ne, L2mapsO->B,
-                               mapsC->Gt, mapsO->Bt, pa_data, x, y);
-   else if (dim == 2)
-      PAHdivL2ApplyTranspose2D(dofs1D, quad1D, L2dofs1D, ne, L2mapsO->B,
-                               mapsC->Gt, mapsO->Bt, pa_data, x, y);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
-
-static void PAHdivL2AssembleDiagonal_ADAt_3D(const int D1D,
-                                             const int Q1D,
-                                             const int L2D1D,
-                                             const int NE,
-                                             const Array<double> &L2Bo_,
-                                             const Array<double> &Gct_,
-                                             const Array<double> &Bot_,
-                                             const Vector &op_,
-                                             const Vector &D_,
-                                             Vector &diag_)
-{
-   MFEM_VERIFY(D1D <= HDIV_MAX_D1D, "Error: D1D > HDIV_MAX_D1D");
-   MFEM_VERIFY(Q1D <= HDIV_MAX_Q1D, "Error: Q1D > HDIV_MAX_Q1D");
-   constexpr static int VDIM = 3;
-
-   auto L2Bo = Reshape(L2Bo_.Read(), Q1D, L2D1D);
-   auto Gct = Reshape(Gct_.Read(), D1D, Q1D);
-   auto Bot = Reshape(Bot_.Read(), D1D-1, Q1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, NE);
-   auto D = Reshape(D_.Read(), 3*(D1D-1)*(D1D-1)*D1D, NE);
-   auto diag = Reshape(diag_.ReadWrite(), L2D1D, L2D1D, L2D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int rz = 0; rz < L2D1D; ++rz)
-      {
-         for (int ry = 0; ry < L2D1D; ++ry)
-         {
-            for (int rx = 0; rx < L2D1D; ++rx)
-            {
-               // Compute row (rx,ry,rz), assuming all contributions are from
-               // a single element.
-
-               double row[3*HDIV_MAX_D1D*(HDIV_MAX_D1D-1)*(HDIV_MAX_D1D-1)];
-               double div[HDIV_MAX_Q1D][HDIV_MAX_Q1D][HDIV_MAX_Q1D];
-
-               for (int i=0; i<3*D1D*(D1D - 1)*(D1D - 1); ++i)
-               {
-                  row[i] = 0;
-               }
-
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  for (int qy = 0; qy < Q1D; ++qy)
-                  {
-                     for (int qx = 0; qx < Q1D; ++qx)
-                     {
-                        div[qz][qy][qx] = op(qx,qy,qz,e) * L2Bo(qx,rx) *
-                                          L2Bo(qy,ry) * L2Bo(qz,rz);
-                     }
-                  }
-               }
-
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  double aXY[HDIV_MAX_D1D][HDIV_MAX_D1D];
-
-                  int osc = 0;
-                  for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-                  {
-                     const int D1Dz = (c == 2) ? D1D : D1D - 1;
-                     const int D1Dy = (c == 1) ? D1D : D1D - 1;
-                     const int D1Dx = (c == 0) ? D1D : D1D - 1;
-
-                     for (int dy = 0; dy < D1Dy; ++dy)
-                     {
-                        for (int dx = 0; dx < D1Dx; ++dx)
-                        {
-                           aXY[dy][dx] = 0;
-                        }
-                     }
-                     for (int qy = 0; qy < Q1D; ++qy)
-                     {
-                        double aX[HDIV_MAX_D1D];
-                        for (int dx = 0; dx < D1Dx; ++dx)
-                        {
-                           aX[dx] = 0;
-                        }
-                        for (int qx = 0; qx < Q1D; ++qx)
-                        {
-                           for (int dx = 0; dx < D1Dx; ++dx)
-                           {
-                              aX[dx] += div[qz][qy][qx] * ((c == 0) ? Gct(dx,qx)
-                                                           : Bot(dx,qx));
-                           }
-                        }
-                        for (int dy = 0; dy < D1Dy; ++dy)
-                        {
-                           const double wy = (c == 1) ? Gct(dy,qy) : Bot(dy,qy);
-                           for (int dx = 0; dx < D1Dx; ++dx)
-                           {
-                              aXY[dy][dx] += aX[dx] * wy;
-                           }
-                        }
-                     }
-
-                     for (int dz = 0; dz < D1Dz; ++dz)
-                     {
-                        const double wz = (c == 2) ? Gct(dz,qz) : Bot(dz,qz);
-                        for (int dy = 0; dy < D1Dy; ++dy)
-                        {
-                           for (int dx = 0; dx < D1Dx; ++dx)
-                           {
-                              row[dx + ((dy + (dz * D1Dy)) * D1Dx) + osc] +=
-                                 aXY[dy][dx] * wz;
-                           }
-                        }
-                     }
-
-                     osc += D1Dx * D1Dy * D1Dz;
-                  }  // loop c
-               }  // loop qz
-
-               double val = 0.0;
-               for (int i=0; i<3*D1D*(D1D - 1)*(D1D - 1); ++i)
-               {
-                  val += row[i] * row[i] * D(i,e);
-               }
-               diag(rx,ry,rz,e) += val;
-            }  // loop rx
-         }  // loop ry
-      }  // loop rz
-   }); // end of element loop
-}
-
-static void PAHdivL2AssembleDiagonal_ADAt_2D(const int D1D,
-                                             const int Q1D,
-                                             const int L2D1D,
-                                             const int NE,
-                                             const Array<double> &L2Bo_,
-                                             const Array<double> &Gct_,
-                                             const Array<double> &Bot_,
-                                             const Vector &op_,
-                                             const Vector &D_,
-                                             Vector &diag_)
-{
-   constexpr static int VDIM = 2;
-
-   auto L2Bo = Reshape(L2Bo_.Read(), Q1D, L2D1D);
-   auto Gct = Reshape(Gct_.Read(), D1D, Q1D);
-   auto Bot = Reshape(Bot_.Read(), D1D-1, Q1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, NE);
-   auto D = Reshape(D_.Read(), 2*(D1D-1)*D1D, NE);
-   auto diag = Reshape(diag_.ReadWrite(), L2D1D, L2D1D, NE);
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      for (int ry = 0; ry < L2D1D; ++ry)
-      {
-         for (int rx = 0; rx < L2D1D; ++rx)
-         {
-            // Compute row (rx,ry), assuming all contributions are from
-            // a single element.
-
-            double row[2*HDIV_MAX_D1D*(HDIV_MAX_D1D-1)];
-            double div[HDIV_MAX_Q1D][HDIV_MAX_Q1D];
-
-            for (int i=0; i<2*D1D*(D1D - 1); ++i)
-            {
-               row[i] = 0;
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  div[qy][qx] = op(qx,qy,e) * L2Bo(qx,rx) * L2Bo(qy,ry);
-               }
-            }
-
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               int osc = 0;
-               for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
-               {
-                  const int D1Dy = (c == 1) ? D1D : D1D - 1;
-                  const int D1Dx = (c == 0) ? D1D : D1D - 1;
-
-                  double aX[HDIV_MAX_D1D];
-                  for (int dx = 0; dx < D1Dx; ++dx)
-                  {
-                     aX[dx] = 0;
-                  }
-                  for (int qx = 0; qx < Q1D; ++qx)
-                  {
-                     for (int dx = 0; dx < D1Dx; ++dx)
-                     {
-                        aX[dx] += div[qy][qx] * ((c == 0) ? Gct(dx,qx) :
-                                                 Bot(dx,qx));
-                     }
-                  }
-
-                  for (int dy = 0; dy < D1Dy; ++dy)
-                  {
-                     const double wy = (c == 1) ? Gct(dy,qy) : Bot(dy,qy);
-
-                     for (int dx = 0; dx < D1Dx; ++dx)
-                     {
-                        row[dx + (dy * D1Dx) + osc] += aX[dx] * wy;
-                     }
-                  }
-
-                  osc += D1Dx * D1Dy;
-               }  // loop c
-            }  // loop qy
-
-            double val = 0.0;
-            for (int i=0; i<2*D1D*(D1D - 1); ++i)
-            {
-               val += row[i] * row[i] * D(i,e);
-            }
-            diag(rx,ry,e) += val;
-         }  // loop rx
-      }  // loop ry
-   }); // end of element loop
-}
-
-void VectorFEDivergenceIntegrator::AssembleDiagonalPA_ADAt(const Vector &D,
-                                                           Vector &diag)
-{
-   if (dim == 3)
-      PAHdivL2AssembleDiagonal_ADAt_3D(dofs1D, quad1D, L2dofs1D, ne, L2mapsO->B,
-                                       mapsC->Gt, mapsO->Bt, pa_data, D, diag);
-   else if (dim == 2)
-      PAHdivL2AssembleDiagonal_ADAt_2D(dofs1D, quad1D, L2dofs1D, ne, L2mapsO->B,
-                                       mapsC->Gt, mapsO->Bt, pa_data, D, diag);
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
-}
+} // namespace internal
 
 } // namespace mfem
+
+#endif
diff --git a/fem/integ/bilininteg_interp_pa.cpp b/fem/integ/bilininteg_interp_pa.cpp
new file mode 100644
index 000000000..3cac18c65
--- /dev/null
+++ b/fem/integ/bilininteg_interp_pa.cpp
@@ -0,0 +1,1937 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+
+namespace mfem
+{
+
+// Apply to x corresponding to DOFs in H^1 (domain) the (topological) gradient
+// to get a dof in H(curl) (range). You can think of the range as the "test" space
+// and the domain as the "trial" space, but there's no integration.
+static void PAHcurlApplyGradient2D(const int c_dofs1D,
+                                   const int o_dofs1D,
+                                   const int NE,
+                                   const Array<double> &B_,
+                                   const Array<double> &G_,
+                                   const Vector &x_,
+                                   Vector &y_)
+{
+   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, NE);
+   auto y = Reshape(y_.ReadWrite(), 2 * c_dofs1D * o_dofs1D, NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[MAX_D1D][MAX_D1D];
+
+      // horizontal part
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            w[dx][ey] = 0.0;
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               w[dx][ey] += B(ey, dy) * x(dx, dy, e);
+            }
+         }
+      }
+
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            double s = 0.0;
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               s += G(ex, dx) * w[dx][ey];
+            }
+            const int local_index = ey*o_dofs1D + ex;
+            y(local_index, e) += s;
+         }
+      }
+
+      // vertical part
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            w[dx][ey] = 0.0;
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               w[dx][ey] += G(ey, dy) * x(dx, dy, e);
+            }
+         }
+      }
+
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            double s = 0.0;
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               s += B(ex, dx) * w[dx][ey];
+            }
+            const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
+            y(local_index, e) += s;
+         }
+      }
+   });
+}
+
+// Specialization of PAHcurlApplyGradient2D to the case where B is identity
+static void PAHcurlApplyGradient2DBId(const int c_dofs1D,
+                                      const int o_dofs1D,
+                                      const int NE,
+                                      const Array<double> &G_,
+                                      const Vector &x_,
+                                      Vector &y_)
+{
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, NE);
+   auto y = Reshape(y_.ReadWrite(), 2 * c_dofs1D * o_dofs1D, NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[MAX_D1D][MAX_D1D];
+
+      // horizontal part
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            const int dy = ey;
+            w[dx][ey] = x(dx, dy, e);
+         }
+      }
+
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            double s = 0.0;
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               s += G(ex, dx) * w[dx][ey];
+            }
+            const int local_index = ey*o_dofs1D + ex;
+            y(local_index, e) += s;
+         }
+      }
+
+      // vertical part
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            w[dx][ey] = 0.0;
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               w[dx][ey] += G(ey, dy) * x(dx, dy, e);
+            }
+         }
+      }
+
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            const int dx = ex;
+            const double s = w[dx][ey];
+            const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
+            y(local_index, e) += s;
+         }
+      }
+   });
+}
+
+static void PAHcurlApplyGradientTranspose2D(
+   const int c_dofs1D, const int o_dofs1D, const int NE,
+   const Array<double> &B_, const Array<double> &G_,
+   const Vector &x_, Vector &y_)
+{
+   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), 2 * c_dofs1D * o_dofs1D, NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[MAX_D1D][MAX_D1D];
+
+      // horizontal part (open x, closed y)
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            w[dy][ex] = 0.0;
+            for (int ey = 0; ey < c_dofs1D; ++ey)
+            {
+               const int local_index = ey*o_dofs1D + ex;
+               w[dy][ex] += B(ey, dy) * x(local_index, e);
+            }
+         }
+      }
+
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            double s = 0.0;
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               s += G(ex, dx) * w[dy][ex];
+            }
+            y(dx, dy, e) += s;
+         }
+      }
+
+      // vertical part (open y, closed x)
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            w[dy][ex] = 0.0;
+            for (int ey = 0; ey < o_dofs1D; ++ey)
+            {
+               const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
+               w[dy][ex] += G(ey, dy) * x(local_index, e);
+            }
+         }
+      }
+
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            double s = 0.0;
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               s += B(ex, dx) * w[dy][ex];
+            }
+            y(dx, dy, e) += s;
+         }
+      }
+   });
+}
+
+// Specialization of PAHcurlApplyGradientTranspose2D to the case where
+// B is identity
+static void PAHcurlApplyGradientTranspose2DBId(
+   const int c_dofs1D, const int o_dofs1D, const int NE,
+   const Array<double> &G_,
+   const Vector &x_, Vector &y_)
+{
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), 2 * c_dofs1D * o_dofs1D, NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[MAX_D1D][MAX_D1D];
+
+      // horizontal part (open x, closed y)
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            const int ey = dy;
+            const int local_index = ey*o_dofs1D + ex;
+            w[dy][ex] = x(local_index, e);
+         }
+      }
+
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            double s = 0.0;
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               s += G(ex, dx) * w[dy][ex];
+            }
+            y(dx, dy, e) += s;
+         }
+      }
+
+      // vertical part (open y, closed x)
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            w[dy][ex] = 0.0;
+            for (int ey = 0; ey < o_dofs1D; ++ey)
+            {
+               const int local_index = c_dofs1D * o_dofs1D + ey*c_dofs1D + ex;
+               w[dy][ex] += G(ey, dy) * x(local_index, e);
+            }
+         }
+      }
+
+      for (int dy = 0; dy < c_dofs1D; ++dy)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            const int ex = dx;
+            const double s = w[dy][ex];
+            y(dx, dy, e) += s;
+         }
+      }
+   });
+}
+
+static void PAHcurlApplyGradient3D(const int c_dofs1D,
+                                   const int o_dofs1D,
+                                   const int NE,
+                                   const Array<double> &B_,
+                                   const Array<double> &G_,
+                                   const Vector &x_,
+                                   Vector &y_)
+{
+   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
+   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
+
+      // ---
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+      // ---
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               w1[dx][dy][ez] = 0.0;
+               for (int dz = 0; dz < c_dofs1D; ++dz)
+               {
+                  w1[dx][dy][ez] += B(ez, dz) * x(dx, dy, dz, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               w2[dx][ey][ez] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w2[dx][ey][ez] += B(ey, dy) * w1[dx][dy][ez];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += G(ex, dx) * w2[dx][ey][ez];
+               }
+               const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+               y(local_index, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+      // ---
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               w1[dx][dy][ez] = 0.0;
+               for (int dz = 0; dz < c_dofs1D; ++dz)
+               {
+                  w1[dx][dy][ez] += B(ez, dz) * x(dx, dy, dz, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               w2[dx][ey][ez] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w2[dx][ey][ez] += G(ey, dy) * w1[dx][dy][ez];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += B(ex, dx) * w2[dx][ey][ez];
+               }
+               const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                       ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+               y(local_index, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+      // ---
+
+      // contract in z
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               w1[dx][dy][ez] = 0.0;
+               for (int dz = 0; dz < c_dofs1D; ++dz)
+               {
+                  w1[dx][dy][ez] += G(ez, dz) * x(dx, dy, dz, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               w2[dx][ey][ez] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w2[dx][ey][ez] += B(ey, dy) * w1[dx][dy][ez];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += B(ex, dx) * w2[dx][ey][ez];
+               }
+               const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                       ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+               y(local_index, e) += s;
+            }
+         }
+      }
+   });
+}
+
+// Specialization of PAHcurlApplyGradient3D to the case where
+static void PAHcurlApplyGradient3DBId(const int c_dofs1D,
+                                      const int o_dofs1D,
+                                      const int NE,
+                                      const Array<double> &G_,
+                                      const Vector &x_,
+                                      Vector &y_)
+{
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
+   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
+
+      // ---
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+      // ---
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               const int dz = ez;
+               w1[dx][dy][ez] = x(dx, dy, dz, e);
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               const int dy = ey;
+               w2[dx][ey][ez] = w1[dx][dy][ez];
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += G(ex, dx) * w2[dx][ey][ez];
+               }
+               const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+               y(local_index, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+      // ---
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               const int dz = ez;
+               w1[dx][dy][ez] = x(dx, dy, dz, e);
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               w2[dx][ey][ez] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w2[dx][ey][ez] += G(ey, dy) * w1[dx][dy][ez];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               const int dx = ex;
+               const double s = w2[dx][ey][ez];
+               const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                       ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+               y(local_index, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+      // ---
+
+      // contract in z
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               w1[dx][dy][ez] = 0.0;
+               for (int dz = 0; dz < c_dofs1D; ++dz)
+               {
+                  w1[dx][dy][ez] += G(ez, dz) * x(dx, dy, dz, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               const int dy = ey;
+               w2[dx][ey][ez] = w1[dx][dy][ez];
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               const int dx = ex;
+               const double s = w2[dx][ey][ez];
+               const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                       ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+               y(local_index, e) += s;
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlApplyGradientTranspose3D(
+   const int c_dofs1D, const int o_dofs1D, const int NE,
+   const Array<double> &B_, const Array<double> &G_,
+   const Vector &x_, Vector &y_)
+{
+   auto B = Reshape(B_.Read(), c_dofs1D, c_dofs1D);
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
+      // ---
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+      // ---
+
+      // contract in z
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            for (int ey = 0; ey < c_dofs1D; ++ey)
+            {
+               w1[ex][ey][dz] = 0.0;
+               for (int ez = 0; ez < c_dofs1D; ++ez)
+               {
+                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+                  w1[ex][ey][dz] += B(ez, dz) * x(local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               w2[ex][dy][dz] = 0.0;
+               for (int ey = 0; ey < c_dofs1D; ++ey)
+               {
+                  w2[ex][dy][dz] += B(ey, dy) * w1[ex][ey][dz];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               double s = 0.0;
+               for (int ex = 0; ex < o_dofs1D; ++ex)
+               {
+                  s += G(ex, dx) * w2[ex][dy][dz];
+               }
+               y(dx, dy, dz, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+      // ---
+
+      // contract in z
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            for (int ey = 0; ey < o_dofs1D; ++ey)
+            {
+               w1[ex][ey][dz] = 0.0;
+               for (int ez = 0; ez < c_dofs1D; ++ez)
+               {
+                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+                  w1[ex][ey][dz] += B(ez, dz) * x(local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               w2[ex][dy][dz] = 0.0;
+               for (int ey = 0; ey < o_dofs1D; ++ey)
+               {
+                  w2[ex][dy][dz] += G(ey, dy) * w1[ex][ey][dz];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               double s = 0.0;
+               for (int ex = 0; ex < c_dofs1D; ++ex)
+               {
+                  s += B(ex, dx) * w2[ex][dy][dz];
+               }
+               y(dx, dy, dz, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+      // ---
+
+      // contract in z
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            for (int ey = 0; ey < c_dofs1D; ++ey)
+            {
+               w1[ex][ey][dz] = 0.0;
+               for (int ez = 0; ez < o_dofs1D; ++ez)
+               {
+                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+                  w1[ex][ey][dz] += G(ez, dz) * x(local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               w2[ex][dy][dz] = 0.0;
+               for (int ey = 0; ey < c_dofs1D; ++ey)
+               {
+                  w2[ex][dy][dz] += B(ey, dy) * w1[ex][ey][dz];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               double s = 0.0;
+               for (int ex = 0; ex < c_dofs1D; ++ex)
+               {
+                  s += B(ex, dx) * w2[ex][dy][dz];
+               }
+               y(dx, dy, dz, e) += s;
+            }
+         }
+      }
+   });
+}
+
+// Specialization of PAHcurlApplyGradientTranspose3D to the case where
+static void PAHcurlApplyGradientTranspose3DBId(
+   const int c_dofs1D, const int o_dofs1D, const int NE,
+   const Array<double> &G_,
+   const Vector &x_, Vector &y_)
+{
+   auto G = Reshape(G_.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[MAX_D1D][MAX_D1D][MAX_D1D];
+      // ---
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+      // ---
+
+      // contract in z
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            for (int ey = 0; ey < c_dofs1D; ++ey)
+            {
+               const int ez = dz;
+               const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+               w1[ex][ey][dz] = x(local_index, e);
+            }
+         }
+      }
+
+      // contract in y
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               const int ey = dy;
+               w2[ex][dy][dz] = w1[ex][ey][dz];
+            }
+         }
+      }
+
+      // contract in x
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               double s = 0.0;
+               for (int ex = 0; ex < o_dofs1D; ++ex)
+               {
+                  s += G(ex, dx) * w2[ex][dy][dz];
+               }
+               y(dx, dy, dz, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+      // ---
+
+      // contract in z
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            for (int ey = 0; ey < o_dofs1D; ++ey)
+            {
+               const int ez = dz;
+               const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                       ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+               w1[ex][ey][dz] = x(local_index, e);
+            }
+         }
+      }
+
+      // contract in y
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               w2[ex][dy][dz] = 0.0;
+               for (int ey = 0; ey < o_dofs1D; ++ey)
+               {
+                  w2[ex][dy][dz] += G(ey, dy) * w1[ex][ey][dz];
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               const int ex = dx;
+               double s = w2[ex][dy][dz];
+               y(dx, dy, dz, e) += s;
+            }
+         }
+      }
+
+      // ---
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+      // ---
+
+      // contract in z
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            for (int ey = 0; ey < c_dofs1D; ++ey)
+            {
+               w1[ex][ey][dz] = 0.0;
+               for (int ez = 0; ez < o_dofs1D; ++ez)
+               {
+                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+                  w1[ex][ey][dz] += G(ez, dz) * x(local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               const int ey = dy;
+               w2[ex][dy][dz] = w1[ex][ey][dz];
+            }
+         }
+      }
+
+      // contract in x
+      for (int dz = 0; dz < c_dofs1D; ++dz)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               const int ex = dx;
+               double s = w2[ex][dy][dz];
+               y(dx, dy, dz, e) += s;
+            }
+         }
+      }
+   });
+}
+
+void GradientInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "Bad dimension!");
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "Bad dimension!");
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(),
+               "Orders do not match!");
+   ne = trial_fes.GetNE();
+
+   const int order = trial_el->GetOrder();
+   dofquad_fe = new H1_SegmentElement(order, trial_el->GetBasisType());
+   mfem::QuadratureFunctions1D qf1d;
+   mfem::IntegrationRule closed_ir;
+   closed_ir.SetSize(order + 1);
+   qf1d.GaussLobatto(order + 1, &closed_ir);
+   mfem::IntegrationRule open_ir;
+   open_ir.SetSize(order);
+   qf1d.GaussLegendre(order, &open_ir);
+
+   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
+   o_dofs1D = maps_O_C->nqpt;
+   if (trial_el->GetBasisType() == BasisType::GaussLobatto)
+   {
+      B_id = true;
+      c_dofs1D = maps_O_C->ndof;
+   }
+   else
+   {
+      B_id = false;
+      maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
+      c_dofs1D = maps_C_C->nqpt;
+   }
+}
+
+void GradientInterpolator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+   {
+      if (B_id)
+      {
+         PAHcurlApplyGradient3DBId(c_dofs1D, o_dofs1D, ne,
+                                   maps_O_C->G, x, y);
+      }
+      else
+      {
+         PAHcurlApplyGradient3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                maps_O_C->G, x, y);
+      }
+   }
+   else if (dim == 2)
+   {
+      if (B_id)
+      {
+         PAHcurlApplyGradient2DBId(c_dofs1D, o_dofs1D, ne,
+                                   maps_O_C->G, x, y);
+      }
+      else
+      {
+         PAHcurlApplyGradient2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->G,
+                                x, y);
+      }
+   }
+   else
+   {
+      mfem_error("Bad dimension!");
+   }
+}
+
+void GradientInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+   {
+      if (B_id)
+      {
+         PAHcurlApplyGradientTranspose3DBId(c_dofs1D, o_dofs1D, ne,
+                                            maps_O_C->G, x, y);
+      }
+      else
+      {
+         PAHcurlApplyGradientTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                         maps_O_C->G, x, y);
+      }
+   }
+   else if (dim == 2)
+   {
+      if (B_id)
+      {
+         PAHcurlApplyGradientTranspose2DBId(c_dofs1D, o_dofs1D, ne,
+                                            maps_O_C->G, x, y);
+      }
+      else
+      {
+         PAHcurlApplyGradientTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                         maps_O_C->G, x, y);
+      }
+   }
+   else
+   {
+      mfem_error("Bad dimension!");
+   }
+}
+
+static void PAHcurlVecH1IdentityApply2D(const int c_dofs1D,
+                                        const int o_dofs1D,
+                                        const int NE,
+                                        const Array<double> &Bclosed,
+                                        const Array<double> &Bopen,
+                                        const Vector &pa_data,
+                                        const Vector &x_,
+                                        Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, 2, NE);
+   auto y = Reshape(y_.ReadWrite(), (2 * c_dofs1D * o_dofs1D), NE);
+
+   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[2][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y)
+
+      // contract in y
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               w[j][dx][ey] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w[j][dx][ey] += Bc(ey, dy) * x(dx, dy, j, e);
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += Bo(ex, dx) * w[j][dx][ey];
+               }
+               const int local_index = ey*o_dofs1D + ex;
+               y(local_index, e) += s * vk(j, local_index, e);
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x)
+
+      // contract in y
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               w[j][dx][ey] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w[j][dx][ey] += Bo(ey, dy) * x(dx, dy, j, e);
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += Bc(ex, dx) * w[j][dx][ey];
+               }
+               const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+               y(local_index, e) += s * vk(j, local_index, e);
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApplyTranspose2D(const int c_dofs1D,
+                                                 const int o_dofs1D,
+                                                 const int NE,
+                                                 const Array<double> &Bclosed,
+                                                 const Array<double> &Bopen,
+                                                 const Vector &pa_data,
+                                                 const Vector &x_,
+                                                 Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), (2 * c_dofs1D * o_dofs1D), NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, 2, NE);
+
+   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   //constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[2][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y)
+
+      // contract in x
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
+         }
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            const int local_index = ey*o_dofs1D + ex;
+            const double xd = x(local_index, e);
+
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<2; ++j)
+               {
+                  w[j][dx][ey] += Bo(ex, dx) * xd * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int ey = 0; ey < c_dofs1D; ++ey)
+               {
+                  s += w[j][dx][ey] * Bc(ey, dy);
+               }
+               y(dx, dy, j, e) += s;
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x)
+
+      // contract in x
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
+         }
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+            const double xd = x(local_index, e);
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<2; ++j)
+               {
+                  w[j][dx][ey] += Bc(ex, dx) * xd * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int ey = 0; ey < o_dofs1D; ++ey)
+               {
+                  s += w[j][dx][ey] * Bo(ey, dy);
+               }
+               y(dx, dy, j, e) += s;
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApply3D(const int c_dofs1D,
+                                        const int o_dofs1D,
+                                        const int NE,
+                                        const Array<double> &Bclosed,
+                                        const Array<double> &Bopen,
+                                        const Vector &pa_data,
+                                        const Vector &x_,
+                                        Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
+   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+
+   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
+                     NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bo(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bo(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+
+      // contract in z
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bo(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApplyTranspose3D(const int c_dofs1D,
+                                                 const int o_dofs1D,
+                                                 const int NE,
+                                                 const Array<double> &Bclosed,
+                                                 const Array<double> &Bopen,
+                                                 const Vector &pa_data,
+                                                 const Vector &x_,
+                                                 Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
+
+   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
+                     NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < o_dofs1D; ++ex)
+               {
+                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bo(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < c_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < c_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < c_dofs1D; ++ex)
+               {
+                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < o_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bo(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < c_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+
+      // contract in x
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < c_dofs1D; ++ex)
+               {
+                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < c_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < o_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bo(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+   });
+}
+
+void IdentityInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
+
+   ne = trial_fes.GetNE();
+
+   const int order = trial_el->GetOrder();
+   dofquad_fe = new H1_SegmentElement(order);
+   mfem::QuadratureFunctions1D qf1d;
+   mfem::IntegrationRule closed_ir;
+   closed_ir.SetSize(order + 1);
+   qf1d.GaussLobatto(order + 1, &closed_ir);
+   mfem::IntegrationRule open_ir;
+   open_ir.SetSize(order);
+   qf1d.GaussLegendre(order, &open_ir);
+
+   maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
+   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
+
+   o_dofs1D = maps_O_C->nqpt;
+   c_dofs1D = maps_C_C->nqpt;
+   MFEM_VERIFY(maps_O_C->ndof == c_dofs1D &&
+               maps_C_C->ndof == c_dofs1D, "Discrepancy in the number of DOFs");
+
+   const int ndof_test = (dim == 3) ? 3 * c_dofs1D * c_dofs1D * o_dofs1D
+                         : 2 * c_dofs1D * o_dofs1D;
+
+   const IntegrationRule & Nodes = test_el->GetNodes();
+
+   pa_data.SetSize(dim * ndof_test * ne, Device::GetMemoryType());
+   auto op = Reshape(pa_data.HostWrite(), dim, ndof_test, ne);
+
+   const Array<int> &dofmap = test_el->GetDofMap();
+
+   if (dim == 3)
+   {
+      // Note that ND_HexahedronElement uses 6 vectors in tk rather than 3, with
+      // the last 3 having negative signs. Here the signs are all positive, as
+      // signs are applied in ElementRestriction.
+
+      const double tk[9] = { 1.,0.,0.,  0.,1.,0.,  0.,0.,1. };
+
+      for (int c=0; c<3; ++c)
+      {
+         for (int i=0; i<ndof_test/3; ++i)
+         {
+            const int d = (c*ndof_test/3) + i;
+            // ND_HexahedronElement sets dof2tk = (dofmap < 0) ? 3+c : c, but here
+            // no signs should be applied due to ElementRestriction.
+            const int dof2tk = c;
+            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
+
+            for (int e=0; e<ne; ++e)
+            {
+               double v[3];
+               ElementTransformation *tr = mesh->GetElementTransformation(e);
+               tr->SetIntPoint(&Nodes.IntPoint(id));
+               tr->Jacobian().Mult(tk + dof2tk*dim, v);
+
+               for (int j=0; j<3; ++j)
+               {
+                  op(j,d,e) = v[j];
+               }
+            }
+         }
+      }
+   }
+   else // 2D case
+   {
+      const double tk[4] = { 1.,0.,  0.,1. };
+      for (int c=0; c<2; ++c)
+      {
+         for (int i=0; i<ndof_test/2; ++i)
+         {
+            const int d = (c*ndof_test/2) + i;
+            // ND_QuadrilateralElement sets dof2tk = (dofmap < 0) ? 2+c : c, but here
+            // no signs should be applied due to ElementRestriction.
+            const int dof2tk = c;
+            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
+
+            for (int e=0; e<ne; ++e)
+            {
+               double v[2];
+               ElementTransformation *tr = mesh->GetElementTransformation(e);
+               tr->SetIntPoint(&Nodes.IntPoint(id));
+               tr->Jacobian().Mult(tk + dof2tk*dim, v);
+
+               for (int j=0; j<2; ++j)
+               {
+                  op(j,d,e) = v[j];
+               }
+            }
+         }
+      }
+   }
+}
+
+void IdentityInterpolator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+   {
+      PAHcurlVecH1IdentityApply3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
+                                  pa_data, x, y);
+   }
+   else if (dim == 2)
+   {
+      PAHcurlVecH1IdentityApply2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
+                                  pa_data, x, y);
+   }
+   else
+   {
+      mfem_error("Bad dimension!");
+   }
+}
+
+void IdentityInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+   {
+      PAHcurlVecH1IdentityApplyTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                           maps_O_C->B, pa_data, x, y);
+   }
+   else if (dim == 2)
+   {
+      PAHcurlVecH1IdentityApplyTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                           maps_O_C->B, pa_data, x, y);
+   }
+   else
+   {
+      mfem_error("Bad dimension!");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/bilininteg_mass_ea.cpp b/fem/integ/bilininteg_mass_ea.cpp
similarity index 88%
rename from fem/bilininteg_mass_ea.cpp
rename to fem/integ/bilininteg_mass_ea.cpp
index cb1e7e064..315b9da8f 100644
--- a/fem/bilininteg_mass_ea.cpp
+++ b/fem/integ/bilininteg_mass_ea.cpp
@@ -9,9 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
 
 namespace mfem
 {
@@ -21,7 +21,6 @@ static void EAMassAssemble1D(const int NE,
                              const Array<double> &basis,
                              const Vector &padata,
                              Vector &eadata,
-                             const bool add,
                              const int d1d = 0,
                              const int q1d = 0)
 {
@@ -53,14 +52,7 @@ static void EAMassAssemble1D(const int NE,
             {
                val += r_Bi[k1] * r_Bj[k1] * D(k1, e);
             }
-            if (add)
-            {
-               M(i1, j1, e) += val;
-            }
-            else
-            {
-               M(i1, j1, e) = val;
-            }
+            M(i1, j1, e) += val;
          }
       }
    });
@@ -71,7 +63,6 @@ static void EAMassAssemble2D(const int NE,
                              const Array<double> &basis,
                              const Vector &padata,
                              Vector &eadata,
-                             const bool add,
                              const int d1d = 0,
                              const int q1d = 0)
 {
@@ -123,14 +114,7 @@ static void EAMassAssemble2D(const int NE,
                                * s_D[k1][k2];
                      }
                   }
-                  if (add)
-                  {
-                     M(i1, i2, j1, j2, e) += val;
-                  }
-                  else
-                  {
-                     M(i1, i2, j1, j2, e) = val;
-                  }
+                  M(i1, i2, j1, j2, e) += val;
                }
             }
          }
@@ -143,7 +127,6 @@ static void EAMassAssemble3D(const int NE,
                              const Array<double> &basis,
                              const Vector &padata,
                              Vector &eadata,
-                             const bool add,
                              const int d1d = 0,
                              const int q1d = 0)
 {
@@ -237,14 +220,7 @@ static void EAMassAssemble3D(const int NE,
                               }
                            }
                         }
-                        if (add)
-                        {
-                           M(i1, i2, i3, j1, j2, j3, e) += val;
-                        }
-                        else
-                        {
-                           M(i1, i2, i3, j1, j2, j3, e) = val;
-                        }
+                        M(i1, i2, i3, j1, j2, j3, e) += val;
                      }
                   }
                }
@@ -255,8 +231,7 @@ static void EAMassAssemble3D(const int NE,
 }
 
 void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                Vector &ea_data,
-                                const bool add)
+                                Vector &ea_data)
 {
    AssemblePA(fes);
    ne = fes.GetMesh()->GetNE();
@@ -265,15 +240,15 @@ void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAMassAssemble1D<2,2>(ne,B,pa_data,ea_data,add);
-         case 0x33: return EAMassAssemble1D<3,3>(ne,B,pa_data,ea_data,add);
-         case 0x44: return EAMassAssemble1D<4,4>(ne,B,pa_data,ea_data,add);
-         case 0x55: return EAMassAssemble1D<5,5>(ne,B,pa_data,ea_data,add);
-         case 0x66: return EAMassAssemble1D<6,6>(ne,B,pa_data,ea_data,add);
-         case 0x77: return EAMassAssemble1D<7,7>(ne,B,pa_data,ea_data,add);
-         case 0x88: return EAMassAssemble1D<8,8>(ne,B,pa_data,ea_data,add);
-         case 0x99: return EAMassAssemble1D<9,9>(ne,B,pa_data,ea_data,add);
-         default:   return EAMassAssemble1D(ne,B,pa_data,ea_data,add,
+         case 0x22: return EAMassAssemble1D<2,2>(ne,B,pa_data,ea_data);
+         case 0x33: return EAMassAssemble1D<3,3>(ne,B,pa_data,ea_data);
+         case 0x44: return EAMassAssemble1D<4,4>(ne,B,pa_data,ea_data);
+         case 0x55: return EAMassAssemble1D<5,5>(ne,B,pa_data,ea_data);
+         case 0x66: return EAMassAssemble1D<6,6>(ne,B,pa_data,ea_data);
+         case 0x77: return EAMassAssemble1D<7,7>(ne,B,pa_data,ea_data);
+         case 0x88: return EAMassAssemble1D<8,8>(ne,B,pa_data,ea_data);
+         case 0x99: return EAMassAssemble1D<9,9>(ne,B,pa_data,ea_data);
+         default:   return EAMassAssemble1D(ne,B,pa_data,ea_data,
                                                dofs1D,quad1D);
       }
    }
@@ -281,15 +256,15 @@ void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAMassAssemble2D<2,2>(ne,B,pa_data,ea_data,add);
-         case 0x33: return EAMassAssemble2D<3,3>(ne,B,pa_data,ea_data,add);
-         case 0x44: return EAMassAssemble2D<4,4>(ne,B,pa_data,ea_data,add);
-         case 0x55: return EAMassAssemble2D<5,5>(ne,B,pa_data,ea_data,add);
-         case 0x66: return EAMassAssemble2D<6,6>(ne,B,pa_data,ea_data,add);
-         case 0x77: return EAMassAssemble2D<7,7>(ne,B,pa_data,ea_data,add);
-         case 0x88: return EAMassAssemble2D<8,8>(ne,B,pa_data,ea_data,add);
-         case 0x99: return EAMassAssemble2D<9,9>(ne,B,pa_data,ea_data,add);
-         default:   return EAMassAssemble2D(ne,B,pa_data,ea_data,add,
+         case 0x22: return EAMassAssemble2D<2,2>(ne,B,pa_data,ea_data);
+         case 0x33: return EAMassAssemble2D<3,3>(ne,B,pa_data,ea_data);
+         case 0x44: return EAMassAssemble2D<4,4>(ne,B,pa_data,ea_data);
+         case 0x55: return EAMassAssemble2D<5,5>(ne,B,pa_data,ea_data);
+         case 0x66: return EAMassAssemble2D<6,6>(ne,B,pa_data,ea_data);
+         case 0x77: return EAMassAssemble2D<7,7>(ne,B,pa_data,ea_data);
+         case 0x88: return EAMassAssemble2D<8,8>(ne,B,pa_data,ea_data);
+         case 0x99: return EAMassAssemble2D<9,9>(ne,B,pa_data,ea_data);
+         default:   return EAMassAssemble2D(ne,B,pa_data,ea_data,
                                                dofs1D,quad1D);
       }
    }
@@ -297,14 +272,14 @@ void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EAMassAssemble3D<2,3>(ne,B,pa_data,ea_data,add);
-         case 0x34: return EAMassAssemble3D<3,4>(ne,B,pa_data,ea_data,add);
-         case 0x45: return EAMassAssemble3D<4,5>(ne,B,pa_data,ea_data,add);
-         case 0x56: return EAMassAssemble3D<5,6>(ne,B,pa_data,ea_data,add);
-         case 0x67: return EAMassAssemble3D<6,7>(ne,B,pa_data,ea_data,add);
-         case 0x78: return EAMassAssemble3D<7,8>(ne,B,pa_data,ea_data,add);
-         case 0x89: return EAMassAssemble3D<8,9>(ne,B,pa_data,ea_data,add);
-         default:   return EAMassAssemble3D(ne,B,pa_data,ea_data,add,
+         case 0x23: return EAMassAssemble3D<2,3>(ne,B,pa_data,ea_data);
+         case 0x34: return EAMassAssemble3D<3,4>(ne,B,pa_data,ea_data);
+         case 0x45: return EAMassAssemble3D<4,5>(ne,B,pa_data,ea_data);
+         case 0x56: return EAMassAssemble3D<5,6>(ne,B,pa_data,ea_data);
+         case 0x67: return EAMassAssemble3D<6,7>(ne,B,pa_data,ea_data);
+         case 0x78: return EAMassAssemble3D<7,8>(ne,B,pa_data,ea_data);
+         case 0x89: return EAMassAssemble3D<8,9>(ne,B,pa_data,ea_data);
+         default:   return EAMassAssemble3D(ne,B,pa_data,ea_data,
                                                dofs1D,quad1D);
       }
    }
diff --git a/fem/integ/bilininteg_mass_kernels.hpp b/fem/integ/bilininteg_mass_kernels.hpp
new file mode 100644
index 000000000..c26f242ef
--- /dev/null
+++ b/fem/integ/bilininteg_mass_kernels.hpp
@@ -0,0 +1,1329 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_BILININTEG_MASS_KERNELS_HPP
+#define MFEM_BILININTEG_MASS_KERNELS_HPP
+
+#include "../../config/config.hpp"
+#include "../../general/forall.hpp"
+#include "../../linalg/dtensor.hpp"
+
+namespace mfem
+{
+
+namespace internal
+{
+
+MFEM_HOST_DEVICE inline
+void PAMassAssembleDiagonal1D(const int NE,
+                              const Array<double> &b,
+                              const Vector &d,
+                              Vector &y,
+                              const int D1D,
+                              const int Q1D)
+{
+   MFEM_VERIFY(D1D <= MAX_D1D, "");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
+   auto B = Reshape(b.Read(), Q1D, D1D);
+   auto D = Reshape(d.Read(), Q1D, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      for (int dx = 0; dx < D1D; ++dx)
+      {
+         Y(dx, e) = 0.0;
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            Y(dx, e) += B(qx, dx) * B(qx, dx) * D(qx, e);
+         }
+      }
+   });
+}
+
+template<int T_D1D = 0, int T_Q1D = 0>
+MFEM_HOST_DEVICE inline
+void PAMassAssembleDiagonal2D(const int NE,
+                              const Array<double> &b,
+                              const Vector &d,
+                              Vector &y,
+                              const int d1d = 0,
+                              const int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   MFEM_VERIFY(D1D <= MAX_D1D, "");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
+   auto B = Reshape(b.Read(), Q1D, D1D);
+   auto D = Reshape(d.Read(), Q1D, Q1D, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, D1D, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+      double QD[MQ1][MD1];
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            QD[qx][dy] = 0.0;
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               QD[qx][dy] += B(qy, dy) * B(qy, dy) * D(qx, qy, e);
+            }
+         }
+      }
+      for (int dy = 0; dy < D1D; ++dy)
+      {
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               Y(dx,dy,e) += B(qx, dx) * B(qx, dx) * QD[qx][dy];
+            }
+         }
+      }
+   });
+}
+
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+MFEM_HOST_DEVICE inline
+void SmemPAMassAssembleDiagonal2D(const int NE,
+                                  const Array<double> &b_,
+                                  const Vector &d_,
+                                  Vector &y_,
+                                  const int d1d = 0,
+                                  const int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int NBZ = T_NBZ ? T_NBZ : 1;
+   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+   MFEM_VERIFY(D1D <= MD1, "");
+   MFEM_VERIFY(Q1D <= MQ1, "");
+   auto b = Reshape(b_.Read(), Q1D, D1D);
+   auto D = Reshape(d_.Read(), Q1D, Q1D, NE);
+   auto Y = Reshape(y_.ReadWrite(), D1D, D1D, NE);
+   mfem::forall_2D_batch(NE, Q1D, Q1D, NBZ, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int tidz = MFEM_THREAD_ID(z);
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      constexpr int NBZ = T_NBZ ? T_NBZ : 1;
+      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+      MFEM_SHARED double B[MQ1][MD1];
+      MFEM_SHARED double QDZ[NBZ][MQ1][MD1];
+      double (*QD)[MD1] = (double (*)[MD1])(QDZ + tidz);
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               B[q][d] = b(q,d);
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(dy,y,D1D)
+         {
+            QD[qx][dy] = 0.0;
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               QD[qx][dy] += B[qy][dy] * B[qy][dy] * D(qx, qy, e);
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(dy,y,D1D)
+      {
+         MFEM_FOREACH_THREAD(dx,x,D1D)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               // might need absolute values on next line
+               Y(dx,dy,e) += B[qx][dx] * B[qx][dx] * QD[qx][dy];
+            }
+         }
+      }
+   });
+}
+
+template<int T_D1D = 0, int T_Q1D = 0>
+MFEM_HOST_DEVICE inline
+void PAMassAssembleDiagonal3D(const int NE,
+                              const Array<double> &b,
+                              const Vector &d,
+                              Vector &y,
+                              const int d1d = 0,
+                              const int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   MFEM_VERIFY(D1D <= MAX_D1D, "");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
+   auto B = Reshape(b.Read(), Q1D, D1D);
+   auto D = Reshape(d.Read(), Q1D, Q1D, Q1D, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, D1D, D1D, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+      double QQD[MQ1][MQ1][MD1];
+      double QDD[MQ1][MD1][MD1];
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int dz = 0; dz < D1D; ++dz)
+            {
+               QQD[qx][qy][dz] = 0.0;
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  QQD[qx][qy][dz] += B(qz, dz) * B(qz, dz) * D(qx, qy, qz, e);
+               }
+            }
+         }
+      }
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         for (int dz = 0; dz < D1D; ++dz)
+         {
+            for (int dy = 0; dy < D1D; ++dy)
+            {
+               QDD[qx][dy][dz] = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  QDD[qx][dy][dz] += B(qy, dy) * B(qy, dy) * QQD[qx][qy][dz];
+               }
+            }
+         }
+      }
+      for (int dz = 0; dz < D1D; ++dz)
+      {
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               double t = 0.0;
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  t += B(qx, dx) * B(qx, dx) * QDD[qx][dy][dz];
+               }
+               Y(dx, dy, dz, e) += t;
+            }
+         }
+      }
+   });
+}
+
+template<int T_D1D = 0, int T_Q1D = 0>
+MFEM_HOST_DEVICE inline
+void SmemPAMassAssembleDiagonal3D(const int NE,
+                                  const Array<double> &b_,
+                                  const Vector &d_,
+                                  Vector &y_,
+                                  const int d1d = 0,
+                                  const int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+   MFEM_VERIFY(D1D <= MD1, "");
+   MFEM_VERIFY(Q1D <= MQ1, "");
+   auto b = Reshape(b_.Read(), Q1D, D1D);
+   auto D = Reshape(d_.Read(), Q1D, Q1D, Q1D, NE);
+   auto Y = Reshape(y_.ReadWrite(), D1D, D1D, D1D, NE);
+   mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int tidz = MFEM_THREAD_ID(z);
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+      MFEM_SHARED double B[MQ1][MD1];
+      MFEM_SHARED double QQD[MQ1][MQ1][MD1];
+      MFEM_SHARED double QDD[MQ1][MD1][MD1];
+      if (tidz == 0)
+      {
+         MFEM_FOREACH_THREAD(d,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(q,x,Q1D)
+            {
+               B[q][d] = b(q,d);
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(qy,y,Q1D)
+         {
+            MFEM_FOREACH_THREAD(dz,z,D1D)
+            {
+               QQD[qx][qy][dz] = 0.0;
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  QQD[qx][qy][dz] += B[qz][dz] * B[qz][dz] * D(qx, qy, qz, e);
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         MFEM_FOREACH_THREAD(dz,z,D1D)
+         {
+            MFEM_FOREACH_THREAD(dy,y,D1D)
+            {
+               QDD[qx][dy][dz] = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  QDD[qx][dy][dz] += B[qy][dy] * B[qy][dy] * QQD[qx][qy][dz];
+               }
+            }
+         }
+      }
+      MFEM_SYNC_THREAD;
+      MFEM_FOREACH_THREAD(dz,z,D1D)
+      {
+         MFEM_FOREACH_THREAD(dy,y,D1D)
+         {
+            MFEM_FOREACH_THREAD(dx,x,D1D)
+            {
+               double t = 0.0;
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  t += B[qx][dx] * B[qx][dx] * QDD[qx][dy][dz];
+               }
+               Y(dx, dy, dz, e) += t;
+            }
+         }
+      }
+   });
+}
+
+MFEM_HOST_DEVICE inline
+void PAMassAssembleDiagonal(const int dim, const int D1D,
+                            const int Q1D, const int NE,
+                            const Array<double> &B,
+                            const Vector &D,
+                            Vector &Y)
+{
+   if (dim == 1)
+   {
+      return PAMassAssembleDiagonal1D(NE,B,D,Y,D1D,Q1D);
+   }
+   else if (dim == 2)
+   {
+      switch ((D1D << 4 ) | Q1D)
+      {
+         case 0x22: return SmemPAMassAssembleDiagonal2D<2,2,16>(NE,B,D,Y);
+         case 0x33: return SmemPAMassAssembleDiagonal2D<3,3,16>(NE,B,D,Y);
+         case 0x44: return SmemPAMassAssembleDiagonal2D<4,4,8>(NE,B,D,Y);
+         case 0x55: return SmemPAMassAssembleDiagonal2D<5,5,8>(NE,B,D,Y);
+         case 0x66: return SmemPAMassAssembleDiagonal2D<6,6,4>(NE,B,D,Y);
+         case 0x77: return SmemPAMassAssembleDiagonal2D<7,7,4>(NE,B,D,Y);
+         case 0x88: return SmemPAMassAssembleDiagonal2D<8,8,2>(NE,B,D,Y);
+         case 0x99: return SmemPAMassAssembleDiagonal2D<9,9,2>(NE,B,D,Y);
+         default:   return PAMassAssembleDiagonal2D(NE,B,D,Y,D1D,Q1D);
+      }
+   }
+   else if (dim == 3)
+   {
+      switch ((D1D << 4 ) | Q1D)
+      {
+         case 0x23: return SmemPAMassAssembleDiagonal3D<2,3>(NE,B,D,Y);
+         case 0x24: return SmemPAMassAssembleDiagonal3D<2,4>(NE,B,D,Y);
+         case 0x26: return SmemPAMassAssembleDiagonal3D<2,6>(NE,B,D,Y);
+         case 0x34: return SmemPAMassAssembleDiagonal3D<3,4>(NE,B,D,Y);
+         case 0x35: return SmemPAMassAssembleDiagonal3D<3,5>(NE,B,D,Y);
+         case 0x45: return SmemPAMassAssembleDiagonal3D<4,5>(NE,B,D,Y);
+         case 0x48: return SmemPAMassAssembleDiagonal3D<4,8>(NE,B,D,Y);
+         case 0x56: return SmemPAMassAssembleDiagonal3D<5,6>(NE,B,D,Y);
+         case 0x67: return SmemPAMassAssembleDiagonal3D<6,7>(NE,B,D,Y);
+         case 0x78: return SmemPAMassAssembleDiagonal3D<7,8>(NE,B,D,Y);
+         case 0x89: return SmemPAMassAssembleDiagonal3D<8,9>(NE,B,D,Y);
+         default:   return PAMassAssembleDiagonal3D(NE,B,D,Y,D1D,Q1D);
+      }
+   }
+   MFEM_ABORT("Unknown kernel.");
+}
+
+#ifdef MFEM_USE_OCCA
+// OCCA PA Mass Apply 2D kernel
+MFEM_HOST_DEVICE inline
+void OccaPAMassApply2D(const int D1D,
+                       const int Q1D,
+                       const int NE,
+                       const Array<double> &B,
+                       const Array<double> &Bt,
+                       const Vector &D,
+                       const Vector &X,
+                       Vector &Y)
+{
+   occa::properties props;
+   props["defines/D1D"] = D1D;
+   props["defines/Q1D"] = Q1D;
+   const occa::memory o_B = OccaMemoryRead(B.GetMemory(), B.Size());
+   const occa::memory o_Bt = OccaMemoryRead(Bt.GetMemory(), Bt.Size());
+   const occa::memory o_D = OccaMemoryRead(D.GetMemory(), D.Size());
+   const occa::memory o_X = OccaMemoryRead(X.GetMemory(), X.Size());
+   occa::memory o_Y = OccaMemoryReadWrite(Y.GetMemory(), Y.Size());
+   const occa_id_t id = std::make_pair(D1D,Q1D);
+   if (!Device::Allows(Backend::OCCA_CUDA))
+   {
+      static occa_kernel_t OccaMassApply2D_cpu;
+      if (OccaMassApply2D_cpu.find(id) == OccaMassApply2D_cpu.end())
+      {
+         const occa::kernel MassApply2D_CPU =
+            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
+                                        "MassApply2D_CPU", props);
+         OccaMassApply2D_cpu.emplace(id, MassApply2D_CPU);
+      }
+      OccaMassApply2D_cpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
+   }
+   else
+   {
+      static occa_kernel_t OccaMassApply2D_gpu;
+      if (OccaMassApply2D_gpu.find(id) == OccaMassApply2D_gpu.end())
+      {
+         const occa::kernel MassApply2D_GPU =
+            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
+                                        "MassApply2D_GPU", props);
+         OccaMassApply2D_gpu.emplace(id, MassApply2D_GPU);
+      }
+      OccaMassApply2D_gpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
+   }
+}
+
+// OCCA PA Mass Apply 3D kernel
+MFEM_HOST_DEVICE inline
+void OccaPAMassApply3D(const int D1D,
+                       const int Q1D,
+                       const int NE,
+                       const Array<double> &B,
+                       const Array<double> &Bt,
+                       const Vector &D,
+                       const Vector &X,
+                       Vector &Y)
+{
+   occa::properties props;
+   props["defines/D1D"] = D1D;
+   props["defines/Q1D"] = Q1D;
+   const occa::memory o_B = OccaMemoryRead(B.GetMemory(), B.Size());
+   const occa::memory o_Bt = OccaMemoryRead(Bt.GetMemory(), Bt.Size());
+   const occa::memory o_D = OccaMemoryRead(D.GetMemory(), D.Size());
+   const occa::memory o_X = OccaMemoryRead(X.GetMemory(), X.Size());
+   occa::memory o_Y = OccaMemoryReadWrite(Y.GetMemory(), Y.Size());
+   const occa_id_t id = std::make_pair(D1D,Q1D);
+   if (!Device::Allows(Backend::OCCA_CUDA))
+   {
+      static occa_kernel_t OccaMassApply3D_cpu;
+      if (OccaMassApply3D_cpu.find(id) == OccaMassApply3D_cpu.end())
+      {
+         const occa::kernel MassApply3D_CPU =
+            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
+                                        "MassApply3D_CPU", props);
+         OccaMassApply3D_cpu.emplace(id, MassApply3D_CPU);
+      }
+      OccaMassApply3D_cpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
+   }
+   else
+   {
+      static occa_kernel_t OccaMassApply3D_gpu;
+      if (OccaMassApply3D_gpu.find(id) == OccaMassApply3D_gpu.end())
+      {
+         const occa::kernel MassApply3D_GPU =
+            mfem::OccaDev().buildKernel("occa://mfem/fem/occa.okl",
+                                        "MassApply3D_GPU", props);
+         OccaMassApply3D_gpu.emplace(id, MassApply3D_GPU);
+      }
+      OccaMassApply3D_gpu.at(id)(NE, o_B, o_Bt, o_D, o_X, o_Y);
+   }
+}
+#endif // MFEM_USE_OCCA
+
+MFEM_HOST_DEVICE inline
+void PAMassApply1D_Element(const int e,
+                           const int NE,
+                           const double *b_,
+                           const double *bt_,
+                           const double *d_,
+                           const double *x_,
+                           double *y_,
+                           const int d1d = 0,
+                           const int q1d = 0)
+{
+   const int D1D = d1d;
+   const int Q1D = q1d;
+   auto B = ConstDeviceMatrix(b_, Q1D, D1D);
+   auto Bt = ConstDeviceMatrix(bt_, D1D, Q1D);
+   auto D = ConstDeviceMatrix(d_, Q1D, NE);
+   auto X = ConstDeviceMatrix(x_, D1D, NE);
+   auto Y = DeviceMatrix(y_, D1D, NE);
+
+   constexpr int max_Q1D = MAX_Q1D;
+   double XQ[max_Q1D];
+   for (int qx = 0; qx < Q1D; ++qx)
+   {
+      XQ[qx] = 0.0;
+   }
+   for (int dx = 0; dx < D1D; ++dx)
+   {
+      const double s = X(dx,e);
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         XQ[qx] += B(qx,dx)*s;
+      }
+   }
+   for (int qx = 0; qx < Q1D; ++qx)
+   {
+      const double q = XQ[qx]*D(qx,e);
+      for (int dx = 0; dx < D1D; ++dx)
+      {
+         Y(dx,e) += Bt(dx,qx) * q;
+      }
+   }
+}
+
+template <bool ACCUMULATE = true>
+MFEM_HOST_DEVICE inline
+void PAMassApply2D_Element(const int e,
+                           const int NE,
+                           const double *b_,
+                           const double *bt_,
+                           const double *d_,
+                           const double *x_,
+                           double *y_,
+                           const int d1d = 0,
+                           const int q1d = 0)
+{
+   const int D1D = d1d;
+   const int Q1D = q1d;
+   auto B = ConstDeviceMatrix(b_, Q1D, D1D);
+   auto Bt = ConstDeviceMatrix(bt_, D1D, Q1D);
+   auto D = ConstDeviceCube(d_, Q1D, Q1D, NE);
+   auto X = ConstDeviceCube(x_, D1D, D1D, NE);
+   auto Y = DeviceCube(y_, D1D, D1D, NE);
+
+   if (!ACCUMULATE)
+   {
+      for (int dy = 0; dy < D1D; ++dy)
+      {
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            Y(dx, dy, e) = 0.0;
+         }
+      }
+   }
+
+   constexpr int max_D1D = MAX_D1D;
+   constexpr int max_Q1D = MAX_Q1D;
+   double sol_xy[max_Q1D][max_Q1D];
+   for (int qy = 0; qy < Q1D; ++qy)
+   {
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         sol_xy[qy][qx] = 0.0;
+      }
+   }
+   for (int dy = 0; dy < D1D; ++dy)
+   {
+      double sol_x[max_Q1D];
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         sol_x[qy] = 0.0;
+      }
+      for (int dx = 0; dx < D1D; ++dx)
+      {
+         const double s = X(dx,dy,e);
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            sol_x[qx] += B(qx,dx)* s;
+         }
+      }
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         const double d2q = B(qy,dy);
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            sol_xy[qy][qx] += d2q * sol_x[qx];
+         }
+      }
+   }
+   for (int qy = 0; qy < Q1D; ++qy)
+   {
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         sol_xy[qy][qx] *= D(qx,qy,e);
+      }
+   }
+   for (int qy = 0; qy < Q1D; ++qy)
+   {
+      double sol_x[max_D1D];
+      for (int dx = 0; dx < D1D; ++dx)
+      {
+         sol_x[dx] = 0.0;
+      }
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         const double s = sol_xy[qy][qx];
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            sol_x[dx] += Bt(dx,qx) * s;
+         }
+      }
+      for (int dy = 0; dy < D1D; ++dy)
+      {
+         const double q2d = Bt(dy,qy);
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            Y(dx,dy,e) += q2d * sol_x[dx];
+         }
+      }
+   }
+}
+
+template<int T_D1D, int T_Q1D, int T_NBZ, bool ACCUMULATE = true>
+MFEM_HOST_DEVICE inline
+void SmemPAMassApply2D_Element(const int e,
+                               const int NE,
+                               const double *b_,
+                               const double *d_,
+                               const double *x_,
+                               double *y_,
+                               int d1d = 0,
+                               int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int NBZ = T_NBZ ? T_NBZ : 1;
+
+   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+   constexpr int MDQ = (MQ1 > MD1) ? MQ1 : MD1;
+
+   auto b = ConstDeviceMatrix(b_, Q1D, D1D);
+   auto D = ConstDeviceCube(d_, Q1D, Q1D, NE);
+   auto x = ConstDeviceCube(x_, D1D, D1D, NE);
+   auto Y = DeviceCube(y_, D1D, D1D, NE);
+
+   const int tidz = MFEM_THREAD_ID(z);
+
+   MFEM_SHARED double BBt[MQ1*MD1];
+   double (*B)[MD1] = (double (*)[MD1]) BBt;
+   double (*Bt)[MQ1] = (double (*)[MQ1]) BBt;
+   MFEM_SHARED double sm0[NBZ][MDQ*MDQ];
+   MFEM_SHARED double sm1[NBZ][MDQ*MDQ];
+   double (*X)[MD1] = (double (*)[MD1]) (sm0 + tidz);
+   double (*DQ)[MQ1] = (double (*)[MQ1]) (sm1 + tidz);
+   double (*QQ)[MQ1] = (double (*)[MQ1]) (sm0 + tidz);
+   double (*QD)[MD1] = (double (*)[MD1]) (sm1 + tidz);
+
+   MFEM_FOREACH_THREAD(dy,y,D1D)
+   {
+      MFEM_FOREACH_THREAD(dx,x,D1D)
+      {
+         X[dy][dx] = x(dx,dy,e);
+      }
+   }
+   if (tidz == 0)
+   {
+      MFEM_FOREACH_THREAD(dy,y,D1D)
+      {
+         MFEM_FOREACH_THREAD(q,x,Q1D)
+         {
+            B[q][dy] = b(q,dy);
+         }
+      }
+   }
+   MFEM_SYNC_THREAD;
+   MFEM_FOREACH_THREAD(dy,y,D1D)
+   {
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         double dq = 0.0;
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            dq += X[dy][dx] * B[qx][dx];
+         }
+         DQ[dy][qx] = dq;
+      }
+   }
+   MFEM_SYNC_THREAD;
+   MFEM_FOREACH_THREAD(qy,y,Q1D)
+   {
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         double qq = 0.0;
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            qq += DQ[dy][qx] * B[qy][dy];
+         }
+         QQ[qy][qx] = qq * D(qx, qy, e);
+      }
+   }
+   MFEM_SYNC_THREAD;
+   if (tidz == 0)
+   {
+      MFEM_FOREACH_THREAD(dy,y,D1D)
+      {
+         MFEM_FOREACH_THREAD(q,x,Q1D)
+         {
+            Bt[dy][q] = b(q,dy);
+         }
+      }
+   }
+   MFEM_SYNC_THREAD;
+   MFEM_FOREACH_THREAD(qy,y,Q1D)
+   {
+      MFEM_FOREACH_THREAD(dx,x,D1D)
+      {
+         double dq = 0.0;
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            dq += QQ[qy][qx] * Bt[dx][qx];
+         }
+         QD[qy][dx] = dq;
+      }
+   }
+   MFEM_SYNC_THREAD;
+   MFEM_FOREACH_THREAD(dy,y,D1D)
+   {
+      MFEM_FOREACH_THREAD(dx,x,D1D)
+      {
+         double dd = 0.0;
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            dd += (QD[qy][dx] * Bt[dy][qy]);
+         }
+         if (ACCUMULATE)
+         {
+            Y(dx, dy, e) += dd;
+         }
+         else
+         {
+            Y(dx, dy, e) = dd;
+         }
+      }
+   }
+}
+
+template <bool ACCUMULATE = true>
+MFEM_HOST_DEVICE inline
+void PAMassApply3D_Element(const int e,
+                           const int NE,
+                           const double *b_,
+                           const double *bt_,
+                           const double *d_,
+                           const double *x_,
+                           double *y_,
+                           const int d1d,
+                           const int q1d)
+{
+   const int D1D = d1d;
+   const int Q1D = q1d;
+   auto B = ConstDeviceMatrix(b_, Q1D, D1D);
+   auto Bt = ConstDeviceMatrix(bt_, D1D, Q1D);
+   auto D = DeviceTensor<4,const double>(d_, Q1D, Q1D, Q1D, NE);
+   auto X = DeviceTensor<4,const double>(x_, D1D, D1D, D1D, NE);
+   auto Y = DeviceTensor<4,double>(y_, D1D, D1D, D1D, NE);
+
+   if (!ACCUMULATE)
+   {
+      for (int dz = 0; dz < D1D; ++dz)
+      {
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               Y(dx, dy, dz, e) = 0.0;
+            }
+         }
+      }
+   }
+
+   constexpr int max_D1D = MAX_D1D;
+   constexpr int max_Q1D = MAX_Q1D;
+   double sol_xyz[max_Q1D][max_Q1D][max_Q1D];
+   for (int qz = 0; qz < Q1D; ++qz)
+   {
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            sol_xyz[qz][qy][qx] = 0.0;
+         }
+      }
+   }
+   for (int dz = 0; dz < D1D; ++dz)
+   {
+      double sol_xy[max_Q1D][max_Q1D];
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            sol_xy[qy][qx] = 0.0;
+         }
+      }
+      for (int dy = 0; dy < D1D; ++dy)
+      {
+         double sol_x[max_Q1D];
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            sol_x[qx] = 0;
+         }
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            const double s = X(dx,dy,dz,e);
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               sol_x[qx] += B(qx,dx) * s;
+            }
+         }
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            const double wy = B(qy,dy);
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               sol_xy[qy][qx] += wy * sol_x[qx];
+            }
+         }
+      }
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         const double wz = B(qz,dz);
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               sol_xyz[qz][qy][qx] += wz * sol_xy[qy][qx];
+            }
+         }
+      }
+   }
+   for (int qz = 0; qz < Q1D; ++qz)
+   {
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            sol_xyz[qz][qy][qx] *= D(qx,qy,qz,e);
+         }
+      }
+   }
+   for (int qz = 0; qz < Q1D; ++qz)
+   {
+      double sol_xy[max_D1D][max_D1D];
+      for (int dy = 0; dy < D1D; ++dy)
+      {
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            sol_xy[dy][dx] = 0;
+         }
+      }
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         double sol_x[max_D1D];
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            sol_x[dx] = 0;
+         }
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            const double s = sol_xyz[qz][qy][qx];
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               sol_x[dx] += Bt(dx,qx) * s;
+            }
+         }
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            const double wy = Bt(dy,qy);
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               sol_xy[dy][dx] += wy * sol_x[dx];
+            }
+         }
+      }
+      for (int dz = 0; dz < D1D; ++dz)
+      {
+         const double wz = Bt(dz,qz);
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               Y(dx,dy,dz,e) += wz * sol_xy[dy][dx];
+            }
+         }
+      }
+   }
+}
+
+template<int T_D1D, int T_Q1D, bool ACCUMULATE = true>
+MFEM_HOST_DEVICE inline
+void SmemPAMassApply3D_Element(const int e,
+                               const int NE,
+                               const double *b_,
+                               const double *d_,
+                               const double *x_,
+                               double *y_,
+                               const int d1d = 0,
+                               const int q1d = 0)
+{
+   constexpr int D1D = T_D1D ? T_D1D : d1d;
+   constexpr int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+   constexpr int MDQ = (MQ1 > MD1) ? MQ1 : MD1;
+
+   auto b = ConstDeviceMatrix(b_, Q1D, D1D);
+   auto d = DeviceTensor<4,const double>(d_, Q1D, Q1D, Q1D, NE);
+   auto x = DeviceTensor<4,const double>(x_, D1D, D1D, D1D, NE);
+   auto y = DeviceTensor<4,double>(y_, D1D, D1D, D1D, NE);
+
+   MFEM_SHARED double sDQ[MQ1*MD1];
+   double (*B)[MD1] = (double (*)[MD1]) sDQ;
+   double (*Bt)[MQ1] = (double (*)[MQ1]) sDQ;
+   MFEM_SHARED double sm0[MDQ*MDQ*MDQ];
+   MFEM_SHARED double sm1[MDQ*MDQ*MDQ];
+   double (*X)[MD1][MD1]   = (double (*)[MD1][MD1]) sm0;
+   double (*DDQ)[MD1][MQ1] = (double (*)[MD1][MQ1]) sm1;
+   double (*DQQ)[MQ1][MQ1] = (double (*)[MQ1][MQ1]) sm0;
+   double (*QQQ)[MQ1][MQ1] = (double (*)[MQ1][MQ1]) sm1;
+   double (*QQD)[MQ1][MD1] = (double (*)[MQ1][MD1]) sm0;
+   double (*QDD)[MD1][MD1] = (double (*)[MD1][MD1]) sm1;
+   MFEM_FOREACH_THREAD(dy,y,D1D)
+   {
+      MFEM_FOREACH_THREAD(dx,x,D1D)
+      {
+         MFEM_UNROLL(MD1)
+         for (int dz = 0; dz < D1D; ++dz)
+         {
+            X[dz][dy][dx] = x(dx,dy,dz,e);
+         }
+      }
+      MFEM_FOREACH_THREAD(dx,x,Q1D)
+      {
+         B[dx][dy] = b(dx,dy);
+      }
+   }
+   MFEM_SYNC_THREAD;
+   MFEM_FOREACH_THREAD(dy,y,D1D)
+   {
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         double u[D1D];
+         MFEM_UNROLL(MD1)
+         for (int dz = 0; dz < D1D; dz++)
+         {
+            u[dz] = 0;
+         }
+         MFEM_UNROLL(MD1)
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            MFEM_UNROLL(MD1)
+            for (int dz = 0; dz < D1D; ++dz)
+            {
+               u[dz] += X[dz][dy][dx] * B[qx][dx];
+            }
+         }
+         MFEM_UNROLL(MD1)
+         for (int dz = 0; dz < D1D; ++dz)
+         {
+            DDQ[dz][dy][qx] = u[dz];
+         }
+      }
+   }
+   MFEM_SYNC_THREAD;
+   MFEM_FOREACH_THREAD(qy,y,Q1D)
+   {
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         double u[D1D];
+         MFEM_UNROLL(MD1)
+         for (int dz = 0; dz < D1D; dz++)
+         {
+            u[dz] = 0;
+         }
+         MFEM_UNROLL(MD1)
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            MFEM_UNROLL(MD1)
+            for (int dz = 0; dz < D1D; dz++)
+            {
+               u[dz] += DDQ[dz][dy][qx] * B[qy][dy];
+            }
+         }
+         MFEM_UNROLL(MD1)
+         for (int dz = 0; dz < D1D; dz++)
+         {
+            DQQ[dz][qy][qx] = u[dz];
+         }
+      }
+   }
+   MFEM_SYNC_THREAD;
+   MFEM_FOREACH_THREAD(qy,y,Q1D)
+   {
+      MFEM_FOREACH_THREAD(qx,x,Q1D)
+      {
+         double u[Q1D];
+         MFEM_UNROLL(MQ1)
+         for (int qz = 0; qz < Q1D; qz++)
+         {
+            u[qz] = 0;
+         }
+         MFEM_UNROLL(MD1)
+         for (int dz = 0; dz < D1D; ++dz)
+         {
+            MFEM_UNROLL(MQ1)
+            for (int qz = 0; qz < Q1D; qz++)
+            {
+               u[qz] += DQQ[dz][qy][qx] * B[qz][dz];
+            }
+         }
+         MFEM_UNROLL(MQ1)
+         for (int qz = 0; qz < Q1D; qz++)
+         {
+            QQQ[qz][qy][qx] = u[qz] * d(qx,qy,qz,e);
+         }
+      }
+   }
+   MFEM_SYNC_THREAD;
+   MFEM_FOREACH_THREAD(di,y,D1D)
+   {
+      MFEM_FOREACH_THREAD(q,x,Q1D)
+      {
+         Bt[di][q] = b(q,di);
+      }
+   }
+   MFEM_SYNC_THREAD;
+   MFEM_FOREACH_THREAD(qy,y,Q1D)
+   {
+      MFEM_FOREACH_THREAD(dx,x,D1D)
+      {
+         double u[Q1D];
+         MFEM_UNROLL(MQ1)
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            u[qz] = 0;
+         }
+         MFEM_UNROLL(MQ1)
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            MFEM_UNROLL(MQ1)
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               u[qz] += QQQ[qz][qy][qx] * Bt[dx][qx];
+            }
+         }
+         MFEM_UNROLL(MQ1)
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            QQD[qz][qy][dx] = u[qz];
+         }
+      }
+   }
+   MFEM_SYNC_THREAD;
+   MFEM_FOREACH_THREAD(dy,y,D1D)
+   {
+      MFEM_FOREACH_THREAD(dx,x,D1D)
+      {
+         double u[Q1D];
+         MFEM_UNROLL(MQ1)
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            u[qz] = 0;
+         }
+         MFEM_UNROLL(MQ1)
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            MFEM_UNROLL(MQ1)
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               u[qz] += QQD[qz][qy][dx] * Bt[dy][qy];
+            }
+         }
+         MFEM_UNROLL(MQ1)
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            QDD[qz][dy][dx] = u[qz];
+         }
+      }
+   }
+   MFEM_SYNC_THREAD;
+   MFEM_FOREACH_THREAD(dy,y,D1D)
+   {
+      MFEM_FOREACH_THREAD(dx,x,D1D)
+      {
+         double u[D1D];
+         MFEM_UNROLL(MD1)
+         for (int dz = 0; dz < D1D; ++dz)
+         {
+            u[dz] = 0;
+         }
+         MFEM_UNROLL(MQ1)
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            MFEM_UNROLL(MD1)
+            for (int dz = 0; dz < D1D; ++dz)
+            {
+               u[dz] += QDD[qz][dy][dx] * Bt[dz][qz];
+            }
+         }
+         MFEM_UNROLL(MD1)
+         for (int dz = 0; dz < D1D; ++dz)
+         {
+            if (ACCUMULATE)
+            {
+               y(dx,dy,dz,e) += u[dz];
+            }
+            else
+            {
+               y(dx,dy,dz,e) = u[dz];
+            }
+         }
+      }
+   }
+   MFEM_SYNC_THREAD;
+}
+
+MFEM_HOST_DEVICE inline
+void PAMassApply1D(const int NE,
+                   const Array<double> &b_,
+                   const Array<double> &bt_,
+                   const Vector &d_,
+                   const Vector &x_,
+                   Vector &y_,
+                   const int d1d = 0,
+                   const int q1d = 0)
+{
+   MFEM_VERIFY(d1d <= MAX_D1D, "");
+   MFEM_VERIFY(q1d <= MAX_Q1D, "");
+
+   const auto B = b_.Read();
+   const auto Bt = bt_.Read();
+   const auto D = d_.Read();
+   const auto X = x_.Read();
+   auto Y = y_.ReadWrite();
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      internal::PAMassApply1D_Element(e, NE, B, Bt, D, X, Y, d1d, q1d);
+   });
+}
+
+template<int T_D1D = 0, int T_Q1D = 0>
+MFEM_HOST_DEVICE inline
+void PAMassApply2D(const int NE,
+                   const Array<double> &b_,
+                   const Array<double> &bt_,
+                   const Vector &d_,
+                   const Vector &x_,
+                   Vector &y_,
+                   const int d1d = 0,
+                   const int q1d = 0)
+{
+   MFEM_VERIFY(T_D1D ? T_D1D : d1d <= MAX_D1D, "");
+   MFEM_VERIFY(T_Q1D ? T_Q1D : q1d <= MAX_Q1D, "");
+
+   const auto B = b_.Read();
+   const auto Bt = bt_.Read();
+   const auto D = d_.Read();
+   const auto X = x_.Read();
+   auto Y = y_.ReadWrite();
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      internal::PAMassApply2D_Element(e, NE, B, Bt, D, X, Y, d1d, q1d);
+   });
+}
+
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+MFEM_HOST_DEVICE inline
+void SmemPAMassApply2D(const int NE,
+                       const Array<double> &b_,
+                       const Array<double> &bt_,
+                       const Vector &d_,
+                       const Vector &x_,
+                       Vector &y_,
+                       const int d1d = 0,
+                       const int q1d = 0)
+{
+   MFEM_CONTRACT_VAR(bt_);
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int NBZ = T_NBZ ? T_NBZ : 1;
+   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+   MFEM_VERIFY(D1D <= MD1, "");
+   MFEM_VERIFY(Q1D <= MQ1, "");
+   const auto b = b_.Read();
+   const auto D = d_.Read();
+   const auto x = x_.Read();
+   auto Y = y_.ReadWrite();
+   mfem::forall_2D_batch(NE, Q1D, Q1D, NBZ, [=] MFEM_HOST_DEVICE (int e)
+   {
+      internal::SmemPAMassApply2D_Element<T_D1D,T_Q1D,T_NBZ>(e, NE, b, D, x, Y, d1d,
+                                                             q1d);
+   });
+}
+
+template<int T_D1D = 0, int T_Q1D = 0>
+MFEM_HOST_DEVICE inline
+void PAMassApply3D(const int NE,
+                   const Array<double> &b_,
+                   const Array<double> &bt_,
+                   const Vector &d_,
+                   const Vector &x_,
+                   Vector &y_,
+                   const int d1d = 0,
+                   const int q1d = 0)
+{
+   MFEM_VERIFY(T_D1D ? T_D1D : d1d <= MAX_D1D, "");
+   MFEM_VERIFY(T_Q1D ? T_Q1D : q1d <= MAX_Q1D, "");
+
+   const auto B = b_.Read();
+   const auto Bt = bt_.Read();
+   const auto D = d_.Read();
+   const auto X = x_.Read();
+   auto Y = y_.ReadWrite();
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      internal::PAMassApply3D_Element(e, NE, B, Bt, D, X, Y, d1d, q1d);
+   });
+}
+
+template<int T_D1D = 0, int T_Q1D = 0>
+MFEM_HOST_DEVICE inline
+void SmemPAMassApply3D(const int NE,
+                       const Array<double> &b_,
+                       const Array<double> &bt_,
+                       const Vector &d_,
+                       const Vector &x_,
+                       Vector &y_,
+                       const int d1d = 0,
+                       const int q1d = 0)
+{
+   MFEM_CONTRACT_VAR(bt_);
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int M1Q = T_Q1D ? T_Q1D : MAX_Q1D;
+   constexpr int M1D = T_D1D ? T_D1D : MAX_D1D;
+   MFEM_VERIFY(D1D <= M1D, "");
+   MFEM_VERIFY(Q1D <= M1Q, "");
+   auto b = b_.Read();
+   auto d = d_.Read();
+   auto x = x_.Read();
+   auto y = y_.ReadWrite();
+   mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+   {
+      internal::SmemPAMassApply3D_Element<T_D1D,T_Q1D>(e, NE, b, d, x, y, d1d, q1d);
+   });
+}
+
+MFEM_HOST_DEVICE inline
+void PAMassApply(const int dim,
+                 const int D1D,
+                 const int Q1D,
+                 const int NE,
+                 const Array<double> &B,
+                 const Array<double> &Bt,
+                 const Vector &D,
+                 const Vector &X,
+                 Vector &Y)
+{
+#ifdef MFEM_USE_OCCA
+   if (DeviceCanUseOcca())
+   {
+      if (dim == 2)
+      {
+         return OccaPAMassApply2D(D1D,Q1D,NE,B,Bt,D,X,Y);
+      }
+      if (dim == 3)
+      {
+         return OccaPAMassApply3D(D1D,Q1D,NE,B,Bt,D,X,Y);
+      }
+      MFEM_ABORT("OCCA PA Mass Apply unknown kernel!");
+   }
+#endif // MFEM_USE_OCCA
+   const int id = (D1D << 4) | Q1D;
+
+   if (dim == 1)
+   {
+      return PAMassApply1D(NE,B,Bt,D,X,Y,D1D,Q1D);
+   }
+   else if (dim == 2)
+   {
+      switch (id)
+      {
+         case 0x22: return SmemPAMassApply2D<2,2,16>(NE,B,Bt,D,X,Y);
+         case 0x24: return SmemPAMassApply2D<2,4,16>(NE,B,Bt,D,X,Y);
+         case 0x33: return SmemPAMassApply2D<3,3,16>(NE,B,Bt,D,X,Y);
+         case 0x34: return SmemPAMassApply2D<3,4,16>(NE,B,Bt,D,X,Y);
+         case 0x35: return SmemPAMassApply2D<3,5,16>(NE,B,Bt,D,X,Y);
+         case 0x36: return SmemPAMassApply2D<3,6,16>(NE,B,Bt,D,X,Y);
+         case 0x44: return SmemPAMassApply2D<4,4,8>(NE,B,Bt,D,X,Y);
+         case 0x46: return SmemPAMassApply2D<4,6,8>(NE,B,Bt,D,X,Y);
+         case 0x48: return SmemPAMassApply2D<4,8,4>(NE,B,Bt,D,X,Y);
+         case 0x55: return SmemPAMassApply2D<5,5,8>(NE,B,Bt,D,X,Y);
+         case 0x57: return SmemPAMassApply2D<5,7,8>(NE,B,Bt,D,X,Y);
+         case 0x58: return SmemPAMassApply2D<5,8,2>(NE,B,Bt,D,X,Y);
+         case 0x66: return SmemPAMassApply2D<6,6,4>(NE,B,Bt,D,X,Y);
+         case 0x77: return SmemPAMassApply2D<7,7,4>(NE,B,Bt,D,X,Y);
+         case 0x88: return SmemPAMassApply2D<8,8,2>(NE,B,Bt,D,X,Y);
+         case 0x99: return SmemPAMassApply2D<9,9,2>(NE,B,Bt,D,X,Y);
+         default:   return PAMassApply2D(NE,B,Bt,D,X,Y,D1D,Q1D);
+      }
+   }
+   else if (dim == 3)
+   {
+      switch (id)
+      {
+         case 0x22: return SmemPAMassApply3D<2,2>(NE,B,Bt,D,X,Y);
+         case 0x23: return SmemPAMassApply3D<2,3>(NE,B,Bt,D,X,Y);
+         case 0x24: return SmemPAMassApply3D<2,4>(NE,B,Bt,D,X,Y);
+         case 0x26: return SmemPAMassApply3D<2,6>(NE,B,Bt,D,X,Y);
+         case 0x34: return SmemPAMassApply3D<3,4>(NE,B,Bt,D,X,Y);
+         case 0x35: return SmemPAMassApply3D<3,5>(NE,B,Bt,D,X,Y);
+         case 0x36: return SmemPAMassApply3D<3,6>(NE,B,Bt,D,X,Y);
+         case 0x37: return SmemPAMassApply3D<3,7>(NE,B,Bt,D,X,Y);
+         case 0x45: return SmemPAMassApply3D<4,5>(NE,B,Bt,D,X,Y);
+         case 0x46: return SmemPAMassApply3D<4,6>(NE,B,Bt,D,X,Y);
+         case 0x48: return SmemPAMassApply3D<4,8>(NE,B,Bt,D,X,Y);
+         case 0x56: return SmemPAMassApply3D<5,6>(NE,B,Bt,D,X,Y);
+         case 0x58: return SmemPAMassApply3D<5,8>(NE,B,Bt,D,X,Y);
+         case 0x67: return SmemPAMassApply3D<6,7>(NE,B,Bt,D,X,Y);
+         case 0x78: return SmemPAMassApply3D<7,8>(NE,B,Bt,D,X,Y);
+         case 0x89: return SmemPAMassApply3D<8,9>(NE,B,Bt,D,X,Y);
+         case 0x9A: return SmemPAMassApply3D<9,10>(NE,B,Bt,D,X,Y);
+         default:   return PAMassApply3D(NE,B,Bt,D,X,Y,D1D,Q1D);
+      }
+   }
+   mfem::out << "Unknown kernel 0x" << std::hex << id << std::endl;
+   MFEM_ABORT("Unknown kernel.");
+}
+
+} // namespace internal
+
+} // namespace mfem
+
+#endif
diff --git a/fem/bilininteg_mass_mf.cpp b/fem/integ/bilininteg_mass_mf.cpp
similarity index 92%
rename from fem/bilininteg_mass_mf.cpp
rename to fem/integ/bilininteg_mass_mf.cpp
index 2a89c0ce6..34a118b6d 100644
--- a/fem/bilininteg_mass_mf.cpp
+++ b/fem/integ/bilininteg_mass_mf.cpp
@@ -9,12 +9,10 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "ceed/integrators/mass/mass.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/mass/mass.hpp"
 
 namespace mfem
 {
@@ -22,7 +20,6 @@ namespace mfem
 void MassIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
diff --git a/fem/integ/bilininteg_mass_pa.cpp b/fem/integ/bilininteg_mass_pa.cpp
new file mode 100644
index 000000000..ffdec1edb
--- /dev/null
+++ b/fem/integ/bilininteg_mass_pa.cpp
@@ -0,0 +1,220 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../ceed/integrators/mass/mass.hpp"
+#include "bilininteg_mass_kernels.hpp"
+
+namespace mfem
+{
+
+void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
+                         Device::GetDeviceMemoryType() : pa_mt;
+
+   // Assuming the same element type
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation *T0 = mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T0);
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
+                         fes.IsVariableOrder();
+      if (mixed)
+      {
+         ceedOp = new ceed::MixedPAMassIntegrator(*this, fes, Q);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMassIntegrator(fes, *ir, Q);
+      }
+      return;
+   }
+   int map_type = el.GetMapType();
+   dim = mesh->Dimension();
+   ne = fes.GetMesh()->GetNE();
+   nq = ir->GetNPoints();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::DETERMINANTS, mt);
+   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
+   dofs1D = maps->ndof;
+   quad1D = maps->nqpt;
+   pa_data.SetSize(ne*nq, mt);
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
+
+   if (dim==1) { MFEM_ABORT("Not supported yet... stay tuned!"); }
+   if (dim==2)
+   {
+      const int NE = ne;
+      const int Q1D = quad1D;
+      const bool const_c = coeff.Size() == 1;
+      const bool by_val = map_type == FiniteElement::VALUE;
+      const auto W = Reshape(ir->GetWeights().Read(), Q1D,Q1D);
+      const auto J = Reshape(geom->detJ.Read(), Q1D,Q1D,NE);
+      const auto C = const_c ? Reshape(coeff.Read(), 1,1,1) :
+                     Reshape(coeff.Read(), Q1D,Q1D,NE);
+      auto v = Reshape(pa_data.Write(), Q1D,Q1D, NE);
+      mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+      {
+         MFEM_FOREACH_THREAD(qx,x,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qy,y,Q1D)
+            {
+               const double detJ = J(qx,qy,e);
+               const double coeff = const_c ? C(0,0,0) : C(qx,qy,e);
+               v(qx,qy,e) = W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
+            }
+         }
+      });
+   }
+   if (dim==3)
+   {
+      const int NE = ne;
+      const int Q1D = quad1D;
+      const bool const_c = coeff.Size() == 1;
+      const bool by_val = map_type == FiniteElement::VALUE;
+      const auto W = Reshape(ir->GetWeights().Read(), Q1D,Q1D,Q1D);
+      const auto J = Reshape(geom->detJ.Read(), Q1D,Q1D,Q1D,NE);
+      const auto C = const_c ? Reshape(coeff.Read(), 1,1,1,1) :
+                     Reshape(coeff.Read(), Q1D,Q1D,Q1D,NE);
+      auto v = Reshape(pa_data.Write(), Q1D,Q1D,Q1D,NE);
+      mfem::forall_3D(NE, Q1D, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+      {
+         MFEM_FOREACH_THREAD(qx,x,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qy,y,Q1D)
+            {
+               MFEM_FOREACH_THREAD(qz,z,Q1D)
+               {
+                  const double detJ = J(qx,qy,qz,e);
+                  const double coeff = const_c ? C(0,0,0,0) : C(qx,qy,qz,e);
+                  v(qx,qy,qz,e) = W(qx,qy,qz) * coeff * (by_val ? detJ : 1.0/detJ);
+               }
+            }
+         }
+      });
+   }
+}
+
+void MassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
+                         Device::GetDeviceMemoryType() : pa_mt;
+
+   // Assuming the same element type
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   const FiniteElement &el = *fes.GetBE(0);
+   ElementTransformation *T0 = mesh->GetBdrElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T0);
+
+   int map_type = el.GetMapType();
+   dim = el.GetDim(); // Dimension of the boundary element, *not* the mesh
+   ne = fes.GetMesh()->GetNBE();
+   nq = ir->GetNPoints();
+   face_geom = mesh->GetFaceGeometricFactors(*ir, GeometricFactors::DETERMINANTS,
+                                             FaceType::Boundary, mt);
+   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
+   dofs1D = maps->ndof;
+   quad1D = maps->nqpt;
+   pa_data.SetSize(ne*nq, mt);
+
+   FaceQuadratureSpace qs(*mesh, *ir, FaceType::Boundary);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
+
+   const int NE = ne;
+   const int Q1D = quad1D;
+   const bool const_c = coeff.Size() == 1;
+   const bool by_val = map_type == FiniteElement::VALUE;
+   if (dim==1)
+   {
+      const auto W = Reshape(ir->GetWeights().Read(), Q1D);
+      const auto J = Reshape(face_geom->detJ.Read(), Q1D, NE);
+      const auto C = const_c ? Reshape(coeff.Read(), 1, 1) :
+                     Reshape(coeff.Read(), Q1D, NE);
+      auto v = Reshape(pa_data.Write(), Q1D, NE);
+      mfem::forall_2D(NE, Q1D, 1, [=] MFEM_HOST_DEVICE (int e)
+      {
+         MFEM_FOREACH_THREAD(qx,x,Q1D)
+         {
+            const double detJ = J(qx,e);
+            const double coeff = const_c ? C(0,0) : C(qx,e);
+            v(qx,e) = W(qx) * coeff * (by_val ? detJ : 1.0/detJ);
+         }
+      });
+   }
+   else if (dim==2)
+   {
+      const auto W = Reshape(ir->GetWeights().Read(), Q1D,Q1D);
+      const auto J = Reshape(face_geom->detJ.Read(), Q1D,Q1D,NE);
+      const auto C = const_c ? Reshape(coeff.Read(), 1,1,1) :
+                     Reshape(coeff.Read(), Q1D,Q1D,NE);
+      auto v = Reshape(pa_data.Write(), Q1D,Q1D, NE);
+      mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+      {
+         MFEM_FOREACH_THREAD(qx,x,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qy,y,Q1D)
+            {
+               const double detJ = J(qx,qy,e);
+               const double coeff = const_c ? C(0,0,0) : C(qx,qy,e);
+               v(qx,qy,e) = W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
+            }
+         }
+      });
+   }
+   else
+   {
+      MFEM_ABORT("Not supported.");
+   }
+}
+
+void MassIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
+   {
+      internal::PAMassAssembleDiagonal(dim, dofs1D, quad1D, ne, maps->B, pa_data,
+                                       diag);
+   }
+}
+
+void MassIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      internal::PAMassApply(dim, dofs1D, quad1D, ne, maps->B, maps->Bt, pa_data, x,
+                            y);
+   }
+}
+
+void MassIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
+{
+   // Mass integrator is symmetric
+   AddMultPA(x, y);
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_mixedcurl_pa.cpp b/fem/integ/bilininteg_mixedcurl_pa.cpp
new file mode 100644
index 000000000..3d70bc4c9
--- /dev/null
+++ b/fem/integ/bilininteg_mixedcurl_pa.cpp
@@ -0,0 +1,424 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "bilininteg_hcurl_kernels.hpp"
+#include "bilininteg_hcurlhdiv_kernels.hpp"
+
+namespace mfem
+{
+
+void MixedScalarCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                           const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *fel = trial_fes.GetFE(0); // In H(curl)
+   const FiniteElement *eltest = test_fes.GetFE(0); // In scalar space
+
+   const VectorTensorFiniteElement *el =
+      dynamic_cast<const VectorTensorFiniteElement*>(fel);
+   MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   if (el->GetDerivType() != mfem::FiniteElement::CURL)
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+
+   const IntegrationRule *ir
+      = IntRule ? IntRule : &MassIntegrator::GetRule(*eltest, *eltest,
+                                                     *mesh->GetElementTransformation(0));
+
+   const int dims = el->GetDim();
+   MFEM_VERIFY(dims == 2, "");
+
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2, "");
+
+   ne = test_fes.GetNE();
+   mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   if (el->GetOrder() == eltest->GetOrder())
+   {
+      dofs1Dtest = dofs1D;
+   }
+   else
+   {
+      dofs1Dtest = dofs1D - 1;
+   }
+
+   pa_data.SetSize(nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
+
+   if (dim == 2)
+   {
+      internal::PAHcurlL2Setup2D(quad1D, ne, ir->GetWeights(), coeff, pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+void MixedScalarCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (dim == 2)
+   {
+      internal::PAHcurlL2Apply2D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
+                                 mapsO->Bt, mapsC->Bt, mapsC->G, pa_data,
+                                 x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+void MixedScalarCurlIntegrator::AddMultTransposePA(const Vector &x,
+                                                   Vector &y) const
+{
+   if (dim == 2)
+   {
+      internal::PAHcurlL2ApplyTranspose2D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
+                                          mapsO->Bt, mapsC->B, mapsC->Gt, pa_data,
+                                          x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+void MixedVectorCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                           const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements, with vector test and trial spaces.
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const VectorTensorFiniteElement *trial_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const IntegrationRule *ir
+      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
+                                                     *mesh->GetElementTransformation(0));
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 3, "");
+
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
+
+   ne = trial_fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &trial_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   mapsCtest = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsOtest = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+   dofs1Dtest = mapsCtest->ndof;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   testType = test_el->GetDerivType();
+   trialType = trial_el->GetDerivType();
+
+   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+   coeffDim = (DQ ? 3 : 1);
+
+   const bool curlSpaces = (testType == mfem::FiniteElement::CURL &&
+                            trialType == mfem::FiniteElement::CURL);
+
+   const int ndata = curlSpaces ? (coeffDim == 1 ? 1 : 9) : symmDims;
+   pa_data.SetSize(ndata * nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(qs, CoefficientStorage::FULL);
+   if (Q) { coeff.Project(*Q); }
+   else if (DQ) { coeff.Project(*DQ); }
+   else { coeff.SetConstant(1.0); }
+
+   if (testType == mfem::FiniteElement::CURL &&
+       trialType == mfem::FiniteElement::CURL && dim == 3)
+   {
+      if (coeffDim == 1)
+      {
+         internal::PAHcurlL2Setup3D(nq, coeffDim, ne, ir->GetWeights(), coeff, pa_data);
+      }
+      else
+      {
+         internal::PAHcurlHdivMassSetup3D(quad1D, coeffDim, ne, false, ir->GetWeights(),
+                                          geom->J, coeff, pa_data);
+      }
+   }
+   else if (testType == mfem::FiniteElement::DIV &&
+            trialType == mfem::FiniteElement::CURL && dim == 3 &&
+            test_fel->GetOrder() == trial_fel->GetOrder())
+   {
+      internal::PACurlCurlSetup3D(quad1D, coeffDim, ne, ir->GetWeights(), geom->J,
+                                  coeff, pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
+void MixedVectorCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (testType == mfem::FiniteElement::CURL &&
+       trialType == mfem::FiniteElement::CURL && dim == 3)
+   {
+      const int ndata = coeffDim == 1 ? 1 : 9;
+
+      if (Device::Allows(Backend::DEVICE_MASK))
+      {
+         const int ID = (dofs1D << 4) | quad1D;
+         switch (ID)
+         {
+            case 0x23:
+               return internal::SmemPAHcurlL2Apply3D<2,3>(
+                         dofs1D, quad1D, ndata, ne,
+                         mapsO->B, mapsC->B, mapsC->G,
+                         pa_data, x, y);
+            case 0x34:
+               return internal::SmemPAHcurlL2Apply3D<3,4>(
+                         dofs1D, quad1D, ndata, ne,
+                         mapsO->B, mapsC->B, mapsC->G,
+                         pa_data, x, y);
+            case 0x45:
+               return internal::SmemPAHcurlL2Apply3D<4,5>(
+                         dofs1D, quad1D, ndata, ne,
+                         mapsO->B, mapsC->B, mapsC->G,
+                         pa_data, x, y);
+            case 0x56:
+               return internal::SmemPAHcurlL2Apply3D<5,6>(
+                         dofs1D, quad1D, ndata, ne,
+                         mapsO->B, mapsC->B, mapsC->G,
+                         pa_data, x, y);
+            default:
+               return internal::SmemPAHcurlL2Apply3D(
+                         dofs1D, quad1D, ndata, ne,
+                         mapsO->B, mapsC->B, mapsC->G,
+                         pa_data, x, y);
+         }
+      }
+      else
+      {
+         internal::PAHcurlL2Apply3D(dofs1D, quad1D, ndata, ne, mapsO->B, mapsC->B,
+                                    mapsO->Bt, mapsC->Bt, mapsC->G, pa_data, x, y);
+      }
+   }
+   else if (testType == mfem::FiniteElement::DIV &&
+            trialType == mfem::FiniteElement::CURL && dim == 3)
+   {
+      internal::PAHcurlHdivApply3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
+                                   mapsC->B, mapsOtest->Bt, mapsCtest->Bt, mapsC->G,
+                                   pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension or space!");
+   }
+}
+
+void MixedVectorCurlIntegrator::AddMultTransposePA(const Vector &x,
+                                                   Vector &y) const
+{
+   if (testType == mfem::FiniteElement::DIV &&
+       trialType == mfem::FiniteElement::CURL && dim == 3)
+   {
+      internal::PAHcurlHdivApply3DTranspose(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
+                                            mapsC->B, mapsOtest->Bt, mapsCtest->Bt,
+                                            mapsC->Gt, pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension or space!");
+   }
+}
+
+void MixedVectorWeakCurlIntegrator::AssemblePA(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements, with vector test and trial spaces.
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const VectorTensorFiniteElement *trial_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const IntegrationRule *ir
+      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
+                                                     *mesh->GetElementTransformation(0));
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 3, "");
+
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
+
+   ne = trial_fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   testType = test_el->GetDerivType();
+   trialType = trial_el->GetDerivType();
+
+   const bool curlSpaces = (testType == mfem::FiniteElement::CURL &&
+                            trialType == mfem::FiniteElement::CURL);
+
+   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+
+   coeffDim = DQ ? 3 : 1;
+   const int ndata = curlSpaces ? (DQ ? 9 : 1) : symmDims;
+
+   pa_data.SetSize(ndata * nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(qs, CoefficientStorage::FULL);
+   if (Q) { coeff.Project(*Q); }
+   else if (DQ) { coeff.Project(*DQ); }
+   else { coeff.SetConstant(1.0); }
+
+   if (trialType == mfem::FiniteElement::CURL && dim == 3)
+   {
+      if (coeffDim == 1)
+      {
+         internal::PAHcurlL2Setup3D(nq, coeffDim, ne, ir->GetWeights(), coeff, pa_data);
+      }
+      else
+      {
+         internal::PAHcurlHdivMassSetup3D(quad1D, coeffDim, ne, false, ir->GetWeights(),
+                                          geom->J, coeff, pa_data);
+      }
+   }
+   else if (trialType == mfem::FiniteElement::DIV && dim == 3 &&
+            test_el->GetOrder() == trial_el->GetOrder())
+   {
+      internal::PACurlCurlSetup3D(quad1D, coeffDim, ne, ir->GetWeights(), geom->J,
+                                  coeff, pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
+void MixedVectorWeakCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (testType == mfem::FiniteElement::CURL &&
+       trialType == mfem::FiniteElement::CURL && dim == 3)
+   {
+      const int ndata = coeffDim == 1 ? 1 : 9;
+      if (Device::Allows(Backend::DEVICE_MASK))
+      {
+         const int ID = (dofs1D << 4) | quad1D;
+         switch (ID)
+         {
+            case 0x23:
+               return internal::SmemPAHcurlL2Apply3DTranspose<2,3>(
+                         dofs1D, quad1D, ndata,
+                         ne, mapsO->B, mapsC->B,
+                         mapsC->G, pa_data, x, y);
+            case 0x34:
+               return internal::SmemPAHcurlL2Apply3DTranspose<3,4>(
+                         dofs1D, quad1D, ndata,
+                         ne, mapsO->B, mapsC->B,
+                         mapsC->G, pa_data, x, y);
+            case 0x45:
+               return internal::SmemPAHcurlL2Apply3DTranspose<4,5>(
+                         dofs1D, quad1D, ndata,
+                         ne, mapsO->B, mapsC->B,
+                         mapsC->G, pa_data, x, y);
+            case 0x56:
+               return internal::SmemPAHcurlL2Apply3DTranspose<5,6>(
+                         dofs1D, quad1D, ndata,
+                         ne, mapsO->B, mapsC->B,
+                         mapsC->G, pa_data, x, y);
+            default:
+               return internal::SmemPAHcurlL2Apply3DTranspose(
+                         dofs1D, quad1D, ndata, ne,
+                         mapsO->B, mapsC->B,
+                         mapsC->G, pa_data, x, y);
+         }
+      }
+      else
+      {
+         internal::PAHcurlL2Apply3DTranspose(dofs1D, quad1D, ndata, ne, mapsO->B,
+                                             mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->Gt,
+                                             pa_data, x, y);
+      }
+   }
+   else if (testType == mfem::FiniteElement::CURL &&
+            trialType == mfem::FiniteElement::DIV && dim == 3)
+   {
+      internal::PAHcurlHdivApply3DTranspose(dofs1D, dofs1D, quad1D, ne, mapsO->B,
+                                            mapsC->B, mapsO->Bt, mapsC->Bt,
+                                            mapsC->Gt, pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension or space!");
+   }
+}
+
+void MixedVectorWeakCurlIntegrator::AddMultTransposePA(const Vector &x,
+                                                       Vector &y) const
+{
+   if (testType == mfem::FiniteElement::CURL &&
+       trialType == mfem::FiniteElement::DIV && dim == 3)
+   {
+      internal::PAHcurlHdivApply3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
+                                   mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->G,
+                                   pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension or space!");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_mixedvecgrad_pa.cpp b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
new file mode 100644
index 000000000..f9e6d3ee8
--- /dev/null
+++ b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
@@ -0,0 +1,757 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "bilininteg_diffusion_kernels.hpp"
+
+namespace mfem
+{
+
+// Apply to x corresponding to DOFs in H^1 (trial), whose gradients are
+// integrated against H(curl) test functions corresponding to y.
+static void PAHcurlH1Apply2D(const int D1D,
+                             const int Q1D,
+                             const int NE,
+                             const Array<double> &bc,
+                             const Array<double> &gc,
+                             const Array<double> &bot,
+                             const Array<double> &bct,
+                             const Vector &pa_data,
+                             const Vector &x,
+                             Vector &y)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, 3, NE);
+   auto X = Reshape(x.Read(), D1D, D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 2*(D1D-1)*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            for (int c = 0; c < VDIM; ++c)
+            {
+               mass[qy][qx][c] = 0.0;
+            }
+         }
+      }
+
+      for (int dy = 0; dy < D1D; ++dy)
+      {
+         double gradX[MAX_Q1D][2];
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            gradX[qx][0] = 0.0;
+            gradX[qx][1] = 0.0;
+         }
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            const double s = X(dx,dy,e);
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               gradX[qx][0] += s * Bc(qx,dx);
+               gradX[qx][1] += s * Gc(qx,dx);
+            }
+         }
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            const double wy  = Bc(qy,dy);
+            const double wDy = Gc(qy,dy);
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double wx  = gradX[qx][0];
+               const double wDx = gradX[qx][1];
+               mass[qy][qx][0] += wDx * wy;
+               mass[qy][qx][1] += wx * wDy;
+            }
+         }
+      }
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            const double O11 = op(qx,qy,0,e);
+            const double O12 = op(qx,qy,1,e);
+            const double O22 = op(qx,qy,2,e);
+            const double massX = mass[qy][qx][0];
+            const double massY = mass[qy][qx][1];
+            mass[qy][qx][0] = (O11*massX)+(O12*massY);
+            mass[qy][qx][1] = (O12*massX)+(O22*massY);
+         }
+      }
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         int osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+         {
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            double massX[MAX_D1D];
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               massX[dx] = 0;
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] += mass[qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  Y(dx + (dy * D1Dx) + osc, e) += massX[dx] * wy;
+               }
+            }
+
+            osc += D1Dx * D1Dy;
+         }  // loop c
+      }
+   }); // end of element loop
+}
+
+// Apply to x corresponding to DOFs in H(curl), integrated
+// against gradients of H^1 functions corresponding to y.
+static void PAHcurlH1ApplyTranspose2D(const int D1D,
+                                      const int Q1D,
+                                      const int NE,
+                                      const Array<double> &bc,
+                                      const Array<double> &bo,
+                                      const Array<double> &bct,
+                                      const Array<double> &gct,
+                                      const Vector &pa_data,
+                                      const Vector &x,
+                                      Vector &y)
+{
+   constexpr static int VDIM = 2;
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bt = Reshape(bct.Read(), D1D, Q1D);
+   auto Gt = Reshape(gct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, 3, NE);
+   auto X = Reshape(x.Read(), 2*(D1D-1)*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            for (int c = 0; c < VDIM; ++c)
+            {
+               mass[qy][qx][c] = 0.0;
+            }
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y components
+      {
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dy = 0; dy < D1Dy; ++dy)
+         {
+            double massX[MAX_Q1D];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               massX[qx] = 0.0;
+            }
+
+            for (int dx = 0; dx < D1Dx; ++dx)
+            {
+               const double t = X(dx + (dy * D1Dx) + osc, e);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+               }
+            }
+
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  mass[qy][qx][c] += massX[qx] * wy;
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            const double O11 = op(qx,qy,0,e);
+            const double O12 = op(qx,qy,1,e);
+            const double O22 = op(qx,qy,2,e);
+            const double massX = mass[qy][qx][0];
+            const double massY = mass[qy][qx][1];
+            mass[qy][qx][0] = (O11*massX)+(O12*massY);
+            mass[qy][qx][1] = (O12*massX)+(O22*massY);
+         }
+      }
+
+      for (int qy = 0; qy < Q1D; ++qy)
+      {
+         double gradX[MAX_D1D][2];
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            gradX[dx][0] = 0;
+            gradX[dx][1] = 0;
+         }
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            const double gX = mass[qy][qx][0];
+            const double gY = mass[qy][qx][1];
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               const double wx  = Bt(dx,qx);
+               const double wDx = Gt(dx,qx);
+               gradX[dx][0] += gX * wDx;
+               gradX[dx][1] += gY * wx;
+            }
+         }
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            const double wy  = Bt(dy,qy);
+            const double wDy = Gt(dy,qy);
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               Y(dx,dy,e) += ((gradX[dx][0] * wy) + (gradX[dx][1] * wDy));
+            }
+         }
+      }
+   }); // end of element loop
+}
+
+// Apply to x corresponding to DOFs in H^1 (trial), whose gradients are
+// integrated against H(curl) test functions corresponding to y.
+static void PAHcurlH1Apply3D(const int D1D,
+                             const int Q1D,
+                             const int NE,
+                             const Array<double> &bc,
+                             const Array<double> &gc,
+                             const Array<double> &bot,
+                             const Array<double> &bct,
+                             const Vector &pa_data,
+                             const Vector &x,
+                             Vector &y)
+{
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+
+   constexpr static int VDIM = 3;
+
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Gc = Reshape(gc.Read(), Q1D, D1D);
+   auto Bot = Reshape(bot.Read(), D1D-1, Q1D);
+   auto Bct = Reshape(bct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
+   auto X = Reshape(x.Read(), D1D, D1D, D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), 3*(D1D-1)*D1D*D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  mass[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      for (int dz = 0; dz < D1D; ++dz)
+      {
+         double gradXY[MAX_Q1D][MAX_Q1D][3];
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               gradXY[qy][qx][0] = 0.0;
+               gradXY[qy][qx][1] = 0.0;
+               gradXY[qy][qx][2] = 0.0;
+            }
+         }
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            double gradX[MAX_Q1D][2];
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               gradX[qx][0] = 0.0;
+               gradX[qx][1] = 0.0;
+            }
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               const double s = X(dx,dy,dz,e);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  gradX[qx][0] += s * Bc(qx,dx);
+                  gradX[qx][1] += s * Gc(qx,dx);
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const double wy  = Bc(qy,dy);
+               const double wDy = Gc(qy,dy);
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  const double wx  = gradX[qx][0];
+                  const double wDx = gradX[qx][1];
+                  gradXY[qy][qx][0] += wDx * wy;
+                  gradXY[qy][qx][1] += wx * wDy;
+                  gradXY[qy][qx][2] += wx * wy;
+               }
+            }
+         }
+         for (int qz = 0; qz < Q1D; ++qz)
+         {
+            const double wz  = Bc(qz,dz);
+            const double wDz = Gc(qz,dz);
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  mass[qz][qy][qx][0] += gradXY[qy][qx][0] * wz;
+                  mass[qz][qy][qx][1] += gradXY[qy][qx][1] * wz;
+                  mass[qz][qy][qx][2] += gradXY[qy][qx][2] * wDz;
+               }
+            }
+         }
+      }
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(qx,qy,qz,0,e);
+               const double O12 = op(qx,qy,qz,1,e);
+               const double O13 = op(qx,qy,qz,2,e);
+               const double O22 = op(qx,qy,qz,3,e);
+               const double O23 = op(qx,qy,qz,4,e);
+               const double O33 = op(qx,qy,qz,5,e);
+               const double massX = mass[qz][qy][qx][0];
+               const double massY = mass[qz][qy][qx][1];
+               const double massZ = mass[qz][qy][qx][2];
+               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
+               mass[qz][qy][qx][1] = (O12*massX)+(O22*massY)+(O23*massZ);
+               mass[qz][qy][qx][2] = (O13*massX)+(O23*massY)+(O33*massZ);
+            }
+         }
+      }
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         double massXY[MAX_D1D][MAX_D1D];
+
+         int osc = 0;
+
+         for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+         {
+            const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+            const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+            const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massXY[dy][dx] = 0.0;
+               }
+            }
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               double massX[MAX_D1D];
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  massX[dx] = 0;
+               }
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massX[dx] += mass[qz][qy][qx][c] * ((c == 0) ? Bot(dx,qx) : Bct(dx,qx));
+                  }
+               }
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  const double wy = (c == 1) ? Bot(dy,qy) : Bct(dy,qy);
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     massXY[dy][dx] += massX[dx] * wy;
+                  }
+               }
+            }
+
+            for (int dz = 0; dz < D1Dz; ++dz)
+            {
+               const double wz = (c == 2) ? Bot(dz,qz) : Bct(dz,qz);
+               for (int dy = 0; dy < D1Dy; ++dy)
+               {
+                  for (int dx = 0; dx < D1Dx; ++dx)
+                  {
+                     Y(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e) += massXY[dy][dx] * wz;
+                  }
+               }
+            }
+
+            osc += D1Dx * D1Dy * D1Dz;
+         }  // loop c
+      }  // loop qz
+   }); // end of element loop
+}
+
+// Apply to x corresponding to DOFs in H(curl), integrated
+// against gradients of H^1 functions corresponding to y.
+static void PAHcurlH1ApplyTranspose3D(const int D1D,
+                                      const int Q1D,
+                                      const int NE,
+                                      const Array<double> &bc,
+                                      const Array<double> &bo,
+                                      const Array<double> &bct,
+                                      const Array<double> &gct,
+                                      const Vector &pa_data,
+                                      const Vector &x,
+                                      Vector &y)
+{
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(D1D <= MAX_D1D, "Error: D1D > MAX_D1D");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "Error: Q1D > MAX_Q1D");
+
+   constexpr static int VDIM = 3;
+
+   auto Bc = Reshape(bc.Read(), Q1D, D1D);
+   auto Bo = Reshape(bo.Read(), Q1D, D1D-1);
+   auto Bt = Reshape(bct.Read(), D1D, Q1D);
+   auto Gt = Reshape(gct.Read(), D1D, Q1D);
+   auto op = Reshape(pa_data.Read(), Q1D, Q1D, Q1D, 6, NE);
+   auto X = Reshape(x.Read(), 3*(D1D-1)*D1D*D1D, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, D1D, D1D, NE);
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double mass[MAX_Q1D][MAX_Q1D][MAX_Q1D][VDIM];
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int c = 0; c < VDIM; ++c)
+               {
+                  mass[qz][qy][qx][c] = 0.0;
+               }
+            }
+         }
+      }
+
+      int osc = 0;
+
+      for (int c = 0; c < VDIM; ++c)  // loop over x, y, z components
+      {
+         const int D1Dz = (c == 2) ? D1D - 1 : D1D;
+         const int D1Dy = (c == 1) ? D1D - 1 : D1D;
+         const int D1Dx = (c == 0) ? D1D - 1 : D1D;
+
+         for (int dz = 0; dz < D1Dz; ++dz)
+         {
+            double massXY[MAX_Q1D][MAX_Q1D];
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massXY[qy][qx] = 0.0;
+               }
+            }
+
+            for (int dy = 0; dy < D1Dy; ++dy)
+            {
+               double massX[MAX_Q1D];
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  massX[qx] = 0.0;
+               }
+
+               for (int dx = 0; dx < D1Dx; ++dx)
+               {
+                  const double t = X(dx + ((dy + (dz * D1Dy)) * D1Dx) + osc, e);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     massX[qx] += t * ((c == 0) ? Bo(qx,dx) : Bc(qx,dx));
+                  }
+               }
+
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  const double wy = (c == 1) ? Bo(qy,dy) : Bc(qy,dy);
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     const double wx = massX[qx];
+                     massXY[qy][qx] += wx * wy;
+                  }
+               }
+            }
+
+            for (int qz = 0; qz < Q1D; ++qz)
+            {
+               const double wz = (c == 2) ? Bo(qz,dz) : Bc(qz,dz);
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int qx = 0; qx < Q1D; ++qx)
+                  {
+                     mass[qz][qy][qx][c] += massXY[qy][qx] * wz;
+                  }
+               }
+            }
+         }
+
+         osc += D1Dx * D1Dy * D1Dz;
+      }  // loop (c) over components
+
+      // Apply D operator.
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double O11 = op(qx,qy,qz,0,e);
+               const double O12 = op(qx,qy,qz,1,e);
+               const double O13 = op(qx,qy,qz,2,e);
+               const double O22 = op(qx,qy,qz,3,e);
+               const double O23 = op(qx,qy,qz,4,e);
+               const double O33 = op(qx,qy,qz,5,e);
+               const double massX = mass[qz][qy][qx][0];
+               const double massY = mass[qz][qy][qx][1];
+               const double massZ = mass[qz][qy][qx][2];
+               mass[qz][qy][qx][0] = (O11*massX)+(O12*massY)+(O13*massZ);
+               mass[qz][qy][qx][1] = (O12*massX)+(O22*massY)+(O23*massZ);
+               mass[qz][qy][qx][2] = (O13*massX)+(O23*massY)+(O33*massZ);
+            }
+         }
+      }
+
+      for (int qz = 0; qz < Q1D; ++qz)
+      {
+         double gradXY[MAX_D1D][MAX_D1D][3];
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               gradXY[dy][dx][0] = 0;
+               gradXY[dy][dx][1] = 0;
+               gradXY[dy][dx][2] = 0;
+            }
+         }
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            double gradX[MAX_D1D][3];
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               gradX[dx][0] = 0;
+               gradX[dx][1] = 0;
+               gradX[dx][2] = 0;
+            }
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               const double gX = mass[qz][qy][qx][0];
+               const double gY = mass[qz][qy][qx][1];
+               const double gZ = mass[qz][qy][qx][2];
+               for (int dx = 0; dx < D1D; ++dx)
+               {
+                  const double wx  = Bt(dx,qx);
+                  const double wDx = Gt(dx,qx);
+                  gradX[dx][0] += gX * wDx;
+                  gradX[dx][1] += gY * wx;
+                  gradX[dx][2] += gZ * wx;
+               }
+            }
+            for (int dy = 0; dy < D1D; ++dy)
+            {
+               const double wy  = Bt(dy,qy);
+               const double wDy = Gt(dy,qy);
+               for (int dx = 0; dx < D1D; ++dx)
+               {
+                  gradXY[dy][dx][0] += gradX[dx][0] * wy;
+                  gradXY[dy][dx][1] += gradX[dx][1] * wDy;
+                  gradXY[dy][dx][2] += gradX[dx][2] * wy;
+               }
+            }
+         }
+         for (int dz = 0; dz < D1D; ++dz)
+         {
+            const double wz  = Bt(dz,qz);
+            const double wDz = Gt(dz,qz);
+            for (int dy = 0; dy < D1D; ++dy)
+            {
+               for (int dx = 0; dx < D1D; ++dx)
+               {
+                  Y(dx,dy,dz,e) +=
+                     ((gradXY[dy][dx][0] * wz) +
+                      (gradXY[dy][dx][1] * wz) +
+                      (gradXY[dy][dx][2] * wDz));
+               }
+            }
+         }
+      }  // loop qz
+   }); // end of element loop
+}
+
+void MixedVectorGradientIntegrator::AssemblePA(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const IntegrationRule *ir
+      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
+                                                     *mesh->GetElementTransformation(0));
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
+
+   ne = trial_fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   pa_data.SetSize(symmDims * nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
+
+   // Use the same setup functions as VectorFEMassIntegrator.
+   if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 3)
+   {
+      internal::PADiffusionSetup3D(quad1D, 1, ne, ir->GetWeights(), geom->J,
+                                   coeff, pa_data);
+   }
+   else if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 2)
+   {
+      internal::PADiffusionSetup2D<2>(quad1D, 1, ne, ir->GetWeights(), geom->J,
+                                      coeff, pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
+void MixedVectorGradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+   {
+      PAHcurlH1Apply3D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
+                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
+   }
+   else if (dim == 2)
+   {
+      PAHcurlH1Apply2D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
+                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+void MixedVectorGradientIntegrator::AddMultTransposePA(const Vector &x,
+                                                       Vector &y) const
+{
+   if (dim == 3)
+   {
+      PAHcurlH1ApplyTranspose3D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
+                                mapsC->Bt, mapsC->Gt, pa_data, x, y);
+   }
+   else if (dim == 2)
+   {
+      PAHcurlH1ApplyTranspose2D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
+                                mapsC->Bt, mapsC->Gt, pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_transpose_ea.cpp b/fem/integ/bilininteg_transpose_ea.cpp
new file mode 100644
index 000000000..e1ac154fc
--- /dev/null
+++ b/fem/integ/bilininteg_transpose_ea.cpp
@@ -0,0 +1,106 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+
+namespace mfem
+{
+
+void TransposeIntegrator::AssembleEA(const FiniteElementSpace &fes,
+                                     Vector &ea_data)
+{
+   const int ne = fes.GetNE();
+   if (ne == 0) { return; }
+
+   const int dofs = fes.GetFE(0)->GetDof();
+   Vector ea_data_tmp(ea_data.Size());
+   ea_data_tmp = 0.0;
+   bfi->AssembleEA(fes, ea_data_tmp);
+   auto A = Reshape(ea_data_tmp.Read(), dofs, dofs, ne);
+   auto AT = Reshape(ea_data.ReadWrite(), dofs, dofs, ne);
+   mfem::forall(ne, [=] MFEM_HOST_DEVICE (int e)
+   {
+      for (int i = 0; i < dofs; i++)
+      {
+         for (int j = 0; j < dofs; j++)
+         {
+            const double a = A(i, j, e);
+            AT(j, i, e) += a;
+         }
+      }
+   });
+}
+
+void TransposeIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &fes,
+                                                  Vector &ea_data_int,
+                                                  Vector &ea_data_ext)
+{
+   const int nf = fes.GetNFbyType(FaceType::Interior);
+   if (nf == 0) { return; }
+
+   const int face_dofs = fes.GetTraceElement(0,
+                                             fes.GetMesh()->GetFaceGeometry(0))->GetDof();
+   Vector ea_data_int_tmp(ea_data_int.Size());
+   Vector ea_data_ext_tmp(ea_data_ext.Size());
+   ea_data_int_tmp = 0.0;
+   ea_data_ext_tmp = 0.0;
+   bfi->AssembleEAInteriorFaces(fes, ea_data_int_tmp, ea_data_ext_tmp);
+   auto A_int = Reshape(ea_data_int_tmp.Read(), face_dofs, face_dofs, 2, nf);
+   auto A_ext = Reshape(ea_data_ext_tmp.Read(), face_dofs, face_dofs, 2, nf);
+   auto AT_int = Reshape(ea_data_int.ReadWrite(), face_dofs, face_dofs, 2, nf);
+   auto AT_ext = Reshape(ea_data_ext.ReadWrite(), face_dofs, face_dofs, 2, nf);
+   mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
+   {
+      for (int i = 0; i < face_dofs; i++)
+      {
+         for (int j = 0; j < face_dofs; j++)
+         {
+            const double a_int0 = A_int(i, j, 0, f);
+            const double a_int1 = A_int(i, j, 1, f);
+            const double a_ext0 = A_ext(i, j, 0, f);
+            const double a_ext1 = A_ext(i, j, 1, f);
+            AT_int(j, i, 0, f) += a_int0;
+            AT_int(j, i, 1, f) += a_int1;
+            AT_ext(j, i, 0, f) += a_ext1;
+            AT_ext(j, i, 1, f) += a_ext0;
+         }
+      }
+   });
+}
+
+void TransposeIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace &fes,
+                                                  Vector &ea_data_bdr)
+{
+   const int nf = fes.GetNFbyType(FaceType::Boundary);
+   if (nf == 0) { return; }
+
+   const int face_dofs = fes.GetTraceElement(0,
+                                             fes.GetMesh()->GetFaceGeometry(0))->GetDof();
+   Vector ea_data_bdr_tmp(ea_data_bdr.Size());
+   ea_data_bdr_tmp = 0.0;
+   bfi->AssembleEABoundaryFaces(fes, ea_data_bdr_tmp);
+   auto A_bdr = Reshape(ea_data_bdr_tmp.Read(), face_dofs, face_dofs, nf);
+   auto AT_bdr = Reshape(ea_data_bdr.ReadWrite(), face_dofs, face_dofs, nf);
+   mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
+   {
+      for (int i = 0; i < face_dofs; i++)
+      {
+         for (int j = 0; j < face_dofs; j++)
+         {
+            const double a_bdr = A_bdr(i, j, f);
+            AT_bdr(j, i, f) += a_bdr;
+         }
+      }
+   });
+}
+
+}
diff --git a/fem/bilininteg_vecdiffusion_mf.cpp b/fem/integ/bilininteg_vecdiffusion_mf.cpp
similarity index 93%
rename from fem/bilininteg_vecdiffusion_mf.cpp
rename to fem/integ/bilininteg_vecdiffusion_mf.cpp
index dae344544..7cad61496 100644
--- a/fem/bilininteg_vecdiffusion_mf.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_mf.cpp
@@ -9,12 +9,10 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "ceed/integrators/diffusion/diffusion.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/diffusion/diffusion.hpp"
 
 namespace mfem
 {
diff --git a/fem/bilininteg_vecdiffusion.cpp b/fem/integ/bilininteg_vecdiffusion_pa.cpp
similarity index 88%
rename from fem/bilininteg_vecdiffusion.cpp
rename to fem/integ/bilininteg_vecdiffusion_pa.cpp
index 1915fca37..84e4d5b2a 100644
--- a/fem/bilininteg_vecdiffusion.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_pa.cpp
@@ -9,19 +9,15 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "qfunction.hpp"
-#include "ceed/integrators/diffusion/diffusion.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../ceed/integrators/diffusion/diffusion.hpp"
 
 namespace mfem
 {
 
-// PA Vector Diffusion Integrator
-
 // PA Diffusion Assemble 2D kernel
 static void PAVectorDiffusionSetup2D(const int Q1D,
                                      const int NE,
@@ -40,7 +36,6 @@ static void PAVectorDiffusionSetup2D(const int Q1D,
    const auto C = const_c ? Reshape(c.Read(), 1,1) :
                   Reshape(c.Read(), NQ, NE);
 
-
    mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
       for (int q = 0; q < NQ; ++q)
@@ -76,7 +71,6 @@ static void PAVectorDiffusionSetup3D(const int Q1D,
    const auto C = const_c ? Reshape(c.Read(), 1,1) :
                   Reshape(c.Read(), NQ,NE);
 
-
    mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
       for (int q = 0; q < NQ; ++q)
@@ -118,28 +112,6 @@ static void PAVectorDiffusionSetup3D(const int Q1D,
    });
 }
 
-static void PAVectorDiffusionSetup(const int dim,
-                                   const int Q1D,
-                                   const int NE,
-                                   const Array<double> &W,
-                                   const Vector &J,
-                                   const Vector &C,
-                                   Vector &op)
-{
-   if (!(dim == 2 || dim == 3))
-   {
-      MFEM_ABORT("Dimension not supported.");
-   }
-   if (dim == 2)
-   {
-      PAVectorDiffusionSetup2D(Q1D, NE, W, J, C, op);
-   }
-   if (dim == 3)
-   {
-      PAVectorDiffusionSetup3D(Q1D, NE, W, J, C, op);
-   }
-}
-
 void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    // Assumes tensor-product elements
@@ -183,7 +155,10 @@ void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    const Array<double> &w = ir->GetWeights();
    const Vector &j = geom->J;
    Vector &d = pa_data;
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PAVectorDiffusionSetup"); }
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in VectorDiffusionIntegrator::AssemblePA");
+   }
    if (dim == 2 && sdim == 3)
    {
       constexpr int DIM = 2;
@@ -222,23 +197,224 @@ void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
    else
    {
-      PAVectorDiffusionSetup(dim, quad1D, ne, w, j, coeff, d);
+      if (dim == 2)
+      {
+         return PAVectorDiffusionSetup2D(quad1D, ne, w, j, coeff, d);
+      }
+      if (dim == 3)
+      {
+         return PAVectorDiffusionSetup3D(quad1D, ne, w, j, coeff, d);
+      }
+      MFEM_ABORT("Dimension not supported.");
+   }
+}
+
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAVectorDiffusionDiagonal2D(const int NE,
+                                        const Array<double> &b,
+                                        const Array<double> &g,
+                                        const Vector &d,
+                                        Vector &y,
+                                        const int d1d = 0,
+                                        const int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   MFEM_VERIFY(D1D <= MAX_D1D, "");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
+   auto B = Reshape(b.Read(), Q1D, D1D);
+   auto G = Reshape(g.Read(), Q1D, D1D);
+   // note the different shape for D, this is a (symmetric) matrix so we only
+   // store necessary entries
+   auto D = Reshape(d.Read(), Q1D*Q1D, 3, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, D1D, 2, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+      // gradphi \cdot Q \gradphi has four terms
+      double QD0[MQ1][MD1];
+      double QD1[MQ1][MD1];
+      double QD2[MQ1][MD1];
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            QD0[qx][dy] = 0.0;
+            QD1[qx][dy] = 0.0;
+            QD2[qx][dy] = 0.0;
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               const int q = qx + qy * Q1D;
+               const double D0 = D(q,0,e);
+               const double D1 = D(q,1,e);
+               const double D2 = D(q,2,e);
+               QD0[qx][dy] += B(qy, dy) * B(qy, dy) * D0;
+               QD1[qx][dy] += B(qy, dy) * G(qy, dy) * D1;
+               QD2[qx][dy] += G(qy, dy) * G(qy, dy) * D2;
+            }
+         }
+      }
+      for (int dy = 0; dy < D1D; ++dy)
+      {
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            double temp = 0.0;
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               temp += G(qx, dx) * G(qx, dx) * QD0[qx][dy];
+               temp += G(qx, dx) * B(qx, dx) * QD1[qx][dy];
+               temp += B(qx, dx) * G(qx, dx) * QD1[qx][dy];
+               temp += B(qx, dx) * B(qx, dx) * QD2[qx][dy];
+            }
+            Y(dx,dy,0,e) += temp;
+            Y(dx,dy,1,e) += temp;
+         }
+      }
+   });
+}
+
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAVectorDiffusionDiagonal3D(const int NE,
+                                        const Array<double> &b,
+                                        const Array<double> &g,
+                                        const Vector &d,
+                                        Vector &y,
+                                        const int d1d = 0,
+                                        const int q1d = 0)
+{
+   constexpr int DIM = 3;
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+   MFEM_VERIFY(D1D <= MD1, "");
+   MFEM_VERIFY(Q1D <= MQ1, "");
+   auto B = Reshape(b.Read(), Q1D, D1D);
+   auto G = Reshape(g.Read(), Q1D, D1D);
+   auto Q = Reshape(d.Read(), Q1D*Q1D*Q1D, 6, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, D1D, D1D, 3, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
+      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
+      double QQD[MQ1][MQ1][MD1];
+      double QDD[MQ1][MD1][MD1];
+      for (int i = 0; i < DIM; ++i)
+      {
+         for (int j = 0; j < DIM; ++j)
+         {
+            // first tensor contraction, along z direction
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  for (int dz = 0; dz < D1D; ++dz)
+                  {
+                     QQD[qx][qy][dz] = 0.0;
+                     for (int qz = 0; qz < Q1D; ++qz)
+                     {
+                        const int q = qx + (qy + qz * Q1D) * Q1D;
+                        const int k = j >= i ?
+                                      3 - (3-i)*(2-i)/2 + j:
+                                      3 - (3-j)*(2-j)/2 + i;
+                        const double O = Q(q,k,e);
+                        const double Bz = B(qz,dz);
+                        const double Gz = G(qz,dz);
+                        const double L = i==2 ? Gz : Bz;
+                        const double R = j==2 ? Gz : Bz;
+                        QQD[qx][qy][dz] += L * O * R;
+                     }
+                  }
+               }
+            }
+            // second tensor contraction, along y direction
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               for (int dz = 0; dz < D1D; ++dz)
+               {
+                  for (int dy = 0; dy < D1D; ++dy)
+                  {
+                     QDD[qx][dy][dz] = 0.0;
+                     for (int qy = 0; qy < Q1D; ++qy)
+                     {
+                        const double By = B(qy,dy);
+                        const double Gy = G(qy,dy);
+                        const double L = i==1 ? Gy : By;
+                        const double R = j==1 ? Gy : By;
+                        QDD[qx][dy][dz] += L * QQD[qx][qy][dz] * R;
+                     }
+                  }
+               }
+            }
+            // third tensor contraction, along x direction
+            for (int dz = 0; dz < D1D; ++dz)
+            {
+               for (int dy = 0; dy < D1D; ++dy)
+               {
+                  for (int dx = 0; dx < D1D; ++dx)
+                  {
+                     double temp = 0.0;
+                     for (int qx = 0; qx < Q1D; ++qx)
+                     {
+                        const double Bx = B(qx,dx);
+                        const double Gx = G(qx,dx);
+                        const double L = i==0 ? Gx : Bx;
+                        const double R = j==0 ? Gx : Bx;
+                        temp += L * QDD[qx][dy][dz] * R;
+                     }
+                     Y(dx, dy, dz, 0, e) += temp;
+                     Y(dx, dy, dz, 1, e) += temp;
+                     Y(dx, dy, dz, 2, e) += temp;
+                  }
+               }
+            }
+         }
+      }
+   });
+}
+
+void VectorDiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
+   {
+      if (dim == 2)
+      {
+         return PAVectorDiffusionDiagonal2D(ne, maps->B, maps->G,
+                                            pa_data, diag,
+                                            dofs1D, quad1D);
+      }
+      else if (dim == 3)
+      {
+         return PAVectorDiffusionDiagonal3D(ne, maps->B, maps->G,
+                                            pa_data, diag,
+                                            dofs1D, quad1D);
+      }
+      MFEM_ABORT("Dimension not implemented.");
    }
 }
 
 // PA Diffusion Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0, int T_VDIM = 0> static
-void PAVectorDiffusionApply2D(const int NE,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &d_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0,
-                              const int vdim = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_VDIM = 0>
+static void PAVectorDiffusionApply2D(const int NE,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &d_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     const int d1d = 0,
+                                     const int q1d = 0,
+                                     const int vdim = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -349,17 +525,16 @@ void PAVectorDiffusionApply2D(const int NE,
 }
 
 // PA Diffusion Apply 3D kernel
-template<const int T_D1D = 0,
-         const int T_Q1D = 0> static
-void PAVectorDiffusionApply3D(const int NE,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &op_,
-                              const Vector &x_,
-                              Vector &y_,
-                              int d1d = 0, int q1d = 0)
+template<const int T_D1D = 0, const int T_Q1D = 0>
+static void PAVectorDiffusionApply3D(const int NE,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &op_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     int d1d = 0, int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -542,7 +717,6 @@ void PAVectorDiffusionApply3D(const int NE,
    });
 }
 
-// PA Diffusion Apply kernel
 void VectorDiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
@@ -572,220 +746,14 @@ void VectorDiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
          }
       }
       if (dim == 2 && sdim == 2)
-      { return PAVectorDiffusionApply2D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D,sdim); }
-
-      if (dim == 3 && sdim == 3)
-      { return PAVectorDiffusionApply3D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D); }
-
-      MFEM_ABORT("Unknown kernel.");
-   }
-}
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void PAVectorDiffusionDiagonal2D(const int NE,
-                                        const Array<double> &b,
-                                        const Array<double> &g,
-                                        const Vector &d,
-                                        Vector &y,
-                                        const int d1d = 0,
-                                        const int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   MFEM_VERIFY(D1D <= MAX_D1D, "");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
-   auto B = Reshape(b.Read(), Q1D, D1D);
-   auto G = Reshape(g.Read(), Q1D, D1D);
-   // note the different shape for D, this is a (symmetric) matrix so we only
-   // store necessary entries
-   auto D = Reshape(d.Read(), Q1D*Q1D, 3, NE);
-   auto Y = Reshape(y.ReadWrite(), D1D, D1D, 2, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-      // gradphi \cdot Q \gradphi has four terms
-      double QD0[MQ1][MD1];
-      double QD1[MQ1][MD1];
-      double QD2[MQ1][MD1];
-      for (int qx = 0; qx < Q1D; ++qx)
       {
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            QD0[qx][dy] = 0.0;
-            QD1[qx][dy] = 0.0;
-            QD2[qx][dy] = 0.0;
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               const int q = qx + qy * Q1D;
-               const double D0 = D(q,0,e);
-               const double D1 = D(q,1,e);
-               const double D2 = D(q,2,e);
-               QD0[qx][dy] += B(qy, dy) * B(qy, dy) * D0;
-               QD1[qx][dy] += B(qy, dy) * G(qy, dy) * D1;
-               QD2[qx][dy] += G(qy, dy) * G(qy, dy) * D2;
-            }
-         }
+         return PAVectorDiffusionApply2D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D,sdim);
       }
-      for (int dy = 0; dy < D1D; ++dy)
-      {
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            double temp = 0.0;
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               temp += G(qx, dx) * G(qx, dx) * QD0[qx][dy];
-               temp += G(qx, dx) * B(qx, dx) * QD1[qx][dy];
-               temp += B(qx, dx) * G(qx, dx) * QD1[qx][dy];
-               temp += B(qx, dx) * B(qx, dx) * QD2[qx][dy];
-            }
-            Y(dx,dy,0,e) += temp;
-            Y(dx,dy,1,e) += temp;
-         }
-      }
-   });
-}
-
-template<int T_D1D = 0, int T_Q1D = 0>
-static void PAVectorDiffusionDiagonal3D(const int NE,
-                                        const Array<double> &b,
-                                        const Array<double> &g,
-                                        const Vector &d,
-                                        Vector &y,
-                                        const int d1d = 0,
-                                        const int q1d = 0)
-{
-   constexpr int DIM = 3;
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-   constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-   MFEM_VERIFY(D1D <= MD1, "");
-   MFEM_VERIFY(Q1D <= MQ1, "");
-   auto B = Reshape(b.Read(), Q1D, D1D);
-   auto G = Reshape(g.Read(), Q1D, D1D);
-   auto Q = Reshape(d.Read(), Q1D*Q1D*Q1D, 6, NE);
-   auto Y = Reshape(y.ReadWrite(), D1D, D1D, D1D, 3, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      constexpr int MD1 = T_D1D ? T_D1D : MAX_D1D;
-      constexpr int MQ1 = T_Q1D ? T_Q1D : MAX_Q1D;
-      double QQD[MQ1][MQ1][MD1];
-      double QDD[MQ1][MD1][MD1];
-      for (int i = 0; i < DIM; ++i)
+      if (dim == 3 && sdim == 3)
       {
-         for (int j = 0; j < DIM; ++j)
-         {
-            // first tensor contraction, along z direction
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  for (int dz = 0; dz < D1D; ++dz)
-                  {
-                     QQD[qx][qy][dz] = 0.0;
-                     for (int qz = 0; qz < Q1D; ++qz)
-                     {
-                        const int q = qx + (qy + qz * Q1D) * Q1D;
-                        const int k = j >= i ?
-                                      3 - (3-i)*(2-i)/2 + j:
-                                      3 - (3-j)*(2-j)/2 + i;
-                        const double O = Q(q,k,e);
-                        const double Bz = B(qz,dz);
-                        const double Gz = G(qz,dz);
-                        const double L = i==2 ? Gz : Bz;
-                        const double R = j==2 ? Gz : Bz;
-                        QQD[qx][qy][dz] += L * O * R;
-                     }
-                  }
-               }
-            }
-            // second tensor contraction, along y direction
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               for (int dz = 0; dz < D1D; ++dz)
-               {
-                  for (int dy = 0; dy < D1D; ++dy)
-                  {
-                     QDD[qx][dy][dz] = 0.0;
-                     for (int qy = 0; qy < Q1D; ++qy)
-                     {
-                        const double By = B(qy,dy);
-                        const double Gy = G(qy,dy);
-                        const double L = i==1 ? Gy : By;
-                        const double R = j==1 ? Gy : By;
-                        QDD[qx][dy][dz] += L * QQD[qx][qy][dz] * R;
-                     }
-                  }
-               }
-            }
-            // third tensor contraction, along x direction
-            for (int dz = 0; dz < D1D; ++dz)
-            {
-               for (int dy = 0; dy < D1D; ++dy)
-               {
-                  for (int dx = 0; dx < D1D; ++dx)
-                  {
-                     double temp = 0.0;
-                     for (int qx = 0; qx < Q1D; ++qx)
-                     {
-                        const double Bx = B(qx,dx);
-                        const double Gx = G(qx,dx);
-                        const double L = i==0 ? Gx : Bx;
-                        const double R = j==0 ? Gx : Bx;
-                        temp += L * QDD[qx][dy][dz] * R;
-                     }
-                     Y(dx, dy, dz, 0, e) += temp;
-                     Y(dx, dy, dz, 1, e) += temp;
-                     Y(dx, dy, dz, 2, e) += temp;
-                  }
-               }
-            }
-         }
+         return PAVectorDiffusionApply3D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D);
       }
-   });
-}
-
-static void PAVectorDiffusionAssembleDiagonal(const int dim,
-                                              const int D1D,
-                                              const int Q1D,
-                                              const int NE,
-                                              const Array<double> &B,
-                                              const Array<double> &G,
-                                              const Vector &op,
-                                              Vector &y)
-{
-   if (dim == 2)
-   {
-      return PAVectorDiffusionDiagonal2D(NE, B, G, op, y, D1D, Q1D);
-   }
-   else if (dim == 3)
-   {
-      return PAVectorDiffusionDiagonal3D(NE, B, G, op, y, D1D, Q1D);
-   }
-   MFEM_ABORT("Dimension not implemented.");
-}
-
-void VectorDiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
-{
-   if (DeviceCanUseCeed())
-   {
-      ceedOp->GetDiagonal(diag);
-   }
-   else
-   {
-      PAVectorDiffusionAssembleDiagonal(dim,
-                                        dofs1D,
-                                        quad1D,
-                                        ne,
-                                        maps->B,
-                                        maps->G,
-                                        pa_data,
-                                        diag);
+      MFEM_ABORT("Unknown kernel.");
    }
 }
 
diff --git a/fem/bilininteg_divergence.cpp b/fem/integ/bilininteg_vecdiv_pa.cpp
similarity index 94%
rename from fem/bilininteg_divergence.cpp
rename to fem/integ/bilininteg_vecdiv_pa.cpp
index c0102ff5e..63f7a3308 100644
--- a/fem/bilininteg_divergence.cpp
+++ b/fem/integ/bilininteg_vecdiv_pa.cpp
@@ -9,17 +9,13 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
 
 namespace mfem
 {
 
-// PA Divergence Integrator
-
 // PA Divergence Assemble 2D kernel
 static void PADivergenceSetup2D(const int Q1D,
                                 const int NE,
@@ -100,27 +96,6 @@ static void PADivergenceSetup3D(const int Q1D,
    });
 }
 
-static void PADivergenceSetup(const int dim,
-                              const int TR_D1D,
-                              const int TE_D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &W,
-                              const Vector &J,
-                              const double COEFF,
-                              Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PADivergenceSetup"); }
-   if (dim == 2)
-   {
-      PADivergenceSetup2D(Q1D, NE, W, J, COEFF, op);
-   }
-   if (dim == 3)
-   {
-      PADivergenceSetup3D(Q1D, NE, W, J, COEFF, op);
-   }
-}
-
 void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                             const FiniteElementSpace &test_fes)
 {
@@ -147,6 +122,7 @@ void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    MFEM_ASSERT(quad1D == test_maps->nqpt,
                "PA requires test and trial space to have same number of quadrature points!");
    pa_data.SetSize(nq * dimsToStore * ne, Device::GetMemoryType());
+
    double coeff = 1.0;
    if (Q)
    {
@@ -154,8 +130,19 @@ void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
       MFEM_VERIFY(cQ != NULL, "only ConstantCoefficient is supported!");
       coeff = cQ->constant;
    }
-   PADivergenceSetup(dim, trial_dofs1D, test_dofs1D, quad1D,
-                     ne, ir->GetWeights(), geom->J, coeff, pa_data);
+
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in VectorDivergenceIntegrator::AssemblePA");
+   }
+   else if (dim == 2)
+   {
+      PADivergenceSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PADivergenceSetup3D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
 }
 
 // PA Divergence Apply 2D kernel
@@ -1025,45 +1012,37 @@ static void SmemPADivergenceApply3D(const int NE,
    });
 }
 
-static void PADivergenceApply(const int dim,
-                              const int TR_D1D,
-                              const int TE_D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &B,
-                              const Array<double> &G,
-                              const Array<double> &Bt,
-                              const Vector &op,
-                              const Vector &x,
-                              Vector &y,
-                              bool transpose=false)
+void VectorDivergenceIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (dim == 2)
    {
-      return PADivergenceApply2D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
+      return PADivergenceApply2D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                                 pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    if (dim == 3)
    {
-      return PADivergenceApply3D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
+      return PADivergenceApply3D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                                 pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    MFEM_ABORT("Unknown kernel.");
 }
 
-// PA Divergence Apply kernel
-void VectorDivergenceIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   PADivergenceApply(dim, trial_dofs1D, test_dofs1D, quad1D, ne,
-                     trial_maps->B, trial_maps->G, test_maps->Bt, pa_data, x, y,
-                     false);
-}
-
-// PA Divergence Apply kernel
 void VectorDivergenceIntegrator::AddMultTransposePA(const Vector &x,
                                                     Vector &y) const
 {
-   PADivergenceApply(dim, trial_dofs1D, test_dofs1D, quad1D, ne,
-                     trial_maps->Bt, trial_maps->Gt, test_maps->B, pa_data, x, y,
-                     true);
+   if (dim == 2)
+   {
+      return PADivergenceApplyTranspose2D(ne, trial_maps->Bt, trial_maps->Gt,
+                                          test_maps->B, pa_data, x, y,
+                                          trial_dofs1D, test_dofs1D, quad1D);
+   }
+   if (dim == 3)
+   {
+      return PADivergenceApplyTranspose3D(ne, trial_maps->Bt, trial_maps->Gt,
+                                          test_maps->B, pa_data, x, y,
+                                          trial_dofs1D, test_dofs1D, quad1D);
+   }
+   MFEM_ABORT("Unknown kernel.");
 }
 
 } // namespace mfem
diff --git a/fem/bilininteg_vecmass_mf.cpp b/fem/integ/bilininteg_vecmass_mf.cpp
similarity index 90%
rename from fem/bilininteg_vecmass_mf.cpp
rename to fem/integ/bilininteg_vecmass_mf.cpp
index 2e8d74491..cc2eb0174 100644
--- a/fem/bilininteg_vecmass_mf.cpp
+++ b/fem/integ/bilininteg_vecmass_mf.cpp
@@ -9,19 +9,14 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "ceed/integrators/mass/mass.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/mass/mass.hpp"
 
 namespace mfem
 {
 
-// MF Mass Integrator
-
-// MF Mass Assemble kernel
 void VectorMassIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    // Assuming the same element type
diff --git a/fem/bilininteg_vecmass.cpp b/fem/integ/bilininteg_vecmass_pa.cpp
similarity index 88%
rename from fem/bilininteg_vecmass.cpp
rename to fem/integ/bilininteg_vecmass_pa.cpp
index 512cd42d5..b1c20b4c4 100644
--- a/fem/bilininteg_vecmass.cpp
+++ b/fem/integ/bilininteg_vecmass_pa.cpp
@@ -9,19 +9,14 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "bilininteg.hpp"
-#include "gridfunc.hpp"
-#include "ceed/integrators/mass/mass.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/mass/mass.hpp"
 
 namespace mfem
 {
 
-// PA Mass Integrator
-
-// PA Mass Assemble kernel
 void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    // Assuming the same element type
@@ -83,7 +78,7 @@ void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
             const double J21 = J(q,0,1,e);
             const double J22 = J(q,1,1,e);
             const double detJ = (J11*J22)-(J21*J12);
-            v(q,e) =  w[q] * constant * detJ;
+            v(q,e) = w[q] * constant * detJ;
          }
       });
    }
@@ -111,8 +106,159 @@ void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
-template<const int T_D1D = 0,
-         const int T_Q1D = 0>
+template<const int T_D1D = 0, const int T_Q1D = 0>
+static void PAVectorMassAssembleDiagonal2D(const int NE,
+                                           const Array<double> &B_,
+                                           const Array<double> &Bt_,
+                                           const Vector &op_,
+                                           Vector &diag_,
+                                           const int d1d = 0,
+                                           const int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int VDIM = 2;
+   MFEM_VERIFY(D1D <= MAX_D1D, "");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
+   auto B = Reshape(B_.Read(), Q1D, D1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, NE);
+   auto y = Reshape(diag_.ReadWrite(), D1D, D1D, VDIM, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int D1D = T_D1D ? T_D1D : d1d;
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      constexpr int max_D1D = T_D1D ? T_D1D : MAX_D1D;
+      constexpr int max_Q1D = T_Q1D ? T_Q1D : MAX_Q1D;
+
+      double temp[max_Q1D][max_D1D];
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            temp[qx][dy] = 0.0;
+            for (int qy = 0; qy < Q1D; ++qy)
+            {
+               temp[qx][dy] += B(qy, dy) * B(qy, dy) * op(qx, qy, e);
+            }
+         }
+      }
+      for (int dy = 0; dy < D1D; ++dy)
+      {
+         for (int dx = 0; dx < D1D; ++dx)
+         {
+            double temp1 = 0.0;
+            for (int qx = 0; qx < Q1D; ++qx)
+            {
+               temp1 += B(qx, dx) * B(qx, dx) * temp[qx][dy];
+            }
+            y(dx, dy, 0, e) = temp1;
+            y(dx, dy, 1, e) = temp1;
+         }
+      }
+   });
+}
+
+template<const int T_D1D = 0, const int T_Q1D = 0>
+static void PAVectorMassAssembleDiagonal3D(const int NE,
+                                           const Array<double> &B_,
+                                           const Array<double> &Bt_,
+                                           const Vector &op_,
+                                           Vector &diag_,
+                                           const int d1d = 0,
+                                           const int q1d = 0)
+{
+   const int D1D = T_D1D ? T_D1D : d1d;
+   const int Q1D = T_Q1D ? T_Q1D : q1d;
+   constexpr int VDIM = 3;
+   MFEM_VERIFY(D1D <= MAX_D1D, "");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
+   auto B = Reshape(B_.Read(), Q1D, D1D);
+   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, NE);
+   auto y = Reshape(diag_.ReadWrite(), D1D, D1D, D1D, VDIM, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      const int D1D = T_D1D ? T_D1D : d1d; // nvcc workaround
+      const int Q1D = T_Q1D ? T_Q1D : q1d;
+      // the following variables are evaluated at compile time
+      constexpr int max_D1D = T_D1D ? T_D1D : MAX_D1D;
+      constexpr int max_Q1D = T_Q1D ? T_Q1D : MAX_Q1D;
+
+      double temp[max_Q1D][max_Q1D][max_D1D];
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         for (int qy = 0; qy < Q1D; ++qy)
+         {
+            for (int dz = 0; dz < D1D; ++dz)
+            {
+               temp[qx][qy][dz] = 0.0;
+               for (int qz = 0; qz < Q1D; ++qz)
+               {
+                  temp[qx][qy][dz] += B(qz, dz) * B(qz, dz) * op(qx, qy, qz, e);
+               }
+            }
+         }
+      }
+      double temp2[max_Q1D][max_D1D][max_D1D];
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         for (int dz = 0; dz < D1D; ++dz)
+         {
+            for (int dy = 0; dy < D1D; ++dy)
+            {
+               temp2[qx][dy][dz] = 0.0;
+               for (int qy = 0; qy < Q1D; ++qy)
+               {
+                  temp2[qx][dy][dz] += B(qy, dy) * B(qy, dy) * temp[qx][qy][dz];
+               }
+            }
+         }
+      }
+      for (int dz = 0; dz < D1D; ++dz)
+      {
+         for (int dy = 0; dy < D1D; ++dy)
+         {
+            for (int dx = 0; dx < D1D; ++dx)
+            {
+               double temp3 = 0.0;
+               for (int qx = 0; qx < Q1D; ++qx)
+               {
+                  temp3 += B(qx, dx) * B(qx, dx)
+                           * temp2[qx][dy][dz];
+               }
+               y(dx, dy, dz, 0, e) = temp3;
+               y(dx, dy, dz, 1, e) = temp3;
+               y(dx, dy, dz, 2, e) = temp3;
+            }
+         }
+      }
+   });
+}
+
+void VectorMassIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
+   {
+      if (dim == 2)
+      {
+         return PAVectorMassAssembleDiagonal2D(ne, maps->B, maps->Bt,
+                                               pa_data, diag,
+                                               dofs1D, quad1D);
+      }
+      else if (dim == 3)
+      {
+         return PAVectorMassAssembleDiagonal3D(ne, maps->B, maps->Bt,
+                                               pa_data, diag,
+                                               dofs1D, quad1D);
+      }
+      MFEM_ABORT("Dimension not implemented.");
+   }
+}
+
+template<const int T_D1D = 0, const int T_Q1D = 0>
 static void PAVectorMassApply2D(const int NE,
                                 const Array<double> &B_,
                                 const Array<double> &Bt_,
@@ -208,8 +354,7 @@ static void PAVectorMassApply2D(const int NE,
    });
 }
 
-template<const int T_D1D = 0,
-         const int T_Q1D = 0>
+template<const int T_D1D = 0, const int T_Q1D = 0>
 static void PAVectorMassApply3D(const int NE,
                                 const Array<double> &B_,
                                 const Array<double> &Bt_,
@@ -354,27 +499,6 @@ static void PAVectorMassApply3D(const int NE,
    });
 }
 
-static void PAVectorMassApply(const int dim,
-                              const int D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &B,
-                              const Array<double> &Bt,
-                              const Vector &op,
-                              const Vector &x,
-                              Vector &y)
-{
-   if (dim == 2)
-   {
-      return PAVectorMassApply2D(NE, B, Bt, op, x, y, D1D, Q1D);
-   }
-   if (dim == 3)
-   {
-      return PAVectorMassApply3D(NE, B, Bt, op, x, y, D1D, Q1D);
-   }
-   MFEM_ABORT("Unknown kernel.");
-}
-
 void VectorMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
@@ -383,174 +507,17 @@ void VectorMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
    }
    else
    {
-      PAVectorMassApply(dim, dofs1D, quad1D, ne, maps->B, maps->Bt, pa_data, x, y);
-   }
-}
-
-template<const int T_D1D = 0, const int T_Q1D = 0>
-static void PAVectorMassAssembleDiagonal2D(const int NE,
-                                           const Array<double> &B_,
-                                           const Array<double> &Bt_,
-                                           const Vector &op_,
-                                           Vector &diag_,
-                                           const int d1d = 0,
-                                           const int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int VDIM = 2;
-   MFEM_VERIFY(D1D <= MAX_D1D, "");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
-   auto B = Reshape(B_.Read(), Q1D, D1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, NE);
-   auto y = Reshape(diag_.ReadWrite(), D1D, D1D, VDIM, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int D1D = T_D1D ? T_D1D : d1d;
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      constexpr int max_D1D = T_D1D ? T_D1D : MAX_D1D;
-      constexpr int max_Q1D = T_Q1D ? T_Q1D : MAX_Q1D;
-
-      double temp[max_Q1D][max_D1D];
-      for (int qx = 0; qx < Q1D; ++qx)
+      if (dim == 2)
       {
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            temp[qx][dy] = 0.0;
-            for (int qy = 0; qy < Q1D; ++qy)
-            {
-               temp[qx][dy] += B(qy, dy) * B(qy, dy) * op(qx, qy, e);
-            }
-         }
+         return PAVectorMassApply2D(ne, maps->B, maps->Bt, pa_data, x, y,
+                                    dofs1D, quad1D);
       }
-      for (int dy = 0; dy < D1D; ++dy)
+      if (dim == 3)
       {
-         for (int dx = 0; dx < D1D; ++dx)
-         {
-            double temp1 = 0.0;
-            for (int qx = 0; qx < Q1D; ++qx)
-            {
-               temp1 += B(qx, dx) * B(qx, dx) * temp[qx][dy];
-            }
-            y(dx, dy, 0, e) = temp1;
-            y(dx, dy, 1, e) = temp1;
-         }
+         return PAVectorMassApply3D(ne, maps->B, maps->Bt, pa_data, x, y,
+                                    dofs1D, quad1D);
       }
-   });
-}
-
-template<const int T_D1D = 0, const int T_Q1D = 0>
-static void PAVectorMassAssembleDiagonal3D(const int NE,
-                                           const Array<double> &B_,
-                                           const Array<double> &Bt_,
-                                           const Vector &op_,
-                                           Vector &diag_,
-                                           const int d1d = 0,
-                                           const int q1d = 0)
-{
-   const int D1D = T_D1D ? T_D1D : d1d;
-   const int Q1D = T_Q1D ? T_Q1D : q1d;
-   constexpr int VDIM = 3;
-   MFEM_VERIFY(D1D <= MAX_D1D, "");
-   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
-   auto B = Reshape(B_.Read(), Q1D, D1D);
-   auto op = Reshape(op_.Read(), Q1D, Q1D, Q1D, NE);
-   auto y = Reshape(diag_.ReadWrite(), D1D, D1D, D1D, VDIM, NE);
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      const int D1D = T_D1D ? T_D1D : d1d; // nvcc workaround
-      const int Q1D = T_Q1D ? T_Q1D : q1d;
-      // the following variables are evaluated at compile time
-      constexpr int max_D1D = T_D1D ? T_D1D : MAX_D1D;
-      constexpr int max_Q1D = T_Q1D ? T_Q1D : MAX_Q1D;
-
-      double temp[max_Q1D][max_Q1D][max_D1D];
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         for (int qy = 0; qy < Q1D; ++qy)
-         {
-            for (int dz = 0; dz < D1D; ++dz)
-            {
-               temp[qx][qy][dz] = 0.0;
-               for (int qz = 0; qz < Q1D; ++qz)
-               {
-                  temp[qx][qy][dz] += B(qz, dz) * B(qz, dz) * op(qx, qy, qz, e);
-               }
-            }
-         }
-      }
-      double temp2[max_Q1D][max_D1D][max_D1D];
-      for (int qx = 0; qx < Q1D; ++qx)
-      {
-         for (int dz = 0; dz < D1D; ++dz)
-         {
-            for (int dy = 0; dy < D1D; ++dy)
-            {
-               temp2[qx][dy][dz] = 0.0;
-               for (int qy = 0; qy < Q1D; ++qy)
-               {
-                  temp2[qx][dy][dz] += B(qy, dy) * B(qy, dy) * temp[qx][qy][dz];
-               }
-            }
-         }
-      }
-      for (int dz = 0; dz < D1D; ++dz)
-      {
-         for (int dy = 0; dy < D1D; ++dy)
-         {
-            for (int dx = 0; dx < D1D; ++dx)
-            {
-               double temp3 = 0.0;
-               for (int qx = 0; qx < Q1D; ++qx)
-               {
-                  temp3 += B(qx, dx) * B(qx, dx)
-                           * temp2[qx][dy][dz];
-               }
-               y(dx, dy, dz, 0, e) = temp3;
-               y(dx, dy, dz, 1, e) = temp3;
-               y(dx, dy, dz, 2, e) = temp3;
-            }
-         }
-      }
-   });
-}
-
-static void PAVectorMassAssembleDiagonal(const int dim,
-                                         const int D1D,
-                                         const int Q1D,
-                                         const int NE,
-                                         const Array<double> &B,
-                                         const Array<double> &Bt,
-                                         const Vector &op,
-                                         Vector &y)
-{
-   if (dim == 2)
-   {
-      return PAVectorMassAssembleDiagonal2D(NE, B, Bt, op, y, D1D, Q1D);
-   }
-   else if (dim == 3)
-   {
-      return PAVectorMassAssembleDiagonal3D(NE, B, Bt, op, y, D1D, Q1D);
-   }
-   MFEM_ABORT("Dimension not implemented.");
-}
-
-void VectorMassIntegrator::AssembleDiagonalPA(Vector &diag)
-{
-   if (DeviceCanUseCeed())
-   {
-      ceedOp->GetDiagonal(diag);
-   }
-   else
-   {
-      PAVectorMassAssembleDiagonal(dim,
-                                   dofs1D,
-                                   quad1D,
-                                   ne,
-                                   maps->B,
-                                   maps->Bt,
-                                   pa_data,
-                                   diag);
+      MFEM_ABORT("Unknown kernel.");
    }
 }
 
diff --git a/fem/integ/bilininteg_vectorfediv_pa.cpp b/fem/integ/bilininteg_vectorfediv_pa.cpp
new file mode 100644
index 000000000..2915a253b
--- /dev/null
+++ b/fem/integ/bilininteg_vectorfediv_pa.cpp
@@ -0,0 +1,157 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license.  We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "bilininteg_hdiv_kernels.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void
+VectorFEDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                         const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements, with a vector test space and
+   // scalar trial space.
+   Mesh *mesh = trial_fes.GetMesh();
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const VectorTensorFiniteElement *trial_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const NodalTensorFiniteElement *test_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const IntegrationRule *ir = IntRule ? IntRule : &MassIntegrator::GetRule(
+                                  *trial_el, *trial_el,
+                                  *mesh->GetElementTransformation(0));
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder() + 1, "");
+
+   ne = trial_fes.GetNE();
+   mapsC = &trial_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   L2mapsO = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   L2dofs1D = L2mapsO->ndof;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+   if (dim == 2)
+   {
+      MFEM_VERIFY(nq == quad1D * quad1D, "");
+   }
+   else
+   {
+      MFEM_VERIFY(nq == quad1D * quad1D * quad1D, "");
+   }
+
+   pa_data.SetSize(nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
+
+   if (test_el->GetMapType() == FiniteElement::INTEGRAL)
+   {
+      const GeometricFactors *geom =
+         mesh->GetGeometricFactors(*ir, GeometricFactors::DETERMINANTS);
+      coeff /= geom->detJ;
+   }
+
+   if (trial_el->GetDerivType() == mfem::FiniteElement::DIV && dim == 3)
+   {
+      internal::PAHdivL2Setup3D(quad1D, ne, ir->GetWeights(), coeff, pa_data);
+   }
+   else if (trial_el->GetDerivType() == mfem::FiniteElement::DIV && dim == 2)
+   {
+      internal::PAHdivL2Setup2D(quad1D, ne, ir->GetWeights(), coeff, pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
+void VectorFEDivergenceIntegrator::AssembleDiagonalPA_ADAt(const Vector &D,
+                                                           Vector &diag)
+{
+   if (dim == 3)
+   {
+      internal::PAHdivL2AssembleDiagonal_ADAt_3D(dofs1D, quad1D, L2dofs1D, ne,
+                                                 L2mapsO->B,
+                                                 mapsC->Gt, mapsO->Bt, pa_data, D, diag);
+   }
+   else if (dim == 2)
+   {
+      internal::PAHdivL2AssembleDiagonal_ADAt_2D(dofs1D, quad1D, L2dofs1D, ne,
+                                                 L2mapsO->B,
+                                                 mapsC->Gt, mapsO->Bt, pa_data, D, diag);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+void VectorFEDivergenceIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (dim == 3)
+   {
+      internal::PAHdivL2Apply3D(dofs1D, quad1D, L2dofs1D, ne, mapsO->B, mapsC->G,
+                                L2mapsO->Bt, pa_data, x, y);
+   }
+   else if (dim == 2)
+   {
+      internal::PAHdivL2Apply2D(dofs1D, quad1D, L2dofs1D, ne, mapsO->B, mapsC->G,
+                                L2mapsO->Bt, pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+void VectorFEDivergenceIntegrator::AddMultTransposePA(const Vector &x,
+                                                      Vector &y) const
+{
+   if (dim == 3)
+   {
+      internal::PAHdivL2ApplyTranspose3D(dofs1D, quad1D, L2dofs1D, ne, L2mapsO->B,
+                                         mapsC->Gt, mapsO->Bt, pa_data, x, y);
+   }
+   else if (dim == 2)
+   {
+      internal::PAHdivL2ApplyTranspose2D(dofs1D, quad1D, L2dofs1D, ne, L2mapsO->B,
+                                         mapsC->Gt, mapsO->Bt, pa_data, x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported dimension!");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_vectorfemass_pa.cpp b/fem/integ/bilininteg_vectorfemass_pa.cpp
new file mode 100644
index 000000000..c07e9f816
--- /dev/null
+++ b/fem/integ/bilininteg_vectorfemass_pa.cpp
@@ -0,0 +1,346 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "bilininteg_diffusion_kernels.hpp"
+#include "bilininteg_hcurl_kernels.hpp"
+#include "bilininteg_hdiv_kernels.hpp"
+#include "bilininteg_hcurlhdiv_kernels.hpp"
+
+namespace mfem
+{
+
+void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                        const FiniteElementSpace &test_fes)
+{
+   // Assumes tensor-product elements
+   Mesh *mesh = trial_fes.GetMesh();
+
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const VectorTensorFiniteElement *trial_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const IntegrationRule *ir
+      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
+                                                     *mesh->GetElementTransformation(0));
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+   nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   ne = trial_fes.GetNE();
+   MFEM_VERIFY(ne == test_fes.GetNE(),
+               "Different meshes for test and trial spaces");
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &trial_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   mapsCtest = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsOtest = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1Dtest = mapsCtest->ndof;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   trial_fetype = trial_el->GetDerivType();
+   test_fetype = test_el->GetDerivType();
+
+   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
+   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
+   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
+   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(qs, CoefficientStorage::SYMMETRIC);
+   if (Q) { coeff.Project(*Q); }
+   else if (MQ) { coeff.ProjectTranspose(*MQ); }
+   else if (DQ) { coeff.Project(*DQ); }
+   else { coeff.SetConstant(1.0); }
+
+   const int coeff_dim = coeff.GetVDim();
+   symmetric = (coeff_dim != dim*dim);
+
+   if ((trial_curl && test_div) || (trial_div && test_curl))
+   {
+      pa_data.SetSize((coeff_dim == 1 ? 1 : dim*dim) * nq * ne,
+                      Device::GetMemoryType());
+   }
+   else
+   {
+      pa_data.SetSize((symmetric ? symmDims : dims*dims) * nq * ne,
+                      Device::GetMemoryType());
+   }
+   if (trial_curl && test_curl && dim == 3)
+   {
+      internal::PADiffusionSetup3D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
+                                   coeff, pa_data);
+   }
+   else if (trial_curl && test_curl && dim == 2)
+   {
+      internal::PADiffusionSetup2D<2>(quad1D, coeff_dim, ne, ir->GetWeights(),
+                                      geom->J, coeff, pa_data);
+   }
+   else if (trial_div && test_div && dim == 3)
+   {
+      internal::PAHdivMassSetup3D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
+                                  coeff, pa_data);
+   }
+   else if (trial_div && test_div && dim == 2)
+   {
+      internal::PAHdivMassSetup2D(quad1D, coeff_dim, ne, ir->GetWeights(), geom->J,
+                                  coeff, pa_data);
+   }
+   else if (((trial_curl && test_div) || (trial_div && test_curl)) &&
+            test_fel->GetOrder() == trial_fel->GetOrder())
+   {
+      if (coeff_dim == 1)
+      {
+         internal::PAHcurlL2Setup3D(nq, coeff_dim, ne, ir->GetWeights(), coeff, pa_data);
+      }
+      else
+      {
+         const bool tr = (trial_div && test_curl);
+         if (dim == 3)
+         {
+            internal::PAHcurlHdivMassSetup3D(quad1D, coeff_dim, ne, tr, ir->GetWeights(),
+                                             geom->J, coeff, pa_data);
+         }
+         else
+         {
+            internal::PAHcurlHdivMassSetup2D(quad1D, coeff_dim, ne, tr, ir->GetWeights(),
+                                             geom->J, coeff, pa_data);
+         }
+      }
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
+void VectorFEMassIntegrator::AssembleDiagonalPA(Vector& diag)
+{
+   if (dim == 3)
+   {
+      if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
+      {
+         if (Device::Allows(Backend::DEVICE_MASK))
+         {
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPAHcurlMassAssembleDiagonal3D<2,3>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, pa_data, diag);
+               case 0x34:
+                  return internal::SmemPAHcurlMassAssembleDiagonal3D<3,4>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, pa_data, diag);
+               case 0x45:
+                  return internal::SmemPAHcurlMassAssembleDiagonal3D<4,5>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, pa_data, diag);
+               case 0x56:
+                  return internal::SmemPAHcurlMassAssembleDiagonal3D<5,6>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, pa_data, diag);
+               default:
+                  return internal::SmemPAHcurlMassAssembleDiagonal3D(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, pa_data, diag);
+            }
+         }
+         else
+         {
+            internal::PAHcurlMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
+                                                    mapsO->B, mapsC->B, pa_data, diag);
+         }
+      }
+      else if (trial_fetype == mfem::FiniteElement::DIV &&
+               test_fetype == trial_fetype)
+      {
+         internal::PAHdivMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
+                                                mapsO->B, mapsC->B, pa_data, diag);
+      }
+      else
+      {
+         MFEM_ABORT("Unknown kernel.");
+      }
+   }
+   else // 2D
+   {
+      if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
+      {
+         internal::PAHcurlMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
+                                                 mapsO->B, mapsC->B, pa_data, diag);
+      }
+      else if (trial_fetype == mfem::FiniteElement::DIV &&
+               test_fetype == trial_fetype)
+      {
+         internal::PAHdivMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
+                                                mapsO->B, mapsC->B, pa_data, diag);
+      }
+      else
+      {
+         MFEM_ABORT("Unknown kernel.");
+      }
+   }
+}
+
+void VectorFEMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
+   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
+   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
+   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
+
+   if (dim == 3)
+   {
+      if (trial_curl && test_curl)
+      {
+         if (Device::Allows(Backend::DEVICE_MASK))
+         {
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPAHcurlMassApply3D<2,3>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, mapsO->Bt,
+                            mapsC->Bt, pa_data, x, y);
+               case 0x34:
+                  return internal::SmemPAHcurlMassApply3D<3,4>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, mapsO->Bt,
+                            mapsC->Bt, pa_data, x, y);
+               case 0x45:
+                  return internal::SmemPAHcurlMassApply3D<4,5>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, mapsO->Bt,
+                            mapsC->Bt, pa_data, x, y);
+               case 0x56:
+                  return internal::SmemPAHcurlMassApply3D<5,6>(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, mapsO->Bt,
+                            mapsC->Bt, pa_data, x, y);
+               default:
+                  return internal::SmemPAHcurlMassApply3D(
+                            dofs1D, quad1D, ne, symmetric,
+                            mapsO->B, mapsC->B, mapsO->Bt,
+                            mapsC->Bt, pa_data, x, y);
+            }
+         }
+         else
+         {
+            internal::PAHcurlMassApply3D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                         mapsO->Bt, mapsC->Bt, pa_data, x, y);
+         }
+      }
+      else if (trial_div && test_div)
+      {
+         internal::PAHdivMassApply(3, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                   mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      }
+      else if (trial_curl && test_div)
+      {
+         const bool scalarCoeff = !(DQ || MQ);
+         internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                          true, false, mapsO->B, mapsC->B, mapsOtest->Bt,
+                                          mapsCtest->Bt, pa_data, x, y);
+      }
+      else if (trial_div && test_curl)
+      {
+         const bool scalarCoeff = !(DQ || MQ);
+         internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                          false, false, mapsO->B, mapsC->B, mapsOtest->Bt,
+                                          mapsCtest->Bt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unknown kernel.");
+      }
+   }
+   else // 2D
+   {
+      if (trial_curl && test_curl)
+      {
+         internal::PAHcurlMassApply2D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                      mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      }
+      else if (trial_div && test_div)
+      {
+         internal::PAHdivMassApply(2, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                   mapsO->Bt,
+                                   mapsC->Bt, pa_data, x, y);
+      }
+      else if ((trial_curl && test_div) || (trial_div && test_curl))
+      {
+         const bool scalarCoeff = !(DQ || MQ);
+         internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                          trial_curl, false, mapsO->B, mapsC->B,
+                                          mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unknown kernel.");
+      }
+   }
+}
+
+void VectorFEMassIntegrator::AddMultTransposePA(const Vector &x,
+                                                Vector &y) const
+{
+   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
+   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
+   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
+   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
+
+   bool symmetricSpaces = true;
+   if (dim == 3 && ((trial_div && test_curl) || (trial_curl && test_div)))
+   {
+      const bool scalarCoeff = !(DQ || MQ);
+      internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                       trial_div, true, mapsO->B, mapsC->B,
+                                       mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+      symmetricSpaces = false;
+   }
+   else if (dim == 2 && ((trial_curl && test_div) || (trial_div && test_curl)))
+   {
+      const bool scalarCoeff = !(DQ || MQ);
+      internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                       !trial_curl, true, mapsO->B, mapsC->B,
+                                       mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+      symmetricSpaces = false;
+   }
+   if (symmetricSpaces)
+   {
+      if (MQ && dynamic_cast<SymmetricMatrixCoefficient*>(MQ) == NULL)
+      {
+         MFEM_ABORT("VectorFEMassIntegrator transpose not implemented for asymmetric MatrixCoefficient");
+      }
+      AddMultPA(x, y);
+   }
+}
+
+} // namespace mfem
diff --git a/fem/lininteg_boundary.cpp b/fem/integ/lininteg_boundary.cpp
similarity index 89%
rename from fem/lininteg_boundary.cpp
rename to fem/integ/lininteg_boundary.cpp
index 68e54dd1b..9b785335c 100644
--- a/fem/lininteg_boundary.cpp
+++ b/fem/integ/lininteg_boundary.cpp
@@ -9,18 +9,19 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "fem.hpp"
-#include "../fem/kernels.hpp"
-#include "../general/forall.hpp"
+#include "../../general/forall.hpp"
+#include "../../fem/kernels.hpp"
+#include "../fem.hpp"
 
 namespace mfem
 {
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void BLFEvalAssemble2D(const int vdim, const int nbe, const int d, const int q,
-                       const bool normals, const int *markers, const double *b,
-                       const double *detj, const double *n, const double *weights,
-                       const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void BLFEvalAssemble2D(const int vdim, const int nbe, const int d,
+                              const int q,
+                              const bool normals, const int *markers, const double *b,
+                              const double *detj, const double *n, const double *weights,
+                              const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, nbe);
@@ -69,11 +70,12 @@ void BLFEvalAssemble2D(const int vdim, const int nbe, const int d, const int q,
    });
 }
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void BLFEvalAssemble3D(const int vdim, const int nbe, const int d, const int q,
-                       const bool normals, const int *markers, const double *b,
-                       const double *detj, const double *n, const double *weights,
-                       const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void BLFEvalAssemble3D(const int vdim, const int nbe, const int d,
+                              const int q,
+                              const bool normals, const int *markers, const double *b,
+                              const double *detj, const double *n, const double *weights,
+                              const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, nbe);
diff --git a/fem/lininteg_boundary_flux.cpp b/fem/integ/lininteg_boundary_flux.cpp
similarity index 89%
rename from fem/lininteg_boundary_flux.cpp
rename to fem/integ/lininteg_boundary_flux.cpp
index 411ba0314..b9f047817 100644
--- a/fem/lininteg_boundary_flux.cpp
+++ b/fem/integ/lininteg_boundary_flux.cpp
@@ -9,17 +9,17 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "fem.hpp"
-#include "../fem/kernels.hpp"
-#include "../general/forall.hpp"
+#include "../../general/forall.hpp"
+#include "../../fem/kernels.hpp"
+#include "../fem.hpp"
 
 namespace mfem
 {
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void BFLFEvalAssemble2D(const int nbe, const int d, const int q,
-                        const int *markers, const double *b,
-                        const double *weights, const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void BFLFEvalAssemble2D(const int nbe, const int d, const int q,
+                               const int *markers, const double *b,
+                               const double *weights, const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, nbe);
@@ -50,10 +50,10 @@ void BFLFEvalAssemble2D(const int nbe, const int d, const int q,
    });
 }
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void BFLFEvalAssemble3D(const int nbe, const int d, const int q,
-                        const int *markers, const double *b,
-                        const double *weights, const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void BFLFEvalAssemble3D(const int nbe, const int d, const int q,
+                               const int *markers, const double *b,
+                               const double *weights, const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, nbe);
diff --git a/fem/lininteg_domain.cpp b/fem/integ/lininteg_domain.cpp
similarity index 91%
rename from fem/lininteg_domain.cpp
rename to fem/integ/lininteg_domain.cpp
index 6fa0ec82b..6ff7b090d 100644
--- a/fem/lininteg_domain.cpp
+++ b/fem/integ/lininteg_domain.cpp
@@ -9,18 +9,19 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "fem.hpp"
-#include "../fem/kernels.hpp"
-#include "../general/forall.hpp"
+#include "../../general/forall.hpp"
+#include "../../fem/kernels.hpp"
+#include "../fem.hpp"
 
 namespace mfem
 {
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void DLFEvalAssemble2D(const int vdim, const int ne, const int d, const int q,
-                       const int map_type, const int *markers, const double *b,
-                       const double *detj, const double *weights,
-                       const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void DLFEvalAssemble2D(const int vdim, const int ne, const int d,
+                              const int q,
+                              const int map_type, const int *markers, const double *b,
+                              const double *detj, const double *weights,
+                              const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, ne);
@@ -85,11 +86,12 @@ void DLFEvalAssemble2D(const int vdim, const int ne, const int d, const int q,
    });
 }
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void DLFEvalAssemble3D(const int vdim, const int ne, const int d, const int q,
-                       const int map_type, const int *markers, const double *b,
-                       const double *detj, const double *weights,
-                       const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void DLFEvalAssemble3D(const int vdim, const int ne, const int d,
+                              const int q,
+                              const int map_type, const int *markers, const double *b,
+                              const double *detj, const double *weights,
+                              const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, ne);
diff --git a/fem/lininteg_domain_grad.cpp b/fem/integ/lininteg_domain_grad.cpp
similarity index 93%
rename from fem/lininteg_domain_grad.cpp
rename to fem/integ/lininteg_domain_grad.cpp
index 16131e11c..5cca01a1d 100644
--- a/fem/lininteg_domain_grad.cpp
+++ b/fem/integ/lininteg_domain_grad.cpp
@@ -9,18 +9,19 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "fem.hpp"
-#include "../fem/kernels.hpp"
-#include "../general/forall.hpp"
+#include "../../general/forall.hpp"
+#include "../../fem/kernels.hpp"
+#include "../fem.hpp"
 
 namespace mfem
 {
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void DLFGradAssemble2D(const int vdim, const int ne, const int d, const int q,
-                       const int *markers, const double *b, const double *g,
-                       const double *jacobians,
-                       const double *weights, const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void DLFGradAssemble2D(const int vdim, const int ne, const int d,
+                              const int q,
+                              const int *markers, const double *b, const double *g,
+                              const double *jacobians,
+                              const double *weights, const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, ne);
@@ -108,12 +109,13 @@ void DLFGradAssemble2D(const int vdim, const int ne, const int d, const int q,
    });
 }
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void DLFGradAssemble3D(const int vdim, const int ne, const int d, const int q,
-                       const int *markers, const double *b, const double *g,
-                       const double *jacobians,
-                       const double *weights, const Vector &coeff,
-                       double *output)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void DLFGradAssemble3D(const int vdim, const int ne, const int d,
+                              const int q,
+                              const int *markers, const double *b, const double *g,
+                              const double *jacobians,
+                              const double *weights, const Vector &coeff,
+                              double *output)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, ne);
diff --git a/fem/lininteg_vectorfe_domain.cpp b/fem/integ/lininteg_domain_vectorfe.cpp
similarity index 99%
rename from fem/lininteg_vectorfe_domain.cpp
rename to fem/integ/lininteg_domain_vectorfe.cpp
index 55a3dda7e..16d9e866c 100644
--- a/fem/lininteg_vectorfe_domain.cpp
+++ b/fem/integ/lininteg_domain_vectorfe.cpp
@@ -9,9 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "fem.hpp"
-#include "../fem/kernels.hpp"
-#include "../general/forall.hpp"
+#include "../../general/forall.hpp"
+#include "../../fem/kernels.hpp"
+#include "../fem.hpp"
 
 namespace mfem
 {
diff --git a/fem/nonlininteg_vectorconvection_mf.cpp b/fem/integ/nonlininteg_vecconvection_mf.cpp
similarity index 92%
rename from fem/nonlininteg_vectorconvection_mf.cpp
rename to fem/integ/nonlininteg_vecconvection_mf.cpp
index c29f4e920..4005d6836 100644
--- a/fem/nonlininteg_vectorconvection_mf.cpp
+++ b/fem/integ/nonlininteg_vecconvection_mf.cpp
@@ -9,14 +9,13 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "nonlininteg.hpp"
-#include "ceed/integrators/nlconvection/nlconvection.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../nonlininteg.hpp"
+#include "../ceed/integrators/nlconvection/nlconvection.hpp"
 
 namespace mfem
 {
+
 void VectorConvectionNLFIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    MFEM_ASSERT(fes.GetOrdering() == Ordering::byNODES,
diff --git a/fem/nonlininteg_vectorconvection.cpp b/fem/integ/nonlininteg_vecconvection_pa.cpp
similarity index 99%
rename from fem/nonlininteg_vectorconvection.cpp
rename to fem/integ/nonlininteg_vecconvection_pa.cpp
index efa7a10a3..7bed31800 100644
--- a/fem/nonlininteg_vectorconvection.cpp
+++ b/fem/integ/nonlininteg_vecconvection_pa.cpp
@@ -9,14 +9,13 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../general/forall.hpp"
-#include "nonlininteg.hpp"
-#include "ceed/integrators/nlconvection/nlconvection.hpp"
-
-using namespace std;
+#include "../../general/forall.hpp"
+#include "../nonlininteg.hpp"
+#include "../ceed/integrators/nlconvection/nlconvection.hpp"
 
 namespace mfem
 {
+
 void VectorConvectionNLFIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    MFEM_ASSERT(fes.GetOrdering() == Ordering::byNODES,
diff --git a/fem/intrules.cpp b/fem/intrules.cpp
index 67ab66320..1494043d6 100644
--- a/fem/intrules.cpp
+++ b/fem/intrules.cpp
@@ -946,22 +946,14 @@ const IntegrationRule &IntegrationRules::Get(int GeomType, int Order)
 
    if (!HaveIntRule(*ir_array, Order))
    {
-#ifdef MFEM_USE_LEGACY_OPENMP
-      #pragma omp critical
-#endif
+      IntegrationRule *ir = GenerateIntegrationRule(GeomType, Order);
+      int RealOrder = Order;
+      while (RealOrder+1 < ir_array->Size() &&
+             (*ir_array)[RealOrder+1] == ir)
       {
-         if (!HaveIntRule(*ir_array, Order))
-         {
-            IntegrationRule *ir = GenerateIntegrationRule(GeomType, Order);
-            int RealOrder = Order;
-            while (RealOrder+1 < ir_array->Size() &&
-                   (*ir_array)[RealOrder+1] == ir)
-            {
-               RealOrder++;
-            }
-            ir->SetOrder(RealOrder);
-         }
+         RealOrder++;
       }
+      ir->SetOrder(RealOrder);
    }
 
    return *(*ir_array)[Order];
diff --git a/fem/linearform.hpp b/fem/linearform.hpp
index c24118426..29f816db1 100644
--- a/fem/linearform.hpp
+++ b/fem/linearform.hpp
@@ -121,10 +121,6 @@ public:
    LinearForm &operator=(const LinearForm &rhs)
    { return operator=((const Vector &)rhs); }
 
-   /// (DEPRECATED) Return the FE space associated with the LinearForm.
-   /** @deprecated Use FESpace() instead. */
-   MFEM_DEPRECATED FiniteElementSpace *GetFES() { return fes; }
-
    /// Read+write access to the associated FiniteElementSpace.
    FiniteElementSpace *FESpace() { return fes; }
    /// Read-only access to the associated FiniteElementSpace.
diff --git a/fem/linearform_ext.cpp b/fem/linearform_ext.cpp
index f70a7b6e3..3475574fd 100644
--- a/fem/linearform_ext.cpp
+++ b/fem/linearform_ext.cpp
@@ -164,10 +164,8 @@ void LinearFormExtension::Update()
          }
       }
 
-      bdr_restrict_lex =
-         dynamic_cast<const FaceRestriction*>(
-            fes.GetFaceRestriction(ordering, FaceType::Boundary,
-                                   L2FaceValues::SingleValued));
+      bdr_restrict_lex = fes.GetFaceRestriction(ordering, FaceType::Boundary,
+                                                L2FaceValues::SingleValued);
       MFEM_VERIFY(bdr_restrict_lex, "Face restriction not available");
       bdr_b.SetSize(bdr_restrict_lex->Height(), Device::GetMemoryType());
       bdr_b.UseDevice(true);
diff --git a/fem/linearform_ext.hpp b/fem/linearform_ext.hpp
index 2cc861cea..46acf637d 100644
--- a/fem/linearform_ext.hpp
+++ b/fem/linearform_ext.hpp
@@ -34,7 +34,7 @@ class LinearFormExtension
    LinearForm *lf;
 
    /// Operator that converts FiniteElementSpace L-vectors to E-vectors.
-   const ElementRestrictionOperator *elem_restrict_lex; // Not owned
+   const ElementRestriction *elem_restrict_lex; // Not owned
 
    /// Operator that converts L-vectors to boundary E-vectors.
    const FaceRestriction *bdr_restrict_lex; // Not owned
diff --git a/fem/lininteg.cpp b/fem/lininteg.cpp
index 52abc3cad..c9b6b4699 100644
--- a/fem/lininteg.cpp
+++ b/fem/lininteg.cpp
@@ -9,7 +9,6 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-
 #include "fem.hpp"
 #include <cmath>
 
diff --git a/fem/lor/lor_ads.cpp b/fem/lor/lor_ads.cpp
index 3ba4816ee..f962f8469 100644
--- a/fem/lor/lor_ads.cpp
+++ b/fem/lor/lor_ads.cpp
@@ -103,9 +103,9 @@ void BatchedLOR_ADS::FormCurlMatrix()
    Form3DFaceToEdge(face2edge);
 
    ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
-   const auto *R_f = dynamic_cast<const ElementRestriction*>(
+   const auto *R_f = dynamic_cast<const ConformingElementRestriction*>(
                         face_fes.GetElementRestriction(ordering));
-   const auto *R_e = dynamic_cast<const ElementRestriction*>(
+   const auto *R_e = dynamic_cast<const ConformingElementRestriction*>(
                         edge_fes.GetElementRestriction(ordering));
    MFEM_VERIFY(R_f != NULL && R_e != NULL, "");
 
diff --git a/fem/lor/lor_ams.cpp b/fem/lor/lor_ams.cpp
index 1c37f165b..0d7ac222f 100644
--- a/fem/lor/lor_ams.cpp
+++ b/fem/lor/lor_ams.cpp
@@ -163,9 +163,9 @@ void BatchedLOR_AMS::FormGradientMatrix()
    else { Form3DEdgeToVertex(edge2vertex); }
 
    ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
-   const auto *R_v = dynamic_cast<const ElementRestriction*>(
+   const auto *R_v = dynamic_cast<const ConformingElementRestriction*>(
                         vert_fes.GetElementRestriction(ordering));
-   const auto *R_e = dynamic_cast<const ElementRestriction*>(
+   const auto *R_e = dynamic_cast<const ConformingElementRestriction*>(
                         edge_fes.GetElementRestriction(ordering));
    MFEM_VERIFY(R_v != NULL && R_e != NULL, "");
 
@@ -268,7 +268,7 @@ void BatchedLOR_AMS::FormCoordinateVectors(const Vector &X_vert)
    // Create the H1 vertex space and get the element restriction
    ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
    const Operator *op = vert_fes.GetElementRestriction(ordering);
-   const auto *el_restr = dynamic_cast<const ElementRestriction*>(op);
+   const auto *el_restr = dynamic_cast<const ConformingElementRestriction*>(op);
    MFEM_VERIFY(el_restr != NULL, "");
    const SparseMatrix *R = vert_fes.GetRestrictionMatrix();
 
diff --git a/fem/lor/lor_batched.cpp b/fem/lor/lor_batched.cpp
index fe0494880..0050c3de5 100644
--- a/fem/lor/lor_batched.cpp
+++ b/fem/lor/lor_batched.cpp
@@ -145,8 +145,8 @@ int BatchedLORAssembly::FillI(SparseMatrix &A) const
 
    const ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
    const Operator *op = fes_ho.GetElementRestriction(ordering);
-   const ElementRestriction *el_restr =
-      dynamic_cast<const ElementRestriction*>(op);
+   const auto *el_restr =
+      dynamic_cast<const ConformingElementRestriction*>(op);
    MFEM_VERIFY(el_restr != nullptr, "Bad element restriction");
 
    const Array<int> &el_dof_lex_ = el_restr->GatherMap();
@@ -235,8 +235,8 @@ void BatchedLORAssembly::FillJAndData(SparseMatrix &A) const
 
    const ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
    const Operator *op = fes_ho.GetElementRestriction(ordering);
-   const ElementRestriction *el_restr =
-      dynamic_cast<const ElementRestriction*>(op);
+   const auto *el_restr =
+      dynamic_cast<const ConformingElementRestriction*>(op);
    MFEM_VERIFY(el_restr != nullptr, "Bad element restriction");
 
    const Array<int> &el_dof_lex_ = el_restr->GatherMap();
diff --git a/fem/nonlinearform.hpp b/fem/nonlinearform.hpp
index d15d09e04..60cae2055 100644
--- a/fem/nonlinearform.hpp
+++ b/fem/nonlinearform.hpp
@@ -330,7 +330,6 @@ public:
    virtual ~BlockNonlinearForm();
 };
 
-
 }
 
 #endif
diff --git a/fem/nonlininteg.cpp b/fem/nonlininteg.cpp
index e1558fda4..5ee1febea 100644
--- a/fem/nonlininteg.cpp
+++ b/fem/nonlininteg.cpp
@@ -15,68 +15,69 @@
 namespace mfem
 {
 
-double NonlinearFormIntegrator::GetLocalStateEnergyPA(const Vector &x) const
-{
-   mfem_error ("NonlinearFormIntegrator::GetLocalStateEnergyPA(...)\n"
-               "   is not implemented for this class.");
-   return 0.0;
-}
-
 void NonlinearFormIntegrator::AssemblePA(const FiniteElementSpace&)
 {
-   mfem_error ("NonlinearFormIntegrator::AssemblePA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssemblePA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssemblePA(const FiniteElementSpace &,
-                                         const FiniteElementSpace &)
+void NonlinearFormIntegrator::AssembleGradPA(const Vector &x,
+                                             const FiniteElementSpace &fes)
 {
-   mfem_error ("NonlinearFormIntegrator::AssemblePA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleGradPA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleGradPA(const Vector &x,
-                                             const FiniteElementSpace &fes)
+void NonlinearFormIntegrator::AssembleGradDiagonalPA(Vector &diag) const
 {
-   mfem_error ("NonlinearFormIntegrator::AssembleGradPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleGradDiagonalPA(...)\n"
+              "   is not implemented for this class.");
 }
 
 void NonlinearFormIntegrator::AddMultPA(const Vector &, Vector &) const
 {
-   mfem_error ("NonlinearFormIntegrator::AddMultPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AddMultPA(...)\n"
+              "   is not implemented for this class.");
 }
 
 void NonlinearFormIntegrator::AddMultGradPA(const Vector&, Vector&) const
 {
-   mfem_error ("NonlinearFormIntegrator::AddMultGradPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AddMultGradPA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleGradDiagonalPA(Vector &diag) const
+double NonlinearFormIntegrator::GetLocalStateEnergyPA(const Vector &x) const
 {
-   mfem_error ("NonlinearFormIntegrator::AssembleGradDiagonalPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::GetLocalStateEnergyPA(...)\n"
+              "   is not implemented for this class.");
+   return 0.0;
 }
 
 void NonlinearFormIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   mfem_error ("NonlinearFormIntegrator::AssembleMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleMF(...)\n"
+              "   is not implemented for this class.");
 }
 
 void NonlinearFormIntegrator::AddMultMF(const Vector &, Vector &) const
 {
-   mfem_error ("NonlinearFormIntegrator::AddMultMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AddMultMF(...)\n"
+              "   is not implemented for this class.");
+}
+
+double NonlinearFormIntegrator::GetElementEnergy(
+   const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun)
+{
+   MFEM_ABORT("NonlinearFormIntegrator::GetElementEnergy"
+              " is not overloaded!");
+   return 0.0;
 }
 
 void NonlinearFormIntegrator::AssembleElementVector(
    const FiniteElement &el, ElementTransformation &Tr,
    const Vector &elfun, Vector &elvect)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleElementVector"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementVector"
               " is not overloaded!");
 }
 
@@ -84,7 +85,7 @@ void NonlinearFormIntegrator::AssembleFaceVector(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Tr, const Vector &elfun, Vector &elvect)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleFaceVector"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceVector"
               " is not overloaded!");
 }
 
@@ -92,7 +93,7 @@ void NonlinearFormIntegrator::AssembleElementGrad(
    const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun,
    DenseMatrix &elmat)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleElementGrad"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementGrad"
               " is not overloaded!");
 }
 
@@ -101,18 +102,10 @@ void NonlinearFormIntegrator::AssembleFaceGrad(
    FaceElementTransformations &Tr, const Vector &elfun,
    DenseMatrix &elmat)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleFaceGrad"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceGrad"
               " is not overloaded!");
 }
 
-double NonlinearFormIntegrator::GetElementEnergy(
-   const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun)
-{
-   mfem_error("NonlinearFormIntegrator::GetElementEnergy"
-              " is not overloaded!");
-   return 0.0;
-}
-
 
 void BlockNonlinearFormIntegrator::AssembleElementVector(
    const Array<const FiniteElement *> &el,
@@ -120,7 +113,7 @@ void BlockNonlinearFormIntegrator::AssembleElementVector(
    const Array<const Vector *> &elfun,
    const Array<Vector *> &elvec)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleElementVector"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementVector"
               " is not overloaded!");
 }
 
@@ -131,7 +124,7 @@ void BlockNonlinearFormIntegrator::AssembleFaceVector(
    const Array<const Vector *> &elfun,
    const Array<Vector *> &elvect)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleFaceVector"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceVector"
               " is not overloaded!");
 }
 
@@ -141,7 +134,7 @@ void BlockNonlinearFormIntegrator::AssembleElementGrad(
    const Array<const Vector *> &elfun,
    const Array2D<DenseMatrix *> &elmats)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleElementGrad"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementGrad"
               " is not overloaded!");
 }
 
@@ -152,7 +145,7 @@ void BlockNonlinearFormIntegrator::AssembleFaceGrad(
    const Array<const Vector *> &elfun,
    const Array2D<DenseMatrix *> &elmats)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleFaceGrad"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceGrad"
               " is not overloaded!");
 }
 
@@ -161,7 +154,7 @@ double BlockNonlinearFormIntegrator::GetElementEnergy(
    ElementTransformation &Tr,
    const Array<const Vector *>&elfun)
 {
-   mfem_error("BlockNonlinearFormIntegrator::GetElementEnergy"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::GetElementEnergy"
               " is not overloaded!");
    return 0.0;
 }
@@ -497,6 +490,7 @@ void HyperelasticNLFIntegrator::AssembleElementGrad(const FiniteElement &el,
    }
 }
 
+
 double IncompressibleNeoHookeanIntegrator::GetElementEnergy(
    const Array<const FiniteElement *>&el,
    ElementTransformation &Tr,
@@ -504,7 +498,7 @@ double IncompressibleNeoHookeanIntegrator::GetElementEnergy(
 {
    if (el.Size() != 2)
    {
-      mfem_error("IncompressibleNeoHookeanIntegrator::GetElementEnergy"
+      MFEM_ABORT("IncompressibleNeoHookeanIntegrator::GetElementEnergy"
                  " has incorrect block finite element space size!");
    }
 
@@ -549,7 +543,7 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementVector(
 {
    if (el.Size() != 2)
    {
-      mfem_error("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
+      MFEM_ABORT("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
                  " has finite element space of incorrect block number");
    }
 
@@ -561,11 +555,10 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementVector(
 
    if (dim != spaceDim)
    {
-      mfem_error("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
+      MFEM_ABORT("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
                  " is not defined on manifold meshes");
    }
 
-
    DSh_u.SetSize(dof_u, dim);
    DS_u.SetSize(dof_u, dim);
    J0i.SetSize(dim);
@@ -731,6 +724,7 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementGrad(
 
 }
 
+
 const IntegrationRule&
 VectorConvectionNLFIntegrator::GetRule(const FiniteElement &fe,
                                        ElementTransformation &T)
diff --git a/fem/nonlininteg.hpp b/fem/nonlininteg.hpp
index 54f342b85..38b133244 100644
--- a/fem/nonlininteg.hpp
+++ b/fem/nonlininteg.hpp
@@ -29,13 +29,12 @@ class NonlinearFormIntegrator
 protected:
    const IntegrationRule *IntRule;
 
-   // CEED extension
-   ceed::Operator* ceedOp;
+   ceed::Operator *ceedOp;  // libCEED extension
 
    MemoryType pa_mt = MemoryType::DEFAULT;
 
    NonlinearFormIntegrator(const IntegrationRule *ir = NULL)
-      : IntRule(ir), ceedOp(NULL) { }
+      : IntRule(ir), ceedOp(NULL) {}
 
 public:
    /** @brief Prescribe a fixed IntegrationRule to use (when @a ir != NULL) or
@@ -52,46 +51,11 @@ public:
    /// Get the integration rule of the integrator (possibly NULL).
    const IntegrationRule *GetIntegrationRule() const { return IntRule; }
 
-   /// Perform the local action of the NonlinearFormIntegrator
-   virtual void AssembleElementVector(const FiniteElement &el,
-                                      ElementTransformation &Tr,
-                                      const Vector &elfun, Vector &elvect);
-
-   /// @brief Perform the local action of the NonlinearFormIntegrator resulting
-   /// from a face integral term.
-   virtual void AssembleFaceVector(const FiniteElement &el1,
-                                   const FiniteElement &el2,
-                                   FaceElementTransformations &Tr,
-                                   const Vector &elfun, Vector &elvect);
-
-   /// Assemble the local gradient matrix
-   virtual void AssembleElementGrad(const FiniteElement &el,
-                                    ElementTransformation &Tr,
-                                    const Vector &elfun, DenseMatrix &elmat);
-
-   /// @brief Assemble the local action of the gradient of the
-   /// NonlinearFormIntegrator resulting from a face integral term.
-   virtual void AssembleFaceGrad(const FiniteElement &el1,
-                                 const FiniteElement &el2,
-                                 FaceElementTransformations &Tr,
-                                 const Vector &elfun, DenseMatrix &elmat);
-
-   /// Compute the local energy
-   virtual double GetElementEnergy(const FiniteElement &el,
-                                   ElementTransformation &Tr,
-                                   const Vector &elfun);
-
    /// Method defining partial assembly.
    /** The result of the partial assembly is stored internally so that it can be
        used later in the methods AddMultPA(). */
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   /** The result of the partial assembly is stored internally so that it can be
-       used later in the methods AddMultPA().
-       Used with BilinearFormIntegrators that have different spaces. */
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
    /** @brief Prepare the integrator for partial assembly (PA) gradient
        evaluations on the given FE space @a fes at the state @a x. */
    /** The result of the partial assembly is stored internally so that it can be
@@ -99,10 +63,12 @@ public:
        The state Vector @a x is an E-vector. */
    virtual void AssembleGradPA(const Vector &x, const FiniteElementSpace &fes);
 
-   /// Compute the local (to the MPI rank) energy with partial assembly.
-   /** Here the state @a x is an E-vector. This method can be called only after
-       the method AssemblePA() has been called. */
-   virtual double GetLocalStateEnergyPA(const Vector &x) const;
+   /// Method for computing the diagonal of the gradient with partial assembly.
+   /** The result Vector @a diag is an E-Vector. This method can be called only
+       after the method AssembleGradPA() has been called.
+
+       @param[in,out] diag  The result Vector: @f$ diag += diag(G) @f$. */
+   virtual void AssembleGradDiagonalPA(Vector &diag) const;
 
    /// Method for partially assembled action.
    /** Perform the action of integrator on the input @a x and add the result to
@@ -121,15 +87,10 @@ public:
        @param[in,out] y  The result Vector: @f$ y += G x @f$. */
    virtual void AddMultGradPA(const Vector &x, Vector &y) const;
 
-   /// Method for computing the diagonal of the gradient with partial assembly.
-   /** The result Vector @a diag is an E-Vector. This method can be called only
-       after the method AssembleGradPA() has been called.
-
-       @param[in,out] diag  The result Vector: @f$ diag += diag(G) @f$. */
-   virtual void AssembleGradDiagonalPA(Vector &diag) const;
-
-   /// Indicates whether this integrator can use a Ceed backend.
-   virtual bool SupportsCeed() const { return false; }
+   /// Compute the local (to the MPI rank) energy with partial assembly.
+   /** Here the state @a x is an E-vector. This method can be called only after
+       the method AssemblePA() has been called. */
+   virtual double GetLocalStateEnergyPA(const Vector &x) const;
 
    /// Method defining fully unassembled operator.
    virtual void AssembleMF(const FiniteElementSpace &fes);
@@ -142,7 +103,39 @@ public:
        called. */
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   ceed::Operator& GetCeedOp() { return *ceedOp; }
+   /// Compute the local energy
+   virtual double GetElementEnergy(const FiniteElement &el,
+                                   ElementTransformation &Tr,
+                                   const Vector &elfun);
+
+   /// Perform the local action of the NonlinearFormIntegrator
+   virtual void AssembleElementVector(const FiniteElement &el,
+                                      ElementTransformation &Tr,
+                                      const Vector &elfun, Vector &elvect);
+
+   /// @brief Perform the local action of the NonlinearFormIntegrator resulting
+   /// from a face integral term.
+   virtual void AssembleFaceVector(const FiniteElement &el1,
+                                   const FiniteElement &el2,
+                                   FaceElementTransformations &Tr,
+                                   const Vector &elfun, Vector &elvect);
+
+   /// Assemble the local gradient matrix
+   virtual void AssembleElementGrad(const FiniteElement &el,
+                                    ElementTransformation &Tr,
+                                    const Vector &elfun, DenseMatrix &elmat);
+
+   /// @brief Assemble the local action of the gradient of the
+   /// NonlinearFormIntegrator resulting from a face integral term.
+   virtual void AssembleFaceGrad(const FiniteElement &el1,
+                                 const FiniteElement &el2,
+                                 FaceElementTransformations &Tr,
+                                 const Vector &elfun, DenseMatrix &elmat);
+
+   /// Indicates whether this integrator can use a Ceed backend.
+   virtual bool SupportsCeed() const { return false; }
+
+   ceed::Operator &GetCeedOp() { return *ceedOp; }
 
    virtual ~NonlinearFormIntegrator()
    {
@@ -150,6 +143,7 @@ public:
    }
 };
 
+
 /** The abstract base class BlockNonlinearFormIntegrator is
     a generalization of the NonlinearFormIntegrator class suitable
     for block state vectors. */
@@ -185,7 +179,7 @@ public:
                                  const Array<const Vector *> &elfun,
                                  const Array2D<DenseMatrix *> &elmats);
 
-   virtual ~BlockNonlinearFormIntegrator() { }
+   virtual ~BlockNonlinearFormIntegrator() {}
 };
 
 
@@ -197,8 +191,8 @@ protected:
                                     transformation. */
 
 public:
-   HyperelasticModel() : Ttr(NULL) { }
-   virtual ~HyperelasticModel() { }
+   HyperelasticModel() : Ttr(NULL) {}
+   virtual ~HyperelasticModel() {}
 
    /// A reference-element to target-element transformation that can be used to
    /// evaluate Coefficient%s.
@@ -277,7 +271,7 @@ public:
 
    NeoHookeanModel(Coefficient &mu_, Coefficient &K_, Coefficient *g_ = NULL)
       : mu(0.0), K(0.0), g(1.0), c_mu(&mu_), c_K(&K_), c_g(g_),
-        have_coeffs(true) { }
+        have_coeffs(true) {}
 
    virtual double EvalW(const DenseMatrix &J) const;
 
@@ -314,7 +308,7 @@ private:
 
 public:
    /** @param[in] m  HyperelasticModel that will be integrated. */
-   HyperelasticNLFIntegrator(HyperelasticModel *m) : model(m) { }
+   HyperelasticNLFIntegrator(HyperelasticModel *m) : model(m) {}
 
    /** @brief Computes the integral of W(Jacobian(Trt)) over a target zone
        @param[in] el     Type of FiniteElement.
@@ -333,6 +327,7 @@ public:
                                     const Vector &elfun, DenseMatrix &elmat);
 };
 
+
 /** Hyperelastic incompressible Neo-Hookean integrator with the PK1 stress
     \f$P = \mu F - p F^{-T}\f$ where \f$\mu\f$ is the shear modulus,
     \f$p\f$ is the pressure, and \f$F\f$ is the deformation gradient */
@@ -345,7 +340,7 @@ private:
    Vector Sh_p;
 
 public:
-   IncompressibleNeoHookeanIntegrator(Coefficient &mu_) : c_mu(&mu_) { }
+   IncompressibleNeoHookeanIntegrator(Coefficient &mu_) : c_mu(&mu_) {}
 
    virtual double GetElementEnergy(const Array<const FiniteElement *>&el,
                                    ElementTransformation &Tr,
@@ -371,6 +366,7 @@ private:
    Coefficient *Q{};
    DenseMatrix dshape, dshapex, EF, gradEF, ELV, elmat_comp;
    Vector shape;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;         ///< Not owned
@@ -378,7 +374,7 @@ private:
    int dim, ne, nq;
 
 public:
-   VectorConvectionNLFIntegrator(Coefficient &q): Q(&q) { }
+   VectorConvectionNLFIntegrator(Coefficient &q): Q(&q) {}
 
    VectorConvectionNLFIntegrator() = default;
 
@@ -395,14 +391,12 @@ public:
                                     const Vector &elfun,
                                     DenseMatrix &elmat);
 
-   using NonlinearFormIntegrator::AssemblePA;
-
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleMF(const FiniteElementSpace &fes);
-
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 };
 
@@ -418,7 +412,7 @@ private:
    Vector shape;
 
 public:
-   ConvectiveVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) { }
+   ConvectiveVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) {}
 
    ConvectiveVectorConvectionNLFIntegrator() = default;
 
@@ -441,7 +435,7 @@ private:
    Vector shape;
 
 public:
-   SkewSymmetricVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) { }
+   SkewSymmetricVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) {}
 
    SkewSymmetricVectorConvectionNLFIntegrator() = default;
 
diff --git a/fem/pbilinearform.cpp b/fem/pbilinearform.cpp
index ee1030c48..707473f87 100644
--- a/fem/pbilinearform.cpp
+++ b/fem/pbilinearform.cpp
@@ -19,107 +19,109 @@
 namespace mfem
 {
 
-void ParBilinearForm::pAllocMat()
-{
-   int nbr_size = pfes->GetFaceNbrVSize();
 
-   if (precompute_sparsity == 0 || fes->GetVDim() > 1)
-   {
-      if (keep_nbr_block)
-      {
-         mat = new SparseMatrix(height + nbr_size, width + nbr_size);
-      }
-      else
-      {
-         mat = new SparseMatrix(height, width + nbr_size);
-      }
-      return;
-   }
-
-   // the sparsity pattern is defined from the map: face->element->dof
-   const Table &lelem_ldof = fes->GetElementToDofTable(); // <-- dofs
-   const Table &nelem_ndof = pfes->face_nbr_element_dof; // <-- vdofs
-   Table elem_dof; // element + nbr-element <---> dof
-   if (nbr_size > 0)
-   {
-      // merge lelem_ldof and nelem_ndof into elem_dof
-      int s1 = lelem_ldof.Size(), s2 = nelem_ndof.Size();
-      const int *I1 = lelem_ldof.GetI(), *J1 = lelem_ldof.GetJ();
-      const int *I2 = nelem_ndof.GetI(), *J2 = nelem_ndof.GetJ();
-      const int nnz1 = I1[s1], nnz2 = I2[s2];
-
-      elem_dof.SetDims(s1 + s2, nnz1 + nnz2);
-
-      int *I = elem_dof.GetI(), *J = elem_dof.GetJ();
-      for (int i = 0; i <= s1; i++)
-      {
-         I[i] = I1[i];
-      }
-      for (int j = 0; j < nnz1; j++)
-      {
-         J[j] = J1[j];
-      }
-      for (int i = 0; i <= s2; i++)
-      {
-         I[s1+i] = I2[i] + nnz1;
-      }
-      for (int j = 0; j < nnz2; j++)
-      {
-         J[nnz1+j] = J2[j] + height;
-      }
-   }
-   //   dof_elem x  elem_face x face_elem x elem_dof  (keep_nbr_block = true)
-   // ldof_lelem x lelem_face x face_elem x elem_dof  (keep_nbr_block = false)
-   Table dof_dof;
-   {
-      Table face_dof; // face_elem x elem_dof
-      {
-         Table *face_elem = pfes->GetParMesh()->GetFaceToAllElementTable();
-         if (nbr_size > 0)
-         {
-            mfem::Mult(*face_elem, elem_dof, face_dof);
-         }
-         else
-         {
-            mfem::Mult(*face_elem, lelem_ldof, face_dof);
-         }
-         delete face_elem;
-         if (nbr_size > 0)
-         {
-            elem_dof.Clear();
-         }
-      }
-
-      if (keep_nbr_block)
-      {
-         Table dof_face;
-         Transpose(face_dof, dof_face, height + nbr_size);
-         mfem::Mult(dof_face, face_dof, dof_dof);
-      }
-      else
-      {
-         Table ldof_face;
-         {
-            Table face_ldof;
-            Table *face_lelem = fes->GetMesh()->GetFaceToElementTable();
-            mfem::Mult(*face_lelem, lelem_ldof, face_ldof);
-            delete face_lelem;
-            Transpose(face_ldof, ldof_face, height);
-         }
-         mfem::Mult(ldof_face, face_dof, dof_dof);
-      }
-   }
-
-   int *I = dof_dof.GetI();
-   int *J = dof_dof.GetJ();
-   int nrows = dof_dof.Size();
-   double *data = Memory<double>(I[nrows]);
-
-   mat = new SparseMatrix(I, J, data, nrows, height + nbr_size);
-   *mat = 0.0;
-
-   dof_dof.LoseData();
-}
+//XX TODO
+// void ParBilinearForm::pAllocMat()
+// {
+//    int nbr_size = pfes->GetFaceNbrVSize();
+
+//    if (precompute_sparsity == 0 || fes->GetVDim() > 1)
+//    {
+//       if (keep_nbr_block)
+//       {
+//          mat = new SparseMatrix(height + nbr_size, width + nbr_size);
+//       }
+//       else
+//       {
+//          mat = new SparseMatrix(height, width + nbr_size);
+//       }
+//       return;
+//    }
+
+//    // the sparsity pattern is defined from the map: face->element->dof
+//    const Table &lelem_ldof = fes->GetElementToDofTable(); // <-- dofs
+//    const Table &nelem_ndof = pfes->face_nbr_element_dof; // <-- vdofs
+//    Table elem_dof; // element + nbr-element <---> dof
+//    if (nbr_size > 0)
+//    {
+//       // merge lelem_ldof and nelem_ndof into elem_dof
+//       int s1 = lelem_ldof.Size(), s2 = nelem_ndof.Size();
+//       const int *I1 = lelem_ldof.GetI(), *J1 = lelem_ldof.GetJ();
+//       const int *I2 = nelem_ndof.GetI(), *J2 = nelem_ndof.GetJ();
+//       const int nnz1 = I1[s1], nnz2 = I2[s2];
+
+//       elem_dof.SetDims(s1 + s2, nnz1 + nnz2);
+
+//       int *I = elem_dof.GetI(), *J = elem_dof.GetJ();
+//       for (int i = 0; i <= s1; i++)
+//       {
+//          I[i] = I1[i];
+//       }
+//       for (int j = 0; j < nnz1; j++)
+//       {
+//          J[j] = J1[j];
+//       }
+//       for (int i = 0; i <= s2; i++)
+//       {
+//          I[s1+i] = I2[i] + nnz1;
+//       }
+//       for (int j = 0; j < nnz2; j++)
+//       {
+//          J[nnz1+j] = J2[j] + height;
+//       }
+//    }
+//    //   dof_elem x  elem_face x face_elem x elem_dof  (keep_nbr_block = true)
+//    // ldof_lelem x lelem_face x face_elem x elem_dof  (keep_nbr_block = false)
+//    Table dof_dof;
+//    {
+//       Table face_dof; // face_elem x elem_dof
+//       {
+//          Table *face_elem = pfes->GetParMesh()->GetFaceToAllElementTable();
+//          if (nbr_size > 0)
+//          {
+//             mfem::Mult(*face_elem, elem_dof, face_dof);
+//          }
+//          else
+//          {
+//             mfem::Mult(*face_elem, lelem_ldof, face_dof);
+//          }
+//          delete face_elem;
+//          if (nbr_size > 0)
+//          {
+//             elem_dof.Clear();
+//          }
+//       }
+
+//       if (keep_nbr_block)
+//       {
+//          Table dof_face;
+//          Transpose(face_dof, dof_face, height + nbr_size);
+//          mfem::Mult(dof_face, face_dof, dof_dof);
+//       }
+//       else
+//       {
+//          Table ldof_face;
+//          {
+//             Table face_ldof;
+//             Table *face_lelem = fes->GetMesh()->GetFaceToElementTable();
+//             mfem::Mult(*face_lelem, lelem_ldof, face_ldof);
+//             delete face_lelem;
+//             Transpose(face_ldof, ldof_face, height);
+//          }
+//          mfem::Mult(ldof_face, face_dof, dof_dof);
+//       }
+//    }
+
+//    int *I = dof_dof.GetI();
+//    int *J = dof_dof.GetJ();
+//    int nrows = dof_dof.Size();
+//    double *data = Memory<double>(I[nrows]);
+
+//    mat = new SparseMatrix(I, J, data, nrows, height + nbr_size);
+//    *mat = 0.0;
+
+//    dof_dof.LoseData();
+// }
 
 void ParBilinearForm::ParallelRAP(SparseMatrix &loc_A, OperatorHandle &A,
                                   bool steal_loc_A)
@@ -151,7 +153,8 @@ void ParBilinearForm::ParallelRAP(SparseMatrix &loc_A, OperatorHandle &A,
    }
 }
 
-void ParBilinearForm::ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local)
+void ParBilinearForm::ParallelAssemble(OperatorHandle &A,
+                                       SparseMatrix *A_local) const
 {
    A.Clear();
 
@@ -201,6 +204,7 @@ void ParBilinearForm::ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local)
 
    // TODO - assemble the Dof_TrueDof_Matrix directly in the required format?
    Ph.ConvertFrom(pfes->Dof_TrueDof_Matrix());
+
    // TODO: When Ph.Type() == Operator::ANY_TYPE we want to use the Operator
    // returned by pfes->GetProlongationMatrix(), however that Operator is a
    // const Operator, so we cannot store it in OperatorHandle. We need a const
@@ -209,7 +213,7 @@ void ParBilinearForm::ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local)
    A.MakePtAP(dA, Ph);
 }
 
-HypreParMatrix *ParBilinearForm::ParallelAssemble(SparseMatrix *m)
+HypreParMatrix *ParBilinearForm::ParallelAssemble(SparseMatrix *m) const
 {
    OperatorHandle Mh(Operator::Hypre_ParCSR);
    ParallelAssemble(Mh, m);
@@ -246,10 +250,9 @@ void ParBilinearForm::AssembleSharedFaces(int skip_zeros)
       vdofs_all.Append(vdofs2);
       for (int k = 0; k < interior_face_integs.Size(); k++)
       {
-         interior_face_integs[k]->
-         AssembleFaceMatrix(*pfes->GetFE(T->Elem1No),
-                            *pfes->GetFaceNbrFE(Elem2NbrNo),
-                            *T, elemmat);
+         interior_face_integs[k]->AssembleFaceMatrix(*pfes->GetFE(T->Elem1No),
+                                                     *pfes->GetFaceNbrFE(Elem2NbrNo),
+                                                     *T, elemmat);
          if (keep_nbr_block)
          {
             mat->AddSubMatrix(vdofs_all, vdofs_all, elemmat, skip_zeros);
@@ -269,7 +272,15 @@ void ParBilinearForm::Assemble(int skip_zeros)
       pfes->ExchangeFaceNbrData();
       if (!ext && mat == NULL)
       {
-         pAllocMat();
+         int nbr_size = pfes->GetFaceNbrVSize();
+         if (keep_nbr_block)
+         {
+            mat = new SparseMatrix(height + nbr_size, width + nbr_size);
+         }
+         else
+         {
+            mat = new SparseMatrix(height, width + nbr_size);
+         }
       }
    }
 
@@ -301,29 +312,23 @@ void ParBilinearForm::AssembleDiagonal(Vector &diag) const
    // Here, we have extension, ext, and parallel/conforming prolongation, P.
    Vector local_diag(P->Height());
    ext->AssembleDiagonal(local_diag);
-   if (fes->Conforming())
+   const HypreParMatrix *HP = dynamic_cast<const HypreParMatrix*>(P);
+   if (!HP)
    {
+      // This is a parallel prolongation
       P->MultTranspose(local_diag, diag);
       return;
    }
    // For an AMR mesh, a convergent diagonal is assembled with |P^T| d_l,
    // where |P^T| has the entry-wise absolute values of the conforming
    // prolongation transpose operator.
-   const HypreParMatrix *HP = dynamic_cast<const HypreParMatrix*>(P);
-   if (HP)
-   {
-      HP->AbsMultTranspose(1.0, local_diag, 0.0, diag);
-   }
-   else
-   {
-      MFEM_ABORT("unsupported prolongation matrix type.");
-   }
+   HP->AbsMultTranspose(1.0, local_diag, 0.0, diag);
 }
 
-void ParBilinearForm
-::ParallelEliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
-                               HypreParMatrix &A, const HypreParVector &X,
-                               HypreParVector &B) const
+void ParBilinearForm::ParallelEliminateEssentialBC(
+   const Array<int> &bdr_attr_is_ess,
+   HypreParMatrix &A, const HypreParVector &X,
+   HypreParVector &B) const
 {
    Array<int> dof_list;
 
@@ -333,9 +338,9 @@ void ParBilinearForm
    A.EliminateRowsCols(dof_list, X, B);
 }
 
-HypreParMatrix *ParBilinearForm::
-ParallelEliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
-                             HypreParMatrix &A) const
+HypreParMatrix *ParBilinearForm::ParallelEliminateEssentialBC(
+   const Array<int> &bdr_attr_is_ess,
+   HypreParMatrix &A) const
 {
    Array<int> dof_list;
 
@@ -374,7 +379,17 @@ void ParBilinearForm::FormLinearSystem(
 {
    if (ext)
    {
-      ext->FormLinearSystem(ess_tdof_list, x, b, A, X, B, copy_interior);
+      Operator *oper;
+      ext->FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         delete oper;
+         FormSystemMatrix(ess_tdof_list, A);
+      }
+      else
+      {
+         A.Reset(oper);
+      }
       return;
    }
 
@@ -418,18 +433,28 @@ void ParBilinearForm::FormLinearSystem(
    }
 }
 
-void ParBilinearForm::EliminateVDofsInRHS(
-   const Array<int> &vdofs, const Vector &x, Vector &b)
-{
-   p_mat.EliminateBC(p_mat_e, vdofs, x, b);
-}
-
 void ParBilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
                                        OperatorHandle &A)
 {
    if (ext)
    {
-      ext->FormSystemMatrix(ess_tdof_list, A);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         // Always does `DIAG_ONE` policy to be consistent with
+         // `Operator::FormConstrainedSystemOperator`.
+         MFEM_VERIFY(diag_policy == DiagonalPolicy::DIAG_ONE,
+                     "Only DiagonalPolicy::DIAG_ONE supported with"
+                     " FABilinearFormExtension.");
+         ParallelRAP(*mat, A);
+         A.As<HypreParMatrix>()->EliminateBC(ess_tdof_list,
+                                             DiagonalPolicy::DIAG_ONE);
+      }
+      else
+      {
+         Operator *oper;
+         ext->FormSystemOperator(ess_tdof_list, oper);
+         A.Reset(oper);
+      }
       return;
    }
 
@@ -460,6 +485,7 @@ void ParBilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
          delete mat_e;
          mat_e = NULL;
          p_mat_e.EliminateRowsCols(p_mat, ess_tdof_list);
+         A = p_mat;
       }
       if (hybridization)
       {
@@ -521,30 +547,22 @@ void ParBilinearForm::Update(FiniteElementSpace *nfes)
    p_mat_e.Clear();
 }
 
-
-HypreParMatrix *ParMixedBilinearForm::ParallelAssemble()
+void ParBilinearForm::EliminateVDofsInRHS(
+   const Array<int> &vdofs, const Vector &x, Vector &b)
 {
-   // construct the block-diagonal matrix A
-   HypreParMatrix *A =
-      new HypreParMatrix(trial_pfes->GetComm(),
-                         test_pfes->GlobalVSize(),
-                         trial_pfes->GlobalVSize(),
-                         test_pfes->GetDofOffsets(),
-                         trial_pfes->GetDofOffsets(),
-                         mat);
+   p_mat.EliminateBC(p_mat_e, vdofs, x, b);
+}
 
-   HypreParMatrix *rap = RAP(test_pfes->Dof_TrueDof_Matrix(), A,
-                             trial_pfes->Dof_TrueDof_Matrix());
+void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A) const
+{
+   A.Clear();
 
-   delete A;
+   if (mat == NULL) { return; }
+   MFEM_VERIFY(mat->Finalized(), "the local matrix must be finalized");
 
-   return rap;
-}
+   OperatorHandle dA(A.Type()), P_test(A.Type()), P_trial(A.Type());
 
-void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A)
-{
    // construct the rectangular block-diagonal matrix dA
-   OperatorHandle dA(A.Type());
    dA.MakeRectangularBlockDiag(trial_pfes->GetComm(),
                                test_pfes->GlobalVSize(),
                                trial_pfes->GlobalVSize(),
@@ -552,8 +570,6 @@ void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A)
                                trial_pfes->GetDofOffsets(),
                                mat);
 
-   OperatorHandle P_test(A.Type()), P_trial(A.Type());
-
    // TODO - construct the Dof_TrueDof_Matrix directly in the required format.
    P_test.ConvertFrom(test_pfes->Dof_TrueDof_Matrix());
    P_trial.ConvertFrom(trial_pfes->Dof_TrueDof_Matrix());
@@ -561,6 +577,14 @@ void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A)
    A.MakeRAP(P_test, dA, P_trial);
 }
 
+HypreParMatrix *ParMixedBilinearForm::ParallelAssemble() const
+{
+   OperatorHandle Mh(Operator::Hypre_ParCSR);
+   ParallelAssemble(Mh);
+   Mh.SetOperatorOwner(false);
+   return Mh.As<HypreParMatrix>();
+}
+
 /// Compute y += a (P^t A P) x, where x and y are vectors on the true dofs
 void ParMixedBilinearForm::TrueAddMult(const Vector &x, Vector &y,
                                        const double a) const
@@ -576,21 +600,55 @@ void ParMixedBilinearForm::TrueAddMult(const Vector &x, Vector &y,
    test_pfes->Dof_TrueDof_Matrix()->MultTranspose(a, Yaux, 1.0, y);
 }
 
+void ParMixedBilinearForm::FormRectangularLinearSystem(
+   const Array<int> &trial_tdof_list,
+   const Array<int> &test_tdof_list, Vector &x,
+   Vector &b, OperatorHandle &A, Vector &X,
+   Vector &B)
+{
+   if (ext)
+   {
+      Operator *oper;
+      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
+                                       x, b, oper, X, B);
+      A.Reset(oper);
+      return;
+   }
+
+   FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, A);
+
+   const Operator *test_P = test_pfes->GetProlongationMatrix();
+   const SparseMatrix *trial_R = trial_pfes->GetRestrictionMatrix();
+
+   X.SetSize(trial_pfes->TrueVSize());
+   B.SetSize(test_pfes->TrueVSize());
+   test_P->MultTranspose(b, B);
+   trial_R->Mult(x, X);
+
+   p_mat_e.As<HypreParMatrix>()->Mult(-1.0, X, 1.0, B);
+   B.SetSubVector(test_tdof_list, 0.0);
+}
+
 void ParMixedBilinearForm::FormRectangularSystemMatrix(
-   const Array<int>
-   &trial_tdof_list,
+   const Array<int> &trial_tdof_list,
    const Array<int> &test_tdof_list,
    OperatorHandle &A)
 {
    if (ext)
    {
-      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, A);
+      Operator *oper;
+      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, oper);
+      A.Reset(oper);
       return;
    }
 
    if (mat)
    {
-      Finalize();
+      const int remove_zeros = 0;
+      Finalize(remove_zeros);
+      MFEM_VERIFY(p_mat.Ptr() == NULL && p_mat_e.Ptr() == NULL,
+                  "The ParMixedBilinearFormBilinearForm must be updated "
+                  "with Update() before re-assembling the ParMixedBilinearFormBilinearForm.");
       ParallelAssemble(p_mat);
       delete mat;
       mat = NULL;
@@ -600,97 +658,89 @@ void ParMixedBilinearForm::FormRectangularSystemMatrix(
          p_mat.As<HypreParMatrix>()->EliminateCols(trial_tdof_list);
       p_mat.As<HypreParMatrix>()->EliminateRows(test_tdof_list);
       p_mat_e.Reset(temp, true);
+      A = p_mat;
    }
-
-   A = p_mat;
 }
 
-void ParMixedBilinearForm::FormRectangularLinearSystem(
-   const Array<int>
-   &trial_tdof_list,
-   const Array<int> &test_tdof_list, Vector &x,
-   Vector &b, OperatorHandle &A, Vector &X,
-   Vector &B)
+void ParDiscreteLinearOperator::ParallelAssemble(OperatorHandle &A) const
 {
-   if (ext)
+   A.Clear();
+
+   if (mat == NULL) { return; }
+   MFEM_VERIFY(mat->Finalized(), "the local matrix must be finalized");
+
+   if (A.Type() == Operator::Hypre_ParCSR)
    {
-      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
-                                       x, b, A, X, B);
-      return;
+      const SparseMatrix *R = range_fes->GetRestrictionMatrix();
+      const HypreParMatrix *P = domain_fes->Dof_TrueDof_Matrix();
+      SparseMatrix *RA = mfem::Mult(*R, *mat);
+      A.Reset(P->LeftDiagMult(*RA, range_fes->GetTrueDofOffsets()));
+      delete RA;
    }
+   else
+   {
+      OperatorHandle dA(A.Type()), P_trial(A.Type()), Rt_test(A.Type());
 
-   FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, A);
-
-   const Operator *test_P = test_pfes->GetProlongationMatrix();
-   const SparseMatrix *trial_R = trial_pfes->GetRestrictionMatrix();
+      // construct the rectangular block-diagonal matrix dA
+      dA.MakeRectangularBlockDiag(domain_fes->GetComm(),
+                                  range_fes->GlobalVSize(),
+                                  domain_fes->GlobalVSize(),
+                                  range_fes->GetDofOffsets(),
+                                  domain_fes->GetDofOffsets(),
+                                  mat);
 
-   X.SetSize(trial_pfes->TrueVSize());
-   B.SetSize(test_pfes->TrueVSize());
-   test_P->MultTranspose(b, B);
-   trial_R->Mult(x, X);
+      SparseMatrix *Rt = Transpose(*range_fes->GetRestrictionMatrix());
+      Rt_test.MakeRectangularBlockDiag(range_fes->GetComm(),
+                                       range_fes->GlobalVSize(),
+                                       range_fes->GlobalTrueVSize(),
+                                       range_fes->GetDofOffsets(),
+                                       range_fes->GetTrueDofOffsets(),
+                                       Rt);
 
-   p_mat_e.As<HypreParMatrix>()->Mult(-1.0, X, 1.0, B);
-   B.SetSubVector(test_tdof_list, 0.0);
-}
+      // TODO - construct the Dof_TrueDof_Matrix directly in the required format.
+      P_trial.ConvertFrom(domain_fes->Dof_TrueDof_Matrix());
 
-HypreParMatrix* ParDiscreteLinearOperator::ParallelAssemble() const
-{
-   MFEM_ASSERT(mat, "Matrix is not assembled");
-   MFEM_ASSERT(mat->Finalized(), "Matrix is not finalized");
-   SparseMatrix* RA = mfem::Mult(*range_fes->GetRestrictionMatrix(), *mat);
-   HypreParMatrix* P = domain_fes->Dof_TrueDof_Matrix();
-   HypreParMatrix* RAP = P->LeftDiagMult(*RA, range_fes->GetTrueDofOffsets());
-   delete RA;
-   return RAP;
+      A.MakeRAP(Rt_test, dA, P_trial);
+      delete Rt;
+   }
 }
 
-void ParDiscreteLinearOperator::ParallelAssemble(OperatorHandle &A)
+HypreParMatrix *ParDiscreteLinearOperator::ParallelAssemble() const
 {
-   // construct the rectangular block-diagonal matrix dA
-   OperatorHandle dA(A.Type());
-   dA.MakeRectangularBlockDiag(domain_fes->GetComm(),
-                               range_fes->GlobalVSize(),
-                               domain_fes->GlobalVSize(),
-                               range_fes->GetDofOffsets(),
-                               domain_fes->GetDofOffsets(),
-                               mat);
-
-   SparseMatrix *Rt = Transpose(*range_fes->GetRestrictionMatrix());
-   OperatorHandle R_test_transpose(A.Type());
-   R_test_transpose.MakeRectangularBlockDiag(range_fes->GetComm(),
-                                             range_fes->GlobalVSize(),
-                                             range_fes->GlobalTrueVSize(),
-                                             range_fes->GetDofOffsets(),
-                                             range_fes->GetTrueDofOffsets(),
-                                             Rt);
-
-   // TODO - construct the Dof_TrueDof_Matrix directly in the required format.
-   OperatorHandle P_trial(A.Type());
-   P_trial.ConvertFrom(domain_fes->Dof_TrueDof_Matrix());
-
-   A.MakeRAP(R_test_transpose, dA, P_trial);
-   delete Rt;
+   OperatorHandle Mh(Operator::Hypre_ParCSR);
+   ParallelAssemble(Mh);
+   Mh.SetOperatorOwner(false);
+   return Mh.As<HypreParMatrix>();
 }
 
-void ParDiscreteLinearOperator::FormRectangularSystemMatrix(OperatorHandle &A)
+void ParDiscreteLinearOperator::FormDiscreteOperatorMatrix(OperatorHandle &A)
 {
    if (ext)
    {
-      Array<int> empty;
-      ext->FormRectangularSystemOperator(empty, empty, A);
+      Operator *oper;
+      ext->FormDiscreteOperator(oper);
+      A.Reset(oper);
       return;
    }
 
-   mfem_error("not implemented!");
+   if (mat)
+   {
+      Finalize();
+      ParallelAssemble(A);
+      delete mat;
+      mat = NULL;
+      delete mat_e;
+      mat_e = NULL;
+   }
 }
 
-void ParDiscreteLinearOperator::GetParBlocks(Array2D<HypreParMatrix *> &blocks)
-const
+void ParDiscreteLinearOperator::GetParBlocks(
+   Array2D<HypreParMatrix *> &blocks)
 {
    MFEM_VERIFY(mat->Finalized(), "Local matrix needs to be finalized for "
                "GetParBlocks");
 
-   HypreParMatrix* RLP = ParallelAssemble();
+   HypreParMatrix *RLP = ParallelAssemble();
 
    blocks.SetSize(range_fes->GetVDim(), domain_fes->GetVDim());
 
diff --git a/fem/pbilinearform.hpp b/fem/pbilinearform.hpp
index c8fef567b..be8e50ca3 100644
--- a/fem/pbilinearform.hpp
+++ b/fem/pbilinearform.hpp
@@ -28,27 +28,31 @@ namespace mfem
 class ParBilinearForm : public BilinearForm
 {
    friend FABilinearFormExtension;
+
 protected:
-   ParFiniteElementSpace *pfes; ///< Points to the same object as #fes
+   ///< Points to the same object as #fes
+   ParFiniteElementSpace *pfes;
 
    /// Auxiliary vectors used in TrueAddMult(): L-, L-, and T-vector, resp.
    mutable Vector Xaux, Yaux, Ytmp;
 
+   /// Matrix and eliminated matrix
    OperatorHandle p_mat, p_mat_e;
 
    bool keep_nbr_block;
 
-   // Allocate mat - called when (mat == NULL && fbfi.Size() > 0)
-   void pAllocMat();
+   //XX TODO
+   // // Allocate mat - called when (mat == NULL && fbfi.Size() > 0)
+   // void pAllocMat();
 
    void AssembleSharedFaces(int skip_zeros = 1);
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   ParBilinearForm(const ParBilinearForm &);
+   /// Copy construction is not supported.
+   ParBilinearForm(const ParBilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   ParBilinearForm &operator=(const ParBilinearForm &);
+   /// Copy assignment is not supported.
+   ParBilinearForm &operator=(const ParBilinearForm &) = delete;
 
 public:
    /// Creates parallel bilinear form associated with the FE space @a *pf.
@@ -103,40 +107,40 @@ public:
 
    /// Returns the matrix assembled on the true dofs, i.e. P^t A P.
    /** The returned matrix has to be deleted by the caller. */
-   HypreParMatrix *ParallelAssemble() { return ParallelAssemble(mat); }
+   HypreParMatrix *ParallelAssemble() const { return ParallelAssemble(mat); }
 
    /// Returns the eliminated matrix assembled on the true dofs, i.e. P^t A_e P.
    /** The returned matrix has to be deleted by the caller. */
-   HypreParMatrix *ParallelAssembleElim() { return ParallelAssemble(mat_e); }
+   HypreParMatrix *ParallelAssembleElim() const { return ParallelAssemble(mat_e); }
 
    /// Return the matrix @a m assembled on the true dofs, i.e. P^t A P.
    /** The returned matrix has to be deleted by the caller. */
-   HypreParMatrix *ParallelAssemble(SparseMatrix *m);
-
-   /** @brief Compute parallel RAP operator and store it in @a A as a HypreParMatrix.
-
-       @param[in] loc_A The rank-local `SparseMatrix`.
-       @param[out] A The `OperatorHandle` containing the global `HypreParMatrix`.
-       @param[in] steal_loc_A Have the `HypreParMatrix` in @a A take ownership of
-                              the memory objects in @a loc_A.
-       */
-   void ParallelRAP(SparseMatrix &loc_A,
-                    OperatorHandle &A,
-                    bool steal_loc_A = false);
+   HypreParMatrix *ParallelAssemble(SparseMatrix *m) const;
 
    /** @brief Returns the matrix assembled on the true dofs, i.e.
        @a A = P^t A_local P, in the format (type id) specified by @a A. */
-   void ParallelAssemble(OperatorHandle &A) { ParallelAssemble(A, mat); }
+   void ParallelAssemble(OperatorHandle &A) const { ParallelAssemble(A, mat); }
 
    /** Returns the eliminated matrix assembled on the true dofs, i.e.
        @a A_elim = P^t A_elim_local P in the format (type id) specified by @a A.
     */
-   void ParallelAssembleElim(OperatorHandle &A_elim)
+   void ParallelAssembleElim(OperatorHandle &A_elim) const
    { ParallelAssemble(A_elim, mat_e); }
 
    /** Returns the matrix @a A_local assembled on the true dofs, i.e.
        @a A = P^t A_local P in the format (type id) specified by @a A. */
-   void ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local);
+   void ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local) const;
+
+   /** @brief Compute parallel RAP operator and store it in @a A as a HypreParMatrix.
+
+       @param[in] loc_A The rank-local `SparseMatrix`.
+       @param[out] A The `OperatorHandle` containing the global `HypreParMatrix`.
+       @param[in] steal_loc_A Have the `HypreParMatrix` in @a A take ownership of
+                              the memory objects in @a loc_A.
+       */
+   void ParallelRAP(SparseMatrix &loc_A,
+                    OperatorHandle &A,
+                    bool steal_loc_A = false);
 
    /// Eliminate essential boundary DOFs from a parallel assembled system.
    /** The array @a bdr_attr_is_ess marks boundary attributes that constitute
@@ -183,9 +187,7 @@ public:
    /// Get the parallel finite element space prolongation matrix
    virtual const Operator *GetProlongation() const
    { return pfes->GetProlongationMatrix(); }
-   /// Get the transpose of GetRestriction, useful for matrix-free RAP
-   virtual const Operator *GetRestrictionTranspose() const
-   { return pfes->GetRestrictionTransposeOperator(); }
+
    /// Get the parallel finite element space restriction matrix
    virtual const Operator *GetRestriction() const
    { return pfes->GetRestrictionMatrix(); }
@@ -209,7 +211,7 @@ public:
 
    void EliminateVDofsInRHS(const Array<int> &vdofs, const Vector &x, Vector &b);
 
-   virtual ~ParBilinearForm() { }
+   virtual ~ParBilinearForm() {}
 };
 
 /// Class for parallel bilinear form using different test and trial FE spaces.
@@ -220,6 +222,7 @@ protected:
    ParFiniteElementSpace *trial_pfes;
    /// Points to the same object as #test_fes
    ParFiniteElementSpace *test_pfes;
+
    /// Auxiliary objects used in TrueAddMult().
    mutable ParGridFunction Xaux, Yaux;
 
@@ -227,11 +230,11 @@ protected:
    OperatorHandle p_mat, p_mat_e;
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   ParMixedBilinearForm(const ParMixedBilinearForm &);
+   /// Copy construction is not supported.
+   ParMixedBilinearForm(const ParMixedBilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   ParMixedBilinearForm &operator=(const ParMixedBilinearForm &);
+   /// Copy assignment is not supported.
+   ParMixedBilinearForm &operator=(const ParMixedBilinearForm &) = delete;
 
 public:
    /** @brief Construct a ParMixedBilinearForm on the given FiniteElementSpace%s
@@ -258,7 +261,7 @@ public:
        by the newly constructed ParMixedBilinearForm. */
    ParMixedBilinearForm(ParFiniteElementSpace *trial_fes,
                         ParFiniteElementSpace *test_fes,
-                        ParMixedBilinearForm * mbf)
+                        ParMixedBilinearForm *mbf)
       : MixedBilinearForm(trial_fes, test_fes, mbf),
         p_mat(Operator::Hypre_ParCSR), p_mat_e(Operator::Hypre_ParCSR)
    {
@@ -267,24 +270,16 @@ public:
    }
 
    /// Returns the matrix assembled on the true dofs, i.e. P_test^t A P_trial.
-   HypreParMatrix *ParallelAssemble();
+   HypreParMatrix *ParallelAssemble() const;
 
    /** @brief Returns the matrix assembled on the true dofs, i.e.
        @a A = P_test^t A_local P_trial, in the format (type id) specified by
        @a A. */
-   void ParallelAssemble(OperatorHandle &A);
+   void ParallelAssemble(OperatorHandle &A) const;
 
    using MixedBilinearForm::FormRectangularSystemMatrix;
    using MixedBilinearForm::FormRectangularLinearSystem;
 
-   /** @brief Return in @a A a parallel (on truedofs) version of this operator.
-
-       This returns the same operator as FormRectangularLinearSystem(), but does
-       without the transformations of the right-hand side. */
-   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
-                                            const Array<int> &test_tdof_list,
-                                            OperatorHandle &A);
-
    /** @brief Form the parallel linear system A X = B, corresponding to this mixed
        bilinear form and the linear form @a b(.).
 
@@ -296,10 +291,18 @@ public:
                                             Vector &b, OperatorHandle &A, Vector &X,
                                             Vector &B);
 
+   /** @brief Return in @a A a parallel (on truedofs) version of this operator.
+
+       This returns the same operator as FormRectangularLinearSystem(), but does
+       without the transformations of the right-hand side. */
+   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
+                                            const Array<int> &test_tdof_list,
+                                            OperatorHandle &A);
+
    /// Compute y += a (P^t A P) x, where x and y are vectors on the true dofs
    void TrueAddMult(const Vector &x, Vector &y, const double a = 1.0) const;
 
-   virtual ~ParMixedBilinearForm() { }
+   virtual ~ParMixedBilinearForm() {}
 };
 
 /** The parallel matrix representation a linear operator between parallel finite
@@ -313,11 +316,12 @@ protected:
    ParFiniteElementSpace *range_fes;
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   ParDiscreteLinearOperator(const ParDiscreteLinearOperator &);
+   /// Copy construction is not supported.
+   ParDiscreteLinearOperator(const ParDiscreteLinearOperator &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   ParDiscreteLinearOperator &operator=(const ParDiscreteLinearOperator &);
+   /// Copy assignment is not supported.
+   ParDiscreteLinearOperator &operator=(const ParDiscreteLinearOperator &) =
+      delete;
 
 public:
    /** @brief Construct a ParDiscreteLinearOperator on the given
@@ -327,7 +331,11 @@ public:
        object. */
    ParDiscreteLinearOperator(ParFiniteElementSpace *dfes,
                              ParFiniteElementSpace *rfes)
-      : DiscreteLinearOperator(dfes, rfes) { domain_fes=dfes; range_fes=rfes; }
+      : DiscreteLinearOperator(dfes, rfes)
+   {
+      domain_fes = dfes;
+      range_fes = rfes;
+   }
 
    /// Returns the matrix "assembled" on the true dofs
    HypreParMatrix *ParallelAssemble() const;
@@ -335,18 +343,18 @@ public:
    /** @brief Returns the matrix assembled on the true dofs, i.e.
        @a A = R_test A_local P_trial, in the format (type id) specified by
        @a A. */
-   void ParallelAssemble(OperatorHandle &A);
+   void ParallelAssemble(OperatorHandle &A) const;
 
-   /** Extract the parallel blocks corresponding to the vector dimensions of the
-       domain and range parallel finite element spaces */
-   void GetParBlocks(Array2D<HypreParMatrix *> &blocks) const;
-
-   using MixedBilinearForm::FormRectangularSystemMatrix;
+   using DiscreteLinearOperator::FormDiscreteOperatorMatrix;
 
    /** @brief Return in @a A a parallel (on truedofs) version of this operator. */
-   virtual void FormRectangularSystemMatrix(OperatorHandle &A);
+   virtual void FormDiscreteOperatorMatrix(OperatorHandle &A);
+
+   /** Extract the parallel blocks corresponding to the vector dimensions of the
+       domain and range parallel finite element spaces */
+   void GetParBlocks(Array2D<HypreParMatrix *> &blocks);
 
-   virtual ~ParDiscreteLinearOperator() { }
+   virtual ~ParDiscreteLinearOperator() {}
 };
 
 }
diff --git a/fem/pfespace.cpp b/fem/pfespace.cpp
index 6f0af11c6..d74e08580 100644
--- a/fem/pfespace.cpp
+++ b/fem/pfespace.cpp
@@ -101,8 +101,6 @@ void ParFiniteElementSpace::ParInit(ParMesh *pm)
    P = NULL;
    Pconf = NULL;
    nonconf_P = false;
-   Rconf = NULL;
-   R_transpose = NULL;
    R = NULL;
 
    num_face_nbr_dofs = -1;
@@ -961,6 +959,34 @@ void ParFiniteElementSpace::Build_Dof_TrueDof_Matrix() const // matrix P
    R = Transpose(Pdiag);
 }
 
+const Operator *ParFiniteElementSpace::GetProlongationMatrix() const
+{
+   if (Conforming() && !nd_strias)
+   {
+      if (Pconf) { return Pconf; }
+      if (NRanks == 1)
+      {
+         Pconf = new IdentityOperator(GetTrueVSize());
+      }
+      else
+      {
+         if (!Device::Allows(Backend::DEVICE_MASK))
+         {
+            Pconf = new ConformingProlongationOperator(*this);
+         }
+         else
+         {
+            Pconf = new DeviceConformingProlongationOperator(*this);
+         }
+      }
+      return Pconf;
+   }
+   else
+   {
+      return Dof_TrueDof_Matrix();
+   }
+}
+
 HypreParMatrix *ParFiniteElementSpace::GetPartialConformingInterpolation()
 {
    HypreParMatrix *P_pc;
@@ -1150,76 +1176,6 @@ HYPRE_BigInt ParFiniteElementSpace::GetMyTDofOffset() const
    return HYPRE_AssumedPartitionCheck()? tdof_offsets[0] : tdof_offsets[MyRank];
 }
 
-const Operator *ParFiniteElementSpace::GetProlongationMatrix() const
-{
-   if (Conforming())
-   {
-      if (Pconf) { return Pconf; }
-
-      if (nd_strias) { return Dof_TrueDof_Matrix(); }
-
-      if (NRanks == 1)
-      {
-         Pconf = new IdentityOperator(GetTrueVSize());
-      }
-      else
-      {
-         if (!Device::Allows(Backend::DEVICE_MASK))
-         {
-            Pconf = new ConformingProlongationOperator(*this);
-         }
-         else
-         {
-            Pconf = new DeviceConformingProlongationOperator(*this);
-         }
-      }
-      return Pconf;
-   }
-   else
-   {
-      return Dof_TrueDof_Matrix();
-   }
-}
-
-const Operator *ParFiniteElementSpace::GetRestrictionOperator() const
-{
-   if (Conforming())
-   {
-      if (Rconf) { return Rconf; }
-
-      if (NRanks == 1)
-      {
-         R_transpose = new IdentityOperator(GetTrueVSize());
-      }
-      else
-      {
-         if (!Device::Allows(Backend::DEVICE_MASK))
-         {
-            R_transpose = new ConformingProlongationOperator(*this, true);
-         }
-         else
-         {
-            R_transpose =
-               new DeviceConformingProlongationOperator(*this, true);
-         }
-      }
-      Rconf = new TransposeOperator(R_transpose);
-      return Rconf;
-   }
-   else
-   {
-      Dof_TrueDof_Matrix();
-      R_transpose = new TransposeOperator(R);
-      return R;
-   }
-}
-
-const Operator *ParFiniteElementSpace::GetRestrictionTransposeOperator() const
-{
-   GetRestrictionOperator();
-   return R_transpose;
-}
-
 void ParFiniteElementSpace::ExchangeFaceNbrData()
 {
    if (num_face_nbr_dofs >= 0) { return; }
@@ -3186,8 +3142,6 @@ void ParFiniteElementSpace::Destroy()
 
    delete P; P = NULL;
    delete Pconf; Pconf = NULL;
-   delete Rconf; Rconf = NULL;
-   delete R_transpose; R_transpose = NULL;
    delete R; R = NULL;
 
    delete gcomm; gcomm = NULL;
@@ -3393,8 +3347,8 @@ void ParFiniteElementSpace::UpdateMeshPointer(Mesh *new_mesh)
 }
 
 ConformingProlongationOperator::ConformingProlongationOperator(
-   int lsize, const GroupCommunicator &gc_, bool local_)
-   : gc(gc_), local(local_)
+   int lsize, const GroupCommunicator &gc_)
+   : gc(gc_)
 {
    const Table &group_ldof = gc.GroupLDofTable();
 
@@ -3429,11 +3383,10 @@ const
 }
 
 ConformingProlongationOperator::ConformingProlongationOperator(
-   const ParFiniteElementSpace &pfes, bool local_)
+   const ParFiniteElementSpace &pfes)
    : Operator(pfes.GetVSize(), pfes.GetTrueVSize()),
      external_ldofs(),
-     gc(pfes.GroupComm()),
-     local(local_)
+     gc(pfes.GroupComm())
 {
    MFEM_VERIFY(pfes.Conforming(), "");
    const Table &group_ldof = gc.GroupLDofTable();
@@ -3482,14 +3435,7 @@ void ConformingProlongationOperator::Mult(const Vector &x, Vector &y) const
    const int m = external_ldofs.Size();
 
    const int in_layout = 2; // 2 - input is ltdofs array
-   if (local)
-   {
-      y = 0.0;
-   }
-   else
-   {
-      gc.BcastBegin(const_cast<double*>(xdata), in_layout);
-   }
+   gc.BcastBegin(const_cast<double*>(xdata), in_layout);
 
    int j = 0;
    for (int i = 0; i < m; i++)
@@ -3501,10 +3447,7 @@ void ConformingProlongationOperator::Mult(const Vector &x, Vector &y) const
    std::copy(xdata+j-m, xdata+Width(), ydata+j);
 
    const int out_layout = 0; // 0 - output is ldofs array
-   if (!local)
-   {
-      gc.BcastEnd(ydata, out_layout);
-   }
+   gc.BcastEnd(ydata, out_layout);
 }
 
 void ConformingProlongationOperator::MultTranspose(
@@ -3517,10 +3460,7 @@ void ConformingProlongationOperator::MultTranspose(
    double *ydata = y.HostWrite();
    const int m = external_ldofs.Size();
 
-   if (!local)
-   {
-      gc.ReduceBegin(xdata);
-   }
+   gc.ReduceBegin(xdata);
 
    int j = 0;
    for (int i = 0; i < m; i++)
@@ -3532,15 +3472,12 @@ void ConformingProlongationOperator::MultTranspose(
    std::copy(xdata+j, xdata+Height(), ydata+j-m);
 
    const int out_layout = 2; // 2 - output is an array on all ltdofs
-   if (!local)
-   {
-      gc.ReduceEnd<double>(ydata, out_layout, GroupCommunicator::Sum);
-   }
+   gc.ReduceEnd<double>(ydata, out_layout, GroupCommunicator::Sum);
 }
 
 DeviceConformingProlongationOperator::DeviceConformingProlongationOperator(
-   const GroupCommunicator &gc_, const SparseMatrix *R, bool local_)
-   : ConformingProlongationOperator(R->Width(), gc_, local_),
+   const GroupCommunicator &gc_, const SparseMatrix *R)
+   : ConformingProlongationOperator(R->Width(), gc_),
      mpi_gpu_aware(Device::GetGPUAwareMPI())
 {
    MFEM_ASSERT(R->Finalized(), "");
@@ -3605,10 +3542,9 @@ DeviceConformingProlongationOperator::DeviceConformingProlongationOperator(
 }
 
 DeviceConformingProlongationOperator::DeviceConformingProlongationOperator(
-   const ParFiniteElementSpace &pfes, bool local_)
+   const ParFiniteElementSpace &pfes)
    : DeviceConformingProlongationOperator(pfes.GroupComm(),
-                                          pfes.GetRestrictionMatrix(),
-                                          local_)
+                                          pfes.GetRestrictionMatrix())
 {
    MFEM_ASSERT(pfes.Conforming(), "internal error");
    MFEM_ASSERT(pfes.GetRestrictionMatrix()->Height() == pfes.GetTrueVSize(), "");
@@ -3672,48 +3608,36 @@ void DeviceConformingProlongationOperator::Mult(const Vector &x,
                                                 Vector &y) const
 {
    const GroupTopology &gtopo = gc.GetGroupTopology();
-   int req_counter = 0;
    // Make sure 'y' is marked as valid on device and for use on device.
    // This ensures that there is no unnecessary host to device copy when the
-   // input 'y' is valid on host (in 'y.SetSubVector(ext_ldof, 0.0)' when local
-   // is true) or BcastLocalCopy (when local is false).
+   // input 'y' is valid on host.
    y.Write();
-   if (local)
-   {
-      // done on device since we've marked ext_ldof for use on device:
-      y.SetSubVector(ext_ldof, 0.0);
-   }
-   else
+   BcastBeginCopy(x); // copy to 'shr_buf'
+   int req_counter = 0;
+   for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
    {
-      BcastBeginCopy(x); // copy to 'shr_buf'
-      for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
+      const int send_offset = shr_buf_offsets[nbr];
+      const int send_size = shr_buf_offsets[nbr+1] - send_offset;
+      if (send_size > 0)
       {
-         const int send_offset = shr_buf_offsets[nbr];
-         const int send_size = shr_buf_offsets[nbr+1] - send_offset;
-         if (send_size > 0)
-         {
-            auto send_buf = mpi_gpu_aware ? shr_buf.Read() : shr_buf.HostRead();
-            MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41822,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
-         const int recv_offset = ext_buf_offsets[nbr];
-         const int recv_size = ext_buf_offsets[nbr+1] - recv_offset;
-         if (recv_size > 0)
-         {
-            auto recv_buf = mpi_gpu_aware ? ext_buf.Write() : ext_buf.HostWrite();
-            MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41822,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
+         auto send_buf = mpi_gpu_aware ? shr_buf.Read() : shr_buf.HostRead();
+         MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41822,
+                   gtopo.GetComm(), &requests[req_counter++]);
+      }
+      const int recv_offset = ext_buf_offsets[nbr];
+      const int recv_size = ext_buf_offsets[nbr+1] - recv_offset;
+      if (recv_size > 0)
+      {
+         auto recv_buf = mpi_gpu_aware ? ext_buf.Write() : ext_buf.HostWrite();
+         MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41822,
+                   gtopo.GetComm(), &requests[req_counter++]);
       }
    }
    BcastLocalCopy(x, y);
-   if (!local)
-   {
-      MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
-      BcastEndCopy(y); // copy from 'ext_buf'
-   }
+   MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
+   BcastEndCopy(y); // copy from 'ext_buf'
 }
 
 DeviceConformingProlongationOperator::~DeviceConformingProlongationOperator()
@@ -3774,38 +3698,32 @@ void DeviceConformingProlongationOperator::MultTranspose(const Vector &x,
                                                          Vector &y) const
 {
    const GroupTopology &gtopo = gc.GetGroupTopology();
+   ReduceBeginCopy(x); // copy to 'ext_buf'
    int req_counter = 0;
-   if (!local)
+   for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
    {
-      ReduceBeginCopy(x); // copy to 'ext_buf'
-      for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
+      const int send_offset = ext_buf_offsets[nbr];
+      const int send_size = ext_buf_offsets[nbr+1] - send_offset;
+      if (send_size > 0)
       {
-         const int send_offset = ext_buf_offsets[nbr];
-         const int send_size = ext_buf_offsets[nbr+1] - send_offset;
-         if (send_size > 0)
-         {
-            auto send_buf = mpi_gpu_aware ? ext_buf.Read() : ext_buf.HostRead();
-            MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41823,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
-         const int recv_offset = shr_buf_offsets[nbr];
-         const int recv_size = shr_buf_offsets[nbr+1] - recv_offset;
-         if (recv_size > 0)
-         {
-            auto recv_buf = mpi_gpu_aware ? shr_buf.Write() : shr_buf.HostWrite();
-            MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41823,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
+         auto send_buf = mpi_gpu_aware ? ext_buf.Read() : ext_buf.HostRead();
+         MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41823,
+                   gtopo.GetComm(), &requests[req_counter++]);
+      }
+      const int recv_offset = shr_buf_offsets[nbr];
+      const int recv_size = shr_buf_offsets[nbr+1] - recv_offset;
+      if (recv_size > 0)
+      {
+         auto recv_buf = mpi_gpu_aware ? shr_buf.Write() : shr_buf.HostWrite();
+         MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41823,
+                   gtopo.GetComm(), &requests[req_counter++]);
       }
    }
    ReduceLocalCopy(x, y);
-   if (!local)
-   {
-      MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
-      ReduceEndAssemble(y); // assemble from 'shr_buf'
-   }
+   MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
+   ReduceEndAssemble(y); // assemble from 'shr_buf'
 }
 
 } // namespace mfem
diff --git a/fem/pfespace.hpp b/fem/pfespace.hpp
index 8f574670b..c4a95a365 100644
--- a/fem/pfespace.hpp
+++ b/fem/pfespace.hpp
@@ -70,6 +70,7 @@ private:
 
    /// The matrix P (interpolation from true dof to dof). Owned.
    mutable HypreParMatrix *P;
+
    /// Optimized action-only prolongation operator for conforming meshes. Owned.
    mutable Operator *Pconf;
 
@@ -80,12 +81,6 @@ private:
 
    /// The (block-diagonal) matrix R (restriction of dof to true dof). Owned.
    mutable SparseMatrix *R;
-   /// Optimized action-only restriction operator for conforming meshes. Owned.
-   mutable Operator *Rconf;
-   /** Transpose of R or Rconf. For conforming mesh, this is a matrix-free
-       (Device)ConformingProlongationOperator, for a non-conforming mesh
-       this is a TransposeOperator wrapping R. */
-   mutable Operator *R_transpose;
 
    /// Flag indicating the existence of shared triangles with interior ND dofs
    bool nd_strias;
@@ -321,6 +316,13 @@ public:
    HypreParMatrix *Dof_TrueDof_Matrix() const
    { if (!P) { Build_Dof_TrueDof_Matrix(); } return P; }
 
+   /// Get the P matrix which prolongates a true dof vector to local dof vector.
+   virtual const Operator *GetProlongationMatrix() const;
+
+   /// Get the R matrix which restricts a local dof vector to true dof vector.
+   virtual const SparseMatrix *GetRestrictionMatrix() const
+   { Dof_TrueDof_Matrix(); return R; }
+
    /** @brief For a non-conforming mesh, construct and return the interpolation
        matrix from the partially conforming true dofs to the local dofs. */
    /** @note The returned pointer must be deleted by the caller. */
@@ -374,21 +376,6 @@ public:
    HYPRE_BigInt GetMyDofOffset() const;
    HYPRE_BigInt GetMyTDofOffset() const;
 
-   virtual const Operator *GetProlongationMatrix() const;
-   /** @brief Return logical transpose of restriction matrix, but in
-       non-assembled optimized matrix-free form.
-
-       The implementation is like GetProlongationMatrix, but it sets local
-       DOFs to the true DOF values if owned locally, otherwise zero. */
-   virtual const Operator *GetRestrictionTransposeOperator() const;
-   /** Get an Operator that performs the action of GetRestrictionMatrix(),
-       but potentially with a non-assembled optimized matrix-free
-       implementation. */
-   virtual const Operator *GetRestrictionOperator() const;
-   /// Get the R matrix which restricts a local dof vector to true dof vector.
-   virtual const SparseMatrix *GetRestrictionMatrix() const
-   { Dof_TrueDof_Matrix(); return R; }
-
    // Face-neighbor functions
    void ExchangeFaceNbrData();
    int GetFaceNbrVSize() const { return num_face_nbr_dofs; }
@@ -434,21 +421,17 @@ public:
    int TrueVSize() const { return ltdof_size; }
 };
 
-
 /// Auxiliary class used by ParFiniteElementSpace.
 class ConformingProlongationOperator : public Operator
 {
 protected:
    Array<int> external_ldofs;
    const GroupCommunicator &gc;
-   bool local;
 
 public:
-   ConformingProlongationOperator(int lsize, const GroupCommunicator &gc_,
-                                  bool local_=false);
+   ConformingProlongationOperator(int lsize, const GroupCommunicator &gc_);
 
-   ConformingProlongationOperator(const ParFiniteElementSpace &pfes,
-                                  bool local_=false);
+   ConformingProlongationOperator(const ParFiniteElementSpace &pfes);
 
    const GroupCommunicator &GetGroupCommunicator() const;
 
@@ -458,8 +441,8 @@ public:
 };
 
 /// Auxiliary device class used by ParFiniteElementSpace.
-class DeviceConformingProlongationOperator: public
-   ConformingProlongationOperator
+class DeviceConformingProlongationOperator :
+   public ConformingProlongationOperator
 {
 protected:
    bool mpi_gpu_aware;
@@ -495,11 +478,10 @@ protected:
    void ReduceEndAssemble(Vector &dst) const;
 
 public:
-   DeviceConformingProlongationOperator(
-      const GroupCommunicator &gc_, const SparseMatrix *R, bool local_=false);
+   DeviceConformingProlongationOperator(const GroupCommunicator &gc_,
+                                        const SparseMatrix *R);
 
-   DeviceConformingProlongationOperator(const ParFiniteElementSpace &pfes,
-                                        bool local_=false);
+   DeviceConformingProlongationOperator(const ParFiniteElementSpace &pfes);
 
    virtual ~DeviceConformingProlongationOperator();
 
diff --git a/fem/prestriction.cpp b/fem/prestriction.cpp
index 37dee3c8d..89ce189db 100644
--- a/fem/prestriction.cpp
+++ b/fem/prestriction.cpp
@@ -325,7 +325,7 @@ void ParL2FaceRestriction::DoubleValuedConformingMult(
    auto d_x_shared = Reshape(x_gf.FaceNbrData().Read(),
                              t?vd:nsdofs, t?nsdofs:vd);
    auto d_y = Reshape(y.Write(), nface_dofs, vd, 2, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
    {
       const int dof = i % nface_dofs;
       const int face = i / nface_dofs;
diff --git a/fem/restriction.cpp b/fem/restriction.cpp
index c7343d7c7..e0877606b 100644
--- a/fem/restriction.cpp
+++ b/fem/restriction.cpp
@@ -12,27 +12,24 @@
 #include "restriction.hpp"
 #include "gridfunc.hpp"
 #include "fespace.hpp"
-#include "../general/forall.hpp"
-#include <climits>
-
 #ifdef MFEM_USE_MPI
-
 #include "pfespace.hpp"
-
 #endif
+#include "../general/forall.hpp"
+#include <climits>
 
 namespace mfem
 {
 
-ElementRestriction::ElementRestriction(const FiniteElementSpace &f,
-                                       ElementDofOrdering e_ordering)
+ConformingElementRestriction::ConformingElementRestriction(
+   const FiniteElementSpace &f,
+   ElementDofOrdering e_ordering)
    : fes(f),
      ne(fes.GetNE()),
      vdim(fes.GetVDim()),
      byvdim(fes.GetOrdering() == Ordering::byVDIM),
      ndofs(fes.GetNDofs()),
      dof(ne > 0 ? fes.GetFE(0)->GetDof() : 0),
-     nedofs(ne*dof),
      offsets(ndofs+1),
      indices(ne*dof),
      gather_map(ne*dof)
@@ -104,7 +101,7 @@ ElementRestriction::ElementRestriction(const FiniteElementSpace &f,
    offsets[0] = 0;
 }
 
-void ElementRestriction::Mult(const Vector& x, Vector& y) const
+void ConformingElementRestriction::Mult(const Vector& x, Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -126,7 +123,8 @@ void ElementRestriction::Mult(const Vector& x, Vector& y) const
    });
 }
 
-void ElementRestriction::MultUnsigned(const Vector& x, Vector& y) const
+void ConformingElementRestriction::MultUnsigned(const Vector& x,
+                                                Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -148,12 +146,13 @@ void ElementRestriction::MultUnsigned(const Vector& x, Vector& y) const
 }
 
 template <bool ADD>
-void ElementRestriction::TAddMultTranspose(const Vector& x, Vector& y) const
+static void TAddMultTranspose(const int nd, const int vd, const bool t,
+                              const int ndofs, const int ne,
+                              const Array<int>& offsets,
+                              const Array<int>& indices,
+                              const Vector& x, Vector& y)
 {
    // Assumes all elements have the same number of dofs
-   const int nd = dof;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_offsets = offsets.Read();
    auto d_indices = indices.Read();
    auto d_x = Reshape(x.Read(), nd, vd, ne);
@@ -177,21 +176,23 @@ void ElementRestriction::TAddMultTranspose(const Vector& x, Vector& y) const
    });
 }
 
-void ElementRestriction::MultTranspose(const Vector& x, Vector& y) const
+void ConformingElementRestriction::MultTranspose(const Vector& x,
+                                                 Vector& y) const
 {
    constexpr bool ADD = false;
-   TAddMultTranspose<ADD>(x, y);
+   TAddMultTranspose<ADD>(dof, vdim, byvdim, ndofs, ne, offsets, indices, x, y);
 }
 
-void ElementRestriction::AddMultTranspose(const Vector& x, Vector& y,
-                                          const double a) const
+void ConformingElementRestriction::AddMultTranspose(const Vector& x, Vector& y,
+                                                    const double a) const
 {
    MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    constexpr bool ADD = true;
-   TAddMultTranspose<ADD>(x, y);
+   TAddMultTranspose<ADD>(dof, vdim, byvdim, ndofs, ne, offsets, indices, x, y);
 }
 
-void ElementRestriction::MultTransposeUnsigned(const Vector& x, Vector& y) const
+void ConformingElementRestriction::MultTransposeUnsigned(const Vector& x,
+                                                         Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -218,32 +219,7 @@ void ElementRestriction::MultTransposeUnsigned(const Vector& x, Vector& y) const
    });
 }
 
-void ElementRestriction::MultLeftInverse(const Vector& x, Vector& y) const
-{
-   // Assumes all elements have the same number of dofs
-   const int nd = dof;
-   const int vd = vdim;
-   const bool t = byvdim;
-   auto d_offsets = offsets.Read();
-   auto d_indices = indices.Read();
-   auto d_x = Reshape(x.Read(), nd, vd, ne);
-   auto d_y = Reshape(y.Write(), t?vd:ndofs, t?ndofs:vd);
-   mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
-   {
-      const int next_offset = d_offsets[i + 1];
-      for (int c = 0; c < vd; ++c)
-      {
-         double dof_value = 0;
-         const int j = next_offset - 1;
-         const int idx_j = (d_indices[j] >= 0) ? d_indices[j] : -1 - d_indices[j];
-         dof_value = (d_indices[j] >= 0) ? d_x(idx_j % nd, c, idx_j / nd) :
-                     -d_x(idx_j % nd, c, idx_j / nd);
-         d_y(t?c:i,t?i:c) = dof_value;
-      }
-   });
-}
-
-void ElementRestriction::BooleanMask(Vector& y) const
+void ConformingElementRestriction::BooleanMask(Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -280,8 +256,8 @@ void ElementRestriction::BooleanMask(Vector& y) const
    }
 }
 
-void ElementRestriction::FillSparseMatrix(const Vector &mat_ea,
-                                          SparseMatrix &mat) const
+void ConformingElementRestriction::FillSparseMatrix(const Vector &mat_ea,
+                                                    SparseMatrix &mat) const
 {
    mat.GetMemoryI().New(mat.Height()+1, mat.GetMemoryI().GetMemoryType());
    const int nnz = FillI(mat);
@@ -319,7 +295,7 @@ static MFEM_HOST_DEVICE int GetAndIncrementNnzIndex(const int i_L, int* I)
    return ind;
 }
 
-int ElementRestriction::FillI(SparseMatrix &mat) const
+int ConformingElementRestriction::FillI(SparseMatrix &mat) const
 {
    static constexpr int Max = MaxNbNbr;
    const int all_dofs = ndofs;
@@ -396,8 +372,8 @@ int ElementRestriction::FillI(SparseMatrix &mat) const
    return h_I[nTdofs];
 }
 
-void ElementRestriction::FillJAndData(const Vector &ea_data,
-                                      SparseMatrix &mat) const
+void ConformingElementRestriction::FillJAndData(const Vector &ea_data,
+                                                SparseMatrix &mat) const
 {
    static constexpr int Max = MaxNbNbr;
    const int all_dofs = ndofs;
@@ -523,11 +499,10 @@ void L2ElementRestriction::Mult(const Vector &x, Vector &y) const
 }
 
 template <bool ADD>
-void L2ElementRestriction::TAddMultTranspose(const Vector &x, Vector &y) const
+static void L2TAddMultTranspose(const int nd, const int vd, const bool t,
+                                const int ndofs, const int ne,
+                                const Vector &x, Vector &y)
 {
-   const int nd = ndof;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_x = Reshape(x.Read(), nd, vd, ne);
    auto d_y = Reshape(ADD ? y.ReadWrite() : y.Write(), t?vd:ndofs, t?ndofs:vd);
    mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
@@ -546,7 +521,7 @@ void L2ElementRestriction::TAddMultTranspose(const Vector &x, Vector &y) const
 void L2ElementRestriction::MultTranspose(const Vector &x, Vector &y) const
 {
    constexpr bool ADD = false;
-   TAddMultTranspose<ADD>(x, y);
+   L2TAddMultTranspose<ADD>(ndof, vdim, byvdim, ndofs, ne, x, y);
 }
 
 void L2ElementRestriction::AddMultTranspose(const Vector &x, Vector &y,
@@ -554,7 +529,7 @@ void L2ElementRestriction::AddMultTranspose(const Vector &x, Vector &y,
 {
    MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    constexpr bool ADD = true;
-   TAddMultTranspose<ADD>(x, y);
+   L2TAddMultTranspose<ADD>(ndof, vdim, byvdim, ndofs, ne, x, y);
 }
 
 void L2ElementRestriction::FillI(SparseMatrix &mat) const
@@ -609,7 +584,6 @@ ConformingFaceRestriction::ConformingFaceRestriction(
      byvdim(fes.GetOrdering() == Ordering::byVDIM),
      face_dofs(nf > 0 ? fes.GetFaceElement(0)->GetDof() : 0),
      elem_dofs(fes.GetFE(0)->GetDof()),
-     nfdofs(nf*face_dofs),
      ndofs(fes.GetNDofs()),
      scatter_indices(nf*face_dofs),
      gather_offsets(ndofs+1),
@@ -651,62 +625,102 @@ ConformingFaceRestriction::ConformingFaceRestriction(
    : ConformingFaceRestriction(fes, f_ordering, type, true)
 { }
 
-void ConformingFaceRestriction::Mult(const Vector& x, Vector& y) const
+static void ConformingFaceRestriction_Mult(
+   const int ndofs,
+   const int face_dofs,
+   const int nf,
+   const int vdim,
+   const bool by_vdim,
+   const Array<int> &scatter_indices,
+   const Vector &x,
+   Vector &y,
+   bool use_signs)
 {
    if (nf==0) { return; }
    // Assumes all elements have the same number of dofs
-   const int nface_dofs = face_dofs;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_indices = scatter_indices.Read();
-   auto d_x = Reshape(x.Read(), t?vd:ndofs, t?ndofs:vd);
-   auto d_y = Reshape(y.Write(), nface_dofs, vd, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
-   {
-      const int s_idx = d_indices[i];
-      const int sgn = (s_idx >= 0) ? 1 : -1;
-      const int idx = (s_idx >= 0) ? s_idx : -1 - s_idx;
-      const int dof = i % nface_dofs;
-      const int face = i / nface_dofs;
-      for (int c = 0; c < vd; ++c)
+   auto d_x = Reshape(x.Read(), by_vdim?vdim:ndofs, by_vdim?ndofs:vdim);
+   auto d_y = Reshape(y.Write(), face_dofs, vdim, nf);
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
+   {
+      const int s_idx_j = d_indices[i];
+      const double sgn = (s_idx_j >= 0 || !use_signs) ? 1.0 : -1.0;
+      const int idx_j = (s_idx_j >= 0) ? s_idx_j : -1 - s_idx_j;
+      for (int c = 0; c < vdim; ++c)
       {
-         d_y(dof, c, face) = sgn*d_x(t?c:idx, t?idx:c);
+         d_y(i % face_dofs, c, i / face_dofs) =
+            sgn*d_x(by_vdim?c:idx_j, by_vdim?idx_j:c);
       }
    });
 }
 
-void ConformingFaceRestriction::AddMultTranspose(
-   const Vector& x, Vector& y, const double a) const
+void ConformingFaceRestriction::Mult(const Vector& x, Vector& y) const
+{
+   ConformingFaceRestriction_Mult(
+      ndofs, face_dofs, nf, vdim, byvdim, scatter_indices, x, y, true);
+}
+
+void ConformingFaceRestriction::MultUnsigned(const Vector& x, Vector& y) const
+{
+   ConformingFaceRestriction_Mult(
+      ndofs, face_dofs, nf, vdim, byvdim, scatter_indices, x, y, false);
+}
+
+static void ConformingFaceRestriction_AddMultTranspose(
+   const int ndofs,
+   const int face_dofs,
+   const int nf,
+   const int vdim,
+   const bool by_vdim,
+   const Array<int> &gather_offsets,
+   const Array<int> &gather_indices,
+   const Vector &x,
+   Vector &y,
+   bool use_signs,
+   const double a)
 {
    MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    if (nf==0) { return; }
    // Assumes all elements have the same number of dofs
-   const int nface_dofs = face_dofs;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_offsets = gather_offsets.Read();
    auto d_indices = gather_indices.Read();
-   auto d_x = Reshape(x.Read(), nface_dofs, vd, nf);
-   auto d_y = Reshape(y.ReadWrite(), t?vd:ndofs, t?ndofs:vd);
+   auto d_x = Reshape(x.Read(), face_dofs, vdim, nf);
+   auto d_y = Reshape(y.ReadWrite(), by_vdim?vdim:ndofs, by_vdim?ndofs:vdim);
    mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
    {
       const int offset = d_offsets[i];
       const int next_offset = d_offsets[i + 1];
-      for (int c = 0; c < vd; ++c)
+      for (int c = 0; c < vdim; ++c)
       {
          double dof_value = 0;
          for (int j = offset; j < next_offset; ++j)
          {
             const int s_idx_j = d_indices[j];
-            const int sgn = (s_idx_j >= 0) ? 1 : -1;
+            const double sgn = (s_idx_j >= 0 || !use_signs) ? 1.0 : -1.0;
             const int idx_j = (s_idx_j >= 0) ? s_idx_j : -1 - s_idx_j;
-            dof_value += sgn*d_x(idx_j % nface_dofs, c, idx_j / nface_dofs);
+            dof_value += sgn*d_x(idx_j % face_dofs, c, idx_j / face_dofs);
          }
-         d_y(t?c:i,t?i:c) += dof_value;
+         d_y(by_vdim?c:i,by_vdim?i:c) += dof_value;
       }
    });
 }
 
+void ConformingFaceRestriction::AddMultTranspose(
+   const Vector& x, Vector& y, const double a) const
+{
+   ConformingFaceRestriction_AddMultTranspose(
+      ndofs, face_dofs, nf, vdim, byvdim, gather_offsets, gather_indices, x, y,
+      true, a);
+}
+
+void ConformingFaceRestriction::AddMultTransposeUnsigned(
+   const Vector& x, Vector& y, const double a) const
+{
+   ConformingFaceRestriction_AddMultTranspose(
+      ndofs, face_dofs, nf, vdim, byvdim, gather_offsets, gather_indices, x, y,
+      false, a);
+}
+
 void ConformingFaceRestriction::CheckFESpace(const ElementDofOrdering
                                              f_ordering)
 {
@@ -1019,7 +1033,6 @@ L2FaceRestriction::L2FaceRestriction(const FiniteElementSpace &fes,
                fes.GetTraceElement(0, fes.GetMesh()->GetFaceGeometry(0))->GetDof()
                : 0),
      elem_dofs(fes.GetFE(0)->GetDof()),
-     nfdofs(nf*face_dofs),
      ndofs(fes.GetNDofs()),
      type(type),
      m(m),
@@ -1060,7 +1073,7 @@ void L2FaceRestriction::SingleValuedConformingMult(const Vector& x,
    auto d_indices1 = scatter_indices1.Read();
    auto d_x = Reshape(x.Read(), t?vd:ndofs, t?ndofs:vd);
    auto d_y = Reshape(y.Write(), nface_dofs, vd, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
    {
       const int dof = i % nface_dofs;
       const int face = i / nface_dofs;
@@ -1086,7 +1099,7 @@ void L2FaceRestriction::DoubleValuedConformingMult(const Vector& x,
    auto d_indices2 = scatter_indices2.Read();
    auto d_x = Reshape(x.Read(), t?vd:ndofs, t?ndofs:vd);
    auto d_y = Reshape(y.Write(), nface_dofs, vd, 2, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
    {
       const int dof = i % nface_dofs;
       const int face = i / nface_dofs;
@@ -1137,7 +1150,7 @@ void L2FaceRestriction::SingleValuedConformingAddMultTranspose(
          for (int j = offset; j < next_offset; ++j)
          {
             int idx_j = d_indices[j];
-            dof_value +=  d_x(idx_j % nface_dofs, c, idx_j / nface_dofs);
+            dof_value += d_x(idx_j % nface_dofs, c, idx_j / nface_dofs);
          }
          d_y(t?c:i,t?i:c) += dof_value;
       }
@@ -1151,7 +1164,7 @@ void L2FaceRestriction::DoubleValuedConformingAddMultTranspose(
    const int nface_dofs = face_dofs;
    const int vd = vdim;
    const bool t = byvdim;
-   const int dofs = nfdofs;
+   const int dofs = face_dofs*nf;
    auto d_offsets = gather_offsets.Read();
    auto d_indices = gather_indices.Read();
    auto d_x = Reshape(x.Read(), nface_dofs, vd, 2, nf);
@@ -1168,9 +1181,8 @@ void L2FaceRestriction::DoubleValuedConformingAddMultTranspose(
             int idx_j = d_indices[j];
             bool isE1 = idx_j < dofs;
             idx_j = isE1 ? idx_j : idx_j - dofs;
-            dof_value +=  isE1 ?
-                          d_x(idx_j % nface_dofs, c, 0, idx_j / nface_dofs)
-                          :d_x(idx_j % nface_dofs, c, 1, idx_j / nface_dofs);
+            dof_value += (isE1 ? d_x(idx_j % nface_dofs, c, 0, idx_j / nface_dofs)
+                          : d_x(idx_j % nface_dofs, c, 1, idx_j / nface_dofs));
          }
          d_y(t?c:i,t?i:c) += dof_value;
       }
@@ -1565,7 +1577,7 @@ void L2FaceRestriction::PermuteAndSetFaceDofsGatherIndices2(
       const int global_dof_elem2 = elem_map[elem_index*elem_dofs + volume_dof_elem2];
       const int restriction_dof_elem2 = face_dofs*face_index + face_dof_elem1;
       // We shift restriction_dof_elem2 to express that it's elem2 of the face
-      gather_indices[gather_offsets[global_dof_elem2]++] = nfdofs +
+      gather_indices[gather_offsets[global_dof_elem2]++] = face_dofs*nf +
                                                            restriction_dof_elem2;
    }
 }
diff --git a/fem/restriction.hpp b/fem/restriction.hpp
index 617305541..7eb6eaede 100644
--- a/fem/restriction.hpp
+++ b/fem/restriction.hpp
@@ -22,19 +22,44 @@ class FiniteElementSpace;
 enum class ElementDofOrdering;
 
 /// Abstract base class that defines an interface for element restrictions.
-class ElementRestrictionOperator : public Operator
+class ElementRestriction : public Operator
 {
 public:
-   /// @brief Add the E-vector degrees of freedom @a x to the L-vector degrees
-   /// of freedom @a y.
+   /** @brief Extract the degrees of freedom from @a x into @a y. */
+   void Mult(const Vector &x, Vector &y) const override = 0;
+
+   /** @brief Set the degrees of freedom in the element degrees of freedom
+       @a y to the values given in @a x. */
+   void MultTranspose(const Vector &x, Vector &y) const override
+   {
+      y = 0.0;
+      AddMultTranspose(x, y);
+   }
+
+   /** @brief Add the degrees of freedom @a x to the element degrees of
+       freedom @a y. */
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override = 0;
+
+   /** @brief Add the degrees of freedom @a x to the element degrees of
+       freedom @a y ignoring the signs from DOF orientation. */
+   virtual void MultUnsigned(const Vector &x, Vector &y) const
+   {
+      Mult(x, y);
+   }
+
+   /** @brief Add the degrees of freedom @a x to the element degrees of
+       freedom @a y ignoring the signs from DOF orientation. */
+   virtual void MultTransposeUnsigned(const Vector &x, Vector &y) const
+   {
+      MultTranspose(x, y);
+   }
 };
 
 /// Operator that converts FiniteElementSpace L-vectors to E-vectors.
 /** Objects of this type are typically created and owned by FiniteElementSpace
     objects, see FiniteElementSpace::GetElementRestriction(). */
-class ElementRestriction : public ElementRestrictionOperator
+class ConformingElementRestriction : public ElementRestriction
 {
 private:
    /** This number defines the maximum number of elements any dof can belong to
@@ -48,7 +73,6 @@ protected:
    const bool byvdim;
    const int ndofs;
    const int dof;
-   const int nedofs;
    Array<int> offsets;
    Array<int> indices;
    Array<int> gather_map;
@@ -65,20 +89,18 @@ protected:
    ///@}
 
 public:
-   ElementRestriction(const FiniteElementSpace&, ElementDofOrdering);
+   ConformingElementRestriction(const FiniteElementSpace&, ElementDofOrdering);
+
    void Mult(const Vector &x, Vector &y) const override;
+
    void MultTranspose(const Vector &x, Vector &y) const override;
+
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override;
 
-   /// Compute Mult without applying signs based on DOF orientations.
-   void MultUnsigned(const Vector &x, Vector &y) const;
-   /// Compute MultTranspose without applying signs based on DOF orientations.
-   void MultTransposeUnsigned(const Vector &x, Vector &y) const;
+   void MultUnsigned(const Vector &x, Vector &y) const override;
 
-   /// Compute MultTranspose by setting (rather than adding) element
-   /// contributions; this is a left inverse of the Mult() operation
-   void MultLeftInverse(const Vector &x, Vector &y) const;
+   void MultTransposeUnsigned(const Vector &x, Vector &y) const override;
 
    /// @brief Fills the E-vector y with `boolean` values 0.0 and 1.0 such that each
    /// each entry of the L-vector is uniquely represented in `y`.
@@ -92,16 +114,13 @@ public:
    void FillSparseMatrix(const Vector &mat_ea, SparseMatrix &mat) const;
 
    /** Fill the I array of SparseMatrix corresponding to the sparsity pattern
-       given by this ElementRestriction. */
+       given by this ConformingElementRestriction. */
    int FillI(SparseMatrix &mat) const;
+
    /** Fill the J and Data arrays of SparseMatrix corresponding to the sparsity
-       pattern given by this ElementRestriction, and the values of ea_data. */
+       pattern given by this ConformingElementRestriction, and the values of
+       ea_data. */
    void FillJAndData(const Vector &ea_data, SparseMatrix &mat) const;
-   /// @private Not part of the public interface (device kernel limitation).
-   ///
-   /// Performs either MultTranspose or AddMultTranspose depending on the
-   /// boolean template parameter @a ADD.
-   template <bool ADD> void TAddMultTranspose(const Vector &x, Vector &y) const;
 };
 
 /// Operator that converts L2 FiniteElementSpace L-vectors to E-vectors.
@@ -109,37 +128,39 @@ public:
     objects, see FiniteElementSpace::GetElementRestriction(). L-vectors
     corresponding to grid functions in L2 finite element spaces differ from
     E-vectors only in the ordering of the degrees of freedom. */
-class L2ElementRestriction : public ElementRestrictionOperator
+class L2ElementRestriction : public ElementRestriction
 {
+private:
    const int ne;
    const int vdim;
    const bool byvdim;
    const int ndof;
    const int ndofs;
+
 public:
    L2ElementRestriction(const FiniteElementSpace&);
+
    void Mult(const Vector &x, Vector &y) const override;
+
    void MultTranspose(const Vector &x, Vector &y) const override;
+
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override;
+
    /** Fill the I array of SparseMatrix corresponding to the sparsity pattern
        given by this ElementRestriction. */
    void FillI(SparseMatrix &mat) const;
+
    /** Fill the J and Data arrays of SparseMatrix corresponding to the sparsity
        pattern given by this L2FaceRestriction, and the values of ea_data. */
    void FillJAndData(const Vector &ea_data, SparseMatrix &mat) const;
-   /// @private Not part of the public interface (device kernel limitation).
-   ///
-   /// Performs either MultTranspose or AddMultTranspose depending on the
-   /// boolean template parameter @a ADD.
-   template <bool ADD> void TAddMultTranspose(const Vector &x, Vector &y) const;
 };
 
 /** An enum type to specify if only e1 value is requested (SingleValued) or both
     e1 and e2 (DoubleValued). */
 enum class L2FaceValues : bool {SingleValued, DoubleValued};
 
-/** @brief Base class for operators that extracts Face degrees of freedom.
+/** @brief Abstract base class for operators that extracts Face degrees of freedom.
 
     In order to compute quantities on the faces of a mesh, it is often useful to
     extract the degrees of freedom on the faces of the elements. This class
@@ -177,6 +198,19 @@ public:
    */
    void Mult(const Vector &x, Vector &y) const override = 0;
 
+   /** @brief Set the face degrees of freedom in the element degrees of freedom
+       @a y to the values given in @a x.
+
+       @param[in]     x The face degrees of freedom on the face.
+       @param[in,out] y The L-vector of degrees of freedom to which we add the
+                        face degrees of freedom.
+   */
+   void MultTranspose(const Vector &x, Vector &y) const override
+   {
+      y = 0.0;
+      AddMultTranspose(x, y);
+   }
+
    /** @brief Add the face degrees of freedom @a x to the element degrees of
        freedom @a y.
 
@@ -185,14 +219,29 @@ public:
                         face degrees of freedom.
        @param[in]     a Scalar coefficient for addition.
    */
-   virtual void AddMultTranspose(const Vector &x, Vector &y,
-                                 const double a = 1.0) const override = 0;
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override = 0;
+
+   /** @brief Extract the face degrees of freedom from @a x into @a y ignoring
+       the signs from DOF orientation. */
+   virtual void MultUnsigned(const Vector &x, Vector &y) const
+   {
+      Mult(x, y);
+   }
+
+   /** @brief Add the face degrees of freedom @a x to the element degrees of
+       freedom @a y ignoring the signs from DOF orientation. */
+   virtual void AddMultTransposeUnsigned(const Vector &x, Vector &y,
+                                         const double a = 1.0) const
+   {
+      AddMultTranspose(x, y, a);
+   }
 
    /** @brief Add the face degrees of freedom @a x to the element degrees of
        freedom @a y. Perform the same computation as AddMultTranspose, but
        @a x is invalid after calling this method.
 
-       @param[in,out]     x The face degrees of freedom on the face.
+       @param[in,out] x The face degrees of freedom on the face.
        @param[in,out] y The L-vector of degrees of freedom to which we add the
                         face degrees of freedom.
 
@@ -203,19 +252,6 @@ public:
    {
       AddMultTranspose(x, y);
    }
-
-   /** @brief Set the face degrees of freedom in the element degrees of freedom
-       @a y to the values given in @a x.
-
-       @param[in]     x The face degrees of freedom on the face.
-       @param[in,out] y The L-vector of degrees of freedom to which we add the
-                        face degrees of freedom.
-   */
-   void MultTranspose(const Vector &x, Vector &y) const override
-   {
-      y = 0.0;
-      AddMultTranspose(x, y);
-   }
 };
 
 /// @brief Operator that extracts face degrees of freedom for H1, ND, or RT
@@ -232,7 +268,6 @@ protected:
    const bool byvdim;
    const int face_dofs; // Number of dofs on each face
    const int elem_dofs; // Number of dofs in each element
-   const int nfdofs; // Total number of face E-vector dofs
    const int ndofs; // Total number of dofs
    Array<int> scatter_indices; // Scattering indices for element 1 on each face
    Array<int> gather_offsets; // offsets for the gathering indices of each dof
@@ -252,6 +287,7 @@ protected:
                              const ElementDofOrdering f_ordering,
                              const FaceType type,
                              bool build);
+
 public:
    /** @brief Construct a ConformingFaceRestriction.
 
@@ -274,22 +310,33 @@ public:
                      ElementDofOrdering. */
    void Mult(const Vector &x, Vector &y) const override;
 
-   using FaceRestriction::AddMultTransposeInPlace;
+   /** @brief Extract the face degrees of freedom from @a x into @a y ignoring
+       the signs from DOF orientation.
+
+       @sa Mult(). */
+   void MultUnsigned(const Vector &x, Vector &y) const override;
 
    /** @brief Gather the degrees of freedom, i.e. goes from face E-Vector to
        L-Vector.
 
-       @param[in]  x The face E-Vector degrees of freedom with the given format:
-                     face_dofs x vdim x nf
-                     where nf is the number of interior or boundary faces
-                     requested by @a type in the constructor.
-                     The face_dofs should be ordered according to the given
-                     ElementDofOrdering
+       @param[in]     x The face E-Vector degrees of freedom with the given format:
+                        face_dofs x vdim x nf
+                        where nf is the number of interior or boundary faces
+                        requested by @a type in the constructor.
+                        The face_dofs should be ordered according to the given
+                        ElementDofOrdering
        @param[in,out] y The L-vector degrees of freedom.
-       @param[in]  a Scalar coefficient for addition. */
+       @param[in]     a Scalar coefficient for addition. */
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override;
 
+   /** @brief Gather the degrees of freedom, i.e. goes from face E-Vector to
+       L-Vector @b not taking into account signs from DOF orientations.
+
+       @sa AddMultTranspose(). */
+   void AddMultTransposeUnsigned(const Vector &x, Vector &y,
+                                 const double a = 1.0) const override;
+
 private:
    /** @brief Compute the scatter indices: L-vector to E-vector, and the offsets
        for the gathering: E-vector to L-vector.
@@ -360,7 +407,6 @@ protected:
    const bool byvdim;
    const int face_dofs; // Number of dofs on each face
    const int elem_dofs; // Number of dofs in each element
-   const int nfdofs; // Total number of dofs on the faces
    const int ndofs; // Total number of dofs
    const FaceType type;
    const L2FaceValues m;
@@ -412,8 +458,6 @@ public:
                      ElementDofOrdering. */
    void Mult(const Vector &x, Vector &y) const override;
 
-   using FaceRestriction::AddMultTranspose;
-
    /** @brief Gather the degrees of freedom, i.e. goes from face E-Vector to
        L-Vector.
 
@@ -810,6 +854,7 @@ protected:
                        const FaceType type,
                        const L2FaceValues m,
                        bool build);
+
 public:
    /** @brief Constructs an NCL2FaceRestriction, this is a specialization of a
        L2FaceRestriction for nonconforming meshes.
diff --git a/fem/transfer.cpp b/fem/transfer.cpp
index 68dab72d5..7f95ca9fe 100644
--- a/fem/transfer.cpp
+++ b/fem/transfer.cpp
@@ -92,9 +92,9 @@ const Operator &GridTransfer::MakeTrueOperator(
    else // Parallel() == true
    {
 #ifdef MFEM_USE_MPI
+      const SparseMatrix *out_R = fes_out.GetRestrictionMatrix();
       if (oper_type == Operator::Hypre_ParCSR)
       {
-         const SparseMatrix *out_R = fes_out.GetRestrictionMatrix();
          const ParFiniteElementSpace *pfes_in =
             dynamic_cast<const ParFiniteElementSpace *>(&fes_in);
          const ParFiniteElementSpace *pfes_out =
@@ -122,7 +122,6 @@ const Operator &GridTransfer::MakeTrueOperator(
       }
       else if (oper_type == Operator::ANY_TYPE)
       {
-         const Operator *out_R = fes_out.GetRestrictionOperator();
          t_oper.Reset(new TripleProductOperator(
                          out_R, &oper, fes_in.GetProlongationMatrix(),
                          false, false, false));
@@ -1159,12 +1158,12 @@ TensorProductPRefinementTransferOperator(
    localL.UseDevice(true);
    localH.UseDevice(true);
 
-   MFEM_VERIFY(dynamic_cast<const ElementRestriction*>(elem_restrict_lex_h),
+   const auto *elem_restrict =
+      dynamic_cast<const ConformingElementRestriction*>(elem_restrict_lex_h);
+   MFEM_VERIFY(elem_restrict,
                "High order element restriction is of unsupported type");
-
    mask.SetSize(localH.Size(), Device::GetMemoryType());
-   static_cast<const ElementRestriction*>(elem_restrict_lex_h)
-   ->BooleanMask(mask);
+   elem_restrict->BooleanMask(mask);
    mask.UseDevice(true);
 }
 
diff --git a/general/communication.hpp b/general/communication.hpp
index 474486f1b..c7d00f1e4 100644
--- a/general/communication.hpp
+++ b/general/communication.hpp
@@ -217,7 +217,6 @@ protected:
    int group_buf_size;
    mutable Array<char> group_buf;
    MPI_Request *requests;
-   // MPI_Status  *statuses;
    // comm_lock: 0 - no lock, 1 - locked for Bcast, 2 - locked for Reduce
    mutable int comm_lock;
    mutable int num_requests;
diff --git a/general/version.cpp b/general/version.cpp
index d2b05f8ed..f4c402d51 100644
--- a/general/version.cpp
+++ b/general/version.cpp
@@ -103,9 +103,6 @@ const char *GetConfigStr()
 #ifdef MFEM_USE_LAPACK
       "MFEM_USE_LAPACK\n"
 #endif
-#ifdef MFEM_USE_LEGACY_OPENMP
-      "MFEM_USE_LEGACY_OPENMP\n"
-#endif
 #ifdef MFEM_USE_LIBUNWIND
       "MFEM_USE_LIBUNWIND\n"
 #endif
diff --git a/linalg/auxiliary.cpp b/linalg/auxiliary.cpp
index 003e52695..bcb55ca3e 100644
--- a/linalg/auxiliary.cpp
+++ b/linalg/auxiliary.cpp
@@ -171,7 +171,6 @@ MatrixFreeAuxiliarySpace::MatrixFreeAuxiliarySpace(
    {
       a_lor.AddDomainIntegrator(new VectorMassIntegrator);
    }
-   a_lor.UsePrecomputedSparsity();
    a_lor.Assemble();
    a_lor.EliminateEssentialBC(ess_bdr, policy);
    a_lor.Finalize();
@@ -244,7 +243,6 @@ MatrixFreeAuxiliarySpace::MatrixFreeAuxiliarySpace(
    {
       a_lor.AddDomainIntegrator(new DiffusionIntegrator);
    }
-   a_lor.UsePrecomputedSparsity();
    a_lor.Assemble();
    if (ess_bdr.Size())
    {
@@ -460,14 +458,14 @@ MatrixFreeAMS::MatrixFreeAMS(
    pa_grad->SetAssemblyLevel(AssemblyLevel::PARTIAL);
    pa_grad->AddDomainInterpolator(new GradientInterpolator);
    pa_grad->Assemble();
-   pa_grad->FormRectangularSystemMatrix(Gradient);
+   pa_grad->FormDiscreteOperatorMatrix(Gradient);
 
    // build Pi operator
    pa_interp = new ParDiscreteLinearOperator(h1_fespace_d, &nd_fespace);
    pa_interp->SetAssemblyLevel(AssemblyLevel::PARTIAL);
    pa_interp->AddDomainInterpolator(new IdentityInterpolator);
    pa_interp->Assemble();
-   pa_interp->FormRectangularSystemMatrix(Pi);
+   pa_interp->FormDiscreteOperatorMatrix(Pi);
 
    // build LOR space
    ParMesh mesh_lor = ParMesh::MakeRefined(*mesh, order, BasisType::GaussLobatto);
diff --git a/linalg/handle.hpp b/linalg/handle.hpp
index 818294985..96f658d6a 100644
--- a/linalg/handle.hpp
+++ b/linalg/handle.hpp
@@ -207,7 +207,6 @@ public:
                     const Vector &X, Vector &B) const;
 };
 
-
 /// Add an alternative name for OperatorHandle -- OperatorPtr.
 typedef OperatorHandle OperatorPtr;
 
diff --git a/linalg/hypre.hpp b/linalg/hypre.hpp
index 913bdb2d0..3d5b4b2fe 100644
--- a/linalg/hypre.hpp
+++ b/linalg/hypre.hpp
@@ -720,7 +720,7 @@ public:
 
    /** @brief The "Boolean" analog of y = alpha * A * x + beta * y, where
        elements in the sparsity pattern of the matrix are treated as "true". */
-   void BooleanMult(int alpha, const int *x, int beta, int *y)
+   void BooleanMult(int alpha, const int *x, int beta, int *y) const
    {
       HostRead();
       internal::hypre_ParCSRMatrixBooleanMatvec(A, alpha, const_cast<int*>(x),
@@ -730,7 +730,7 @@ public:
 
    /** @brief The "Boolean" analog of y = alpha * A^T * x + beta * y, where
        elements in the sparsity pattern of the matrix are treated as "true". */
-   void BooleanMultTranspose(int alpha, const int *x, int beta, int *y)
+   void BooleanMultTranspose(int alpha, const int *x, int beta, int *y) const
    {
       HostRead();
       internal::hypre_ParCSRMatrixBooleanMatvecT(A, alpha, const_cast<int*>(x),
diff --git a/linalg/operator.cpp b/linalg/operator.cpp
index 1f214ece7..64f75c8a4 100644
--- a/linalg/operator.cpp
+++ b/linalg/operator.cpp
@@ -165,7 +165,7 @@ void Operator::RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x)
    }
 }
 
-Operator * Operator::SetupRAP(const Operator *Pi, const Operator *Po)
+Operator *Operator::SetupRAP(const Operator *Pi, const Operator *Po)
 {
    Operator *rap;
    if (!IsIdentityProlongation(Pi))
@@ -176,15 +176,15 @@ Operator * Operator::SetupRAP(const Operator *Pi, const Operator *Po)
       }
       else
       {
-         rap = new ProductOperator(this, Pi, false,false);
+         rap = new ProductOperator(this, Pi, false, false);
       }
    }
    else
    {
       if (!IsIdentityProlongation(Po))
       {
-         TransposeOperator * PoT = new TransposeOperator(Po);
-         rap = new ProductOperator(PoT, this, true,false);
+         TransposeOperator *PoT = new TransposeOperator(Po);
+         rap = new ProductOperator(PoT, this, true, false);
       }
       else
       {
@@ -245,10 +245,10 @@ void Operator::FormDiscreteOperator(Operator* &Aout)
 {
    const Operator *Pin  = this->GetProlongation();
    const Operator *Rout = this->GetOutputRestriction();
-   Aout = new TripleProductOperator(Rout, this, Pin,false, false, false);
+   Aout = new TripleProductOperator(Rout, this, Pin, false, false, false);
 }
 
-void Operator::PrintMatlab(std::ostream & os, int n, int m) const
+void Operator::PrintMatlab(std::ostream &os, int n, int m) const
 {
    using namespace std;
    if (n == 0) { n = width; }
diff --git a/linalg/operator.hpp b/linalg/operator.hpp
index baa9bf767..cdf700e17 100644
--- a/linalg/operator.hpp
+++ b/linalg/operator.hpp
@@ -29,8 +29,8 @@ protected:
 
    /// see FormSystemOperator()
    /** @note Uses DiagonalPolicy::DIAG_ONE. */
-   void FormConstrainedSystemOperator(
-      const Array<int> &ess_tdof_list, ConstrainedOperator* &Aout);
+   void FormConstrainedSystemOperator(const Array<int> &ess_tdof_list,
+                                      ConstrainedOperator* &Aout);
 
    /// see FormRectangularSystemOperator()
    void FormRectangularConstrainedSystemOperator(
@@ -38,10 +38,6 @@ protected:
       const Array<int> &test_tdof_list,
       RectangularConstrainedOperator* &Aout);
 
-   /** @brief Returns RAP Operator of this, using input/output Prolongation matrices
-       @a Pi corresponds to "P", @a Po corresponds to "Rt" */
-   Operator *SetupRAP(const Operator *Pi, const Operator *Po);
-
 public:
    /// Defines operator diagonal policy upon elimination of rows and/or columns.
    enum DiagonalPolicy
@@ -149,12 +145,6 @@ public:
       return GetProlongation(); // Assume square unless specialized
    }
 
-   /** @brief Transpose of GetOutputRestriction, directly available in this
-       form to facilitate matrix-free RAP-type operators.
-
-       `NULL` means identity. */
-   virtual const Operator *GetOutputRestrictionTranspose() const { return NULL; }
-
    /** @brief Restriction operator from output vectors for the operator to linear
        algebra (linear system) vectors. `NULL` means identity. */
    virtual const Operator *GetOutputRestriction() const
@@ -239,6 +229,10 @@ public:
        forms, though currently @a b is not used in the implementation. */
    virtual void RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x);
 
+   /** @brief Returns RAP Operator of this, using input/output Prolongation matrices
+       @a Pi corresponds to "P", @a Po corresponds to "Rt" */
+   Operator *SetupRAP(const Operator *Pi, const Operator *Po);
+
    /** @brief Return in @a A a parallel (on truedofs) version of this square
        operator.
 
@@ -270,10 +264,10 @@ public:
    void FormDiscreteOperator(Operator* &A);
 
    /// Prints operator with input size n and output size m in Matlab format.
-   void PrintMatlab(std::ostream & out, int n, int m = 0) const;
+   void PrintMatlab(std::ostream &out, int n, int m = 0) const;
 
    /// Prints operator in Matlab format.
-   virtual void PrintMatlab(std::ostream & out) const;
+   virtual void PrintMatlab(std::ostream &out) const;
 
    /// Virtual destructor.
    virtual ~Operator() { }
@@ -722,6 +716,7 @@ inline bool IsIdentityProlongation(const Operator *P)
    return !P || dynamic_cast<const IdentityOperator*>(P);
 }
 
+
 /// Scaled Operator B: x -> a A(x).
 class ScaledOperator : public Operator
 {
@@ -928,6 +923,7 @@ public:
    virtual ~ConstrainedOperator() { if (own_A) { delete A; } }
 };
 
+
 /** @brief Rectangular Operator for imposing essential boundary conditions on
     the input space using only the action, Mult(), of a given unconstrained
     Operator.
@@ -981,6 +977,7 @@ public:
    virtual ~RectangularConstrainedOperator() { if (own_A) { delete A; } }
 };
 
+
 /** @brief PowerMethod helper class to estimate the largest eigenvalue of an
            operator using the iterative power method. */
 class PowerMethod
diff --git a/linalg/solvers.hpp b/linalg/solvers.hpp
index 085cea616..434864042 100644
--- a/linalg/solvers.hpp
+++ b/linalg/solvers.hpp
@@ -276,8 +276,11 @@ public:
 
    ///@}
 
-   /// This should be called before SetOperator
+   /// This should be called before SetOperator if you want SetOperator to
+   /// set both the solver and preconditioner operators together
    virtual void SetPreconditioner(Solver &pr);
+   void SetPreconditioner(Solver *pr)
+   { if (pr) { SetPreconditioner(*pr); } else { prec = nullptr; } }
 
    /// Also calls SetOperator for the preconditioner if there is one
    virtual void SetOperator(const Operator &op) override;
diff --git a/linalg/sparsemat.cpp b/linalg/sparsemat.cpp
index 145379c00..e55ea47b4 100644
--- a/linalg/sparsemat.cpp
+++ b/linalg/sparsemat.cpp
@@ -764,7 +764,6 @@ void SparseMatrix::AddMult(const Vector &x, Vector &y, const double a) const
       return;
    }
 
-#ifndef MFEM_USE_LEGACY_OPENMP
    const int height = this->height;
    const int nnz = J.Capacity();
    auto d_I = Read(I, height+1);
@@ -885,24 +884,6 @@ void SparseMatrix::AddMult(const Vector &x, Vector &y, const double a) const
       });
 
    }
-
-#else // MFEM_USE_LEGACY_OPENMP
-   const double *Ap = A, *xp = x.GetData();
-   double *yp = y.GetData();
-   const int *Jp = J, *Ip = I;
-
-   #pragma omp parallel for
-   for (int i = 0; i < height; i++)
-   {
-      double d = 0.0;
-      const int end = Ip[i+1];
-      for (int j = Ip[i]; j < end; j++)
-      {
-         d += Ap[j] * xp[Jp[j]];
-      }
-      yp[i] += a * d;
-   }
-#endif // MFEM_USE_LEGACY_OPENMP
 }
 
 void SparseMatrix::MultTranspose(const Vector &x, Vector &y) const
diff --git a/linalg/vector.cpp b/linalg/vector.cpp
index 4951ed914..db1a93666 100644
--- a/linalg/vector.cpp
+++ b/linalg/vector.cpp
@@ -113,9 +113,6 @@ const double &Vector::Elem(int i) const
 double Vector::operator*(const double *v) const
 {
    double dot = 0.0;
-#ifdef MFEM_USE_LEGACY_OPENMP
-   #pragma omp parallel for reduction(+:dot)
-#endif
    for (int i = 0; i < size; i++)
    {
       dot += data[i] * v[i];
@@ -313,12 +310,19 @@ void Vector::Neg()
    mfem::forall_switch(use_dev, N, [=] MFEM_HOST_DEVICE (int i) { y[i] = -y[i]; });
 }
 
+void Vector::Reciprocal()
+{
+   const bool use_dev = UseDevice();
+   const int N = size;
+   auto y = ReadWrite(use_dev);
+   mfem::forall_switch(use_dev, N, [=] MFEM_HOST_DEVICE (int i) { y[i] = 1.0/y[i]; });
+}
+
 void add(const Vector &v1, const Vector &v2, Vector &v)
 {
    MFEM_ASSERT(v.size == v1.size && v.size == v2.size,
                "incompatible Vectors!");
 
-#if !defined(MFEM_USE_LEGACY_OPENMP)
    const bool use_dev = v1.UseDevice() || v2.UseDevice() || v.UseDevice();
    const int N = v.size;
    // Note: get read access first, in case v is the same as v1/v2.
@@ -326,13 +330,6 @@ void add(const Vector &v1, const Vector &v2, Vector &v)
    auto x2 = v2.Read(use_dev);
    auto y = v.Write(use_dev);
    mfem::forall_switch(use_dev, N, [=] MFEM_HOST_DEVICE (int i) { y[i] = x1[i] + x2[i]; });
-#else
-   #pragma omp parallel for
-   for (int i = 0; i < v.size; i++)
-   {
-      v.data[i] = v1.data[i] + v2.data[i];
-   }
-#endif
 }
 
 void add(const Vector &v1, double alpha, const Vector &v2, Vector &v)
@@ -350,7 +347,6 @@ void add(const Vector &v1, double alpha, const Vector &v2, Vector &v)
    }
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = v1.UseDevice() || v2.UseDevice() || v.UseDevice();
       const int N = v.size;
       // Note: get read access first, in case v is the same as v1/v2.
@@ -361,16 +357,6 @@ void add(const Vector &v1, double alpha, const Vector &v2, Vector &v)
       {
          d_z[i] = d_x[i] + alpha * d_y[i];
       });
-#else
-      const double *v1p = v1.data, *v2p = v2.data;
-      double *vp = v.data;
-      const int s = v.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         vp[i] = v1p[i] + alpha*v2p[i];
-      }
-#endif
    }
 }
 
@@ -389,7 +375,6 @@ void add(const double a, const Vector &x, const Vector &y, Vector &z)
    }
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
       const int N = x.size;
       // Note: get read access first, in case z is the same as x/y.
@@ -400,17 +385,6 @@ void add(const double a, const Vector &x, const Vector &y, Vector &z)
       {
          zd[i] = a * (xd[i] + yd[i]);
       });
-#else
-      const double *xp = x.data;
-      const double *yp = y.data;
-      double       *zp = z.data;
-      const int      s = x.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         zp[i] = a * (xp[i] + yp[i]);
-      }
-#endif
    }
 }
 
@@ -444,7 +418,6 @@ void add(const double a, const Vector &x,
 #endif
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
       const int N = x.size;
       // Note: get read access first, in case z is the same as x/y.
@@ -455,17 +428,6 @@ void add(const double a, const Vector &x,
       {
          zd[i] = a * xd[i] + b * yd[i];
       });
-#else
-      const double *xp = x.data;
-      const double *yp = y.data;
-      double       *zp = z.data;
-      const int      s = x.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         zp[i] = a * xp[i] + b * yp[i];
-      }
-#endif
    }
 }
 
@@ -474,7 +436,6 @@ void subtract(const Vector &x, const Vector &y, Vector &z)
    MFEM_ASSERT(x.size == y.size && x.size == z.size,
                "incompatible Vectors!");
 
-#if !defined(MFEM_USE_LEGACY_OPENMP)
    const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
    const int N = x.size;
    // Note: get read access first, in case z is the same as x/y.
@@ -485,17 +446,6 @@ void subtract(const Vector &x, const Vector &y, Vector &z)
    {
       zd[i] = xd[i] - yd[i];
    });
-#else
-   const double *xp = x.data;
-   const double *yp = y.data;
-   double       *zp = z.data;
-   const int     s = x.size;
-   #pragma omp parallel for
-   for (int i = 0; i < s; i++)
-   {
-      zp[i] = xp[i] - yp[i];
-   }
-#endif
 }
 
 void subtract(const double a, const Vector &x, const Vector &y, Vector &z)
@@ -513,7 +463,6 @@ void subtract(const double a, const Vector &x, const Vector &y, Vector &z)
    }
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
       const int N = x.size;
       // Note: get read access first, in case z is the same as x/y.
@@ -524,17 +473,6 @@ void subtract(const double a, const Vector &x, const Vector &y, Vector &z)
       {
          zd[i] = a * (xd[i] - yd[i]);
       });
-#else
-      const double *xp = x.data;
-      const double *yp = y.data;
-      double       *zp = z.data;
-      const int      s = x.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         zp[i] = a * (xp[i] - yp[i]);
-      }
-#endif
    }
 }
 
diff --git a/linalg/vector.hpp b/linalg/vector.hpp
index 4d2dda36d..04605d2f9 100644
--- a/linalg/vector.hpp
+++ b/linalg/vector.hpp
@@ -323,6 +323,9 @@ public:
    /// (*this) = -(*this)
    void Neg();
 
+   /// (*this)(i) = 1.0 / (*this)(i)
+   void Reciprocal();
+
    /// Swap the contents of two Vectors
    inline void Swap(Vector &other);
 
diff --git a/makefile b/makefile
index 00d139b28..a606f6dfe 100644
--- a/makefile
+++ b/makefile
@@ -265,16 +265,6 @@ endif
 
 DEP_CXX ?= $(MFEM_CXX)
 
-# Check legacy OpenMP configuration
-ifeq ($(MFEM_USE_LEGACY_OPENMP),YES)
-   MFEM_THREAD_SAFE ?= YES
-   ifneq ($(MFEM_THREAD_SAFE),YES)
-      $(error Incompatible config: MFEM_USE_LEGACY_OPENMP requires MFEM_THREAD_SAFE)
-   endif
-   # NOTE: MFEM_USE_LEGACY_OPENMP cannot be combined with any of:
-   # MFEM_USE_OPENMP, MFEM_USE_CUDA, MFEM_USE_RAJA, MFEM_USE_OCCA
-endif
-
 # List of MFEM dependencies, that require the *_LIB variable to be non-empty
 MFEM_REQ_LIB_DEPS = ENZYME SUPERLU MUMPS METIS FMS CONDUIT SIDRE LAPACK SUNDIALS\
  SUITESPARSE STRUMPACK GINKGO GNUTLS NETCDF PETSC SLEPC MPFR PUMI HIOP\
@@ -339,16 +329,16 @@ endif
 MFEM_DEFINES = MFEM_VERSION MFEM_VERSION_STRING MFEM_GIT_STRING MFEM_USE_MPI\
  MFEM_USE_METIS MFEM_USE_METIS_5 MFEM_DEBUG MFEM_USE_EXCEPTIONS MFEM_USE_ZLIB\
  MFEM_USE_LIBUNWIND MFEM_USE_LAPACK MFEM_THREAD_SAFE MFEM_USE_OPENMP\
- MFEM_USE_LEGACY_OPENMP MFEM_USE_MEMALLOC MFEM_TIMER_TYPE MFEM_USE_SUNDIALS\
- MFEM_USE_SUITESPARSE MFEM_USE_GINKGO MFEM_USE_SUPERLU MFEM_USE_SUPERLU5\
- MFEM_USE_STRUMPACK MFEM_USE_GNUTLS MFEM_USE_NETCDF MFEM_USE_PETSC\
- MFEM_USE_SLEPC MFEM_USE_MPFR MFEM_USE_SIDRE MFEM_USE_FMS MFEM_USE_CONDUIT\
- MFEM_USE_PUMI MFEM_USE_HIOP MFEM_USE_GSLIB MFEM_USE_CUDA MFEM_USE_HIP\
- MFEM_USE_OCCA MFEM_USE_MOONOLITH MFEM_USE_CEED MFEM_USE_RAJA MFEM_USE_UMPIRE\
- MFEM_USE_SIMD MFEM_USE_ADIOS2 MFEM_USE_MKL_CPARDISO MFEM_USE_AMGX\
- MFEM_USE_MUMPS MFEM_USE_ADFORWARD MFEM_USE_CODIPACK MFEM_USE_CALIPER\
- MFEM_USE_BENCHMARK MFEM_USE_PARELAG MFEM_USE_ALGOIM MFEM_USE_ENZYME\
- MFEM_SOURCE_DIR MFEM_INSTALL_DIR MFEM_SHARED_BUILD
+ MFEM_USE_MEMALLOC MFEM_TIMER_TYPE MFEM_USE_SUNDIALS MFEM_USE_SUITESPARSE\
+ MFEM_USE_GINKGO MFEM_USE_SUPERLU MFEM_USE_SUPERLU5 MFEM_USE_STRUMPACK\
+ MFEM_USE_GNUTLS MFEM_USE_NETCDF MFEM_USE_PETSC MFEM_USE_SLEPC MFEM_USE_MPFR\
+ MFEM_USE_SIDRE MFEM_USE_FMS MFEM_USE_CONDUIT MFEM_USE_PUMI MFEM_USE_HIOP\
+ MFEM_USE_GSLIB MFEM_USE_CUDA MFEM_USE_HIP MFEM_USE_OCCA MFEM_USE_MOONOLITH\
+ MFEM_USE_CEED MFEM_USE_RAJA MFEM_USE_UMPIRE MFEM_USE_SIMD MFEM_USE_ADIOS2\
+ MFEM_USE_MKL_CPARDISO MFEM_USE_AMGX MFEM_USE_MUMPS MFEM_USE_ADFORWARD\
+ MFEM_USE_CODIPACK MFEM_USE_CALIPER MFEM_USE_BENCHMARK MFEM_USE_PARELAG\
+ MFEM_USE_ALGOIM MFEM_USE_ENZYME MFEM_SOURCE_DIR MFEM_INSTALL_DIR\
+ MFEM_SHARED_BUILD
 
 # List of makefile variables that will be written to config.mk:
 MFEM_CONFIG_VARS = MFEM_CXX MFEM_HOST_CXX MFEM_CPPFLAGS MFEM_CXXFLAGS\
@@ -419,7 +409,7 @@ endif
 DIRS = general linalg linalg/simd mesh mesh/submesh fem fem/ceed/interface \
        fem/ceed/integrators/mass fem/ceed/integrators/convection \
        fem/ceed/integrators/diffusion fem/ceed/integrators/nlconvection \
-       fem/ceed/solvers fem/fe fem/lor fem/qinterp fem/tmop
+       fem/ceed/solvers fem/fe fem/lor fem/qinterp fem/integ fem/tmop
 
 ifeq ($(MFEM_USE_MOONOLITH),YES)
    MFEM_CXXFLAGS += $(MOONOLITH_CXX_FLAGS)
@@ -672,7 +662,6 @@ status info:
 	$(info MFEM_USE_LAPACK        = $(MFEM_USE_LAPACK))
 	$(info MFEM_THREAD_SAFE       = $(MFEM_THREAD_SAFE))
 	$(info MFEM_USE_OPENMP        = $(MFEM_USE_OPENMP))
-	$(info MFEM_USE_LEGACY_OPENMP = $(MFEM_USE_LEGACY_OPENMP))
 	$(info MFEM_USE_MEMALLOC      = $(MFEM_USE_MEMALLOC))
 	$(info MFEM_TIMER_TYPE        = $(MFEM_TIMER_TYPE))
 	$(info MFEM_USE_SUNDIALS      = $(MFEM_USE_SUNDIALS))
@@ -756,10 +745,6 @@ deprecation-warnings:
 	@if [ -t 1 ]; then\
 	   red="\033[0;31m"; yellow="\033[0;33m"; end="\033[0m";\
 	 fi;\
-	if [ $(MFEM_USE_LEGACY_OPENMP) = YES ]; then\
-	  printf $$red"[MFEM_USE_LEGACY_OPENMP]"$$end": "$$yellow"%s"$$end"\n"\
-	  $(DEPRECATION_WARNING);\
-	fi
 
 # $(call mfem_check_command, command-to-execute, success_msg, failed_msg)
 mfem_check_command = \
diff --git a/miniapps/performance/ex1.cpp b/miniapps/performance/ex1.cpp
index e2271585c..916e7022e 100644
--- a/miniapps/performance/ex1.cpp
+++ b/miniapps/performance/ex1.cpp
@@ -317,8 +317,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ref_levels, int order, int basis,
    cout << "Assembling the bilinear form ..." << flush;
    tic_toc.Clear();
    tic_toc.Start();
-   // Pre-allocate sparsity assuming dense element matrices
-   a->UsePrecomputedSparsity();
 
    HPCBilinearForm *a_hpc = NULL;
    Operator *a_oper = NULL;
@@ -373,7 +371,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ref_levels, int order, int basis,
    {
       // TODO: assemble the LOR matrix using the performance code
       a_pc->AddDomainIntegrator(new DiffusionIntegrator(one));
-      a_pc->UsePrecomputedSparsity();
       a_pc->Assemble();
       a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
    }
@@ -385,7 +382,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ref_levels, int order, int basis,
       }
       else
       {
-         a_pc->UsePrecomputedSparsity();
          a_hpc->AssembleBilinearForm(*a_pc);
          a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
       }
diff --git a/miniapps/performance/ex1p.cpp b/miniapps/performance/ex1p.cpp
index 79735c7ff..1e80576bb 100644
--- a/miniapps/performance/ex1p.cpp
+++ b/miniapps/performance/ex1p.cpp
@@ -390,8 +390,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ser_ref_levels, int par_ref_levels,
    }
    tic_toc.Clear();
    tic_toc.Start();
-   // Pre-allocate sparsity assuming dense element matrices
-   a->UsePrecomputedSparsity();
 
    HPCBilinearForm *a_hpc = NULL;
    Operator *a_oper = NULL;
@@ -460,7 +458,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ser_ref_levels, int par_ref_levels,
    {
       // TODO: assemble the LOR matrix using the performance code
       a_pc->AddDomainIntegrator(new DiffusionIntegrator(one));
-      a_pc->UsePrecomputedSparsity();
       a_pc->Assemble();
       a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
    }
@@ -472,7 +469,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ser_ref_levels, int par_ref_levels,
       }
       else
       {
-         a_pc->UsePrecomputedSparsity();
          a_hpc->AssembleBilinearForm(*a_pc);
          a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
       }
diff --git a/tests/unit/fem/test_assemblediagonalpa.cpp b/tests/unit/fem/test_assemblediagonalpa.cpp
index ebbb8e224..050561e1d 100644
--- a/tests/unit/fem/test_assemblediagonalpa.cpp
+++ b/tests/unit/fem/test_assemblediagonalpa.cpp
@@ -17,11 +17,9 @@ using namespace mfem;
 namespace assemblediagonalpa
 {
 
-int dimension;
-
 double coeffFunction(const Vector& x)
 {
-   if (dimension == 2)
+   if (x.Size() == 2)
    {
       return sin(8.0 * M_PI * x[0]) * cos(6.0 * M_PI * x[1]) + 2.0;
    }
@@ -36,12 +34,12 @@ double coeffFunction(const Vector& x)
 void vectorCoeffFunction(const Vector & x, Vector & f)
 {
    f = 0.0;
-   if (dimension > 1)
+   if (x.Size() > 1)
    {
       f[0] = sin(M_PI * x[1]);
       f[1] = sin(2.5 * M_PI * x[0]);
    }
-   if (dimension == 3)
+   if (x.Size() == 3)
    {
       f[2] = sin(6.1 * M_PI * x[2]);
    }
@@ -50,14 +48,14 @@ void vectorCoeffFunction(const Vector & x, Vector & f)
 void asymmetricMatrixCoeffFunction(const Vector & x, DenseMatrix & f)
 {
    f = 0.0;
-   if (dimension == 2)
+   if (x.Size() == 2)
    {
       f(0,0) = 1.1 + sin(M_PI * x[1]);  // 1,1
       f(1,0) = cos(1.3 * M_PI * x[1]);  // 2,1
       f(0,1) = cos(2.5 * M_PI * x[0]);  // 1,2
       f(1,1) = 1.1 + sin(4.9 * M_PI * x[0]);  // 2,2
    }
-   else if (dimension == 3)
+   else if (x.Size() == 3)
    {
       f(0,0) = 1.1 + sin(M_PI * x[1]);  // 1,1
       f(0,1) = cos(2.5 * M_PI * x[0]);  // 1,2
@@ -74,13 +72,13 @@ void asymmetricMatrixCoeffFunction(const Vector & x, DenseMatrix & f)
 void symmetricMatrixCoeffFunction(const Vector & x, DenseSymmetricMatrix & f)
 {
    f = 0.0;
-   if (dimension == 2)
+   if (x.Size() == 2)
    {
       f(0,0) = 1.1 + sin(M_PI * x[1]);  // 1,1
       f(0,1) = cos(2.5 * M_PI * x[0]);  // 1,2
       f(1,1) = 1.1 + sin(4.9 * M_PI * x[0]);  // 2,2
    }
-   else if (dimension == 3)
+   else if (x.Size() == 3)
    {
       f(0,0) = sin(M_PI * x[1]);  // 1,1
       f(0,1) = cos(2.5 * M_PI * x[0]);  // 1,2
@@ -93,7 +91,7 @@ void symmetricMatrixCoeffFunction(const Vector & x, DenseSymmetricMatrix & f)
 
 TEST_CASE("Mass Diagonal PA", "[PartialAssembly][AssembleDiagonal]")
 {
-   for (dimension = 2; dimension < 4; ++dimension)
+   for (int dimension = 2; dimension < 4; ++dimension)
    {
       for (int ne = 1; ne < 3; ++ne)
       {
@@ -140,9 +138,45 @@ TEST_CASE("Mass Diagonal PA", "[PartialAssembly][AssembleDiagonal]")
    }
 }
 
+TEST_CASE("Mass Boundary Diagonal PA", "[PartialAssembly][AssembleDiagonal]")
+{
+   const bool all_tests = launch_all_non_regression_tests;
+
+   auto fname = GENERATE("../../data/star.mesh", "../../data/star-q3.mesh",
+                         "../../data/fichera.mesh", "../../data/fichera-q3.mesh");
+   auto order = !all_tests ? 2 : GENERATE(1, 2, 3);
+
+   CAPTURE(fname, order);
+
+   Mesh mesh(fname);
+   int dim = mesh.Dimension();
+   RT_FECollection fec(order, dim);
+   FiniteElementSpace fes(&mesh, &fec);
+
+   FunctionCoefficient coeff(coeffFunction);
+
+   Vector diag_fa(fes.GetTrueVSize()), diag_pa(fes.GetTrueVSize());
+
+   BilinearForm blf_fa(&fes);
+   blf_fa.AddBoundaryIntegrator(new MassIntegrator(coeff));
+   blf_fa.Assemble();
+   blf_fa.Finalize();
+   blf_fa.SpMat().GetDiag(diag_fa);
+
+   BilinearForm blf_pa(&fes);
+   blf_pa.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   blf_pa.AddBoundaryIntegrator(new MassIntegrator(coeff));
+   blf_pa.Assemble();
+   blf_pa.AssembleDiagonal(diag_pa);
+
+   diag_pa -= diag_fa;
+
+   REQUIRE(diag_pa.Normlinf() == MFEM_Approx(0.0));
+}
+
 TEST_CASE("Diffusion Diagonal PA", "[PartialAssembly][AssembleDiagonal]")
 {
-   for (dimension = 2; dimension < 4; ++dimension)
+   for (int dimension = 2; dimension < 4; ++dimension)
    {
       for (int ne = 1; ne < 3; ++ne)
       {
@@ -322,7 +356,7 @@ TEST_CASE("Vector Diffusion Diagonal PA",
 TEST_CASE("Hcurl/Hdiv diagonal PA",
           "[CUDA][PartialAssembly][AssembleDiagonal]")
 {
-   for (dimension = 2; dimension < 4; ++dimension)
+   for (int dimension = 2; dimension < 4; ++dimension)
    {
       for (int coeffType = 0; coeffType < 5; ++coeffType)
       {
diff --git a/tests/unit/fem/test_bilinearform.cpp b/tests/unit/fem/test_bilinearform.cpp
index 5fd00b3e1..647ae38f2 100644
--- a/tests/unit/fem/test_bilinearform.cpp
+++ b/tests/unit/fem/test_bilinearform.cpp
@@ -127,7 +127,7 @@ TEST_CASE("FormLinearSystem/SolutionScope",
    // Legacy full assembly
    {
       GridFunction sol(&fes);
-      SolvePDE(AssemblyLevel::LEGACYFULL, sol);
+      SolvePDE(AssemblyLevel::LEGACY, sol);
       // Make sure the solution is still accessible after 'X' is destroyed
       sol.HostRead();
       REQUIRE(AsConst(sol)(bdr_dof) == 0.0);
diff --git a/tests/unit/fem/test_pa_grad.cpp b/tests/unit/fem/test_pa_grad.cpp
index a42d7c83c..af0038cee 100644
--- a/tests/unit/fem/test_pa_grad.cpp
+++ b/tests/unit/fem/test_pa_grad.cpp
@@ -154,7 +154,7 @@ double par_compare_pa_assembly(int dim, int num_elements, int order,
    pa_grad.AddDomainInterpolator(new GradientInterpolator);
    pa_grad.Assemble();
    OperatorPtr pa_grad_oper;
-   pa_grad.FormRectangularSystemMatrix(pa_grad_oper);
+   pa_grad.FormDiscreteOperatorMatrix(pa_grad_oper);
 
    int insize, outsize;
    if (transpose)
diff --git a/tests/unit/fem/test_pa_kernels.cpp b/tests/unit/fem/test_pa_kernels.cpp
index 2277efdfa..b50a69886 100644
--- a/tests/unit/fem/test_pa_kernels.cpp
+++ b/tests/unit/fem/test_pa_kernels.cpp
@@ -9,11 +9,6 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#ifdef _WIN32
-#define _USE_MATH_DEFINES
-#include <cmath>
-#endif
-
 #include "unit_tests.hpp"
 #include "mfem.hpp"
 
@@ -520,17 +515,17 @@ static void test_pa_integrator()
    GridFunction x(&fes), y_fa(&fes), y_pa(&fes);
    x.Randomize(1);
 
-   ConstantCoefficient pi(M_PI);
+   FunctionCoefficient coeff(f1);
 
    BilinearForm blf_fa(&fes);
-   blf_fa.AddDomainIntegrator(new INTEGRATOR(pi,ir));
+   blf_fa.AddDomainIntegrator(new INTEGRATOR(coeff,ir));
    blf_fa.Assemble();
    blf_fa.Finalize();
    blf_fa.Mult(x, y_fa);
 
    BilinearForm blf_pa(&fes);
    blf_pa.SetAssemblyLevel(AssemblyLevel::PARTIAL);
-   blf_pa.AddDomainIntegrator(new INTEGRATOR(pi,ir));
+   blf_pa.AddDomainIntegrator(new INTEGRATOR(coeff,ir));
    blf_pa.Assemble();
    blf_pa.Mult(x, y_pa);
 
@@ -549,4 +544,39 @@ TEST_CASE("PA Diffusion", "[PartialAssembly], [CUDA]")
    test_pa_integrator<DiffusionIntegrator>();
 } // PA Diffusion test case
 
+TEST_CASE("PA Boundary Mass", "[PartialAssembly], [CUDA]")
+{
+   const bool all_tests = launch_all_non_regression_tests;
+
+   auto fname = GENERATE("../../data/star.mesh", "../../data/star-q3.mesh",
+                         "../../data/fichera.mesh", "../../data/fichera-q3.mesh");
+   auto order = !all_tests ? 2 : GENERATE(1, 2, 3);
+
+   Mesh mesh(fname);
+   int dim = mesh.Dimension();
+   RT_FECollection fec(order, dim);
+   FiniteElementSpace fes(&mesh, &fec);
+
+   GridFunction x(&fes), y_fa(&fes), y_pa(&fes);
+   x.Randomize(1);
+
+   FunctionCoefficient coeff(f1);
+
+   BilinearForm blf_fa(&fes);
+   blf_fa.AddBoundaryIntegrator(new MassIntegrator(coeff));
+   blf_fa.Assemble();
+   blf_fa.Finalize();
+   blf_fa.Mult(x, y_fa);
+
+   BilinearForm blf_pa(&fes);
+   blf_pa.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   blf_pa.AddBoundaryIntegrator(new MassIntegrator(coeff));
+   blf_pa.Assemble();
+   blf_pa.Mult(x, y_pa);
+
+   y_fa -= y_pa;
+
+   REQUIRE(y_fa.Normlinf() == MFEM_Approx(0.0));
+}
+
 } // namespace pa_kernels
