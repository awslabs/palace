diff --git a/fem/CMakeLists.txt b/fem/CMakeLists.txt
index 6da0cfea3..f11a5a72b 100644
--- a/fem/CMakeLists.txt
+++ b/fem/CMakeLists.txt
@@ -17,19 +17,25 @@ set(SRCS
   integ/bilininteg_convection_mf.cpp
   integ/bilininteg_convection_pa.cpp
   integ/bilininteg_convection_ea.cpp
+  integ/bilininteg_curlcurl_mf.cpp
   integ/bilininteg_curlcurl_pa.cpp
   integ/bilininteg_dgtrace_pa.cpp
   integ/bilininteg_dgtrace_ea.cpp
   integ/bilininteg_diffusion_mf.cpp
   integ/bilininteg_diffusion_pa.cpp
   integ/bilininteg_diffusion_ea.cpp
+  integ/bilininteg_divdiv_mf.cpp
   integ/bilininteg_divdiv_pa.cpp
   integ/bilininteg_gradient_pa.cpp
-  integ/bilininteg_interp_pa.cpp
+  integ/bilininteg_interp_id_pa.cpp
+  integ/bilininteg_interp_grad_pa.cpp
+  integ/bilininteg_interp_curl_pa.cpp
   integ/bilininteg_mass_mf.cpp
   integ/bilininteg_mass_pa.cpp
   integ/bilininteg_mass_ea.cpp
+  integ/bilininteg_mixedcurl_mf.cpp
   integ/bilininteg_mixedcurl_pa.cpp
+  integ/bilininteg_mixedvecgrad_mf.cpp
   integ/bilininteg_mixedvecgrad_pa.cpp
   integ/bilininteg_transpose_ea.cpp
   integ/bilininteg_vecdiffusion_mf.cpp
@@ -38,6 +44,7 @@ set(SRCS
   integ/bilininteg_vecmass_mf.cpp
   integ/bilininteg_vecmass_pa.cpp
   integ/bilininteg_vectorfediv_pa.cpp
+  integ/bilininteg_vectorfemass_mf.cpp
   integ/bilininteg_vectorfemass_pa.cpp
   integ/lininteg_boundary.cpp
   integ/lininteg_boundary_flux.cpp
@@ -72,15 +79,20 @@ set(SRCS
   hybridization.cpp
   intrules.cpp
   ceed/interface/basis.cpp
-  ceed/interface/restriction.cpp
   ceed/interface/operator.cpp
+  ceed/interface/restriction.cpp
   ceed/interface/util.cpp
+  ceed/integrators/mass/mass.cpp
   ceed/integrators/convection/convection.cpp
   ceed/integrators/diffusion/diffusion.cpp
   ceed/integrators/nlconvection/nlconvection.cpp
-  ceed/integrators/mass/mass.cpp
+  ceed/integrators/vecfemass/vecfemass.cpp
+  ceed/integrators/divdiv/divdiv.cpp
+  ceed/integrators/curlcurl/curlcurl.cpp
+  ceed/integrators/mixedvecgrad/mixedvecgrad.cpp
+  ceed/integrators/mixedveccurl/mixedveccurl.cpp
+  ceed/integrators/interp/interp.cpp
   ceed/solvers/algebraic.cpp
-  ceed/solvers/full-assembly.cpp
   ceed/solvers/solvers-atpmg.cpp
   linearform.cpp
   linearform_ext.cpp
@@ -180,18 +192,33 @@ set(HDRS
   hybridization.hpp
   intrules.hpp
   ceed/interface/basis.hpp
+  ceed/interface/ceed.hpp
+  ceed/interface/coefficient.hpp
   ceed/interface/integrator.hpp
   ceed/interface/interface.hpp
+  ceed/interface/mixed_operator.hpp
   ceed/interface/operator.hpp
   ceed/interface/restriction.hpp
   ceed/interface/util.hpp
+  ceed/integrators/mass/mass.hpp
+  ceed/integrators/mass/mass_qf.h
   ceed/integrators/convection/convection.hpp
+  ceed/integrators/convection/convection_qf.h
   ceed/integrators/diffusion/diffusion.hpp
-  ceed/integrators/mass/mass.hpp
+  ceed/integrators/diffusion/diffusion_qf.h
   ceed/integrators/nlconvection/nlconvection.hpp
-  ceed/interface/coefficient.hpp
+  ceed/integrators/nlconvection/nlconvection_qf.h
+  ceed/integrators/vecfemass/vecfemass.hpp
+  ceed/integrators/vecfemass/vecfemass_qf.h
+  ceed/integrators/divdiv/divdiv.hpp
+  ceed/integrators/divdiv/divdiv_qf.h
+  ceed/integrators/curlcurl/curlcurl.hpp
+  ceed/integrators/curlcurl/curlcurl_qf.h
+  ceed/integrators/mixedvecgrad/mixedvecgrad.hpp
+  ceed/integrators/mixedveccurl/mixedveccurl.hpp
+  ceed/integrators/interp/interp.hpp
+  ceed/integrators/util/util_qf.h
   ceed/solvers/algebraic.hpp
-  ceed/solvers/full-assembly.hpp
   ceed/solvers/solvers-atpmg.hpp
   linearform.hpp
   linearform_ext.hpp
diff --git a/fem/bilinearform.cpp b/fem/bilinearform.cpp
index a549d03a7..0a566cba5 100644
--- a/fem/bilinearform.cpp
+++ b/fem/bilinearform.cpp
@@ -1353,8 +1353,8 @@ void MixedBilinearForm::Assemble(int skip_zeros)
          }
          for (int k = 0; k < trace_face_integs.Size(); k++)
          {
-            trace_face_integs[k]->AssembleFaceMatrix(*trial_face_fe, *test_fe1,
-                                                     *test_fe2, *ftr, elemmat);
+            trace_face_integs[k]->AssembleFaceMatrix2(*trial_face_fe, *test_fe1,
+                                                      *test_fe2, *ftr, elemmat);
             mat->AddSubMatrix(test_vdofs, trial_vdofs, elemmat, skip_zeros);
          }
       }
@@ -1409,10 +1409,10 @@ void MixedBilinearForm::Assemble(int skip_zeros)
                    (*boundary_trace_face_integs_marker[k])[bdr_attr-1] == 0)
                { continue; }
 
-               boundary_trace_face_integs[k]->AssembleFaceMatrix(*trial_face_fe,
-                                                                 *test_fe1,
-                                                                 *test_fe2,
-                                                                 *ftr, elemmat);
+               boundary_trace_face_integs[k]->AssembleFaceMatrix2(*trial_face_fe,
+                                                                  *test_fe1,
+                                                                  *test_fe2,
+                                                                  *ftr, elemmat);
                mat->AddSubMatrix(test_vdofs, trial_vdofs, elemmat, skip_zeros);
             }
          }
diff --git a/fem/bilinearform_ext.cpp b/fem/bilinearform_ext.cpp
index 90a1655f4..0c88fdf91 100644
--- a/fem/bilinearform_ext.cpp
+++ b/fem/bilinearform_ext.cpp
@@ -2131,6 +2131,33 @@ void PADiscreteLinearOperatorExtension::Assemble()
    test_multiplicity.Reciprocal();
 }
 
+void PADiscreteLinearOperatorExtension::Mult(const Vector &x, Vector &y) const
+{
+   Array<BilinearFormIntegrator *> &interpolators = *a->GetDBFI();
+   if (elem_restrict_trial)
+   {
+      elem_restrict_trial->Mult(x, local_trial);
+   }
+   if (elem_restrict_test)
+   {
+      local_test = 0.0;
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultPA(elem_restrict_trial ? local_trial : x, local_test);
+      }
+      elem_restrict_test->MultTranspose(local_test, y);
+   }
+   else
+   {
+      y = 0.0;
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultPA(elem_restrict_trial ? local_trial : x, y);
+      }
+   }
+   y *= test_multiplicity;
+}
+
 void PADiscreteLinearOperatorExtension::AddMult(const Vector &x, Vector &y,
                                                 const double c) const
 {
@@ -2152,6 +2179,7 @@ void PADiscreteLinearOperatorExtension::AddMult(const Vector &x, Vector &y,
    }
    else
    {
+      temp_test = 0.0;
       for (BilinearFormIntegrator *interp : interpolators)
       {
          interp->AddMultPA(elem_restrict_trial ? local_trial : x, temp_test);
@@ -2165,8 +2193,10 @@ void PADiscreteLinearOperatorExtension::AddMultTranspose(const Vector &x,
                                                          Vector &y,
                                                          const double c) const
 {
+   MFEM_VERIFY(c == 1.0,
+               "General coefficient case for PADiscreteLinearOperatorExtension::"
+               "AddMultTranspose is not yet supported!");
    Array<BilinearFormIntegrator *> &interpolators = *a->GetDBFI();
-   temp_test.SetSize(y.Size());
    temp_test.UseDevice(true);
    temp_test = x;
    temp_test *= test_multiplicity;
@@ -2182,26 +2212,14 @@ void PADiscreteLinearOperatorExtension::AddMultTranspose(const Vector &x,
          interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test,
                                     local_trial);
       }
-      if (c != 1.0)
-      {
-         local_trial *= c;
-      }
       elem_restrict_trial->AddMultTranspose(local_trial, y);
    }
    else
    {
       y.UseDevice(true); // typically this is a large vector, so store on device
-      if (c != 1.0)
-      {
-         MFEM_ABORT("General coefficient case for PADiscreteLinearOperatorExtension::"
-                    "AddMultTranspose is not yet supported!");
-      }
-      else
+      for (BilinearFormIntegrator *interp : interpolators)
       {
-         for (BilinearFormIntegrator *interp : interpolators)
-         {
-            interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test, y);
-         }
+         interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test, y);
       }
    }
 }
diff --git a/fem/bilinearform_ext.hpp b/fem/bilinearform_ext.hpp
index db26eb801..aa9271d8f 100644
--- a/fem/bilinearform_ext.hpp
+++ b/fem/bilinearform_ext.hpp
@@ -227,6 +227,7 @@ public:
    PADiscreteLinearOperatorExtension(DiscreteLinearOperator *linop);
 
    void Assemble();
+   void Mult(const Vector &x, Vector &y) const;
    void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
    void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
 };
diff --git a/fem/bilininteg.cpp b/fem/bilininteg.cpp
index e6fc2a6ee..096285723 100644
--- a/fem/bilininteg.cpp
+++ b/fem/bilininteg.cpp
@@ -141,7 +141,7 @@ void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace&,
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &,
+void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace&,
                                                      Vector&,
                                                      Vector&)
 {
@@ -156,47 +156,50 @@ void BilinearFormIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace&,
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleElementMatrix(
-   const FiniteElement &el, ElementTransformation &Trans,
-   DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleElementMatrix(const FiniteElement&,
+                                                   ElementTransformation&,
+                                                   DenseMatrix&)
 {
    MFEM_ABORT("BilinearFormIntegrator::AssembleElementMatrix(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleElementMatrix2(
-   const FiniteElement &el1, const FiniteElement &el2,
-   ElementTransformation &Trans, DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleElementMatrix2(const FiniteElement&,
+                                                    const FiniteElement&,
+                                                    ElementTransformation&,
+                                                    DenseMatrix&)
 {
    MFEM_ABORT("BilinearFormIntegrator::AssembleElementMatrix2(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleFaceMatrix(
-   const FiniteElement &el1, const FiniteElement &el2,
-   FaceElementTransformations &Trans, DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleFaceMatrix(const FiniteElement&,
+                                                const FiniteElement&,
+                                                FaceElementTransformations&Trans,
+                                                DenseMatrix&)
 {
    MFEM_ABORT("BilinearFormIntegrator::AssembleFaceMatrix(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleFaceMatrix(
-   const FiniteElement &trial_face_fe, const FiniteElement &test_fe1,
-   const FiniteElement &test_fe2, FaceElementTransformations &Trans,
-   DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleFaceMatrix2(const FiniteElement&,
+                                                 const FiniteElement&,
+                                                 const FiniteElement&,
+                                                 FaceElementTransformations&,
+                                                 DenseMatrix&)
 {
-   MFEM_ABORT("AssembleFaceMatrix (mixed form) is not implemented for this"
-              " Integrator class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleFaceMatrix2(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleTraceFaceMatrix (int elem,
-                                                      const FiniteElement &trial_face_fe,
-                                                      const FiniteElement &test_fe1,
-                                                      FaceElementTransformations &Trans,
-                                                      DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleTraceFaceMatrix(int,
+                                                     const FiniteElement&,
+                                                     const FiniteElement&,
+                                                     FaceElementTransformations&,
+                                                     DenseMatrix&)
 {
-   MFEM_ABORT("AssembleTraceFaceMatrix (DPG form) is not implemented for this"
-              " Integrator class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleTraceFaceMatrix(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleElementVector(
@@ -221,17 +224,10 @@ void BilinearFormIntegrator::AssembleFaceVector(
    elmat.Mult(elfun, elvect);
 }
 
-void TransposeIntegrator::SetIntRule(const IntegrationRule *ir)
-{
-   IntRule = ir;
-   bfi->SetIntRule(ir);
-}
-
 void TransposeIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
    bfi->AssembleElementMatrix(el, Trans, bfi_elmat);
-   // elmat = bfi_elmat^t
    elmat.Transpose(bfi_elmat);
 }
 
@@ -240,7 +236,6 @@ void TransposeIntegrator::AssembleElementMatrix2(
    ElementTransformation &Trans, DenseMatrix &elmat)
 {
    bfi->AssembleElementMatrix2(test_fe, trial_fe, Trans, bfi_elmat);
-   // elmat = bfi_elmat^t
    elmat.Transpose(bfi_elmat);
 }
 
@@ -249,16 +244,9 @@ void TransposeIntegrator::AssembleFaceMatrix(
    FaceElementTransformations &Trans, DenseMatrix &elmat)
 {
    bfi->AssembleFaceMatrix(el1, el2, Trans, bfi_elmat);
-   // elmat = bfi_elmat^t
    elmat.Transpose(bfi_elmat);
 }
 
-void LumpedIntegrator::SetIntRule(const IntegrationRule *ir)
-{
-   IntRule = ir;
-   bfi->SetIntRule(ir);
-}
-
 void LumpedIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
@@ -266,38 +254,41 @@ void LumpedIntegrator::AssembleElementMatrix(
    elmat.Lump();
 }
 
-void InverseIntegrator::SetIntRule(const IntegrationRule *ir)
-{
-   IntRule = ir;
-   integrator->SetIntRule(ir);
-}
-
 void InverseIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   integrator->AssembleElementMatrix(el, Trans, elmat);
+   bfi->AssembleElementMatrix(el, Trans, elmat);
    elmat.Invert();
 }
 
+bool SumIntegrator::SupportsCeed() const
+{
+   for (int i = 0; i < bfis.Size(); i++)
+   {
+      if (!bfis[i]->SupportsCeed()) { return false; }
+   }
+   return true;
+}
+
 void SumIntegrator::SetIntRule(const IntegrationRule *ir)
 {
    IntRule = ir;
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->SetIntRule(ir);
+      bfis[i]->SetIntRule(ir);
    }
 }
 
 void SumIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   MFEM_ASSERT(integrators.Size() > 0, "empty SumIntegrator.");
+   MFEM_ASSERT(bfis.Size() > 0, "empty SumIntegrator.");
 
-   integrators[0]->AssembleElementMatrix(el, Trans, elmat);
-   for (int i = 1; i < integrators.Size(); i++)
+   bfis[0]->AssembleElementMatrix(el, Trans, elmat);
+   for (int i = 1; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleElementMatrix(el, Trans, elem_mat);
-      elmat += elem_mat;
+      bfis[i]->AssembleElementMatrix(el, Trans, bfi_elmat);
+      elmat += bfi_elmat;
    }
 }
 
@@ -305,13 +296,13 @@ void SumIntegrator::AssembleElementMatrix2(
    const FiniteElement &el1, const FiniteElement &el2,
    ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   MFEM_ASSERT(integrators.Size() > 0, "empty SumIntegrator.");
+   MFEM_ASSERT(bfis.Size() > 0, "empty SumIntegrator.");
 
-   integrators[0]->AssembleElementMatrix2(el1, el2, Trans, elmat);
-   for (int i = 1; i < integrators.Size(); i++)
+   bfis[0]->AssembleElementMatrix2(el1, el2, Trans, elmat);
+   for (int i = 1; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleElementMatrix2(el1, el2, Trans, elem_mat);
-      elmat += elem_mat;
+      bfis[i]->AssembleElementMatrix2(el1, el2, Trans, bfi_elmat);
+      elmat += bfi_elmat;
    }
 }
 
@@ -319,134 +310,134 @@ void SumIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
 {
-   MFEM_ASSERT(integrators.Size() > 0, "empty SumIntegrator.");
+   MFEM_ASSERT(bfis.Size() > 0, "empty SumIntegrator.");
 
-   integrators[0]->AssembleFaceMatrix(el1, el2, Trans, elmat);
-   for (int i = 1; i < integrators.Size(); i++)
+   bfis[0]->AssembleFaceMatrix(el1, el2, Trans, elmat);
+   for (int i = 1; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleFaceMatrix(el1, el2, Trans, elem_mat);
-      elmat += elem_mat;
+      bfis[i]->AssembleFaceMatrix(el1, el2, Trans, bfi_elmat);
+      elmat += bfi_elmat;
    }
 }
 
-void SumIntegrator::AssembleFaceMatrix(
-   const FiniteElement &tr_fe,
-   const FiniteElement &te_fe1, const FiniteElement &te_fe2,
-   FaceElementTransformations &Trans, DenseMatrix &elmat)
+void SumIntegrator::AssembleFaceMatrix2(
+   const FiniteElement &tr_fe, const FiniteElement &te_fe1,
+   const FiniteElement &te_fe2, FaceElementTransformations &Trans,
+   DenseMatrix &elmat)
 {
-   MFEM_ASSERT(integrators.Size() > 0, "empty SumIntegrator.");
+   MFEM_ASSERT(bfis.Size() > 0, "empty SumIntegrator.");
 
-   integrators[0]->AssembleFaceMatrix(tr_fe, te_fe1, te_fe2, Trans, elmat);
-   for (int i = 1; i < integrators.Size(); i++)
+   bfis[0]->AssembleFaceMatrix2(tr_fe, te_fe1, te_fe2, Trans, elmat);
+   for (int i = 1; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleFaceMatrix(tr_fe, te_fe1, te_fe2, Trans, elem_mat);
-      elmat += elem_mat;
+      bfis[i]->AssembleFaceMatrix2(tr_fe, te_fe1, te_fe2, Trans, bfi_elmat);
+      elmat += bfi_elmat;
    }
 }
 
 void SumIntegrator::AssemblePA(const FiniteElementSpace& fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssemblePA(fes);
+      bfis[i]->AssemblePA(fes);
    }
 }
 
 void SumIntegrator::AssemblePA(const FiniteElementSpace& trial_fes,
                                const FiniteElementSpace& test_fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssemblePA(trial_fes, test_fes);
+      bfis[i]->AssemblePA(trial_fes, test_fes);
    }
 }
 
 void SumIntegrator::AssembleDiagonalPA(Vector &diag)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleDiagonalPA(diag);
+      bfis[i]->AssembleDiagonalPA(diag);
    }
 }
 
 void SumIntegrator::AssemblePAInteriorFaces(const FiniteElementSpace &fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssemblePAInteriorFaces(fes);
+      bfis[i]->AssemblePAInteriorFaces(fes);
    }
 }
 
 void SumIntegrator::AssemblePABoundaryFaces(const FiniteElementSpace &fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssemblePABoundaryFaces(fes);
+      bfis[i]->AssemblePABoundaryFaces(fes);
    }
 }
 
 void SumIntegrator::AddMultPA(const Vector& x, Vector& y) const
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AddMultPA(x, y);
+      bfis[i]->AddMultPA(x, y);
    }
 }
 
 void SumIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AddMultTransposePA(x, y);
+      bfis[i]->AddMultTransposePA(x, y);
    }
 }
 
 void SumIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleMF(fes);
+      bfis[i]->AssembleMF(fes);
    }
 }
 
 void SumIntegrator::AssembleMF(const FiniteElementSpace& trial_fes,
                                const FiniteElementSpace& test_fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleMF(trial_fes, test_fes);
+      bfis[i]->AssembleMF(trial_fes, test_fes);
    }
 }
 
 void SumIntegrator::AssembleDiagonalMF(Vector &diag)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleDiagonalMF(diag);
+      bfis[i]->AssembleDiagonalMF(diag);
    }
 }
 
 void SumIntegrator::AddMultMF(const Vector& x, Vector& y) const
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AddMultTransposeMF(x, y);
+      bfis[i]->AddMultTransposeMF(x, y);
    }
 }
 
 void SumIntegrator::AddMultTransposeMF(const Vector &x, Vector &y) const
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AddMultMF(x, y);
+      bfis[i]->AddMultMF(x, y);
    }
 }
 
 void SumIntegrator::AssembleEA(const FiniteElementSpace &fes, Vector &emat)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleEA(fes, emat);
+      bfis[i]->AssembleEA(fes, emat);
    }
 }
 
@@ -454,32 +445,41 @@ void SumIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                             Vector &ea_data_int,
                                             Vector &ea_data_ext)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleEAInteriorFaces(fes, ea_data_int, ea_data_ext);
+      bfis[i]->AssembleEAInteriorFaces(fes, ea_data_int, ea_data_ext);
    }
 }
 
 void SumIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace &fes,
                                             Vector &ea_data_bdr)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleEABoundaryFaces(fes, ea_data_bdr);
+      bfis[i]->AssembleEABoundaryFaces(fes, ea_data_bdr);
    }
 }
 
 SumIntegrator::~SumIntegrator()
 {
-   if (own_integrators)
+   if (own_bfis)
    {
-      for (int i = 0; i < integrators.Size(); i++)
+      for (int i = 0; i < bfis.Size(); i++)
       {
-         delete integrators[i];
+         delete bfis[i];
       }
    }
 }
 
+const IntegrationRule &MixedScalarIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void MixedScalarIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -507,12 +507,8 @@ void MixedScalarIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int ir_order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
-      ir = &IntRules.Get(trial_fe.GetGeomType(), ir_order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -539,6 +535,15 @@ void MixedScalarIntegrator::AssembleElementMatrix2(
 #endif
 }
 
+const IntegrationRule &MixedVectorIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void MixedVectorIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -598,12 +603,8 @@ void MixedVectorIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int ir_order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
-      ir = &IntRules.Get(trial_fe.GetGeomType(), ir_order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -713,6 +714,15 @@ void MixedVectorIntegrator::AssembleElementMatrix2(
 #endif
 }
 
+const IntegrationRule &MixedScalarVectorIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void MixedScalarVectorIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -754,12 +764,8 @@ void MixedScalarVectorIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int ir_order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
-      ir = &IntRules.Get(trial_fe.GetGeomType(), ir_order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -787,6 +793,15 @@ void MixedScalarVectorIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &GradientIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void GradientIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans,  DenseMatrix &elmat)
@@ -843,18 +858,30 @@ void GradientIntegrator::AssembleElementMatrix2(
    }
 }
 
-const IntegrationRule &GradientIntegrator::GetRule(
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
+const IntegrationRule &DiffusionIntegrator::GetRuleStatic(
+   const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans)
 {
-   int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
+   int order;
+   if (trial_fe.Space() == FunctionSpace::Pk)
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() - 2;
+   }
+   else
+   {
+      // order = 2 * el.GetOrder() - 2;  // <-- this seems to work fine too
+      order = trial_fe.GetOrder() + test_fe.GetOrder() + trial_fe.GetDim() - 1;
+   }
+   if (trial_fe.Space() == FunctionSpace::rQk)
+   {
+      return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
+   }
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-void DiffusionIntegrator::AssembleElementMatrix(
-   const FiniteElement &el, ElementTransformation &Trans,
-   DenseMatrix &elmat)
+void DiffusionIntegrator::AssembleElementMatrix(const FiniteElement &el,
+                                                ElementTransformation &Trans,
+                                                DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    dim = el.GetDim();
@@ -889,7 +916,7 @@ void DiffusionIntegrator::AssembleElementMatrix(
 #endif
    elmat.SetSize(nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -970,7 +997,8 @@ void DiffusionIntegrator::AssembleElementMatrix2(
 #endif
    elmat.SetSize(te_nd, tr_nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1048,7 +1076,7 @@ void DiffusionIntegrator::AssembleElementVector(
 
    elvect.SetSize(nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    elvect = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1094,13 +1122,9 @@ void DiffusionIntegrator::AssembleElementVector(
 }
 
 void DiffusionIntegrator::ComputeElementFlux(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   Vector &u,
-   const FiniteElement &fluxelem,
-   Vector &flux,
-   bool with_coef,
-   const IntegrationRule *ir)
+   const FiniteElement &el, ElementTransformation &Trans,
+   Vector &u, const FiniteElement &fluxelem, Vector &flux,
+   bool with_coef, const IntegrationRule *ir)
 {
    int nd, spaceDim, fnd;
 
@@ -1196,11 +1220,9 @@ void DiffusionIntegrator::ComputeElementFlux(
    }
 }
 
-double DiffusionIntegrator::ComputeFluxEnergy(
-   const FiniteElement &fluxelem,
-   ElementTransformation &Trans,
-   Vector &flux,
-   Vector* d_energy)
+double DiffusionIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
+                                              ElementTransformation &Trans,
+                                              Vector &flux, Vector* d_energy)
 {
    int nd = fluxelem.GetDof();
    dim = fluxelem.GetDim();
@@ -1218,7 +1240,7 @@ double DiffusionIntegrator::ComputeFluxEnergy(
    if (d_energy) { vec.SetSize(spaceDim); }
    if (MQ) { M.SetSize(spaceDim); }
 
-   int order = 2 * fluxelem.GetOrder(); // <--
+   int order = 2 * fluxelem.GetOrder();
    const IntegrationRule *ir = &IntRules.Get(fluxelem.GetGeomType(), order);
 
    double energy = 0.0;
@@ -1274,20 +1296,13 @@ double DiffusionIntegrator::ComputeFluxEnergy(
    return energy;
 }
 
-const IntegrationRule &DiffusionIntegrator::GetRule(
+const IntegrationRule &MassIntegrator::GetRuleStatic(
    const FiniteElement &trial_fe,
-   const FiniteElement &test_fe)
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans,
+   int Q_order)
 {
-   int order;
-   if (trial_fe.Space() == FunctionSpace::Pk)
-   {
-      order = trial_fe.GetOrder() + test_fe.GetOrder() - 2;
-   }
-   else
-   {
-      // order = 2*el.GetOrder() - 2;  // <-- this seems to work fine too
-      order = trial_fe.GetOrder() + test_fe.GetOrder() + trial_fe.GetDim() - 1;
-   }
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() + Q_order;
    if (trial_fe.Space() == FunctionSpace::rQk)
    {
       return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
@@ -1295,22 +1310,20 @@ const IntegrationRule &DiffusionIntegrator::GetRule(
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-void MassIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+void MassIntegrator::AssembleElementMatrix(const FiniteElement &el,
+                                           ElementTransformation &Trans,
+                                           DenseMatrix &elmat)
 {
    int nd = el.GetDof();
-   // int dim = el.GetDim();
    double w;
 
 #ifdef MFEM_THREAD_SAFE
    Vector shape;
 #endif
-   shape.SetSize(nd);
    elmat.SetSize(nd);
+   shape.SetSize(nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, Trans);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1345,8 +1358,8 @@ void MassIntegrator::AssembleElementMatrix2(
    shape.SetSize(tr_nd);
    te_shape.SetSize(te_nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule :
-                               &GetRule(trial_fe, test_fe, Trans);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1367,18 +1380,13 @@ void MassIntegrator::AssembleElementMatrix2(
    }
 }
 
-const IntegrationRule &MassIntegrator::GetRule(const FiniteElement &trial_fe,
-                                               const FiniteElement &test_fe,
-                                               ElementTransformation &Trans)
+const IntegrationRule &BoundaryMassIntegrator::GetRule(
+   const FiniteElement &el1,
+   const FiniteElement &el2,
+   FaceElementTransformations &Trans) const
 {
-   // int order = trial_fe.GetOrder() + test_fe.GetOrder();
-   const int order = trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW();
-
-   if (trial_fe.Space() == FunctionSpace::rQk)
-   {
-      return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
-   }
-   return IntRules.Get(trial_fe.GetGeomType(), order);
+   int order = el1.GetOrder() + el2.GetOrder();
+   return IntRules.Get(Trans.GetGeometryType(), order);
 }
 
 void BoundaryMassIntegrator::AssembleFaceMatrix(
@@ -1397,13 +1405,7 @@ void BoundaryMassIntegrator::AssembleFaceMatrix(
    elmat.SetSize(nd1);
    shape.SetSize(nd1);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * el1.GetOrder();
-
-      ir = &IntRules.Get(Trans.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1427,6 +1429,15 @@ void BoundaryMassIntegrator::AssembleFaceMatrix(
    }
 }
 
+const IntegrationRule &ConvectionIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = Trans.OrderGrad(&trial_fe) + Trans.Order() + test_fe.GetOrder();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void ConvectionIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
@@ -1446,12 +1457,7 @@ void ConvectionIntegrator::AssembleElementMatrix(
 
    Vector vec1;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = Trans.OrderGrad(&el) + Trans.Order() + el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    Q->Eval(Q_ir, Trans, *ir);
 
@@ -1474,18 +1480,8 @@ void ConvectionIntegrator::AssembleElementMatrix(
    }
 }
 
-const IntegrationRule &ConvectionIntegrator::GetRule(
-   const FiniteElement &fe,
-   ElementTransformation &Trans)
-{
-   int order = Trans.OrderGrad(&fe) + Trans.Order() + fe.GetOrder();
-   return IntRules.Get(fe.GetGeomType(), order);
-}
-
 void GroupConvectionIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+   const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    int dim = el.GetDim();
@@ -1496,12 +1492,7 @@ void GroupConvectionIntegrator::AssembleElementMatrix(
    shape.SetSize(nd);
    grad.SetSize(nd,dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = Trans.OrderGrad(&el) + el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    Q->Eval(Q_nodal, Trans, el.GetNodes()); // sets the size of Q_nodal
 
@@ -1536,10 +1527,9 @@ void GroupConvectionIntegrator::AssembleElementMatrix(
    }
 }
 
-void VectorMassIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+void VectorMassIntegrator::AssembleElementMatrix(const FiniteElement &el,
+                                                 ElementTransformation &Trans,
+                                                 DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    int spaceDim = Trans.GetSpaceDim();
@@ -1561,20 +1551,7 @@ void VectorMassIntegrator::AssembleElementMatrix(
       mcoeff.SetSize(vdim);
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * el.GetOrder() + Trans.OrderW() + Q_order;
-
-      if (el.Space() == FunctionSpace::rQk)
-      {
-         ir = &RefinedIntRules.Get(el.GetGeomType(), order);
-      }
-      else
-      {
-         ir = &IntRules.Get(el.GetGeomType(), order);
-      }
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int s = 0; s < ir->GetNPoints(); s++)
@@ -1644,21 +1621,8 @@ void VectorMassIntegrator::AssembleElementMatrix2(
       mcoeff.SetSize(vdim);
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = (trial_fe.GetOrder() + test_fe.GetOrder() +
-                   Trans.OrderW() + Q_order);
-
-      if (trial_fe.Space() == FunctionSpace::rQk)
-      {
-         ir = &RefinedIntRules.Get(trial_fe.GetGeomType(), order);
-      }
-      else
-      {
-         ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-      }
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int s = 0; s < ir->GetNPoints(); s++)
@@ -1704,6 +1668,179 @@ void VectorMassIntegrator::AssembleElementMatrix2(
    }
 }
 
+void VectorDiffusionIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
+{
+   const int dof = el.GetDof();
+   dim = el.GetDim();
+   sdim = Trans.GetSpaceDim();
+
+   // If vdim is not set, set it to the space dimension;
+   vdim = (vdim <= 0) ? sdim : vdim;
+   const bool square = (dim == sdim);
+
+   if (VQ)
+   {
+      vcoeff.SetSize(vdim);
+   }
+   else if (MQ)
+   {
+      mcoeff.SetSize(vdim);
+   }
+
+   dshape.SetSize(dof, dim);
+   dshapedxt.SetSize(dof, sdim);
+
+   elmat.SetSize(vdim * dof);
+   pelmat.SetSize(dof);
+
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
+
+   elmat = 0.0;
+
+   for (int i = 0; i < ir->GetNPoints(); i++)
+   {
+
+      const IntegrationPoint &ip = ir->IntPoint(i);
+      el.CalcDShape(ip, dshape);
+
+      Trans.SetIntPoint(&ip);
+      double w = Trans.Weight();
+      w = ip.weight / (square ? w : w*w*w);
+      // AdjugateJacobian = / adj(J),         if J is square
+      //                    \ adj(J^t.J).J^t, otherwise
+      Mult(dshape, Trans.AdjugateJacobian(), dshapedxt);
+
+      if (VQ)
+      {
+         VQ->Eval(vcoeff, Trans, ip);
+         for (int k = 0; k < vdim; ++k)
+         {
+            Mult_a_AAt(w*vcoeff(k), dshapedxt, pelmat);
+            elmat.AddMatrix(pelmat, dof*k, dof*k);
+         }
+      }
+      else if (MQ)
+      {
+         MQ->Eval(mcoeff, Trans, ip);
+         for (int ii = 0; ii < vdim; ++ii)
+         {
+            for (int jj = 0; jj < vdim; ++jj)
+            {
+               Mult_a_AAt(w*mcoeff(ii,jj), dshapedxt, pelmat);
+               elmat.AddMatrix(pelmat, dof*ii, dof*jj);
+            }
+         }
+      }
+      else
+      {
+         if (Q) { w *= Q->Eval(Trans, ip); }
+         Mult_a_AAt(w, dshapedxt, pelmat);
+         for (int k = 0; k < vdim; ++k)
+         {
+            elmat.AddMatrix(pelmat, dof*k, dof*k);
+         }
+      }
+   }
+}
+
+void VectorDiffusionIntegrator::AssembleElementVector(
+   const FiniteElement &el, ElementTransformation &Tr,
+   const Vector &elfun, Vector &elvect)
+{
+   const int dof = el.GetDof();
+   dim = el.GetDim();
+   sdim = Tr.GetSpaceDim();
+
+   // If vdim is not set, set it to the space dimension;
+   vdim = (vdim <= 0) ? sdim : vdim;
+   const bool square = (dim == sdim);
+
+   if (VQ)
+   {
+      vcoeff.SetSize(vdim);
+   }
+   else if (MQ)
+   {
+      mcoeff.SetSize(vdim);
+   }
+
+   dshape.SetSize(dof, dim);
+   dshapedxt.SetSize(dof, dim);
+   // pelmat.SetSize(dim);
+
+   elvect.SetSize(dim*dof);
+
+   // NOTE: DenseMatrix is in column-major order. This is consistent with
+   // vectors ordered byNODES. In the resulting DenseMatrix, each column
+   // corresponds to a particular vdim.
+   DenseMatrix mat_in(elfun.GetData(), dof, dim);
+   DenseMatrix mat_out(elvect.GetData(), dof, dim);
+
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
+
+   elvect = 0.0;
+   for (int i = 0; i < ir->GetNPoints(); i++)
+   {
+      const IntegrationPoint &ip = ir->IntPoint(i);
+      el.CalcDShape(ip, dshape);
+
+      Tr.SetIntPoint(&ip);
+      double w = Tr.Weight();
+      w = ip.weight / (square ? w : w*w*w);
+      Mult(dshape, Tr.AdjugateJacobian(), dshapedxt);
+      MultAAt(dshapedxt, pelmat);
+
+      if (VQ)
+      {
+         VQ->Eval(vcoeff, Tr, ip);
+         for (int k = 0; k < vdim; ++k)
+         {
+            pelmat *= w*vcoeff(k);
+            const Vector vec_in(mat_in.GetColumn(k), dof);
+            Vector vec_out(mat_out.GetColumn(k), dof);
+            pelmat.AddMult(vec_in, vec_out);
+         }
+      }
+      else if (MQ)
+      {
+         MQ->Eval(mcoeff, Tr, ip);
+         for (int ii = 0; ii < vdim; ++ii)
+         {
+            Vector vec_out(mat_out.GetColumn(ii), dof);
+            for (int jj = 0; jj < vdim; ++jj)
+            {
+               pelmat *= w*mcoeff(ii,jj);
+               const Vector vec_in(mat_in.GetColumn(jj), dof);
+               pelmat.Mult(vec_in, vec_out);
+            }
+         }
+      }
+      else
+      {
+         if (Q) { w *= Q->Eval(Tr, ip); }
+         pelmat *= w;
+         for (int k = 0; k < vdim; ++k)
+         {
+            const Vector vec_in(mat_in.GetColumn(k), dof);
+            Vector vec_out(mat_out.GetColumn(k), dof);
+            pelmat.AddMult(vec_in, vec_out);
+         }
+      }
+   }
+}
+
+const IntegrationRule &VectorFEDivergenceIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorFEDivergenceIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -1719,12 +1856,8 @@ void VectorFEDivergenceIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = trial_fe.GetOrder() + test_fe.GetOrder() - 1; // <--
-      ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -1744,6 +1877,46 @@ void VectorFEDivergenceIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &VectorFEWeakDivergenceIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   // The integrand on the reference element is:
+   //    -( Q/det(J) ) u_hat^T adj(J) adj(J)^T grad_hat(v_hat).
+   //
+   // For Trans in (P_k)^d, v_hat in P_l, u_hat in ND_m, and dim=sdim=d>=1
+   // - J_{ij} is in P_{k-1}, so adj(J)_{ij} is in P_{(d-1)*(k-1)}
+   // - so adj(J)^T grad_hat(v_hat) is in (P_{(d-1)*(k-1)+(l-1)})^d
+   // - u_hat is in (P_m)^d
+   // - adj(J)^T u_hat is in (P_{(d-1)*(k-1)+m})^d
+   // - and u_hat^T adj(J) adj(J)^T grad_hat(v_hat) is in P_n with
+   //   n = 2*(d-1)*(k-1)+(l-1)+m
+   //
+   // For Trans in (Q_k)^d, v_hat in Q_l, u_hat in ND_m, and dim=sdim=d>1
+   // - J_{i*}, J's i-th row, is in ( Q_{k-1,k,k}, Q_{k,k-1,k}, Q_{k,k,k-1} )
+   // - adj(J)_{*j} is in ( Q_{s,s-1,s-1}, Q_{s-1,s,s-1}, Q_{s-1,s-1,s} )
+   //   with s = (d-1)*k
+   // - adj(J)^T grad_hat(v_hat) is in Q_{(d-1)*k+(l-1)}
+   // - u_hat is in ( Q_{m-1,m,m}, Q_{m,m-1,m}, Q_{m,m,m-1} )
+   // - adj(J)^T u_hat is in Q_{(d-1)*k+(m-1)}
+   // - and u_hat^T adj(J) adj(J)^T grad_hat(v_hat) is in Q_n with
+   //   n = 2*(d-1)*k+(l-1)+(m-1)
+   //
+   // In the next formula we use the expressions for n with k=1, which means
+   // that the term Q/det(J) is disregarded:
+   int order;
+   if (trial_fe.Space() == FunctionSpace::Pk)
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
+   }
+   else
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() + 2 * (trial_fe.GetDim() - 2);
+   }
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorFEWeakDivergenceIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -1770,37 +1943,8 @@ void VectorFEWeakDivergenceIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // The integrand on the reference element is:
-      //    -( Q/det(J) ) u_hat^T adj(J) adj(J)^T grad_hat(v_hat).
-      //
-      // For Trans in (P_k)^d, v_hat in P_l, u_hat in ND_m, and dim=sdim=d>=1
-      // - J_{ij} is in P_{k-1}, so adj(J)_{ij} is in P_{(d-1)*(k-1)}
-      // - so adj(J)^T grad_hat(v_hat) is in (P_{(d-1)*(k-1)+(l-1)})^d
-      // - u_hat is in (P_m)^d
-      // - adj(J)^T u_hat is in (P_{(d-1)*(k-1)+m})^d
-      // - and u_hat^T adj(J) adj(J)^T grad_hat(v_hat) is in P_n with
-      //   n = 2*(d-1)*(k-1)+(l-1)+m
-      //
-      // For Trans in (Q_k)^d, v_hat in Q_l, u_hat in ND_m, and dim=sdim=d>1
-      // - J_{i*}, J's i-th row, is in ( Q_{k-1,k,k}, Q_{k,k-1,k}, Q_{k,k,k-1} )
-      // - adj(J)_{*j} is in ( Q_{s,s-1,s-1}, Q_{s-1,s,s-1}, Q_{s-1,s-1,s} )
-      //   with s = (d-1)*k
-      // - adj(J)^T grad_hat(v_hat) is in Q_{(d-1)*k+(l-1)}
-      // - u_hat is in ( Q_{m-1,m,m}, Q_{m,m-1,m}, Q_{m,m,m-1} )
-      // - adj(J)^T u_hat is in Q_{(d-1)*k+(m-1)}
-      // - and u_hat^T adj(J) adj(J)^T grad_hat(v_hat) is in Q_n with
-      //   n = 2*(d-1)*k+(l-1)+(m-1)
-      //
-      // In the next formula we use the expressions for n with k=1, which means
-      // that the term Q/det(J) is disregarded:
-      int ir_order = (trial_fe.Space() == FunctionSpace::Pk) ?
-                     (trial_fe.GetOrder() + test_fe.GetOrder() - 1) :
-                     (trial_fe.GetOrder() + test_fe.GetOrder() + 2*(dim-2));
-      ir = &IntRules.Get(trial_fe.GetGeomType(), ir_order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -1826,6 +1970,15 @@ void VectorFEWeakDivergenceIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &VectorFECurlIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorFECurlIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -1863,12 +2016,8 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = trial_fe.GetOrder() + test_fe.GetOrder() - 1; // <--
-      ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -1923,6 +2072,27 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &DerivativeIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order;
+   if (trial_fe.Space() == FunctionSpace::Pk)
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
+   }
+   else
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() + trial_fe.GetDim();
+   }
+   if (trial_fe.Space() == FunctionSpace::rQk)
+   {
+      return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
+   }
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void DerivativeIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe,
    const FiniteElement &test_fe,
@@ -1944,28 +2114,8 @@ void DerivativeIntegrator::AssembleElementMatrix2(
    invdfdx.SetSize(dim, spaceDim);
    shape.SetSize(test_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      if (trial_fe.Space() == FunctionSpace::Pk)
-      {
-         order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
-      }
-      else
-      {
-         order = trial_fe.GetOrder() + test_fe.GetOrder() + dim;
-      }
-
-      if (trial_fe.Space() == FunctionSpace::rQk)
-      {
-         ir = &RefinedIntRules.Get(trial_fe.GetGeomType(), order);
-      }
-      else
-      {
-         ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-      }
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -1991,10 +2141,26 @@ void DerivativeIntegrator::AssembleElementMatrix2(
    }
 }
 
-void CurlCurlIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+const IntegrationRule &CurlCurlIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order;
+   if (trial_fe.Space() == FunctionSpace::Pk)
+   {
+      order = test_fe.GetOrder() + trial_fe.GetOrder() - 2;
+   }
+   else
+   {
+      order = test_fe.GetOrder() + trial_fe.GetOrder() + trial_fe.GetDim() - 1;
+   }
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
+void CurlCurlIntegrator::AssembleElementMatrix(const FiniteElement &el,
+                                               ElementTransformation &Trans,
+                                               DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    dim = el.GetDim();
@@ -2009,25 +2175,10 @@ void CurlCurlIntegrator::AssembleElementMatrix(
    curlshape_dFt.SetSize(nd,dimc);
 #endif
    elmat.SetSize(nd);
-
    if (MQ) { M.SetSize(dimc); }
    if (DQ) { D.SetSize(dimc); }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      if (el.Space() == FunctionSpace::Pk)
-      {
-         order = 2*el.GetOrder() - 2;
-      }
-      else
-      {
-         order = 2*el.GetOrder();
-      }
-
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2090,20 +2241,8 @@ void CurlCurlIntegrator::AssembleElementMatrix2(const FiniteElement &trial_fe,
    if (MQ) { M.SetSize(dimc); }
    if (DQ) { D.SetSize(dimc); }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      if (trial_fe.Space() == FunctionSpace::Pk)
-      {
-         order = test_fe.GetOrder() + trial_fe.GetOrder() - 2;
-      }
-      else
-      {
-         order = test_fe.GetOrder() + trial_fe.GetOrder() + trial_fe.GetDim() - 1;
-      }
-      ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2174,7 +2313,7 @@ double CurlCurlIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
    pointflux.SetSize(dim);
    if (d_energy) { vec.SetSize(dim); }
 
-   int order = 2 * fluxelem.GetOrder(); // <--
+   int order = 2 * fluxelem.GetOrder();
    const IntegrationRule &ir = IntRules.Get(fluxelem.GetGeomType(), order);
 
    double energy = 0.0;
@@ -2265,10 +2404,18 @@ double CurlCurlIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
    return energy;
 }
 
+const IntegrationRule &VectorCurlCurlIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   // Use the same integration rule as diffusion
+   int order = Trans.OrderGrad(&trial_fe) + Trans.OrderGrad(&test_fe);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorCurlCurlIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+   const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
    int dim = el.GetDim();
    int dof = el.GetDof();
@@ -2284,13 +2431,7 @@ void VectorCurlCurlIntegrator::AssembleElementMatrix(
    Jadj.SetSize(dim);
 #endif
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // use the same integration rule as diffusion
-      int order = 2 * Trans.OrderGrad(&el);
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat.SetSize(dof*dim);
    elmat = 0.0;
@@ -2332,13 +2473,7 @@ double VectorCurlCurlIntegrator::GetElementEnergy(
 #endif
    DenseMatrix elfun_mat(elfun.GetData(), dof, dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // use the same integration rule as diffusion
-      int order = 2 * Tr.OrderGrad(&el);
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    double energy = 0.;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2380,6 +2515,15 @@ double VectorCurlCurlIntegrator::GetElementEnergy(
    return 0.5 * energy;
 }
 
+const IntegrationRule &MixedCurlIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderJ();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void MixedCurlIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -2415,13 +2559,9 @@ void MixedCurlIntegrator::AssembleElementMatrix2(
 
    double c;
    Vector d_col;
-   const IntegrationRule *ir = IntRule;
 
-   if (ir == NULL)
-   {
-      int order = trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderJ();
-      ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -2458,6 +2598,15 @@ void MixedCurlIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &VectorFEMassIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = Trans.OrderW() + test_fe.GetOrder() + trial_fe.GetOrder();
+   return IntRules.Get(test_fe.GetGeomType(), order);
+}
+
 void VectorFEMassIntegrator::AssembleElementMatrix(
    const FiniteElement &el,
    ElementTransformation &Trans,
@@ -2483,13 +2632,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix(
    elmat.SetSize(dof);
    elmat = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // int order = 2 * el.GetOrder();
-      int order = Trans.OrderW() + 2 * el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -2517,7 +2660,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix(
       {
          if (Q)
          {
-            w *= Q->Eval (Trans, ip);
+            w *= Q->Eval(Trans, ip);
          }
          AddMult_a_AAt(w, trial_vshape, elmat);
       }
@@ -2551,15 +2694,11 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
 #endif
 
       elmat.SetSize(vdim*test_dof, trial_dof);
+      elmat = 0.0;
 
-      const IntegrationRule *ir = IntRule;
-      if (ir == NULL)
-      {
-         int order = (Trans.OrderW() + test_fe.GetOrder() + trial_fe.GetOrder());
-         ir = &IntRules.Get(test_fe.GetGeomType(), order);
-      }
+      const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                               Trans);
 
-      elmat = 0.0;
       for (int i = 0; i < ir->GetNPoints(); i++)
       {
          const IntegrationPoint &ip = ir->IntPoint(i);
@@ -2652,12 +2791,8 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
 
       elmat.SetSize(test_dof, trial_dof);
 
-      const IntegrationRule *ir = IntRule;
-      if (ir == NULL)
-      {
-         int order = (Trans.OrderW() + test_fe.GetOrder() + trial_fe.GetOrder());
-         ir = &IntRules.Get(test_fe.GetGeomType(), order);
-      }
+      const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                               Trans);
 
       elmat = 0.0;
       for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2687,7 +2822,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
          {
             if (Q)
             {
-               w *= Q->Eval (Trans, ip);
+               w *= Q->Eval(Trans, ip);
             }
             AddMult_a_ABt(w,test_vshape,trial_vshape,elmat);
          }
@@ -2700,6 +2835,15 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &VectorDivergenceIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorDivergenceIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe,
    const FiniteElement &test_fe,
@@ -2741,7 +2885,7 @@ void VectorDivergenceIntegrator::AssembleElementMatrix2(
       c = ip.weight;
       if (Q)
       {
-         c *= Q->Eval (Trans, ip);
+         c *= Q->Eval(Trans, ip);
       }
 
       // elmat += c * shape * divshape ^ t
@@ -2750,12 +2894,13 @@ void VectorDivergenceIntegrator::AssembleElementMatrix2(
    }
 }
 
-const IntegrationRule &VectorDivergenceIntegrator::GetRule(
+const IntegrationRule &DivDivIntegrator::GetRule(
    const FiniteElement &trial_fe,
    const FiniteElement &test_fe,
-   ElementTransformation &Trans)
+   ElementTransformation &Trans) const
 {
-   int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
+   int order = 2 * max(trial_fe.GetOrder(),
+                       test_fe.GetOrder()) - 2; // <--- OK for RTk
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
@@ -2774,12 +2919,7 @@ void DivDivIntegrator::AssembleElementMatrix(
 #endif
    elmat.SetSize(dof);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * el.GetOrder() - 2; // <--- OK for RTk
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2793,7 +2933,7 @@ void DivDivIntegrator::AssembleElementMatrix(
 
       if (Q)
       {
-         c *= Q->Eval (Trans, ip);
+         c *= Q->Eval(Trans, ip);
       }
 
       // elmat += c * divshape * divshape ^ t
@@ -2820,13 +2960,8 @@ void DivDivIntegrator::AssembleElementMatrix2(
 #endif
    elmat.SetSize(te_nd,tr_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * max(test_fe.GetOrder(),
-                          trial_fe.GetOrder()) - 2; // <--- OK for RTk
-      ir = &IntRules.Get(test_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2841,7 +2976,7 @@ void DivDivIntegrator::AssembleElementMatrix2(
 
       if (Q)
       {
-         c *= Q->Eval (Trans, ip);
+         c *= Q->Eval(Trans, ip);
       }
 
       te_divshape *= c;
@@ -2849,176 +2984,13 @@ void DivDivIntegrator::AssembleElementMatrix2(
    }
 }
 
-void VectorDiffusionIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
-{
-   const int dof = el.GetDof();
-   dim = el.GetDim();
-   sdim = Trans.GetSpaceDim();
-
-   // If vdim is not set, set it to the space dimension;
-   vdim = (vdim <= 0) ? sdim : vdim;
-   const bool square = (dim == sdim);
-
-   if (VQ)
-   {
-      vcoeff.SetSize(vdim);
-   }
-   else if (MQ)
-   {
-      mcoeff.SetSize(vdim);
-   }
-
-   dshape.SetSize(dof, dim);
-   dshapedxt.SetSize(dof, sdim);
-
-   elmat.SetSize(vdim * dof);
-   pelmat.SetSize(dof);
-
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      ir = &DiffusionIntegrator::GetRule(el,el);
-   }
-
-   elmat = 0.0;
-
-   for (int i = 0; i < ir->GetNPoints(); i++)
-   {
-
-      const IntegrationPoint &ip = ir->IntPoint(i);
-      el.CalcDShape(ip, dshape);
-
-      Trans.SetIntPoint(&ip);
-      double w = Trans.Weight();
-      w = ip.weight / (square ? w : w*w*w);
-      // AdjugateJacobian = / adj(J),         if J is square
-      //                    \ adj(J^t.J).J^t, otherwise
-      Mult(dshape, Trans.AdjugateJacobian(), dshapedxt);
-
-      if (VQ)
-      {
-         VQ->Eval(vcoeff, Trans, ip);
-         for (int k = 0; k < vdim; ++k)
-         {
-            Mult_a_AAt(w*vcoeff(k), dshapedxt, pelmat);
-            elmat.AddMatrix(pelmat, dof*k, dof*k);
-         }
-      }
-      else if (MQ)
-      {
-         MQ->Eval(mcoeff, Trans, ip);
-         for (int ii = 0; ii < vdim; ++ii)
-         {
-            for (int jj = 0; jj < vdim; ++jj)
-            {
-               Mult_a_AAt(w*mcoeff(ii,jj), dshapedxt, pelmat);
-               elmat.AddMatrix(pelmat, dof*ii, dof*jj);
-            }
-         }
-      }
-      else
-      {
-         if (Q) { w *= Q->Eval(Trans, ip); }
-         Mult_a_AAt(w, dshapedxt, pelmat);
-         for (int k = 0; k < vdim; ++k)
-         {
-            elmat.AddMatrix(pelmat, dof*k, dof*k);
-         }
-      }
-   }
-}
-
-void VectorDiffusionIntegrator::AssembleElementVector(
-   const FiniteElement &el, ElementTransformation &Tr,
-   const Vector &elfun, Vector &elvect)
+const IntegrationRule &ElasticityIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
 {
-   const int dof = el.GetDof();
-   dim = el.GetDim();
-   sdim = Tr.GetSpaceDim();
-
-   // If vdim is not set, set it to the space dimension;
-   vdim = (vdim <= 0) ? sdim : vdim;
-   const bool square = (dim == sdim);
-
-   if (VQ)
-   {
-      vcoeff.SetSize(vdim);
-   }
-   else if (MQ)
-   {
-      mcoeff.SetSize(vdim);
-   }
-
-   dshape.SetSize(dof, dim);
-   dshapedxt.SetSize(dof, dim);
-   // pelmat.SetSize(dim);
-
-   elvect.SetSize(dim*dof);
-
-   // NOTE: DenseMatrix is in column-major order. This is consistent with
-   // vectors ordered byNODES. In the resulting DenseMatrix, each column
-   // corresponds to a particular vdim.
-   DenseMatrix mat_in(elfun.GetData(), dof, dim);
-   DenseMatrix mat_out(elvect.GetData(), dof, dim);
-
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      ir = &DiffusionIntegrator::GetRule(el,el);
-   }
-
-   elvect = 0.0;
-   for (int i = 0; i < ir->GetNPoints(); i++)
-   {
-      const IntegrationPoint &ip = ir->IntPoint(i);
-      el.CalcDShape(ip, dshape);
-
-      Tr.SetIntPoint(&ip);
-      double w = Tr.Weight();
-      w = ip.weight / (square ? w : w*w*w);
-      Mult(dshape, Tr.AdjugateJacobian(), dshapedxt);
-      MultAAt(dshapedxt, pelmat);
-
-      if (VQ)
-      {
-         VQ->Eval(vcoeff, Tr, ip);
-         for (int k = 0; k < vdim; ++k)
-         {
-            pelmat *= w*vcoeff(k);
-            const Vector vec_in(mat_in.GetColumn(k), dof);
-            Vector vec_out(mat_out.GetColumn(k), dof);
-            pelmat.AddMult(vec_in, vec_out);
-         }
-      }
-      else if (MQ)
-      {
-         MQ->Eval(mcoeff, Tr, ip);
-         for (int ii = 0; ii < vdim; ++ii)
-         {
-            Vector vec_out(mat_out.GetColumn(ii), dof);
-            for (int jj = 0; jj < vdim; ++jj)
-            {
-               pelmat *= w*mcoeff(ii,jj);
-               const Vector vec_in(mat_in.GetColumn(jj), dof);
-               pelmat.Mult(vec_in, vec_out);
-            }
-         }
-      }
-      else
-      {
-         if (Q) { w *= Q->Eval(Tr, ip); }
-         pelmat *= w;
-         for (int k = 0; k < vdim; ++k)
-         {
-            const Vector vec_in(mat_in.GetColumn(k), dof);
-            Vector vec_out(mat_out.GetColumn(k), dof);
-            pelmat.AddMult(vec_in, vec_out);
-         }
-      }
-   }
+   int order = Trans.OrderGrad(&trial_fe) + Trans.OrderGrad(&test_fe);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
 void ElasticityIntegrator::AssembleElementMatrix(
@@ -3042,12 +3014,7 @@ void ElasticityIntegrator::AssembleElementMatrix(
 
    elmat.SetSize(dof * dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * Trans.OrderGrad(&el); // correct order?
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
 
@@ -3210,12 +3177,7 @@ double ElasticityIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
    // Use the same integration rule as in AssembleElementMatrix, replacing 'el'
    // with 'fluxelem' when 'IntRule' is not set.
    // Should we be using a different (more accurate) rule here?
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * Trans.OrderGrad(&fluxelem);
-      ir = &IntRules.Get(fluxelem.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fluxelem, Trans);
 
    double energy = 0.0;
 
@@ -3275,6 +3237,28 @@ double ElasticityIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
    return energy;
 }
 
+const IntegrationRule &DGTraceIntegrator::GetRule(
+   const FiniteElement &el1, const FiniteElement &el2,
+   FaceElementTransformations &Trans) const
+{
+   // Assuming order(u) == order(mesh)
+   int order;
+   if (Trans.Elem2No >= 0)
+   {
+      order = (min(Trans.Elem1->OrderW(), Trans.Elem2->OrderW()) +
+               2 * max(el1.GetOrder(), el2.GetOrder()));
+   }
+   else
+   {
+      order = Trans.Elem1->OrderW() + 2 * el1.GetOrder();
+   }
+   if (el1.Space() == FunctionSpace::Pk)
+   {
+      order++;
+   }
+   return IntRules.Get(Trans.GetGeometryType(), order);
+}
+
 void DGTraceIntegrator::AssembleFaceMatrix(const FiniteElement &el1,
                                            const FiniteElement &el2,
                                            FaceElementTransformations &Trans,
@@ -3302,24 +3286,7 @@ void DGTraceIntegrator::AssembleFaceMatrix(const FiniteElement &el1,
    elmat.SetSize(ndof1 + ndof2);
    elmat = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      // Assuming order(u)==order(mesh)
-      if (Trans.Elem2No >= 0)
-         order = (min(Trans.Elem1->OrderW(), Trans.Elem2->OrderW()) +
-                  2*max(el1.GetOrder(), el2.GetOrder()));
-      else
-      {
-         order = Trans.Elem1->OrderW() + 2*el1.GetOrder();
-      }
-      if (el1.Space() == FunctionSpace::Pk)
-      {
-         order++;
-      }
-      ir = &IntRules.Get(Trans.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, el2, Trans);
 
    for (int p = 0; p < ir->GetNPoints(); p++)
    {
@@ -3408,11 +3375,21 @@ void DGTraceIntegrator::AssembleFaceMatrix(const FiniteElement &el1,
    }
 }
 
-const IntegrationRule &DGTraceIntegrator::GetRule(
-   Geometry::Type geom, int order, FaceElementTransformations &T)
+const IntegrationRule &DGDiffusionIntegrator::GetRuleStatic(
+   const FiniteElement &el1, const FiniteElement &el2,
+   FaceElementTransformations &Trans)
 {
-   int int_order = T.Elem1->OrderW() + 2*order;
-   return IntRules.Get(geom, int_order);
+   // A simple choice for the integration order; is this OK?
+   int order;
+   if (Trans.Elem2No >= 0)
+   {
+      order = 2 * max(el1.GetOrder(), el2.GetOrder());
+   }
+   else
+   {
+      order = 2 * el1.GetOrder();
+   }
+   return IntRules.Get(Trans.GetGeometryType(), order);
 }
 
 void DGDiffusionIntegrator::AssembleFaceMatrix(
@@ -3459,21 +3436,7 @@ void DGDiffusionIntegrator::AssembleFaceMatrix(
       jmat = 0.;
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // a simple choice for the integration order; is this OK?
-      int order;
-      if (ndof2)
-      {
-         order = 2*max(el1.GetOrder(), el2.GetOrder());
-      }
-      else
-      {
-         order = 2*el1.GetOrder();
-      }
-      ir = &IntRules.Get(Trans.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, el2, Trans);
 
    // assemble: < {(Q \nabla u).n},[v] >      --> elmat
    //           kappa < {h^{-1} Q} [u],[v] >  --> jmat
@@ -3749,13 +3712,7 @@ void DGElasticityIntegrator::AssembleFaceMatrix(
       dshape2_dnM.SetSize(ndofs2);
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // a simple choice for the integration order; is this OK?
-      const int order = 2 * max(el1.GetOrder(), ndofs2 ? el2.GetOrder() : 0);
-      ir = &IntRules.Get(Trans.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, el2, Trans);
 
    for (int pind = 0; pind < ir->GetNPoints(); ++pind)
    {
@@ -3872,7 +3829,7 @@ void DGElasticityIntegrator::AssembleFaceMatrix(
    }
 }
 
-void TraceJumpIntegrator::AssembleFaceMatrix(
+void TraceJumpIntegrator::AssembleFaceMatrix2(
    const FiniteElement &trial_face_fe, const FiniteElement &test_fe1,
    const FiniteElement &test_fe2, FaceElementTransformations &Trans,
    DenseMatrix &elmat)
@@ -3964,7 +3921,7 @@ void TraceJumpIntegrator::AssembleFaceMatrix(
    }
 }
 
-void NormalTraceJumpIntegrator::AssembleFaceMatrix(
+void NormalTraceJumpIntegrator::AssembleFaceMatrix2(
    const FiniteElement &trial_face_fe, const FiniteElement &test_fe1,
    const FiniteElement &test_fe2, FaceElementTransformations &Trans,
    DenseMatrix &elmat)
@@ -4312,11 +4269,11 @@ struct ShapeCoefficient : public VectorCoefficient
 
 }
 
-void
-ScalarProductInterpolator::AssembleElementMatrix2(const FiniteElement &dom_fe,
-                                                  const FiniteElement &ran_fe,
-                                                  ElementTransformation &Trans,
-                                                  DenseMatrix &elmat)
+void ScalarProductInterpolator::AssembleElementMatrix2(
+   const FiniteElement &dom_fe,
+   const FiniteElement &ran_fe,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    internal::ShapeCoefficient dom_shape_coeff(*Q, dom_fe);
 
@@ -4327,8 +4284,7 @@ ScalarProductInterpolator::AssembleElementMatrix2(const FiniteElement &dom_fe,
    ran_fe.Project(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-void
-ScalarVectorProductInterpolator::AssembleElementMatrix2(
+void ScalarVectorProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
@@ -4361,8 +4317,7 @@ ScalarVectorProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-void
-VectorScalarProductInterpolator::AssembleElementMatrix2(
+void VectorScalarProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
@@ -4398,8 +4353,7 @@ VectorScalarProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-void
-ScalarCrossProductInterpolator::AssembleElementMatrix2(
+void ScalarCrossProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
@@ -4440,8 +4394,7 @@ ScalarCrossProductInterpolator::AssembleElementMatrix2(
    ran_fe.Project(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-void
-VectorCrossProductInterpolator::AssembleElementMatrix2(
+void VectorCrossProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
diff --git a/fem/bilininteg.hpp b/fem/bilininteg.hpp
index 209898714..598da405d 100644
--- a/fem/bilininteg.hpp
+++ b/fem/bilininteg.hpp
@@ -41,10 +41,6 @@ public:
    // TODO: add support for other assembly levels (in addition to PA) and their
    // actions.
 
-   // TODO: for mixed meshes the quadrature rules to be used by methods like
-   // AssemblePA() can be given as a QuadratureSpace, e.g. using a new method:
-   // SetQuadratureSpace().
-
    // TODO: the methods for the various assembly levels make sense even in the
    // base class NonlinearFormIntegrator, except that not all assembly levels
    // make sense for the action of the nonlinear operator (but they all make
@@ -159,11 +155,11 @@ public:
 
    /** Abstract method used for assembling TraceFaceIntegrators in a
        MixedBilinearForm. */
-   virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
-                                   const FiniteElement &test_fe1,
-                                   const FiniteElement &test_fe2,
-                                   FaceElementTransformations &Trans,
-                                   DenseMatrix &elmat);
+   virtual void AssembleFaceMatrix2(const FiniteElement &trial_face_fe,
+                                    const FiniteElement &test_fe1,
+                                    const FiniteElement &test_fe2,
+                                    FaceElementTransformations &Trans,
+                                    DenseMatrix &elmat);
 
    /** Abstract method used for assembling TraceFaceIntegrators for
        DPG weak formulations. */
@@ -173,7 +169,6 @@ public:
                                         FaceElementTransformations &Trans,
                                         DenseMatrix &elmat);
 
-
    /// @brief Perform the local action of the BilinearFormIntegrator.
    /// Note that the default implementation in the base class is general but not
    /// efficient.
@@ -282,7 +277,12 @@ public:
    TransposeIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
    { bfi = bfi_; own_bfi = own_bfi_; }
 
-   virtual void SetIntRule(const IntegrationRule *ir);
+   virtual bool SupportsCeed() const { return bfi->SupportsCeed(); }
+
+   virtual void SetIntRule(const IntegrationRule *ir)
+   {
+      IntRule = ir; bfi->SetIntRule(ir);
+   }
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
@@ -293,7 +293,6 @@ public:
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -362,7 +361,12 @@ public:
    LumpedIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
    { bfi = bfi_; own_bfi = own_bfi_; }
 
-   virtual void SetIntRule(const IntegrationRule *ir);
+   virtual bool SupportsCeed() const { return bfi->SupportsCeed(); }
+
+   virtual void SetIntRule(const IntegrationRule *ir)
+   {
+      IntRule = ir; bfi->SetIntRule(ir);
+   }
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
@@ -375,57 +379,64 @@ public:
 class InverseIntegrator : public BilinearFormIntegrator
 {
 private:
-   bool own_integrator;
-   BilinearFormIntegrator *integrator;
+   bool own_bfi;
+   BilinearFormIntegrator *bfi;
 
 public:
-   InverseIntegrator(BilinearFormIntegrator *integ, bool own_integ = 1)
-   { integrator = integ; own_integrator = own_integ; }
+   InverseIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
+   { bfi = bfi_; own_bfi = own_bfi_; }
 
-   virtual void SetIntRule(const IntegrationRule *ir);
+   virtual bool SupportsCeed() const { return bfi->SupportsCeed(); }
+
+   virtual void SetIntRule(const IntegrationRule *ir)
+   {
+      IntRule = ir; bfi->SetIntRule(ir);
+   }
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
 
-   virtual ~InverseIntegrator() { if (own_integrator) { delete integrator; } }
+   virtual ~InverseIntegrator() { if (own_bfi) { delete bfi; } }
 };
 
 /// Integrator defining a sum of multiple Integrators.
 class SumIntegrator : public BilinearFormIntegrator
 {
 private:
-   bool own_integrators;
-   mutable DenseMatrix elem_mat;
-   Array<BilinearFormIntegrator*> integrators;
+   bool own_bfis;
+   Array<BilinearFormIntegrator*> bfis;
+   DenseMatrix bfi_elmat;
 
 public:
-   SumIntegrator(bool own_integs = true) { own_integrators = own_integs; }
+   SumIntegrator(bool own_bfis_ = true) { own_bfis = own_bfis_; }
 
-   virtual void SetIntRule(const IntegrationRule *ir);
+   void AddIntegrator(BilinearFormIntegrator *bfi)
+   { bfis.Append(bfi); }
+
+   virtual bool SupportsCeed() const;
 
-   void AddIntegrator(BilinearFormIntegrator *integ)
-   { integrators.Append(integ); }
+   virtual void SetIntRule(const IntegrationRule *ir);
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
-                                   const FiniteElement &test_fe1,
-                                   const FiniteElement &test_fe2,
-                                   FaceElementTransformations &Trans,
-                                   DenseMatrix &elmat);
+   virtual void AssembleFaceMatrix2(const FiniteElement &trial_face_fe,
+                                    const FiniteElement &test_fe1,
+                                    const FiniteElement &test_fe2,
+                                    FaceElementTransformations &Trans,
+                                    DenseMatrix &elmat);
 
    virtual void AssemblePA(const FiniteElementSpace &fes);
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
@@ -469,6 +480,11 @@ public:
 class MixedScalarIntegrator: public BilinearFormIntegrator
 {
 public:
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -486,39 +502,40 @@ protected:
    /// result if given the same FiniteElement. The default is false.
    bool same_calc_shape;
 
+   Coefficient *Q;
+
    MixedScalarIntegrator() : same_calc_shape(false), Q(NULL) {}
    MixedScalarIntegrator(Coefficient &q) : same_calc_shape(false), Q(&q) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement &trial_fe, const FiniteElement &test_fe) const
+   virtual bool VerifyFiniteElementTypes(
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarIntegrator:  "
              "Trial and test spaces must both be scalar fields.";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     Vector &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              Vector &shape)
    { test_fe.CalcPhysShape(Trans, shape); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      Vector &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               Vector &shape)
    { trial_fe.CalcPhysShape(Trans, shape); }
 
-   Coefficient *Q;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector test_shape, trial_shape;
@@ -530,6 +547,11 @@ private:
 class MixedVectorIntegrator: public BilinearFormIntegrator
 {
 public:
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -547,6 +569,12 @@ protected:
    /// result if given the same FiniteElement. The default is false.
    bool same_calc_shape;
 
+   int space_dim;
+   Coefficient *Q;
+   VectorCoefficient *VQ;
+   DiagonalMatrixCoefficient *DQ;
+   MatrixCoefficient *MQ;
+
    MixedVectorIntegrator()
       : same_calc_shape(false), Q(NULL), VQ(NULL), DQ(NULL), MQ(NULL) {}
    MixedVectorIntegrator(Coefficient &q)
@@ -557,47 +585,41 @@ protected:
    MixedVectorIntegrator(MatrixCoefficient &mq)
       : same_calc_shape(false), Q(NULL), VQ(NULL), DQ(NULL), MQ(&mq) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorIntegrator:  "
              "Trial and test spaces must both be vector fields";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return std::max(space_dim, test_fe.GetVDim()); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcVShape(Trans, shape); }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return std::max(space_dim, trial_fe.GetVDim()); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcVShape(Trans, shape); }
 
-   int space_dim;
-   Coefficient *Q;
-   VectorCoefficient *VQ;
-   DiagonalMatrixCoefficient *DQ;
-   MatrixCoefficient *MQ;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector V, D;
@@ -611,6 +633,11 @@ private:
 class MixedScalarVectorIntegrator: public BilinearFormIntegrator
 {
 public:
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -627,24 +654,28 @@ public:
    { AssembleElementMatrix2(fe, fe, Trans, elmat); }
 
 protected:
+   VectorCoefficient *VQ;
+   int space_dim;
+   bool transpose;
+   bool cross_2d;  // In 2D use a cross product rather than a dot product
+
    MixedScalarVectorIntegrator(VectorCoefficient &vq, bool transpose_ = false,
                                bool cross_2d_ = false)
       : VQ(&vq), transpose(transpose_), cross_2d(cross_2d_) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return ((transpose &&
                trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR ) ||
+               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR) ||
               (!transpose &&
                trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR )
-             );
+               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR));
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       if (transpose)
       {
@@ -660,35 +691,28 @@ protected:
       }
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-   inline virtual int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return std::max(space_dim, vector_fe.GetVDim()); }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape_)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape_)
    { vector_fe.CalcVShape(Trans, shape_); }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape_)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape_)
    { scalar_fe.CalcPhysShape(Trans, shape_); }
 
-   VectorCoefficient *VQ;
-   int space_dim;
-   bool transpose;
-   bool cross_2d;  // In 2D use a cross product rather than a dot product
-
 private:
 #ifndef MFEM_THREAD_SAFE
-   Vector V;
+   Vector V, shape, vshape_tmp;
    DenseMatrix vshape;
-   Vector      shape;
-   Vector      vshape_tmp;
 #endif
 };
 
@@ -723,25 +747,25 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 1 && test_fe.GetDim() == 1 &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD  &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarDerivativeIntegrator:  "
              "Trial and test spaces must both be scalar fields in 1D "
              "and the trial space must implement CalcDShape.";
    }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      Vector &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       trial_fe.CalcPhysDShape(Trans, dshape);
@@ -758,16 +782,16 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 1 && test_fe.GetDim() == 1 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakDerivativeIntegrator:  "
              "Trial and test spaces must both be scalar fields in 1D "
@@ -775,9 +799,9 @@ protected:
              "map type \"VALUE\".";
    }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     Vector &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       test_fe.CalcPhysDShape(Trans, dshape);
@@ -796,29 +820,29 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
-      return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV  &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+      return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarDivergenceIntegrator:  "
              "Trial must be H(Div) and the test space must be a "
              "scalar field";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      Vector &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               Vector &shape)
    { trial_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -832,15 +856,15 @@ public:
       : MixedScalarVectorIntegrator(vq) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
-      return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV  &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+      return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorDivergenceIntegrator:  "
              "Trial must be H(Div) and the test space must be a "
@@ -849,14 +873,14 @@ protected:
 
    // Subtract one due to the divergence and add one for the coefficient
    // which is assumed to be at least linear.
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1 + 1; }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -871,24 +895,24 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::DIV );
+              test_fe.GetDerivType()  == mfem::FiniteElement::DIV);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakGradientIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be H(Div)";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
    virtual void CalcTestShape(const FiniteElement &test_fe,
@@ -911,7 +935,7 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -920,21 +944,21 @@ protected:
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCurlIntegrator:  "
              "Trial must be H(Curl) and the test space must be a "
              "scalar field";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      Vector &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       trial_fe.CalcPhysCurlShape(Trans, dshape);
@@ -968,25 +992,25 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCurlIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be H(Curl)";
    }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     Vector &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       test_fe.CalcPhysCurlShape(Trans, dshape);
@@ -1026,15 +1050,15 @@ public:
    MixedDotProductIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDotProductIntegrator:  "
              "Trial space must be a vector field "
@@ -1051,16 +1075,16 @@ public:
    MixedWeakGradDotIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::DIV );
+              test_fe.GetDerivType()  == mfem::FiniteElement::DIV);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakGradDotIntegrator:  "
              "Trial space must be a vector field "
@@ -1069,14 +1093,14 @@ public:
 
    // Subtract one due to the gradient and add one for the coefficient
    // which is assumed to be at least linear.
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1 + 1; }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1088,29 +1112,29 @@ public:
    MixedWeakDivCrossIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakDivCrossIntegrator:  "
              "Trial space must be a vector field in 3D "
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1128,26 +1152,26 @@ public:
    MixedGradGradIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) { same_calc_shape = true; }
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedGradGradIntegrator:  "
              "Trial and test spaces must both be scalar fields "
              "with a gradient operator.";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    {
       // Same as DiffusionIntegrator
       return test_fe.Space() == FunctionSpace::Pk ?
@@ -1155,20 +1179,20 @@ public:
              trial_fe.GetOrder() + test_fe.GetOrder() + test_fe.GetDim() - 1;
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1180,37 +1204,37 @@ public:
    MixedCrossGradGradIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) { same_calc_shape = true; }
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradGradIntegrator:  "
              "Trial and test spaces must both be scalar fields "
              "with a gradient operator.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1228,7 +1252,7 @@ public:
    MixedCurlCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) { same_calc_shape = true; }
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -1236,30 +1260,30 @@ public:
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCurlCurlIntegrator"
              "Trial and test spaces must both be vector fields in 3D "
              "with a curl.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1271,7 +1295,7 @@ public:
    MixedCrossCurlCurlIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) { same_calc_shape = true; }
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -1280,30 +1304,30 @@ public:
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlCurlIntegrator:  "
              "Trial and test spaces must both be vector fields in 3D "
              "with a curl.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1315,7 +1339,7 @@ public:
    MixedCrossCurlGradIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -1323,30 +1347,30 @@ public:
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlGradIntegrator"
              "Trial space must be a vector field in 3D with a curl"
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1358,7 +1382,7 @@ public:
    MixedCrossGradCurlIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -1366,30 +1390,30 @@ public:
               trial_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType()  == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType() == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType() == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradCurlIntegrator"
              "Trial space must be a scalar field in 3D with a gradient"
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1402,29 +1426,29 @@ public:
    MixedWeakCurlCrossIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakCurlCrossIntegrator:  "
              "Trial space must be a vector field in 3D "
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1437,26 +1461,26 @@ public:
    MixedScalarWeakCurlCrossIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCurlCrossIntegrator:  "
              "Trial space must be a vector field in 2D "
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       scalar_fe.CalcPhysCurlShape(Trans, dshape);
@@ -1472,34 +1496,34 @@ public:
    MixedCrossGradIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (test_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradIntegrator:  "
              "Trial space must be a scalar field with a gradient operator"
              " and the test space must be a vector field both in 3D.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcVShape(Trans, shape); }
 };
 
@@ -1512,29 +1536,29 @@ public:
    MixedCrossCurlIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::CURL   &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlIntegrator:  "
              "Trial space must be a vector field in 3D with a curl "
              "and the test space must be a vector field";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1547,26 +1571,26 @@ public:
    MixedScalarCrossCurlIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, false, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::CURL   &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlIntegrator:  "
              "Trial space must be a vector field in 2D with a curl "
              "and the test space must be a vector field";
    }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       scalar_fe.CalcPhysCurlShape(Trans, dshape); shape *= -1.0;
@@ -1581,29 +1605,29 @@ public:
    MixedScalarCrossGradIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCrossGradIntegrator:  "
              "Trial space must be a scalar field in 2D with a gradient "
              "and the test space must be a scalar field";
    }
 
-   inline int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1615,16 +1639,16 @@ public:
    MixedScalarCrossProductIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCrossProductIntegrator:  "
              "Trial space must be a vector field in 2D "
@@ -1640,25 +1664,25 @@ public:
    MixedScalarWeakCrossProductIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, false, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCrossProductIntegrator:  "
              "Trial space must be a scalar field in 2D "
              "and the test space must be a vector field";
    }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1670,28 +1694,28 @@ public:
    MixedDirectionalDerivativeIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDirectionalDerivativeIntegrator:  "
              "Trial space must be a scalar field with a gradient "
              "and the test space must be a scalar field";
    }
 
-   inline virtual int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1703,34 +1727,34 @@ public:
    MixedGradDivIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
+              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::DIV   );
+              test_fe.GetDerivType()  == mfem::FiniteElement::DIV);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedGradDivIntegrator:  "
              "Trial space must be a scalar field with a gradient"
              "and the test space must be a vector field with a divergence";
    }
 
-   inline virtual int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -1742,35 +1766,34 @@ public:
    MixedDivGradIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::DIV    &&
+              trial_fe.GetDerivType() == mfem::FiniteElement::DIV &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD
-             );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDivGradIntegrator:  "
              "Trial space must be a vector field with a divergence"
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -1782,28 +1805,28 @@ public:
    MixedScalarWeakDivergenceIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD   );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakDivergenceIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1824,40 +1847,57 @@ public:
    MixedVectorGradientIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorGradientIntegrator:  "
              "Trial spaces must be H1 and the test space must be a "
              "vector field in 2D or 3D";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    {
       trial_fe.CalcPhysDShape(Trans, shape);
    }
 
+private:
    DenseMatrix Jinv;
 
    // PA extension
@@ -1882,6 +1922,8 @@ public:
    MixedVectorCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
@@ -1890,29 +1932,35 @@ public:
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::CURL  &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorCurlIntegrator:  "
              "Trial space must be H(Curl) and the test space must be a "
              "vector field in 3D";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    {
       trial_fe.CalcPhysCurlShape(Trans, shape);
    }
@@ -1942,6 +1990,8 @@ public:
    MixedVectorWeakCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
@@ -1950,29 +2000,35 @@ public:
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorWeakCurlIntegrator:  "
              "Trial space must be vector field in 3D and the "
              "test space must be H(Curl)";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    {
       test_fe.CalcPhysCurlShape(Trans, shape);
    }
@@ -2000,28 +2056,50 @@ public:
    MixedVectorWeakDivergenceIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorWeakDivergenceIntegrator:  "
              "Trial space must be vector field and the "
              "test space must be H1";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    {
       test_fe.CalcPhysDShape(Trans, shape);
       shape *= -1.0;
@@ -2063,6 +2141,11 @@ public:
       Q{&q}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
    {}
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2075,10 +2158,6 @@ public:
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
-
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe,
-                                         ElementTransformation &Trans);
 };
 
 /** Class for integrating the bilinear form a(u,v) := (Q grad u, grad v) where Q
@@ -2128,6 +2207,18 @@ public:
       : BilinearFormIntegrator(ir),
         Q(NULL), VQ(NULL), MQ(&q), maps(NULL), geom(NULL) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   static const IntegrationRule &GetRuleStatic(const FiniteElement &trial_fe,
+                                               const FiniteElement &test_fe,
+                                               ElementTransformation &Trans);
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return GetRuleStatic(trial_fe, test_fe, Trans); }
+
    /** Given a particular Finite Element computes the element stiffness matrix
        elmat. */
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -2159,6 +2250,9 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
@@ -2168,6 +2262,9 @@ public:
    using BilinearFormIntegrator::AssembleMF;
    virtual void AssembleMF(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
@@ -2175,11 +2272,6 @@ public:
    using BilinearFormIntegrator::AssembleEA;
    virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe);
-
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
-
    Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2210,6 +2302,19 @@ public:
    MassIntegrator(Coefficient &q, const IntegrationRule *ir = NULL)
       : BilinearFormIntegrator(ir), Q(&q), maps(NULL), geom(NULL) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   static const IntegrationRule &GetRuleStatic(const FiniteElement &trial_fe,
+                                               const FiniteElement &test_fe,
+                                               ElementTransformation &Trans,
+                                               int Q_order = 0);
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return GetRuleStatic(trial_fe, test_fe, Trans); }
+
    /** Given a particular Finite Element computes the element mass matrix
        elmat. */
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -2236,6 +2341,9 @@ public:
    using BilinearFormIntegrator::AssembleMF;
    virtual void AssembleMF(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
@@ -2243,12 +2351,6 @@ public:
    using BilinearFormIntegrator::AssembleEA;
    virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe,
-                                         ElementTransformation &Trans);
-
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
-
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2258,7 +2360,10 @@ class BoundaryMassIntegrator : public MassIntegrator
 public:
    BoundaryMassIntegrator(Coefficient &q) : MassIntegrator(q) {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const;
 
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
@@ -2289,6 +2394,13 @@ public:
    ConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
       : Q(&q) { alpha = a; }
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix(const FiniteElement &fes,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
@@ -2296,6 +2408,9 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
@@ -2305,17 +2420,15 @@ public:
    using BilinearFormIntegrator::AssembleMF;
    virtual void AssembleMF(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 
    using BilinearFormIntegrator::AssembleEA;
    virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
-
-   static const IntegrationRule &GetRule(const FiniteElement &fe,
-                                         ElementTransformation &Trans);
-
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
 };
 
 // Alias for @ConvectionIntegrator.
@@ -2349,33 +2462,154 @@ public:
                                       DenseMatrix &);
 };
 
-/** Class for integrating the bilinear form a(u,v) := (Q u, v),
-    where u=(u1,...,un) and v=(v1,...,vn); ui and vi are defined
-    by scalar FE through standard transformation. */
-class VectorMassIntegrator: public BilinearFormIntegrator
-{
-private:
-   int vdim;
-   Vector shape, te_shape, vec;
-   DenseMatrix partelmat;
-   DenseMatrix mcoeff;
-   int Q_order;
+/** Integrator for
 
+      (Q grad u, grad v) = sum_i (Q grad u_i, grad v_i) e_i e_i^T
+
+    for vector FE spaces, where e_i is the unit vector in the i-th direction.
+    The resulting local element matrix is square, of size <tt> vdim*dof </tt>,
+    where \c vdim is the vector dimension space and \c dof is the local degrees
+    of freedom. The integrator is not aware of the true vector dimension and
+    must use \c VectorCoefficient, \c MatrixCoefficient, or a caller-specified
+    value to determine the vector space. For a scalar coefficient, the caller
+    may manually specify the vector dimension or the vector dimension is assumed
+    to be the spatial dimension (i.e. 2-dimension or 3-dimension).
+*/
+class VectorDiffusionIntegrator : public BilinearFormIntegrator
+{
 protected:
-   Coefficient *Q;
-   VectorCoefficient *VQ;
-   MatrixCoefficient *MQ;
+   Coefficient *Q = NULL;
+   VectorCoefficient *VQ = NULL;
+   MatrixCoefficient *MQ = NULL;
 
    // PA extension
-   Vector pa_data;
    const DofToQuad *maps;         ///< Not owned
    const GeometricFactors *geom;  ///< Not owned
-   int dim, ne, nq, dofs1D, quad1D;
+   int dim, sdim, ne, dofs1D, quad1D;
+   Vector pa_data;
+
+private:
+   DenseMatrix dshape, dshapedxt, pelmat;
+   int vdim = -1;
+   DenseMatrix mcoeff;
+   Vector vcoeff;
 
 public:
-   /// Construct an integrator with coefficient 1.0
-   VectorMassIntegrator()
-      : vdim(-1), Q_order(0), Q(NULL), VQ(NULL), MQ(NULL) {}
+   VectorDiffusionIntegrator() {}
+
+   /** \brief Integrator with unit coefficient for caller-specified vector
+       dimension.
+
+       If the vector dimension does not match the true dimension of the space,
+       the resulting element matrix will be mathematically invalid. */
+   VectorDiffusionIntegrator(int vector_dimension)
+      : vdim(vector_dimension) {}
+
+   VectorDiffusionIntegrator(Coefficient &q)
+      : Q(&q) {}
+
+   VectorDiffusionIntegrator(Coefficient &q, const IntegrationRule *ir)
+      : BilinearFormIntegrator(ir), Q(&q) {}
+
+   /** \brief Integrator with scalar coefficient for caller-specified vector
+       dimension.
+
+       The element matrix is block-diagonal with \c vdim copies of the element
+       matrix integrated with the \c Coefficient.
+
+       If the vector dimension does not match the true dimension of the space,
+       the resulting element matrix will be mathematically invalid. */
+   VectorDiffusionIntegrator(Coefficient &q, int vector_dimension)
+      : Q(&q), vdim(vector_dimension) {}
+
+   /** \brief Integrator with \c VectorCoefficient. The vector dimension of the
+       \c FiniteElementSpace is assumed to be the same as the dimension of the
+       \c Vector.
+
+       The element matrix is block-diagonal and each block is integrated with
+       coefficient q_i.
+
+       If the vector dimension does not match the true dimension of the space,
+       the resulting element matrix will be mathematically invalid. */
+   VectorDiffusionIntegrator(VectorCoefficient &vq)
+      : VQ(&vq), vdim(vq.GetVDim()) {}
+
+   /** \brief Integrator with \c MatrixCoefficient. The vector dimension of the
+       \c FiniteElementSpace is assumed to be the same as the dimension of the
+       \c Matrix.
+
+       The element matrix is populated in each block. Each block is integrated
+       with coefficient q_ij.
+
+       If the vector dimension does not match the true dimension of the space,
+       the resulting element matrix will be mathematically invalid. */
+   VectorDiffusionIntegrator(MatrixCoefficient& mq)
+      : MQ(&mq), vdim(mq.GetVDim()) {}
+
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return DiffusionIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
+
+   virtual void AssembleElementMatrix(const FiniteElement &el,
+                                      ElementTransformation &Trans,
+                                      DenseMatrix &elmat);
+
+   virtual void AssembleElementVector(const FiniteElement &el,
+                                      ElementTransformation &Tr,
+                                      const Vector &elfun, Vector &elvect);
+
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+};
+
+/** Class for integrating the bilinear form a(u,v) := (Q u, v),
+    where u=(u1,...,un) and v=(v1,...,vn); ui and vi are defined
+    by scalar FE through standard transformation. */
+class VectorMassIntegrator: public BilinearFormIntegrator
+{
+private:
+   int vdim;
+   Vector shape, te_shape, vec;
+   DenseMatrix partelmat;
+   DenseMatrix mcoeff;
+   int Q_order;
+
+protected:
+   Coefficient *Q;
+   VectorCoefficient *VQ;
+   MatrixCoefficient *MQ;
+
+   // PA extension
+   Vector pa_data;
+   const DofToQuad *maps;         ///< Not owned
+   const GeometricFactors *geom;  ///< Not owned
+   int dim, ne, nq, dofs1D, quad1D;
+
+public:
+   /// Construct an integrator with coefficient 1.0
+   VectorMassIntegrator()
+      : vdim(-1), Q_order(0), Q(NULL), VQ(NULL), MQ(NULL) {}
    /** Construct an integrator with scalar coefficient q.  If possible, save
        memory by using a scalar integrator since the resulting matrix is block
        diagonal with the same diagonal block repeated. */
@@ -2394,6 +2628,14 @@ public:
    int GetVDim() const { return vdim; }
    void SetVDim(int vdim_) { vdim = vdim_; }
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return MassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans, Q_order); }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
@@ -2406,6 +2648,9 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
@@ -2413,11 +2658,12 @@ public:
    using BilinearFormIntegrator::AssembleMF;
    virtual void AssembleMF(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
-
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
 };
 
 /** Class for integrating (div u, p) where u is a vector field given by
@@ -2430,14 +2676,14 @@ public:
     ElementTransformation Trans. */
 class VectorFEDivergenceIntegrator : public BilinearFormIntegrator
 {
-protected:
-   Coefficient *Q;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector divshape, shape;
 #endif
 
+protected:
+   Coefficient *Q;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *mapsO;         ///< Not owned. DOF-to-quad map, open.
@@ -2449,9 +2695,10 @@ public:
    VectorFEDivergenceIntegrator() { Q = NULL; }
    VectorFEDivergenceIntegrator(Coefficient &q) { Q = &q; }
 
-   virtual void AssembleElementMatrix(const FiniteElement &el,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &elmat) {}
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2473,9 +2720,6 @@ public:
     This is equivalent to a weak divergence of the Nedelec basis functions. */
 class VectorFEWeakDivergenceIntegrator: public BilinearFormIntegrator
 {
-protected:
-   Coefficient *Q;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    DenseMatrix dshape;
@@ -2484,13 +2728,17 @@ private:
    DenseMatrix invdfdx;
 #endif
 
+protected:
+   Coefficient *Q;
+
 public:
    VectorFEWeakDivergenceIntegrator() { Q = NULL; }
    VectorFEWeakDivergenceIntegrator(Coefficient &q) { Q = &q; }
 
-   virtual void AssembleElementMatrix(const FiniteElement &el,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &elmat) {}
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2502,9 +2750,6 @@ public:
     test spaces are switched, assembles the form (u, curl v). */
 class VectorFECurlIntegrator: public BilinearFormIntegrator
 {
-protected:
-   Coefficient *Q;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    DenseMatrix curlshapeTrial;
@@ -2512,13 +2757,17 @@ private:
    DenseMatrix curlshapeTrial_dFT;
 #endif
 
+protected:
+   Coefficient *Q;
+
 public:
    VectorFECurlIntegrator() { Q = NULL; }
    VectorFECurlIntegrator(Coefficient &q) { Q = &q; }
 
-   virtual void AssembleElementMatrix(const FiniteElement &el,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &elmat) {}
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2540,6 +2789,11 @@ private:
 public:
    DerivativeIntegrator(Coefficient &q, int i) : Q(&q), xi(i) {}
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat)
@@ -2587,6 +2841,13 @@ public:
    CurlCurlIntegrator(MatrixCoefficient &mq, const IntegrationRule *ir = NULL) :
       BilinearFormIntegrator(ir), Q(NULL), DQ(NULL), MQ(&mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    /* Given a particular Finite Element, compute the
       element curl-curl matrix elmat */
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -2611,10 +2872,23 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2632,13 +2906,18 @@ protected:
 
 public:
    VectorCurlCurlIntegrator() { Q = NULL; }
-
    VectorCurlCurlIntegrator(Coefficient &q) : Q(&q) {}
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    /// Assemble an element matrix
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    /// Compute element energy: (1/2) (curl u, curl u)_E
    virtual double GetElementEnergy(const FiniteElement &el,
                                    ElementTransformation &Tr,
@@ -2663,11 +2942,17 @@ private:
    DenseMatrix dshape;
    DenseMatrix curlshape;
    DenseMatrix elmat_comp;
+
 public:
    MixedCurlIntegrator() : Q{NULL} {}
    MixedCurlIntegrator(Coefficient *q_) :  Q{q_} {}
    MixedCurlIntegrator(Coefficient &q) :  Q{&q} {}
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2681,9 +2966,6 @@ public:
 class VectorFEMassIntegrator: public BilinearFormIntegrator
 {
 private:
-   void Init(Coefficient *q, DiagonalMatrixCoefficient *dq, MatrixCoefficient *mq)
-   { Q = q; DQ = dq; MQ = mq; }
-
 #ifndef MFEM_THREAD_SAFE
    Vector shape;
    Vector D;
@@ -2693,6 +2975,9 @@ private:
    DenseMatrix trial_vshape;
 #endif
 
+   void Init(Coefficient *q, DiagonalMatrixCoefficient *dq, MatrixCoefficient *mq)
+   { Q = q; DQ = dq; MQ = mq; }
+
 protected:
    Coefficient *Q;
    DiagonalMatrixCoefficient *DQ;
@@ -2717,6 +3002,13 @@ public:
    VectorFEMassIntegrator(MatrixCoefficient *mq_) { Init(NULL, NULL, mq_); }
    VectorFEMassIntegrator(MatrixCoefficient &mq) { Init(NULL, NULL, &mq); }
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
@@ -2730,12 +3022,25 @@ public:
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2762,14 +3067,16 @@ private:
 
 public:
    VectorDivergenceIntegrator() :
-      Q(NULL), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   {  }
+      Q(NULL), trial_maps(NULL), test_maps(NULL), geom(NULL) {}
    VectorDivergenceIntegrator(Coefficient *q_) :
-      Q(q_), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   {}
+      Q(q_), trial_maps(NULL), test_maps(NULL), geom(NULL) {}
    VectorDivergenceIntegrator(Coefficient &q) :
-      Q(&q), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   {}
+      Q(&q), trial_maps(NULL), test_maps(NULL), geom(NULL) {}
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2783,10 +3090,6 @@ public:
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
-
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe,
-                                         ElementTransformation &Trans);
 };
 
 /// (Q div u, div v) for RT elements
@@ -2812,6 +3115,13 @@ public:
    DivDivIntegrator(Coefficient &q, const IntegrationRule *ir = NULL) :
       BilinearFormIntegrator(ir), Q(&q) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
@@ -2824,107 +3134,8 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleDiagonalPA(Vector &diag);
-
-   virtual void AddMultPA(const Vector &x, Vector &y) const;
-
-   const Coefficient *GetCoefficient() const { return Q; }
-};
-
-/** Integrator for
-
-      (Q grad u, grad v) = sum_i (Q grad u_i, grad v_i) e_i e_i^T
-
-    for vector FE spaces, where e_i is the unit vector in the i-th direction.
-    The resulting local element matrix is square, of size <tt> vdim*dof </tt>,
-    where \c vdim is the vector dimension space and \c dof is the local degrees
-    of freedom. The integrator is not aware of the true vector dimension and
-    must use \c VectorCoefficient, \c MatrixCoefficient, or a caller-specified
-    value to determine the vector space. For a scalar coefficient, the caller
-    may manually specify the vector dimension or the vector dimension is assumed
-    to be the spatial dimension (i.e. 2-dimension or 3-dimension).
-*/
-class VectorDiffusionIntegrator : public BilinearFormIntegrator
-{
-protected:
-   Coefficient *Q = NULL;
-   VectorCoefficient *VQ = NULL;
-   MatrixCoefficient *MQ = NULL;
-
-   // PA extension
-   const DofToQuad *maps;         ///< Not owned
-   const GeometricFactors *geom;  ///< Not owned
-   int dim, sdim, ne, dofs1D, quad1D;
-   Vector pa_data;
-
-private:
-   DenseMatrix dshape, dshapedxt, pelmat;
-   int vdim = -1;
-   DenseMatrix mcoeff;
-   Vector vcoeff;
-
-public:
-   VectorDiffusionIntegrator() {}
-
-   /** \brief Integrator with unit coefficient for caller-specified vector
-       dimension.
-
-       If the vector dimension does not match the true dimension of the space,
-       the resulting element matrix will be mathematically invalid. */
-   VectorDiffusionIntegrator(int vector_dimension)
-      : vdim(vector_dimension) {}
-
-   VectorDiffusionIntegrator(Coefficient &q)
-      : Q(&q) {}
-
-   VectorDiffusionIntegrator(Coefficient &q, const IntegrationRule *ir)
-      : BilinearFormIntegrator(ir), Q(&q) {}
-
-   /** \brief Integrator with scalar coefficient for caller-specified vector
-       dimension.
-
-       The element matrix is block-diagonal with \c vdim copies of the element
-       matrix integrated with the \c Coefficient.
-
-       If the vector dimension does not match the true dimension of the space,
-       the resulting element matrix will be mathematically invalid. */
-   VectorDiffusionIntegrator(Coefficient &q, int vector_dimension)
-      : Q(&q), vdim(vector_dimension) {}
-
-   /** \brief Integrator with \c VectorCoefficient. The vector dimension of the
-       \c FiniteElementSpace is assumed to be the same as the dimension of the
-       \c Vector.
-
-       The element matrix is block-diagonal and each block is integrated with
-       coefficient q_i.
-
-       If the vector dimension does not match the true dimension of the space,
-       the resulting element matrix will be mathematically invalid. */
-   VectorDiffusionIntegrator(VectorCoefficient &vq)
-      : VQ(&vq), vdim(vq.GetVDim()) {}
-
-   /** \brief Integrator with \c MatrixCoefficient. The vector dimension of the
-       \c FiniteElementSpace is assumed to be the same as the dimension of the
-       \c Matrix.
-
-       The element matrix is populated in each block. Each block is integrated
-       with coefficient q_ij.
-
-       If the vector dimension does not match the true dimension of the space,
-       the resulting element matrix will be mathematically invalid. */
-   VectorDiffusionIntegrator(MatrixCoefficient& mq)
-      : MQ(&mq), vdim(mq.GetVDim()) {}
-
-   virtual void AssembleElementMatrix(const FiniteElement &el,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &elmat);
-
-   virtual void AssembleElementVector(const FiniteElement &el,
-                                      ElementTransformation &Tr,
-                                      const Vector &elfun, Vector &elvect);
-
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &fes);
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
 
    virtual void AssembleDiagonalPA(Vector &diag);
 
@@ -2933,11 +3144,14 @@ public:
    using BilinearFormIntegrator::AssembleMF;
    virtual void AssembleMF(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
+   const Coefficient *GetCoefficient() const { return Q; }
 };
 
 /** Integrator for the linear elasticity form:
@@ -2966,6 +3180,11 @@ public:
    ElasticityIntegrator(Coefficient &m, double q_l, double q_m)
    { lambda = NULL; mu = &m; q_lambda = q_l; q_mu = q_m; }
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix(const FiniteElement &,
                                       ElementTransformation &,
                                       DenseMatrix &);
@@ -3054,7 +3273,11 @@ public:
                      double a, double b)
    { rho = &rho_; u = &u_; alpha = a; beta = b; }
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const;
+
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -3075,9 +3298,6 @@ public:
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace& fes,
                                         Vector &ea_data_bdr);
 
-   static const IntegrationRule &GetRule(Geometry::Type geom, int order,
-                                         FaceElementTransformations &T);
-
 private:
    void SetupPA(const FiniteElementSpace &fes, FaceType type);
 };
@@ -3137,7 +3357,16 @@ public:
    DGDiffusionIntegrator(MatrixCoefficient &q, const double s, const double k)
       : Q(NULL), MQ(&q), sigma(s), kappa(k) {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   static const IntegrationRule &GetRuleStatic(const FiniteElement &el1,
+                                               const FiniteElement &el2,
+                                               FaceElementTransformations &Trans);
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const
+   { return GetRuleStatic(el1, el2, Trans); }
+
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -3197,7 +3426,12 @@ public:
    MFEM_DEPRECATED DGDiffusionBR2Integrator(class FiniteElementSpace *fes,
                                             double e = 1.0);
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const
+   { return DGDiffusionIntegrator::GetRuleStatic(el1, el2, Trans); }
+
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -3274,7 +3508,12 @@ public:
                           double alpha_, double kappa_)
       : lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const
+   { return DGDiffusionIntegrator::GetRuleStatic(el1, el2, Trans); }
+
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -3325,12 +3564,11 @@ private:
 public:
    TraceJumpIntegrator() {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
-   virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
-                                   const FiniteElement &test_fe1,
-                                   const FiniteElement &test_fe2,
-                                   FaceElementTransformations &Trans,
-                                   DenseMatrix &elmat);
+   virtual void AssembleFaceMatrix2(const FiniteElement &trial_face_fe,
+                                    const FiniteElement &test_fe1,
+                                    const FiniteElement &test_fe2,
+                                    FaceElementTransformations &Trans,
+                                    DenseMatrix &elmat);
 };
 
 /** Integrator for the form: < v, [w.n] > over all faces (the interface) where
@@ -3345,12 +3583,11 @@ private:
 public:
    NormalTraceJumpIntegrator() {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
-   virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
-                                   const FiniteElement &test_fe1,
-                                   const FiniteElement &test_fe2,
-                                   FaceElementTransformations &Trans,
-                                   DenseMatrix &elmat);
+   virtual void AssembleFaceMatrix2(const FiniteElement &trial_face_fe,
+                                    const FiniteElement &test_fe1,
+                                    const FiniteElement &test_fe2,
+                                    FaceElementTransformations &Trans,
+                                    DenseMatrix &elmat);
 };
 
 /** Integrator for the DPG form: < v, w > over a face (the interface) where
@@ -3361,13 +3598,15 @@ class TraceIntegrator : public BilinearFormIntegrator
 {
 private:
    Vector face_shape, shape;
+
 public:
-   TraceIntegrator() { }
-   void AssembleTraceFaceMatrix(int elem,
-                                const FiniteElement &trial_face_fe,
-                                const FiniteElement &test_fe,
-                                FaceElementTransformations &Trans,
-                                DenseMatrix &elmat);
+   TraceIntegrator() {}
+
+   virtual void AssembleTraceFaceMatrix(int elem,
+                                        const FiniteElement &trial_face_fe,
+                                        const FiniteElement &test_fe,
+                                        FaceElementTransformations &Trans,
+                                        DenseMatrix &elmat);
 };
 
 /** Integrator for the form: < v, w.n > over a face (the interface) where
@@ -3380,15 +3619,15 @@ private:
    DenseMatrix shape;
 
 public:
-   NormalTraceIntegrator() { }
-   virtual void AssembleTraceFaceMatrix(int ielem,
+   NormalTraceIntegrator() {}
+
+   virtual void AssembleTraceFaceMatrix(int elem,
                                         const FiniteElement &trial_face_fe,
                                         const FiniteElement &test_fe,
                                         FaceElementTransformations &Trans,
                                         DenseMatrix &elmat);
 };
 
-
 /** Integrator for the form: < v, w  n > over a face (the interface)
  *  In 3D the trial variable v is defined on the interface (H^-1/2(curl), trace of H(curl))
  *  In 2D it's defined on the interface (H^1/2, trace of H1)
@@ -3426,17 +3665,30 @@ private:
    }
 
 public:
-   TangentTraceIntegrator() { }
-   void AssembleTraceFaceMatrix(int elem,
-                                const FiniteElement &trial_face_fe,
-                                const FiniteElement &test_fe,
-                                FaceElementTransformations &Trans,
-                                DenseMatrix &elmat);
+   TangentTraceIntegrator() {}
+
+   virtual void AssembleTraceFaceMatrix(int elem,
+                                        const FiniteElement &trial_face_fe,
+                                        const FiniteElement &test_fe,
+                                        FaceElementTransformations &Trans,
+                                        DenseMatrix &elmat);
 };
 
 /** Abstract class to serve as a base for local interpolators to be used in the
     DiscreteLinearOperator class. */
-class DiscreteInterpolator : public BilinearFormIntegrator {};
+class DiscreteInterpolator : public BilinearFormIntegrator
+{
+public:
+   // This avoids an error when GetRule is called with an interpolator even if
+   // it is never used.
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   {
+      return IntRules.Get(0, 0);
+   }
+};
 
 /** Class for constructing the gradient as a DiscreteLinearOperator from an
     H1-conforming space to an H(curl)-conforming space. The range space can be
@@ -3447,17 +3699,14 @@ public:
    GradientInterpolator() : dofquad_fe(NULL) {}
    virtual ~GradientInterpolator() { delete dofquad_fe; }
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    virtual void AssembleElementMatrix2(const FiniteElement &h1_fe,
                                        const FiniteElement &nd_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat)
    { nd_fe.ProjectGrad(h1_fe, Trans, elmat); }
 
-   /** @brief Setup method for PA data.
-
-       @param[in] trial_fes   H1 Lagrange space
-       @param[in] test_fes    H(curl) Nedelec space
-    */
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
@@ -3469,7 +3718,6 @@ public:
 private:
    /// 1D finite element that generates and owns the 1D DofToQuad maps below
    FiniteElement *dofquad_fe;
-
    bool B_id; // is the B basis operator (maps_C_C) the identity?
    const DofToQuad *maps_C_C; // one-d map with Lobatto rows, Lobatto columns
    const DofToQuad *maps_O_C; // one-d map with Legendre rows, Lobatto columns
@@ -3482,7 +3730,9 @@ private:
 class IdentityInterpolator : public DiscreteInterpolator
 {
 public:
-   IdentityInterpolator(): dofquad_fe(NULL) { }
+   IdentityInterpolator(): dofquad_fe(NULL) {}
+
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
@@ -3503,11 +3753,9 @@ public:
 private:
    /// 1D finite element that generates and owns the 1D DofToQuad maps below
    FiniteElement *dofquad_fe;
-
    const DofToQuad *maps_C_C; // one-d map with Lobatto rows, Lobatto columns
    const DofToQuad *maps_O_C; // one-d map with Legendre rows, Lobatto columns
    int dim, ne, o_dofs1D, c_dofs1D;
-
    Vector pa_data;
 };
 
@@ -3517,11 +3765,21 @@ private:
 class CurlInterpolator : public DiscreteInterpolator
 {
 public:
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat)
    { ran_fe.ProjectCurl(dom_fe, Trans, elmat); }
+
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 };
 
 /** Class for constructing the (local) discrete divergence matrix which can
@@ -3577,8 +3835,7 @@ protected:
 class ScalarVectorProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarVectorProductInterpolator(Coefficient &sc)
-      : Q(&sc) {}
+   ScalarVectorProductInterpolator(Coefficient &sc) : Q(&sc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
@@ -3595,8 +3852,7 @@ protected:
 class VectorScalarProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorScalarProductInterpolator(VectorCoefficient &vc)
-      : VQ(&vc) {}
+   VectorScalarProductInterpolator(VectorCoefficient &vc) : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
@@ -3630,8 +3886,7 @@ protected:
 class VectorCrossProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorCrossProductInterpolator(VectorCoefficient &vc)
-      : VQ(&vc) {}
+   VectorCrossProductInterpolator(VectorCoefficient &vc) : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &nd_fe,
                                        const FiniteElement &rt_fe,
diff --git a/fem/ceed/integrators/convection/convection.cpp b/fem/ceed/integrators/convection/convection.cpp
index c5560f354..c980123ba 100644
--- a/fem/ceed/integrators/convection/convection.cpp
+++ b/fem/ceed/integrators/convection/convection.cpp
@@ -25,81 +25,94 @@ namespace ceed
 #ifdef MFEM_USE_CEED
 struct ConvectionOperatorInfo : public OperatorInfo
 {
-   ConvectionContext ctx;
-   ConvectionOperatorInfo(int dim, double alpha)
+   ConvectionContext ctx = {0};
+   ConvectionOperatorInfo(const mfem::FiniteElementSpace &fes,
+                          mfem::VectorCoefficient *VQ, double alpha,
+                          bool use_bdr = false, bool use_mf = false)
    {
+      MFEM_VERIFY(VQ && VQ->GetVDim() == fes.GetMesh()->SpaceDimension(),
+                  "Incorrect coefficient dimensions in ceed::ConvectionOperatorInfo!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      ctx.alpha = alpha;
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_conv";
+         apply_qf = &f_apply_conv;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(VQ))
+      {
+         const int vdim = VQ->GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_CONV_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_const";
+            build_qf = &f_build_conv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_const";
+            apply_qf = &f_apply_conv_mf_const;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_quad";
+            build_qf = &f_build_conv_quad;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_quad";
+            apply_qf = &f_apply_conv_mf_quad;
+         }
+      }
       header = "/integrators/convection/convection_qf.h";
-      build_func_const = ":f_build_conv_const";
-      build_qf_const = &f_build_conv_const;
-      build_func_quad = ":f_build_conv_quad";
-      build_qf_quad = &f_build_conv_quad;
-      apply_func = ":f_apply_conv";
-      apply_qf = &f_apply_conv;
-      apply_func_mf_const = ":f_apply_conv_mf_const";
-      apply_qf_mf_const = &f_apply_conv_mf_const;
-      apply_func_mf_quad = ":f_apply_conv_mf_quad";
-      apply_qf_mf_quad = &f_apply_conv_mf_quad;
       trial_op = EvalMode::Grad;
       test_op = EvalMode::Interp;
-      qdatasize = dim * (dim + 1) / 2;
-      ctx.alpha = alpha;
+      qdatasize = ctx.dim;
    }
 };
 #endif
 
 PAConvectionIntegrator::PAConvectionIntegrator(
+   const mfem::ConvectionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::VectorCoefficient *Q,
-   const double alpha)
-   : PAIntegrator()
-{
-#ifdef MFEM_USE_CEED
-   ConvectionOperatorInfo info(fes.GetMesh()->Dimension(), alpha);
-   Assemble(info, fes, irm, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedPAConvectionIntegrator::MixedPAConvectionIntegrator(
-   const ConvectionIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::VectorCoefficient *Q,
-   const double alpha)
+   mfem::VectorCoefficient *VQ,
+   const double alpha,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   ConvectionOperatorInfo info(fes.GetMesh()->Dimension(), alpha);
-   Assemble(integ, info, fes, Q);
+   ConvectionOperatorInfo info(fes, VQ, alpha, use_bdr);
+   Assemble(integ, info, fes, VQ, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
 MFConvectionIntegrator::MFConvectionIntegrator(
+   const mfem::ConvectionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::VectorCoefficient *Q,
-   const double alpha)
-   : MFIntegrator()
-{
-#ifdef MFEM_USE_CEED
-   ConvectionOperatorInfo info(fes.GetMesh()->Dimension(), alpha);
-   Assemble(info, fes, irm, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedMFConvectionIntegrator::MixedMFConvectionIntegrator(
-   const ConvectionIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::VectorCoefficient *Q,
-   const double alpha)
+   mfem::VectorCoefficient *VQ,
+   const double alpha,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   ConvectionOperatorInfo info(fes.GetMesh()->Dimension(), alpha);
-   Assemble(integ, info, fes, Q);
+   ConvectionOperatorInfo info(fes, VQ, alpha, use_bdr, true);
+   Assemble(integ, info, fes, VQ, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
diff --git a/fem/ceed/integrators/convection/convection.hpp b/fem/ceed/integrators/convection/convection.hpp
index 1cd968770..713b98c2c 100644
--- a/fem/ceed/integrators/convection/convection.hpp
+++ b/fem/ceed/integrators/convection/convection.hpp
@@ -13,7 +13,7 @@
 #define MFEM_LIBCEED_CONV_HPP
 
 #include "../../interface/integrator.hpp"
-#include "../../interface/mixed_integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
 #include "../../../fespace.hpp"
 
 namespace mfem
@@ -23,41 +23,25 @@ namespace ceed
 {
 
 /// Represent a ConvectionIntegrator with AssemblyLevel::Partial using libCEED.
-class PAConvectionIntegrator : public PAIntegrator
+class PAConvectionIntegrator : public MixedOperator<Integrator>
 {
 public:
-   PAConvectionIntegrator(const mfem::FiniteElementSpace &fes,
-                          const mfem::IntegrationRule &ir,
-                          mfem::VectorCoefficient *Q,
-                          const double alpha);
-};
-
-class MixedPAConvectionIntegrator : public MixedIntegrator<PAIntegrator>
-{
-public:
-   MixedPAConvectionIntegrator(const ConvectionIntegrator &integ,
-                               const mfem::FiniteElementSpace &fes,
-                               mfem::VectorCoefficient *Q,
-                               const double alpha);
+   PAConvectionIntegrator(const mfem::ConvectionIntegrator &integ,
+                          const mfem::FiniteElementSpace &fes,
+                          mfem::VectorCoefficient *VQ,
+                          const double alpha,
+                          const bool use_bdr = false);
 };
 
 /// Represent a ConvectionIntegrator with AssemblyLevel::None using libCEED.
-class MFConvectionIntegrator : public MFIntegrator
-{
-public:
-   MFConvectionIntegrator(const mfem::FiniteElementSpace &fes,
-                          const mfem::IntegrationRule &ir,
-                          mfem::VectorCoefficient *Q,
-                          const double alpha);
-};
-
-class MixedMFConvectionIntegrator : public MixedIntegrator<MFIntegrator>
+class MFConvectionIntegrator : public MixedOperator<Integrator>
 {
 public:
-   MixedMFConvectionIntegrator(const ConvectionIntegrator &integ,
-                               const mfem::FiniteElementSpace &fes,
-                               mfem::VectorCoefficient *Q,
-                               const double alpha);
+   MFConvectionIntegrator(const mfem::ConvectionIntegrator &integ,
+                          const mfem::FiniteElementSpace &fes,
+                          mfem::VectorCoefficient *VQ,
+                          const double alpha,
+                          const bool use_bdr = false);
 };
 
 }
diff --git a/fem/ceed/integrators/convection/convection_qf.h b/fem/ceed/integrators/convection/convection_qf.h
index 68e96895e..0dd11387c 100644
--- a/fem/ceed/integrators/convection/convection_qf.h
+++ b/fem/ceed/integrators/convection/convection_qf.h
@@ -9,207 +9,151 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-/// A structure used to pass additional data to f_build_conv and f_apply_conv
-struct ConvectionContext {
-   CeedInt dim, space_dim, vdim;
-   CeedScalar coeff[3];
+#ifndef MFEM_LIBCEED_CONV_QF_H
+#define MFEM_LIBCEED_CONV_QF_H
+
+#include "../util/util_qf.h"
+
+#define LIBCEED_CONV_COEFF_COMP_MAX 3
+
+struct ConvectionContext
+{
+   CeedInt dim, space_dim;
    CeedScalar alpha;
+   CeedScalar coeff[LIBCEED_CONV_COEFF_COMP_MAX];
 };
 
-/// libCEED Q-function for building quadrature data for a convection operator
+/// libCEED QFunction for building quadrature data for a convection operator
 /// with a constant coefficient
 CEED_QFUNCTION(f_build_conv_const)(void *ctx, CeedInt Q,
                                    const CeedScalar *const *in,
                                    CeedScalar *const *out)
 {
-   ConvectionContext *bc = (ConvectionContext*)ctx;
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
+   ConvectionContext *bc = (ConvectionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[1] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute and store qw * adj(J).
-   const CeedScalar coeff0 = bc->coeff[0];
-   const CeedScalar coeff1 = bc->coeff[1];
-   const CeedScalar coeff2 = bc->coeff[2];
+   // At every quadrature point, compute and store qw *  * c^T adj(J)^T
    const CeedScalar alpha  = bc->alpha;
+   const CeedScalar *coeff = bc->coeff;
    const CeedScalar *J = in[0], *qw = in[1];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            qd[i] = alpha * coeff0 * qw[i] * J[i];
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * alpha * coeff0 * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultCtAdjJt21(J + i, Q, coeff, 1, qw[i] * alpha, Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultCtAdjJt22(J + i, Q, coeff, 1, qw[i] * alpha, Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            qd[i + Q * 0] =  wx * J22 - wy * J12;
-            qd[i + Q * 1] = -wx * J21 + wy * J11;
+            MultCtAdjJt32(J + i, Q, coeff, 1, qw[i] * alpha, Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar wz = w * coeff2;
-            qd[i + Q * 0] = wx * A11 + wy * A12 + wz * A13;
-            qd[i + Q * 1] = wx * A21 + wy * A22 + wz * A23;
-            qd[i + Q * 2] = wx * A31 + wy * A32 + wz * A33;
+            MultCtAdjJt33(J + i, Q, coeff, 1, qw[i] * alpha, Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for building quadrature data for a convection operator
-/// coefficient evaluated at quadrature points.
+/// libCEED QFunction for building quadrature data for a convection operator
+/// with a coefficient evaluated at quadrature points
 CEED_QFUNCTION(f_build_conv_quad)(void *ctx, CeedInt Q,
                                   const CeedScalar *const *in,
                                   CeedScalar *const *out)
 {
    ConvectionContext *bc = (ConvectionContext *)ctx;
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute and store qw * adj(J).
-   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   // At every quadrature point, compute and store qw *  * c^T adj(J)^T
    const CeedScalar alpha  = bc->alpha;
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar coeff = c[i];
-            qd[i] = alpha * coeff * qw[i] * J[i];
+            qd[i] = qw[i] * alpha * c[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultCtAdjJt21(J + i, Q, c + i, Q, qw[i] * alpha, Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            qd[i + Q * 0] =  wx * J22 - wy * J12;
-            qd[i + Q * 1] = -wx * J21 + wy * J11;
+            MultCtAdjJt22(J + i, Q, c + i, Q, qw[i] * alpha, Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultCtAdjJt32(J + i, Q, c + i, Q, qw[i] * alpha, Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar wz = w * c[i + Q * 2];
-            qd[i + Q * 0] = wx * A11 + wy * A12 + wz * A13;
-            qd[i + Q * 1] = wx * A21 + wy * A22 + wz * A23;
-            qd[i + Q * 2] = wx * A31 + wy * A32 + wz * A33;
+            MultCtAdjJt33(J + i, Q, c + i, Q, qw[i] * alpha, Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a conv operator
+/// libCEED QFunction for applying a convection operator
 CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
                              const CeedScalar *const *in,
                              CeedScalar *const *out)
 {
    ConvectionContext *bc = (ConvectionContext *)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
+   // in[0] has shape [dim, ncomp=1, Q]
+   // out[0] has shape [ncomp=1, Q]
    const CeedScalar *ug = in[0], *qd = in[1];
    CeedScalar *vg = out[0];
-   switch (10*bc->dim + bc->vdim)
+   switch (bc->dim)
    {
-      case 11:
-         for (CeedInt i = 0; i < Q; i++)
+      case 1:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            vg[i] = ug[i] * qd[i];
+            vg[i] = qd[i] * ug[i];
          }
          break;
-      case 21:
-         for (CeedInt i = 0; i < Q; i++)
+      case 2:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             vg[i] = qd[i + Q * 0] * ug0 + qd[i + Q * 1] * ug1;
          }
          break;
-      case 22:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            const CeedScalar qd0 = qd[i + Q * 0];
-            const CeedScalar qd1 = qd[i + Q * 1];
-            for (CeedInt c = 0; c < 2; c++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (c+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+2*1)];
-               vg[i + Q * c] = qd0 * ug0 + qd1 * ug1;
-            }
-         }
-         break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
+      case 3:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
@@ -217,313 +161,147 @@ CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
             vg[i] = qd[i + Q * 0] * ug0 + qd[i + Q * 1] * ug1 + qd[i + Q * 2] * ug2;
          }
          break;
-      case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            const CeedScalar qd0 = qd[i + Q * 0];
-            const CeedScalar qd1 = qd[i + Q * 1];
-            const CeedScalar qd2 = qd[i + Q * 2];
-            for (CeedInt c = 0; c < 3; c++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (c+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (c+3*2)];
-               vg[i + Q * c] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
-            }
-         }
-         break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a conv operator
+/// libCEED QFunction for applying a convection operator with a constant
+/// coefficient
 CEED_QFUNCTION(f_apply_conv_mf_const)(void *ctx, CeedInt Q,
                                       const CeedScalar *const *in,
                                       CeedScalar *const *out)
 {
-   ConvectionContext *bc = (ConvectionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   ConvectionContext *bc = (ConvectionContext *)ctx;
+   // in[0] has shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
+   // out[0] has shape [ncomp=1, Q]
    //
-   // At every quadrature point, compute qw * adj(J).
-   const CeedScalar coeff0 = bc->coeff[0];
-   const CeedScalar coeff1 = bc->coeff[1];
-   const CeedScalar coeff2 = bc->coeff[2];
+   // At every quadrature point, compute qw *  * c^T adj(J)^T
    const CeedScalar alpha  = bc->alpha;
+   const CeedScalar *coeff = bc->coeff;
    const CeedScalar *ug = in[0], *J = in[1], *qw = in[2];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = alpha * coeff0 * qw[i] * J[i];
-            vg[i] = ug[i] * qd;
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * alpha * coeff0 * J[i];
+            vg[i] = qd * ug[i];
          }
          break;
       case 21:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar qd0 =  wx * J22 - wy * J12;
-            const CeedScalar qd1 = -wx * J21 + wy * J11;
-            const CeedScalar ug0 = ug[i + Q * 0];
-            const CeedScalar ug1 = ug[i + Q * 1];
-            vg[i] = qd0 * ug0 + qd1 * ug1;
+            CeedScalar qd;
+            MultCtAdjJt21(J + i, Q, coeff, 1, qw[i] * alpha, 1, &qd);
+            vg[i] = qd * ug[i];
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar qd0 =  wx * J22 - wy * J12;
-            const CeedScalar qd1 = -wx * J21 + wy * J11;
-            for (CeedInt c = 0; c < 2; c++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (c+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+2*1)];
-               vg[i + Q * c] = qd0 * ug0 + qd1 * ug1;
-            }
+            CeedScalar qd[2];
+            MultCtAdjJt22(J + i, Q, coeff, 1, qw[i] * alpha, 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i] = qd[0] * ug0 + qd[1] * ug1;
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar wz = w * coeff2;
-            const CeedScalar qd0 = wx * A11 + wy * A12 + wz * A13;
-            const CeedScalar qd1 = wx * A21 + wy * A22 + wz * A23;
-            const CeedScalar qd2 = wx * A31 + wy * A32 + wz * A33;
+            CeedScalar qd[2];
+            MultCtAdjJt32(J + i, Q, coeff, 1, qw[i] * alpha, 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
-            const CeedScalar ug2 = ug[i + Q * 2];
-            vg[i] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
+            vg[i] = qd[0] * ug0 + qd[1] * ug1;
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar wz = w * coeff2;
-            const CeedScalar qd0 = wx * A11 + wy * A12 + wz * A13;
-            const CeedScalar qd1 = wx * A21 + wy * A22 + wz * A23;
-            const CeedScalar qd2 = wx * A31 + wy * A32 + wz * A33;
-            for (CeedInt c = 0; c < 3; c++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (c+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (c+3*2)];
-               vg[i + Q * c] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
-            }
+            CeedScalar qd[3];
+            MultCtAdjJt33(J + i, Q, coeff, 1, qw[i] * alpha, 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
          }
          break;
    }
    return 0;
 }
 
+/// libCEED QFunction for applying a convection operator with a coefficient
+/// evaluated at quadrature points
 CEED_QFUNCTION(f_apply_conv_mf_quad)(void *ctx, CeedInt Q,
                                      const CeedScalar *const *in,
                                      CeedScalar *const *out)
 {
-   ConvectionContext *bc = (ConvectionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
-   // in[2] is quadrature weights, size (Q)
+   ConvectionContext *bc = (ConvectionContext *)ctx;
+   // in[0] has shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   // out[0] has shape [ncomp=1, Q]
    //
-   // At every quadrature point, compute qw * adj(J).
-   const CeedScalar *c = in[0], *ug = in[1], *J = in[2], *qw = in[3];
+   // At every quadrature point, compute qw *  * c^T adj(J)^T
    const CeedScalar alpha  = bc->alpha;
+   const CeedScalar *ug = in[0], *c = in[1], *J = in[2], *qw = in[3];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = alpha * c[i] * qw[i] * J[i];
-            vg[i] = ug[i] * qd;
+            const CeedScalar qd = qw[i] * alpha * c[i] * J[i];
+            vg[i] = qd * ug[i];
          }
          break;
       case 21:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar qd0 =  wx * J22 - wy * J12;
-            const CeedScalar qd1 = -wx * J21 + wy * J11;
-            const CeedScalar ug0 = ug[i + Q * 0];
-            const CeedScalar ug1 = ug[i + Q * 1];
-            vg[i] = qd0 * ug0 + qd1 * ug1;
+            CeedScalar qd;
+            MultCtAdjJt21(J + i, Q, c + i, Q, qw[i] * alpha, 1, &qd);
+            vg[i] = qd * ug[i];
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar qd0 =  wx * J22 - wy * J12;
-            const CeedScalar qd1 = -wx * J21 + wy * J11;
-            for (CeedInt d = 0; d < 2; d++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (d+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (d+2*1)];
-               vg[i + Q * d] = qd0 * ug0 + qd1 * ug1;
-            }
+            CeedScalar qd[2];
+            MultCtAdjJt22(J + i, Q, c + i, Q, qw[i] * alpha, 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i] = qd[0] * ug0 + qd[1] * ug1;
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar wz = w * c[i + Q * 2];
-            const CeedScalar qd0 = wx * A11 + wy * A12 + wz * A13;
-            const CeedScalar qd1 = wx * A21 + wy * A22 + wz * A23;
-            const CeedScalar qd2 = wx * A31 + wy * A32 + wz * A33;
+            CeedScalar qd[2];
+            MultCtAdjJt32(J + i, Q, c + i, Q, qw[i] * alpha, 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
-            const CeedScalar ug2 = ug[i + Q * 2];
-            vg[i] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
+            vg[i] = qd[0] * ug0 + qd[1] * ug1;
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar wz = w * c[i + Q * 2];
-            const CeedScalar qd0 = wx * A11 + wy * A12 + wz * A13;
-            const CeedScalar qd1 = wx * A21 + wy * A22 + wz * A23;
-            const CeedScalar qd2 = wx * A31 + wy * A32 + wz * A33;
-            for (CeedInt d = 0; d < 3; d++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (d+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (d+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (d+3*2)];
-               vg[i + Q * d] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
-            }
+            CeedScalar qd[3];
+            MultCtAdjJt33(J + i, Q, c + i, Q, qw[i] * alpha, 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
          }
          break;
    }
    return 0;
 }
+
+#endif // MFEM_LIBCEED_CONV_QF_H
diff --git a/fem/ceed/integrators/curlcurl/curlcurl.cpp b/fem/ceed/integrators/curlcurl/curlcurl.cpp
new file mode 100644
index 000000000..ace7c18e4
--- /dev/null
+++ b/fem/ceed/integrators/curlcurl/curlcurl.cpp
@@ -0,0 +1,244 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "curlcurl.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "curlcurl_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct CurlCurlOperatorInfo : public OperatorInfo
+{
+   CurlCurlContext ctx = {0};
+   template <typename CoeffType>
+   CurlCurlOperatorInfo(const mfem::FiniteElementSpace &fes, CoeffType *Q,
+                        bool use_bdr = false, bool use_mf = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      MFEM_VERIFY(ctx.dim == 2 || ctx.dim == 3,
+                  "CurlCurlIntegrator requires dim == 2 or dim == 3!");
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      ctx.curl_dim = (ctx.dim < 3) ? 1 : ctx.dim;
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_curlcurl";
+         apply_qf = &f_apply_curlcurl;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_scalar";
+            build_qf = &f_build_curlcurl_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_scalar";
+            apply_qf = &f_apply_curlcurl_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, use_mf);
+      }
+      header = "/integrators/curlcurl/curlcurl_qf.h";
+      trial_op = EvalMode::Curl;
+      test_op = EvalMode::Curl;
+      qdatasize = (ctx.curl_dim * (ctx.curl_dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_scalar";
+            build_qf = &f_build_curlcurl_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_scalar";
+            apply_qf = &f_apply_curlcurl_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_scalar";
+            build_qf = &f_build_curlcurl_quad_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_scalar";
+            apply_qf = &f_apply_curlcurl_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_CURLCURL_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_vector";
+            build_qf = &f_build_curlcurl_const_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_vector";
+            apply_qf = &f_apply_curlcurl_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_vector";
+            build_qf = &f_build_curlcurl_quad_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_vector";
+            apply_qf = &f_apply_curlcurl_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_CURLCURL_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_matrix";
+            build_qf = &f_build_curlcurl_const_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_matrix";
+            apply_qf = &f_apply_curlcurl_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_matrix";
+            build_qf = &f_build_curlcurl_quad_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_matrix";
+            apply_qf = &f_apply_curlcurl_mf_quad_matrix;
+         }
+      }
+   }
+};
+#endif
+
+template <typename CoeffType>
+PACurlCurlIntegrator::PACurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   CurlCurlOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, Q, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFCurlCurlIntegrator::MFCurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   CurlCurlOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, Q, use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PACurlCurlIntegrator::PACurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template PACurlCurlIntegrator::PACurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template PACurlCurlIntegrator::PACurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template MFCurlCurlIntegrator::MFCurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template MFCurlCurlIntegrator::MFCurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template MFCurlCurlIntegrator::MFCurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/curlcurl/curlcurl.hpp b/fem/ceed/integrators/curlcurl/curlcurl.hpp
new file mode 100644
index 000000000..71d62c915
--- /dev/null
+++ b/fem/ceed/integrators/curlcurl/curlcurl.hpp
@@ -0,0 +1,51 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_CURLCURL_HPP
+#define MFEM_LIBCEED_CURLCURL_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/// Represent a CurlCurlIntegrator with AssemblyLevel::Partial using libCEED.
+class PACurlCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PACurlCurlIntegrator(const mfem::CurlCurlIntegrator &integ,
+                        const mfem::FiniteElementSpace &fes,
+                        CoeffType *Q,
+                        const bool use_bdr = false);
+};
+
+/// Represent a CurlCurlIntegrator with AssemblyLevel::None using libCEED.
+class MFCurlCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFCurlCurlIntegrator(const mfem::CurlCurlIntegrator &integ,
+                        const mfem::FiniteElementSpace &fes,
+                        CoeffType *Q,
+                        const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_CURLCURL_HPP
diff --git a/fem/ceed/integrators/curlcurl/curlcurl_qf.h b/fem/ceed/integrators/curlcurl/curlcurl_qf.h
new file mode 100644
index 000000000..6fbace54b
--- /dev/null
+++ b/fem/ceed/integrators/curlcurl/curlcurl_qf.h
@@ -0,0 +1,479 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_CURLCURL_QF_H
+#define MFEM_LIBCEED_CURLCURL_QF_H
+
+#include "../util/util_qf.h"
+
+#define LIBCEED_CURLCURL_COEFF_COMP_MAX 6
+
+struct CurlCurlContext
+{
+   CeedInt dim, space_dim, curl_dim;
+   CeedScalar coeff[LIBCEED_CURLCURL_COEFF_COMP_MAX];
+};
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a scalar constant coefficient
+CEED_QFUNCTION(f_build_curlcurl_const_scalar)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 / DetJ22(J + i, Q);
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 / DetJ32(J + i, Q);
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a vector constant coefficient
+CEED_QFUNCTION(f_build_curlcurl_const_vector)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a matrix constant coefficient
+CEED_QFUNCTION(f_build_curlcurl_const_matrix)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_quad_scalar)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ22(J + i, Q);
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ32(J + i, Q);
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_quad_vector)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_quad_matrix)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator
+CEED_QFUNCTION(f_apply_curlcurl)(void *ctx, CeedInt Q,
+                                 const CeedScalar *const *in,
+                                 CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   const CeedScalar *uc = in[0], *qd = in[1];
+   CeedScalar *vc = out[0];
+   switch (10 * bc->dim + bc->curl_dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            vc[i] = qd[i] * uc[i];
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[i + Q * 0] * uc0 + qd[i + Q * 1] * uc1 + qd[i + Q * 2] * uc2;
+            vc[i + Q * 1] = qd[i + Q * 1] * uc0 + qd[i + Q * 3] * uc1 + qd[i + Q * 4] * uc2;
+            vc[i + Q * 2] = qd[i + Q * 2] * uc0 + qd[i + Q * 4] * uc1 + qd[i + Q * 5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a scalar constant
+/// coefficient
+CEED_QFUNCTION(f_apply_curlcurl_mf_const_scalar)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *uc = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 / DetJ22(J + i, Q);
+            vc[i] = qd * uc[i];
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 / DetJ32(J + i, Q);
+            vc[i] = qd * uc[i];
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a vector constant
+/// coefficient
+CEED_QFUNCTION(f_apply_curlcurl_mf_const_vector)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *uc = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a matrix constant
+/// coefficient
+CEED_QFUNCTION(f_apply_curlcurl_mf_const_matrix)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *uc = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a scalar
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_curlcurl_mf_quad_scalar)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *uc = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ22(J + i, Q);
+            vc[i] = qd * uc[i];
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ32(J + i, Q);
+            vc[i] = qd * uc[i];
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a vector
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_curlcurl_mf_quad_vector)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *uc = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a matrix
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_curlcurl_mf_quad_matrix)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *uc = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_CURLCURL_QF_H
diff --git a/fem/ceed/integrators/diffusion/diffusion.cpp b/fem/ceed/integrators/diffusion/diffusion.cpp
index 4cd68669f..d2f56db82 100644
--- a/fem/ceed/integrators/diffusion/diffusion.cpp
+++ b/fem/ceed/integrators/diffusion/diffusion.cpp
@@ -25,106 +25,253 @@ namespace ceed
 #ifdef MFEM_USE_CEED
 struct DiffusionOperatorInfo : public OperatorInfo
 {
-   DiffusionContext ctx;
-   DiffusionOperatorInfo(int dim)
+   DiffusionContext ctx = {0};
+   template <typename CoeffType>
+   DiffusionOperatorInfo(const mfem::FiniteElementSpace &fes, CoeffType *Q,
+                         bool use_bdr = false, bool use_mf = false)
    {
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      ctx.vdim = fes.GetVDim();
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_diff";
+         apply_qf = &f_apply_diff;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_scalar";
+            build_qf = &f_build_diff_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_scalar";
+            apply_qf = &f_apply_diff_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, use_mf);
+      }
       header = "/integrators/diffusion/diffusion_qf.h";
-      build_func_const = ":f_build_diff_const";
-      build_qf_const = &f_build_diff_const;
-      build_func_quad = ":f_build_diff_quad";
-      build_qf_quad = &f_build_diff_quad;
-      apply_func = ":f_apply_diff";
-      apply_qf = &f_apply_diff;
-      apply_func_mf_const = ":f_apply_diff_mf_const";
-      apply_qf_mf_const = &f_apply_diff_mf_const;
-      apply_func_mf_quad = ":f_apply_diff_mf_quad";
-      apply_qf_mf_quad = &f_apply_diff_mf_quad;
       trial_op = EvalMode::Grad;
       test_op = EvalMode::Grad;
-      qdatasize = dim*(dim+1)/2;
+      qdatasize = (ctx.dim * (ctx.dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_scalar";
+            build_qf = &f_build_diff_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_scalar";
+            apply_qf = &f_apply_diff_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_scalar";
+            build_qf = &f_build_diff_quad_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_scalar";
+            apply_qf = &f_apply_diff_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_DIFF_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_vector";
+            build_qf = &f_build_diff_const_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_vector";
+            apply_qf = &f_apply_diff_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_vector";
+            build_qf = &f_build_diff_quad_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_vector";
+            apply_qf = &f_apply_diff_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_DIFF_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_matrix";
+            build_qf = &f_build_diff_const_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_matrix";
+            apply_qf = &f_apply_diff_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_matrix";
+            build_qf = &f_build_diff_quad_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_matrix";
+            apply_qf = &f_apply_diff_mf_quad_matrix;
+         }
+      }
    }
 };
 #endif
 
+template <typename CoeffType>
 PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::DiffusionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::Coefficient *Q)
-   : PAIntegrator()
+   CoeffType *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(info, fes, irm, Q);
+   DiffusionOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, Q, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPADiffusionIntegrator::MixedPADiffusionIntegrator(
-   const DiffusionIntegrator &integ,
+template <typename CoeffType>
+PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::VectorDiffusionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
+   CoeffType *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
+   DiffusionOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, Q, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPADiffusionIntegrator::MixedPADiffusionIntegrator(
-   const VectorDiffusionIntegrator &integ,
+template <typename CoeffType>
+MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::DiffusionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
+   CoeffType *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
+   DiffusionOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, Q, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
+template <typename CoeffType>
 MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::VectorDiffusionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::Coefficient *Q)
-   : MFIntegrator()
+   CoeffType *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(info, fes, irm, Q);
+   DiffusionOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, Q, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedMFDiffusionIntegrator::MixedMFDiffusionIntegrator(
-   const DiffusionIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
+// @cond DOXYGEN_SKIP
 
-MixedMFDiffusionIntegrator::MixedMFDiffusionIntegrator(
-   const VectorDiffusionIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
+template PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::VectorDiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+
+template MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::VectorDiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+
+// @endcond
 
 } // namespace ceed
 
diff --git a/fem/ceed/integrators/diffusion/diffusion.hpp b/fem/ceed/integrators/diffusion/diffusion.hpp
index dd28c9d16..b92710bad 100644
--- a/fem/ceed/integrators/diffusion/diffusion.hpp
+++ b/fem/ceed/integrators/diffusion/diffusion.hpp
@@ -13,7 +13,7 @@
 #define MFEM_LIBCEED_DIFF_HPP
 
 #include "../../interface/integrator.hpp"
-#include "../../interface/mixed_integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
 #include "../../../fespace.hpp"
 
 namespace mfem
@@ -23,45 +23,37 @@ namespace ceed
 {
 
 /// Represent a DiffusionIntegrator with AssemblyLevel::Partial using libCEED.
-class PADiffusionIntegrator : public PAIntegrator
+class PADiffusionIntegrator : public MixedOperator<Integrator>
 {
 public:
-   PADiffusionIntegrator(const mfem::FiniteElementSpace &fes,
-                         const mfem::IntegrationRule &ir,
-                         mfem::Coefficient *Q);
-};
-
-class MixedPADiffusionIntegrator : public MixedIntegrator<PAIntegrator>
-{
-public:
-   MixedPADiffusionIntegrator(const DiffusionIntegrator &integ,
-                              const mfem::FiniteElementSpace &fes,
-                              mfem::Coefficient *Q);
-
-   MixedPADiffusionIntegrator(const VectorDiffusionIntegrator &integ,
-                              const mfem::FiniteElementSpace &fes,
-                              mfem::Coefficient *Q);
+   template <typename CoeffType>
+   PADiffusionIntegrator(const mfem::DiffusionIntegrator &integ,
+                         const mfem::FiniteElementSpace &fes,
+                         CoeffType *Q,
+                         const bool use_bdr = false);
+
+   template <typename CoeffType>
+   PADiffusionIntegrator(const mfem::VectorDiffusionIntegrator &integ,
+                         const mfem::FiniteElementSpace &fes,
+                         CoeffType *Q,
+                         const bool use_bdr = false);
 };
 
 /// Represent a DiffusionIntegrator with AssemblyLevel::None using libCEED.
-class MFDiffusionIntegrator : public MFIntegrator
+class MFDiffusionIntegrator : public MixedOperator<Integrator>
 {
 public:
-   MFDiffusionIntegrator(const mfem::FiniteElementSpace &fes,
-                         const mfem::IntegrationRule &ir,
-                         mfem::Coefficient *Q);
-};
-
-class MixedMFDiffusionIntegrator : public MixedIntegrator<MFIntegrator>
-{
-public:
-   MixedMFDiffusionIntegrator(const DiffusionIntegrator &integ,
-                              const mfem::FiniteElementSpace &fes,
-                              mfem::Coefficient *Q);
-
-   MixedMFDiffusionIntegrator(const VectorDiffusionIntegrator &integ,
-                              const mfem::FiniteElementSpace &fes,
-                              mfem::Coefficient *Q);
+   template <typename CoeffType>
+   MFDiffusionIntegrator(const mfem::DiffusionIntegrator &integ,
+                         const mfem::FiniteElementSpace &fes,
+                         CoeffType *Q,
+                         const bool use_bdr = false);
+
+   template <typename CoeffType>
+   MFDiffusionIntegrator(const mfem::VectorDiffusionIntegrator &integ,
+                         const mfem::FiniteElementSpace &fes,
+                         CoeffType *Q,
+                         const bool use_bdr = false);
 };
 
 }
diff --git a/fem/ceed/integrators/diffusion/diffusion_qf.h b/fem/ceed/integrators/diffusion/diffusion_qf.h
index aa4850e37..9ab50a3ed 100644
--- a/fem/ceed/integrators/diffusion/diffusion_qf.h
+++ b/fem/ceed/integrators/diffusion/diffusion_qf.h
@@ -9,180 +9,331 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
+#ifndef MFEM_LIBCEED_DIFF_QF_H
+#define MFEM_LIBCEED_DIFF_QF_H
 
-/// A structure used to pass additional data to f_build_diff and f_apply_diff
-struct DiffusionContext { CeedInt dim, space_dim, vdim; CeedScalar coeff; };
+#include "../util/util_qf.h"
 
-/// libCEED Q-function for building quadrature data for a diffusion operator
-/// with a constant coefficient
-CEED_QFUNCTION(f_build_diff_const)(void *ctx, CeedInt Q,
-                                   const CeedScalar *const *in,
-                                   CeedScalar *const *out)
+#define LIBCEED_DIFF_COEFF_COMP_MAX 6
+
+struct DiffusionContext
+{
+   CeedInt dim, space_dim, vdim;
+   CeedScalar coeff[LIBCEED_DIFF_COEFF_COMP_MAX];
+};
+
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a scalar constant coefficient
+CEED_QFUNCTION(f_build_diff_const_scalar)(void *ctx, CeedInt Q,
+                                          const CeedScalar *const *in,
+                                          CeedScalar *const *out)
 {
-   DiffusionContext *bc = (DiffusionContext*)ctx;
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[1] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute qw/det(J).adj(J).adj(J)^T and store
-   // the symmetric part of the result.
-   const CeedScalar coeff = bc->coeff;
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *coeff = bc->coeff;
    const CeedScalar *J = in[0], *qw = in[1];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a vector constant coefficient
+CEED_QFUNCTION(f_build_diff_const_vector)(void *ctx, CeedInt Q,
+                                          const CeedScalar *const *in,
+                                          CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a matrix constant coefficient
+CEED_QFUNCTION(f_build_diff_const_matrix)(void *ctx, CeedInt Q,
+                                          const CeedScalar *const *in,
+                                          CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            qd[i] = coeff * qw[i] / J[i];
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
-            qd[i + Q * 0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[i + Q * 1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[i + Q * 2] =   coeff * w * (J11 * J11 + J21 * J21);
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
-            qd[i + Q * 0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[i + Q * 1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[i + Q * 2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[i + Q * 3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[i + Q * 4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[i + Q * 5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for building quadrature data for a diffusion operator
-/// coefficient evaluated at quadrature points.
-CEED_QFUNCTION(f_build_diff_quad)(void *ctx, CeedInt Q,
-                                  const CeedScalar *const *in,
-                                  CeedScalar *const *out)
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_quad_scalar)(void *ctx, CeedInt Q,
+                                         const CeedScalar *const *in,
+                                         CeedScalar *const *out)
 {
    DiffusionContext *bc = (DiffusionContext *)ctx;
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   // in[0] is coefficients with shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute qw/det(J).adj(J).adj(J)^T and store
-   // the symmetric part of the result.
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
    const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            qd[i] = c[i] * qw[i] / J[i];
+            qd[i] = qw[i] * c[i] / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar coeff = c[i];
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
-            qd[i + Q * 0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[i + Q * 1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[i + Q * 2] =   coeff * w * (J11 * J11 + J21 * J21);
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar coeff = c[i];
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
-            qd[i + Q * 0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[i + Q * 1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[i + Q * 2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[i + Q * 3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[i + Q * 4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[i + Q * 5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a diff operator
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_quad_vector)(void *ctx, CeedInt Q,
+                                         const CeedScalar *const *in,
+                                         CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_quad_matrix)(void *ctx, CeedInt Q,
+                                         const CeedScalar *const *in,
+                                         CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a diffusion operator
 CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
                              const CeedScalar *const *in,
                              CeedScalar *const *out)
 {
    DiffusionContext *bc = (DiffusionContext *)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
    const CeedScalar *ug = in[0], *qd = in[1];
    CeedScalar *vg = out[0];
-   switch (10*bc->dim + bc->vdim)
+   switch (10 * bc->dim + bc->vdim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            vg[i] = ug[i] * qd[i];
+            vg[i] = qd[i] * ug[i];
+         }
+         break;
+      case 12:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd0 = qd[i];
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd0 * ug[i + Q * d];
+            }
          }
          break;
       case 21:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
@@ -191,23 +342,23 @@ CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar qd00 = qd[i + Q * 0];
             const CeedScalar qd01 = qd[i + Q * 1];
             const CeedScalar qd10 = qd01;
             const CeedScalar qd11 = qd[i + Q * 2];
-            for (CeedInt c = 0; c < 2; c++)
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (c+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+2*1)];
-               vg[i + Q * (c+2*0)] = qd00 * ug0 + qd01 * ug1;
-               vg[i + Q * (c+2*1)] = qd10 * ug0 + qd11 * ug1;
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd00 * ug0 + qd01 * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd10 * ug0 + qd11 * ug1;
             }
          }
          break;
       case 31:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
@@ -217,8 +368,24 @@ CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
             vg[i + Q * 2] = qd[i + Q * 2] * ug0 + qd[i + Q * 4] * ug1 + qd[i + Q * 5] * ug2;
          }
          break;
+      case 23:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd00 = qd[i + Q * 0];
+            const CeedScalar qd01 = qd[i + Q * 1];
+            const CeedScalar qd10 = qd01;
+            const CeedScalar qd11 = qd[i + Q * 2];
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd00 * ug0 + qd01 * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd10 * ug0 + qd11 * ug1;
+            }
+         }
+         break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar qd00 = qd[i + Q * 0];
             const CeedScalar qd01 = qd[i + Q * 1];
@@ -229,14 +396,14 @@ CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
             const CeedScalar qd20 = qd02;
             const CeedScalar qd21 = qd12;
             const CeedScalar qd22 = qd[i + Q * 5];
-            for (CeedInt c = 0; c < 3; c++)
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (c+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (c+3*2)];
-               vg[i + Q * (c+3*0)] = qd00 * ug0 + qd01 * ug1 + qd02 * ug2;
-               vg[i + Q * (c+3*1)] = qd10 * ug0 + qd11 * ug1 + qd12 * ug2;
-               vg[i + Q * (c+3*2)] = qd20 * ug0 + qd21 * ug1 + qd22 * ug2;
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd00 * ug0 + qd01 * ug1 + qd02 * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd10 * ug0 + qd11 * ug1 + qd12 * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd20 * ug0 + qd21 * ug1 + qd22 * ug2;
             }
          }
          break;
@@ -244,104 +411,105 @@ CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
    return 0;
 }
 
-/// libCEED Q-function for applying a diff operator
-CEED_QFUNCTION(f_apply_diff_mf_const)(void *ctx, CeedInt Q,
-                                      const CeedScalar *const *in,
-                                      CeedScalar *const *out)
+/// libCEED QFunction for applying a diffusion operator with a scalar constant
+/// coefficient
+CEED_QFUNCTION(f_apply_diff_mf_const_scalar)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
 {
-   DiffusionContext *bc = (DiffusionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute qw/det(J).adj(J).adj(J)^T
-   const CeedScalar coeff = bc->coeff;
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *coeff = bc->coeff;
    const CeedScalar *ug = in[0], *J = in[1], *qw = in[2];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
    {
-      case 11:
-         for (CeedInt i = 0; i < Q; i++)
+      case 111:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = coeff * qw[i] / J[i];
-            vg[i] = ug[i] * qd;
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 / J[i];
+            vg[i] = qd * ug[i];
          }
          break;
-      case 21:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[3];
-            qd[0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[2] =   coeff * w * (J11 * J11 + J21 * J21);
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
             vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
          }
          break;
-      case 22:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[3];
-            qd[0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[2] =   coeff * w * (J11 * J11 + J21 * J21);
-            for (CeedInt c = 0; c < 2; c++)
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (c+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+2*1)];
-               vg[i + Q * (c+2*0)] = qd[0] * ug0 + qd[1] * ug1;
-               vg[i + Q * (c+2*1)] = qd[1] * ug0 + qd[2] * ug1;
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
             }
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[6];
-            qd[0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             const CeedScalar ug2 = ug[i + Q * 2];
@@ -350,46 +518,19 @@ CEED_QFUNCTION(f_apply_diff_mf_const)(void *ctx, CeedInt Q,
             vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
          }
          break;
-      case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[6];
-            qd[0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
-            for (CeedInt c = 0; c < 3; c++)
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (c+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (c+3*2)];
-               vg[i + Q * (c+3*0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
-               vg[i + Q * (c+3*1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
-               vg[i + Q * (c+3*2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
             }
          }
          break;
@@ -397,105 +538,97 @@ CEED_QFUNCTION(f_apply_diff_mf_const)(void *ctx, CeedInt Q,
    return 0;
 }
 
-CEED_QFUNCTION(f_apply_diff_mf_quad)(void *ctx, CeedInt Q,
-                                     const CeedScalar *const *in,
-                                     CeedScalar *const *out)
+/// libCEED QFunction for applying a diffusion operator with a vector constant
+/// coefficient
+CEED_QFUNCTION(f_apply_diff_mf_const_vector)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
 {
-   DiffusionContext *bc = (DiffusionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute qw/det(J).adj(J).adj(J)^T
-   const CeedScalar *c = in[0], *ug = in[1], *J = in[2], *qw = in[3];
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *ug = in[0], *J = in[1], *qw = in[2];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
    {
-      case 11:
-         for (CeedInt i = 0; i < Q; i++)
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = c[i] * qw[i] / J[i];
-            vg[i] = ug[i] * qd;
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
          }
          break;
-      case 21:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[3];
-            const CeedScalar coeff = c[i];
-            qd[0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[2] =   coeff * w * (J11 * J11 + J21 * J21);
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
             vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
          }
          break;
-      case 22:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[3];
-            const CeedScalar coeff = c[i];
-            qd[0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[2] =   coeff * w * (J11 * J11 + J21 * J21);
-            for (CeedInt d = 0; d < 2; d++)
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (d+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (d+2*1)];
-               vg[i + Q * (d+2*0)] = qd[0] * ug0 + qd[1] * ug1;
-               vg[i + Q * (d+2*1)] = qd[1] * ug0 + qd[2] * ug1;
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
             }
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[6];
-            const CeedScalar coeff = c[i];
-            qd[0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             const CeedScalar ug2 = ug[i + Q * 2];
@@ -504,50 +637,507 @@ CEED_QFUNCTION(f_apply_diff_mf_quad)(void *ctx, CeedInt Q,
             vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
          }
          break;
-      case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[6];
-            const CeedScalar coeff = c[i];
-            qd[0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
-            for (CeedInt d = 0; d < 3; d++)
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (d+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (d+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (d+3*2)];
-               vg[i + Q * (d+3*0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
-               vg[i + Q * (d+3*1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
-               vg[i + Q * (d+3*2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
             }
          }
          break;
    }
    return 0;
 }
+
+/// libCEED QFunction for applying a diffusion operator with a matrix constant
+/// coefficient
+CEED_QFUNCTION(f_apply_diff_mf_const_matrix)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *ug = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vg = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
+   {
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+            vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+            }
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a diffusion operator with a scalar
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_diff_mf_quad_scalar)(void *ctx, CeedInt Q,
+                                            const CeedScalar *const *in,
+                                            CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *ug = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vg = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
+   {
+      case 111:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / J[i];
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+            vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+            }
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a diffusion operator with a vector
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_diff_mf_quad_vector)(void *ctx, CeedInt Q,
+                                            const CeedScalar *const *in,
+                                            CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *ug = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vg = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
+   {
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+            vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+            }
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a diffusion operator with a matrix
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_diff_mf_quad_matrix)(void *ctx, CeedInt Q,
+                                            const CeedScalar *const *in,
+                                            CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *ug = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vg = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
+   {
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+            vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+            }
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_DIFF_QF_H
diff --git a/fem/ceed/integrators/divdiv/divdiv.cpp b/fem/ceed/integrators/divdiv/divdiv.cpp
new file mode 100644
index 000000000..f574c0f4e
--- /dev/null
+++ b/fem/ceed/integrators/divdiv/divdiv.cpp
@@ -0,0 +1,124 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "divdiv.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "divdiv_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct DivDivOperatorInfo : public OperatorInfo
+{
+   DivDivContext ctx = {0};
+   DivDivOperatorInfo(const mfem::FiniteElementSpace &fes, mfem::Coefficient *Q,
+                      bool use_bdr = false, bool use_mf = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_divdiv";
+         apply_qf = &f_apply_divdiv;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx.coeff = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_divdiv_const";
+            build_qf = &f_build_divdiv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_divdiv_mf_const";
+            apply_qf = &f_apply_divdiv_mf_const;
+         }
+      }
+      else if (mfem::ConstantCoefficient *const_coeff =
+                  dynamic_cast<mfem::ConstantCoefficient *>(Q))
+      {
+         ctx.coeff = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_divdiv_const";
+            build_qf = &f_build_divdiv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_divdiv_mf_const";
+            apply_qf = &f_apply_divdiv_mf_const;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_divdiv_quad";
+            build_qf = &f_build_divdiv_quad;
+         }
+         else
+         {
+            apply_func = ":f_apply_divdiv_mf_quad";
+            apply_qf = &f_apply_divdiv_mf_quad;
+         }
+      }
+      header = "/integrators/divdiv/divdiv_qf.h";
+      trial_op = EvalMode::Div;
+      test_op = EvalMode::Div;
+      qdatasize = 1;
+   }
+};
+#endif
+
+PADivDivIntegrator::PADivDivIntegrator(const mfem::DivDivIntegrator &integ,
+                                       const mfem::FiniteElementSpace &fes,
+                                       mfem::Coefficient *Q,
+                                       const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   DivDivOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, Q, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+MFDivDivIntegrator::MFDivDivIntegrator(const mfem::DivDivIntegrator &integ,
+                                       const mfem::FiniteElementSpace &fes,
+                                       mfem::Coefficient *Q,
+                                       const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   DivDivOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, Q, use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/divdiv/divdiv.hpp b/fem/ceed/integrators/divdiv/divdiv.hpp
new file mode 100644
index 000000000..1e5bf163e
--- /dev/null
+++ b/fem/ceed/integrators/divdiv/divdiv.hpp
@@ -0,0 +1,49 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_DIVDIV_HPP
+#define MFEM_LIBCEED_DIVDIV_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/// Represent a DivDivIntegrator with AssemblyLevel::Partial using libCEED.
+class PADivDivIntegrator : public MixedOperator<Integrator>
+{
+public:
+   PADivDivIntegrator(const mfem::DivDivIntegrator &integ,
+                      const mfem::FiniteElementSpace &fes,
+                      mfem::Coefficient *Q,
+                      const bool use_bdr = false);
+};
+
+/// Represent a DivDivIntegrator with AssemblyLevel::None using libCEED.
+class MFDivDivIntegrator : public MixedOperator<Integrator>
+{
+public:
+   MFDivDivIntegrator(const mfem::DivDivIntegrator &integ,
+                      const mfem::FiniteElementSpace &fes,
+                      mfem::Coefficient *Q,
+                      const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_DIVDIV_HPP
diff --git a/fem/ceed/integrators/divdiv/divdiv_qf.h b/fem/ceed/integrators/divdiv/divdiv_qf.h
new file mode 100644
index 000000000..853aa0011
--- /dev/null
+++ b/fem/ceed/integrators/divdiv/divdiv_qf.h
@@ -0,0 +1,250 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_DIVDIV_QF_H
+#define MFEM_LIBCEED_DIVDIV_QF_H
+
+#include "../util/util_qf.h"
+
+struct DivDivContext
+{
+   CeedInt dim, space_dim;
+   CeedScalar coeff;
+};
+
+/// libCEED QFunction for building quadrature data for a div-div operator
+/// with a constant coefficient
+CEED_QFUNCTION(f_build_divdiv_const)(void *ctx, CeedInt Q,
+                                     const CeedScalar *const *in,
+                                     CeedScalar *const *out)
+{
+   DivDivContext *bc = (DivDivContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute and store qw * c / det(J)
+   const CeedScalar coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / DetJ21(J + i, Q);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / DetJ32(J + i, Q);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / DetJ33(J + i, Q);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a div-div operator
+/// with a coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_divdiv_quad)(void *ctx, CeedInt Q,
+                                    const CeedScalar *const *in,
+                                    CeedScalar *const *out)
+{
+   DivDivContext *bc = (DivDivContext *)ctx;
+   // in[0] is coefficients, size (Q)
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute and store qw * c / det(J)
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ21(J + i, Q);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ32(J + i, Q);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ33(J + i, Q);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a div-div operator
+CEED_QFUNCTION(f_apply_divdiv)(void *ctx, CeedInt Q,
+                               const CeedScalar *const *in,
+                               CeedScalar *const *out)
+{
+   // in[0], out[0] have shape [ncomp=1, Q]
+   const CeedScalar *ud = in[0], *qd = in[1];
+   CeedScalar *vd = out[0];
+   CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+   {
+      vd[i] = qd[i] * ud[i];
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a div-div operator with a constant
+/// coefficient
+CEED_QFUNCTION(f_apply_divdiv_mf_const)(void *ctx, CeedInt Q,
+                                        const CeedScalar *const *in,
+                                        CeedScalar *const *out)
+{
+   DivDivContext *bc = (DivDivContext *)ctx;
+   // in[0], out[0] have shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c / det(J)
+   const CeedScalar coeff = bc->coeff;
+   const CeedScalar *ud = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / J[i];
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / DetJ21(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / DetJ22(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / DetJ32(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / DetJ33(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a div-div operator with a coefficient
+/// evaluated at quadrature points
+CEED_QFUNCTION(f_apply_divdiv_mf_quad)(void *ctx, CeedInt Q,
+                                       const CeedScalar *const *in,
+                                       CeedScalar *const *out)
+{
+   DivDivContext *bc = (DivDivContext *)ctx;
+   // in[0], out[0] have shape [ncomp=1, Q]
+   // in[0] is coefficients, size (Q)
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c / det(J)
+   const CeedScalar *ud = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / J[i];
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ21(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ22(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ32(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ33(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_DIVDIV_QF_H
diff --git a/fem/ceed/integrators/interp/interp.cpp b/fem/ceed/integrators/interp/interp.cpp
new file mode 100644
index 000000000..6aab4f47f
--- /dev/null
+++ b/fem/ceed/integrators/interp/interp.cpp
@@ -0,0 +1,58 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "interp.hpp"
+
+#include "../../../../config/config.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct DiscreteInterpolatorOperatorInfo : public OperatorInfo
+{
+   DiscreteInterpolatorOperatorInfo()
+   {
+      // Discrete interpolators use a built-in QFunction
+      header = "";
+      header = "";
+      build_func = "";
+      build_qf = nullptr;
+      apply_func = "";
+      apply_qf = nullptr;
+      apply_func_mf = "";
+      apply_qf_mf = nullptr;
+      trial_op = EvalMode::Interp;
+      test_op = EvalMode::None;
+      qdatasize = 0;
+   }
+};
+#endif
+
+PADiscreteInterpolator::PADiscreteInterpolator(
+   const mfem::DiscreteInterpolator &interp,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes)
+{
+#ifdef MFEM_USE_CEED
+   DiscreteInterpolatorOperatorInfo info;
+   Assemble(interp, info, trial_fes, test_fes, (mfem::Coefficient *)nullptr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/solvers/full-assembly.hpp b/fem/ceed/integrators/interp/interp.hpp
similarity index 50%
rename from fem/ceed/solvers/full-assembly.hpp
rename to fem/ceed/integrators/interp/interp.hpp
index ed338f725..a923df572 100644
--- a/fem/ceed/solvers/full-assembly.hpp
+++ b/fem/ceed/integrators/interp/interp.hpp
@@ -9,12 +9,12 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#ifndef MFEM_CEED_ASSEMBLE_HPP
-#define MFEM_CEED_ASSEMBLE_HPP
+#ifndef MFEM_LIBCEED_INTERP_HPP
+#define MFEM_LIBCEED_INTERP_HPP
 
-#include "../interface/ceed.hpp"
-
-#ifdef MFEM_USE_CEED
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
 
 namespace mfem
 {
@@ -22,18 +22,19 @@ namespace mfem
 namespace ceed
 {
 
-/** @brief Assembles a CeedOperator as an mfem::SparseMatrix
-
-    In parallel, this assembles independently on each processor, that is, it
-    assembles at the L-vector level. The assembly procedure is always performed
-    on the host, but this works also for operators stored on device by copying
-    memory. */
-int CeedOperatorFullAssemble(CeedOperator op, SparseMatrix **mat);
-
-} // namespace ceed
+/** Represent DiscreteInterpolator classes with AssemblyLevel::Partial
+    using libCEED. */
+class PADiscreteInterpolator : public MixedOperator<Interpolator>
+{
+public:
+   PADiscreteInterpolator(
+      const mfem::DiscreteInterpolator &interp,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes);
+};
 
-} // namespace mfem
+}
 
-#endif
+}
 
-#endif
+#endif // MFEM_LIBCEED_INTERP_HPP
diff --git a/fem/ceed/integrators/mass/mass.cpp b/fem/ceed/integrators/mass/mass.cpp
index dfcc9a8ce..6a8d67ddc 100644
--- a/fem/ceed/integrators/mass/mass.cpp
+++ b/fem/ceed/integrators/mass/mass.cpp
@@ -25,20 +25,66 @@ namespace ceed
 #ifdef MFEM_USE_CEED
 struct MassOperatorInfo : public OperatorInfo
 {
-   MassContext ctx;
-   MassOperatorInfo()
+   MassContext ctx = {0};
+   MassOperatorInfo(const mfem::FiniteElementSpace &fes, mfem::Coefficient *Q,
+                    bool use_bdr = false, bool use_mf = false)
    {
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      ctx.vdim = fes.GetVDim();
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_mass";
+         apply_qf = &f_apply_mass;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx.coeff = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_mass_const";
+            build_qf = &f_build_mass_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_mass_mf_const";
+            apply_qf = &f_apply_mass_mf_const;
+         }
+      }
+      else if (mfem::ConstantCoefficient *const_coeff =
+                  dynamic_cast<mfem::ConstantCoefficient *>(Q))
+      {
+         ctx.coeff = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_mass_const";
+            build_qf = &f_build_mass_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_mass_mf_const";
+            apply_qf = &f_apply_mass_mf_const;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_mass_quad";
+            build_qf = &f_build_mass_quad;
+         }
+         else
+         {
+            apply_func = ":f_apply_mass_mf_quad";
+            apply_qf = &f_apply_mass_mf_quad;
+         }
+      }
       header = "/integrators/mass/mass_qf.h";
-      build_func_const = ":f_build_mass_const";
-      build_qf_const = &f_build_mass_const;
-      build_func_quad = ":f_build_mass_quad";
-      build_qf_quad = &f_build_mass_quad;
-      apply_func = ":f_apply_mass";
-      apply_qf = &f_apply_mass;
-      apply_func_mf_const = ":f_apply_mass_mf_const";
-      apply_qf_mf_const = &f_apply_mass_mf_const;
-      apply_func_mf_quad = ":f_apply_mass_mf_quad";
-      apply_qf_mf_quad = &f_apply_mass_mf_quad;
       trial_op = EvalMode::Interp;
       test_op = EvalMode::Interp;
       qdatasize = 1;
@@ -46,75 +92,53 @@ struct MassOperatorInfo : public OperatorInfo
 };
 #endif
 
-PAMassIntegrator::PAMassIntegrator(const mfem::FiniteElementSpace &fes,
-                                   const mfem::IntegrationRule &irm,
-                                   mfem::Coefficient *Q)
-   : PAIntegrator()
+PAMassIntegrator::PAMassIntegrator(const mfem::MassIntegrator &integ,
+                                   const mfem::FiniteElementSpace &fes,
+                                   mfem::Coefficient *Q,
+                                   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(info, fes, irm, Q);
+   MassOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, Q, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPAMassIntegrator::MixedPAMassIntegrator(const MassIntegrator &integ,
-                                             const mfem::FiniteElementSpace &fes,
-                                             mfem::Coefficient *Q)
+PAMassIntegrator::PAMassIntegrator(const mfem::VectorMassIntegrator &integ,
+                                   const mfem::FiniteElementSpace &fes,
+                                   mfem::Coefficient *Q,
+                                   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(integ, info, fes, Q);
+   MassOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, Q, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPAMassIntegrator::MixedPAMassIntegrator(const VectorMassIntegrator &integ,
-                                             const mfem::FiniteElementSpace &fes,
-                                             mfem::Coefficient *Q)
+MFMassIntegrator::MFMassIntegrator(const mfem::MassIntegrator &integ,
+                                   const mfem::FiniteElementSpace &fes,
+                                   mfem::Coefficient *Q,
+                                   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(integ, info, fes, Q);
+   MassOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, Q, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MFMassIntegrator::MFMassIntegrator(const mfem::FiniteElementSpace &fes,
-                                   const mfem::IntegrationRule &irm,
-                                   mfem::Coefficient *Q)
-   : MFIntegrator()
+MFMassIntegrator::MFMassIntegrator(const mfem::VectorMassIntegrator &integ,
+                                   const mfem::FiniteElementSpace &fes,
+                                   mfem::Coefficient *Q,
+                                   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(info, fes, irm, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedMFMassIntegrator::MixedMFMassIntegrator(const MassIntegrator &integ,
-                                             const mfem::FiniteElementSpace &fes,
-                                             mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(integ, info, fes, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedMFMassIntegrator::MixedMFMassIntegrator(const VectorMassIntegrator &integ,
-                                             const mfem::FiniteElementSpace &fes,
-                                             mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(integ, info, fes, Q);
+   MassOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, Q, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
diff --git a/fem/ceed/integrators/mass/mass.hpp b/fem/ceed/integrators/mass/mass.hpp
index 696f8c3dc..4125fc6ed 100644
--- a/fem/ceed/integrators/mass/mass.hpp
+++ b/fem/ceed/integrators/mass/mass.hpp
@@ -13,7 +13,7 @@
 #define MFEM_LIBCEED_MASS_HPP
 
 #include "../../interface/integrator.hpp"
-#include "../../interface/mixed_integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
 #include "../../../fespace.hpp"
 
 namespace mfem
@@ -23,45 +23,33 @@ namespace ceed
 {
 
 /// Represent a MassIntegrator with AssemblyLevel::Partial using libCEED.
-class PAMassIntegrator : public PAIntegrator
+class PAMassIntegrator : public MixedOperator<Integrator>
 {
 public:
-   PAMassIntegrator(const mfem::FiniteElementSpace &fes,
-                    const mfem::IntegrationRule &ir,
-                    mfem::Coefficient *Q);
-};
-
-class MixedPAMassIntegrator : public MixedIntegrator<PAIntegrator>
-{
-public:
-   MixedPAMassIntegrator(const MassIntegrator &integ,
-                         const mfem::FiniteElementSpace &fes,
-                         mfem::Coefficient *Q);
-
-   MixedPAMassIntegrator(const VectorMassIntegrator &integ,
-                         const mfem::FiniteElementSpace &fes,
-                         mfem::Coefficient *Q);
+   PAMassIntegrator(const mfem::MassIntegrator &integ,
+                    const mfem::FiniteElementSpace &fes,
+                    mfem::Coefficient *Q,
+                    const bool use_bdr = false);
+
+   PAMassIntegrator(const mfem::VectorMassIntegrator &integ,
+                    const mfem::FiniteElementSpace &fes,
+                    mfem::Coefficient *Q,
+                    const bool use_bdr = false);
 };
 
 /// Represent a MassIntegrator with AssemblyLevel::None using libCEED.
-class MFMassIntegrator : public MFIntegrator
+class MFMassIntegrator : public MixedOperator<Integrator>
 {
 public:
-   MFMassIntegrator(const mfem::FiniteElementSpace &fes,
-                    const mfem::IntegrationRule &ir,
-                    mfem::Coefficient *Q);
-};
-
-class MixedMFMassIntegrator : public MixedIntegrator<MFIntegrator>
-{
-public:
-   MixedMFMassIntegrator(const MassIntegrator &integ,
-                         const mfem::FiniteElementSpace &fes,
-                         mfem::Coefficient *Q);
-
-   MixedMFMassIntegrator(const VectorMassIntegrator &integ,
-                         const mfem::FiniteElementSpace &fes,
-                         mfem::Coefficient *Q);
+   MFMassIntegrator(const mfem::MassIntegrator &integ,
+                    const mfem::FiniteElementSpace &fes,
+                    mfem::Coefficient *Q,
+                    const bool use_bdr = false);
+
+   MFMassIntegrator(const mfem::VectorMassIntegrator &integ,
+                    const mfem::FiniteElementSpace &fes,
+                    mfem::Coefficient *Q,
+                    const bool use_bdr = false);
 };
 
 }
diff --git a/fem/ceed/integrators/mass/mass_qf.h b/fem/ceed/integrators/mass/mass_qf.h
index 85002ae04..3cdd3b5e3 100644
--- a/fem/ceed/integrators/mass/mass_qf.h
+++ b/fem/ceed/integrators/mass/mass_qf.h
@@ -9,128 +9,151 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
+#ifndef MFEM_LIBCEED_MASS_QF_H
+#define MFEM_LIBCEED_MASS_QF_H
 
-/// A structure used to pass additional data to f_build_diff and f_apply_diff
-struct MassContext { CeedInt dim, space_dim, vdim; CeedScalar coeff; };
+#include "../util/util_qf.h"
 
-/// libCEED Q-function for building quadrature data for a mass operator with a
-/// constant coefficient
+struct MassContext
+{
+   CeedInt dim, space_dim, vdim;
+   CeedScalar coeff;
+};
+
+/// libCEED QFunction for building quadrature data for a mass operator
+/// with a constant coefficient
 CEED_QFUNCTION(f_build_mass_const)(void *ctx, CeedInt Q,
                                    const CeedScalar *const *in,
                                    CeedScalar *const *out)
 {
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute and store qw * c * det(J)
    MassContext *bc = (MassContext *)ctx;
    const CeedScalar coeff = bc->coeff;
    const CeedScalar *J = in[0], *qw = in[1];
-   CeedScalar *rho = out[0];
-   switch (bc->dim + 10*bc->space_dim)
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            rho[i] = coeff * J[i] * qw[i];
+            qd[i] = qw[i] * coeff * DetJ21(J + i, Q);
          }
          break;
       case 22:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            rho[i] = coeff * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
+            qd[i] = qw[i] * coeff * DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff * DetJ32(J + i, Q);
          }
          break;
       case 33:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            rho[i] = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                      J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                      J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * coeff * qw[i];
+            qd[i] = qw[i] * coeff * DetJ33(J + i, Q);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for building quadrature data for a mass operator with a
-/// coefficient evaluated at quadrature points.
+/// libCEED QFunction for building quadrature data for a mass operator
+/// with a coefficient evaluated at quadrature points
 CEED_QFUNCTION(f_build_mass_quad)(void *ctx, CeedInt Q,
                                   const CeedScalar *const *in,
                                   CeedScalar *const *out)
 {
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
-   // in[1] is quadrature weights, size (Q)
+   // in[0] is coefficients, size (Q)
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute and store qw * c * det(J)
    MassContext *bc = (MassContext *)ctx;
    const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
-   CeedScalar *rho = out[0];
-   switch (bc->dim + 10*bc->space_dim)
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            rho[i] = c[i] * J[i] * qw[i];
+            qd[i] = qw[i] * c[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] * DetJ21(J + i, Q);
          }
          break;
       case 22:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] * DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            rho[i] = c[i] * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
+            qd[i] = qw[i] * c[i] * DetJ32(J + i, Q);
          }
          break;
       case 33:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            rho[i] = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                      J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                      J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * c[i] * qw[i];
+            qd[i] = qw[i] * c[i] * DetJ33(J + i, Q);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a mass operator
+/// libCEED QFunction for applying a mass operator
 CEED_QFUNCTION(f_apply_mass)(void *ctx, CeedInt Q,
                              const CeedScalar *const *in,
                              CeedScalar *const *out)
 {
    MassContext *bc = (MassContext *)ctx;
-   const CeedScalar *u = in[0], *w = in[1];
+   // in[0], out[0] have shape [ncomp=vdim, Q]
+   const CeedScalar *u = in[0], *qd = in[1];
    CeedScalar *v = out[0];
    switch (bc->vdim)
    {
       case 1:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            v[i] = w[i] * u[i];
+            v[i] = qd[i] * u[i];
          }
          break;
       case 2:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar W = w[i];
-            for (CeedInt c = 0; c < 2; c++)
+            const CeedScalar qdi = qd[i];
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               v[i+c*Q] = W * u[i+c*Q];
+               v[i + d * Q] = qdi * u[i + d * Q];
             }
          }
          break;
       case 3:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar W = w[i];
-            for (CeedInt c = 0; c < 3; c++)
+            const CeedScalar qdi = qd[i];
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               v[i+c*Q] = W * u[i+c*Q];
+               v[i + d * Q] = qdi * u[i + d * Q];
             }
          }
          break;
@@ -138,63 +161,95 @@ CEED_QFUNCTION(f_apply_mass)(void *ctx, CeedInt Q,
    return 0;
 }
 
-/// libCEED Q-function for applying a diff operator
+/// libCEED QFunction for applying a mass operator with a constant
+/// coefficient
 CEED_QFUNCTION(f_apply_mass_mf_const)(void *ctx, CeedInt Q,
-                                      const CeedScalar *const *in, CeedScalar *const *out)
+                                      const CeedScalar *const *in,
+                                      CeedScalar *const *out)
 {
-   MassContext *bc = (MassContext*)ctx;
+   MassContext *bc = (MassContext *)ctx;
+   // in[0], out[0] have shape [ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c * det(J)
    const CeedScalar coeff = bc->coeff;
    const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
    CeedScalar *v = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
    {
-      case 11:
-         for (CeedInt i = 0; i < Q; i++)
+      case 111:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar rho = coeff * qw[i] / J[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * coeff * J[i];
+            v[i] = qd * u[i];
          }
          break;
-      case 21:
-         for (CeedInt i = 0; i < Q; i++)
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar rho = coeff * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * coeff * DetJ21(J + i, Q);
+            v[i] = qd * u[i];
          }
          break;
-      case 22:
-         for (CeedInt i=0; i<Q; i++)
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            const CeedScalar rho = coeff * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
-            for (CeedInt c = 0; c < 2; c++)
+            const CeedScalar qd = qw[i] * coeff * DetJ21(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               v[i+c*Q] = rho * u[i+c*Q];
+               v[i + d * Q] = qd * u[i + d * Q];
             }
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar rho = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                                    J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                                    J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * coeff * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * coeff * DetJ22(J + i, Q);
+            v[i] = qd * u[i];
          }
          break;
-      case 33:
-         for (CeedInt i=0; i<Q; i++)
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * DetJ22(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               v[i + d * Q] = qd * u[i + d * Q];
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * DetJ32(J + i, Q);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            const CeedScalar rho = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                                    J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                                    J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * coeff * qw[i];
-            for (CeedInt c = 0; c < 3; c++)
+            const CeedScalar qd = qw[i] * coeff * DetJ32(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               v[i+c*Q] = rho * u[i+c*Q];
+               v[i + d * Q] = qd * u[i + d * Q];
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * DetJ33(J + i, Q);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * DetJ33(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               v[i + d * Q] = qd * u[i + d * Q];
             }
          }
          break;
@@ -202,69 +257,99 @@ CEED_QFUNCTION(f_apply_mass_mf_const)(void *ctx, CeedInt Q,
    return 0;
 }
 
+/// libCEED QFunction for applying a mass operator with a coefficient
+/// evaluated at quadrature points
 CEED_QFUNCTION(f_apply_mass_mf_quad)(void *ctx, CeedInt Q,
-                                     const CeedScalar *const *in, CeedScalar *const *out)
+                                     const CeedScalar *const *in,
+                                     CeedScalar *const *out)
 {
-   MassContext *bc = (MassContext*)ctx;
-   const CeedScalar *c = in[0], *u = in[1], *J = in[2], *qw = in[3];
+   MassContext *bc = (MassContext *)ctx;
+   // in[0], out[0] have shape [ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c * det(J)
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
    CeedScalar *v = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
    {
-      case 11:
-         for (CeedInt i=0; i<Q; i++)
+      case 111:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar rho = c[i] * J[i] * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * c[i] * J[i];
+            v[i] = qd * u[i];
          }
          break;
-      case 21:
-         for (CeedInt i=0; i<Q; i++)
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            const CeedScalar rho = c[i] * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * c[i] * DetJ21(J + i, Q);
+            v[i] = qd * u[i];
          }
          break;
-      case 22:
-         for (CeedInt i=0; i<Q; i++)
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            const CeedScalar rho = c[i] * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
-            for (CeedInt d = 0; d < 2; d++)
+            const CeedScalar qd = qw[i] * c[i] * DetJ21(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               v[i+d*Q] = rho * u[i+d*Q];
+               v[i + d * Q] = qd * u[i + d * Q];
             }
          }
          break;
-      case 31:
-         for (CeedInt i=0; i<Q; i++)
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            const CeedScalar rho = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                                    J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                                    J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * c[i] * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * c[i] * DetJ22(J + i, Q);
+            v[i] = qd * u[i];
          }
          break;
-      case 33:
-         for (CeedInt i=0; i<Q; i++)
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * DetJ22(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               v[i + d * Q] = qd * u[i + d * Q];
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * DetJ32(J + i, Q);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            const CeedScalar rho = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                                    J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                                    J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * c[i] * qw[i];
-            for (CeedInt d = 0; d < 3; d++)
+            const CeedScalar qd = qw[i] * c[i] * DetJ32(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               v[i+d*Q] = rho * u[i+d*Q];
+               v[i + d * Q] = qd * u[i + d * Q];
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * DetJ33(J + i, Q);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * DetJ33(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               v[i + d * Q] = qd * u[i + d * Q];
             }
          }
          break;
    }
    return 0;
 }
+
+#endif // MFEM_LIBCEED_MASS_QF_H
diff --git a/fem/ceed/integrators/mixedveccurl/mixedveccurl.cpp b/fem/ceed/integrators/mixedveccurl/mixedveccurl.cpp
new file mode 100644
index 000000000..a0186e391
--- /dev/null
+++ b/fem/ceed/integrators/mixedveccurl/mixedveccurl.cpp
@@ -0,0 +1,338 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mixedveccurl.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "../curlcurl/curlcurl_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct MixedVectorCurlOperatorInfoBase : public OperatorInfo
+{
+   CurlCurlContext ctx = {0};
+   template <typename CoeffType>
+   MixedVectorCurlOperatorInfoBase(const mfem::FiniteElementSpace &trial_fes,
+                                   const mfem::FiniteElementSpace &test_fes,
+                                   CoeffType *Q, bool use_bdr = false,
+                                   bool use_mf = false)
+   {
+      // Reuse H(div) quadrature functions for CurlCurlIntegrator
+      MFEM_VERIFY(trial_fes.GetVDim() == 1 && test_fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = trial_fes.GetMesh()->Dimension() - use_bdr;
+      MFEM_VERIFY(ctx.dim == 3,
+                  "MixedVectorCurlIntegrator and MixedVectorWeakCurlIntegrator "
+                  "require dim == 3!");
+      ctx.space_dim = trial_fes.GetMesh()->SpaceDimension();
+      ctx.curl_dim = (ctx.dim < 3) ? 1 : ctx.dim;
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_curlcurl";
+         apply_qf = &f_apply_curlcurl;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_scalar";
+            build_qf = &f_build_curlcurl_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_scalar";
+            apply_qf = &f_apply_curlcurl_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, use_mf);
+      }
+      header = "/integrators/curlcurl/curlcurl_qf.h";
+      qdatasize = (ctx.curl_dim * (ctx.curl_dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_scalar";
+            build_qf = &f_build_curlcurl_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_scalar";
+            apply_qf = &f_apply_curlcurl_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_scalar";
+            build_qf = &f_build_curlcurl_quad_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_scalar";
+            apply_qf = &f_apply_curlcurl_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_CURLCURL_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_vector";
+            build_qf = &f_build_curlcurl_const_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_vector";
+            apply_qf = &f_apply_curlcurl_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_vector";
+            build_qf = &f_build_curlcurl_quad_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_vector";
+            apply_qf = &f_apply_curlcurl_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_CURLCURL_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_matrix";
+            build_qf = &f_build_curlcurl_const_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_matrix";
+            apply_qf = &f_apply_curlcurl_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_matrix";
+            build_qf = &f_build_curlcurl_quad_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_matrix";
+            apply_qf = &f_apply_curlcurl_mf_quad_matrix;
+         }
+      }
+   }
+};
+
+struct MixedVectorCurlOperatorInfo : public MixedVectorCurlOperatorInfoBase
+{
+   template <typename CoeffType>
+   MixedVectorCurlOperatorInfo(const mfem::FiniteElementSpace &trial_fes,
+                               const mfem::FiniteElementSpace &test_fes,
+                               CoeffType *Q, bool use_bdr = false,
+                               bool use_mf = false)
+      : MixedVectorCurlOperatorInfoBase(trial_fes, test_fes, Q, use_bdr, use_mf)
+   {
+      MFEM_VERIFY(
+         trial_fes.FEColl()->GetDerivMapType(ctx.dim) == mfem::FiniteElement::H_DIV &&
+         test_fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_DIV,
+         "libCEED interface for MixedVectorCurlIntegrator requires "
+         "H(curl) domain and H(div) range FE spaces!");
+      trial_op = EvalMode::Curl;
+      test_op = EvalMode::Interp;
+   }
+};
+
+struct MixedVectorWeakCurlOperatorInfo : public MixedVectorCurlOperatorInfoBase
+{
+   template <typename CoeffType>
+   MixedVectorWeakCurlOperatorInfo(const mfem::FiniteElementSpace &trial_fes,
+                                   const mfem::FiniteElementSpace &test_fes,
+                                   CoeffType *Q, bool use_bdr = false,
+                                   bool use_mf = false)
+      : MixedVectorCurlOperatorInfoBase(trial_fes, test_fes, Q, use_bdr, use_mf)
+   {
+      MFEM_VERIFY(
+         trial_fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_DIV &&
+         test_fes.FEColl()->GetDerivMapType(ctx.dim) == mfem::FiniteElement::H_DIV,
+         "libCEED interface for MixedVectorWeakCurlIntegrator requires "
+         "H(div) domain and H(curl) range FE spaces!");
+      trial_op = EvalMode::Interp;
+      test_op = EvalMode::Curl;
+   }
+};
+#endif
+
+template <typename CoeffType>
+PAMixedVectorCurlIntegrator::PAMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorCurlOperatorInfo info(trial_fes, test_fes, Q, use_bdr);
+   Assemble(integ, info, trial_fes, test_fes, Q, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFMixedVectorCurlIntegrator::MFMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorCurlOperatorInfo info(trial_fes, test_fes, Q, use_bdr, true);
+   Assemble(integ, info, trial_fes, test_fes, Q, use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+PAMixedVectorWeakCurlIntegrator::PAMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorWeakCurlOperatorInfo info(trial_fes, test_fes, Q, use_bdr);
+   Assemble(integ, info, trial_fes, test_fes, Q, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFMixedVectorWeakCurlIntegrator::MFMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorWeakCurlOperatorInfo info(trial_fes, test_fes, Q, use_bdr, true);
+   Assemble(integ, info, trial_fes, test_fes, Q, use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PAMixedVectorCurlIntegrator::PAMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template PAMixedVectorCurlIntegrator::PAMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template PAMixedVectorCurlIntegrator::PAMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template MFMixedVectorCurlIntegrator::MFMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template MFMixedVectorCurlIntegrator::MFMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template MFMixedVectorCurlIntegrator::MFMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template PAMixedVectorWeakCurlIntegrator::PAMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template PAMixedVectorWeakCurlIntegrator::PAMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template PAMixedVectorWeakCurlIntegrator::PAMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template MFMixedVectorWeakCurlIntegrator::MFMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template MFMixedVectorWeakCurlIntegrator::MFMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template MFMixedVectorWeakCurlIntegrator::MFMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/mixedveccurl/mixedveccurl.hpp b/fem/ceed/integrators/mixedveccurl/mixedveccurl.hpp
new file mode 100644
index 000000000..3bae19e0c
--- /dev/null
+++ b/fem/ceed/integrators/mixedveccurl/mixedveccurl.hpp
@@ -0,0 +1,85 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_MIXEDVECCURL_HPP
+#define MFEM_LIBCEED_MIXEDVECCURL_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/** Represent a MixedVectorCurlIntegrator with AssemblyLevel::Partial
+    using libCEED. */
+class PAMixedVectorCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAMixedVectorCurlIntegrator(
+      const mfem::MixedVectorCurlIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorCurlIntegrator with AssemblyLevel::None
+    using libCEED. */
+class MFMixedVectorCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFMixedVectorCurlIntegrator(
+      const mfem::MixedVectorCurlIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorWeakCurlIntegrator with AssemblyLevel::Partial
+    using libCEED. */
+class PAMixedVectorWeakCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAMixedVectorWeakCurlIntegrator(
+      const mfem::MixedVectorWeakCurlIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorWeakCurlIntegrator with AssemblyLevel::None
+    using libCEED. */
+class MFMixedVectorWeakCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFMixedVectorWeakCurlIntegrator(
+      const mfem::MixedVectorWeakCurlIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_MIXEDVECCURL_HPP
diff --git a/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.cpp b/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.cpp
new file mode 100644
index 000000000..f8f708bab
--- /dev/null
+++ b/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.cpp
@@ -0,0 +1,396 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mixedvecgrad.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "../diffusion/diffusion_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct MixedVectorGradientOperatorInfoBase : public OperatorInfo
+{
+   DiffusionContext ctx = {0};
+   template <typename CoeffType>
+   MixedVectorGradientOperatorInfoBase(const mfem::FiniteElementSpace &trial_fes,
+                                       const mfem::FiniteElementSpace &test_fes,
+                                       CoeffType *Q, bool use_bdr = false,
+                                       bool use_mf = false)
+   {
+      // Reuse H(curl) quadrature functions for DiffusionIntegrator
+      MFEM_VERIFY(trial_fes.GetVDim() == 1 && test_fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = trial_fes.GetMesh()->Dimension() - use_bdr;
+      MFEM_VERIFY(ctx.dim == 2 || ctx.dim == 3,
+                  "MixedVectorGradientIntegrator and MixedVectorWeakDivergenceIntegrator "
+                  "require dim == 2 or dim == 3!");
+      ctx.space_dim = trial_fes.GetMesh()->SpaceDimension();
+      ctx.vdim = 1;
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_diff";
+         apply_qf = &f_apply_diff;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_scalar";
+            build_qf = &f_build_diff_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_scalar";
+            apply_qf = &f_apply_diff_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, use_mf);
+      }
+      header = "/integrators/diffusion/diffusion_qf.h";
+      qdatasize = (ctx.dim * (ctx.dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_scalar";
+            build_qf = &f_build_diff_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_scalar";
+            apply_qf = &f_apply_diff_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_scalar";
+            build_qf = &f_build_diff_quad_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_scalar";
+            apply_qf = &f_apply_diff_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_DIFF_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_vector";
+            build_qf = &f_build_diff_const_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_vector";
+            apply_qf = &f_apply_diff_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_vector";
+            build_qf = &f_build_diff_quad_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_vector";
+            apply_qf = &f_apply_diff_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_DIFF_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_matrix";
+            build_qf = &f_build_diff_const_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_matrix";
+            apply_qf = &f_apply_diff_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_matrix";
+            build_qf = &f_build_diff_quad_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_matrix";
+            apply_qf = &f_apply_diff_mf_quad_matrix;
+         }
+      }
+   }
+};
+
+struct MixedVectorGradientOperatorInfo :
+   public MixedVectorGradientOperatorInfoBase
+{
+   template <typename CoeffType>
+   MixedVectorGradientOperatorInfo(const mfem::FiniteElementSpace &trial_fes,
+                                   const mfem::FiniteElementSpace &test_fes,
+                                   CoeffType *Q, bool use_bdr = false,
+                                   bool use_mf = false)
+      : MixedVectorGradientOperatorInfoBase(trial_fes, test_fes, Q, use_bdr, use_mf)
+   {
+      MFEM_VERIFY(
+         (trial_fes.FEColl()->GetDerivMapType(ctx.dim) == mfem::FiniteElement::H_CURL &&
+          test_fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_CURL),
+         "libCEED interface for MixedVectorGradientIntegrator requires "
+         "H^1 domain and H(curl) range FE spaces!");
+      trial_op = EvalMode::Grad;
+      test_op = EvalMode::Interp;
+   }
+};
+
+struct MixedVectorWeakDivergenceOperatorInfo :
+   public MixedVectorGradientOperatorInfoBase
+{
+   template <typename CoeffType>
+   MixedVectorWeakDivergenceOperatorInfo(const mfem::FiniteElementSpace &trial_fes,
+                                         const mfem::FiniteElementSpace &test_fes,
+                                         CoeffType *Q, bool use_bdr = false,
+                                         bool use_mf = false)
+      : MixedVectorGradientOperatorInfoBase(trial_fes, test_fes, Q, use_bdr, use_mf)
+   {
+      MFEM_VERIFY(
+         (trial_fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_CURL &&
+          test_fes.FEColl()->GetDerivMapType(ctx.dim) == mfem::FiniteElement::H_CURL),
+         "libCEED interface for MixedVectorWeakDivergenceIntegrator requires "
+         "H(curl) domain and H^1 range FE spaces!");
+      trial_op = EvalMode::Interp;
+      test_op = EvalMode::Grad;
+      for (int i = 0; i < LIBCEED_DIFF_COEFF_COMP_MAX; i++)
+      {
+         ctx.coeff[i] *= -1.0;
+      }
+   }
+};
+#endif
+
+template <typename CoeffType>
+PAMixedVectorGradientIntegrator::PAMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorGradientOperatorInfo info(trial_fes, test_fes, Q, use_bdr);
+   Assemble(integ, info, trial_fes, test_fes, Q, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFMixedVectorGradientIntegrator::MFMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorGradientOperatorInfo info(trial_fes, test_fes, Q, use_bdr, true);
+   Assemble(integ, info, trial_fes, test_fes, Q, use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+namespace
+{
+
+#ifdef MFEM_USE_CEED
+mfem::Coefficient *NegativeCoeff(mfem::Coefficient &Q)
+{
+   return (dynamic_cast<mfem::ConstantCoefficient *>(&Q) != nullptr) ?
+          nullptr : new mfem::ProductCoefficient(-1.0, Q);
+}
+
+mfem::VectorCoefficient *NegativeCoeff(mfem::VectorCoefficient &Q)
+{
+   return (dynamic_cast<mfem::VectorConstantCoefficient *>(&Q) != nullptr) ?
+          nullptr : new mfem::ScalarVectorProductCoefficient(-1.0, Q);
+}
+
+mfem::MatrixCoefficient *NegativeCoeff(mfem::MatrixCoefficient &Q)
+{
+   return (dynamic_cast<mfem::MatrixConstantCoefficient *>(&Q) != nullptr) ?
+          nullptr : new mfem::ScalarMatrixProductCoefficient(-1.0, Q);
+}
+#endif
+
+} // namespace
+
+template <typename CoeffType>
+PAMixedVectorWeakDivergenceIntegrator::PAMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorWeakDivergenceOperatorInfo info(trial_fes, test_fes, Q, use_bdr);
+   if (Q)
+   {
+      // Does not inherit ownership of old Q
+      auto *nQ = NegativeCoeff(*Q);
+      Assemble(integ, info, trial_fes, test_fes, nQ, use_bdr);
+      delete nQ;
+   }
+   else
+   {
+      Assemble(integ, info, trial_fes, test_fes, Q, use_bdr);
+   }
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFMixedVectorWeakDivergenceIntegrator::MFMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorWeakDivergenceOperatorInfo info(trial_fes, test_fes, Q, use_bdr,
+                                              true);
+   if (Q)
+   {
+      // Does not inherit ownership of old Q
+      auto *nQ = NegativeCoeff(*Q);
+      Assemble(integ, info, trial_fes, test_fes, nQ, use_bdr, true);
+      delete nQ;
+   }
+   else
+   {
+      Assemble(integ, info, trial_fes, test_fes, Q, use_bdr, true);
+   }
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PAMixedVectorGradientIntegrator::PAMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template PAMixedVectorGradientIntegrator::PAMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template PAMixedVectorGradientIntegrator::PAMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template PAMixedVectorWeakDivergenceIntegrator::PAMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template PAMixedVectorWeakDivergenceIntegrator::PAMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template PAMixedVectorWeakDivergenceIntegrator::PAMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template MFMixedVectorGradientIntegrator::MFMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template MFMixedVectorGradientIntegrator::MFMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template MFMixedVectorGradientIntegrator::MFMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template MFMixedVectorWeakDivergenceIntegrator::MFMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template MFMixedVectorWeakDivergenceIntegrator::MFMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template MFMixedVectorWeakDivergenceIntegrator::MFMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.hpp b/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.hpp
new file mode 100644
index 000000000..c4220ea0f
--- /dev/null
+++ b/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.hpp
@@ -0,0 +1,85 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_MIXEDVECGRAD_HPP
+#define MFEM_LIBCEED_MIXEDVECGRAD_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/** Represent a MixedVectorGradientIntegrator with AssemblyLevel::Partial
+    using libCEED. */
+class PAMixedVectorGradientIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAMixedVectorGradientIntegrator(
+      const mfem::MixedVectorGradientIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorGradientIntegrator with AssemblyLevel::None
+    using libCEED. */
+class MFMixedVectorGradientIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFMixedVectorGradientIntegrator(
+      const mfem::MixedVectorGradientIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorWeakDivergenceIntegrator with AssemblyLevel::Partial
+    using libCEED. */
+class PAMixedVectorWeakDivergenceIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAMixedVectorWeakDivergenceIntegrator(
+      const mfem::MixedVectorWeakDivergenceIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorWeakDivergenceIntegrator with AssemblyLevel::None
+    using libCEED. */
+class MFMixedVectorWeakDivergenceIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFMixedVectorWeakDivergenceIntegrator(
+      const mfem::MixedVectorWeakDivergenceIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_MIXEDVECGRAD_HPP
diff --git a/fem/ceed/integrators/nlconvection/nlconvection.cpp b/fem/ceed/integrators/nlconvection/nlconvection.cpp
index ba4a274dc..c285051ee 100644
--- a/fem/ceed/integrators/nlconvection/nlconvection.cpp
+++ b/fem/ceed/integrators/nlconvection/nlconvection.cpp
@@ -25,76 +25,98 @@ namespace ceed
 #ifdef MFEM_USE_CEED
 struct NLConvectionOperatorInfo : public OperatorInfo
 {
-   NLConvectionContext ctx;
-   NLConvectionOperatorInfo(int dim)
+   NLConvectionContext ctx = {0};
+   NLConvectionOperatorInfo(const mfem::FiniteElementSpace &fes,
+                            mfem::Coefficient *Q, bool use_bdr = false,
+                            bool use_mf = false)
    {
+      MFEM_VERIFY(fes.GetVDim() == fes.GetMesh()->SpaceDimension(),
+                  "Missing coefficient in ceed::NLConvectionOperatorInfo!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_conv";
+         apply_qf = &f_apply_conv;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx.coeff = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_const";
+            build_qf = &f_build_conv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_const";
+            apply_qf = &f_apply_conv_mf_const;
+         }
+      }
+      else if (mfem::ConstantCoefficient *const_coeff =
+                  dynamic_cast<mfem::ConstantCoefficient *>(Q))
+      {
+         ctx.coeff = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_const";
+            build_qf = &f_build_conv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_const";
+            apply_qf = &f_apply_conv_mf_const;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_quad";
+            build_qf = &f_build_conv_quad;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_quad";
+            apply_qf = &f_apply_conv_mf_quad;
+         }
+      }
       header = "/integrators/nlconvection/nlconvection_qf.h";
-      build_func_const = ":f_build_conv_const";
-      build_qf_const = &f_build_conv_const;
-      build_func_quad = ":f_build_conv_quad";
-      build_qf_quad = &f_build_conv_quad;
-      apply_func = ":f_apply_conv";
-      apply_qf = &f_apply_conv;
-      apply_func_mf_const = ":f_apply_conv_mf_const";
-      apply_qf_mf_const = &f_apply_conv_mf_const;
-      apply_func_mf_quad = ":f_apply_conv_mf_quad";
-      apply_qf_mf_quad = &f_apply_conv_mf_quad;
       trial_op = EvalMode::InterpAndGrad;
       test_op = EvalMode::Interp;
-      qdatasize = dim * dim;
+      qdatasize = ctx.dim * ctx.space_dim;
    }
 };
 #endif
 
-PAVectorConvectionNLFIntegrator::PAVectorConvectionNLFIntegrator(
+PAVectorConvectionNLIntegrator::PAVectorConvectionNLIntegrator(
+   const mfem::VectorConvectionNLFIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::Coefficient *Q)
-   : PAIntegrator()
+   mfem::Coefficient *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   NLConvectionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(info, fes, irm, Q);
+   NLConvectionOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, Q, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPAVectorConvectionNLIntegrator::MixedPAVectorConvectionNLIntegrator(
-   const VectorConvectionNLFIntegrator &integ,
+MFVectorConvectionNLIntegrator::MFVectorConvectionNLIntegrator(
+   const mfem::VectorConvectionNLFIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
+   mfem::Coefficient *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   NLConvectionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MFVectorConvectionNLFIntegrator::MFVectorConvectionNLFIntegrator(
-   const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::Coefficient *Q)
-   : MFIntegrator()
-{
-#ifdef MFEM_USE_CEED
-   NLConvectionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(info, fes, irm, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedMFVectorConvectionNLIntegrator::MixedMFVectorConvectionNLIntegrator(
-   const VectorConvectionNLFIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   NLConvectionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
+   NLConvectionOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, Q, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
diff --git a/fem/ceed/integrators/nlconvection/nlconvection.hpp b/fem/ceed/integrators/nlconvection/nlconvection.hpp
index 3efe88728..cf245322a 100644
--- a/fem/ceed/integrators/nlconvection/nlconvection.hpp
+++ b/fem/ceed/integrators/nlconvection/nlconvection.hpp
@@ -13,7 +13,7 @@
 #define MFEM_LIBCEED_NLCONV_HPP
 
 #include "../../interface/integrator.hpp"
-#include "../../interface/mixed_integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
 #include "../../../fespace.hpp"
 
 namespace mfem
@@ -24,40 +24,26 @@ namespace ceed
 
 /** Represent a VectorConvectionNLFIntegrator with AssemblyLevel::Partial
     using libCEED. */
-class PAVectorConvectionNLFIntegrator : public PAIntegrator
+class PAVectorConvectionNLIntegrator : public MixedOperator<Integrator>
 {
 public:
-   PAVectorConvectionNLFIntegrator(const mfem::FiniteElementSpace &fes,
-                                   const mfem::IntegrationRule &irm,
-                                   mfem::Coefficient *coeff);
-};
-
-class MixedPAVectorConvectionNLIntegrator : public MixedIntegrator<PAIntegrator>
-{
-public:
-   MixedPAVectorConvectionNLIntegrator(
-      const VectorConvectionNLFIntegrator &integ,
+   PAVectorConvectionNLIntegrator(
+      const mfem::VectorConvectionNLFIntegrator &integ,
       const mfem::FiniteElementSpace &fes,
-      mfem::Coefficient *Q);
+      mfem::Coefficient *Q,
+      const bool use_bdr = false);
 };
 
 /** Represent a VectorConvectionNLFIntegrator with AssemblyLevel::None
     using libCEED. */
-class MFVectorConvectionNLFIntegrator : public MFIntegrator
-{
-public:
-   MFVectorConvectionNLFIntegrator(const mfem::FiniteElementSpace &fes,
-                                   const mfem::IntegrationRule &irm,
-                                   mfem::Coefficient *coeff);
-};
-
-class MixedMFVectorConvectionNLIntegrator : public MixedIntegrator<MFIntegrator>
+class MFVectorConvectionNLIntegrator : public MixedOperator<Integrator>
 {
 public:
-   MixedMFVectorConvectionNLIntegrator(
-      const VectorConvectionNLFIntegrator &integ,
+   MFVectorConvectionNLIntegrator(
+      const mfem::VectorConvectionNLFIntegrator &integ,
       const mfem::FiniteElementSpace &fes,
-      mfem::Coefficient *Q);
+      mfem::Coefficient *Q,
+      const bool use_bdr = false);
 };
 
 }
diff --git a/fem/ceed/integrators/nlconvection/nlconvection_qf.h b/fem/ceed/integrators/nlconvection/nlconvection_qf.h
index ef0d41327..ee1782784 100644
--- a/fem/ceed/integrators/nlconvection/nlconvection_qf.h
+++ b/fem/ceed/integrators/nlconvection/nlconvection_qf.h
@@ -9,186 +9,155 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-/// A structure used to pass additional data to f_build_conv and f_apply_conv
-struct NLConvectionContext { CeedInt dim, space_dim, vdim; CeedScalar coeff; };
+#ifndef MFEM_LIBCEED_NLCONV_QF_H
+#define MFEM_LIBCEED_NLCONV_QF_H
 
-/// libCEED Q-function for building quadrature data for a convection operator
-/// with a constant coefficient
+#include "../util/util_qf.h"
+
+struct NLConvectionContext
+{
+   CeedInt dim, space_dim;
+   CeedScalar coeff;
+};
+
+/// libCEED QFunction for building quadrature data for a convection
+/// operator with a constant coefficient
 CEED_QFUNCTION(f_build_conv_const)(void *ctx, CeedInt Q,
                                    const CeedScalar *const *in,
                                    CeedScalar *const *out)
 {
-   NLConvectionContext *bc = (NLConvectionContext*)ctx;
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
+   NLConvectionContext *bc = (NLConvectionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[1] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute and store qw * adj(J).
+   // At every quadrature point, compute and store qw * c * adj(J)^T
    const CeedScalar coeff = bc->coeff;
    const CeedScalar *J = in[0], *qw = in[1];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            qd[i] = coeff * qw[i] * J[i];
+            MultAdjJt21(J + i, Q, qw[i] * coeff, Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 2   adj(J):  J22 -J12
-            //    1 3       1 3           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] * coeff;
-            qd[i + Q * 0] =  w * J22;
-            qd[i + Q * 1] = -w * J21;
-            qd[i + Q * 2] = -w * J12;
-            qd[i + Q * 3] =  w * J11;
+            MultAdjJt22(J + i, Q, qw[i] * coeff, Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJt32(J + i, Q, qw[i] * coeff, Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 3 6
-            //    1 4 7       1 4 7
-            //    2 5 8       2 5 8
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] * coeff;
-            qd[i + Q * 0] = w * A11;
-            qd[i + Q * 1] = w * A21;
-            qd[i + Q * 2] = w * A31;
-            qd[i + Q * 3] = w * A12;
-            qd[i + Q * 4] = w * A22;
-            qd[i + Q * 5] = w * A32;
-            qd[i + Q * 6] = w * A13;
-            qd[i + Q * 7] = w * A23;
-            qd[i + Q * 8] = w * A33;
+            MultAdjJt33(J + i, Q, qw[i] * coeff, Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for building quadrature data for a convection operator
-/// coefficient evaluated at quadrature points.
+/// libCEED QFunction for building quadrature data for a convection
+/// operator with a coefficient evaluated at quadrature points
 CEED_QFUNCTION(f_build_conv_quad)(void *ctx, CeedInt Q,
                                   const CeedScalar *const *in,
                                   CeedScalar *const *out)
 {
    NLConvectionContext *bc = (NLConvectionContext *)ctx;
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   // in[0] is coefficients, size (Q)
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute and store qw * adj(J).
+   // At every quadrature point, compute and store qw * c * adj(J)^T
    const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar coeff = c[i];
-            qd[i] = coeff * qw[i] * J[i];
+            MultAdjJt21(J + i, Q, qw[i] * c[i], Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 2   adj(J):  J22 -J12
-            //    1 3       1 3           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar coeff = c[i];
-            const CeedScalar w = qw[i] * coeff;
-            qd[i + Q * 0] =  w * J22;
-            qd[i + Q * 1] = -w * J21;
-            qd[i + Q * 2] = -w * J12;
-            qd[i + Q * 3] =  w * J11;
+            MultAdjJt22(J + i, Q, qw[i] * c[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJt32(J + i, Q, qw[i] * c[i], Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 3 6
-            //    1 4 7       1 4 7
-            //    2 5 8       2 5 8
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar coeff = c[i];
-            const CeedScalar w = qw[i] * coeff;
-            qd[i + Q * 0] = w * A11;
-            qd[i + Q * 1] = w * A21;
-            qd[i + Q * 2] = w * A31;
-            qd[i + Q * 3] = w * A12;
-            qd[i + Q * 4] = w * A22;
-            qd[i + Q * 5] = w * A32;
-            qd[i + Q * 6] = w * A13;
-            qd[i + Q * 7] = w * A23;
-            qd[i + Q * 8] = w * A33;
+            MultAdjJt33(J + i, Q, qw[i] * c[i], Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a conv operator
+/// libCEED QFunction for applying a convection operator
 CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
                              const CeedScalar *const *in,
                              CeedScalar *const *out)
 {
    NLConvectionContext *bc = (NLConvectionContext *)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
+   // in[0] has shape [ncomp=space_dim, Q]
+   // in[1] has shape [dim, ncomp=space_dim, Q]
+   // out[0] has shape [ncomp=space_dim, Q]
    const CeedScalar *u = in[0], *ug = in[1], *qd = in[2];
    CeedScalar *vg = out[0];
-   switch (10*bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            vg[i] = qd[i] * u[i] * ug[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            vg[i] = u[i] * ug[i] * qd[i];
+            const CeedScalar qd00 = qd[i + Q * 0];
+            const CeedScalar qd10 = qd[i + Q * 1];
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar Dxu0 = qd00 * ug00;
+            const CeedScalar Dyu0 = qd10 * ug00;
+            const CeedScalar Dxu1 = qd00 * ug10;
+            const CeedScalar Dyu1 = qd10 * ug10;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar qd00 = qd[i + Q * 0];
             const CeedScalar qd10 = qd[i + Q * 1];
@@ -200,16 +169,47 @@ CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
             const CeedScalar ug10 = ug[i + Q * 1];
             const CeedScalar ug01 = ug[i + Q * 2];
             const CeedScalar ug11 = ug[i + Q * 3];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11;
+            const CeedScalar Dxu0 = qd00 * ug00 + qd01 * ug01;
+            const CeedScalar Dyu0 = qd10 * ug00 + qd11 * ug01;
+            const CeedScalar Dxu1 = qd00 * ug10 + qd01 * ug11;
+            const CeedScalar Dyu1 = qd10 * ug10 + qd11 * ug11;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd00 = qd[i + Q * 0];
+            const CeedScalar qd10 = qd[i + Q * 1];
+            const CeedScalar qd20 = qd[i + Q * 2];
+            const CeedScalar qd01 = qd[i + Q * 3];
+            const CeedScalar qd11 = qd[i + Q * 4];
+            const CeedScalar qd21 = qd[i + Q * 5];
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar u2   = u[i + Q * 2];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar ug20 = ug[i + Q * 2];
+            const CeedScalar ug01 = ug[i + Q * 3];
+            const CeedScalar ug11 = ug[i + Q * 4];
+            const CeedScalar ug21 = ug[i + Q * 5];
+            const CeedScalar Dxu0 = qd00 * ug00 + qd01 * ug01;
+            const CeedScalar Dyu0 = qd10 * ug00 + qd11 * ug01;
+            const CeedScalar Dzu0 = qd20 * ug00 + qd21 * ug01;
+            const CeedScalar Dxu1 = qd00 * ug10 + qd01 * ug11;
+            const CeedScalar Dyu1 = qd10 * ug10 + qd11 * ug11;
+            const CeedScalar Dzu1 = qd20 * ug10 + qd21 * ug11;
+            const CeedScalar Dxu2 = qd00 * ug20 + qd01 * ug21;
+            const CeedScalar Dyu2 = qd10 * ug20 + qd11 * ug21;
+            const CeedScalar Dzu2 = qd20 * ug20 + qd21 * ug21;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
+            vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
+         }
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar qd00 = qd[i + Q * 0];
             const CeedScalar qd10 = qd[i + Q * 1];
@@ -232,15 +232,15 @@ CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
             const CeedScalar ug02 = ug[i + Q * 6];
             const CeedScalar ug12 = ug[i + Q * 7];
             const CeedScalar ug22 = ug[i + Q * 8];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10 + ug02 * qd20;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11 + ug02 * qd21;
-            const CeedScalar Dzu0 = ug00 * qd02 + ug01 * qd12 + ug02 * qd22;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10 + ug12 * qd20;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11 + ug12 * qd21;
-            const CeedScalar Dzu1 = ug10 * qd02 + ug11 * qd12 + ug12 * qd22;
-            const CeedScalar Dxu2 = ug20 * qd00 + ug21 * qd10 + ug22 * qd20;
-            const CeedScalar Dyu2 = ug20 * qd01 + ug21 * qd11 + ug22 * qd21;
-            const CeedScalar Dzu2 = ug20 * qd02 + ug21 * qd12 + ug22 * qd22;
+            const CeedScalar Dxu0 = qd00 * ug00 + qd01 * ug01 + qd02 * ug02;
+            const CeedScalar Dyu0 = qd10 * ug00 + qd11 * ug01 + qd12 * ug02;
+            const CeedScalar Dzu0 = qd20 * ug00 + qd21 * ug01 + qd22 * ug02;
+            const CeedScalar Dxu1 = qd00 * ug10 + qd01 * ug11 + qd02 * ug12;
+            const CeedScalar Dyu1 = qd10 * ug10 + qd11 * ug11 + qd12 * ug12;
+            const CeedScalar Dzu1 = qd20 * ug10 + qd21 * ug11 + qd22 * ug12;
+            const CeedScalar Dxu2 = qd00 * ug20 + qd01 * ug21 + qd02 * ug22;
+            const CeedScalar Dyu2 = qd10 * ug20 + qd11 * ug21 + qd12 * ug22;
+            const CeedScalar Dzu2 = qd20 * ug20 + qd21 * ug21 + qd22 * ug22;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
             vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
@@ -250,91 +250,101 @@ CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
    return 0;
 }
 
-/// libCEED Q-function for applying a conv operator
+/// libCEED QFunction for applying a convection operator with a constant
+/// coefficient
 CEED_QFUNCTION(f_apply_conv_mf_const)(void *ctx, CeedInt Q,
                                       const CeedScalar *const *in,
                                       CeedScalar *const *out)
 {
-   NLConvectionContext *bc = (NLConvectionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
-   // in[2] is quadrature weights, size (Q)
+   NLConvectionContext *bc = (NLConvectionContext *)ctx;
+   // in[0] has shape [ncomp=space_dim, Q]
+   // in[1] has shape [dim, ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   // out[0] has shape [ncomp=space_dim, Q]
    //
-   // At every quadrature point, compute qw * adj(J).
+   // At every quadrature point, compute qw * c * adj(J)^T
    const CeedScalar coeff = bc->coeff;
    const CeedScalar *u = in[0], *ug = in[1], *J = in[2], *qw = in[3];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * J[i];
+            vg[i] = u[i] * qd * ug[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = coeff * qw[i] * J[i];
-            vg[i] = u[i] * ug[i] * qd;
+            CeedScalar qd[2];
+            MultAdjJt21(J + i, Q, qw[i] * coeff, 1, qd);
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar Dxu0 = qd[0] * ug00;
+            const CeedScalar Dyu0 = qd[1] * ug00;
+            const CeedScalar Dxu1 = qd[0] * ug10;
+            const CeedScalar Dyu1 = qd[1] * ug10;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 2   adj(J):  J22 -J12
-            //    1 3       1 3           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] * coeff;
-            const CeedScalar qd00 =  w * J22;
-            const CeedScalar qd10 = -w * J21;
-            const CeedScalar qd01 = -w * J12;
-            const CeedScalar qd11 =  w * J11;
+            CeedScalar qd[4];
+            MultAdjJt22(J + i, Q, qw[i] * coeff, 1, qd);
             const CeedScalar u0   = u[i + Q * 0];
             const CeedScalar u1   = u[i + Q * 1];
             const CeedScalar ug00 = ug[i + Q * 0];
             const CeedScalar ug10 = ug[i + Q * 1];
             const CeedScalar ug01 = ug[i + Q * 2];
             const CeedScalar ug11 = ug[i + Q * 3];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11;
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[2] * ug01;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[3] * ug01;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[2] * ug11;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[3] * ug11;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJt32(J + i, Q, qw[i] * coeff, 1, qd);
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar u2   = u[i + Q * 2];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar ug20 = ug[i + Q * 2];
+            const CeedScalar ug01 = ug[i + Q * 3];
+            const CeedScalar ug11 = ug[i + Q * 4];
+            const CeedScalar ug21 = ug[i + Q * 5];
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[3] * ug01;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[4] * ug01;
+            const CeedScalar Dzu0 = qd[2] * ug00 + qd[5] * ug01;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[3] * ug11;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[4] * ug11;
+            const CeedScalar Dzu1 = qd[2] * ug10 + qd[5] * ug11;
+            const CeedScalar Dxu2 = qd[0] * ug20 + qd[3] * ug21;
+            const CeedScalar Dyu2 = qd[1] * ug20 + qd[4] * ug21;
+            const CeedScalar Dzu2 = qd[2] * ug20 + qd[5] * ug21;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
+            vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
+         }
+         break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 3 6
-            //    1 4 7       1 4 7
-            //    2 5 8       2 5 8
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] * coeff;
-            const CeedScalar qd00 = w * A11;
-            const CeedScalar qd10 = w * A21;
-            const CeedScalar qd20 = w * A31;
-            const CeedScalar qd01 = w * A12;
-            const CeedScalar qd11 = w * A22;
-            const CeedScalar qd21 = w * A32;
-            const CeedScalar qd02 = w * A13;
-            const CeedScalar qd12 = w * A23;
-            const CeedScalar qd22 = w * A33;
+            CeedScalar qd[9];
+            MultAdjJt33(J + i, Q, qw[i] * coeff, 1, qd);
             const CeedScalar u0   = u[i + Q * 0];
             const CeedScalar u1   = u[i + Q * 1];
             const CeedScalar u2   = u[i + Q * 2];
@@ -347,15 +357,15 @@ CEED_QFUNCTION(f_apply_conv_mf_const)(void *ctx, CeedInt Q,
             const CeedScalar ug02 = ug[i + Q * 6];
             const CeedScalar ug12 = ug[i + Q * 7];
             const CeedScalar ug22 = ug[i + Q * 8];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10 + ug02 * qd20;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11 + ug02 * qd21;
-            const CeedScalar Dzu0 = ug00 * qd02 + ug01 * qd12 + ug02 * qd22;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10 + ug12 * qd20;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11 + ug12 * qd21;
-            const CeedScalar Dzu1 = ug10 * qd02 + ug11 * qd12 + ug12 * qd22;
-            const CeedScalar Dxu2 = ug20 * qd00 + ug21 * qd10 + ug22 * qd20;
-            const CeedScalar Dyu2 = ug20 * qd01 + ug21 * qd11 + ug22 * qd21;
-            const CeedScalar Dzu2 = ug20 * qd02 + ug21 * qd12 + ug22 * qd22;
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[3] * ug01 + qd[6] * ug02;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[4] * ug01 + qd[7] * ug02;
+            const CeedScalar Dzu0 = qd[2] * ug00 + qd[5] * ug01 + qd[8] * ug02;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[3] * ug11 + qd[6] * ug12;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[4] * ug11 + qd[7] * ug12;
+            const CeedScalar Dzu1 = qd[2] * ug10 + qd[5] * ug11 + qd[8] * ug12;
+            const CeedScalar Dxu2 = qd[0] * ug20 + qd[3] * ug21 + qd[6] * ug22;
+            const CeedScalar Dyu2 = qd[1] * ug20 + qd[4] * ug21 + qd[7] * ug22;
+            const CeedScalar Dzu2 = qd[2] * ug20 + qd[5] * ug21 + qd[8] * ug22;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
             vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
@@ -365,89 +375,101 @@ CEED_QFUNCTION(f_apply_conv_mf_const)(void *ctx, CeedInt Q,
    return 0;
 }
 
+/// libCEED QFunction for applying a convection operator with a coefficient
+/// evaluated at quadrature points
 CEED_QFUNCTION(f_apply_conv_mf_quad)(void *ctx, CeedInt Q,
                                      const CeedScalar *const *in,
                                      CeedScalar *const *out)
 {
-   NLConvectionContext *bc = (NLConvectionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
-   // in[2] is quadrature weights, size (Q)
+   NLConvectionContext *bc = (NLConvectionContext *)ctx;
+   // in[0] has shape [ncomp=space_dim, Q]
+   // in[1] has shape [dim, ncomp=space_dim, Q]
+   // in[2] is coefficients, size (Q)
+   // in[3] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[4] is quadrature weights, size (Q)
+   // out[0] has shape [ncomp=space_dim, Q]
    //
-   // At every quadrature point, compute qw * adj(J).
-   const CeedScalar *c = in[0], *u = in[1], *ug = in[2], *J = in[3], *qw = in[4];
+   // At every quadrature point, compute qw * c * adj(J)^T
+   const CeedScalar *u = in[0], *ug = in[1], *c = in[2], *J = in[3], *qw = in[4];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = c[i] * qw[i] * J[i];
-            vg[i] = u[i] * ug[i] * qd;
+            const CeedScalar qd = qw[i] * c[i] * J[i];
+            vg[i] = u[i] * qd * ug[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[2];
+            MultAdjJt21(J + i, Q, qw[i] * c[i], 1, qd);
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar Dxu0 = qd[0] * ug00;
+            const CeedScalar Dyu0 = qd[1] * ug00;
+            const CeedScalar Dxu1 = qd[0] * ug10;
+            const CeedScalar Dyu1 = qd[1] * ug10;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 2   adj(J):  J22 -J12
-            //    1 3       1 3           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] * c[i];
-            const CeedScalar qd00 =  w * J22;
-            const CeedScalar qd10 = -w * J21;
-            const CeedScalar qd01 = -w * J12;
-            const CeedScalar qd11 =  w * J11;
+            CeedScalar qd[4];
+            MultAdjJt22(J + i, Q, qw[i] * c[i], 1, qd);
             const CeedScalar u0   = u[i + Q * 0];
             const CeedScalar u1   = u[i + Q * 1];
             const CeedScalar ug00 = ug[i + Q * 0];
             const CeedScalar ug10 = ug[i + Q * 1];
             const CeedScalar ug01 = ug[i + Q * 2];
             const CeedScalar ug11 = ug[i + Q * 3];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11;
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[2] * ug01;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[3] * ug01;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[2] * ug11;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[3] * ug11;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJt32(J + i, Q, qw[i] * c[i], 1, qd);
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar u2   = u[i + Q * 2];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar ug20 = ug[i + Q * 2];
+            const CeedScalar ug01 = ug[i + Q * 3];
+            const CeedScalar ug11 = ug[i + Q * 4];
+            const CeedScalar ug21 = ug[i + Q * 5];
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[3] * ug01;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[4] * ug01;
+            const CeedScalar Dzu0 = qd[2] * ug00 + qd[5] * ug01;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[3] * ug11;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[4] * ug11;
+            const CeedScalar Dzu1 = qd[2] * ug10 + qd[5] * ug11;
+            const CeedScalar Dxu2 = qd[0] * ug20 + qd[3] * ug21;
+            const CeedScalar Dyu2 = qd[1] * ug20 + qd[4] * ug21;
+            const CeedScalar Dzu2 = qd[2] * ug20 + qd[5] * ug21;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
+            vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
+         }
+         break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 3 6
-            //    1 4 7       1 4 7
-            //    2 5 8       2 5 8
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] * c[i];
-            const CeedScalar qd00 = w * A11;
-            const CeedScalar qd10 = w * A21;
-            const CeedScalar qd20 = w * A31;
-            const CeedScalar qd01 = w * A12;
-            const CeedScalar qd11 = w * A22;
-            const CeedScalar qd21 = w * A32;
-            const CeedScalar qd02 = w * A13;
-            const CeedScalar qd12 = w * A23;
-            const CeedScalar qd22 = w * A33;
+            CeedScalar qd[9];
+            MultAdjJt33(J + i, Q, qw[i] * c[i], 1, qd);
             const CeedScalar u0   = u[i + Q * 0];
             const CeedScalar u1   = u[i + Q * 1];
             const CeedScalar u2   = u[i + Q * 2];
@@ -460,15 +482,15 @@ CEED_QFUNCTION(f_apply_conv_mf_quad)(void *ctx, CeedInt Q,
             const CeedScalar ug02 = ug[i + Q * 6];
             const CeedScalar ug12 = ug[i + Q * 7];
             const CeedScalar ug22 = ug[i + Q * 8];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10 + ug02 * qd20;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11 + ug02 * qd21;
-            const CeedScalar Dzu0 = ug00 * qd02 + ug01 * qd12 + ug02 * qd22;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10 + ug12 * qd20;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11 + ug12 * qd21;
-            const CeedScalar Dzu1 = ug10 * qd02 + ug11 * qd12 + ug12 * qd22;
-            const CeedScalar Dxu2 = ug20 * qd00 + ug21 * qd10 + ug22 * qd20;
-            const CeedScalar Dyu2 = ug20 * qd01 + ug21 * qd11 + ug22 * qd21;
-            const CeedScalar Dzu2 = ug20 * qd02 + ug21 * qd12 + ug22 * qd22;
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[3] * ug01 + qd[6] * ug02;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[4] * ug01 + qd[7] * ug02;
+            const CeedScalar Dzu0 = qd[2] * ug00 + qd[5] * ug01 + qd[8] * ug02;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[3] * ug11 + qd[6] * ug12;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[4] * ug11 + qd[7] * ug12;
+            const CeedScalar Dzu1 = qd[2] * ug10 + qd[5] * ug11 + qd[8] * ug12;
+            const CeedScalar Dxu2 = qd[0] * ug20 + qd[3] * ug21 + qd[6] * ug22;
+            const CeedScalar Dyu2 = qd[1] * ug20 + qd[4] * ug21 + qd[7] * ug22;
+            const CeedScalar Dzu2 = qd[2] * ug20 + qd[5] * ug21 + qd[8] * ug22;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
             vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
@@ -477,3 +499,5 @@ CEED_QFUNCTION(f_apply_conv_mf_quad)(void *ctx, CeedInt Q,
    }
    return 0;
 }
+
+#endif // MFEM_LIBCEED_NLCONV_QF_H
diff --git a/fem/ceed/integrators/util/util_qf.h b/fem/ceed/integrators/util/util_qf.h
new file mode 100644
index 000000000..fa7ca763b
--- /dev/null
+++ b/fem/ceed/integrators/util/util_qf.h
@@ -0,0 +1,855 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_UTIL_QF_H
+#define MFEM_LIBCEED_UTIL_QF_H
+
+#include <math.h>
+
+CEED_QFUNCTION_HELPER CeedScalar DetJ22(const CeedScalar *J,
+                                        const CeedInt J_stride)
+{
+   // J: 0 2
+   //    1 3
+   return J[J_stride * 0] * J[J_stride * 3] -
+          J[J_stride * 1] * J[J_stride * 2];
+}
+
+CEED_QFUNCTION_HELPER CeedScalar DetJ21(const CeedScalar *J,
+                                        const CeedInt J_stride)
+{
+   // J: 0
+   //    1
+   return sqrt(J[J_stride * 0] * J[J_stride * 0] +
+               J[J_stride * 1] * J[J_stride * 1]);
+}
+
+CEED_QFUNCTION_HELPER CeedScalar DetJ33(const CeedScalar *J,
+                                        const CeedInt J_stride)
+{
+   // J: 0 3 6
+   //    1 4 7
+   //    2 5 8
+   return J[J_stride * 0] * (J[J_stride * 4] * J[J_stride * 8] -
+                             J[J_stride * 5] * J[J_stride * 7]) -
+          J[J_stride * 1] * (J[J_stride * 3] * J[J_stride * 8] -
+                             J[J_stride * 5] * J[J_stride * 6]) +
+          J[J_stride * 2] * (J[J_stride * 3] * J[J_stride * 7] -
+                             J[J_stride * 4] * J[J_stride * 6]);
+}
+
+CEED_QFUNCTION_HELPER CeedScalar DetJ32(const CeedScalar *J,
+                                        const CeedInt J_stride)
+{
+   // J: 0 3
+   //    1 4
+   //    2 5
+   const CeedScalar E = J[J_stride * 0] * J[J_stride * 0] +
+                        J[J_stride * 1] * J[J_stride * 1] +
+                        J[J_stride * 2] * J[J_stride * 2];
+   const CeedScalar G = J[J_stride * 3] * J[J_stride * 3] +
+                        J[J_stride * 4] * J[J_stride * 4] +
+                        J[J_stride * 5] * J[J_stride * 5];
+   const CeedScalar F = J[J_stride * 0] * J[J_stride * 3] +
+                        J[J_stride * 1] * J[J_stride * 4] +
+                        J[J_stride * 2] * J[J_stride * 5];
+   return sqrt(E * G - F * F);
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJCAdjJt22(const CeedScalar *J,
+                                            const CeedInt J_stride,
+                                            const CeedScalar *c,
+                                            const CeedInt c_stride,
+                                            const CeedInt c_comp,
+                                            const CeedScalar qw,
+                                            const CeedInt qd_stride,
+                                            CeedScalar *qd)
+{
+   // compute qw/det(J) adj(J) C adj(J)^T and store the symmetric part of the result
+   // J: 0 2   adj(J):  J22 -J12   qd: 0 1
+   //    1 3           -J21  J11       1 2
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J12 = J[J_stride * 2];
+   const CeedScalar J22 = J[J_stride * 3];
+   const CeedScalar w = qw / (J11 * J22 - J21 * J12);
+   if (c_comp == 3)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0 1
+      //    1 2
+      const CeedScalar R11 =  c[c_stride * 0] * J22 - c[c_stride * 1] * J12;
+      const CeedScalar R21 =  c[c_stride * 1] * J22 - c[c_stride * 2] * J12;
+      const CeedScalar R12 = -c[c_stride * 0] * J21 + c[c_stride * 1] * J11;
+      const CeedScalar R22 = -c[c_stride * 1] * J21 + c[c_stride * 2] * J11;
+      qd[qd_stride * 0] = w * (J22 * R11 - J12 * R21);
+      qd[qd_stride * 1] = w * (J11 * R21 - J21 * R11);
+      qd[qd_stride * 2] = w * (J11 * R22 - J21 * R12);
+   }
+   else if (c_comp == 2)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      qd[qd_stride * 0] =  w * (c[c_stride * 1] * J12 * J12 +
+                                c[c_stride * 0] * J22 * J22);
+      qd[qd_stride * 1] = -w * (c[c_stride * 1] * J11 * J12 +
+                                c[c_stride * 0] * J21 * J22);
+      qd[qd_stride * 2] =  w * (c[c_stride * 1] * J11 * J11 +
+                                c[c_stride * 0] * J21 * J21);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] =  w * c[c_stride * 0] * (J12 * J12 + J22 * J22);
+      qd[qd_stride * 1] = -w * c[c_stride * 0] * (J11 * J12 + J21 * J22);
+      qd[qd_stride * 2] =  w * c[c_stride * 0] * (J11 * J11 + J21 * J21);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJCAdjJt21(const CeedScalar *J,
+                                            const CeedInt J_stride,
+                                            const CeedScalar *c,
+                                            const CeedInt c_stride,
+                                            const CeedInt c_comp,
+                                            const CeedScalar qw,
+                                            const CeedInt qd_stride,
+                                            CeedScalar *qd)
+{
+   // compute qw/det(J) adj(J) C adj(J)^T and store the symmetric part of the result
+   // J: 0   adj(J): 1/sqrt(J^T J) J^T   qd: 0
+   //    1
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar d = J11 * J11 + J21 * J21;
+   const CeedScalar w = qw / sqrt(d);
+   if (c_comp == 3)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0 1
+      //    1 2
+      const CeedScalar R11 = c[c_stride * 0] * J11 + c[c_stride * 1] * J21;
+      const CeedScalar R21 = c[c_stride * 1] * J11 + c[c_stride * 2] * J21;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21) / d;
+   }
+   else if (c_comp == 2)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21) / d;
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] = w * c[c_stride * 0];
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJCAdjJt33(const CeedScalar *J,
+                                            const CeedInt J_stride,
+                                            const CeedScalar *c,
+                                            const CeedInt c_stride,
+                                            const CeedInt c_comp,
+                                            const CeedScalar qw,
+                                            const CeedInt qd_stride,
+                                            CeedScalar *qd)
+{
+   // compute qw/det(J) adj(J) C adj(J)^T and store the symmetric part of the result
+   // J: 0 3 6   qd: 0 1 2
+   //    1 4 7       1 3 4
+   //    2 5 8       2 4 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar J13 = J[J_stride * 6];
+   const CeedScalar J23 = J[J_stride * 7];
+   const CeedScalar J33 = J[J_stride * 8];
+   const CeedScalar A11 = J22 * J33 - J23 * J32;
+   const CeedScalar A12 = J13 * J32 - J12 * J33;
+   const CeedScalar A13 = J12 * J23 - J13 * J22;
+   const CeedScalar A21 = J23 * J31 - J21 * J33;
+   const CeedScalar A22 = J11 * J33 - J13 * J31;
+   const CeedScalar A23 = J13 * J21 - J11 * J23;
+   const CeedScalar A31 = J21 * J32 - J22 * J31;
+   const CeedScalar A32 = J12 * J31 - J11 * J32;
+   const CeedScalar A33 = J11 * J22 - J12 * J21;
+   const CeedScalar w = qw / (J11 * A11 + J21 * A12 + J31 * A13);
+   if (c_comp == 6)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0 1 2
+      //    1 3 4
+      //    2 4 5
+      const CeedScalar R11 = c[c_stride * 0] * A11 +
+                             c[c_stride * 1] * A12 +
+                             c[c_stride * 2] * A13;
+      const CeedScalar R12 = c[c_stride * 0] * A21 +
+                             c[c_stride * 1] * A22 +
+                             c[c_stride * 2] * A23;
+      const CeedScalar R13 = c[c_stride * 0] * A31 +
+                             c[c_stride * 1] * A32 +
+                             c[c_stride * 2] * A33;
+      const CeedScalar R21 = c[c_stride * 1] * A11 +
+                             c[c_stride * 3] * A12 +
+                             c[c_stride * 4] * A13;
+      const CeedScalar R22 = c[c_stride * 1] * A21 +
+                             c[c_stride * 3] * A22 +
+                             c[c_stride * 4] * A23;
+      const CeedScalar R23 = c[c_stride * 1] * A31 +
+                             c[c_stride * 3] * A32 +
+                             c[c_stride * 4] * A33;
+      const CeedScalar R31 = c[c_stride * 2] * A11 +
+                             c[c_stride * 4] * A12 +
+                             c[c_stride * 5] * A13;
+      const CeedScalar R32 = c[c_stride * 2] * A21 +
+                             c[c_stride * 4] * A22 +
+                             c[c_stride * 5] * A23;
+      const CeedScalar R33 = c[c_stride * 2] * A31 +
+                             c[c_stride * 4] * A32 +
+                             c[c_stride * 5] * A33;
+      qd[qd_stride * 0] = w * (A11 * R11 + A12 * R21 + A13 * R31);
+      qd[qd_stride * 1] = w * (A11 * R12 + A12 * R22 + A13 * R32);
+      qd[qd_stride * 2] = w * (A11 * R13 + A12 * R23 + A13 * R33);
+      qd[qd_stride * 3] = w * (A21 * R12 + A22 * R22 + A23 * R32);
+      qd[qd_stride * 4] = w * (A21 * R13 + A22 * R23 + A23 * R33);
+      qd[qd_stride * 5] = w * (A31 * R13 + A32 * R23 + A33 * R33);
+   }
+   else if (c_comp == 3)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      //        2
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * A11 * A11 +
+                               c[c_stride * 1] * A12 * A12 +
+                               c[c_stride * 2] * A13 * A13);
+      qd[qd_stride * 1] = w * (c[c_stride * 0] * A11 * A21 +
+                               c[c_stride * 1] * A12 * A22 +
+                               c[c_stride * 2] * A13 * A23);
+      qd[qd_stride * 2] = w * (c[c_stride * 0] * A11 * A31 +
+                               c[c_stride * 1] * A12 * A32 +
+                               c[c_stride * 2] * A13 * A33);
+      qd[qd_stride * 3] = w * (c[c_stride * 0] * A21 * A21 +
+                               c[c_stride * 1] * A22 * A22 +
+                               c[c_stride * 2] * A23 * A23);
+      qd[qd_stride * 4] = w * (c[c_stride * 0] * A21 * A31 +
+                               c[c_stride * 1] * A22 * A32 +
+                               c[c_stride * 2] * A23 * A33);
+      qd[qd_stride * 5] = w * (c[c_stride * 0] * A31 * A31 +
+                               c[c_stride * 1] * A32 * A32 +
+                               c[c_stride * 2] * A33 * A33);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] =
+         w * c[c_stride * 0] * (A11 * A11 + A12 * A12 + A13 * A13);
+      qd[qd_stride * 1] =
+         w * c[c_stride * 0] * (A11 * A21 + A12 * A22 + A13 * A23);
+      qd[qd_stride * 2] =
+         w * c[c_stride * 0] * (A11 * A31 + A12 * A32 + A13 * A33);
+      qd[qd_stride * 3] =
+         w * c[c_stride * 0] * (A21 * A21 + A22 * A22 + A23 * A23);
+      qd[qd_stride * 4] =
+         w * c[c_stride * 0] * (A21 * A31 + A22 * A32 + A23 * A33);
+      qd[qd_stride * 5] =
+         w * c[c_stride * 0] * (A31 * A31 + A32 * A32 + A33 * A33);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJCAdjJt32(const CeedScalar *J,
+                                            const CeedInt J_stride,
+                                            const CeedScalar *c,
+                                            const CeedInt c_stride,
+                                            const CeedInt c_comp,
+                                            const CeedScalar qw,
+                                            const CeedInt qd_stride,
+                                            CeedScalar *qd)
+{
+   // compute qw/det(J) adj(J) C adj(J)^T and store the symmetric part of the result
+   // J: 0 3   qd: 0 1
+   //    1 4       1 2
+   //    2 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar E = J11 * J11 + J21 * J21 + J31 * J31;
+   const CeedScalar G = J12 * J12 + J22 * J22 + J32 * J32;
+   const CeedScalar F = J11 * J12 + J21 * J22 + J31 * J32;
+   const CeedScalar d = E * G - F * F;
+   const CeedScalar w = qw / sqrt(d);
+   if (c_comp == 6)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0 1 2
+      //    1 3 4
+      //    2 4 5
+      const CeedScalar R11 = G * (c[c_stride * 0] * J11 +
+                                  c[c_stride * 1] * J21 +
+                                  c[c_stride * 2] * J31) -
+                             F * (c[c_stride * 0] * J12 +
+                                  c[c_stride * 1] * J22 +
+                                  c[c_stride * 2] * J32);
+      const CeedScalar R21 = G * (c[c_stride * 1] * J11 +
+                                  c[c_stride * 3] * J21 +
+                                  c[c_stride * 4] * J31) -
+                             F * (c[c_stride * 1] * J12 +
+                                  c[c_stride * 3] * J22 +
+                                  c[c_stride * 4] * J32);
+      const CeedScalar R31 = G * (c[c_stride * 2] * J11 +
+                                  c[c_stride * 4] * J21 +
+                                  c[c_stride * 5] * J31) -
+                             F * (c[c_stride * 2] * J12 +
+                                  c[c_stride * 4] * J22 +
+                                  c[c_stride * 5] * J32);
+      const CeedScalar R12 = E * (c[c_stride * 0] * J12 +
+                                  c[c_stride * 1] * J22 +
+                                  c[c_stride * 2] * J32) -
+                             F * (c[c_stride * 0] * J11 +
+                                  c[c_stride * 1] * J21 +
+                                  c[c_stride * 2] * J31);
+      const CeedScalar R22 = E * (c[c_stride * 1] * J12 +
+                                  c[c_stride * 3] * J22 +
+                                  c[c_stride * 4] * J32) -
+                             F * (c[c_stride * 1] * J11 +
+                                  c[c_stride * 3] * J21 +
+                                  c[c_stride * 4] * J31);
+      const CeedScalar R32 = E * (c[c_stride * 2] * J12 +
+                                  c[c_stride * 4] * J22 +
+                                  c[c_stride * 5] * J32) -
+                             F * (c[c_stride * 2] * J11 +
+                                  c[c_stride * 4] * J21 +
+                                  c[c_stride * 5] * J31);
+      qd[qd_stride * 0] = w * (G * (J11 * R11 + J21 * R21 + J31 * R31) -
+                               F * (J12 * R11 + J22 * R21 + J32 * R31)) / d;
+      qd[qd_stride * 1] = w * (G * (J11 * R12 + J21 * R22 + J31 * R32) -
+                               F * (J12 * R12 + J22 * R22 + J32 * R32)) / d;
+      qd[qd_stride * 2] = w * (E * (J12 * R12 + J22 * R22 + J32 * R32) -
+                               F * (J11 * R12 + J21 * R22 + J31 * R32)) / d;
+   }
+   else if (c_comp == 3)  // Vector coefficient
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0
+      //      1
+      //        2
+      const CeedScalar R11 = c[c_stride * 0] * (G * J11 - F * J12);
+      const CeedScalar R21 = c[c_stride * 1] * (G * J21 - F * J22);
+      const CeedScalar R31 = c[c_stride * 2] * (G * J31 - F * J32);
+      const CeedScalar R12 = c[c_stride * 0] * (E * J12 - F * J11);
+      const CeedScalar R22 = c[c_stride * 1] * (E * J22 - F * J21);
+      const CeedScalar R32 = c[c_stride * 2] * (E * J32 - F * J31);
+      qd[qd_stride * 0] = w * (G * (J11 * R11 + J21 * R21 + J31 * R31) -
+                               F * (J12 * R11 + J22 * R21 + J32 * R31)) / d;
+      qd[qd_stride * 1] = w * (G * (J11 * R12 + J21 * R22 + J31 * R32) -
+                               F * (J12 * R12 + J22 * R22 + J32 * R32)) / d;
+      qd[qd_stride * 2] = w * (E * (J12 * R12 + J22 * R22 + J32 * R32) -
+                               F * (J11 * R12 + J21 * R22 + J31 * R32)) / d;
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] =  w * c[c_stride * 0] * G;
+      qd[qd_stride * 1] = -w * c[c_stride * 0] * F;
+      qd[qd_stride * 2] =  w * c[c_stride * 0] * E;
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultJtCJ22(const CeedScalar *J,
+                                      const CeedInt J_stride,
+                                      const CeedScalar *c,
+                                      const CeedInt c_stride,
+                                      const CeedInt c_comp,
+                                      const CeedScalar qw,
+                                      const CeedInt qd_stride,
+                                      CeedScalar *qd)
+{
+   // compute qw/det(J) J^T C J and store the symmetric part of the result
+   // J: 0 2   qd: 0 1
+   //    1 3       1 2
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J12 = J[J_stride * 2];
+   const CeedScalar J22 = J[J_stride * 3];
+   const CeedScalar w = qw / (J11 * J22 - J21 * J12);
+   if (c_comp == 3)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C J
+      // c: 0 1
+      //    1 2
+      const CeedScalar R11 = c[c_stride * 0] * J11 + c[c_stride * 1] * J21;
+      const CeedScalar R21 = c[c_stride * 1] * J11 + c[c_stride * 2] * J21;
+      const CeedScalar R12 = c[c_stride * 0] * J12 + c[c_stride * 1] * J22;
+      const CeedScalar R22 = c[c_stride * 1] * J12 + c[c_stride * 2] * J22;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21);
+      qd[qd_stride * 1] = w * (J11 * R12 + J21 * R22);
+      qd[qd_stride * 2] = w * (J12 * R12 + J22 * R22);
+   }
+   else if (c_comp == 2)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21);
+      qd[qd_stride * 1] = w * (c[c_stride * 0] * J11 * J12 +
+                               c[c_stride * 1] * J21 * J22);
+      qd[qd_stride * 2] = w * (c[c_stride * 0] * J12 * J12 +
+                               c[c_stride * 1] * J22 * J22);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] = w * c[c_stride * 0] * (J11 * J11 + J21 * J21);
+      qd[qd_stride * 1] = w * c[c_stride * 0] * (J11 * J12 + J21 * J22);
+      qd[qd_stride * 2] = w * c[c_stride * 0] * (J12 * J12 + J22 * J22);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultJtCJ21(const CeedScalar *J,
+                                      const CeedInt J_stride,
+                                      const CeedScalar *c,
+                                      const CeedInt c_stride,
+                                      const CeedInt c_comp,
+                                      const CeedScalar qw,
+                                      const CeedInt qd_stride,
+                                      CeedScalar *qd)
+{
+   // compute qw/det(J) J^T C J and store the symmetric part of the result
+   // J: 0   qd: 0
+   //    1
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   if (c_comp == 3)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C J
+      // c: 0 1
+      //    1 2
+      const CeedScalar w = qw / sqrt(J11 * J11 + J21 * J21);
+      const CeedScalar R11 = c[c_stride * 0] * J11 + c[c_stride * 1] * J21;
+      const CeedScalar R21 = c[c_stride * 1] * J11 + c[c_stride * 2] * J21;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21);
+   }
+   else if (c_comp == 2)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      const CeedScalar w = qw / sqrt(J11 * J11 + J21 * J21);
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] = qw * c[c_stride * 0] * sqrt(J11 * J11 + J21 * J21);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultJtCJ33(const CeedScalar *J,
+                                      const CeedInt J_stride,
+                                      const CeedScalar *c,
+                                      const CeedInt c_stride,
+                                      const CeedInt c_comp,
+                                      const CeedScalar qw,
+                                      const CeedInt qd_stride,
+                                      CeedScalar *qd)
+{
+   // compute qw/det(J) J^T C J and store the symmetric part of the result
+   // J: 0 3 6   qd: 0 1 2
+   //    1 4 7       1 3 4
+   //    2 5 8       2 4 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar J13 = J[J_stride * 6];
+   const CeedScalar J23 = J[J_stride * 7];
+   const CeedScalar J33 = J[J_stride * 8];
+   const CeedScalar w = qw / (J11 * (J22 * J33 - J23 * J32) +
+                              J21 * (J13 * J32 - J12 * J33) +
+                              J31 * (J12 * J23 - J13 * J22));
+   if (c_comp == 6)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C J
+      // c: 0 1 2
+      //    1 3 4
+      //    2 4 5
+      const CeedScalar R11 = c[c_stride * 0] * J11 +
+                             c[c_stride * 1] * J21 +
+                             c[c_stride * 2] * J31;
+      const CeedScalar R12 = c[c_stride * 0] * J12 +
+                             c[c_stride * 1] * J22 +
+                             c[c_stride * 2] * J32;
+      const CeedScalar R13 = c[c_stride * 0] * J13 +
+                             c[c_stride * 1] * J23 +
+                             c[c_stride * 2] * J33;
+      const CeedScalar R21 = c[c_stride * 1] * J11 +
+                             c[c_stride * 3] * J21 +
+                             c[c_stride * 4] * J31;
+      const CeedScalar R22 = c[c_stride * 1] * J12 +
+                             c[c_stride * 3] * J22 +
+                             c[c_stride * 4] * J32;
+      const CeedScalar R23 = c[c_stride * 1] * J13 +
+                             c[c_stride * 3] * J23 +
+                             c[c_stride * 4] * J33;
+      const CeedScalar R31 = c[c_stride * 2] * J11 +
+                             c[c_stride * 4] * J21 +
+                             c[c_stride * 5] * J31;
+      const CeedScalar R32 = c[c_stride * 2] * J12 +
+                             c[c_stride * 4] * J22 +
+                             c[c_stride * 5] * J32;
+      const CeedScalar R33 = c[c_stride * 2] * J13 +
+                             c[c_stride * 4] * J23 +
+                             c[c_stride * 5] * J33;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21 + J31 * R31);
+      qd[qd_stride * 1] = w * (J11 * R12 + J21 * R22 + J31 * R32);
+      qd[qd_stride * 2] = w * (J11 * R13 + J21 * R23 + J31 * R33);
+      qd[qd_stride * 3] = w * (J12 * R12 + J22 * R22 + J32 * R32);
+      qd[qd_stride * 4] = w * (J12 * R13 + J22 * R23 + J32 * R33);
+      qd[qd_stride * 5] = w * (J13 * R13 + J23 * R23 + J33 * R33);
+   }
+   else if (c_comp == 3)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      //        2
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21 +
+                               c[c_stride * 2] * J31 * J31);
+      qd[qd_stride * 1] = w * (c[c_stride * 0] * J11 * J12 +
+                               c[c_stride * 1] * J21 * J22 +
+                               c[c_stride * 2] * J31 * J32);
+      qd[qd_stride * 2] = w * (c[c_stride * 0] * J11 * J13 +
+                               c[c_stride * 1] * J21 * J23 +
+                               c[c_stride * 2] * J31 * J33);
+      qd[qd_stride * 3] = w * (c[c_stride * 0] * J12 * J12 +
+                               c[c_stride * 1] * J22 * J22 +
+                               c[c_stride * 2] * J32 * J32);
+      qd[qd_stride * 4] = w * (c[c_stride * 0] * J12 * J13 +
+                               c[c_stride * 1] * J22 * J23 +
+                               c[c_stride * 2] * J32 * J33);
+      qd[qd_stride * 5] = w * (c[c_stride * 0] * J13 * J13 +
+                               c[c_stride * 1] * J23 * J23 +
+                               c[c_stride * 2] * J33 * J33);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] =
+         w * c[c_stride * 0] * (J11 * J11 + J21 * J21 + J31 * J31);
+      qd[qd_stride * 1] =
+         w * c[c_stride * 0] * (J11 * J12 + J21 * J22 + J31 * J32);
+      qd[qd_stride * 2] =
+         w * c[c_stride * 0] * (J11 * J13 + J21 * J23 + J31 * J33);
+      qd[qd_stride * 3] =
+         w * c[c_stride * 0] * (J12 * J12 + J22 * J22 + J32 * J32);
+      qd[qd_stride * 4] =
+         w * c[c_stride * 0] * (J12 * J13 + J22 * J23 + J32 * J33);
+      qd[qd_stride * 5] =
+         w * c[c_stride * 0] * (J13 * J13 + J23 * J23 + J33 * J33);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultJtCJ32(const CeedScalar *J,
+                                      const CeedInt J_stride,
+                                      const CeedScalar *c,
+                                      const CeedInt c_stride,
+                                      const CeedInt c_comp,
+                                      const CeedScalar qw,
+                                      const CeedInt qd_stride,
+                                      CeedScalar *qd)
+{
+   // compute qw/det(J) J^T C J and store the symmetric part of the result
+   // J: 0 3   qd: 0 1
+   //    1 4       1 2
+   //    2 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar E = J11 * J11 + J21 * J21 + J31 * J31;
+   const CeedScalar G = J12 * J12 + J22 * J22 + J32 * J32;
+   const CeedScalar F = J11 * J12 + J21 * J22 + J31 * J32;
+   const CeedScalar w = qw / sqrt(E * G - F * F);
+   if (c_comp == 6)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C J
+      // c: 0 1 2
+      //    1 3 4
+      //    2 4 5
+      const CeedScalar R11 = c[c_stride * 0] * J11 +
+                             c[c_stride * 1] * J21 +
+                             c[c_stride * 2] * J31;
+      const CeedScalar R21 = c[c_stride * 1] * J11 +
+                             c[c_stride * 3] * J21 +
+                             c[c_stride * 4] * J31;
+      const CeedScalar R31 = c[c_stride * 2] * J11 +
+                             c[c_stride * 4] * J21 +
+                             c[c_stride * 5] * J31;
+      const CeedScalar R12 = c[c_stride * 0] * J12 +
+                             c[c_stride * 1] * J22 +
+                             c[c_stride * 2] * J32;
+      const CeedScalar R22 = c[c_stride * 1] * J12 +
+                             c[c_stride * 3] * J22 +
+                             c[c_stride * 4] * J32;
+      const CeedScalar R32 = c[c_stride * 2] * J12 +
+                             c[c_stride * 4] * J22 +
+                             c[c_stride * 5] * J32;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21 + J31 * R31);
+      qd[qd_stride * 1] = w * (J11 * R12 + J21 * R22 + J31 * R32);
+      qd[qd_stride * 2] = w * (J12 * R12 + J22 * R22 + J32 * R32);
+   }
+   else if (c_comp == 3)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      //        2
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21 +
+                               c[c_stride * 2] * J31 * J31);
+      qd[qd_stride * 1] = w * (c[c_stride * 0] * J11 * J12 +
+                               c[c_stride * 1] * J21 * J22 +
+                               c[c_stride * 2] * J31 * J32);
+      qd[qd_stride * 2] = w * (c[c_stride * 0] * J12 * J12 +
+                               c[c_stride * 1] * J22 * J22 +
+                               c[c_stride * 2] * J32 * J32);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] = w * c[c_stride * 0] * E;
+      qd[qd_stride * 1] = w * c[c_stride * 0] * F;
+      qd[qd_stride * 2] = w * c[c_stride * 0] * G;
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultCtAdjJt22(const CeedScalar *J,
+                                         const CeedInt J_stride,
+                                         const CeedScalar *c,
+                                         const CeedInt c_stride,
+                                         const CeedScalar qw,
+                                         const CeedInt qd_stride,
+                                         CeedScalar *qd)
+{
+   // compute qw c^T adj(J)^T and store the result vector
+   // J: 0 2   adj(J):  J22 -J12
+   //    1 3           -J21  J11
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J12 = J[J_stride * 2];
+   const CeedScalar J22 = J[J_stride * 3];
+   const CeedScalar w1 = qw * c[c_stride * 0];
+   const CeedScalar w2 = qw * c[c_stride * 1];
+   qd[qd_stride * 0] =  w1 * J22 - w2 * J12;
+   qd[qd_stride * 1] = -w1 * J21 + w2 * J11;
+}
+
+CEED_QFUNCTION_HELPER void MultCtAdjJt21(const CeedScalar *J,
+                                         const CeedInt J_stride,
+                                         const CeedScalar *c,
+                                         const CeedInt c_stride,
+                                         const CeedScalar qw,
+                                         const CeedInt qd_stride,
+                                         CeedScalar *qd)
+{
+   // compute qw c^T adj(J)^T and store the result vector
+   // J: 0   adj(J): 1/sqrt(J^T J) J^T
+   //    1
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar w = qw / sqrt(J11 * J11 + J21 * J21);
+   const CeedScalar w1 = w * c[c_stride * 0];
+   const CeedScalar w2 = w * c[c_stride * 1];
+   qd[qd_stride * 0] =  w1 * J11 + w2 * J21;
+}
+
+CEED_QFUNCTION_HELPER void MultCtAdjJt33(const CeedScalar *J,
+                                         const CeedInt J_stride,
+                                         const CeedScalar *c,
+                                         const CeedInt c_stride,
+                                         const CeedScalar qw,
+                                         const CeedInt qd_stride,
+                                         CeedScalar *qd)
+{
+   // compute qw c^T adj(J)^T and store the result vector
+   // J: 0 3 6
+   //    1 4 7
+   //    2 5 8
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar J13 = J[J_stride * 6];
+   const CeedScalar J23 = J[J_stride * 7];
+   const CeedScalar J33 = J[J_stride * 8];
+   const CeedScalar A11 = J22 * J33 - J23 * J32;
+   const CeedScalar A12 = J13 * J32 - J12 * J33;
+   const CeedScalar A13 = J12 * J23 - J13 * J22;
+   const CeedScalar A21 = J23 * J31 - J21 * J33;
+   const CeedScalar A22 = J11 * J33 - J13 * J31;
+   const CeedScalar A23 = J13 * J21 - J11 * J23;
+   const CeedScalar A31 = J21 * J32 - J22 * J31;
+   const CeedScalar A32 = J12 * J31 - J11 * J32;
+   const CeedScalar A33 = J11 * J22 - J12 * J21;
+   const CeedScalar w1 = qw * c[c_stride * 0];
+   const CeedScalar w2 = qw * c[c_stride * 1];
+   const CeedScalar w3 = qw * c[c_stride * 2];
+   qd[qd_stride * 0] = w1 * A11 + w2 * A12 + w3 * A13;
+   qd[qd_stride * 1] = w1 * A21 + w2 * A22 + w3 * A23;
+   qd[qd_stride * 2] = w1 * A31 + w2 * A32 + w3 * A33;
+}
+
+CEED_QFUNCTION_HELPER void MultCtAdjJt32(const CeedScalar *J,
+                                         const CeedInt J_stride,
+                                         const CeedScalar *c,
+                                         const CeedInt c_stride,
+                                         const CeedScalar qw,
+                                         const CeedInt qd_stride,
+                                         CeedScalar *qd)
+{
+   // compute qw c^T adj(J)^T and store the result vector
+   // J: 0 3
+   //    1 4
+   //    2 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar E = J11 * J11 + J21 * J21 + J31 * J31;
+   const CeedScalar G = J12 * J12 + J22 * J22 + J32 * J32;
+   const CeedScalar F = J11 * J12 + J21 * J22 + J31 * J32;
+   const CeedScalar A11 = G * J11 - F * J12;
+   const CeedScalar A21 = E * J12 - F * J11;
+   const CeedScalar A12 = G * J21 - F * J22;
+   const CeedScalar A22 = E * J22 - F * J21;
+   const CeedScalar A13 = G * J31 - F * J32;
+   const CeedScalar A23 = E * J32 - F * J31;
+   const CeedScalar w = qw / sqrt(E * G - F * F);
+   const CeedScalar w1 = w * c[c_stride * 0];
+   const CeedScalar w2 = w * c[c_stride * 1];
+   const CeedScalar w3 = w * c[c_stride * 2];
+   qd[qd_stride * 0] = w1 * A11 + w2 * A12 + w3 * A13;
+   qd[qd_stride * 1] = w1 * A21 + w2 * A22 + w3 * A23;
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJt22(const CeedScalar *J,
+                                       const CeedInt J_stride,
+                                       const CeedScalar qw,
+                                       const CeedInt qd_stride,
+                                       CeedScalar *qd)
+{
+   // compute qw adj(J)^T and store the result matrix
+   // J: 0 2   adj(J):  J22 -J12   qd: 0 2
+   //    1 3           -J21  J11       1 3
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J12 = J[J_stride * 2];
+   const CeedScalar J22 = J[J_stride * 3];
+   qd[qd_stride * 0] =  qw * J22;
+   qd[qd_stride * 1] = -qw * J12;
+   qd[qd_stride * 2] = -qw * J21;
+   qd[qd_stride * 3] =  qw * J11;
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJt21(const CeedScalar *J,
+                                       const CeedInt J_stride,
+                                       const CeedScalar qw,
+                                       const CeedInt qd_stride,
+                                       CeedScalar *qd)
+{
+   // compute qw adj(J)^T and store the result matrix
+   // J: 0   adj(J):  1/sqrt(J^T J) J^T   qd: 0
+   //    1                                    1
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar w = qw / sqrt(J11 * J11 + J21 * J21);
+   qd[qd_stride * 0] = w * J11;
+   qd[qd_stride * 1] = w * J21;
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJt33(const CeedScalar *J,
+                                       const CeedInt J_stride,
+                                       const CeedScalar qw,
+                                       const CeedInt qd_stride,
+                                       CeedScalar *qd)
+{
+   // compute qw adj(J)^T and store the result matrix
+   // J: 0 3 6   qd: 0 3 6
+   //    1 4 7       1 4 7
+   //    2 5 8       2 5 8
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar J13 = J[J_stride * 6];
+   const CeedScalar J23 = J[J_stride * 7];
+   const CeedScalar J33 = J[J_stride * 8];
+   const CeedScalar A11 = J22 * J33 - J23 * J32;
+   const CeedScalar A12 = J13 * J32 - J12 * J33;
+   const CeedScalar A13 = J12 * J23 - J13 * J22;
+   const CeedScalar A21 = J23 * J31 - J21 * J33;
+   const CeedScalar A22 = J11 * J33 - J13 * J31;
+   const CeedScalar A23 = J13 * J21 - J11 * J23;
+   const CeedScalar A31 = J21 * J32 - J22 * J31;
+   const CeedScalar A32 = J12 * J31 - J11 * J32;
+   const CeedScalar A33 = J11 * J22 - J12 * J21;
+   qd[qd_stride * 0] = qw * A11;
+   qd[qd_stride * 1] = qw * A12;
+   qd[qd_stride * 2] = qw * A13;
+   qd[qd_stride * 3] = qw * A21;
+   qd[qd_stride * 4] = qw * A22;
+   qd[qd_stride * 5] = qw * A23;
+   qd[qd_stride * 6] = qw * A31;
+   qd[qd_stride * 7] = qw * A32;
+   qd[qd_stride * 8] = qw * A33;
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJt32(const CeedScalar *J,
+                                       const CeedInt J_stride,
+                                       const CeedScalar qw,
+                                       const CeedInt qd_stride,
+                                       CeedScalar *qd)
+{
+   // compute qw adj(J)^T and store the result matrix
+   // J: 0 3   qd: 0 3
+   //    1 4       1 4
+   //    2 5       2 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar E = J11 * J11 + J21 * J21 + J31 * J31;
+   const CeedScalar G = J12 * J12 + J22 * J22 + J32 * J32;
+   const CeedScalar F = J11 * J12 + J21 * J22 + J31 * J32;
+   const CeedScalar A11 = G * J11 - F * J12;
+   const CeedScalar A21 = E * J12 - F * J11;
+   const CeedScalar A12 = G * J21 - F * J22;
+   const CeedScalar A22 = E * J22 - F * J21;
+   const CeedScalar A13 = G * J31 - F * J32;
+   const CeedScalar A23 = E * J32 - F * J31;
+   const CeedScalar w = qw / sqrt(E * G - F * F);
+   qd[qd_stride * 0] = w * A11;
+   qd[qd_stride * 1] = w * A12;
+   qd[qd_stride * 2] = w * A13;
+   qd[qd_stride * 3] = w * A21;
+   qd[qd_stride * 4] = w * A22;
+   qd[qd_stride * 5] = w * A23;
+}
+
+#endif // MFEM_LIBCEED_UTIL_QF_H
diff --git a/fem/ceed/integrators/vecfemass/vecfemass.cpp b/fem/ceed/integrators/vecfemass/vecfemass.cpp
new file mode 100644
index 000000000..87d624eb6
--- /dev/null
+++ b/fem/ceed/integrators/vecfemass/vecfemass.cpp
@@ -0,0 +1,274 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "vecfemass.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "vecfemass_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct VectorFEMassOperatorInfo : public OperatorInfo
+{
+   VectorFEMassContext ctx = {0};
+   template <typename CoeffType>
+   VectorFEMassOperatorInfo(const mfem::FiniteElementSpace &fes, CoeffType *Q,
+                            bool use_bdr = false, bool use_mf = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      bool is_hdiv = (fes.FEColl()->GetMapType(ctx.dim) ==
+                      mfem::FiniteElement::H_DIV);
+      MFEM_VERIFY(is_hdiv ||
+                  fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_CURL,
+                  "VectorFEMassIntegrator requires H(div) or H(curl) FE space!");
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_vecfemass";
+         apply_qf = &f_apply_vecfemass;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_const_scalar" :
+                         ":f_build_hcurlmass_const_scalar";
+            build_qf = is_hdiv ? &f_build_hdivmass_const_scalar :
+                       &f_build_hcurlmass_const_scalar;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_const_scalar" :
+                         ":f_apply_hcurlmass_mf_const_scalar";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_const_scalar :
+                       &f_apply_hcurlmass_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, is_hdiv, use_mf);
+      }
+      header = "/integrators/vecfemass/vecfemass_qf.h";
+      trial_op = EvalMode::Interp;
+      test_op = EvalMode::Interp;
+      qdatasize = (ctx.dim * (ctx.dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool is_hdiv, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_const_scalar" :
+                         ":f_build_hcurlmass_const_scalar";
+            build_qf = is_hdiv ? &f_build_hdivmass_const_scalar :
+                       &f_build_hcurlmass_const_scalar;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_const_scalar" :
+                         ":f_apply_hcurlmass_mf_const_scalar";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_const_scalar :
+                       &f_apply_hcurlmass_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_quad_scalar" :
+                         ":f_build_hcurlmass_quad_scalar";
+            build_qf = is_hdiv ? &f_build_hdivmass_quad_scalar :
+                       &f_build_hcurlmass_quad_scalar;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_quad_scalar" :
+                         ":f_apply_hcurlmass_mf_quad_scalar";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_quad_scalar :
+                       &f_apply_hcurlmass_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool is_hdiv, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_VECFEMASS_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_const_vector" :
+                         ":f_build_hcurlmass_const_vector";
+            build_qf = is_hdiv ? &f_build_hdivmass_const_vector :
+                       &f_build_hcurlmass_const_vector;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_const_vector" :
+                         ":f_apply_hcurlmass_mf_const_vector";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_const_vector :
+                       &f_apply_hcurlmass_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_quad_vector" :
+                         ":f_build_hcurlmass_quad_vector";
+            build_qf = is_hdiv ? &f_build_hdivmass_quad_vector :
+                       &f_build_hcurlmass_quad_vector;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_quad_vector" :
+                         ":f_apply_hcurlmass_mf_quad_vector";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_quad_vector :
+                       &f_apply_hcurlmass_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool is_hdiv, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_VECFEMASS_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_const_matrix" :
+                         ":f_build_hcurlmass_const_matrix";
+            build_qf = is_hdiv ? &f_build_hdivmass_const_matrix :
+                       &f_build_hcurlmass_const_matrix;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_const_matrix" :
+                         ":f_apply_hcurlmass_mf_const_matrix";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_const_matrix :
+                       &f_apply_hcurlmass_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_quad_matrix" :
+                         ":f_build_hcurlmass_quad_matrix";
+            build_qf = is_hdiv ? &f_build_hdivmass_quad_matrix :
+                       &f_build_hcurlmass_quad_matrix;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_quad_matrix" :
+                         ":f_apply_hcurlmass_mf_quad_matrix";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_quad_matrix :
+                       &f_apply_hcurlmass_mf_quad_matrix;
+         }
+      }
+   }
+};
+#endif
+
+template <typename CoeffType>
+PAVectorFEMassIntegrator::PAVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   VectorFEMassOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, Q, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFVectorFEMassIntegrator::MFVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   VectorFEMassOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, Q, use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PAVectorFEMassIntegrator::PAVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template PAVectorFEMassIntegrator::PAVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template PAVectorFEMassIntegrator::PAVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template MFVectorFEMassIntegrator::MFVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template MFVectorFEMassIntegrator::MFVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template MFVectorFEMassIntegrator::MFVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/vecfemass/vecfemass.hpp b/fem/ceed/integrators/vecfemass/vecfemass.hpp
new file mode 100644
index 000000000..aa0ca2ea3
--- /dev/null
+++ b/fem/ceed/integrators/vecfemass/vecfemass.hpp
@@ -0,0 +1,51 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_VECFEMASS_HPP
+#define MFEM_LIBCEED_VECFEMASS_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/// Represent a VectorFEMassIntegrator with AssemblyLevel::Partial using libCEED.
+class PAVectorFEMassIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAVectorFEMassIntegrator(const mfem::VectorFEMassIntegrator &integ,
+                            const mfem::FiniteElementSpace &fes,
+                            CoeffType *Q,
+                            const bool use_bdr = false);
+};
+
+/// Represent a VectorFEMassIntegrator with AssemblyLevel::None using libCEED.
+class MFVectorFEMassIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFVectorFEMassIntegrator(const mfem::VectorFEMassIntegrator &integ,
+                            const mfem::FiniteElementSpace &fes,
+                            CoeffType *Q,
+                            const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_VECFEMASS_HPP
diff --git a/fem/ceed/integrators/vecfemass/vecfemass_qf.h b/fem/ceed/integrators/vecfemass/vecfemass_qf.h
new file mode 100644
index 000000000..571316ba8
--- /dev/null
+++ b/fem/ceed/integrators/vecfemass/vecfemass_qf.h
@@ -0,0 +1,1454 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_VECFEMASS_QF_H
+#define MFEM_LIBCEED_VECFEMASS_QF_H
+
+#include "../util/util_qf.h"
+
+#define LIBCEED_VECFEMASS_COEFF_COMP_MAX 6
+
+struct VectorFEMassContext
+{
+   CeedInt dim, space_dim;
+   CeedScalar coeff[LIBCEED_VECFEMASS_COEFF_COMP_MAX];
+};
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a scalar constant coefficient
+CEED_QFUNCTION(f_build_hdivmass_const_scalar)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a vector constant coefficient
+CEED_QFUNCTION(f_build_hdivmass_const_vector)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a matrix constant coefficient
+CEED_QFUNCTION(f_build_hdivmass_const_matrix)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a scalar constant coefficient
+CEED_QFUNCTION(f_build_hcurlmass_const_scalar)(void *ctx, CeedInt Q,
+                                               const CeedScalar *const *in,
+                                               CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a vector constant coefficient
+CEED_QFUNCTION(f_build_hcurlmass_const_vector)(void *ctx, CeedInt Q,
+                                               const CeedScalar *const *in,
+                                               CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a matrix constant coefficient
+CEED_QFUNCTION(f_build_hcurlmass_const_matrix)(void *ctx, CeedInt Q,
+                                               const CeedScalar *const *in,
+                                               CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hdivmass_quad_scalar)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hdivmass_quad_vector)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hdivmass_quad_matrix)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hcurlmass_quad_scalar)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hcurlmass_quad_vector)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hcurlmass_quad_matrix)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a vector FE mass operator
+CEED_QFUNCTION(f_apply_vecfemass)(void *ctx, CeedInt Q,
+                                  const CeedScalar *const *in,
+                                  CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   const CeedScalar *u = in[0], *qd = in[1];
+   CeedScalar *v = out[0];
+   switch (bc->dim)
+   {
+      case 1:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            v[i] = qd[i] * u[i];
+         }
+         break;
+      case 2:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[i + Q * 0] * u0 + qd[i + Q * 1] * u1;
+            v[i + Q * 1] = qd[i + Q * 1] * u0 + qd[i + Q * 2] * u1;
+         }
+         break;
+      case 3:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[i + Q * 0] * u0 + qd[i + Q * 1] * u1 + qd[i + Q * 2] * u2;
+            v[i + Q * 1] = qd[i + Q * 1] * u0 + qd[i + Q * 3] * u1 + qd[i + Q * 4] * u2;
+            v[i + Q * 2] = qd[i + Q * 2] * u0 + qd[i + Q * 4] * u1 + qd[i + Q * 5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) mass operator with a scalar
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hdivmass_mf_const_scalar)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 * J[i];
+            v[i] = qd * u[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, coeff, 1, 1, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) mass operator with a vector
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hdivmass_mf_const_vector)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, coeff, 1, 2, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, coeff, 1, 2, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) mass operator with a matrix
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hdivmass_mf_const_matrix)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, coeff, 1, 3, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) mass operator with a scalar
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hcurlmass_mf_const_scalar)(void *ctx, CeedInt Q,
+                                                  const CeedScalar *const *in,
+                                                  CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 / J[i];
+            v[i] = qd * u[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) mass operator with a vector
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hcurlmass_mf_const_vector)(void *ctx, CeedInt Q,
+                                                  const CeedScalar *const *in,
+                                                  CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) mass operator with a matrix
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hcurlmass_mf_const_matrix)(void *ctx, CeedInt Q,
+                                                  const CeedScalar *const *in,
+                                                  CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) operator with a scalar
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hdivmass_mf_quad_scalar)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * J[i];
+            v[i] = qd * u[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, c + i, Q, 1, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) operator with a vector
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hdivmass_mf_quad_vector)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, c + i, Q, 2, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, c + i, Q, 2, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) operator with a matrix
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hdivmass_mf_quad_matrix)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, c + i, Q, 3, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) operator with a scalar
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hcurlmass_mf_quad_scalar)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / J[i];
+            v[i] = qd * u[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) operator with a vector
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hcurlmass_mf_quad_vector)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) operator with a matrix
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hcurlmass_mf_quad_matrix)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_VECFEMASS_QF_H
diff --git a/fem/ceed/interface/basis.cpp b/fem/ceed/interface/basis.cpp
index 37858cb78..487108ef4 100644
--- a/fem/ceed/interface/basis.cpp
+++ b/fem/ceed/interface/basis.cpp
@@ -9,7 +9,8 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../../gridfunc.hpp"
+#include "basis.hpp"
+
 #include "util.hpp"
 
 namespace mfem
@@ -47,75 +48,171 @@ static CeedElemTopology GetCeedTopology(Geometry::Type geom)
 static void InitNonTensorBasis(const mfem::FiniteElementSpace &fes,
                                const mfem::FiniteElement &fe,
                                const mfem::IntegrationRule &ir,
-                               Ceed ceed, CeedBasis *basis)
+                               Ceed ceed,
+                               CeedBasis *basis)
 {
    const mfem::DofToQuad &maps = fe.GetDofToQuad(ir, mfem::DofToQuad::FULL);
-   mfem::Mesh *mesh = fes.GetMesh();
-   const int dim = mesh->Dimension();
-   const int ndofs = maps.ndof;
-   const int nqpts = maps.nqpt;
-   mfem::DenseMatrix qX(dim,nqpts);
-   mfem::Vector qW(nqpts);
-   for (int i = 0; i < nqpts; i++)
+   const int dim = fe.GetDim();
+   const int ncomp = fes.GetVDim();
+   const int P = maps.ndof;
+   const int Q = maps.nqpt;
+   mfem::DenseMatrix qX(dim, Q);
+   mfem::Vector qW(Q);
+   for (int i = 0; i < Q; i++)
    {
       const mfem::IntegrationPoint &ip = ir.IntPoint(i);
-      qX(0,i) = ip.x;
-      if (dim>1) { qX(1,i) = ip.y; }
-      if (dim>2) { qX(2,i) = ip.z; }
+      qX(0, i) = ip.x;
+      if (dim > 1) { qX(1, i) = ip.y; }
+      if (dim > 2) { qX(2, i) = ip.z; }
       qW(i) = ip.weight;
    }
-   CeedBasisCreateH1(ceed, GetCeedTopology(fe.GetGeomType()),
-                     fes.GetVDim(), ndofs, nqpts,
-                     maps.Bt.GetData(), maps.Gt.GetData(),
-                     qX.GetData(), qW.GetData(), basis);
+   if (fe.GetMapType() == mfem::FiniteElement::H_DIV)
+   {
+      CeedBasisCreateHdiv(ceed, GetCeedTopology(fe.GetGeomType()), ncomp, P, Q,
+                          maps.Bt.GetData(), maps.Gt.GetData(),
+                          qX.GetData(), qW.GetData(), basis);
+   }
+   else if (fe.GetMapType() == mfem::FiniteElement::H_CURL)
+   {
+      CeedBasisCreateHcurl(ceed, GetCeedTopology(fe.GetGeomType()), ncomp, P, Q,
+                           maps.Bt.GetData(), maps.Gt.GetData(),
+                           qX.GetData(), qW.GetData(), basis);
+   }
+   else
+   {
+      CeedBasisCreateH1(ceed, GetCeedTopology(fe.GetGeomType()), ncomp, P, Q,
+                        maps.Bt.GetData(), maps.Gt.GetData(),
+                        qX.GetData(), qW.GetData(), basis);
+   }
 }
 
 static void InitTensorBasis(const mfem::FiniteElementSpace &fes,
                             const mfem::FiniteElement &fe,
                             const mfem::IntegrationRule &ir,
-                            Ceed ceed, CeedBasis *basis)
+                            Ceed ceed,
+                            CeedBasis *basis)
 {
    const mfem::DofToQuad &maps = fe.GetDofToQuad(ir, mfem::DofToQuad::TENSOR);
-   mfem::Mesh *mesh = fes.GetMesh();
-   const int ndofs = maps.ndof;
-   const int nqpts = maps.nqpt;
-   mfem::Vector qX(nqpts), qW(nqpts);
-   // The x-coordinates of the first `nqpts` points of the integration rule are
+   const int dim = fe.GetDim();
+   const int ncomp = fes.GetVDim();
+   const int P = maps.ndof;
+   const int Q = maps.nqpt;
+   mfem::Vector qX(Q), qW(Q);
+   // The x-coordinates of the first `Q` points of the integration rule are
    // the points of the corresponding 1D rule. We also scale the weights
    // accordingly.
    double w_sum = 0.0;
-   for (int i = 0; i < nqpts; i++)
+   for (int i = 0; i < Q; i++)
    {
       const mfem::IntegrationPoint &ip = ir.IntPoint(i);
       qX(i) = ip.x;
       qW(i) = ip.weight;
       w_sum += ip.weight;
    }
-   qW *= 1.0/w_sum;
-   CeedBasisCreateTensorH1(ceed, mesh->Dimension(), fes.GetVDim(), ndofs,
-                           nqpts, maps.Bt.GetData(),
-                           maps.Gt.GetData(), qX.GetData(),
-                           qW.GetData(), basis);
+   qW *= 1.0 / w_sum;
+   CeedBasisCreateTensorH1(ceed, dim, ncomp, P, Q,
+                           maps.Bt.GetData(), maps.Gt.GetData(),
+                           qX.GetData(), qW.GetData(), basis);
+}
+
+#if 0
+static void InitCeedInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes,
+                                      const FiniteElement &trial_fe,
+                                      const FiniteElement &test_fe,
+                                      Ceed ceed,
+                                      CeedBasis *basis)
+{
+   // Basis projection operator using libCEED
+   CeedBasis trial_basis, test_basis;
+   const int P = std::max(trial_fe.GetDof(), test_fe.GetDof()), ir_order_max = 100;
+   int ir_order = std::max(trial_fe.GetOrder(), test_fe.GetOrder());
+   for (; ir_order < ir_order_max; ir_order++)
+   {
+      if (IntRules.Get(trial_fe.GetGeomType(), ir_order).GetNPoints() >= P) { break; }
+   }
+   const IntegrationRule &ir = IntRules.Get(trial_fe.GetGeomType(), ir_order);
+   InitBasis(trial_fes, trial_fe, ir, ceed, &trial_basis);
+   InitBasis(test_fes, test_fe, ir, ceed, &test_basis);
+   CeedBasisCreateProjection(trial_basis, test_basis, basis);
+}
+#endif
+
+static void InitMfemInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes,
+                                      const FiniteElement &trial_fe,
+                                      const FiniteElement &test_fe,
+                                      Ceed ceed,
+                                      CeedBasis *basis)
+{
+   MFEM_VERIFY(trial_fes.GetVDim() == test_fes.GetVDim(),
+               "libCEED discrete linear operator requires same vdim for trial "
+               "and test FE spaces.");
+   const int dim = trial_fe.GetDim();
+   const int ncomp = trial_fes.GetVDim();
+   const int trial_P = trial_fe.GetDof();
+   const int test_P = test_fe.GetDof();
+   mfem::DenseMatrix qX(dim, test_P), Gt(trial_P, test_P * dim), Bt;
+   mfem::Vector qW(test_P);
+   mfem::IsoparametricTransformation dummy;
+   dummy.SetIdentityTransformation(trial_fe.GetGeomType());
+   if (trial_fe.GetMapType() == test_fe.GetMapType())
+   {
+      // Prolongation
+      test_fe.GetTransferMatrix(trial_fe, dummy, Bt);
+   }
+   else if (trial_fe.GetMapType() == mfem::FiniteElement::VALUE &&
+            test_fe.GetMapType() == mfem::FiniteElement::H_CURL)
+   {
+      // Discrete gradient interpolator
+      test_fe.ProjectGrad(trial_fe, dummy, Bt);
+   }
+   else if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL &&
+            test_fe.GetMapType() == mfem::FiniteElement::H_DIV)
+   {
+      // Discrete curl interpolator
+      test_fe.ProjectCurl(trial_fe, dummy, Bt);
+   }
+   else if (trial_fe.GetMapType() == mfem::FiniteElement::H_DIV &&
+            test_fe.GetMapType() == mfem::FiniteElement::INTEGRAL)
+   {
+      // Discrete divergence interpolator
+      test_fe.ProjectDiv(trial_fe, dummy, Bt);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported trial/test FE spaces for libCEED discrete "
+                 "linear operator");
+   }
+   Bt.Transpose();
+   Gt = 0.0;
+   qX = 0.0;
+   qW = 0.0;
+   CeedBasisCreateH1(ceed, GetCeedTopology(trial_fe.GetGeomType()), ncomp,
+                     trial_P, test_P, Bt.GetData(), Gt.GetData(),
+                     qX.GetData(), qW.GetData(), basis);
 }
 
-static void InitBasisImpl(const FiniteElementSpace &fes,
-                          const FiniteElement &fe,
-                          const IntegrationRule &ir,
-                          Ceed ceed, CeedBasis *basis)
+void InitBasis(const FiniteElementSpace &fes,
+               const FiniteElement &fe,
+               const IntegrationRule &ir,
+               Ceed ceed,
+               CeedBasis *basis)
 {
-   // Check for FES -> basis, restriction in hash tables
+   // Check for fes -> basis in hash table
+   const int ncomp = fes.GetVDim();
    const int P = fe.GetDof();
    const int Q = ir.GetNPoints();
-   const int ncomp = fes.GetVDim();
-   BasisKey basis_key(&fes, &ir, ncomp, P, Q);
+   BasisKey basis_key(&fes, nullptr, &ir, {ncomp, P, Q});
    auto basis_itr = mfem::internal::ceed_basis_map.find(basis_key);
-   const bool tensor = dynamic_cast<const mfem::TensorBasisElement *>
-                       (&fe) != nullptr;
 
    // Init or retrieve key values
    if (basis_itr == mfem::internal::ceed_basis_map.end())
    {
-      if ( tensor )
+      const bool tensor =
+         dynamic_cast<const mfem::TensorBasisElement *>(&fe) != nullptr;
+      const bool vector = fe.GetRangeType() == mfem::FiniteElement::VECTOR;
+      if (tensor && !vector)
       {
          InitTensorBasis(fes, fe, ir, ceed, basis);
       }
@@ -131,22 +228,41 @@ static void InitBasisImpl(const FiniteElementSpace &fes,
    }
 }
 
-void InitBasis(const FiniteElementSpace &fes,
-               const IntegrationRule &ir,
-               Ceed ceed, CeedBasis *basis)
+void InitInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes,
+                           const FiniteElement &trial_fe,
+                           const FiniteElement &test_fe,
+                           Ceed ceed,
+                           CeedBasis *basis)
 {
-   const mfem::FiniteElement &fe = *fes.GetFE(0);
-   InitBasisImpl(fes, fe, ir, ceed, basis);
-}
+   // Check for fes -> basis in hash table
+   const int ncomp = trial_fes.GetVDim() + test_fes.GetVDim();
+   const int P = trial_fe.GetDof();
+   const int Q = test_fe.GetDof();
+   BasisKey basis_key(&trial_fes, &test_fes, nullptr, {ncomp, P, Q});
+   auto basis_itr = mfem::internal::ceed_basis_map.find(basis_key);
 
-void InitBasisWithIndices(const FiniteElementSpace &fes,
-                          const IntegrationRule &ir,
-                          int nelem,
-                          const int* indices,
-                          Ceed ceed, CeedBasis *basis)
-{
-   const mfem::FiniteElement &fe = *fes.GetFE(indices[0]);
-   InitBasisImpl(fes, fe, ir, ceed, basis);
+   // Init or retrieve key values
+   if (basis_itr == mfem::internal::ceed_basis_map.end())
+   {
+#if 0
+      if (trial_fe.GetMapType() == test_fe.GetMapType())
+      {
+         InitCeedInterpolatorBasis(trial_fes, test_fes, trial_fe, test_fe,
+                                   ceed, basis);
+      }
+      else
+#endif
+      {
+         InitMfemInterpolatorBasis(trial_fes, test_fes, trial_fe, test_fe,
+                                   ceed, basis);
+      }
+      mfem::internal::ceed_basis_map[basis_key] = *basis;
+   }
+   else
+   {
+      *basis = basis_itr->second;
+   }
 }
 
 #endif
diff --git a/fem/ceed/interface/basis.hpp b/fem/ceed/interface/basis.hpp
index 3781f4cf7..361f97863 100644
--- a/fem/ceed/interface/basis.hpp
+++ b/fem/ceed/interface/basis.hpp
@@ -12,6 +12,7 @@
 #ifndef MFEM_LIBCEED_BASIS
 #define MFEM_LIBCEED_BASIS
 
+#include "../../fespace.hpp"
 #include "ceed.hpp"
 
 namespace mfem
@@ -22,31 +23,117 @@ namespace ceed
 
 #ifdef MFEM_USE_CEED
 
-/** @brief Initialize a CeedBasis for non-mixed meshes.
+/** @brief Initialize a CeedBasis based on an mfem::FiniteElementSpace @a fes,
+    an mfem::FiniteElement @a fe, and an mfem::IntegrationRule @a ir.
 
-   @param[in] fes Input finite element space.
-   @param[in] ir Input integration rule.
-   @param[in] ceed Input Ceed object.
-   @param[out] basis The address of the initialized CeedBasis object.
-*/
+    @param[in] fes The finite element space.
+    @param[in] fe The finite element.
+    @param[in] ir The integration rule.
+    @param[in] ceed The Ceed object.
+    @param[out] basis The `CeedBasis` to initialize. */
 void InitBasis(const FiniteElementSpace &fes,
+               const FiniteElement &fe,
                const IntegrationRule &ir,
-               Ceed ceed, CeedBasis *basis);
+               Ceed ceed,
+               CeedBasis *basis);
 
-/** @brief Initialize a CeedBasis for mixed meshes.
+/** @brief Initialize a CeedBasis based on an mfem::FiniteElementSpace @a fes,
+    an mfem::IntegrationRule @a ir, and an optional list of element indices
+    @a indices.
 
     @param[in] fes The finite element space.
-    @param[in] ir is the integration rule for the operator.
-    @param[in] nelem The number of elements.
+    @param[in] ir The integration rule.
+    @param[in] use_bdr Create the basis and restriction for boundary elements.
+    @param[in] indices The indices of the elements of same type in the
+                       `FiniteElementSpace`. If `indices == nullptr`, assumes
+                       that the `FiniteElementSpace` is not mixed.
+    @param[in] ceed The Ceed object.
+    @param[out] basis The `CeedBasis` to initialize. */
+inline void InitBasis(const FiniteElementSpace &fes,
+                      const IntegrationRule &ir,
+                      bool use_bdr,
+                      const int *indices,
+                      Ceed ceed,
+                      CeedBasis *basis)
+{
+   const mfem::FiniteElement *fe;
+   if (indices)
+   {
+      fe = use_bdr ? fes.GetBE(indices[0]) : fes.GetFE(indices[0]);
+   }
+   else
+   {
+      fe = use_bdr ? fes.GetBE(0) : fes.GetFE(0);
+   }
+   InitBasis(fes, *fe, ir, ceed, basis);
+}
+
+inline void InitBasis(const FiniteElementSpace &fes,
+                      const IntegrationRule &ir,
+                      bool use_bdr,
+                      Ceed ceed,
+                      CeedBasis *basis)
+{
+   InitBasis(fes, ir, use_bdr, nullptr, ceed, basis);
+}
+
+/** @brief Initialize a CeedBasis based on an interpolation from
+    mfem::FiniteElementSpace @a trial_fes to @a test_fes. The type of
+    interpolation will be chosen based on the map type of the provided
+    mfem::FiniteElement objects.
+
+    @param[in] trial_fes The trial finite element space.
+    @param[in] test_fes The test finite element space.
+    @param[in] trial_fe The trial finite element.
+    @param[in] test_fe The test finite element.
+    @param[in] ceed The Ceed object.
+    @param[out] basis The `CeedBasis` to initialize. */
+void InitInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes,
+                           const FiniteElement &trial_fe,
+                           const FiniteElement &test_fe,
+                           Ceed ceed,
+                           CeedBasis *basis);
+
+/** @brief Initialize a CeedBasis based on an interpolation from
+    mfem::FiniteElementSpace @a trial_fes to @a test_fes, with an optional list
+    of element indices @a indices. The type of interpolation will be chosen
+    based on the map type of the provided spaces.
+
+    @param[in] trial_fes The trial finite element space.
+    @param[in] test_fes The test finite element space.
     @param[in] indices The indices of the elements of same type in the
-                       `FiniteElementSpace`.
+                       `FiniteElementSpace`. If `indices == nullptr`, assumes
+                       that the `FiniteElementSpace` is not mixed.
     @param[in] ceed The Ceed object.
     @param[out] basis The `CeedBasis` to initialize. */
-void InitBasisWithIndices(const FiniteElementSpace &fes,
-                          const IntegrationRule &ir,
-                          int nelem,
-                          const int* indices,
-                          Ceed ceed, CeedBasis *basis);
+inline void InitInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                                  const FiniteElementSpace &test_fes,
+                                  const int *indices,
+                                  Ceed ceed,
+                                  CeedBasis *basis)
+{
+   const mfem::FiniteElement *trial_fe, *test_fe;
+   if (indices)
+   {
+      trial_fe = trial_fes.GetFE(indices[0]);
+      test_fe = test_fes.GetFE(indices[0]);
+   }
+   else
+   {
+      trial_fe = trial_fes.GetFE(0);
+      test_fe = test_fes.GetFE(0);
+   }
+   InitInterpolatorBasis(trial_fes, test_fes, *trial_fe, *test_fe, ceed, basis);
+}
+
+inline void InitInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                                  const FiniteElementSpace &test_fes,
+                                  Ceed ceed,
+                                  CeedBasis *basis)
+{
+   InitInterpolatorBasis(trial_fes, test_fes, nullptr, ceed, basis);
+}
 
 #endif
 
diff --git a/fem/ceed/interface/ceed.hpp b/fem/ceed/interface/ceed.hpp
index 1e06d9ab5..1945ce3e5 100644
--- a/fem/ceed/interface/ceed.hpp
+++ b/fem/ceed/interface/ceed.hpp
@@ -12,6 +12,7 @@
 #ifndef MFEM_LIBCEED_CEED
 #define MFEM_LIBCEED_CEED
 
+#include "../../../config/config.hpp"
 #ifdef MFEM_USE_CEED
 #include <ceed.h>
 #if !CEED_VERSION_GE(0,10,0)
@@ -24,6 +25,7 @@ namespace mfem
 namespace internal
 {
 
+// Definition in general/device.cpp.
 extern Ceed ceed;
 
 } // namespace internal
diff --git a/fem/ceed/interface/coefficient.hpp b/fem/ceed/interface/coefficient.hpp
index abb70e8b8..d4e067d7a 100644
--- a/fem/ceed/interface/coefficient.hpp
+++ b/fem/ceed/interface/coefficient.hpp
@@ -15,7 +15,6 @@
 #ifdef MFEM_USE_CEED
 
 #include "../../../general/forall.hpp"
-#include "../../../config/config.hpp"
 #include "../../../linalg/vector.hpp"
 #include "../../../linalg/dtensor.hpp"
 #include "../../../mesh/mesh.hpp"
@@ -27,54 +26,38 @@
 namespace mfem
 {
 
-class Mesh;
-class IntegrationRule;
-class Coefficient;
-class VectorCoefficient;
-class GridFunction;
-
 namespace ceed
 {
 
 struct Coefficient
 {
+   CeedVector coeff_vector = nullptr;
    const int ncomp;
-   Coefficient(int ncomp_) : ncomp(ncomp_) { }
-   virtual bool IsConstant() const { return true; }
-   virtual ~Coefficient() { }
-};
-
-struct VariableCoefficient : Coefficient
-{
-   CeedVector coeffVector = nullptr;
    const CeedEvalMode emode;
-   VariableCoefficient(int ncomp_, CeedEvalMode emode_)
-      : Coefficient(ncomp_), emode(emode_) { }
-   virtual bool IsConstant() const override { return false; }
-   ~VariableCoefficient()
+   Coefficient(int ncomp_, CeedEvalMode emode_) : ncomp(ncomp_), emode(emode_) {}
+   virtual ~Coefficient()
    {
-      CeedVectorDestroy(&coeffVector);
+      CeedVectorDestroy(&coeff_vector);
    }
 };
 
-struct GridCoefficient : VariableCoefficient
+struct GridCoefficient : Coefficient
 {
    const mfem::GridFunction &gf;
-   CeedBasis basis;
-   CeedElemRestriction restr;
+   CeedBasis basis = nullptr;
+   CeedElemRestriction restr = nullptr;
    GridCoefficient(const mfem::GridFunction &gf_)
-      : VariableCoefficient(gf_.VectorDim(), CEED_EVAL_INTERP),
-        gf(gf_)
+      : Coefficient(gf_.VectorDim(), CEED_EVAL_INTERP), gf(gf_)
    {
-      InitVector(gf, coeffVector);
+      InitVector(gf, coeff_vector);
    }
 };
 
-struct QuadCoefficient : VariableCoefficient
+struct QuadCoefficient : Coefficient
 {
-   mfem::Vector coeff;
-   CeedElemRestriction restr;
-   QuadCoefficient(int ncomp_) : VariableCoefficient(ncomp_, CEED_EVAL_NONE) { }
+   mfem::Vector vector;
+   CeedElemRestriction restr = nullptr;
+   QuadCoefficient(int ncomp_) : Coefficient(ncomp_, CEED_EVAL_NONE) {}
 };
 
 /** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
@@ -84,73 +67,65 @@ struct QuadCoefficient : VariableCoefficient
     @param[in] Q is the coefficient from the `Integrator`.
     @param[in] mesh is the mesh.
     @param[in] ir is the integration rule.
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
     @param[out] coeff_ptr is the structure to store the coefficient for the
-                          `CeedOperator`.
-    @param[out] ctx is the Context associated to the QFunction. */
-template <typename Context>
-void InitCoefficient(mfem::Coefficient *Q, mfem::Mesh &mesh,
-                     const mfem::IntegrationRule &ir,
-                     Coefficient*& coeff_ptr, Context &ctx)
+                          `CeedOperator`. */
+inline void InitCoefficient(mfem::Coefficient *Q, mfem::Mesh &mesh,
+                            const mfem::IntegrationRule &ir, bool use_bdr,
+                            Coefficient *&coeff_ptr)
 {
-   if ( Q == nullptr )
+   if (Q == nullptr || dynamic_cast<mfem::ConstantCoefficient *>(Q))
    {
-      Coefficient *ceedCoeff = new Coefficient(1);
-      ctx.coeff = 1.0;
-      coeff_ptr = ceedCoeff;
+      // The constant coefficient case is handled by the QFunction context
+      coeff_ptr = nullptr;
    }
-   else if (ConstantCoefficient *const_coeff =
-               dynamic_cast<ConstantCoefficient*>(Q))
+   else if (mfem::GridFunctionCoefficient *gf_coeff =
+               dynamic_cast<mfem::GridFunctionCoefficient *>(Q))
    {
-      Coefficient *ceedCoeff = new Coefficient(1);
-      ctx.coeff = const_coeff->constant;
-      coeff_ptr = ceedCoeff;
-   }
-   else if (GridFunctionCoefficient* gf_coeff =
-               dynamic_cast<GridFunctionCoefficient*>(Q))
-   {
-      GridCoefficient *ceedCoeff =
+      GridCoefficient *ceed_coeff =
          new GridCoefficient(*gf_coeff->GetGridFunction());
-      coeff_ptr = ceedCoeff;
+      coeff_ptr = ceed_coeff;
    }
-   else if (QuadratureFunctionCoefficient *cQ =
-               dynamic_cast<QuadratureFunctionCoefficient*>(Q))
+   else if (mfem::QuadratureFunctionCoefficient *qf_coeff =
+               dynamic_cast<mfem::QuadratureFunctionCoefficient *>(Q))
    {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(1);
-      const int ne = mesh.GetNE();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      const mfem::QuadratureFunction &qFun = cQ->GetQuadFunction();
-      MFEM_VERIFY(qFun.Size() == nq * ne,
-                  "Incompatible QuadratureFunction dimension \n");
-
-      MFEM_VERIFY(&ir == &qFun.GetSpace()->GetIntRule(0),
+      QuadCoefficient *ceed_coeff = new QuadCoefficient(1);
+      const mfem::QuadratureFunction &qfunc = qf_coeff->GetQuadFunction();
+      MFEM_VERIFY(qfunc.Size() == nq * ne,
+                  "Incompatible QuadratureFunction dimension.");
+      MFEM_VERIFY(&ir == &qfunc.GetSpace()->GetIntRule(0),
                   "IntegrationRule used within integrator and in"
-                  " QuadratureFunction appear to be different");
-      qFun.Read();
-      ceedCoeff->coeff.MakeRef(const_cast<mfem::QuadratureFunction &>(qFun),0);
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+                  " QuadratureFunction appear to be different.");
+      qfunc.Read();
+      ceed_coeff->vector.MakeRef(const_cast<mfem::QuadratureFunction &>(qfunc), 0);
+      InitVector(ceed_coeff->vector, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
    else
    {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(1);
-      const int ne = mesh.GetNE();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      ceedCoeff->coeff.SetSize(nq * ne);
-      auto C = Reshape(ceedCoeff->coeff.HostWrite(), nq, ne);
+      QuadCoefficient *ceed_coeff = new QuadCoefficient(1);
+      ceed_coeff->vector.SetSize(nq * ne);
+      auto C = Reshape(ceed_coeff->vector.HostWrite(), nq, ne);
       for (int e = 0; e < ne; ++e)
       {
-         mfem::ElementTransformation &T = *mesh.GetElementTransformation(e);
+         auto &T = use_bdr ? *mesh.GetBdrElementTransformation(e) :
+                   *mesh.GetElementTransformation(e);
          for (int q = 0; q < nq; ++q)
          {
-            C(q,e) = Q->Eval(T, ir.IntPoint(q));
+            const IntegrationPoint &ip = ir.IntPoint(q);
+            T.SetIntPoint(&ip);
+            C(q, e) = Q->Eval(T, ip);
          }
       }
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+      InitVector(ceed_coeff->vector, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
 }
 
-
 /** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
     mfem::VectorCoefficient @a VQ, an mfem::Mesh @a mesh, and an
     mfem::IntegrationRule @a ir.
@@ -158,75 +133,121 @@ void InitCoefficient(mfem::Coefficient *Q, mfem::Mesh &mesh,
     @param[in] VQ is the vector coefficient from the `Integrator`.
     @param[in] mesh is the mesh.
     @param[in] ir is the integration rule.
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
     @param[out] coeff_ptr is the structure to store the coefficient for the
-                          `CeedOperator`.
-    @param[out] ctx is the Context associated to the QFunction. */
-template <typename Context>
-void InitCoefficient(mfem::VectorCoefficient *VQ, mfem::Mesh &mesh,
-                     const mfem::IntegrationRule &ir,
-                     Coefficient *&coeff_ptr, Context &ctx)
+                          `CeedOperator`. */
+inline void InitCoefficient(mfem::VectorCoefficient *VQ, mfem::Mesh &mesh,
+                            const mfem::IntegrationRule &ir, bool use_bdr,
+                            Coefficient *&coeff_ptr)
 {
-   if (VectorConstantCoefficient *const_coeff =
-          dynamic_cast<VectorConstantCoefficient*>(VQ))
+   if (VQ == nullptr || dynamic_cast<mfem::VectorConstantCoefficient *>(VQ))
    {
-      const int vdim = const_coeff->GetVDim();
-      const mfem::Vector &val = const_coeff->GetVec();
-      Coefficient *ceedCoeff = new Coefficient(vdim);
-      for (int i = 0; i < vdim; i++)
-      {
-         ctx.coeff[i] = val[i];
-      }
-      coeff_ptr = ceedCoeff;
+      // The constant coefficient case is handled by the QFunction context
+      coeff_ptr = nullptr;
    }
-   else if (VectorGridFunctionCoefficient* vgf_coeff =
-               dynamic_cast<VectorGridFunctionCoefficient*>(VQ))
+   else if (mfem::VectorGridFunctionCoefficient *vgf_coeff =
+               dynamic_cast<mfem::VectorGridFunctionCoefficient *>(VQ))
    {
-      GridCoefficient *ceedCoeff =
+      GridCoefficient *ceed_coeff =
          new GridCoefficient(*vgf_coeff->GetGridFunction());
-      coeff_ptr = ceedCoeff;
+      coeff_ptr = ceed_coeff;
    }
-   else if (VectorQuadratureFunctionCoefficient *cQ =
-               dynamic_cast<VectorQuadratureFunctionCoefficient*>(VQ))
+   else if (mfem::VectorQuadratureFunctionCoefficient *vqf_coeff =
+               dynamic_cast<mfem::VectorQuadratureFunctionCoefficient *>(VQ))
    {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(cQ->GetVDim());
-      const int dim = mesh.Dimension();
-      const int ne = mesh.GetNE();
+      const int vdim = vqf_coeff->GetVDim();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      const mfem::QuadratureFunction &qFun = cQ->GetQuadFunction();
-      MFEM_VERIFY(qFun.Size() == dim * nq * ne,
-                  "Incompatible QuadratureFunction dimension \n");
-
-      MFEM_VERIFY(&ir == &qFun.GetSpace()->GetIntRule(0),
+      QuadCoefficient *ceed_coeff = new QuadCoefficient(vdim);
+      const mfem::QuadratureFunction &qfunc = vqf_coeff->GetQuadFunction();
+      MFEM_VERIFY(qfunc.Size() == vdim * nq * ne,
+                  "Incompatible QuadratureFunction dimension.");
+      MFEM_VERIFY(&ir == &qfunc.GetSpace()->GetIntRule(0),
                   "IntegrationRule used within integrator and in"
-                  " QuadratureFunction appear to be different");
-      qFun.Read();
-      ceedCoeff->coeff.MakeRef(const_cast<mfem::QuadratureFunction &>(qFun),0);
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+                  " QuadratureFunction appear to be different.");
+      qfunc.Read();
+      ceed_coeff->vector.MakeRef(const_cast<mfem::QuadratureFunction &>(qfunc), 0);
+      InitVector(ceed_coeff->vector, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
    else
    {
-      const int dim = mesh.Dimension();
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(dim);
-      const int ne = mesh.GetNE();
+      const int vdim = VQ->GetVDim();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      ceedCoeff->coeff.SetSize(dim * nq * ne);
-      auto C = Reshape(ceedCoeff->coeff.HostWrite(), dim, nq, ne);
+      QuadCoefficient *ceed_coeff = new QuadCoefficient(vdim);
+      ceed_coeff->vector.SetSize(vdim * nq * ne);
+      auto C = Reshape(ceed_coeff->vector.HostWrite(), vdim, nq, ne);
       mfem::DenseMatrix Q_ir;
       for (int e = 0; e < ne; ++e)
       {
-         mfem::ElementTransformation &T = *mesh.GetElementTransformation(e);
+         auto &T = use_bdr ? *mesh.GetBdrElementTransformation(e) :
+                   *mesh.GetElementTransformation(e);
          VQ->Eval(Q_ir, T, ir);
          for (int q = 0; q < nq; ++q)
          {
-            for (int i = 0; i < dim; ++i)
+            for (int i = 0; i < vdim; ++i)
+            {
+               C(i, q, e) = Q_ir(i, q);
+            }
+         }
+      }
+      InitVector(ceed_coeff->vector, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
+   }
+}
+
+/** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
+    mfem::MatrixCoefficient @a MQ, an mfem::Mesh @a mesh, and an
+    mfem::IntegrationRule @a ir.
+
+    @param[in] MQ is the matrix coefficient from the `Integrator`.
+    @param[in] mesh is the mesh.
+    @param[in] ir is the integration rule.
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[out] coeff_ptr is the structure to store the coefficient for the
+                          `CeedOperator`. */
+inline void InitCoefficient(mfem::MatrixCoefficient *MQ, mfem::Mesh &mesh,
+                            const mfem::IntegrationRule &ir, bool use_bdr,
+                            Coefficient *&coeff_ptr)
+{
+   if (MQ == nullptr || dynamic_cast<mfem::MatrixConstantCoefficient *>(MQ))
+   {
+      // The constant coefficient case is handled by the QFunction context
+      coeff_ptr = nullptr;
+   }
+   else
+   {
+      // Assumes matrix coefficient is symmetric
+      const int vdim = MQ->GetVDim();
+      const int ncomp = (vdim * (vdim + 1)) / 2;
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
+      const int nq = ir.GetNPoints();
+      QuadCoefficient *ceed_coeff = new QuadCoefficient(ncomp);
+      ceed_coeff->vector.SetSize(ncomp * nq * ne);
+      auto C = Reshape(ceed_coeff->vector.HostWrite(), ncomp, nq, ne);
+      mfem::DenseMatrix Q_ip;
+      for (int e = 0; e < ne; ++e)
+      {
+         auto &T = use_bdr ? *mesh.GetBdrElementTransformation(e) :
+                   *mesh.GetElementTransformation(e);
+         for (int q = 0; q < nq; ++q)
+         {
+            const IntegrationPoint &ip = ir.IntPoint(q);
+            T.SetIntPoint(&ip);
+            MQ->Eval(Q_ip, T, ip);
+            for (int j = 0; j < vdim; ++j)
             {
-               C(i,q,e) = Q_ir(i,q);
+               for (int i = j; i < vdim; ++i)
+               {
+                  const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+                  C(idx, q, e) = Q_ip(i, j);  // Column-major
+               }
             }
          }
       }
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+      InitVector(ceed_coeff->vector, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
 }
 
@@ -237,57 +258,49 @@ void InitCoefficient(mfem::VectorCoefficient *VQ, mfem::Mesh &mesh,
     @param[in] Q is the coefficient from the `Integrator`.
     @param[in] mesh is the mesh.
     @param[in] ir is the integration rule.
-    @param[in] nelem The number of elements.
-    @param[in] indices The indices of the elements of same type in the
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] nelem is the number of elements.
+    @param[in] indices are the indices of the elements of same type in the
                        `FiniteElementSpace`.
     @param[out] coeff_ptr is the structure to store the coefficient for the
-                          `CeedOperator`.
-    @param[out] ctx is the Context associated to the QFunction. */
-template <typename Context>
-void InitCoefficientWithIndices(mfem::Coefficient *Q, mfem::Mesh &mesh,
-                                const mfem::IntegrationRule &ir,
-                                int nelem,
-                                const int* indices,
-                                Coefficient*& coeff_ptr, Context &ctx)
+                          `CeedOperator`. */
+inline void InitCoefficientWithIndices(mfem::Coefficient *Q,
+                                       mfem::Mesh &mesh,
+                                       const mfem::IntegrationRule &ir,
+                                       bool use_bdr,
+                                       int nelem,
+                                       const int *indices,
+                                       Coefficient *&coeff_ptr)
 {
-   if ( Q == nullptr )
-   {
-      Coefficient *ceedCoeff = new Coefficient(1);
-      ctx.coeff = 1.0;
-      coeff_ptr = ceedCoeff;
-   }
-   else if (ConstantCoefficient *const_coeff =
-               dynamic_cast<ConstantCoefficient*>(Q))
+   if (Q == nullptr || dynamic_cast<mfem::ConstantCoefficient *>(Q))
    {
-      Coefficient *ceedCoeff = new Coefficient(1);
-      ctx.coeff = const_coeff->constant;
-      coeff_ptr = ceedCoeff;
+      // The constant coefficient case is handled by the QFunction context
+      coeff_ptr = nullptr;
    }
-   else if (GridFunctionCoefficient* gf_coeff =
-               dynamic_cast<GridFunctionCoefficient*>(Q))
+   else if (mfem::GridFunctionCoefficient *gf_coeff =
+               dynamic_cast<mfem::GridFunctionCoefficient *>(Q))
    {
-      GridCoefficient *ceedCoeff =
+      GridCoefficient *ceed_coeff =
          new GridCoefficient(*gf_coeff->GetGridFunction());
-      coeff_ptr = ceedCoeff;
+      coeff_ptr = ceed_coeff;
    }
-   else if (QuadratureFunctionCoefficient *cQ =
-               dynamic_cast<QuadratureFunctionCoefficient*>(Q))
+   else if (mfem::QuadratureFunctionCoefficient *qf_coeff =
+               dynamic_cast<mfem::QuadratureFunctionCoefficient *>(Q))
    {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(1);
-      const int ne = mesh.GetNE();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      const mfem::QuadratureFunction &qFun = cQ->GetQuadFunction();
-      MFEM_VERIFY(qFun.Size() == nq * ne,
-                  "Incompatible QuadratureFunction dimension \n");
-
-      MFEM_VERIFY(&ir == &qFun.GetSpace()->GetIntRule(0),
+      QuadCoefficient *ceed_coeff = new QuadCoefficient(1);
+      ceed_coeff->vector.SetSize(nq * nelem);
+      const mfem::QuadratureFunction &qfunc = qf_coeff->GetQuadFunction();
+      MFEM_VERIFY(qfunc.Size() == nq * ne,
+                  "Incompatible QuadratureFunction dimension.");
+      MFEM_VERIFY(&ir == &qfunc.GetSpace()->GetIntRule(0),
                   "IntegrationRule used within integrator and in"
-                  " QuadratureFunction appear to be different");
-      ceedCoeff->coeff.SetSize(nq * nelem);
+                  " QuadratureFunction appear to be different.");
       Memory<int> m_indices((int*)indices, nelem, false);
-      auto in = Reshape(qFun.Read(), nq, ne);
+      auto in = Reshape(qfunc.Read(), nq, ne);
       auto d_indices = Read(m_indices, nelem);
-      auto out = Reshape(ceedCoeff->coeff.Write(), nq, nelem);
+      auto out = Reshape(ceed_coeff->vector.Write(), nq, nelem);
       mfem::forall(nelem * nq, [=] MFEM_HOST_DEVICE (int i)
       {
          const int q = i%nq;
@@ -296,30 +309,32 @@ void InitCoefficientWithIndices(mfem::Coefficient *Q, mfem::Mesh &mesh,
          out(q, sub_e) = in(q, e);
       });
       m_indices.DeleteDevice();
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+      InitVector(ceed_coeff->vector, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
    else
    {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(1);
       const int nq = ir.GetNPoints();
-      ceedCoeff->coeff.SetSize(nq * nelem);
-      auto C = Reshape(ceedCoeff->coeff.HostWrite(), nq, nelem);
+      QuadCoefficient *ceed_coeff = new QuadCoefficient(1);
+      ceed_coeff->vector.SetSize(nq * nelem);
+      auto C = Reshape(ceed_coeff->vector.HostWrite(), nq, nelem);
       for (int i = 0; i < nelem; ++i)
       {
          const int e = indices[i];
-         mfem::ElementTransformation &T = *mesh.GetElementTransformation(e);
+         auto &T = use_bdr ? *mesh.GetBdrElementTransformation(e) :
+                   *mesh.GetElementTransformation(e);
          for (int q = 0; q < nq; ++q)
          {
-            C(q, i) = Q->Eval(T, ir.IntPoint(q));
+            const IntegrationPoint &ip = ir.IntPoint(q);
+            T.SetIntPoint(&ip);
+            C(q, i) = Q->Eval(T, ip);
          }
       }
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+      InitVector(ceed_coeff->vector, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
 }
 
-
 /** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
     mfem::VectorCoefficient @a Q, an mfem::Mesh @a mesh, and an
     mfem::IntegrationRule @a ir for the elements given by the indices @a indices.
@@ -327,109 +342,165 @@ void InitCoefficientWithIndices(mfem::Coefficient *Q, mfem::Mesh &mesh,
     @param[in] VQ is the vector coefficient from the `Integrator`.
     @param[in] mesh is the mesh.
     @param[in] ir is the integration rule.
-    @param[in] nelem The number of elements.
-    @param[in] indices The indices of the elements of same type in the
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] nelem is the number of elements.
+    @param[in] indices are the indices of the elements of same type in the
                        `FiniteElementSpace`.
     @param[out] coeff_ptr is the structure to store the coefficient for the
-                          `CeedOperator`.
-    @param[out] ctx is the Context associated to the QFunction. */
-template <typename Context>
-void InitCoefficientWithIndices(mfem::VectorCoefficient *VQ, mfem::Mesh &mesh,
-                                const mfem::IntegrationRule &ir,
-                                int nelem,
-                                const int* indices,
-                                Coefficient *&coeff_ptr, Context &ctx)
+                          `CeedOperator`. */
+inline void InitCoefficientWithIndices(mfem::VectorCoefficient *VQ,
+                                       mfem::Mesh &mesh,
+                                       const mfem::IntegrationRule &ir,
+                                       bool use_bdr,
+                                       int nelem, const int *indices,
+                                       Coefficient *&coeff_ptr)
 {
-   if (VectorConstantCoefficient *const_coeff =
-          dynamic_cast<VectorConstantCoefficient*>(VQ))
+   if (VQ == nullptr || dynamic_cast<mfem::VectorConstantCoefficient *>(VQ))
    {
-      const int vdim = const_coeff->GetVDim();
-      const mfem::Vector &val = const_coeff->GetVec();
-      Coefficient *ceedCoeff = new Coefficient(vdim);
-      for (int i = 0; i < vdim; i++)
-      {
-         ctx.coeff[i] = val[i];
-      }
-      coeff_ptr = ceedCoeff;
+      // The constant coefficient case is handled by the QFunction context
+      coeff_ptr = nullptr;
    }
-   else if (VectorGridFunctionCoefficient* vgf_coeff =
-               dynamic_cast<VectorGridFunctionCoefficient*>(VQ))
+   else if (mfem::VectorGridFunctionCoefficient *vgf_coeff =
+               dynamic_cast<mfem::VectorGridFunctionCoefficient *>(VQ))
    {
-      GridCoefficient *ceedCoeff =
+      GridCoefficient *ceed_coeff =
          new GridCoefficient(*vgf_coeff->GetGridFunction());
-      coeff_ptr = ceedCoeff;
+      coeff_ptr = ceed_coeff;
    }
-   else if (VectorQuadratureFunctionCoefficient *cQ =
-               dynamic_cast<VectorQuadratureFunctionCoefficient*>(VQ))
+   else if (mfem::VectorQuadratureFunctionCoefficient *vqf_coeff =
+               dynamic_cast<mfem::VectorQuadratureFunctionCoefficient *>(VQ))
    {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(cQ->GetVDim());
-      const int dim = mesh.Dimension();
-      const int ne = mesh.GetNE();
+      const int vdim = vqf_coeff->GetVDim();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      const mfem::QuadratureFunction &qFun = cQ->GetQuadFunction();
-      MFEM_VERIFY(qFun.Size() == dim * nq * ne,
-                  "Incompatible QuadratureFunction dimension \n");
-
-      MFEM_VERIFY(&ir == &qFun.GetSpace()->GetIntRule(0),
+      QuadCoefficient *ceed_coeff = new QuadCoefficient(vdim);
+      ceed_coeff->vector.SetSize(vdim * nq * nelem);
+      const mfem::QuadratureFunction &qfunc = vqf_coeff->GetQuadFunction();
+      MFEM_VERIFY(qfunc.Size() == vdim * nq * ne,
+                  "Incompatible QuadratureFunction dimension.");
+      MFEM_VERIFY(&ir == &qfunc.GetSpace()->GetIntRule(0),
                   "IntegrationRule used within integrator and in"
-                  " QuadratureFunction appear to be different");
-      ceedCoeff->coeff.SetSize(dim * nq * nelem);
+                  " QuadratureFunction appear to be different.");
       Memory<int> m_indices((int*)indices, nelem, false);
-      auto in = Reshape(qFun.Read(), dim, nq, ne);
+      auto in = Reshape(qfunc.Read(), vdim, nq, ne);
       auto d_indices = Read(m_indices, nelem);
-      auto out = Reshape(ceedCoeff->coeff.Write(), dim, nq, nelem);
+      auto out = Reshape(ceed_coeff->vector.Write(), vdim, nq, nelem);
       mfem::forall(nelem * nq, [=] MFEM_HOST_DEVICE (int i)
       {
          const int q = i%nq;
          const int sub_e = i/nq;
          const int e = d_indices[sub_e];
-         for (int d = 0; d < dim; d++)
+         for (int d = 0; d < vdim; d++)
          {
             out(d, q, sub_e) = in(d, q, e);
          }
       });
       m_indices.DeleteDevice();
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+      InitVector(ceed_coeff->vector, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
    else
    {
-      const int dim = mesh.Dimension();
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(dim);
+      const int vdim = VQ->GetVDim();
       const int nq = ir.GetNPoints();
-      ceedCoeff->coeff.SetSize(dim * nq * nelem);
-      auto C = Reshape(ceedCoeff->coeff.HostWrite(), dim, nq, nelem);
+      QuadCoefficient *ceed_coeff = new QuadCoefficient(vdim);
+      ceed_coeff->vector.SetSize(vdim * nq * nelem);
+      auto C = Reshape(ceed_coeff->vector.HostWrite(), vdim, nq, nelem);
       mfem::DenseMatrix Q_ir;
       for (int i = 0; i < nelem; ++i)
       {
          const int e = indices[i];
-         mfem::ElementTransformation &T = *mesh.GetElementTransformation(e);
+         auto &T = use_bdr ? *mesh.GetBdrElementTransformation(e) :
+                   *mesh.GetElementTransformation(e);
          VQ->Eval(Q_ir, T, ir);
          for (int q = 0; q < nq; ++q)
          {
-            for (int d = 0; d < dim; ++d)
+            for (int d = 0; d < vdim; ++d)
             {
                C(d, q, i) = Q_ir(d, q);
             }
          }
       }
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+      InitVector(ceed_coeff->vector, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
+   }
+}
+
+/** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
+    mfem::MatrixCoefficient @a Q, an mfem::Mesh @a mesh, and an
+    mfem::IntegrationRule @a ir for the elements given by the indices @a indices.
+
+    @param[in] MQ is the matrix coefficient from the `Integrator`.
+    @param[in] mesh is the mesh.
+    @param[in] ir is the integration rule.
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] nelem is the number of elements.
+    @param[in] indices are the indices of the elements of same type in the
+                       `FiniteElementSpace`.
+    @param[out] coeff_ptr is the structure to store the coefficient for the
+                          `CeedOperator`. */
+inline void InitCoefficientWithIndices(mfem::MatrixCoefficient *MQ,
+                                       mfem::Mesh &mesh,
+                                       const mfem::IntegrationRule &ir,
+                                       bool use_bdr,
+                                       int nelem, const int *indices,
+                                       Coefficient *&coeff_ptr)
+{
+   if (MQ == nullptr || dynamic_cast<mfem::MatrixConstantCoefficient *>(MQ))
+   {
+      // The constant coefficient case is handled by the QFunction context
+      coeff_ptr = nullptr;
+   }
+   else
+   {
+      // Assumes matrix coefficient is symmetric
+      const int vdim = MQ->GetVDim();
+      const int ncomp = (vdim * (vdim + 1)) / 2;
+      const int nq = ir.GetNPoints();
+      QuadCoefficient *ceed_coeff = new QuadCoefficient(ncomp);
+      ceed_coeff->vector.SetSize(ncomp * nq * nelem);
+      auto C = Reshape(ceed_coeff->vector.HostWrite(), ncomp, nq, nelem);
+      mfem::DenseMatrix Q_ip;
+      for (int i = 0; i < nelem; ++i)
+      {
+         const int e = indices[i];
+         auto &T = use_bdr ? *mesh.GetBdrElementTransformation(e) :
+                   *mesh.GetElementTransformation(e);
+         for (int q = 0; q < nq; ++q)
+         {
+            const IntegrationPoint &ip = ir.IntPoint(q);
+            T.SetIntPoint(&ip);
+            MQ->Eval(Q_ip, T, ip);
+            for (int dj = 0; dj < vdim; ++dj)
+            {
+               for (int di = dj; di < vdim; ++di)
+               {
+                  const int idx = (dj * vdim) - (((dj - 1) * dj) / 2) + di - dj;
+                  C(idx, q, i) = Q_ip(di, dj);  // Column-major
+               }
+            }
+         }
+      }
+      InitVector(ceed_coeff->vector, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
 }
 
-template <typename Coeff, typename Context>
-void InitCoefficient(Coeff *Q, mfem::Mesh &mesh,
-                     const mfem::IntegrationRule &ir, int nelem,
-                     const int* indices, Coefficient *&coeff_ptr, Context &ctx)
+template <typename CoeffType>
+inline void InitCoefficient(CoeffType *Q, mfem::Mesh &mesh,
+                            const mfem::IntegrationRule &ir,
+                            bool use_bdr,
+                            int nelem,
+                            const int *indices,
+                            Coefficient *&coeff_ptr)
 {
    if (indices)
    {
-      InitCoefficientWithIndices(Q, mesh, ir, nelem, indices, coeff_ptr, ctx);
+      InitCoefficientWithIndices(Q, mesh, ir, use_bdr, nelem, indices, coeff_ptr);
    }
    else
    {
-      InitCoefficient(Q, mesh, ir, coeff_ptr, ctx);
+      InitCoefficient(Q, mesh, ir, use_bdr, coeff_ptr);
    }
 }
 
diff --git a/fem/ceed/interface/integrator.hpp b/fem/ceed/interface/integrator.hpp
index eea79388d..aa24ec207 100644
--- a/fem/ceed/interface/integrator.hpp
+++ b/fem/ceed/interface/integrator.hpp
@@ -9,14 +9,14 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#ifndef MFEM_LIBCEED_INTEG
-#define MFEM_LIBCEED_INTEG
+#ifndef MFEM_LIBCEED_INTEGRATOR
+#define MFEM_LIBCEED_INTEGRATOR
 
-#include "../../../config/config.hpp"
 #include "../../fespace.hpp"
 #include "../../gridfunc.hpp"
-#include "operator.hpp"
+#include "basis.hpp"
 #include "coefficient.hpp"
+#include "operator.hpp"
 #include "restriction.hpp"
 #include "util.hpp"
 #include "ceed.hpp"
@@ -28,43 +28,27 @@ namespace ceed
 {
 
 /** The different evaluation modes available for PA and MF CeedIntegrator. */
-enum class EvalMode { None, Interp, Grad, InterpAndGrad };
+enum class EvalMode { None, Interp, Grad, InterpAndGrad, Div, Curl };
 
 #ifdef MFEM_USE_CEED
 /** This structure is a template interface for the Assemble methods of
     PAIntegrator and MFIntegrator. See ceed/mass.cpp for an example. */
 struct OperatorInfo
 {
-   /** The path to the qFunction header. */
+   /** The path to the QFunction header. */
    const char *header;
-   /** The name of the qFunction to build a partially assembled CeedOperator
-       with a constant Coefficient. */
-   const char *build_func_const;
-   /** The qFunction to build a partially assembled CeedOperator with a constant
-       Coefficient. */
-   CeedQFunctionUser build_qf_const;
-   /** The name of the qFunction to build a partially assembled CeedOperator
-       with a variable Coefficient. */
-   const char *build_func_quad;
-   /** The qFunction to build a partially assembled CeedOperator with a variable
-       Coefficient. */
-   CeedQFunctionUser build_qf_quad;
-   /** The name of the qFunction to apply a partially assembled CeedOperator. */
+   /** The name of the QFunction to build a partially assembled CeedOperator. */
+   const char *build_func;
+   /** The QFunction to build a partially assembled CeedOperator. */
+   CeedQFunctionUser build_qf;
+   /** The name of the QFunction to apply a partially assembled CeedOperator. */
    const char *apply_func;
-   /** The qFunction to apply a partially assembled CeedOperator. */
+   /** The QFunction to apply a partially assembled CeedOperator. */
    CeedQFunctionUser apply_qf;
-   /** The name of the qFunction to apply a matrix-free CeedOperator with a
-       constant Coefficient. */
-   const char *apply_func_mf_const;
-   /** The qFunction to apply a matrix-free CeedOperator with a constant
-       Coefficient. */
-   CeedQFunctionUser apply_qf_mf_const;
-   /** The name of the qFunction to apply a matrix-free CeedOperator with a
-       variable Coefficient. */
-   const char *apply_func_mf_quad;
-   /** The qFunction to apply a matrix-free CeedOperator with a variable
-       Coefficient. */
-   CeedQFunctionUser apply_qf_mf_quad;
+   /** The name of the QFunction to apply a matrix-free CeedOperator. */
+   const char *apply_func_mf;
+   /** The QFunction to apply a matrix-free CeedOperator. */
+   CeedQFunctionUser apply_qf_mf;
    /** The EvalMode on the trial basis functions. */
    EvalMode trial_op;
    /** The EvalMode on the test basis functions. */
@@ -74,284 +58,347 @@ struct OperatorInfo
 };
 #endif
 
-/** This class represent a partially assembled operator using libCEED. */
-class PAIntegrator : public ceed::Operator
+/** This class represents a matrix-free or partially assembled bilinear,
+    mixed bilinear, or nonlinear form operator using libCEED. */
+class Integrator : public Operator
 {
 #ifdef MFEM_USE_CEED
 protected:
-   CeedBasis  trial_basis, test_basis, mesh_basis;
-   CeedElemRestriction trial_restr, test_restr, mesh_restr, restr_i;
-   CeedQFunction build_qfunc, apply_qfunc;
+   CeedBasis trial_basis, test_basis, mesh_basis;
+   CeedElemRestriction trial_restr, test_restr, mesh_restr, qdata_restr;
+   CeedQFunction apply_qfunc;
+   CeedQFunctionContext apply_ctx;
    CeedVector node_coords, qdata;
    Coefficient *coeff;
-   CeedQFunctionContext build_ctx;
-   CeedOperator build_oper;
 
 public:
-   PAIntegrator()
+   Integrator()
       : Operator(),
         trial_basis(nullptr), test_basis(nullptr), mesh_basis(nullptr),
         trial_restr(nullptr), test_restr(nullptr), mesh_restr(nullptr),
-        restr_i(nullptr),
-        build_qfunc(nullptr), apply_qfunc(nullptr), node_coords(nullptr),
-        qdata(nullptr), coeff(nullptr), build_ctx(nullptr), build_oper(nullptr)
-   { }
+        qdata_restr(nullptr),
+        apply_qfunc(nullptr), apply_ctx(nullptr),
+        node_coords(nullptr), qdata(nullptr), coeff(nullptr) {}
 
-   /** @brief This method assembles the `PAIntegrator` with the given
+   /** @brief This method assembles the `Integrator` with the given
        `CeedOperatorInfo` @a info, an `mfem::FiniteElementSpace` @a fes, an
-       `mfem::IntegrationRule` @a ir, and `mfem::Coefficient` or
-       `mfem::VectorCoefficient` @a Q.
+       `mfem::IntegrationRule` @a ir, and `mfem::Coefficient`,
+       `mfem::VectorCoefficient`, or `mfem::MatrixCoefficient` @a Q.
        The `CeedOperatorInfo` type is expected to inherit from `OperatorInfo`,
-       and contain a `Context` type relevant to the qFunctions.
-
-       @param[in] info is the structure describing the CeedOperator to assemble.
-       @param[in] fes is the finite element space.
-       @param[in] ir is the integration rule for the operator.
-       @param[in] Q is the coefficient from the `Integrator`. */
+       and contain a `Context` type relevant to the QFunctions.
+
+       @param[in] info The structure describing the CeedOperator to assemble.
+       @param[in] fes The finite element space.
+       @param[in] ir The integration rule for the operator.
+       @param[in] Q The coefficient from the `Integrator`.
+       @param[in] use_bdr Controls whether to construct the operator for the domain
+                          or domain boundary.
+       @param[in] use_mf Controls whether to construct a matrix-free or partially
+                         assembled operator. */
    template <typename CeedOperatorInfo, typename CoeffType>
    void Assemble(CeedOperatorInfo &info,
                  const mfem::FiniteElementSpace &fes,
                  const mfem::IntegrationRule &ir,
-                 CoeffType *Q)
+                 CoeffType *Q,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
    {
-      Assemble(info, fes, ir, fes.GetNE(), nullptr, Q);
+      Assemble(info, fes, fes, ir,
+               use_bdr ? fes.GetNBE() : fes.GetNE(),
+               nullptr, Q, use_bdr, use_mf);
    }
 
-   /** @brief This method assembles the `PAIntegrator` with the given
+   /** @brief This method assembles the `Integrator` with the given
        `CeedOperatorInfo` @a info, an `mfem::FiniteElementSpace` @a fes, an
-       `mfem::IntegrationRule` @a ir, and `mfem::Coefficient` or
-       `mfem::VectorCoefficient` @a Q for the elements given by the indices
-       @a indices.
+       `mfem::IntegrationRule` @a ir, and `mfem::Coefficient`,
+       `mfem::VectorCoefficient`, or `mfem::MatrixCoefficient` @a Q for the
+       elements given by the indices @a indices.
        The `CeedOperatorInfo` type is expected to inherit from `OperatorInfo`,
-       and contain a `Context` type relevant to the qFunctions.
+       and contain a `Context` type relevant to the QFunctions.
 
-       @param[in] info is the structure describing the CeedOperator to assemble.
-       @param[in] fes is the finite element space.
-       @param[in] ir is the integration rule for the operator.
+       @param[in] info The structure describing the CeedOperator to assemble.
+       @param[in] fes The finite element space.
+       @param[in] ir The integration rule for the operator.
        @param[in] nelem The number of elements.
        @param[in] indices The indices of the elements of same type in the
                           `FiniteElementSpace`. If `indices == nullptr`, assumes
                           that the `FiniteElementSpace` is not mixed.
-       @param[in] Q is the coefficient from the `Integrator`. */
+       @param[in] Q The coefficient from the `Integrator`.
+       @param[in] use_bdr Controls whether to construct the operator for the domain
+                          or domain boundary.
+       @param[in] use_mf Controls whether to construct a matrix-free or partially
+                         assembled operator. */
    template <typename CeedOperatorInfo, typename CoeffType>
    void Assemble(CeedOperatorInfo &info,
                  const mfem::FiniteElementSpace &fes,
                  const mfem::IntegrationRule &ir,
                  int nelem,
-                 const int* indices,
-                 CoeffType *Q)
+                 const int *indices,
+                 CoeffType *Q,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
    {
-      Assemble(info, fes, fes, ir, nelem, indices, Q);
+      Assemble(info, fes, fes, ir, nelem, indices, Q, use_bdr, use_mf);
    }
 
-   /** This method assembles the PAIntegrator for mixed forms.
+   /** This method assembles the `Integrator` for mixed forms.
 
-       @param[in] info the `CeedOperatorInfo` describing the `CeedOperator`,
+       @param[in] info The `CeedOperatorInfo` describing the `CeedOperator`,
                        the `CeedOperatorInfo` type is expected to inherit from
                        `OperatorInfo` and contain a `Context` type relevant to
-                       the qFunctions.
-       @param[in] trial_fes the trial `FiniteElementSpace` for the form,
-       @param[in] test_fes the test `FiniteElementSpace` for the form,
-       @param[in] ir the `IntegrationRule` for the numerical integration,
-       @param[in] Q `Coefficient` or `VectorCoefficient`. */
+                       the QFunctions.
+       @param[in] trial_fes The trial `FiniteElementSpace` for the form.
+       @param[in] test_fes The test `FiniteElementSpace` for the form.
+       @param[in] ir The `IntegrationRule` for the numerical integration.
+       @param[in] Q `Coefficient`, `VectorCoefficient`, or
+                    `MatrixCoefficient`.
+       @param[in] use_bdr Controls whether to construct the operator for the domain
+                          or domain boundary.
+       @param[in] use_mf Controls whether to construct a matrix-free or partially
+                         assembled operator. */
    template <typename CeedOperatorInfo, typename CoeffType>
    void Assemble(CeedOperatorInfo &info,
                  const mfem::FiniteElementSpace &trial_fes,
                  const mfem::FiniteElementSpace &test_fes,
                  const mfem::IntegrationRule &ir,
-                 CoeffType *Q)
+                 CoeffType *Q,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
    {
-      Assemble(info, trial_fes, test_fes, ir, trial_fes.GetNE(), nullptr, Q);
+      Assemble(info, trial_fes, test_fes, ir,
+               use_bdr ? trial_fes.GetNBE() : trial_fes.GetNE(),
+               nullptr, Q, use_bdr, use_mf);
    }
 
-   /** This method assembles the PAIntegrator for mixed forms on mixed meshes.
+   /** This method assembles the `Integrator` for mixed forms on mixed meshes.
 
-       @param[in] info the `CeedOperatorInfo` describing the `CeedOperator`,
+       @param[in] info The `CeedOperatorInfo` describing the `CeedOperator`,
                        the `CeedOperatorInfo` type is expected to inherit from
                        `OperatorInfo` and contain a `Context` type relevant to
-                       the qFunctions.
-       @param[in] trial_fes the trial `FiniteElementSpace` for the form,
-       @param[in] test_fes the test `FiniteElementSpace` for the form,
-       @param[in] ir the `IntegrationRule` for the numerical integration,
-       @param[in] nelem The number of elements,
+                       the QFunctions.
+       @param[in] trial_fes The trial `FiniteElementSpace` for the form.
+       @param[in] test_fes The test `FiniteElementSpace` for the form.
+       @param[in] ir The `IntegrationRule` for the numerical integration.
+       @param[in] nelem The number of elements.
        @param[in] indices The indices of the elements of same type in the
                           `FiniteElementSpace`. If `indices == nullptr`, assumes
-                          that the `FiniteElementSpace` is not mixed,
-       @param[in] Q `Coefficient` or `VectorCoefficient`. */
+                          that the `FiniteElementSpace` is not mixed.
+       @param[in] Q `Coefficient`, `VectorCoefficient`, or
+                    `MatrixCoefficient`.
+       @param[in] use_bdr Controls whether to construct the operator for the domain
+                          or domain boundary.
+       @param[in] use_mf Controls whether to construct a matrix-free or partially
+                         assembled operator. */
    template <typename CeedOperatorInfo, typename CoeffType>
    void Assemble(CeedOperatorInfo &info,
                  const mfem::FiniteElementSpace &trial_fes,
                  const mfem::FiniteElementSpace &test_fes,
                  const mfem::IntegrationRule &ir,
                  int nelem,
-                 const int* indices,
-                 CoeffType *Q)
+                 const int *indices,
+                 CoeffType *Q,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
    {
       Ceed ceed(internal::ceed);
       mfem::Mesh &mesh = *trial_fes.GetMesh();
-      MFEM_VERIFY(!(!indices && mesh.GetNumGeometries(mesh.Dimension()) > 1),
-                  "Use ceed::MixedIntegrator on mixed meshes.");
-      InitCoefficient(Q, mesh, ir, nelem, indices, coeff, info.ctx);
-      bool const_coeff = coeff->IsConstant();
-      std::string build_func = const_coeff ? info.build_func_const
-                               : info.build_func_quad;
-      CeedQFunctionUser build_qf = const_coeff ? info.build_qf_const
-                                   : info.build_qf_quad;
-      PAOperator op {info.qdatasize, info.header,
-                     build_func, build_qf,
-                     info.apply_func, info.apply_qf,
-                     info.trial_op,
-                     info.test_op
-                    };
-      CeedInt dim = mesh.SpaceDimension();
+      CeedInt dim = mesh.Dimension() - use_bdr;
+      CeedInt space_dim = mesh.SpaceDimension();
+      CeedInt curl_dim = (dim < 3) ? 1 : dim;
       CeedInt trial_vdim = trial_fes.GetVDim();
       CeedInt test_vdim = test_fes.GetVDim();
-
-      mesh.EnsureNodes();
-      if ( &trial_fes == &test_fes )
+      bool trial_vectorfe =
+         (trial_fes.FEColl()->GetRangeType(dim) == mfem::FiniteElement::VECTOR);
+      bool test_vectorfe =
+         (test_fes.FEColl()->GetRangeType(dim) == mfem::FiniteElement::VECTOR);
+      MFEM_VERIFY(!(!indices && mesh.GetNumGeometries(dim) > 1),
+                  "Use ceed::MixedOperator<ceed::Integrator> on mixed meshes.");
+      InitCoefficient(Q, mesh, ir, use_bdr, nelem, indices, coeff);
+
+      if (&trial_fes == &test_fes)
       {
-         InitBasisAndRestriction(trial_fes, ir, nelem, indices,
-                                 ceed, &trial_basis, &trial_restr);
-         test_basis = trial_basis;
-         test_restr = trial_restr;
+         InitBasis(trial_fes, ir, use_bdr, indices, ceed,
+                   &trial_basis);
+         InitRestriction(trial_fes, use_bdr, nelem, indices, ceed,
+                         &trial_restr);
+         CeedBasisReferenceCopy(trial_basis, &test_basis);
+         CeedElemRestrictionReferenceCopy(trial_restr, &test_restr);
       }
       else
       {
-         InitBasisAndRestriction(trial_fes, ir, nelem, indices,
-                                 ceed, &trial_basis, &trial_restr);
-         InitBasisAndRestriction(test_fes, ir, nelem, indices,
-                                 ceed, &test_basis, &test_restr);
+         InitBasis(trial_fes, ir, use_bdr, indices, ceed,
+                   &trial_basis);
+         InitBasis(test_fes, ir, use_bdr, indices, ceed,
+                   &test_basis);
+         InitRestriction(trial_fes, use_bdr, nelem, indices, ceed,
+                         &trial_restr);
+         InitRestriction(test_fes, use_bdr, nelem, indices, ceed,
+                         &test_restr);
       }
 
-      const mfem::FiniteElementSpace *mesh_fes = mesh.GetNodalFESpace();
-      MFEM_VERIFY(mesh_fes, "the Mesh has no nodal FE space");
-      InitBasisAndRestriction(*mesh_fes, ir, nelem, indices,
-                              ceed, &mesh_basis, &mesh_restr);
-
       CeedInt trial_nqpts, test_nqpts;
       CeedBasisGetNumQuadraturePoints(trial_basis, &trial_nqpts);
       CeedBasisGetNumQuadraturePoints(test_basis, &test_nqpts);
       MFEM_VERIFY(trial_nqpts == test_nqpts,
                   "Trial and test basis must have the same number of quadrature"
                   " points.");
-      CeedInt nqpts = trial_nqpts;
-
-      const int qdatasize = op.qdatasize;
-      InitStridedRestriction(*mesh_fes, nelem, nqpts, qdatasize,
-                             CEED_STRIDES_BACKEND,
-                             &restr_i);
+      const CeedInt nqpts = trial_nqpts;
 
+      mesh.EnsureNodes();
+      const mfem::FiniteElementSpace *mesh_fes = mesh.GetNodalFESpace();
+      MFEM_VERIFY(mesh_fes, "The mesh has no nodal FE space.");
+      InitBasis(*mesh_fes, ir, use_bdr, indices, ceed, &mesh_basis);
+      InitRestriction(*mesh_fes, use_bdr, nelem, indices, ceed, &mesh_restr);
       InitVector(*mesh.GetNodes(), node_coords);
 
-      CeedVectorCreate(ceed, nelem * nqpts * qdatasize, &qdata);
-
-      // Context data to be passed to the Q-function.
-      info.ctx.dim = mesh.Dimension();
-      info.ctx.space_dim = mesh.SpaceDimension();
-      info.ctx.vdim = trial_fes.GetVDim();
-
-      std::string qf_file = GetCeedPath() + op.header;
-      std::string qf = qf_file + op.build_func;
-      CeedQFunctionCreateInterior(ceed, 1, op.build_qf, qf.c_str(),
-                                  &build_qfunc);
-
-      // Create the Q-function that builds the operator (i.e. computes its
-      // quadrature data) and set its context data.
-      if (VariableCoefficient *var_coeff =
-             dynamic_cast<VariableCoefficient*>(coeff))
-      {
-         CeedQFunctionAddInput(build_qfunc, "coeff", coeff->ncomp,
-                               var_coeff->emode);
-      }
-      CeedQFunctionAddInput(build_qfunc, "dx", dim * dim, CEED_EVAL_GRAD);
-      CeedQFunctionAddInput(build_qfunc, "weights", 1, CEED_EVAL_WEIGHT);
-      CeedQFunctionAddOutput(build_qfunc, "qdata", qdatasize, CEED_EVAL_NONE);
-
-      CeedQFunctionContextCreate(ceed, &build_ctx);
-      CeedQFunctionContextSetData(build_ctx, CEED_MEM_HOST,
+      CeedQFunctionContextCreate(ceed, &apply_ctx);
+      CeedQFunctionContextSetData(apply_ctx, CEED_MEM_HOST,
                                   CEED_COPY_VALUES,
                                   sizeof(info.ctx),
                                   &info.ctx);
-      CeedQFunctionSetContext(build_qfunc, build_ctx);
 
-      // Create the operator that builds the quadrature data for the operator.
-      CeedOperatorCreate(ceed, build_qfunc, NULL, NULL, &build_oper);
-      if (GridCoefficient *gridCoeff = dynamic_cast<GridCoefficient*>(coeff))
-      {
-         InitBasisAndRestriction(*gridCoeff->gf.FESpace(), ir,
-                                 nelem, indices, ceed,
-                                 &gridCoeff->basis,
-                                 &gridCoeff->restr);
-         CeedOperatorSetField(build_oper, "coeff", gridCoeff->restr,
-                              gridCoeff->basis, gridCoeff->coeffVector);
-      }
-      else if (QuadCoefficient *quadCoeff =
-                  dynamic_cast<QuadCoefficient*>(coeff))
+      if (!use_mf)
       {
-         const int ncomp = quadCoeff->ncomp;
-         CeedInt strides[3] = {ncomp, 1, ncomp*nqpts};
-         InitStridedRestriction(*mesh.GetNodalFESpace(),
-                                nelem, nqpts, ncomp, strides,
-                                &quadCoeff->restr);
-         CeedOperatorSetField(build_oper, "coeff", quadCoeff->restr,
-                              CEED_BASIS_COLLOCATED, quadCoeff->coeffVector);
+         const int qdatasize = info.qdatasize;
+         InitStridedRestriction(*mesh_fes, nelem, nqpts, qdatasize,
+                                CEED_STRIDES_BACKEND, ceed,
+                                &qdata_restr);
+         CeedVectorCreate(ceed, nelem * nqpts * qdatasize, &qdata);
+
+         // Create the QFunction that builds the operator (i.e. computes its
+         // quadrature data) and set its context data.
+         CeedQFunction build_qfunc;
+         std::string qf = GetCeedPath() + info.header + info.build_func;
+         CeedQFunctionCreateInterior(ceed, 1, info.build_qf, qf.c_str(),
+                                     &build_qfunc);
+         if (coeff)
+         {
+            CeedQFunctionAddInput(build_qfunc, "coeff", coeff->ncomp, coeff->emode);
+         }
+         CeedQFunctionAddInput(build_qfunc, "dx", dim * space_dim, CEED_EVAL_GRAD);
+         CeedQFunctionAddInput(build_qfunc, "weights", 1, CEED_EVAL_WEIGHT);
+         CeedQFunctionAddOutput(build_qfunc, "qdata", qdatasize, CEED_EVAL_NONE);
+         CeedQFunctionSetContext(build_qfunc, apply_ctx);
+
+         // Create the operator that builds the quadrature data for the operator.
+         CeedOperator build_oper;
+         CeedOperatorCreate(ceed, build_qfunc, NULL, NULL, &build_oper);
+         if (GridCoefficient *grid_coeff = dynamic_cast<GridCoefficient *>(coeff))
+         {
+            const mfem::FiniteElementSpace *coeff_fes = grid_coeff->gf.FESpace();
+            InitBasis(*coeff_fes, ir, use_bdr, indices, ceed,
+                      &grid_coeff->basis);
+            InitRestriction(*coeff_fes, use_bdr, nelem, indices, ceed,
+                            &grid_coeff->restr);
+            CeedOperatorSetField(build_oper, "coeff", grid_coeff->restr,
+                                 grid_coeff->basis, grid_coeff->coeff_vector);
+         }
+         else if (QuadCoefficient *quad_coeff = dynamic_cast<QuadCoefficient *>(coeff))
+         {
+            const int ncomp = quad_coeff->ncomp;
+            CeedInt strides[3] = {ncomp, 1, ncomp * nqpts};
+            InitStridedRestriction(*mesh_fes, nelem, nqpts, ncomp, strides, ceed,
+                                   &quad_coeff->restr);
+            CeedOperatorSetField(build_oper, "coeff", quad_coeff->restr,
+                                 CEED_BASIS_COLLOCATED, quad_coeff->coeff_vector);
+         }
+         CeedOperatorSetField(build_oper, "dx", mesh_restr,
+                              mesh_basis, CEED_VECTOR_ACTIVE);
+         CeedOperatorSetField(build_oper, "weights", CEED_ELEMRESTRICTION_NONE,
+                              mesh_basis, CEED_VECTOR_NONE);
+         CeedOperatorSetField(build_oper, "qdata", qdata_restr,
+                              CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE);
+         CeedOperatorCheckReady(build_oper);
+
+         // Compute the quadrature data for the operator.
+         CeedOperatorApply(build_oper, node_coords, qdata, CEED_REQUEST_IMMEDIATE);
+
+         CeedOperatorDestroy(&build_oper);
+         CeedQFunctionDestroy(&build_qfunc);
+
+         CeedVectorDestroy(&node_coords);
+         node_coords = nullptr;
+         delete coeff;
+         coeff = nullptr;
       }
-      CeedOperatorSetField(build_oper, "dx", mesh_restr,
-                           mesh_basis, CEED_VECTOR_ACTIVE);
-      CeedOperatorSetField(build_oper, "weights", CEED_ELEMRESTRICTION_NONE,
-                           mesh_basis, CEED_VECTOR_NONE);
-      CeedOperatorSetField(build_oper, "qdata", restr_i,
-                           CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE);
-
-      // Compute the quadrature data for the operator.
-      CeedOperatorApply(build_oper, node_coords, qdata, CEED_REQUEST_IMMEDIATE);
-
-      // Create the Q-function that defines the action of the operator.
-      qf = qf_file + op.apply_func;
-      CeedQFunctionCreateInterior(ceed, 1, op.apply_qf, qf.c_str(),
+
+      // Create the QFunction that defines the action of the operator.
+      std::string qf = GetCeedPath() + info.header + info.apply_func;
+      CeedQFunctionCreateInterior(ceed, 1, info.apply_qf, qf.c_str(),
                                   &apply_qfunc);
       // input
-      switch (op.trial_op)
+      switch (info.trial_op)
       {
          case EvalMode::None:
             CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim, CEED_EVAL_NONE);
             break;
          case EvalMode::Interp:
-            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim, CEED_EVAL_INTERP);
+            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim * (trial_vectorfe ? dim : 1),
+                                  CEED_EVAL_INTERP);
             break;
          case EvalMode::Grad:
-            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim*dim, CEED_EVAL_GRAD);
+            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim * dim, CEED_EVAL_GRAD);
             break;
          case EvalMode::InterpAndGrad:
+            MFEM_VERIFY(!trial_vectorfe,
+                        "EvalMode::InterpAndGrad is not intended for vector FE.");
             CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim, CEED_EVAL_INTERP);
-            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim*dim, CEED_EVAL_GRAD);
+            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim * dim, CEED_EVAL_GRAD);
+            break;
+         case EvalMode::Div:
+            CeedQFunctionAddInput(apply_qfunc, "du", trial_vdim, CEED_EVAL_DIV);
+            break;
+         case EvalMode::Curl:
+            CeedQFunctionAddInput(apply_qfunc, "cu", trial_vdim * curl_dim, CEED_EVAL_CURL);
             break;
       }
-      // qdata
-      CeedQFunctionAddInput(apply_qfunc, "qdata", qdatasize, CEED_EVAL_NONE);
+      if (use_mf)
+      {
+         if (coeff)
+         {
+            // coefficient
+            CeedQFunctionAddInput(apply_qfunc, "coeff", coeff->ncomp, coeff->emode);
+         }
+         CeedQFunctionAddInput(apply_qfunc, "dx", dim * space_dim, CEED_EVAL_GRAD);
+         CeedQFunctionAddInput(apply_qfunc, "weights", 1, CEED_EVAL_WEIGHT);
+      }
+      else
+      {
+         // qdata
+         CeedQFunctionAddInput(apply_qfunc, "qdata", info.qdatasize, CEED_EVAL_NONE);
+      }
       // output
-      switch (op.test_op)
+      switch (info.test_op)
       {
          case EvalMode::None:
             CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim, CEED_EVAL_NONE);
             break;
          case EvalMode::Interp:
-            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim, CEED_EVAL_INTERP);
+            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim * (test_vectorfe ? dim : 1),
+                                   CEED_EVAL_INTERP);
             break;
          case EvalMode::Grad:
-            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim*dim, CEED_EVAL_GRAD);
+            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim * dim, CEED_EVAL_GRAD);
             break;
          case EvalMode::InterpAndGrad:
+            MFEM_VERIFY(!test_vectorfe,
+                        "EvalMode::InterpAndGrad is not intended for vector FE.");
             CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim, CEED_EVAL_INTERP);
-            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim*dim, CEED_EVAL_GRAD);
+            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim * dim, CEED_EVAL_GRAD);
+            break;
+         case EvalMode::Div:
+            CeedQFunctionAddOutput(apply_qfunc, "dv", test_vdim, CEED_EVAL_DIV);
+            break;
+         case EvalMode::Curl:
+            CeedQFunctionAddOutput(apply_qfunc, "cv", test_vdim * curl_dim, CEED_EVAL_CURL);
             break;
       }
-      CeedQFunctionSetContext(apply_qfunc, build_ctx);
+      CeedQFunctionSetContext(apply_qfunc, apply_ctx);
 
       // Create the operator.
       CeedOperatorCreate(ceed, apply_qfunc, NULL, NULL, &oper);
       // input
-      switch (op.trial_op)
+      switch (info.trial_op)
       {
          case EvalMode::None:
             CeedOperatorSetField(oper, "u", trial_restr,
@@ -367,12 +414,46 @@ public:
             CeedOperatorSetField(oper, "u", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
             CeedOperatorSetField(oper, "gu", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
             break;
+         case EvalMode::Div:
+            CeedOperatorSetField(oper, "du", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
+            break;
+         case EvalMode::Curl:
+            CeedOperatorSetField(oper, "cu", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
+            break;
+      }
+      if (use_mf)
+      {
+         // coefficient
+         if (GridCoefficient *grid_coeff = dynamic_cast<GridCoefficient *>(coeff))
+         {
+            const mfem::FiniteElementSpace *coeff_fes = grid_coeff->gf.FESpace();
+            InitBasis(*coeff_fes, ir, use_bdr, indices, ceed,
+                      &grid_coeff->basis);
+            InitRestriction(*coeff_fes, use_bdr, nelem, indices, ceed,
+                            &grid_coeff->restr);
+            CeedOperatorSetField(oper, "coeff", grid_coeff->restr,
+                                 grid_coeff->basis, grid_coeff->coeff_vector);
+         }
+         else if (QuadCoefficient *quad_coeff = dynamic_cast<QuadCoefficient *>(coeff))
+         {
+            const int ncomp = quad_coeff->ncomp;
+            CeedInt strides[3] = {ncomp, 1, ncomp * nqpts};
+            InitStridedRestriction(*mesh_fes, nelem, nqpts, ncomp, strides, ceed,
+                                   &quad_coeff->restr);
+            CeedOperatorSetField(oper, "coeff", quad_coeff->restr,
+                                 CEED_BASIS_COLLOCATED, quad_coeff->coeff_vector);
+         }
+         CeedOperatorSetField(oper, "dx", mesh_restr, mesh_basis, node_coords);
+         CeedOperatorSetField(oper, "weights", CEED_ELEMRESTRICTION_NONE,
+                              mesh_basis, CEED_VECTOR_NONE);
+      }
+      else
+      {
+         // qdata
+         CeedOperatorSetField(oper, "qdata", qdata_restr, CEED_BASIS_COLLOCATED, qdata);
       }
-      // qdata
-      CeedOperatorSetField(oper, "qdata", restr_i, CEED_BASIS_COLLOCATED,
-                           qdata);
       // output
-      switch (op.test_op)
+      switch (info.test_op)
       {
          case EvalMode::None:
             CeedOperatorSetField(oper, "v", test_restr,
@@ -388,385 +469,154 @@ public:
             CeedOperatorSetField(oper, "v", test_restr, test_basis, CEED_VECTOR_ACTIVE);
             CeedOperatorSetField(oper, "gv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
             break;
+         case EvalMode::Div:
+            CeedOperatorSetField(oper, "dv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
+            break;
+         case EvalMode::Curl:
+            CeedOperatorSetField(oper, "cv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
+            break;
       }
+      CeedOperatorCheckReady(oper);
 
-      CeedVectorCreate(ceed, trial_vdim*trial_fes.GetNDofs(), &u);
-      CeedVectorCreate(ceed, test_vdim*test_fes.GetNDofs(), &v);
+      CeedVectorCreate(ceed, trial_vdim * trial_fes.GetNDofs(), &u);
+      CeedVectorCreate(ceed, test_vdim * test_fes.GetNDofs(), &v);
    }
 
-   virtual ~PAIntegrator()
+   virtual ~Integrator()
    {
-      CeedQFunctionDestroy(&build_qfunc);
+      // All basis and restriction objects are destroyed by fes destructor
       CeedQFunctionDestroy(&apply_qfunc);
-      CeedQFunctionContextDestroy(&build_ctx);
+      CeedQFunctionContextDestroy(&apply_ctx);
       CeedVectorDestroy(&node_coords);
       CeedVectorDestroy(&qdata);
       delete coeff;
-      CeedOperatorDestroy(&build_oper);
    }
-
-private:
-   /** This structure contains the data to assemble a partially assembled
-       operator with libCEED. */
-   struct PAOperator
-   {
-      /** The number of quadrature data at each quadrature point. */
-      int qdatasize;
-      /** The path to the header containing the functions for libCEED. */
-      std::string header;
-      /** The name of the Qfunction to build the quadrature data. */
-      std::string build_func;
-      /** The Qfunction to build the quadrature data. */
-      CeedQFunctionUser build_qf;
-      /** The name of the Qfunction to apply the operator. */
-      std::string apply_func;
-      /** The Qfunction to apply the operator. */
-      CeedQFunctionUser apply_qf;
-      /** The evaluation mode to apply to the trial function (CEED_EVAL_INTERP,
-          CEED_EVAL_GRAD, etc.) */
-      EvalMode trial_op;
-      /** The evaluation mode to apply to the test function ( CEED_EVAL_INTERP,
-          CEED_EVAL_GRAD, etc.)*/
-      EvalMode test_op;
-   };
 #endif
 };
 
-/** This class represent a matrix-free operator using libCEED. */
-class MFIntegrator : public ceed::Operator
+/** This class represents a matrix-free or partially assembled discrete linear
+    operator using libCEED. */
+class Interpolator : public Operator
 {
 #ifdef MFEM_USE_CEED
 protected:
-   CeedBasis trial_basis, test_basis, mesh_basis;
-   CeedElemRestriction trial_restr, test_restr, mesh_restr, restr_i;
-   CeedQFunction apply_qfunc;
-   CeedVector node_coords, qdata;
-   Coefficient *coeff;
-   CeedQFunctionContext build_ctx;
+   CeedBasis basis_ctof;
+   CeedElemRestriction trial_restr, test_restr;
+   CeedQFunction apply_qfunc, apply_qfunc_t;
 
 public:
-   MFIntegrator()
+   Interpolator()
       : Operator(),
-        trial_basis(nullptr), test_basis(nullptr), mesh_basis(nullptr),
-        trial_restr(nullptr), test_restr(nullptr), mesh_restr(nullptr),
-        restr_i(nullptr),
-        apply_qfunc(nullptr), node_coords(nullptr),
-        qdata(nullptr), coeff(nullptr), build_ctx(nullptr) { }
-
-   /** @brief This method assembles the `MFIntegrator` with the given
-       `CeedOperatorInfo` @a info, an `mfem::FiniteElementSpace` @a fes, an
-       `mfem::IntegrationRule` @a ir, and `mfem::Coefficient` or
-       `mfem::VectorCoefficient` @a Q.
-       The `CeedOperatorInfo` type is expected to inherit from `OperatorInfo`,
-       and contain a `Context` type relevant to the qFunctions.
-
-       @param[in] info is the structure describing the CeedOperator to assemble.
-       @param[in] fes is the finite element space.
-       @param[in] ir is the integration rule for the operator.
-       @param[in] Q is the coefficient from the `Integrator`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
-                 const mfem::FiniteElementSpace &fes,
-                 const mfem::IntegrationRule &ir,
-                 CoeffType *Q)
-   {
-      Assemble(info, fes, ir, fes.GetNE(), nullptr, Q);
-   }
-
-   /** @brief This method assembles the `MFIntegrator` with the given
-       `CeedOperatorInfo` @a info, an `mfem::FiniteElementSpace` @a fes, an
-       `mfem::IntegrationRule` @a ir, and `mfem::Coefficient` or
-       `mfem::VectorCoefficient` @a Q for the elements given by the indices
-       @a indices.
-       The `CeedOperatorInfo` type is expected to inherit from `OperatorInfo`,
-       and contain a `Context` type relevant to the qFunctions.
+        basis_ctof(nullptr),
+        trial_restr(nullptr), test_restr(nullptr),
+        apply_qfunc(nullptr), apply_qfunc_t(nullptr) {}
 
-       @param[in] info is the structure describing the CeedOperator to assemble.
-       @param[in] fes is the finite element space.
-       @param[in] ir is the integration rule for the operator.
-       @param[in] nelem The number of elements.
-       @param[in] indices The indices of the elements of same type in the
-                          `FiniteElementSpace`. If `indices == nullptr`, assumes
-                          that the `FiniteElementSpace` is not mixed.
-       @param[in] Q is the coefficient from the `Integrator`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
-                 const mfem::FiniteElementSpace &fes,
-                 const mfem::IntegrationRule &ir,
-                 int nelem,
-                 const int* indices,
-                 CoeffType *Q)
-   {
-      Assemble(info, fes, fes, ir, nelem, indices, Q);
-   }
-
-   /** This method assembles the MFIntegrator for mixed forms.
+   /** This method assembles the `Interpolator`.
 
-       @param[in] info the `CeedOperatorInfo` describing the `CeedOperator`,
+       @param[in] info The `CeedOperatorInfo` describing the `CeedOperator`,
                        the `CeedOperatorInfo` type is expected to inherit from
                        `OperatorInfo` and contain a `Context` type relevant to
-                       the qFunctions.
-       @param[in] trial_fes the trial `FiniteElementSpace` for the form,
-       @param[in] test_fes the test `FiniteElementSpace` for the form,
-       @param[in] ir the `IntegrationRule` for the numerical integration,
-       @param[in] Q `Coefficient` or `VectorCoefficient`. */
+                       the QFunctions.
+       @param[in] trial_fes The trial `FiniteElementSpace` for the form.
+       @param[in] test_fes The test `FiniteElementSpace` for the form.
+       @param[in] ir Not supported by `Interpolator`.
+       @param[in] Q Not supported by `Interpolator`.
+       @param[in] use_bdr Not supported by `Interpolator`.
+       @param[in] use_mf Controls whether to construct a matrix-free or partially
+                         assembled operator. */
    template <typename CeedOperatorInfo, typename CoeffType>
    void Assemble(CeedOperatorInfo &info,
                  const mfem::FiniteElementSpace &trial_fes,
                  const mfem::FiniteElementSpace &test_fes,
                  const mfem::IntegrationRule &ir,
-                 CoeffType *Q)
+                 CoeffType *Q,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
    {
-      Assemble(info, trial_fes, test_fes, ir, trial_fes.GetNE(), nullptr, Q);
+      Assemble(info, trial_fes, test_fes, ir,
+               use_bdr ? trial_fes.GetNBE() : trial_fes.GetNE(),
+               nullptr, Q, use_bdr, use_mf);
    }
 
-   /** This method assembles the MFIntegrator for mixed forms.
+   /** This method assembles the `Interpolator` on mixed meshes. Its signature
+       matches that for `Integrator`.
 
-       @param[in] info the `CeedOperatorInfo` describing the `CeedOperator`,
+       @param[in] info The `CeedOperatorInfo` describing the `CeedOperator`,
                        the `CeedOperatorInfo` type is expected to inherit from
                        `OperatorInfo` and contain a `Context` type relevant to
-                       the qFunctions.
-       @param[in] trial_fes the trial `FiniteElementSpace` for the form,
-       @param[in] test_fes the test `FiniteElementSpace` for the form,
-       @param[in] ir the `IntegrationRule` for the numerical integration,
-       @param[in] nelem The number of elements,
+                       the QFunctions.
+       @param[in] trial_fes The trial `FiniteElementSpace` for the form.
+       @param[in] test_fes The test `FiniteElementSpace` for the form.
+       @param[in] ir Not supported by `Interpolator`.
+       @param[in] nelem The number of elements.
        @param[in] indices The indices of the elements of same type in the
                           `FiniteElementSpace`. If `indices == nullptr`, assumes
-                          that the `FiniteElementSpace` is not mixed,
-       @param[in] Q `Coefficient` or `VectorCoefficient`. */
+                          that the `FiniteElementSpace` is not mixed.
+       @param[in] Q Not supported by `Interpolator`.
+       @param[in] use_bdr Not supported by `Interpolator`.
+       @param[in] use_mf Controls whether to construct a matrix-free or partially
+                         assembled operator. */
    template <typename CeedOperatorInfo, typename CoeffType>
    void Assemble(CeedOperatorInfo &info,
                  const mfem::FiniteElementSpace &trial_fes,
                  const mfem::FiniteElementSpace &test_fes,
                  const mfem::IntegrationRule &ir,
                  int nelem,
-                 const int* indices,
-                 CoeffType *Q)
+                 const int *indices,
+                 CoeffType *Q,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
    {
       Ceed ceed(internal::ceed);
-      Mesh &mesh = *trial_fes.GetMesh();
-      MFEM_VERIFY(!(!indices && mesh.GetNumGeometries(mesh.Dimension()) > 1),
-                  "Use ceed::MixedIntegrator on mixed meshes.");
-      InitCoefficient(Q, mesh, ir, nelem, indices, coeff, info.ctx);
-      bool const_coeff = coeff->IsConstant();
-      std::string apply_func = const_coeff ? info.apply_func_mf_const
-                               : info.apply_func_mf_quad;
-      CeedQFunctionUser apply_qf = const_coeff ? info.apply_qf_mf_const
-                                   : info.apply_qf_mf_quad;
-      MFOperator op {info.header,
-                     apply_func, apply_qf,
-                     info.trial_op,
-                     info.test_op
-                    };
-
-      CeedInt dim = mesh.SpaceDimension();
       CeedInt trial_vdim = trial_fes.GetVDim();
       CeedInt test_vdim = test_fes.GetVDim();
-
-      mesh.EnsureNodes();
-      if ( &trial_fes == &test_fes )
-      {
-         InitBasisAndRestriction(trial_fes, ir, nelem, indices, ceed,
-                                 &trial_basis, &trial_restr);
-         test_basis = trial_basis;
-         test_restr = trial_restr;
-      }
-      else
-      {
-         InitBasisAndRestriction(trial_fes, ir, nelem, indices, ceed,
-                                 &trial_basis, &trial_restr);
-         InitBasisAndRestriction(test_fes, ir, nelem, indices, ceed,
-                                 &test_basis, &test_restr);
-      }
-
-      const mfem::FiniteElementSpace *mesh_fes = mesh.GetNodalFESpace();
-      MFEM_VERIFY(mesh_fes, "the Mesh has no nodal FE space");
-      InitBasisAndRestriction(*mesh_fes, ir, nelem, indices, ceed, &mesh_basis,
-                              &mesh_restr);
-
-      CeedInt trial_nqpts, test_nqpts;
-      CeedBasisGetNumQuadraturePoints(trial_basis, &trial_nqpts);
-      CeedBasisGetNumQuadraturePoints(trial_basis, &test_nqpts);
-      MFEM_VERIFY(trial_nqpts == test_nqpts,
-                  "Trial and test basis must have the same number of quadrature"
-                  " points.");
-      CeedInt nqpts = trial_nqpts;
-
-      InitVector(*mesh.GetNodes(), node_coords);
-
-      // Context data to be passed to the Q-function.
-      info.ctx.dim = mesh.Dimension();
-      info.ctx.space_dim = mesh.SpaceDimension();
-      info.ctx.vdim = trial_fes.GetVDim();
-
-      std::string qf_file = GetCeedPath() + op.header;
-      std::string qf = qf_file + op.apply_func;
-      CeedQFunctionCreateInterior(ceed, 1, op.apply_qf, qf.c_str(),
+      MFEM_VERIFY(!Q, "ceed:Interpolator does not support coefficients.");
+      MFEM_VERIFY(!use_bdr,
+                  "ceed:Interpolator does not support boundary interpolators.");
+      MFEM_VERIFY(trial_vdim == 1 && test_vdim == 1,
+                  "ceed:Interpolator does not support spaces with vdim > 1.");
+
+      InitInterpolatorBasis(trial_fes, test_fes, indices, ceed, &basis_ctof);
+      InitInterpolatorRestrictions(trial_fes, test_fes, nelem, indices, ceed,
+                                   &trial_restr, &test_restr);
+      MFEM_VERIFY(info.trial_op == EvalMode::Interp,
+                  "ceed:Interpolator only supports trial_op == Interp.");
+      MFEM_VERIFY(info.test_op == EvalMode::None,
+                  "ceed:Interpolator only supports test_op == None.");
+
+      // Create the QFunction that defines the action of the operator
+      // (only an identity as element dof multiplicity is handled outside of libCEED)
+      CeedQFunctionCreateIdentity(ceed, trial_vdim, CEED_EVAL_INTERP, CEED_EVAL_NONE,
                                   &apply_qfunc);
+      CeedQFunctionCreateIdentity(ceed, trial_vdim, CEED_EVAL_NONE, CEED_EVAL_INTERP,
+                                  &apply_qfunc_t);
 
-      // Create the Q-function that builds the operator (i.e. computes its
-      // quadrature data) and set its context data.
-      if (VariableCoefficient *var_coeff =
-             dynamic_cast<VariableCoefficient*>(coeff))
-      {
-         CeedQFunctionAddInput(apply_qfunc, "coeff", coeff->ncomp,
-                               var_coeff->emode);
-      }
-      // input
-      switch (op.trial_op)
-      {
-         case EvalMode::None:
-            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim,
-                                  CEED_EVAL_NONE);
-            break;
-         case EvalMode::Interp:
-            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim,
-                                  CEED_EVAL_INTERP);
-            break;
-         case EvalMode::Grad:
-            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim*dim,
-                                  CEED_EVAL_GRAD);
-            break;
-         case EvalMode::InterpAndGrad:
-            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim,
-                                  CEED_EVAL_INTERP);
-            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim*dim,
-                                  CEED_EVAL_GRAD);
-            break;
-      }
-      CeedQFunctionAddInput(apply_qfunc, "dx", dim * dim, CEED_EVAL_GRAD);
-      CeedQFunctionAddInput(apply_qfunc, "weights", 1, CEED_EVAL_WEIGHT);
-      // output
-      switch (op.test_op)
-      {
-         case EvalMode::None:
-            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim,
-                                   CEED_EVAL_NONE);
-            break;
-         case EvalMode::Interp:
-            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim,
-                                   CEED_EVAL_INTERP);
-            break;
-         case EvalMode::Grad:
-            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim*dim,
-                                   CEED_EVAL_GRAD);
-            break;
-         case EvalMode::InterpAndGrad:
-            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim,
-                                   CEED_EVAL_INTERP);
-            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim*dim,
-                                   CEED_EVAL_GRAD);
-            break;
-      }
-
-      CeedQFunctionContextCreate(ceed, &build_ctx);
-      CeedQFunctionContextSetData(build_ctx, CEED_MEM_HOST,
-                                  CEED_COPY_VALUES,
-                                  sizeof(info.ctx),
-                                  &info.ctx);
-      CeedQFunctionSetContext(apply_qfunc, build_ctx);
-
-      // Create the operator.
+      // Create the operator
       CeedOperatorCreate(ceed, apply_qfunc, NULL, NULL, &oper);
-      // coefficient
-      if (GridCoefficient *gridCoeff = dynamic_cast<GridCoefficient*>(coeff))
-      {
-         InitBasisAndRestriction(*gridCoeff->gf.FESpace(), ir, nelem, indices,
-                                 ceed, &gridCoeff->basis, &gridCoeff->restr);
-         CeedOperatorSetField(oper, "coeff", gridCoeff->restr,
-                              gridCoeff->basis, gridCoeff->coeffVector);
-      }
-      else if (QuadCoefficient *quadCoeff =
-                  dynamic_cast<QuadCoefficient*>(coeff))
-      {
-         const int ncomp = quadCoeff->ncomp;
-         CeedInt strides[3] = {ncomp, 1, ncomp*nqpts};
-         InitStridedRestriction(*mesh.GetNodalFESpace(),
-                                nelem, nqpts, ncomp, strides,
-                                &quadCoeff->restr);
-         CeedOperatorSetField(oper, "coeff", quadCoeff->restr,
-                              CEED_BASIS_COLLOCATED, quadCoeff->coeffVector);
-      }
-      // input
-      switch (op.trial_op)
-      {
-         case EvalMode::None:
-            CeedOperatorSetField(oper, "u", trial_restr,
-                                 CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::Interp:
-            CeedOperatorSetField(oper, "u", trial_restr, trial_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::Grad:
-            CeedOperatorSetField(oper, "gu", trial_restr, trial_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::InterpAndGrad:
-            CeedOperatorSetField(oper, "u", trial_restr, trial_basis,
-                                 CEED_VECTOR_ACTIVE);
-            CeedOperatorSetField(oper, "gu", trial_restr, trial_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-      }
-      CeedOperatorSetField(oper, "dx", mesh_restr,
-                           mesh_basis, node_coords);
-      CeedOperatorSetField(oper, "weights", CEED_ELEMRESTRICTION_NONE,
-                           mesh_basis, CEED_VECTOR_NONE);
-      // output
-      switch (op.test_op)
-      {
-         case EvalMode::None:
-            CeedOperatorSetField(oper, "v", test_restr,
-                                 CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::Interp:
-            CeedOperatorSetField(oper, "v", test_restr, test_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::Grad:
-            CeedOperatorSetField(oper, "gv", test_restr, test_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::InterpAndGrad:
-            CeedOperatorSetField(oper, "v", test_restr, test_basis,
-                                 CEED_VECTOR_ACTIVE);
-            CeedOperatorSetField(oper, "gv", test_restr, test_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-      }
-
-      CeedVectorCreate(ceed, trial_vdim*trial_fes.GetNDofs(), &u);
-      CeedVectorCreate(ceed, test_vdim*test_fes.GetNDofs(), &v);
+      CeedOperatorSetField(oper, "input", trial_restr, basis_ctof,
+                           CEED_VECTOR_ACTIVE);
+      CeedOperatorSetField(oper, "output", test_restr, CEED_BASIS_COLLOCATED,
+                           CEED_VECTOR_ACTIVE);
+      CeedOperatorCheckReady(oper);
+
+      // Create the transpose operator
+      CeedOperatorCreate(ceed, apply_qfunc_t, NULL, NULL, &oper_t);
+      CeedOperatorSetField(oper_t, "input", test_restr, CEED_BASIS_COLLOCATED,
+                           CEED_VECTOR_ACTIVE);
+      CeedOperatorSetField(oper_t, "output", trial_restr, basis_ctof,
+                           CEED_VECTOR_ACTIVE);
+      CeedOperatorCheckReady(oper_t);
+
+      CeedVectorCreate(ceed, trial_vdim * trial_fes.GetNDofs(), &u);
+      CeedVectorCreate(ceed, test_vdim * test_fes.GetNDofs(), &v);
    }
 
-   virtual ~MFIntegrator()
+   virtual ~Interpolator()
    {
+      // All basis and restriction objects are destroyed by fes destructor
       CeedQFunctionDestroy(&apply_qfunc);
-      CeedQFunctionContextDestroy(&build_ctx);
-      CeedVectorDestroy(&node_coords);
-      CeedVectorDestroy(&qdata);
-      delete coeff;
+      CeedQFunctionDestroy(&apply_qfunc_t);
    }
-
-private:
-   /** This structure contains the data to assemble a matrix-free operator with
-       libCEED. */
-   struct MFOperator
-   {
-      /** The path to the header containing the functions for libCEED. */
-      std::string header;
-      /** The name of the Qfunction to apply the operator. */
-      std::string apply_func;
-      /** The Qfunction to apply the operator. */
-      CeedQFunctionUser apply_qf;
-      /** The evaluation mode to apply to the trial function (CEED_EVAL_INTERP,
-          CEED_EVAL_GRAD, etc.) */
-      EvalMode trial_op;
-      /** The evaluation mode to apply to the test function ( CEED_EVAL_INTERP,
-          CEED_EVAL_GRAD, etc.) */
-      EvalMode test_op;
-   };
 #endif
 };
 
@@ -774,4 +624,4 @@ private:
 
 } // namespace mfem
 
-#endif // MFEM_LIBCEED_INTEG
+#endif // MFEM_LIBCEED_INTEGRATOR
diff --git a/fem/ceed/interface/interface.hpp b/fem/ceed/interface/interface.hpp
index 0a69121ad..8b877188c 100644
--- a/fem/ceed/interface/interface.hpp
+++ b/fem/ceed/interface/interface.hpp
@@ -14,6 +14,8 @@
 
 // Object wrapping a CeedOperator in a mfem::Operator.
 #include "operator.hpp"
+// Operator supporting mixed finite element spaces.
+#include "mixed_operator.hpp"
 // Functions to initialize CeedBasis objects.
 #include "basis.hpp"
 // Functions to initialize CeedRestriction objects.
@@ -22,8 +24,6 @@
 #include "coefficient.hpp"
 // PA or MF Operator using libCEED.
 #include "integrator.hpp"
-// PA Operator supporting mixed finite element spaces.
-#include "mixed_integrator.hpp"
 // Utility functions
 #include "util.hpp"
 // Wrapper to include <ceed.h>
diff --git a/fem/ceed/interface/mixed_integrator.hpp b/fem/ceed/interface/mixed_integrator.hpp
deleted file mode 100644
index 8d344f4d9..000000000
--- a/fem/ceed/interface/mixed_integrator.hpp
+++ /dev/null
@@ -1,126 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-#ifndef MFEM_LIBCEED_MIXED_INTEGRATOR
-#define MFEM_LIBCEED_MIXED_INTEGRATOR
-
-#include "ceed.hpp"
-#include "integrator.hpp"
-#include <unordered_map>
-
-namespace mfem
-{
-
-namespace ceed
-{
-
-/** @brief This class wraps a `ceed::PAIntegrator` or `ceed::MFIntegrator` to
-    support mixed finite element spaces. */
-template <typename CeedInteg>
-class MixedIntegrator : public ceed::Operator
-{
-#ifdef MFEM_USE_CEED
-   using ElementKey = std::pair<int, int>; //< Element::Type, Order >
-   struct key_hash
-   {
-      std::size_t operator()(const ElementKey& k) const
-      {
-         return k.first + 2 * k.second;
-      }
-   };
-   using ElementsMap = std::unordered_map<const ElementKey, int*, key_hash>;
-   std::vector<CeedInteg*> sub_ops;
-
-public:
-   template <typename Integrator, typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(const Integrator &integ,
-                 CeedOperatorInfo &info,
-                 const mfem::FiniteElementSpace &fes,
-                 CoeffType *Q)
-   {
-      ElementsMap count;
-      ElementsMap element_indices;
-      ElementsMap offsets;
-
-      // Count the number of elements of each type
-      for (int i = 0; i < fes.GetNE(); i++)
-      {
-         ElementKey key(fes.GetElementType(i), fes.GetElementOrder(i));
-         auto value = count.find(key);
-         if (value == count.end())
-         {
-            count[key] = new int(1);
-         }
-         else
-         {
-            (*value->second)++;
-         }
-      }
-
-      // Initialization of the arrays
-      for ( const auto& value : count )
-      {
-         element_indices[value.first] = new int[*value.second];
-         offsets[value.first] = new int(0);
-      }
-
-      // Populates the indices arrays for each element type
-      for (int i = 0; i < fes.GetNE(); i++)
-      {
-         ElementKey key(fes.GetElementType(i), fes.GetElementOrder(i));
-         int &offset = *(offsets[key]);
-         int* indices_array = element_indices[key];
-         indices_array[offset] = i;
-         offset++;
-      }
-
-      // Create composite CeedOperator
-      CeedCompositeOperatorCreate(internal::ceed, &oper);
-
-      // Create each sub-CeedOperator
-      sub_ops.reserve(element_indices.size());
-      for (const auto& value : element_indices)
-      {
-         const int* indices = value.second;
-         const int first_index = indices[0];
-         const mfem::FiniteElement &el = *fes.GetFE(first_index);
-         auto &T = *fes.GetMesh()->GetElementTransformation(first_index);
-         MFEM_ASSERT(!integ.GetIntegrationRule(),
-                     "Mixed mesh integrators should not have an"
-                     " IntegrationRule.");
-         const IntegrationRule &ir = GetRule(integ, el, el, T);
-         auto sub_op = new CeedInteg();
-         int nelem = *count[value.first];
-         sub_op->Assemble(info, fes, ir, nelem, indices, Q);
-         sub_ops.push_back(sub_op);
-         CeedCompositeOperatorAddSub(oper, sub_op->GetCeedOperator());
-      }
-
-      const int ndofs = fes.GetVDim() * fes.GetNDofs();
-      CeedVectorCreate(internal::ceed, ndofs, &u);
-      CeedVectorCreate(internal::ceed, ndofs, &v);
-   }
-
-   virtual ~MixedIntegrator()
-   {
-      for (auto sub_op : sub_ops)
-      {
-         delete sub_op;
-      }
-   }
-#endif
-};
-
-} // namespace ceed
-
-} // namespace mfem
-
-#endif // MFEM_LIBCEED_MIXED_INTEGRATOR
diff --git a/fem/ceed/interface/mixed_operator.hpp b/fem/ceed/interface/mixed_operator.hpp
new file mode 100644
index 000000000..963e367be
--- /dev/null
+++ b/fem/ceed/interface/mixed_operator.hpp
@@ -0,0 +1,204 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_MIXED_OPERATOR
+#define MFEM_LIBCEED_MIXED_OPERATOR
+
+#include <array>
+#include <unordered_map>
+#include "../../fespace.hpp"
+#include "operator.hpp"
+#include "ceed.hpp"
+#ifdef MFEM_USE_CEED
+#include <ceed/hash.h>
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/** @brief This class wraps one or more `OpType` objects to support
+    finite element spaces on mixed meshes. */
+template <typename OpType>
+class MixedOperator : public Operator
+{
+#ifdef MFEM_USE_CEED
+   using ElementKey =
+      std::array<int, 3>; // <mfem::Element::Type, TrialOrder, TestOrder>
+   struct key_hash
+   {
+      std::size_t operator()(const ElementKey &k) const
+      {
+         return CeedHashCombine(
+                   CeedHashCombine(CeedHashInt(k[0]),
+                                   CeedHashInt(k[1])),
+                   CeedHashInt(k[2]));
+      }
+   };
+   using ElementsMap = std::unordered_map<const ElementKey, int *, key_hash>;
+   std::vector<OpType *> sub_ops;
+
+public:
+   template <typename IntegratorType, typename CeedOperatorInfo, typename CoeffType>
+   void Assemble(const IntegratorType &integ,
+                 CeedOperatorInfo &info,
+                 const mfem::FiniteElementSpace &fes,
+                 CoeffType *Q,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
+   {
+      Assemble(integ, info, fes, fes, Q, use_bdr, use_mf);
+   }
+
+   template <typename IntegratorType, typename CeedOperatorInfo, typename CoeffType>
+   void Assemble(const IntegratorType &integ,
+                 CeedOperatorInfo &info,
+                 const mfem::FiniteElementSpace &trial_fes,
+                 const mfem::FiniteElementSpace &test_fes,
+                 CoeffType *Q,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
+   {
+      MFEM_VERIFY(trial_fes.GetMesh() == test_fes.GetMesh(),
+                  "Trial and test basis must correspond to the same Mesh.");
+      mfem::Mesh &mesh = *trial_fes.GetMesh();
+      const bool mixed =
+         mesh.GetNumGeometries(mesh.Dimension() - use_bdr) > 1 ||
+         trial_fes.IsVariableOrder() || test_fes.IsVariableOrder();
+      if (!mixed)
+      {
+         const mfem::FiniteElement &trial_fe = use_bdr ? *trial_fes.GetBE(0) :
+                                               *trial_fes.GetFE(0);
+         const mfem::FiniteElement &test_fe = use_bdr ? *test_fes.GetBE(0) :
+                                              *test_fes.GetFE(0);
+         auto &T = use_bdr ? *mesh.GetBdrElementTransformation(0) :
+                   *mesh.GetElementTransformation(0);
+         const mfem::IntegrationRule &ir =
+            integ.GetIntegrationRule() ? *integ.GetIntegrationRule() :
+            integ.GetRule(trial_fe, test_fe, T);
+         sub_ops.reserve(1);
+         auto *sub_op = new OpType();
+         sub_op->Assemble(info, trial_fes, test_fes, ir, Q, use_bdr, use_mf);
+         sub_ops.push_back(sub_op);
+
+         CeedOperatorReferenceCopy(sub_op->GetCeedOperator(), &oper);
+         if (sub_op->GetCeedOperatorTranspose())
+         {
+            CeedOperatorReferenceCopy(sub_op->GetCeedOperatorTranspose(), &oper_t);
+         }
+         CeedVectorReferenceCopy(sub_op->GetCeedVectorU(), &u);
+         CeedVectorReferenceCopy(sub_op->GetCeedVectorV(), &v);
+         return;
+      }
+
+      // Count the number of elements of each type
+      ElementsMap count;
+      ElementsMap element_indices;
+      ElementsMap offsets;
+
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
+      for (int i = 0; i < ne; i++)
+      {
+         const mfem::FiniteElement &trial_fe = use_bdr ? *trial_fes.GetBE(i) :
+                                               *trial_fes.GetFE(i);
+         const mfem::FiniteElement &test_fe = use_bdr ? *test_fes.GetBE(i) :
+                                              *test_fes.GetFE(i);
+         mfem::Element::Type type = use_bdr ? mesh.GetBdrElementType(i) :
+                                    mesh.GetElementType(i);
+         ElementKey key = {type, trial_fe.GetOrder(), test_fe.GetOrder()};
+         auto value = count.find(key);
+         if (value == count.end())
+         {
+            count[key] = new int(1);
+         }
+         else
+         {
+            (*value->second)++;
+         }
+      }
+
+      // Initialization of the arrays
+      for (const auto &value : count)
+      {
+         element_indices[value.first] = new int[*value.second];
+         offsets[value.first] = new int(0);
+      }
+
+      // Populates the indices arrays for each element type
+      for (int i = 0; i < ne; i++)
+      {
+         const mfem::FiniteElement &trial_fe = use_bdr ? *trial_fes.GetBE(i) :
+                                               *trial_fes.GetFE(i);
+         const mfem::FiniteElement &test_fe = use_bdr ? *test_fes.GetBE(i) :
+                                              *test_fes.GetFE(i);
+         mfem::Element::Type type = use_bdr ? mesh.GetBdrElementType(i) :
+                                    mesh.GetElementType(i);
+         ElementKey key = {type, trial_fe.GetOrder(), test_fe.GetOrder()};
+         int &offset = *(offsets[key]);
+         int *indices_array = element_indices[key];
+         indices_array[offset] = i;
+         offset++;
+      }
+
+      // Create composite CeedOperator
+      CeedCompositeOperatorCreate(internal::ceed, &oper);
+
+      // Create each sub-CeedOperator
+      sub_ops.reserve(element_indices.size());
+      for (const auto &value : element_indices)
+      {
+         const int *indices = value.second;
+         const int first_index = indices[0];
+         const mfem::FiniteElement &trial_fe =
+            use_bdr ? *trial_fes.GetBE(first_index) : *trial_fes.GetFE(first_index);
+         const mfem::FiniteElement &test_fe =
+            use_bdr ? *test_fes.GetBE(first_index) : *test_fes.GetFE(first_index);
+         auto &T = use_bdr ? *mesh.GetBdrElementTransformation(first_index) :
+                   *mesh.GetElementTransformation(first_index);
+         MFEM_VERIFY(!integ.GetIntegrationRule(),
+                     "Mixed mesh integrators should not have an IntegrationRule.");
+         const IntegrationRule &ir = integ.GetRule(trial_fe, test_fe, T);
+         auto *sub_op = new OpType();
+         sub_op->Assemble(info, trial_fes, test_fes, ir, *count[value.first], indices, Q,
+                          use_bdr, use_mf);
+         sub_ops.push_back(sub_op);
+         CeedCompositeOperatorAddSub(oper, sub_op->GetCeedOperator());
+         if (sub_op->GetCeedOperatorTranspose())
+         {
+            if (!oper_t) { CeedCompositeOperatorCreate(internal::ceed, &oper_t); }
+            CeedCompositeOperatorAddSub(oper_t, sub_op->GetCeedOperatorTranspose());
+         }
+      }
+      CeedOperatorCheckReady(oper);
+      if (oper_t) { CeedOperatorCheckReady(oper_t); }
+
+      CeedVectorCreate(internal::ceed, trial_fes.GetVDim() * trial_fes.GetNDofs(),
+                       &u);
+      CeedVectorCreate(internal::ceed, test_fes.GetVDim() * test_fes.GetNDofs(), &v);
+   }
+
+   virtual ~MixedOperator()
+   {
+      for (auto *sub_op : sub_ops)
+      {
+         delete sub_op;
+      }
+   }
+#endif
+};
+
+} // namespace ceed
+
+} // namespace mfem
+
+#endif // MFEM_LIBCEED_MIXED_OPERATOR
diff --git a/fem/ceed/interface/operator.cpp b/fem/ceed/interface/operator.cpp
index 745e474e5..7f21e7ce4 100644
--- a/fem/ceed/interface/operator.cpp
+++ b/fem/ceed/interface/operator.cpp
@@ -11,11 +11,9 @@
 
 #include "operator.hpp"
 
-#include "../../../config/config.hpp"
 #include "../../../linalg/vector.hpp"
 #include "../../fespace.hpp"
 #include "util.hpp"
-#include "ceed.hpp"
 
 namespace mfem
 {
@@ -27,6 +25,7 @@ namespace ceed
 Operator::Operator(CeedOperator op)
 {
    oper = op;
+   oper_t = nullptr;
    CeedSize in_len, out_len;
    int ierr = CeedOperatorGetActiveVectorLengths(oper, &in_len, &out_len);
    PCeedChk(ierr);
@@ -39,9 +38,15 @@ Operator::Operator(CeedOperator op)
 }
 #endif
 
-void Operator::Mult(const mfem::Vector &x, mfem::Vector &y) const
+namespace
 {
+
 #ifdef MFEM_USE_CEED
+void CeedAddMult(CeedOperator oper, CeedVector u, CeedVector v,
+                 const mfem::Vector &x, mfem::Vector &y, double a)
+{
+   MFEM_VERIFY(a == 0.0 || a == 1.0,
+               "General coefficient case is not yet supported!");
    const CeedScalar *x_ptr;
    CeedScalar *y_ptr;
    CeedMemType mem;
@@ -49,21 +54,37 @@ void Operator::Mult(const mfem::Vector &x, mfem::Vector &y) const
    if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       x_ptr = x.Read();
-      y_ptr = y.Write();
+      y_ptr = (a == 0.0) ? y.Write() : y.ReadWrite();
    }
    else
    {
       x_ptr = x.HostRead();
-      y_ptr = y.HostWrite();
+      y_ptr = (a == 0.0) ? y.HostWrite() : y.HostReadWrite();
       mem = CEED_MEM_HOST;
    }
    CeedVectorSetArray(u, mem, CEED_USE_POINTER, const_cast<CeedScalar*>(x_ptr));
    CeedVectorSetArray(v, mem, CEED_USE_POINTER, y_ptr);
 
-   CeedOperatorApply(oper, u, v, CEED_REQUEST_IMMEDIATE);
+   if (a == 0.0)
+   {
+      CeedOperatorApply(oper, u, v, CEED_REQUEST_IMMEDIATE);
+   }
+   else
+   {
+      CeedOperatorApplyAdd(oper, u, v, CEED_REQUEST_IMMEDIATE);
+   }
 
    CeedVectorTakeArray(u, mem, const_cast<CeedScalar**>(&x_ptr));
    CeedVectorTakeArray(v, mem, &y_ptr);
+}
+#endif
+
+} // namespace
+
+void Operator::Mult(const mfem::Vector &x, mfem::Vector &y) const
+{
+#ifdef MFEM_USE_CEED
+   CeedAddMult(oper, u, v, x, y, 0.0);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
@@ -73,29 +94,30 @@ void Operator::AddMult(const mfem::Vector &x, mfem::Vector &y,
                        const double a) const
 {
 #ifdef MFEM_USE_CEED
-   MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
-   const CeedScalar *x_ptr;
-   CeedScalar *y_ptr;
-   CeedMemType mem;
-   CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
-   {
-      x_ptr = x.Read();
-      y_ptr = y.ReadWrite();
-   }
-   else
-   {
-      x_ptr = x.HostRead();
-      y_ptr = y.HostReadWrite();
-      mem = CEED_MEM_HOST;
-   }
-   CeedVectorSetArray(u, mem, CEED_USE_POINTER, const_cast<CeedScalar*>(x_ptr));
-   CeedVectorSetArray(v, mem, CEED_USE_POINTER, y_ptr);
+   CeedAddMult(oper, u, v, x, y, 1.0);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
 
-   CeedOperatorApplyAdd(oper, u, v, CEED_REQUEST_IMMEDIATE);
+void Operator::MultTranspose(const mfem::Vector &x, mfem::Vector &y) const
+{
+#ifdef MFEM_USE_CEED
+   MFEM_ASSERT(oper_t,
+               "No transpose operator defined for ceed::Operator::MultTranspose.");
+   CeedAddMult(oper_t, v, u, x, y, 0.0);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
 
-   CeedVectorTakeArray(u, mem, const_cast<CeedScalar**>(&x_ptr));
-   CeedVectorTakeArray(v, mem, &y_ptr);
+void Operator::AddMultTranspose(const mfem::Vector &x, mfem::Vector &y,
+                                const double a) const
+{
+#ifdef MFEM_USE_CEED
+   MFEM_ASSERT(oper_t,
+               "No transpose operator defined for ceed::Operator::AddMultTranspose.");
+   CeedAddMult(oper_t, v, u, x, y, 1.0);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
diff --git a/fem/ceed/interface/operator.hpp b/fem/ceed/interface/operator.hpp
index 9e4a4faaf..2f131e64d 100644
--- a/fem/ceed/interface/operator.hpp
+++ b/fem/ceed/interface/operator.hpp
@@ -26,35 +26,40 @@ class Operator : public mfem::Operator
 {
 protected:
 #ifdef MFEM_USE_CEED
-   CeedOperator oper;
+   CeedOperator oper, oper_t;
    CeedVector u, v;
 
-   Operator() : oper(nullptr), u(nullptr), v(nullptr) { }
+   Operator() : oper(nullptr), oper_t(nullptr), u(nullptr), v(nullptr) {}
 #endif
 
 public:
 #ifdef MFEM_USE_CEED
    /// This class takes ownership of op and will delete it
    Operator(CeedOperator op);
+
+   CeedOperator &GetCeedOperator() { return oper; }
+   CeedOperator &GetCeedOperatorTranspose() { return oper_t; }
+   CeedVector &GetCeedVectorU() { return u; }
+   CeedVector &GetCeedVectorV() { return v; }
 #endif
 
    void Mult(const mfem::Vector &x, mfem::Vector &y) const override;
    void AddMult(const mfem::Vector &x, mfem::Vector &y,
                 const double a = 1.0) const override;
+   void MultTranspose(const mfem::Vector &x, mfem::Vector &y) const override;
+   void AddMultTranspose(const mfem::Vector &x, mfem::Vector &y,
+                         const double a = 1.0) const override;
    void GetDiagonal(mfem::Vector &diag) const;
 
    virtual ~Operator()
    {
 #ifdef MFEM_USE_CEED
       CeedOperatorDestroy(&oper);
+      CeedOperatorDestroy(&oper_t);
       CeedVectorDestroy(&u);
       CeedVectorDestroy(&v);
 #endif
    }
-
-#ifdef MFEM_USE_CEED
-   CeedOperator& GetCeedOperator() { return oper; }
-#endif
 };
 
 } // namespace ceed
diff --git a/fem/ceed/interface/restriction.cpp b/fem/ceed/interface/restriction.cpp
index e7e8539bd..32a00223f 100644
--- a/fem/ceed/interface/restriction.cpp
+++ b/fem/ceed/interface/restriction.cpp
@@ -9,8 +9,9 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../../../fem/gridfunc.hpp"
-#include "ceed.hpp"
+#include "restriction.hpp"
+
+#include "util.hpp"
 
 namespace mfem
 {
@@ -20,222 +21,368 @@ namespace ceed
 
 #ifdef MFEM_USE_CEED
 
-static void InitNativeRestr(const mfem::FiniteElementSpace &fes,
-                            Ceed ceed, CeedElemRestriction *restr)
+enum RestrType {Strided = 0, Lexico, Native, NativeRange};
+
+static void InitLexicoRestr(const mfem::FiniteElementSpace &fes,
+                            bool use_bdr,
+                            int nelem,
+                            Ceed ceed,
+                            CeedElemRestriction *restr)
 {
-   const mfem::FiniteElement *fe = fes.GetFE(0);
+   const mfem::FiniteElement *fe = use_bdr ? fes.GetBE(0) :
+                                   fes.GetFE(0);
    const int P = fe->GetDof();
-   CeedInt compstride = fes.GetOrdering()==Ordering::byVDIM ? 1 : fes.GetNDofs();
-   const mfem::Table &el_dof = fes.GetElementToDofTable();
-   mfem::Array<int> tp_el_dof(el_dof.Size_of_connections());
-   const mfem::TensorBasisElement * tfe =
+   const mfem::TensorBasisElement *tfe =
       dynamic_cast<const mfem::TensorBasisElement *>(fe);
-   const int stride = compstride == 1 ? fes.GetVDim() : 1;
-   const mfem::Array<int>& dof_map = tfe->GetDofMap();
+   const mfem::Array<int> &dof_map = tfe->GetDofMap();
+   CeedInt compstride =
+      (fes.GetOrdering() == Ordering::byVDIM) ? 1 : fes.GetNDofs();
+   const int stride = (compstride == 1) ? fes.GetVDim() : 1;
+   const mfem::Table &el_dof = use_bdr ? fes.GetBdrElementToDofTable() :
+                               fes.GetElementToDofTable();
+   const int *el_map = el_dof.GetJ();
+   mfem::Array<int> tp_el_dof(el_dof.Size_of_connections());
+   mfem::Array<bool> tp_el_orients(el_dof.Size_of_connections());
+   bool use_orients = false;
 
-   for (int i = 0; i < fes.GetNE(); i++)
+   for (int i = 0; i < nelem; i++)
    {
-      const int el_offset = P * i;
+      // No need to handle DofTransformation for tensor-product elements
       for (int j = 0; j < P; j++)
       {
-         tp_el_dof[j+el_offset] = stride*el_dof.GetJ()[dof_map[j]+el_offset];
+         const int sdid = dof_map[j];  // signed
+         const int did = (sdid >= 0) ? sdid : -1 - sdid;
+         const int sgid = el_map[did + P * i];  // signed
+         const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+         tp_el_dof[j + P * i] = stride * gid;
+         tp_el_orients[j + P * i] =
+            (sgid >= 0 && sdid < 0) || (sgid < 0 && sdid >= 0);
+         use_orients = use_orients || tp_el_orients[j + P * i];
       }
    }
 
-   CeedElemRestrictionCreate(ceed, fes.GetNE(), P, fes.GetVDim(),
-                             compstride, (fes.GetVDim())*(fes.GetNDofs()),
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
+   if (use_orients)
+   {
+      CeedElemRestrictionCreateOriented(ceed, nelem, P, fes.GetVDim(),
+                                        compstride, fes.GetVDim() * fes.GetNDofs(),
+                                        CEED_MEM_HOST, CEED_COPY_VALUES,
+                                        tp_el_dof.GetData(), tp_el_orients.GetData(),
+                                        restr);
+   }
+   else
+   {
+      CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
+                                compstride, fes.GetVDim() * fes.GetNDofs(),
+                                CEED_MEM_HOST, CEED_COPY_VALUES,
+                                tp_el_dof.GetData(), restr);
+   }
 }
 
-static void InitLexicoRestr(const mfem::FiniteElementSpace &fes,
-                            Ceed ceed, CeedElemRestriction *restr)
+static void InitNativeRestr(const mfem::FiniteElementSpace &fes,
+                            bool use_bdr,
+                            int nelem,
+                            Ceed ceed,
+                            CeedElemRestriction *restr)
 {
-   const mfem::FiniteElement *fe = fes.GetFE(0);
+   const mfem::FiniteElement *fe = use_bdr ? fes.GetBE(0) :
+                                   fes.GetFE(0);
    const int P = fe->GetDof();
-   CeedInt compstride = fes.GetOrdering()==Ordering::byVDIM ? 1 : fes.GetNDofs();
-   const mfem::Table &el_dof = fes.GetElementToDofTable();
+   CeedInt compstride =
+      (fes.GetOrdering() == Ordering::byVDIM) ? 1 : fes.GetNDofs();
+   const int stride = (compstride == 1) ? fes.GetVDim() : 1;
+   const mfem::Table &el_dof = use_bdr ? fes.GetBdrElementToDofTable() :
+                               fes.GetElementToDofTable();
+   const int *el_map = el_dof.GetJ();
    mfem::Array<int> tp_el_dof(el_dof.Size_of_connections());
-   const int stride = compstride == 1 ? fes.GetVDim() : 1;
+   mfem::Array<bool> tp_el_orients(el_dof.Size_of_connections());
+   bool use_orients = false;
 
-   for (int e = 0; e < fes.GetNE(); e++)
+   for (int i = 0; i < nelem; i++)
    {
-      for (int i = 0; i < P; i++)
+      // DofTransformation support uses InitNativeRestrWithIndices
+      for (int j = 0; j < P; j++)
       {
-         tp_el_dof[i + e*P] = stride*el_dof.GetJ()[i + e*P];
+         const int sgid = el_map[j + P * i];  // signed
+         const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+         tp_el_dof[j + P * i] = stride * gid;
+         tp_el_orients[j + P * i] = (sgid < 0);
+         use_orients = use_orients || tp_el_orients[j + P * i];
       }
    }
 
-   CeedElemRestrictionCreate(ceed, fes.GetNE(), P, fes.GetVDim(),
-                             compstride, (fes.GetVDim())*(fes.GetNDofs()),
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
-}
-
-static void InitRestrictionImpl(const mfem::FiniteElementSpace &fes,
-                                Ceed ceed, CeedElemRestriction *restr)
-{
-   const mfem::FiniteElement *fe = fes.GetFE(0);
-   const mfem::TensorBasisElement * tfe =
-      dynamic_cast<const mfem::TensorBasisElement *>(fe);
-   if ( tfe && tfe->GetDofMap().Size()>0 ) // Native ordering using dof_map
+   if (use_orients)
    {
-      InitNativeRestr(fes, ceed, restr);
+      CeedElemRestrictionCreateOriented(ceed, nelem, P, fes.GetVDim(),
+                                        compstride, fes.GetVDim() * fes.GetNDofs(),
+                                        CEED_MEM_HOST, CEED_COPY_VALUES,
+                                        tp_el_dof.GetData(), tp_el_orients.GetData(),
+                                        restr);
    }
-   else  // Lexicographic ordering
+   else
    {
-      InitLexicoRestr(fes, ceed, restr);
+      CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
+                                compstride, fes.GetVDim() * fes.GetNDofs(),
+                                CEED_MEM_HOST, CEED_COPY_VALUES,
+                                tp_el_dof.GetData(), restr);
    }
 }
 
-static void InitNativeRestrWithIndices(
-   const mfem::FiniteElementSpace &fes,
-   int nelem,
-   const int* indices,
-   Ceed ceed, CeedElemRestriction *restr)
+static void InitLexicoRestrWithIndices(const mfem::FiniteElementSpace &fes,
+                                       bool use_bdr,
+                                       int nelem,
+                                       const int *indices,
+                                       Ceed ceed,
+                                       CeedElemRestriction *restr)
 {
-   const mfem::FiniteElement *fe = fes.GetFE(indices[0]);
+   const mfem::FiniteElement *fe = use_bdr ? fes.GetBE(indices[0]) :
+                                   fes.GetFE(indices[0]);
    const int P = fe->GetDof();
-   CeedInt compstride = fes.GetOrdering()==Ordering::byVDIM ? 1 : fes.GetNDofs();
-   mfem::Array<int> tp_el_dof(nelem*P);
-   const mfem::TensorBasisElement * tfe =
+   const mfem::TensorBasisElement *tfe =
       dynamic_cast<const mfem::TensorBasisElement *>(fe);
-   Array<int> dofs;
-   const int stride = compstride == 1 ? fes.GetVDim() : 1;
-   const mfem::Array<int>& dof_map = tfe->GetDofMap();
+   const mfem::Array<int> &dof_map = tfe->GetDofMap();
+   CeedInt compstride =
+      (fes.GetOrdering() == Ordering::byVDIM) ? 1 : fes.GetNDofs();
+   const int stride = (compstride == 1) ? fes.GetVDim() : 1;
+   mfem::Array<int> tp_el_dof(nelem * P), dofs;
+   mfem::Array<bool> tp_el_orients(nelem * P);
+   bool use_orients = false;
 
    for (int i = 0; i < nelem; i++)
    {
+      // No need to handle DofTransformation for tensor-product elements
       const int elem_index = indices[i];
-      fes.GetElementDofs(elem_index, dofs);
-      const int el_offset = P * i;
-      for (int j = 0; j < P; j++)
+      mfem::DofTransformation *dof_trans;
+      if (use_bdr)
       {
-         tp_el_dof[j + el_offset] = stride*dofs[dof_map[j]];
+         dof_trans = fes.GetBdrElementDofs(elem_index, dofs);
       }
-   }
-
-   CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
-                             compstride, (fes.GetVDim())*(fes.GetNDofs()),
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
-}
-
-static void InitLexicoRestrWithIndices(
-   const mfem::FiniteElementSpace &fes,
-   int nelem,
-   const int* indices,
-   Ceed ceed, CeedElemRestriction *restr)
-{
-   const mfem::FiniteElement *fe = fes.GetFE(indices[0]);
-   const int P = fe->GetDof();
-   CeedInt compstride = fes.GetOrdering()==Ordering::byVDIM ? 1 : fes.GetNDofs();
-   mfem::Array<int> tp_el_dof(nelem*P);
-   Array<int> dofs;
-   const int stride = compstride == 1 ? fes.GetVDim() : 1;
-
-   for (int i = 0; i < nelem; i++)
-   {
-      const int elem_index = indices[i];
-      fes.GetElementDofs(elem_index, dofs);
-      const int el_offset = P * i;
+      else
+      {
+         dof_trans = fes.GetElementDofs(elem_index, dofs);
+      }
+      MFEM_VERIFY(!dof_trans,
+                  "Unexpected DofTransformation for lexicographic element "
+                  "restriction.");
       for (int j = 0; j < P; j++)
       {
-         tp_el_dof[j + el_offset] = stride*dofs[j];
+         const int sdid = dof_map[j];  // signed
+         const int did = (sdid >= 0) ? sdid : -1 - sdid;
+         const int sgid = dofs[did];  // signed
+         const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+         tp_el_dof[j + P * i] = stride * gid;
+         tp_el_orients[j + P * i] =
+            (sgid >= 0 && sdid < 0) || (sgid < 0 && sdid >= 0);
+         use_orients = use_orients || tp_el_orients[j + P * i];
       }
    }
 
-   CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
-                             compstride, (fes.GetVDim())*(fes.GetNDofs()),
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
+   if (use_orients)
+   {
+      CeedElemRestrictionCreateOriented(ceed, nelem, P, fes.GetVDim(),
+                                        compstride, fes.GetVDim() * fes.GetNDofs(),
+                                        CEED_MEM_HOST, CEED_COPY_VALUES,
+                                        tp_el_dof.GetData(), tp_el_orients.GetData(),
+                                        restr);
+   }
+   else
+   {
+      CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
+                                compstride, fes.GetVDim() * fes.GetNDofs(),
+                                CEED_MEM_HOST, CEED_COPY_VALUES,
+                                tp_el_dof.GetData(), restr);
+   }
 }
 
-static void InitRestrictionWithIndicesImpl(
-   const mfem::FiniteElementSpace &fes,
-   int nelem,
-   const int* indices,
-   Ceed ceed, CeedElemRestriction *restr)
+static void InitNativeRestrWithIndices(const mfem::FiniteElementSpace &fes,
+                                       bool use_bdr,
+                                       bool is_interp_range,
+                                       int nelem,
+                                       const int *indices,
+                                       Ceed ceed,
+                                       CeedElemRestriction *restr)
 {
-   const mfem::FiniteElement *fe = fes.GetFE(indices[0]);
-   const mfem::TensorBasisElement * tfe =
-      dynamic_cast<const mfem::TensorBasisElement *>(fe);
-   if ( tfe && tfe->GetDofMap().Size()>0 ) // Native ordering using dof_map
+   const int i0 = indices ? indices[0] : 0;
+   const mfem::FiniteElement *fe = use_bdr ? fes.GetBE(i0) : fes.GetFE(i0);
+   const int P = fe->GetDof();
+   CeedInt compstride =
+      (fes.GetOrdering() == Ordering::byVDIM) ? 1 : fes.GetNDofs();
+   const int stride = (compstride == 1) ? fes.GetVDim() : 1;
+   mfem::Array<int> tp_el_dof(nelem * P), dofs;
+   mfem::Array<bool> tp_el_orients;
+   mfem::Array<int> tp_el_curl_orients;
+   mfem::Vector el_trans_j;
+   mfem::DofTransformation *dof_trans = use_bdr ? fes.GetBdrElementDofs(i0, dofs) :
+                                        fes.GetElementDofs(i0, dofs);
+   if (!dof_trans || dof_trans->IsEmpty())
    {
-      InitNativeRestrWithIndices(fes, nelem, indices, ceed, restr);
+      tp_el_orients.SetSize(nelem * P);
    }
-   else  // Lexicographic ordering
+   else
    {
-      InitLexicoRestrWithIndices(fes, nelem, indices, ceed, restr);
+      tp_el_curl_orients.SetSize(nelem * P * 3, 0.0);
+      el_trans_j.SetSize(P);
    }
-}
 
-static void InitCoeffRestrictionWithIndicesImpl(
-   const mfem::FiniteElementSpace &fes,
-   int nelem,
-   const int* indices,
-   int nquads,
-   int ncomp,
-   Ceed ceed,
-   CeedElemRestriction *restr)
-{
-   mfem::Array<int> tp_el_dof(nelem*nquads);
-   const int stride_quad = ncomp;
-   const int stride_elem = ncomp*nquads;
-   // TODO generalize to support different #quads
    for (int i = 0; i < nelem; i++)
    {
-      const int elem_index = indices[i];
-      const int el_offset = elem_index * stride_elem;
-      for (int j = 0; j < nquads; j++)
+      const int elem_index = indices ? indices[i] : i;
+      if (use_bdr)
+      {
+         dof_trans = fes.GetBdrElementDofs(elem_index, dofs);
+      }
+      else
       {
-         tp_el_dof[j + nquads * i] = j * stride_quad + el_offset;
+         dof_trans = fes.GetElementDofs(elem_index, dofs);
+      }
+      if (!dof_trans || dof_trans->IsEmpty())
+      {
+         for (int j = 0; j < P; j++)
+         {
+            const int sgid = dofs[j];  // signed
+            const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+            tp_el_dof[j + P * i] = stride * gid;
+            tp_el_orients[j + P * i] = (sgid < 0);
+         }
+      }
+      else
+      {
+         for (int j = 0; j < P; j++)
+         {
+            const int sgid = dofs[j];  // signed
+            const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+            tp_el_dof[j + P * i] = stride * gid;
+
+            // Fill column j of element tridiagonal matrix tp_el_curl_orients
+            el_trans_j = 0.0;
+            el_trans_j(j) = 1.0;
+            if (is_interp_range)
+            {
+               dof_trans->InvTransformDual(el_trans_j);
+            }
+            else
+            {
+               dof_trans->InvTransformPrimal(el_trans_j);
+            }
+            el_trans_j *= (sgid < 0) ? -1.0 : 1.0;
+            tp_el_curl_orients[3 * (j + 0 + P * i) + 1] = el_trans_j(j + 0);
+            if (j > 0)
+            {
+               tp_el_curl_orients[3 * (j - 1 + P * i) + 2] = el_trans_j(j - 1);
+            }
+            if (j < P - 1)
+            {
+               tp_el_curl_orients[3 * (j + 1 + P * i) + 0] = el_trans_j(j + 1);
+            }
+#ifdef MFEM_DEBUG
+            int nnz = 0;
+            for (int k = 0; k < P; k++)
+            {
+               if (k < j - 1 && k > j + 1 && el_trans_j(k) != 0.0) { nnz++; }
+            }
+            MFEM_ASSERT(nnz == 0,
+                        "Element transformation matrix is not tridiagonal at column "
+                        << j << " (nnz = " << nnz << ")!");
+#endif
+         }
       }
    }
-   CeedElemRestrictionCreate(ceed, nelem, nquads, ncomp, 1,
-                             ncomp*fes.GetNE()*nquads,
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
-}
 
-void InitStridedRestriction(const mfem::FiniteElementSpace &fes,
-                            CeedInt nelem, CeedInt nqpts, CeedInt qdatasize,
-                            const CeedInt *strides,
-                            CeedElemRestriction *restr)
-{
-   RestrKey restr_key(&fes, nelem, nqpts, qdatasize, restr_type::Strided);
-   auto restr_itr = mfem::internal::ceed_restr_map.find(restr_key);
-   if (restr_itr == mfem::internal::ceed_restr_map.end())
+   if (tp_el_curl_orients.Size())
    {
-      CeedElemRestrictionCreateStrided(mfem::internal::ceed, nelem, nqpts, qdatasize,
-                                       nelem*nqpts*qdatasize,
-                                       strides,
-                                       restr);
-      // Will be automatically destroyed when @a fes gets destroyed.
-      mfem::internal::ceed_restr_map[restr_key] = *restr;
+      CeedElemRestrictionCreateCurlOriented(ceed, nelem, P, fes.GetVDim(),
+                                            compstride, fes.GetVDim() * fes.GetNDofs(),
+                                            CEED_MEM_HOST, CEED_COPY_VALUES,
+                                            tp_el_dof.GetData(), tp_el_curl_orients.GetData(),
+                                            restr);
+   }
+   else if (tp_el_orients.Size())
+   {
+      CeedElemRestrictionCreateOriented(ceed, nelem, P, fes.GetVDim(),
+                                        compstride, fes.GetVDim() * fes.GetNDofs(),
+                                        CEED_MEM_HOST, CEED_COPY_VALUES,
+                                        tp_el_dof.GetData(), tp_el_orients.GetData(),
+                                        restr);
    }
    else
    {
-      *restr = restr_itr->second;
+      CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
+                                compstride, fes.GetVDim() * fes.GetNDofs(),
+                                CEED_MEM_HOST, CEED_COPY_VALUES,
+                                tp_el_dof.GetData(), restr);
    }
 }
 
 void InitRestriction(const FiniteElementSpace &fes,
+                     bool use_bdr,
+                     int nelem,
+                     const int *indices,
                      Ceed ceed,
                      CeedElemRestriction *restr)
 {
-   // Check for FES -> basis, restriction in hash tables
-   const mfem::FiniteElement *fe = fes.GetFE(0);
+   // Check for fes -> restriction in hash table
+   // {-1, -1, -1} is unique from CEED_STRIDES_BACKEND for strided restrictions
+   const mfem::FiniteElement *fe;
+   if (indices)
+   {
+      fe = use_bdr ? fes.GetBE(indices[0]) : fes.GetFE(indices[0]);
+   }
+   else
+   {
+      fe = use_bdr ? fes.GetBE(0) : fes.GetFE(0);
+   }
    const int P = fe->GetDof();
-   const int nelem = fes.GetNE();
    const int ncomp = fes.GetVDim();
-   RestrKey restr_key(&fes, nelem, P, ncomp, restr_type::Standard);
+   const mfem::TensorBasisElement *tfe =
+      dynamic_cast<const mfem::TensorBasisElement *>(fe);
+   const bool vector = fe->GetRangeType() == mfem::FiniteElement::VECTOR;
+   const RestrType type = (tfe && tfe->GetDofMap().Size() > 0 && !vector) ?
+                          RestrType::Lexico : RestrType::Native;
+   RestrKey restr_key(&fes, {nelem, P, ncomp}, {-1, -1, -1}, type);
    auto restr_itr = mfem::internal::ceed_restr_map.find(restr_key);
 
    // Init or retrieve key values
    if (restr_itr == mfem::internal::ceed_restr_map.end())
    {
-      InitRestrictionImpl(fes, ceed, restr);
+      if (indices)
+      {
+         if (type == RestrType::Lexico)
+         {
+            // Lexicographic ordering using dof_map
+            InitLexicoRestrWithIndices(fes, use_bdr, nelem, indices,
+                                       ceed, restr);
+         }
+         else
+         {
+            // Native ordering
+            InitNativeRestrWithIndices(fes, use_bdr, false, nelem, indices,
+                                       ceed, restr);
+         }
+      }
+      else
+      {
+         mfem::Array<int> dofs;
+         mfem::DofTransformation *dof_trans = use_bdr ? fes.GetBdrElementDofs(0, dofs) :
+                                              fes.GetElementDofs(0, dofs);
+         if (type == RestrType::Lexico)
+         {
+            // Lexicographic ordering using dof_map
+            MFEM_VERIFY(!dof_trans,
+                        "Unexpected DofTransformation for lexicographic element "
+                        "restriction.");
+            InitLexicoRestr(fes, use_bdr, nelem, ceed, restr);
+         }
+         else if (!dof_trans || dof_trans->IsEmpty())
+         {
+            // Native ordering without dof_trans
+            InitNativeRestr(fes, use_bdr, nelem, ceed, restr);
+         }
+         else
+         {
+            // Native ordering with dof_trans
+            InitNativeRestrWithIndices(fes, use_bdr, false, nelem, nullptr,
+                                       ceed, restr);
+         }
+      }
       mfem::internal::ceed_restr_map[restr_key] = *restr;
    }
    else
@@ -244,48 +391,116 @@ void InitRestriction(const FiniteElementSpace &fes,
    }
 }
 
-void InitRestrictionWithIndices(const FiniteElementSpace &fes,
-                                int nelem,
-                                const int* indices,
-                                Ceed ceed,
-                                CeedElemRestriction *restr)
+void InitInterpolatorRestrictions(const FiniteElementSpace &trial_fes,
+                                  const FiniteElementSpace &test_fes,
+                                  int nelem,
+                                  const int *indices,
+                                  Ceed ceed,
+                                  CeedElemRestriction *trial_restr,
+                                  CeedElemRestriction *test_restr)
 {
-   // Check for FES -> basis, restriction in hash tables
-   const mfem::FiniteElement *fe = fes.GetFE(indices[0]);
-   const int P = fe->GetDof();
-   const int ncomp = fes.GetVDim();
-   RestrKey restr_key(&fes, nelem, P, ncomp, restr_type::Standard);
-   auto restr_itr = mfem::internal::ceed_restr_map.find(restr_key);
-
-   // Init or retrieve key values
-   if (restr_itr == mfem::internal::ceed_restr_map.end())
+   // Check for fes -> restriction in hash table
+   // {-1, -1, -1} is unique from CEED_STRIDES_BACKEND for strided restrictions
+   const mfem::FiniteElement *trial_fe, *test_fe;
+   if (indices)
    {
-      InitRestrictionWithIndicesImpl(fes, nelem, indices, ceed, restr);
-      mfem::internal::ceed_restr_map[restr_key] = *restr;
+      trial_fe = trial_fes.GetFE(indices[0]);
+      test_fe = test_fes.GetFE(indices[0]);
    }
    else
    {
-      *restr = restr_itr->second;
+      trial_fe = trial_fes.GetFE(0);
+      test_fe = test_fes.GetFE(0);
+   }
+   for (int s = 0; s < 2; s++)
+   {
+      // The restriction for the test space is slightly different as the output
+      // is a primal vector instead of a dual vector, and lexicographic ordering
+      // is never used (no use of tensor-product basis)
+      CeedElemRestriction *restr = (s == 0) ? trial_restr : test_restr;
+      const FiniteElementSpace &fes = (s == 0) ? trial_fes : test_fes;
+      const mfem::FiniteElement *fe = (s == 0) ? trial_fe : test_fe;
+      const int P = fe->GetDof();
+      const int ncomp = fes.GetVDim();
+      mfem::Array<int> dofs;
+      mfem::DofTransformation *dof_trans =
+         indices ? fes.GetElementDofs(indices[0], dofs) : fes.GetElementDofs(0, dofs);
+      const RestrType type = (dof_trans && s > 0) ? RestrType::NativeRange :
+                             RestrType::Native;
+      RestrKey restr_key(&fes, {nelem, P, ncomp}, {-1, -1, -1}, type);
+      auto restr_itr = mfem::internal::ceed_restr_map.find(restr_key);
+
+      // Init or retrieve key values
+      if (restr_itr == mfem::internal::ceed_restr_map.end())
+      {
+         if (indices)
+         {
+            if (type == RestrType::Lexico)
+            {
+               // Lexicographic ordering using dof_map
+               MFEM_VERIFY(!dof_trans,
+                           "Unexpected DofTransformation for lexicographic element "
+                           "restriction.");
+               InitLexicoRestrWithIndices(fes, false, nelem, indices,
+                                          ceed, restr);
+            }
+            else
+            {
+               // Native ordering
+               InitNativeRestrWithIndices(fes, false, (s > 0), nelem, indices,
+                                          ceed, restr);
+            }
+         }
+         else
+         {
+            if (type == RestrType::Lexico)
+            {
+               // Lexicographic ordering using dof_map
+               MFEM_VERIFY(!dof_trans,
+                           "Unexpected DofTransformation for lexicographic element "
+                           "restriction.");
+               InitLexicoRestr(fes, false, nelem, ceed, restr);
+            }
+            else if (!dof_trans || dof_trans->IsEmpty())
+            {
+               // Native ordering without dof_trans
+               InitNativeRestr(fes, false, nelem, ceed, restr);
+            }
+            else
+            {
+               // Native ordering with dof_trans
+               InitNativeRestrWithIndices(fes, false, (s > 0), nelem, nullptr,
+                                          ceed, restr);
+            }
+         }
+         mfem::internal::ceed_restr_map[restr_key] = *restr;
+      }
+      else
+      {
+         *restr = restr_itr->second;
+      }
    }
 }
 
-void InitCoeffRestrictionWithIndices(const FiniteElementSpace &fes,
-                                     int nelem,
-                                     const int* indices,
-                                     int nquads,
-                                     int ncomp,
-                                     Ceed ceed,
-                                     CeedElemRestriction *restr)
+void InitStridedRestriction(const mfem::FiniteElementSpace &fes,
+                            CeedInt nelem,
+                            CeedInt nqpts,
+                            CeedInt qdatasize,
+                            const CeedInt strides[3],
+                            Ceed ceed,
+                            CeedElemRestriction *restr)
 {
-   // Check for FES -> basis, restriction in hash tables
-   RestrKey restr_key(&fes, nelem, nquads, ncomp, restr_type::Coeff);
+   // Check for fes -> restriction in hash table
+   RestrKey restr_key(&fes, {nelem, nqpts, qdatasize},
+   {strides[0], strides[1], strides[2]}, RestrType::Strided);
    auto restr_itr = mfem::internal::ceed_restr_map.find(restr_key);
 
    // Init or retrieve key values
    if (restr_itr == mfem::internal::ceed_restr_map.end())
    {
-      InitCoeffRestrictionWithIndicesImpl(fes, nelem, indices, nquads, ncomp,
-                                          ceed, restr);
+      CeedElemRestrictionCreateStrided(ceed, nelem, nqpts, qdatasize,
+                                       nelem * nqpts * qdatasize, strides,
+                                       restr);
       mfem::internal::ceed_restr_map[restr_key] = *restr;
    }
    else
diff --git a/fem/ceed/interface/restriction.hpp b/fem/ceed/interface/restriction.hpp
index 221716b39..612754dc7 100644
--- a/fem/ceed/interface/restriction.hpp
+++ b/fem/ceed/interface/restriction.hpp
@@ -12,6 +12,7 @@
 #ifndef MFEM_LIBCEED_RESTR
 #define MFEM_LIBCEED_RESTR
 
+#include "../../fespace.hpp"
 #include "ceed.hpp"
 
 namespace mfem
@@ -21,65 +22,89 @@ namespace ceed
 {
 
 #ifdef MFEM_USE_CEED
-/** @brief Initialize a CeedElemRestriction for non-mixed meshes.
 
-    @param[in] fes Input finite element space.
-    @param[in] ceed Input Ceed object.
-    @param[out] restr The address of the initialized CeedElemRestriction object.
-*/
+/** @brief Initialize a CeedElemRestriction based on an
+    mfem::FiniteElementSpace @a fes and an optional list of @a nelem elements
+    of indices @a indices.
+
+    @param[in] fes The finite element space.
+    @param[in] use_bdr Create the basis and restriction for boundary elements.
+    @param[in] nelem The number of elements.
+    @param[in] indices The indices of the elements of same type in the
+                       `FiniteElementSpace`. If `indices == nullptr`, assumes
+                       that the `FiniteElementSpace` is not mixed.
+    @param[in] ceed The Ceed object.
+    @param[out] restr The `CeedElemRestriction` to initialize. */
 void InitRestriction(const FiniteElementSpace &fes,
+                     bool use_bdr,
+                     int nelem,
+                     const int *indices,
                      Ceed ceed,
                      CeedElemRestriction *restr);
 
-/** @brief Initialize a CeedElemRestriction for mixed meshes.
+inline void InitRestriction(const FiniteElementSpace &fes,
+                            bool use_bdr,
+                            Ceed ceed,
+                            CeedElemRestriction *restr)
+{
+   InitRestriction(fes, use_bdr, use_bdr ? fes.GetNBE() : fes.GetNE(),
+                   nullptr, ceed, restr);
+}
 
-    @param[in] fes The finite element space.
-    @param[in] ceed The Ceed object.
+/** @brief Initialize a pair of CeedElemRestriction objects based on a
+    mfem::FiniteElementSpace @a trial_fes and @a test_fes, and an optional list
+    of @a nelem elements of indices @a indices.
+
+    @param[in] trial_fes The trial finite element space.
+    @param[in] test_fes The test finite element space.
     @param[in] nelem The number of elements.
     @param[in] indices The indices of the elements of same type in the
-                       `FiniteElementSpace`.
-    @param[out] restr The `CeedElemRestriction` to initialize. */
-void InitRestrictionWithIndices(const FiniteElementSpace &fes,
-                                int nelem,
-                                const int* indices,
-                                Ceed ceed,
-                                CeedElemRestriction *restr);
+                       `FiniteElementSpace`. If `indices == nullptr`, assumes
+                       that the `FiniteElementSpace` is not mixed.
+    @param[in] ceed The Ceed object.
+    @param[out] trial_restr The `CeedElemRestriction` to initialize for the
+                            trial space.
+    @param[out] test_restr The `CeedElemRestriction` to initialize for the
+                           test space. */
+void InitInterpolatorRestrictions(const FiniteElementSpace &trial_fes,
+                                  const FiniteElementSpace &test_fes,
+                                  int nelem,
+                                  const int *indices,
+                                  Ceed ceed,
+                                  CeedElemRestriction *trial_restr,
+                                  CeedElemRestriction *test_restr);
+
+inline void InitInterpolatorRestrictions(const FiniteElementSpace &trial_fes,
+                                         const FiniteElementSpace &test_fes,
+                                         Ceed ceed,
+                                         CeedElemRestriction *trial_restr,
+                                         CeedElemRestriction *test_restr)
+{
+   InitInterpolatorRestrictions(trial_fes, test_fes, trial_fes.GetNE(),
+                                nullptr, ceed, trial_restr, test_restr);
+}
 
-/** @brief Initialize a strided CeedElemRestriction
+/** @brief Initialize a strided CeedElemRestriction.
 
     @param[in] fes Input finite element space.
     @param[in] nelem is the number of elements.
     @param[in] nqpts is the total number of quadrature points.
     @param[in] qdatasize is the number of data per quadrature point.
     @param[in] strides Array for strides between [nodes, components, elements].
-    Data for node i, component j, element k can be found in the L-vector at
-    index i*strides[0] + j*strides[1] + k*strides[2]. CEED_STRIDES_BACKEND may
-    be used with vectors created by a Ceed backend.
+                       Data for node i, component j, element k can be found in
+                       the L-vector at index i*strides[0] + j*strides[1] +
+                       k*strides[2]. CEED_STRIDES_BACKEND may be used with
+                       vectors created by a Ceed backend.
+    @param[in] ceed The Ceed object.
     @param[out] restr The `CeedElemRestriction` to initialize. */
 void InitStridedRestriction(const mfem::FiniteElementSpace &fes,
-                            CeedInt nelem, CeedInt nqpts, CeedInt qdatasize,
-                            const CeedInt *strides,
+                            CeedInt nelem,
+                            CeedInt nqpts,
+                            CeedInt qdatasize,
+                            const CeedInt strides[3],
+                            Ceed ceed,
                             CeedElemRestriction *restr);
 
-/** @brief Initialize a CeedElemRestriction for a mfem::Coefficient on a mixed
-    mesh.
-
-    @param[in] fes The finite element space.
-    @param[in] nelem is the number of elements.
-    @param[in] indices The indices of the elements of same type in the
-                       `FiniteElementSpace`.
-    @param[in] nquads is the total number of quadrature points
-    @param[in] ncomp is the number of data per quadrature point
-    @param[in] ceed The Ceed object.
-    @param[out] restr The `CeedElemRestriction` to initialize. */
-void InitCoeffRestrictionWithIndices(const FiniteElementSpace &fes,
-                                     int nelem,
-                                     const int* indices,
-                                     int nquads,
-                                     int ncomp,
-                                     Ceed ceed,
-                                     CeedElemRestriction *restr);
-
 #endif
 
 } // namespace ceed
diff --git a/fem/ceed/interface/util.cpp b/fem/ceed/interface/util.cpp
index b65fd2197..4eecc7841 100644
--- a/fem/ceed/interface/util.cpp
+++ b/fem/ceed/interface/util.cpp
@@ -9,14 +9,11 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
+#include "util.hpp"
+
 #include "../../../general/device.hpp"
-#include "../../../fem/gridfunc.hpp"
 #include "../../../linalg/dtensor.hpp"
-
-#include "basis.hpp"
-#include "restriction.hpp"
-#include "ceed.hpp"
-
+#include "../../gridfunc.hpp"
 #include <sys/types.h>
 #include <sys/stat.h>
 #if !defined(_WIN32) || !defined(_MSC_VER)
@@ -44,7 +41,7 @@ void RemoveBasisAndRestriction(const mfem::FiniteElementSpace *fes)
    auto itb = mfem::internal::ceed_basis_map.begin();
    while (itb != mfem::internal::ceed_basis_map.end())
    {
-      if (std::get<0>(itb->first)==fes)
+      if (std::get<0>(itb->first) == fes)
       {
          CeedBasisDestroy(&itb->second);
          itb = mfem::internal::ceed_basis_map.erase(itb);
@@ -57,7 +54,7 @@ void RemoveBasisAndRestriction(const mfem::FiniteElementSpace *fes)
    auto itr = mfem::internal::ceed_restr_map.begin();
    while (itr != mfem::internal::ceed_restr_map.end())
    {
-      if (std::get<0>(itr->first)==fes)
+      if (std::get<0>(itr->first) == fes)
       {
          CeedElemRestrictionDestroy(&itr->second);
          itr = mfem::internal::ceed_restr_map.erase(itr);
@@ -78,78 +75,41 @@ void InitVector(const mfem::Vector &v, CeedVector &cv)
    CeedScalar *cv_ptr;
    CeedMemType mem;
    CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
-      cv_ptr = const_cast<CeedScalar*>(v.Read());
+      cv_ptr = const_cast<CeedScalar *>(v.Read());
    }
    else
    {
-      cv_ptr = const_cast<CeedScalar*>(v.HostRead());
+      cv_ptr = const_cast<CeedScalar *>(v.HostRead());
       mem = CEED_MEM_HOST;
    }
    CeedVectorSetArray(cv, mem, CEED_USE_POINTER, cv_ptr);
 }
 
-void InitBasisAndRestriction(const FiniteElementSpace &fes,
-                             const IntegrationRule &irm,
-                             Ceed ceed, CeedBasis *basis,
-                             CeedElemRestriction *restr)
-{
-   InitBasis(fes, irm, ceed, basis);
-   InitRestriction(fes, ceed, restr);
-}
-
-void InitBasisAndRestrictionWithIndices(const FiniteElementSpace &fes,
-                                        const IntegrationRule &irm,
-                                        int nelem,
-                                        const int* indices,
-                                        Ceed ceed, CeedBasis *basis,
-                                        CeedElemRestriction *restr)
-{
-   InitBasisWithIndices(fes, irm, nelem, indices, ceed, basis);
-   InitRestrictionWithIndices(fes, nelem, indices, ceed, restr);
-}
-
-void InitBasisAndRestriction(const FiniteElementSpace &fes,
-                             const IntegrationRule &irm,
-                             int nelem,
-                             const int* indices,
-                             Ceed ceed, CeedBasis *basis,
-                             CeedElemRestriction *restr)
-{
-   if (indices)
-   {
-      InitBasisAndRestrictionWithIndices(fes,irm,nelem,indices,ceed,basis,restr);
-   }
-   else
-   {
-      InitBasisAndRestriction(fes,irm,ceed,basis,restr);
-   }
-}
-
 // Assumes a tensor-product operator with one active field
 int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field)
 {
    int ierr;
    Ceed ceed;
-   ierr = CeedOperatorGetCeed(oper, &ceed); CeedChk(ierr);
+   ierr = CeedOperatorGetCeed(oper, &ceed); PCeedChk(ierr);
 
    CeedQFunction qf;
    bool isComposite;
-   ierr = CeedOperatorIsComposite(oper, &isComposite); CeedChk(ierr);
+   ierr = CeedOperatorIsComposite(oper, &isComposite); PCeedChk(ierr);
    CeedOperator *subops;
    if (isComposite)
    {
 #if CEED_VERSION_GE(0, 10, 2)
-      ierr = CeedCompositeOperatorGetSubList(oper, &subops); CeedChk(ierr);
+      ierr = CeedCompositeOperatorGetSubList(oper, &subops); PCeedChk(ierr);
 #else
-      ierr = CeedOperatorGetSubList(oper, &subops); CeedChk(ierr);
+      ierr = CeedOperatorGetSubList(oper, &subops); PCeedChk(ierr);
 #endif
-      ierr = CeedOperatorGetQFunction(subops[0], &qf); CeedChk(ierr);
+      ierr = CeedOperatorGetQFunction(subops[0], &qf); PCeedChk(ierr);
    }
    else
    {
-      ierr = CeedOperatorGetQFunction(oper, &qf); CeedChk(ierr);
+      ierr = CeedOperatorGetQFunction(oper, &qf); PCeedChk(ierr);
    }
    CeedInt numinputfields, numoutputfields;
    ierr = CeedQFunctionGetNumArgs(qf, &numinputfields, &numoutputfields);
@@ -157,12 +117,12 @@ int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field)
    if (isComposite)
    {
       ierr = CeedOperatorGetFields(subops[0], &numinputfields, &inputfields,
-                                   &numoutputfields, NULL); CeedChk(ierr);
+                                   &numoutputfields, NULL); PCeedChk(ierr);
    }
    else
    {
       ierr = CeedOperatorGetFields(oper, &numinputfields, &inputfields,
-                                   &numoutputfields, NULL); CeedChk(ierr);
+                                   &numoutputfields, NULL); PCeedChk(ierr);
    }
 
    CeedVector if_vector;
@@ -170,7 +130,7 @@ int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field)
    int found_index = -1;
    for (int i = 0; i < numinputfields; ++i)
    {
-      ierr = CeedOperatorFieldGetVector(inputfields[i], &if_vector); CeedChk(ierr);
+      ierr = CeedOperatorFieldGetVector(inputfields[i], &if_vector); PCeedChk(ierr);
       if (if_vector == CEED_VECTOR_ACTIVE)
       {
          if (found)
@@ -190,66 +150,6 @@ int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field)
    return 0;
 }
 
-template <>
-const IntegrationRule & GetRule<MassIntegrator>(
-   const MassIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return MassIntegrator::GetRule(trial_fe, test_fe, trans);
-}
-
-template <>
-const IntegrationRule & GetRule<VectorMassIntegrator>(
-   const VectorMassIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return MassIntegrator::GetRule(trial_fe, test_fe, trans);
-}
-
-template <>
-const IntegrationRule & GetRule<ConvectionIntegrator>(
-   const ConvectionIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return ConvectionIntegrator::GetRule(trial_fe, trans);
-}
-
-template <>
-const IntegrationRule & GetRule<VectorConvectionNLFIntegrator>(
-   const VectorConvectionNLFIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return VectorConvectionNLFIntegrator::GetRule(trial_fe, trans);
-}
-
-template <>
-const IntegrationRule & GetRule<DiffusionIntegrator>(
-   const DiffusionIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return DiffusionIntegrator::GetRule(trial_fe, test_fe);
-}
-
-template <>
-const IntegrationRule & GetRule<VectorDiffusionIntegrator>(
-   const VectorDiffusionIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return DiffusionIntegrator::GetRule(trial_fe, test_fe);
-}
-
 std::string ceed_path;
 
 const std::string &GetCeedPath()
diff --git a/fem/ceed/interface/util.hpp b/fem/ceed/interface/util.hpp
index 17ae4adae..823cd09e3 100644
--- a/fem/ceed/interface/util.hpp
+++ b/fem/ceed/interface/util.hpp
@@ -12,15 +12,15 @@
 #ifndef MFEM_LIBCEED_UTIL
 #define MFEM_LIBCEED_UTIL
 
-#include "../../../config/config.hpp"
+#include <array>
 #include <tuple>
 #include <unordered_map>
 #include <string>
-
+#include "../../../general/error.hpp"
 #include "ceed.hpp"
 #ifdef MFEM_USE_CEED
 #include <ceed/hash.h>
-#include <ceed/backend.h>  // for CeedOperatorField
+#include <ceed/backend.h>
 #endif
 
 namespace mfem
@@ -40,7 +40,7 @@ namespace ceed
 {
 
 /** @brief Remove from ceed_basis_map and ceed_restr_map the entries associated
-    with the given @a fes. */
+    with the given @a fes when @a fes gets destroyed. */
 void RemoveBasisAndRestriction(const mfem::FiniteElementSpace *fes);
 
 #ifdef MFEM_USE_CEED
@@ -48,7 +48,7 @@ void RemoveBasisAndRestriction(const mfem::FiniteElementSpace *fes);
 #define PCeedChk(err) do {                                                     \
      if ((err))                                                                \
      {                                                                         \
-        const char * errmsg;                                                   \
+        const char *errmsg;                                                    \
         CeedGetErrorMessage(internal::ceed, &errmsg);                          \
         MFEM_ABORT(errmsg);                                                    \
      }                                                                         \
@@ -57,91 +57,54 @@ void RemoveBasisAndRestriction(const mfem::FiniteElementSpace *fes);
 /// Initialize a CeedVector from an mfem::Vector
 void InitVector(const mfem::Vector &v, CeedVector &cv);
 
-/** @brief Initialize a CeedBasis and a CeedElemRestriction based on an
-    mfem::FiniteElementSpace @a fes, and an mfem::IntegrationRule @a ir.
-
-    @param[in] fes The finite element space.
-    @param[in] ir The integration rule.
-    @param[in] ceed The Ceed object.
-    @param[out] basis The `CeedBasis` to initialize.
-    @param[out] restr The `CeedElemRestriction` to initialize.
-
-    @warning Only for non-mixed finite element spaces. */
-void InitBasisAndRestriction(const mfem::FiniteElementSpace &fes,
-                             const mfem::IntegrationRule &ir,
-                             Ceed ceed, CeedBasis *basis,
-                             CeedElemRestriction *restr);
-
-/** @brief Initialize a CeedBasis and a CeedElemRestriction based on an
-    mfem::FiniteElementSpace @a fes, and an mfem::IntegrationRule @a ir,
-    and a list of @a nelem elements of indices @a indices.
-
-    @param[in] fes The finite element space.
-    @param[in] ir The integration rule.
-    @param[in] nelem The number of elements.
-    @param[in] indices The indices of the elements of same type in the
-                       `FiniteElementSpace`. If `indices == nullptr`, assumes
-                       that the `FiniteElementSpace` is not mixed.
-    @param[in] ceed The Ceed object.
-    @param[out] basis The `CeedBasis` to initialize.
-    @param[out] restr The `CeedElemRestriction` to initialize. */
-void InitBasisAndRestriction(const FiniteElementSpace &fes,
-                             const IntegrationRule &ir,
-                             int nelem,
-                             const int* indices,
-                             Ceed ceed, CeedBasis *basis,
-                             CeedElemRestriction *restr);
-
 int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field);
 
-
-template <typename Integrator>
-const IntegrationRule & GetRule(
-   const Integrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &Trans);
-
-/// Return the path to the libCEED q-function headers.
+/// Return the path to the libCEED QFunction headers.
 const std::string &GetCeedPath();
 
 // Hash table for CeedBasis
-using BasisKey = std::tuple<const mfem::FiniteElementSpace*,
-      const mfem::IntegrationRule*,
-      int, int, int>;
+using BasisKey =
+   std::tuple<const mfem::FiniteElementSpace *, const mfem::FiniteElementSpace *,
+   const mfem::IntegrationRule *, std::array<int, 3>>;
 struct BasisHash
 {
-   std::size_t operator()(const BasisKey& k) const
+   std::size_t operator()(const BasisKey &k) const
    {
       return CeedHashCombine(
                 CeedHashCombine(
-                   CeedHashInt(reinterpret_cast<CeedHash64_t>(std::get<0>(k))),
-                   CeedHashInt(reinterpret_cast<CeedHash64_t>(std::get<1>(k)))),
+                   CeedHashCombine(
+                      CeedHashInt(reinterpret_cast<CeedHash64_t>(std::get<0>(k))),
+                      CeedHashInt(reinterpret_cast<CeedHash64_t>(std::get<1>(k)))),
+                   CeedHashInt(reinterpret_cast<CeedHash64_t>(std::get<2>(k)))),
                 CeedHashCombine(
-                   CeedHashCombine(CeedHashInt(std::get<2>(k)),
-                                   CeedHashInt(std::get<3>(k))),
-                   CeedHashInt(std::get<4>(k))));
+                   CeedHashCombine(CeedHashInt(std::get<3>(k)[0]),
+                                   CeedHashInt(std::get<3>(k)[1])),
+                   CeedHashInt(std::get<3>(k)[2])));
    }
 };
 using BasisMap = std::unordered_map<const BasisKey, CeedBasis, BasisHash>;
 
-enum restr_type {Standard, Strided, Coeff};
-
 // Hash table for CeedElemRestriction
 using RestrKey =
-   std::tuple<const mfem::FiniteElementSpace*, int, int, int, int>;
+   std::tuple<const mfem::FiniteElementSpace *, std::array<int, 3>,
+   std::array<int, 3>, int>;
 struct RestrHash
 {
-   std::size_t operator()(const RestrKey& k) const
+   std::size_t operator()(const RestrKey &k) const
    {
       return CeedHashCombine(
+                CeedHashInt(reinterpret_cast<CeedHash64_t>(std::get<0>(k))),
                 CeedHashCombine(
                    CeedHashCombine(
-                      CeedHashInt(reinterpret_cast<CeedHash64_t>(std::get<0>(k))),
-                      CeedHashInt(std::get<1>(k))),
-                   CeedHashCombine(CeedHashInt(std::get<2>(k)),
-                                   CeedHashInt(std::get<3>(k)))),
-                CeedHashInt(std::get<4>(k)));
+                      CeedHashCombine(
+                         CeedHashCombine(CeedHashInt(std::get<1>(k)[0]),
+                                         CeedHashInt(std::get<1>(k)[1])),
+                         CeedHashInt(std::get<1>(k)[2])),
+                      CeedHashCombine(
+                         CeedHashCombine(CeedHashInt(std::get<2>(k)[0]),
+                                         CeedHashInt(std::get<2>(k)[1])),
+                         CeedHashInt(std::get<2>(k)[2]))),
+                   CeedHashInt(std::get<3>(k))));
    }
 };
 using RestrMap =
@@ -156,7 +119,7 @@ namespace internal
 
 #ifdef MFEM_USE_CEED
 /** @warning These maps have a tendency to create bugs when adding new "types"
-    of CeedBasis and CeedElemRestriction. */
+    of CeedBasis and CeedElemRestriction. Definitions in general/device.cpp. */
 extern ceed::BasisMap ceed_basis_map;
 extern ceed::RestrMap ceed_restr_map;
 #endif
diff --git a/fem/ceed/solvers/algebraic.cpp b/fem/ceed/solvers/algebraic.cpp
index 280a19960..72eca5c2e 100644
--- a/fem/ceed/solvers/algebraic.cpp
+++ b/fem/ceed/solvers/algebraic.cpp
@@ -11,14 +11,16 @@
 
 #include "algebraic.hpp"
 
+#include "../../../general/forall.hpp"
 #include "../../bilinearform.hpp"
 #include "../../fespace.hpp"
 #include "../../pfespace.hpp"
-#include "../../../general/forall.hpp"
-#include "solvers-atpmg.hpp"
-#include "full-assembly.hpp"
 #include "../interface/restriction.hpp"
-#include "../interface/ceed.hpp"
+#include "../interface/util.hpp"
+#include "solvers-atpmg.hpp"
+#ifdef MFEM_USE_CEED
+#include <ceed/backend.h>
+#endif
 
 namespace mfem
 {
@@ -28,6 +30,13 @@ namespace ceed
 
 #ifdef MFEM_USE_CEED
 
+int CeedInternalFree(void *p)
+{
+   free(*(void **)p);
+   *(void **)p = NULL;
+   return 0;
+}
+
 /** Wraps a CeedOperator in an mfem::Operator, with essential boundary
     conditions and a prolongation operator for parallel application. */
 class ConstrainedOperator : public mfem::Operator
@@ -91,29 +100,22 @@ const mfem::Operator *ConstrainedOperator::GetProlongation() const
    return P;
 }
 
-/// assumes a square operator (you could do rectangular, you'd have
-/// to find separate active input and output fields/restrictions)
-int CeedOperatorGetSize(CeedOperator oper, CeedInt * size)
-{
-   CeedSize in_len, out_len;
-   int ierr = CeedOperatorGetActiveVectorLengths(oper, &in_len, &out_len);
-   CeedChk(ierr);
-   *size = (CeedInt)in_len;
-   MFEM_VERIFY(in_len == out_len, "not a square CeedOperator");
-   MFEM_VERIFY(in_len == *size, "size overflow");
-   return 0;
-}
-
 Solver *BuildSmootherFromCeed(ConstrainedOperator &op, bool chebyshev)
 {
    int ierr;
+
    CeedOperator ceed_op = op.GetCeedOperator();
    const Array<int> &ess_tdofs = op.GetEssentialTrueDofs();
    const mfem::Operator *P = op.GetProlongation();
+
    // Assemble the a local diagonal, in the sense of L-vector
    CeedVector diagceed;
-   CeedInt length;
-   ierr = CeedOperatorGetSize(ceed_op, &length); PCeedChk(ierr);
+   CeedSize l_in, l_out;
+   ierr = CeedOperatorGetActiveVectorLengths(ceed_op, &l_in, &l_out);
+   PCeedChk(ierr);
+   MFEM_VERIFY(l_in == l_out, "Not a square CeedOperator.");
+   MFEM_VERIFY((CeedInt)l_in == l_in, "Size overflow.");
+   CeedInt length = l_in;
    ierr = CeedVectorCreate(internal::ceed, length, &diagceed); PCeedChk(ierr);
    CeedMemType mem;
    ierr = CeedGetPreferredMemType(internal::ceed, &mem); PCeedChk(ierr);
@@ -239,20 +241,18 @@ CeedOperator CreateCeedCompositeOperatorFromBilinearForm(BilinearForm &form)
    int ierr;
    CeedOperator op;
    ierr = CeedCompositeOperatorCreate(internal::ceed, &op); PCeedChk(ierr);
-
-   MFEM_VERIFY(form.GetBBFI()->Size() == 0,
-               "Not implemented for this integrator!");
-   MFEM_VERIFY(form.GetFBFI()->Size() == 0,
-               "Not implemented for this integrator!");
-   MFEM_VERIFY(form.GetBFBFI()->Size() == 0,
-               "Not implemented for this integrator!");
-
-   // Get the domain bilinear form integrators (DBFIs)
-   Array<BilinearFormIntegrator*> *bffis = form.GetDBFI();
-   for (int i = 0; i < bffis->Size(); ++i)
+   for (BilinearFormIntegrator *integ : *form.GetDBFI())
+   {
+      AddToCompositeOperator(integ, op);
+   }
+   for (BilinearFormIntegrator *integ : *form.GetBBFI())
    {
-      AddToCompositeOperator((*bffis)[i], op);
+      AddToCompositeOperator(integ, op);
    }
+   MFEM_VERIFY(form.GetFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in CreateCeedCompositeOperatorFromBilinearForm");
+   MFEM_VERIFY(form.GetBFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in CreateCeedCompositeOperatorFromBilinearForm");
    return op;
 }
 
@@ -266,7 +266,8 @@ CeedOperator CoarsenCeedCompositeOperator(
    int ierr;
    bool isComposite;
    ierr = CeedOperatorIsComposite(op, &isComposite); PCeedChk(ierr);
-   MFEM_ASSERT(isComposite, "");
+   MFEM_ASSERT(isComposite,
+               "CoarsenCeedCompositeOperator requires a composite operator.");
 
    CeedOperator op_coarse;
    ierr = CeedCompositeOperatorCreate(internal::ceed,
@@ -376,67 +377,68 @@ int AlgebraicInterpolation::Initialize(
 
    CeedSize height, width;
    ierr = CeedElemRestrictionGetLVectorSize(erestrictu_coarse, &width);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    ierr = CeedElemRestrictionGetLVectorSize(erestrictu_fine, &height);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    // interpolation qfunction
    const int bp3_ncompu = 1;
    CeedQFunction l_qf_restrict, l_qf_prolong;
    ierr = CeedQFunctionCreateIdentity(ceed, bp3_ncompu, CEED_EVAL_NONE,
-                                      CEED_EVAL_INTERP, &l_qf_restrict); CeedChk(ierr);
+                                      CEED_EVAL_INTERP, &l_qf_restrict); PCeedChk(ierr);
    ierr = CeedQFunctionCreateIdentity(ceed, bp3_ncompu, CEED_EVAL_INTERP,
-                                      CEED_EVAL_NONE, &l_qf_prolong); CeedChk(ierr);
+                                      CEED_EVAL_NONE, &l_qf_prolong); PCeedChk(ierr);
 
    qf_restrict = l_qf_restrict;
    qf_prolong = l_qf_prolong;
 
    CeedVector c_fine_multiplicity;
-   ierr = CeedVectorCreate(ceed, height, &c_fine_multiplicity); CeedChk(ierr);
-   ierr = CeedVectorSetValue(c_fine_multiplicity, 0.0); CeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, height, &c_fine_multiplicity); PCeedChk(ierr);
+   ierr = CeedVectorSetValue(c_fine_multiplicity, 0.0); PCeedChk(ierr);
 
    // Create the restriction operator
    // Restriction - Fine to coarse
    ierr = CeedOperatorCreate(ceed, qf_restrict, CEED_QFUNCTION_NONE,
-                             CEED_QFUNCTION_NONE, &op_restrict); CeedChk(ierr);
+                             CEED_QFUNCTION_NONE, &op_restrict); PCeedChk(ierr);
    ierr = CeedOperatorSetField(op_restrict, "input", erestrictu_fine,
-                               CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE); CeedChk(ierr);
+                               CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE); PCeedChk(ierr);
    ierr = CeedOperatorSetField(op_restrict, "output", erestrictu_coarse,
-                               basisctof, CEED_VECTOR_ACTIVE); CeedChk(ierr);
+                               basisctof, CEED_VECTOR_ACTIVE); PCeedChk(ierr);
 
    // Interpolation - Coarse to fine
    // Create the prolongation operator
    ierr =  CeedOperatorCreate(ceed, qf_prolong, CEED_QFUNCTION_NONE,
-                              CEED_QFUNCTION_NONE, &op_interp); CeedChk(ierr);
+                              CEED_QFUNCTION_NONE, &op_interp); PCeedChk(ierr);
    ierr =  CeedOperatorSetField(op_interp, "input", erestrictu_coarse,
-                                basisctof, CEED_VECTOR_ACTIVE); CeedChk(ierr);
+                                basisctof, CEED_VECTOR_ACTIVE); PCeedChk(ierr);
    ierr = CeedOperatorSetField(op_interp, "output", erestrictu_fine,
-                               CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE); CeedChk(ierr);
+                               CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE); PCeedChk(ierr);
 
    ierr = CeedElemRestrictionGetMultiplicity(erestrictu_fine,
-                                             c_fine_multiplicity); CeedChk(ierr);
-   ierr = CeedVectorCreate(ceed, height, &fine_multiplicity_r); CeedChk(ierr);
+                                             c_fine_multiplicity); PCeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, height, &fine_multiplicity_r); PCeedChk(ierr);
 
    CeedScalar* fine_r_data;
    const CeedScalar* fine_data;
    ierr = CeedVectorGetArrayWrite(fine_multiplicity_r, CEED_MEM_HOST,
-                                  &fine_r_data); CeedChk(ierr);
+                                  &fine_r_data); PCeedChk(ierr);
    ierr = CeedVectorGetArrayRead(c_fine_multiplicity, CEED_MEM_HOST,
-                                 &fine_data); CeedChk(ierr);
+                                 &fine_data); PCeedChk(ierr);
    for (CeedSize i = 0; i < height; ++i)
    {
       fine_r_data[i] = 1.0 / fine_data[i];
    }
 
-   ierr = CeedVectorRestoreArray(fine_multiplicity_r, &fine_r_data); CeedChk(ierr);
+   ierr = CeedVectorRestoreArray(fine_multiplicity_r, &fine_r_data);
+   PCeedChk(ierr);
    ierr = CeedVectorRestoreArrayRead(c_fine_multiplicity, &fine_data);
-   CeedChk(ierr);
-   ierr = CeedVectorDestroy(&c_fine_multiplicity); CeedChk(ierr);
+   PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&c_fine_multiplicity); PCeedChk(ierr);
 
-   ierr = CeedVectorCreate(ceed, height, &fine_work); CeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, height, &fine_work); PCeedChk(ierr);
 
-   ierr = CeedVectorCreate(ceed, height, &v_); CeedChk(ierr);
-   ierr = CeedVectorCreate(ceed, width, &u_); CeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, height, &v_); PCeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, width, &u_); PCeedChk(ierr);
 
    return 0;
 }
@@ -445,12 +447,12 @@ int AlgebraicInterpolation::Finalize()
 {
    int ierr;
 
-   ierr = CeedQFunctionDestroy(&qf_restrict); CeedChk(ierr);
-   ierr = CeedQFunctionDestroy(&qf_prolong); CeedChk(ierr);
-   ierr = CeedOperatorDestroy(&op_interp); CeedChk(ierr);
-   ierr = CeedOperatorDestroy(&op_restrict); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&fine_multiplicity_r); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&fine_work); CeedChk(ierr);
+   ierr = CeedQFunctionDestroy(&qf_restrict); PCeedChk(ierr);
+   ierr = CeedQFunctionDestroy(&qf_prolong); PCeedChk(ierr);
+   ierr = CeedOperatorDestroy(&op_interp); PCeedChk(ierr);
+   ierr = CeedOperatorDestroy(&op_restrict); PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&fine_multiplicity_r); PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&fine_work); PCeedChk(ierr);
 
    return 0;
 }
@@ -468,8 +470,8 @@ AlgebraicInterpolation::AlgebraicInterpolation(
                                             &ho_nldofs); PCeedChk(ierr);
    height = (int)ho_nldofs;
    width = (int)lo_nldofs;
-   MFEM_VERIFY(ho_nldofs == height, "height overflow");
-   MFEM_VERIFY(lo_nldofs == width, "width overflow");
+   MFEM_VERIFY(ho_nldofs == height, "Height overflow.");
+   MFEM_VERIFY(lo_nldofs == width, "Width overflow.");
    owns_basis_ = false;
    ierr = Initialize(ceed, basisctof, erestrictu_coarse, erestrictu_fine);
    PCeedChk(ierr);
@@ -488,7 +490,6 @@ AlgebraicInterpolation::~AlgebraicInterpolation()
 }
 
 /// a = a (pointwise*) b
-/// @todo: using MPI_FORALL in this Ceed-like function is ugly
 int CeedVectorPointwiseMult(CeedVector a, const CeedVector b)
 {
    int ierr;
@@ -496,8 +497,8 @@ int CeedVectorPointwiseMult(CeedVector a, const CeedVector b)
    CeedVectorGetCeed(a, &ceed);
 
    CeedSize length, length2;
-   ierr = CeedVectorGetLength(a, &length); CeedChk(ierr);
-   ierr = CeedVectorGetLength(b, &length2); CeedChk(ierr);
+   ierr = CeedVectorGetLength(a, &length); PCeedChk(ierr);
+   ierr = CeedVectorGetLength(b, &length2); PCeedChk(ierr);
    if (length != length2)
    {
       return CeedError(ceed, 1, "Vector sizes don't match");
@@ -514,14 +515,16 @@ int CeedVectorPointwiseMult(CeedVector a, const CeedVector b)
    }
    CeedScalar *a_data;
    const CeedScalar *b_data;
-   ierr = CeedVectorGetArray(a, mem, &a_data); CeedChk(ierr);
-   ierr = CeedVectorGetArrayRead(b, mem, &b_data); CeedChk(ierr);
-   MFEM_VERIFY(int(length) == length, "length overflow");
+   ierr = CeedVectorGetArray(a, mem, &a_data); PCeedChk(ierr);
+   ierr = CeedVectorGetArrayRead(b, mem, &b_data); PCeedChk(ierr);
+   MFEM_VERIFY(int(length) == length, "Length overflow.");
    mfem::forall(length, [=] MFEM_HOST_DEVICE (int i)
-   {a_data[i] *= b_data[i];});
+   {
+      a_data[i] *= b_data[i];
+   });
 
-   ierr = CeedVectorRestoreArray(a, &a_data); CeedChk(ierr);
-   ierr = CeedVectorRestoreArrayRead(b, &b_data); CeedChk(ierr);
+   ierr = CeedVectorRestoreArray(a, &a_data); PCeedChk(ierr);
+   ierr = CeedVectorRestoreArrayRead(b, &b_data); PCeedChk(ierr);
 
    return 0;
 }
@@ -590,7 +593,7 @@ void AlgebraicInterpolation::MultTranspose(const mfem::Vector& x,
    ierr = CeedVectorGetArrayRead(fine_multiplicity_r, mem,
                                  &multiplicitydata); PCeedChk(ierr);
    ierr = CeedVectorGetArrayWrite(fine_work, mem, &workdata); PCeedChk(ierr);
-   MFEM_VERIFY((int)length == length, "length overflow");
+   MFEM_VERIFY((int)length == length, "Length overflow.");
    mfem::forall(length, [=] MFEM_HOST_DEVICE (int i)
    {workdata[i] = in_ptr[i] * multiplicitydata[i];});
    ierr = CeedVectorRestoreArrayRead(fine_multiplicity_r,
@@ -636,7 +639,7 @@ AlgebraicSpaceHierarchy::AlgebraicSpaceHierarchy(FiniteElementSpace &fes)
    current_order = order;
 
    Ceed ceed = internal::ceed;
-   InitRestriction(fes, ceed, &fine_er);
+   InitRestriction(fes, false, ceed, &fine_er);
    CeedElemRestriction er = fine_er;
 
    int dim = fes.GetMesh()->Dimension();
@@ -715,7 +718,7 @@ AlgebraicCoarseSpace::AlgebraicCoarseSpace(
    ierr = CeedElemRestrictionGetLVectorSize(ceed_elem_restriction, &ndofs_);
    PCeedChk(ierr);
    ndofs = ndofs_;
-   MFEM_VERIFY(ndofs == ndofs_, "ndofs overflow");
+   MFEM_VERIFY(ndofs == ndofs_, "Overflow in ndofs.");
 
    mesh = fine_fes.GetMesh();
 }
@@ -741,9 +744,8 @@ ParAlgebraicCoarseSpace::ParAlgebraicCoarseSpace(
 {
    CeedSize lsize;
    CeedElemRestrictionGetLVectorSize(ceed_elem_restriction, &lsize);
+   MFEM_VERIFY((int)lsize == lsize, "Size overflow.");
    const Table &group_ldof_fine = gc_fine->GroupLDofTable();
-
-   MFEM_VERIFY((int)lsize == lsize, "size overflow");
    ldof_group.SetSize(lsize);
    ldof_group = 0;
 
@@ -814,7 +816,8 @@ HypreParMatrix *ParAlgebraicCoarseSpace::GetProlongationHypreParMatrix()
    if (P_mat) { return P_mat; }
 
    ParMesh *pmesh = dynamic_cast<ParMesh*>(mesh);
-   MFEM_VERIFY(pmesh != NULL, "");
+   MFEM_VERIFY(pmesh != NULL,
+               "ParAlgebraicCoarseSpace requires a ParMesh mesh object.");
    Array<HYPRE_BigInt> dof_offsets, tdof_offsets, tdof_nb_offsets;
    Array<HYPRE_BigInt> *offsets[2] = {&dof_offsets, &tdof_offsets};
    int ltsize = R_mat->Height();
@@ -943,7 +946,7 @@ AlgebraicSolver::AlgebraicSolver(BilinearForm &form,
                form.GetAssemblyLevel() == AssemblyLevel::NONE,
                "AlgebraicSolver requires partial assembly or fully matrix-free.");
    MFEM_VERIFY(UsesTensorBasis(*form.FESpace()),
-               "AlgebraicSolver requires tensor product basis functions.");
+               "AlgebraicSolver requires tensor-product basis functions.");
 #ifdef MFEM_USE_CEED
    fespaces = new AlgebraicSpaceHierarchy(*form.FESpace());
    multigrid = new AlgebraicMultigrid(*fespaces, form, ess_tdofs);
@@ -974,6 +977,88 @@ void AlgebraicSolver::SetOperator(const mfem::Operator& op)
 #endif
 }
 
+#ifdef MFEM_USE_CEED
+SparseMatrix *CeedOperatorFullAssemble(BilinearForm &form, bool set)
+{
+   Array<SparseMatrix *> mat_i;
+   for (BilinearFormIntegrator *integ : *form.GetDBFI())
+   {
+      if (!integ->SupportsCeed()) { continue; }
+      SparseMatrix *mat_integ;
+      int ierr = CeedOperatorFullAssemble(integ->GetCeedOp().GetCeedOperator(),
+                                          &mat_integ, set);
+      PCeedChk(ierr);
+      mat_i.Append(mat_integ);
+   }
+   for (BilinearFormIntegrator *integ : *form.GetBBFI())
+   {
+      if (!integ->SupportsCeed()) { continue; }
+      SparseMatrix *mat_integ;
+      int ierr = CeedOperatorFullAssemble(integ->GetCeedOp().GetCeedOperator(),
+                                          &mat_integ, set);
+      PCeedChk(ierr);
+      mat_i.Append(mat_integ);
+   }
+   MFEM_VERIFY(form.GetFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in CeedOperatorFullAssemble");
+   MFEM_VERIFY(form.GetBFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in CeedOperatorFullAssemble");
+
+   SparseMatrix *mat = Add(mat_i);
+   for (SparseMatrix *mat_integ : mat_i)
+   {
+      delete mat_integ;
+   }
+   return mat;
+}
+
+int CeedOperatorFullAssemble(CeedOperator op, SparseMatrix **mat, bool set)
+{
+   int ierr;
+   Ceed ceed;
+   ierr = CeedOperatorGetCeed(op, &ceed); PCeedChk(ierr);
+
+   CeedSize l_in, l_out;
+   ierr = CeedOperatorGetActiveVectorLengths(op, &l_in, &l_out); PCeedChk(ierr);
+   MFEM_VERIFY((int)l_in == l_in && (int)l_out == l_out, "Size overflow.");
+   *mat = new SparseMatrix(l_out, l_in);
+
+   CeedSize nnz;
+   CeedInt *rows, *cols;
+   ierr = CeedOperatorLinearAssembleSymbolic(op, &nnz, &rows, &cols);
+   PCeedChk(ierr);
+
+   CeedVector vals;
+   ierr = CeedVectorCreate(ceed, nnz, &vals); PCeedChk(ierr);
+   ierr = CeedOperatorLinearAssemble(op, vals); PCeedChk(ierr);
+
+   const CeedScalar *val_array;
+   ierr = CeedVectorGetArrayRead(vals, CEED_MEM_HOST, &val_array); PCeedChk(ierr);
+   for (CeedSize k = 0; k < nnz; ++k)
+   {
+      if (!set)
+      {
+         (*mat)->Add(rows[k], cols[k], val_array[k]);
+      }
+      else
+      {
+         (*mat)->Set(rows[k], cols[k], val_array[k]);
+      }
+   }
+   ierr = CeedVectorRestoreArrayRead(vals, &val_array); PCeedChk(ierr);
+
+   ierr = CeedVectorDestroy(&vals); PCeedChk(ierr);
+   ierr = CeedInternalFree(&rows); PCeedChk(ierr);
+   ierr = CeedInternalFree(&cols); PCeedChk(ierr);
+
+   // Enforce structurally symmetric for later elimination
+   const int skip_zeros = 0;
+   (*mat)->Finalize(skip_zeros);
+
+   return 0;
+}
+#endif
+
 } // namespace ceed
 
 } // namespace mfem
diff --git a/fem/ceed/solvers/algebraic.hpp b/fem/ceed/solvers/algebraic.hpp
index 8ede8324e..b8a37b7ec 100644
--- a/fem/ceed/solvers/algebraic.hpp
+++ b/fem/ceed/solvers/algebraic.hpp
@@ -12,9 +12,9 @@
 #ifndef MFEM_CEED_ALGEBRAIC_HPP
 #define MFEM_CEED_ALGEBRAIC_HPP
 
+#include "../../../linalg/sparsemat.hpp"
 #include "../../fespacehierarchy.hpp"
 #include "../../multigrid.hpp"
-#include "../interface/operator.hpp"
 #include "../interface/ceed.hpp"
 
 namespace mfem
@@ -190,7 +190,7 @@ private:
 #endif
 
 public:
-   /** @brief Constructs algebraic multigrid hierarchy and solver.
+   /** @brief Constructs algebraic multigrid hierarchy and solver
 
        This only works if the Ceed device backend is enabled.
 
@@ -204,6 +204,26 @@ public:
    void SetOperator(const mfem::Operator& op);
 };
 
+#ifdef MFEM_USE_CEED
+/** @brief Assemble the CeedOperators from a BilinearForm as an
+    mfem::SparseMatrix
+
+    In parallel, this assembles independently on each processor, that is, it
+    assembles at the L-vector level. The assembly procedure is always performed
+    on the host, but this works also for operators stored on device by copying
+    memory. */
+SparseMatrix *CeedOperatorFullAssemble(BilinearForm &form, bool set = false);
+
+/** @brief Assembles a CeedOperator as an mfem::SparseMatrix
+
+    In parallel, this assembles independently on each processor, that is, it
+    assembles at the L-vector level. The assembly procedure is always performed
+    on the host, but this works also for operators stored on device by copying
+    memory. */
+int CeedOperatorFullAssemble(CeedOperator op, SparseMatrix **mat,
+                             bool set = false);
+#endif
+
 } // namespace ceed
 
 } // namespace mfem
diff --git a/fem/ceed/solvers/full-assembly.cpp b/fem/ceed/solvers/full-assembly.cpp
deleted file mode 100644
index ccf9b145a..000000000
--- a/fem/ceed/solvers/full-assembly.cpp
+++ /dev/null
@@ -1,341 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-#include "full-assembly.hpp"
-
-#include "../../../linalg/sparsemat.hpp"
-#include "../interface/util.hpp"
-#include "../interface/ceed.hpp"
-
-#ifdef MFEM_USE_CEED
-
-namespace mfem
-{
-
-namespace ceed
-{
-
-int CeedHackReallocArray(size_t n, size_t unit, void *p)
-{
-   *(void **)p = realloc(*(void **)p, n*unit);
-   if (n && unit && !*(void **)p)
-      return CeedError(NULL, 1, "realloc failed to allocate %zd members of size "
-                       "%zd\n", n, unit);
-   return 0;
-}
-
-#define CeedHackRealloc(n, p) CeedHackReallocArray((n), sizeof(**(p)), p)
-
-int CeedHackFree(void *p)
-{
-   free(*(void **)p);
-   *(void **)p = NULL;
-   return 0;
-}
-
-int CeedSingleOperatorFullAssemble(CeedOperator op, SparseMatrix *out)
-{
-   int ierr;
-   Ceed ceed;
-   ierr = CeedOperatorGetCeed(op, &ceed); CeedChk(ierr);
-
-   // Assemble QFunction
-   CeedQFunction qf;
-   ierr = CeedOperatorGetQFunction(op, &qf); CeedChk(ierr);
-   CeedInt numinputfields, numoutputfields;
-   CeedChk(ierr);
-   CeedVector assembledqf;
-   CeedElemRestriction rstr_q;
-   ierr = CeedOperatorLinearAssembleQFunction(
-             op, &assembledqf, &rstr_q, CEED_REQUEST_IMMEDIATE); CeedChk(ierr);
-
-   CeedSize qflength;
-   ierr = CeedVectorGetLength(assembledqf, &qflength); CeedChk(ierr);
-
-   CeedOperatorField *input_fields;
-   CeedOperatorField *output_fields;
-   ierr = CeedOperatorGetFields(op, &numinputfields, &input_fields,
-                                &numoutputfields, &output_fields);
-   CeedChk(ierr);
-
-   // Determine active input basis
-   CeedQFunctionField *qffields;
-   ierr = CeedQFunctionGetFields(qf, &numinputfields, &qffields,
-                                 &numoutputfields, NULL);
-   CeedChk(ierr);
-   CeedInt numemodein = 0, ncomp, dim = 1;
-   CeedEvalMode *emodein = NULL;
-   CeedBasis basisin = NULL;
-   CeedElemRestriction rstrin = NULL;
-   for (CeedInt i=0; i<numinputfields; i++)
-   {
-      CeedVector vec;
-      ierr = CeedOperatorFieldGetVector(input_fields[i], &vec); CeedChk(ierr);
-      if (vec == CEED_VECTOR_ACTIVE)
-      {
-         ierr = CeedOperatorFieldGetBasis(input_fields[i], &basisin);
-         CeedChk(ierr);
-         ierr = CeedBasisGetNumComponents(basisin, &ncomp); CeedChk(ierr);
-         ierr = CeedBasisGetDimension(basisin, &dim); CeedChk(ierr);
-         ierr = CeedOperatorFieldGetElemRestriction(input_fields[i], &rstrin);
-         CeedChk(ierr);
-         CeedEvalMode emode;
-         ierr = CeedQFunctionFieldGetEvalMode(qffields[i], &emode);
-         CeedChk(ierr);
-         switch (emode)
-         {
-            case CEED_EVAL_NONE:
-            case CEED_EVAL_INTERP:
-               ierr = CeedHackRealloc(numemodein + 1, &emodein); CeedChk(ierr);
-               emodein[numemodein] = emode;
-               numemodein += 1;
-               break;
-            case CEED_EVAL_GRAD:
-               ierr = CeedHackRealloc(numemodein + dim, &emodein); CeedChk(ierr);
-               for (CeedInt d=0; d<dim; d++)
-               {
-                  emodein[numemodein+d] = emode;
-               }
-               numemodein += dim;
-               break;
-            case CEED_EVAL_WEIGHT:
-            case CEED_EVAL_DIV:
-            case CEED_EVAL_CURL:
-               break; // Caught by QF Assembly
-         }
-      }
-   }
-
-   // Determine active output basis
-   ierr = CeedQFunctionGetFields(qf, &numinputfields, NULL, &numoutputfields,
-                                 &qffields); CeedChk(ierr);
-   CeedInt numemodeout = 0;
-   CeedEvalMode *emodeout = NULL;
-   CeedBasis basisout = NULL;
-   CeedElemRestriction rstrout = NULL;
-   for (CeedInt i=0; i<numoutputfields; i++)
-   {
-      CeedVector vec;
-      ierr = CeedOperatorFieldGetVector(output_fields[i], &vec); CeedChk(ierr);
-      if (vec == CEED_VECTOR_ACTIVE)
-      {
-         ierr = CeedOperatorFieldGetBasis(output_fields[i], &basisout);
-         CeedChk(ierr);
-         ierr = CeedOperatorFieldGetElemRestriction(output_fields[i], &rstrout);
-         CeedChk(ierr);
-         CeedChk(ierr);
-         CeedEvalMode emode;
-         ierr = CeedQFunctionFieldGetEvalMode(qffields[i], &emode);
-         CeedChk(ierr);
-         switch (emode)
-         {
-            case CEED_EVAL_NONE:
-            case CEED_EVAL_INTERP:
-               ierr = CeedHackRealloc(numemodeout + 1, &emodeout); CeedChk(ierr);
-               emodeout[numemodeout] = emode;
-               numemodeout += 1;
-               break;
-            case CEED_EVAL_GRAD:
-               ierr = CeedHackRealloc(numemodeout + dim, &emodeout); CeedChk(ierr);
-               for (CeedInt d=0; d<dim; d++)
-               {
-                  emodeout[numemodeout+d] = emode;
-               }
-               numemodeout += dim;
-               break;
-            case CEED_EVAL_WEIGHT:
-            case CEED_EVAL_DIV:
-            case CEED_EVAL_CURL:
-               break; // Caught by QF Assembly
-         }
-      }
-   }
-
-   CeedInt nelem, elemsize, nqpts;
-   CeedSize nnodes;
-   ierr = CeedElemRestrictionGetNumElements(rstrin, &nelem); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetElementSize(rstrin, &elemsize); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetLVectorSize(rstrin, &nnodes); CeedChk(ierr);
-   ierr = CeedBasisGetNumQuadraturePoints(basisin, &nqpts); CeedChk(ierr);
-
-   // Determine elem_dof relation
-   CeedVector index_vec;
-   ierr = CeedVectorCreate(ceed, nnodes, &index_vec); CeedChk(ierr);
-   CeedScalar *array;
-   ierr = CeedVectorGetArrayWrite(index_vec, CEED_MEM_HOST, &array);
-   CeedChk(ierr);
-   for (CeedSize i = 0; i < nnodes; ++i)
-   {
-      array[i] = i;
-   }
-   ierr = CeedVectorRestoreArray(index_vec, &array); CeedChk(ierr);
-   CeedVector elem_dof;
-   ierr = CeedVectorCreate(ceed, nelem * elemsize, &elem_dof); CeedChk(ierr);
-   ierr = CeedVectorSetValue(elem_dof, 0.0); CeedChk(ierr);
-   CeedElemRestrictionApply(rstrin, CEED_NOTRANSPOSE, index_vec,
-                            elem_dof, CEED_REQUEST_IMMEDIATE); CeedChk(ierr);
-   const CeedScalar * elem_dof_a;
-   ierr = CeedVectorGetArrayRead(elem_dof, CEED_MEM_HOST, &elem_dof_a);
-   CeedChk(ierr);
-   ierr = CeedVectorDestroy(&index_vec); CeedChk(ierr);
-
-   // loop over elements and put in SparseMatrix
-   // SparseMatrix * out = new SparseMatrix(nnodes, nnodes);
-   MFEM_ASSERT(out->Height() == nnodes, "Sizes don't match!");
-   MFEM_ASSERT(out->Width() == nnodes, "Sizes don't match!");
-   const CeedScalar *interpin, *gradin;
-   ierr = CeedBasisGetInterp(basisin, &interpin); CeedChk(ierr);
-   ierr = CeedBasisGetGrad(basisin, &gradin); CeedChk(ierr);
-
-   const CeedScalar * assembledqfarray;
-   ierr = CeedVectorGetArrayRead(assembledqf, CEED_MEM_HOST, &assembledqfarray);
-   CeedChk(ierr);
-
-   CeedInt layout[3];
-   ierr = CeedElemRestrictionGetELayout(rstr_q, &layout); CeedChk(ierr);
-   ierr = CeedElemRestrictionDestroy(&rstr_q); CeedChk(ierr);
-
-   // enforce structurally symmetric for later elimination
-   const int skip_zeros = 0;
-   MFEM_ASSERT(numemodein == numemodeout,
-               "Ceed full assembly not implemented for this case.");
-   for (int e = 0; e < nelem; ++e)
-   {
-      // get Array<int> for use in SparseMatrix::AddSubMatrix()
-      Array<int> rows(elemsize);
-      for (int i = 0; i < elemsize; ++i)
-      {
-         rows[i] = elem_dof_a[e * elemsize + i];
-      }
-
-      // form element matrix itself
-      DenseMatrix Bmat(nqpts * numemodein, elemsize);
-      Bmat = 0.0;
-      // Store block-diagonal D matrix as collection of small dense blocks
-      DenseTensor Dmat(numemodeout, numemodein, nqpts);
-      Dmat = 0.0;
-      DenseMatrix elem_mat(elemsize, elemsize);
-      elem_mat = 0.0;
-      for (int q = 0; q < nqpts; ++q)
-      {
-         for (int n = 0; n < elemsize; ++n)
-         {
-            CeedInt din = -1;
-            for (int ein = 0; ein < numemodein; ++ein)
-            {
-               if (emodein[ein] == CEED_EVAL_INTERP)
-               {
-                  Bmat(numemodein * q + ein, n) += interpin[q * elemsize + n];
-               }
-               else if (emodein[ein] == CEED_EVAL_GRAD)
-               {
-                  din += 1;
-                  Bmat(numemodein * q + ein, n) += gradin[(din*nqpts+q) * elemsize + n];
-               }
-               else
-               {
-                  MFEM_ASSERT(false, "Not implemented!");
-               }
-            }
-         }
-         for (int ei = 0; ei < numemodein; ++ei)
-         {
-            for (int ej = 0; ej < numemodein; ++ej)
-            {
-               const int comp = ei * numemodein + ej;
-               const int index = q*layout[0] + comp*layout[1] + e*layout[2];
-               Dmat(ei, ej, q) += assembledqfarray[index];
-            }
-         }
-      }
-      DenseMatrix BTD(elemsize, nqpts*numemodein);
-      // Compute B^T*D
-      BTD = 0.0;
-      for (int j=0; j<elemsize; ++j)
-      {
-         for (int q=0; q<nqpts; ++q)
-         {
-            int qq = numemodein*q;
-            for (int ei = 0; ei < numemodein; ++ei)
-            {
-               for (int ej = 0; ej < numemodein; ++ej)
-               {
-                  BTD(j,qq+ei) += Bmat(qq+ej,j)*Dmat(ej,ei,q);
-               }
-            }
-         }
-      }
-
-      Mult(BTD, Bmat, elem_mat);
-
-      // put element matrix in sparsemat
-      out->AddSubMatrix(rows, rows, elem_mat, skip_zeros);
-   }
-
-   ierr = CeedVectorRestoreArrayRead(elem_dof, &elem_dof_a); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&elem_dof); CeedChk(ierr);
-   ierr = CeedVectorRestoreArrayRead(assembledqf, &assembledqfarray);
-   CeedChk(ierr);
-   ierr = CeedVectorDestroy(&assembledqf); CeedChk(ierr);
-   ierr = CeedHackFree(&emodein); CeedChk(ierr);
-   ierr = CeedHackFree(&emodeout); CeedChk(ierr);
-
-   return 0;
-}
-
-int CeedOperatorFullAssemble(CeedOperator op, SparseMatrix **mat)
-{
-   int ierr;
-
-   CeedSize in_len, out_len;
-   ierr = CeedOperatorGetActiveVectorLengths(op, &in_len, &out_len);
-   CeedChk(ierr);
-   const int nnodes = in_len;
-   MFEM_VERIFY(in_len == out_len, "not a square CeedOperator");
-   MFEM_VERIFY(in_len == nnodes, "size overflow");
-
-   SparseMatrix *out = new SparseMatrix(nnodes, nnodes);
-
-   bool isComposite;
-   ierr = CeedOperatorIsComposite(op, &isComposite); CeedChk(ierr);
-   if (isComposite)
-   {
-      CeedInt numsub;
-      CeedOperator *subops;
-#if CEED_VERSION_GE(0, 10, 2)
-      CeedCompositeOperatorGetNumSub(op, &numsub);
-      ierr = CeedCompositeOperatorGetSubList(op, &subops); CeedChk(ierr);
-#else
-      CeedOperatorGetNumSub(op, &numsub);
-      ierr = CeedOperatorGetSubList(op, &subops); CeedChk(ierr);
-#endif
-      for (int i = 0; i < numsub; ++i)
-      {
-         ierr = CeedSingleOperatorFullAssemble(subops[i], out); CeedChk(ierr);
-      }
-   }
-   else
-   {
-      ierr = CeedSingleOperatorFullAssemble(op, out); CeedChk(ierr);
-   }
-   // enforce structurally symmetric for later elimination
-   const int skip_zeros = 0;
-   out->Finalize(skip_zeros);
-   *mat = out;
-
-   return 0;
-}
-
-} // namespace ceed
-
-} // namespace mfem
-
-#endif
diff --git a/fem/ceed/solvers/solvers-atpmg.cpp b/fem/ceed/solvers/solvers-atpmg.cpp
index 8f4be00b2..052f21927 100644
--- a/fem/ceed/solvers/solvers-atpmg.cpp
+++ b/fem/ceed/solvers/solvers-atpmg.cpp
@@ -11,15 +11,13 @@
 
 #include "solvers-atpmg.hpp"
 
-#include "../interface/ceed.hpp"
+#include <math.h>
 #include "../interface/util.hpp"
-
 #ifdef MFEM_USE_CEED
 #include <ceed/backend.h>
+#endif
 
-#include <math.h>
-// todo: should probably use Ceed memory wrappers instead of calloc/free?
-#include <stdlib.h>
+#ifdef MFEM_USE_CEED
 
 namespace mfem
 {
@@ -86,17 +84,17 @@ int CeedATPMGElemRestriction(int order,
 {
    int ierr;
    Ceed ceed;
-   ierr = CeedElemRestrictionGetCeed(er_in, &ceed); CeedChk(ierr);
+   ierr = CeedElemRestrictionGetCeed(er_in, &ceed); PCeedChk(ierr);
 
    CeedInt numelem, numcomp, elemsize;
    CeedSize numnodes;
-   ierr = CeedElemRestrictionGetNumElements(er_in, &numelem); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetLVectorSize(er_in, &numnodes); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetElementSize(er_in, &elemsize); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetNumComponents(er_in, &numcomp); CeedChk(ierr);
+   ierr = CeedElemRestrictionGetNumElements(er_in, &numelem); PCeedChk(ierr);
+   ierr = CeedElemRestrictionGetLVectorSize(er_in, &numnodes); PCeedChk(ierr);
+   ierr = CeedElemRestrictionGetElementSize(er_in, &elemsize); PCeedChk(ierr);
+   ierr = CeedElemRestrictionGetNumComponents(er_in, &numcomp); PCeedChk(ierr);
    if (numcomp != 1)
    {
-      // todo: multi-component will require more thought
+      // TODO: multi-component will require more thought
       return CeedError(ceed, 1, "Algebraic element restriction not "
                        "implemented for multiple components.");
    }
@@ -107,31 +105,31 @@ int CeedATPMGElemRestriction(int order,
 
    CeedVector in_lvec, in_evec;
    ierr = CeedElemRestrictionCreateVector(er_in, &in_lvec, &in_evec);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    // Create the elem_dof array from the given high-order ElemRestriction
    // by using it to map the L-vector indices to an E-vector
    CeedScalar * lvec_data;
    ierr = CeedVectorGetArrayWrite(in_lvec, CEED_MEM_HOST, &lvec_data);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    for (CeedSize i = 0; i < numnodes; ++i)
    {
       lvec_data[i] = (CeedScalar) i;
    }
-   ierr = CeedVectorRestoreArray(in_lvec, &lvec_data); CeedChk(ierr);
+   ierr = CeedVectorRestoreArray(in_lvec, &lvec_data); PCeedChk(ierr);
    CeedInt in_layout[3];
-   ierr = CeedElemRestrictionGetELayout(er_in, &in_layout); CeedChk(ierr);
+   ierr = CeedElemRestrictionGetELayout(er_in, &in_layout); PCeedChk(ierr);
    if (in_layout[0] == 0 && in_layout[1] == 0 && in_layout[2] == 0)
    {
       return CeedError(ceed, 1, "Cannot interpret e-vector ordering of given"
                        "CeedElemRestriction!");
    }
    ierr = CeedElemRestrictionApply(er_in, CEED_NOTRANSPOSE, in_lvec, in_evec,
-                                   CEED_REQUEST_IMMEDIATE); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&in_lvec); CeedChk(ierr);
+                                   CEED_REQUEST_IMMEDIATE); PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&in_lvec); PCeedChk(ierr);
    const CeedScalar * in_elem_dof;
    ierr = CeedVectorGetArrayRead(in_evec, CEED_MEM_HOST, &in_elem_dof);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    // Create a map (dof_map) that maps high-order ldof indices to
    // low-order ldof indices, with -1 indicating no correspondence
@@ -469,13 +467,13 @@ int CeedATPMGElemRestriction(int order,
                        "CeedATPMGElemRestriction does not yet support this dimension.");
    }
 
-   ierr = CeedVectorRestoreArrayRead(in_evec, &in_elem_dof); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&in_evec); CeedChk(ierr);
+   ierr = CeedVectorRestoreArrayRead(in_evec, &in_elem_dof); PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&in_evec); PCeedChk(ierr);
 
    ierr = CeedElemRestrictionCreate(ceed, numelem, coarse_elemsize, numcomp,
                                     0, running_out_ldof_count,
                                     CEED_MEM_HOST, CEED_COPY_VALUES, out_elem_dof,
-                                    er_out); CeedChk(ierr);
+                                    er_out); PCeedChk(ierr);
 
    delete [] out_elem_dof;
 
@@ -491,7 +489,7 @@ int CeedBasisATPMGCoarseToFine(Ceed ceed, int P1d, int dim, int order_reduction,
    // calling the following Ceed function)
    int ierr;
    ierr = CeedBasisCreateTensorH1Lagrange(ceed, dim, 1, P1d - order_reduction, P1d,
-                                          CEED_GAUSS_LOBATTO, basisc2f); CeedChk(ierr);
+                                          CEED_GAUSS_LOBATTO, basisc2f); PCeedChk(ierr);
    return 0;
 }
 
@@ -501,13 +499,13 @@ int CeedBasisATPMGCoarseToFine(CeedBasis basisin,
 {
    int ierr;
    Ceed ceed;
-   ierr = CeedBasisGetCeed(basisin, &ceed); CeedChk(ierr);
+   ierr = CeedBasisGetCeed(basisin, &ceed); PCeedChk(ierr);
 
    CeedInt dim, P1d;
-   ierr = CeedBasisGetDimension(basisin, &dim); CeedChk(ierr);
-   ierr = CeedBasisGetNumNodes1D(basisin, &P1d); CeedChk(ierr);
+   ierr = CeedBasisGetDimension(basisin, &dim); PCeedChk(ierr);
+   ierr = CeedBasisGetNumNodes1D(basisin, &P1d); PCeedChk(ierr);
    ierr = CeedBasisATPMGCoarseToFine(ceed, P1d, dim, order_reduction,
-                                     basisc2f); CeedChk(ierr);
+                                     basisc2f); PCeedChk(ierr);
    return 0;
 }
 
@@ -518,38 +516,38 @@ int CeedBasisATPMGCoarsen(CeedBasis basisin,
 {
    int ierr;
    Ceed ceed;
-   ierr = CeedBasisGetCeed(basisin, &ceed); CeedChk(ierr);
+   ierr = CeedBasisGetCeed(basisin, &ceed); PCeedChk(ierr);
 
    CeedInt dim, ncomp, P1d, Q1d;
-   ierr = CeedBasisGetDimension(basisin, &dim); CeedChk(ierr);
-   ierr = CeedBasisGetNumComponents(basisin, &ncomp); CeedChk(ierr);
-   ierr = CeedBasisGetNumNodes1D(basisin, &P1d); CeedChk(ierr);
-   ierr = CeedBasisGetNumQuadraturePoints1D(basisin, &Q1d); CeedChk(ierr);
+   ierr = CeedBasisGetDimension(basisin, &dim); PCeedChk(ierr);
+   ierr = CeedBasisGetNumComponents(basisin, &ncomp); PCeedChk(ierr);
+   ierr = CeedBasisGetNumNodes1D(basisin, &P1d); PCeedChk(ierr);
+   ierr = CeedBasisGetNumQuadraturePoints1D(basisin, &Q1d); PCeedChk(ierr);
 
    CeedInt coarse_P1d = P1d - order_reduction;
 
    const CeedScalar *interp1d;
-   ierr = CeedBasisGetInterp1D(basisin, &interp1d); CeedChk(ierr);
+   ierr = CeedBasisGetInterp1D(basisin, &interp1d); PCeedChk(ierr);
    const CeedScalar * grad1d;
-   ierr = CeedBasisGetGrad1D(basisin, &grad1d); CeedChk(ierr);
+   ierr = CeedBasisGetGrad1D(basisin, &grad1d); PCeedChk(ierr);
 
    CeedScalar * coarse_interp1d = new CeedScalar[coarse_P1d * Q1d];
    CeedScalar * coarse_grad1d = new CeedScalar[coarse_P1d * Q1d];
    CeedScalar * fine_nodal_points = new CeedScalar[P1d];
 
    // these things are in [-1, 1], not [0, 1], which matters
-   // (todo: how can we determine this or something related, algebraically?)
+   // (TODO: how can we determine this or something related, algebraically?)
    /* one way you might be able to tell is to just run this algorithm
       with coarse_P1d = 2 (i.e., linear) and look for symmetry in the coarse
       basis matrix? */
-   ierr = CeedLobattoQuadrature(P1d, fine_nodal_points, NULL); CeedChk(ierr);
+   ierr = CeedLobattoQuadrature(P1d, fine_nodal_points, NULL); PCeedChk(ierr);
    for (int i = 0; i < P1d; ++i)
    {
       fine_nodal_points[i] = 0.5 * fine_nodal_points[i] + 0.5; // cheating
    }
 
    const CeedScalar *interp_ctof;
-   ierr = CeedBasisGetInterp1D(basisc2f, &interp_ctof); CeedChk(ierr);
+   ierr = CeedBasisGetInterp1D(basisc2f, &interp_ctof); PCeedChk(ierr);
 
    for (int i = 0; i < Q1d; ++i)
    {
@@ -568,12 +566,12 @@ int CeedBasisATPMGCoarsen(CeedBasis basisin,
    }
 
    const CeedScalar * qref1d;
-   ierr = CeedBasisGetQRef(basisin, &qref1d); CeedChk(ierr);
+   ierr = CeedBasisGetQRef(basisin, &qref1d); PCeedChk(ierr);
    const CeedScalar * qweight1d;
-   ierr = CeedBasisGetQWeights(basisin, &qweight1d); CeedChk(ierr);
+   ierr = CeedBasisGetQWeights(basisin, &qweight1d); PCeedChk(ierr);
    ierr = CeedBasisCreateTensorH1(ceed, dim, ncomp,
                                   coarse_P1d, Q1d, coarse_interp1d, coarse_grad1d,
-                                  qref1d, qweight1d, basisout); CeedChk(ierr);
+                                  qref1d, qweight1d, basisout); PCeedChk(ierr);
 
    delete [] fine_nodal_points;
    delete [] coarse_interp1d;
@@ -593,19 +591,19 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
 
    int ierr;
    Ceed ceed;
-   ierr = CeedOperatorGetCeed(oper, &ceed); CeedChk(ierr);
+   ierr = CeedOperatorGetCeed(oper, &ceed); PCeedChk(ierr);
 
    CeedQFunction qf;
-   ierr = CeedOperatorGetQFunction(oper, &qf); CeedChk(ierr);
+   ierr = CeedOperatorGetQFunction(oper, &qf); PCeedChk(ierr);
    CeedInt numinputfields, numoutputfields;
    CeedQFunctionField *inputqfields, *outputqfields;
    ierr = CeedQFunctionGetFields(qf, &numinputfields, &inputqfields,
                                  &numoutputfields, &outputqfields);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    CeedOperatorField *inputfields, *outputfields;
    ierr = CeedOperatorGetFields(oper, &numinputfields, &inputfields,
                                 &numoutputfields, &outputfields);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    CeedElemRestriction * er_input = new CeedElemRestriction[numinputfields];
    CeedElemRestriction * er_output = new CeedElemRestriction[numoutputfields];
@@ -619,10 +617,11 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
    for (int i = 0; i < numinputfields; ++i)
    {
       ierr = CeedOperatorFieldGetElemRestriction(inputfields[i],
-                                                 &er_input[i]); CeedChk(ierr);
-      ierr = CeedOperatorFieldGetVector(inputfields[i], &if_vector[i]); CeedChk(ierr);
+                                                 &er_input[i]); PCeedChk(ierr);
+      ierr = CeedOperatorFieldGetVector(inputfields[i], &if_vector[i]);
+      PCeedChk(ierr);
       ierr = CeedOperatorFieldGetBasis(inputfields[i], &basis_input[i]);
-      CeedChk(ierr);
+      PCeedChk(ierr);
       if (if_vector[i] == CEED_VECTOR_ACTIVE)
       {
          if (active_input_basis < 0)
@@ -638,11 +637,11 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
    for (int i = 0; i < numoutputfields; ++i)
    {
       ierr = CeedOperatorFieldGetElemRestriction(outputfields[i],
-                                                 &er_output[i]); CeedChk(ierr);
+                                                 &er_output[i]); PCeedChk(ierr);
       ierr = CeedOperatorFieldGetVector(outputfields[i], &of_vector[i]);
-      CeedChk(ierr);
+      PCeedChk(ierr);
       ierr = CeedOperatorFieldGetBasis(outputfields[i], &basis_output[i]);
-      CeedChk(ierr);
+      PCeedChk(ierr);
       if (of_vector[i] == CEED_VECTOR_ACTIVE)
       {
          // should already be coarsened
@@ -659,36 +658,36 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
 
    CeedOperator coper;
    ierr = CeedOperatorCreate(ceed, qf, CEED_QFUNCTION_NONE, CEED_QFUNCTION_NONE,
-                             &coper); CeedChk(ierr);
+                             &coper); PCeedChk(ierr);
 
    for (int i = 0; i < numinputfields; ++i)
    {
       char * fieldname;
-      ierr = CeedQFunctionFieldGetName(inputqfields[i], &fieldname); CeedChk(ierr);
+      ierr = CeedQFunctionFieldGetName(inputqfields[i], &fieldname); PCeedChk(ierr);
       if (if_vector[i] == CEED_VECTOR_ACTIVE)
       {
          ierr = CeedOperatorSetField(coper, fieldname, coarse_er, cbasis,
-                                     if_vector[i]); CeedChk(ierr);
+                                     if_vector[i]); PCeedChk(ierr);
       }
       else
       {
          ierr = CeedOperatorSetField(coper, fieldname, er_input[i], basis_input[i],
-                                     if_vector[i]); CeedChk(ierr);
+                                     if_vector[i]); PCeedChk(ierr);
       }
    }
    for (int i = 0; i < numoutputfields; ++i)
    {
       char * fieldname;
-      ierr = CeedQFunctionFieldGetName(outputqfields[i], &fieldname); CeedChk(ierr);
+      ierr = CeedQFunctionFieldGetName(outputqfields[i], &fieldname); PCeedChk(ierr);
       if (of_vector[i] == CEED_VECTOR_ACTIVE)
       {
          ierr = CeedOperatorSetField(coper, fieldname, coarse_er, cbasis,
-                                     of_vector[i]); CeedChk(ierr);
+                                     of_vector[i]); PCeedChk(ierr);
       }
       else
       {
          ierr = CeedOperatorSetField(coper, fieldname, er_output[i], basis_output[i],
-                                     of_vector[i]); CeedChk(ierr);
+                                     of_vector[i]); PCeedChk(ierr);
       }
    }
    delete [] er_input;
@@ -711,21 +710,21 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
    int ierr;
 
    CeedQFunction qf;
-   ierr = CeedOperatorGetQFunction(oper, &qf); CeedChk(ierr);
+   ierr = CeedOperatorGetQFunction(oper, &qf); PCeedChk(ierr);
    CeedInt numinputfields, numoutputfields;
    CeedOperatorField *inputfields;
    ierr = CeedOperatorGetFields(oper, &numinputfields, &inputfields,
                                 &numoutputfields, NULL);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    CeedBasis basis;
-   ierr = CeedOperatorGetActiveBasis(oper, &basis); CeedChk(ierr);
+   ierr = CeedOperatorGetActiveBasis(oper, &basis); PCeedChk(ierr);
    ierr = CeedBasisATPMGCoarseToFine(basis, basis_ctof_out, order_reduction);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    ierr = CeedBasisATPMGCoarsen(basis, *basis_ctof_out, coarse_basis_out,
-                                order_reduction); CeedChk(ierr);
+                                order_reduction); PCeedChk(ierr);
    ierr = CeedATPMGOperator(oper, order_reduction, coarse_er, *coarse_basis_out,
-                            *basis_ctof_out, out); CeedChk(ierr);
+                            *basis_ctof_out, out); PCeedChk(ierr);
    return 0;
 }
 
@@ -734,11 +733,11 @@ int CeedOperatorGetOrder(CeedOperator oper, CeedInt * order)
    int ierr;
 
    CeedOperatorField active_field;
-   ierr = CeedOperatorGetActiveField(oper, &active_field); CeedChk(ierr);
+   ierr = CeedOperatorGetActiveField(oper, &active_field); PCeedChk(ierr);
    CeedBasis basis;
-   ierr = CeedOperatorFieldGetBasis(active_field, &basis); CeedChk(ierr);
+   ierr = CeedOperatorFieldGetBasis(active_field, &basis); PCeedChk(ierr);
    int P1d;
-   ierr = CeedBasisGetNumNodes1D(basis, &P1d); CeedChk(ierr);
+   ierr = CeedBasisGetNumNodes1D(basis, &P1d); PCeedChk(ierr);
    *order = P1d - 1;
 
    return 0;
@@ -753,13 +752,13 @@ int CeedATPMGBundle(CeedOperator oper, int order_reduction,
 {
    int ierr;
    CeedInt order;
-   ierr = CeedOperatorGetOrder(oper, &order); CeedChk(ierr);
+   ierr = CeedOperatorGetOrder(oper, &order); PCeedChk(ierr);
    CeedElemRestriction ho_er;
-   ierr = CeedOperatorGetActiveElemRestriction(oper, &ho_er); CeedChk(ierr);
+   ierr = CeedOperatorGetActiveElemRestriction(oper, &ho_er); PCeedChk(ierr);
    ierr = CeedATPMGElemRestriction(order, order_reduction, ho_er, er_out, dof_map);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    ierr = CeedATPMGOperator(oper, order_reduction, *er_out, coarse_basis_out,
-                            basis_ctof_out, coarse_oper); CeedChk(ierr);
+                            basis_ctof_out, coarse_oper); PCeedChk(ierr);
    return 0;
 }
 
diff --git a/fem/ceed/solvers/solvers-atpmg.hpp b/fem/ceed/solvers/solvers-atpmg.hpp
index 8d85b1840..62a1640fe 100644
--- a/fem/ceed/solvers/solvers-atpmg.hpp
+++ b/fem/ceed/solvers/solvers-atpmg.hpp
@@ -25,7 +25,7 @@ namespace ceed
 /** @brief Take given (high-order) CeedElemRestriction and make a new
     CeedElemRestriction, which corresponds to a lower-order problem.
 
-    Assumes a Gauss-Lobatto basis and tensor product elements, and assumes that
+    Assumes a Gauss-Lobatto basis and tensor-product elements, and assumes that
     the nodes in er_in are ordered in a tensor-product way.
 
     This is a setup routine that operates on the host.
diff --git a/fem/doftrans.cpp b/fem/doftrans.cpp
index 95da3859d..02454d9ce 100644
--- a/fem/doftrans.cpp
+++ b/fem/doftrans.cpp
@@ -271,7 +271,7 @@ ND_TriDofTransformation::ND_TriDofTransformation(int p)
 void ND_TriDofTransformation::TransformPrimal(double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= 1,
                "Face orientations are unset in ND_TriDofTransformation");
@@ -290,11 +290,10 @@ void ND_TriDofTransformation::TransformPrimal(double *v) const
    }
 }
 
-void
-ND_TriDofTransformation::InvTransformPrimal(double *v) const
+void ND_TriDofTransformation::InvTransformPrimal(double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= 1,
                "Face orientations are unset in ND_TriDofTransformation");
@@ -313,11 +312,10 @@ ND_TriDofTransformation::InvTransformPrimal(double *v) const
    }
 }
 
-void
-ND_TriDofTransformation::TransformDual(double *v) const
+void ND_TriDofTransformation::TransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= 1,
                "Face orientations are unset in ND_TriDofTransformation");
@@ -336,11 +334,10 @@ ND_TriDofTransformation::TransformDual(double *v) const
    }
 }
 
-void
-ND_TriDofTransformation::InvTransformDual(double *v) const
+void ND_TriDofTransformation::InvTransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= 1,
                "Face orientations are unset in ND_TriDofTransformation");
@@ -367,7 +364,7 @@ ND_TetDofTransformation::ND_TetDofTransformation(int p)
 void ND_TetDofTransformation::TransformPrimal(double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= 4,
                "Face orientations are unset in ND_TetDofTransformation");
@@ -386,11 +383,10 @@ void ND_TetDofTransformation::TransformPrimal(double *v) const
    }
 }
 
-void
-ND_TetDofTransformation::InvTransformPrimal(double *v) const
+void ND_TetDofTransformation::InvTransformPrimal(double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= 4,
                "Face orientations are unset in ND_TetDofTransformation");
@@ -409,11 +405,10 @@ ND_TetDofTransformation::InvTransformPrimal(double *v) const
    }
 }
 
-void
-ND_TetDofTransformation::TransformDual(double *v) const
+void ND_TetDofTransformation::TransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= 4,
                "Face orientations are unset in ND_TetDofTransformation");
@@ -432,11 +427,10 @@ ND_TetDofTransformation::TransformDual(double *v) const
    }
 }
 
-void
-ND_TetDofTransformation::InvTransformDual(double *v) const
+void ND_TetDofTransformation::InvTransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= 4,
                "Face orientations are unset in ND_TetDofTransformation");
@@ -456,14 +450,14 @@ ND_TetDofTransformation::InvTransformDual(double *v) const
 }
 
 ND_WedgeDofTransformation::ND_WedgeDofTransformation(int p)
-   : ND_DofTransformation(3 * p * ((p + 1) * (p + 2))/2, p)
+   : ND_DofTransformation(3*p*((p + 1)*(p + 2))/2, p)
 {
 }
 
 void ND_WedgeDofTransformation::TransformPrimal(double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= 2,
                "Face orientations are unset in ND_WedgeDofTransformation");
@@ -482,11 +476,10 @@ void ND_WedgeDofTransformation::TransformPrimal(double *v) const
    }
 }
 
-void
-ND_WedgeDofTransformation::InvTransformPrimal(double *v) const
+void ND_WedgeDofTransformation::InvTransformPrimal(double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= 2,
                "Face orientations are unset in ND_WedgeDofTransformation");
@@ -505,11 +498,10 @@ ND_WedgeDofTransformation::InvTransformPrimal(double *v) const
    }
 }
 
-void
-ND_WedgeDofTransformation::TransformDual(double *v) const
+void ND_WedgeDofTransformation::TransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= 2,
                "Face orientations are unset in ND_WedgeDofTransformation");
@@ -528,11 +520,10 @@ ND_WedgeDofTransformation::TransformDual(double *v) const
    }
 }
 
-void
-ND_WedgeDofTransformation::InvTransformDual(double *v) const
+void ND_WedgeDofTransformation::InvTransformDual(double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= 2,
                "Face orientations are unset in ND_WedgeDofTransformation");
diff --git a/fem/doftrans.hpp b/fem/doftrans.hpp
index 9375246b5..d9cf74f5b 100644
--- a/fem/doftrans.hpp
+++ b/fem/doftrans.hpp
@@ -64,20 +64,20 @@ protected:
       : size_(size) {}
 
 public:
+   int Size() const { return size_; }
+   int Height() const { return size_; }
+   int NumRows() const { return size_; }
+   int Width() const { return size_; }
+   int NumCols() const { return size_; }
 
-   inline int Size() const { return size_; }
-   inline int Height() const { return size_; }
-   inline int NumRows() const { return size_; }
-   inline int Width() const { return size_; }
-   inline int NumCols() const { return size_; }
+   /// If the DofTransformation performs no transformation
+   virtual bool IsEmpty() const = 0;
 
    /** @brief Configure the transformation using face orientations for the
        current element. */
    /// The face_orientation array can be obtained from Mesh::GetElementFaces.
-   inline void SetFaceOrientations(const Array<int> & face_orientation)
-   { Fo = face_orientation; }
-
-   inline const Array<int> & GetFaceOrientations() const { return Fo; }
+   virtual void SetFaceOrientations(const Array<int> &face_orientations)
+   { Fo = face_orientations; }
 
    /** Transform local DoFs to align with the global DoFs. For example, this
        transformation can be used to map the local vector computed by
@@ -92,8 +92,7 @@ public:
    /** Inverse transform local DoFs. Used to transform DoFs from a global vector
        back to their element-local form. For example, this must be used to
        transform the vector obtained using GridFunction::GetSubVector before it
-       can be used to compute a local interpolation.
-   */
+       can be used to compute a local interpolation. */
    virtual void InvTransformPrimal(double *v) const = 0;
    virtual void InvTransformPrimal(Vector &v) const;
 
@@ -119,16 +118,14 @@ public:
 
 /** Transform a matrix of DoFs entries from different finite element spaces as
     computed by a DiscreteInterpolator before copying into a
-    DiscreteLinearOperator.
-*/
+    DiscreteLinearOperator. */
 void TransformPrimal(const DofTransformation *ran_dof_trans,
                      const DofTransformation *dom_dof_trans,
                      DenseMatrix &elmat);
 
 /** Transform a matrix of dual DoFs entries from different finite element spaces
     as computed by a BilinearFormIntegrator before summing into a
-    MixedBilinearForm object.
-*/
+    MixedBilinearForm object. */
 void TransformDual(const DofTransformation *ran_dof_trans,
                    const DofTransformation *dom_dof_trans,
                    DenseMatrix &elmat);
@@ -141,7 +138,7 @@ class VDofTransformation : public DofTransformation
 private:
    int vdim_;
    int ordering_;
-   DofTransformation * doftrans_;
+   DofTransformation *doftrans_;
 
 public:
    /** @brief Default constructor which requires that SetDofTransformation be
@@ -152,14 +149,14 @@ public:
         doftrans_(NULL) {}
 
    /// Constructor with a known DofTransformation
-   VDofTransformation(DofTransformation & doftrans, int vdim = 1,
+   VDofTransformation(DofTransformation &doftrans, int vdim = 1,
                       int ordering = 0)
       : DofTransformation(vdim * doftrans.Size()),
         vdim_(vdim), ordering_(ordering),
         doftrans_(&doftrans) {}
 
    /// Set or change the vdim parameter
-   inline void SetVDim(int vdim)
+   void SetVDim(int vdim)
    {
       vdim_ = vdim;
       if (doftrans_)
@@ -169,20 +166,22 @@ public:
    }
 
    /// Return the current vdim value
-   inline int GetVDim() const { return vdim_; }
+   int GetVDim() const { return vdim_; }
 
    /// Set or change the nested DofTransformation object
-   inline void SetDofTransformation(DofTransformation & doftrans)
+   void SetDofTransformation(DofTransformation &doftrans)
    {
       size_ = vdim_ * doftrans.Size();
       doftrans_ = &doftrans;
    }
 
    /// Return the nested DofTransformation object
-   inline DofTransformation * GetDofTransformation() const { return doftrans_; }
+   const DofTransformation *GetDofTransformation() const { return doftrans_; }
 
-   inline void SetFaceOrientation(const Array<int> & face_orientation)
-   { Fo = face_orientation; doftrans_->SetFaceOrientations(face_orientation); }
+   bool IsEmpty() const { return doftrans_->IsEmpty(); }
+
+   void SetFaceOrientations(const Array<int> &face_orientations)
+   { Fo = face_orientations; doftrans_->SetFaceOrientations(face_orientations); }
 
    using DofTransformation::TransformPrimal;
    using DofTransformation::InvTransformPrimal;
@@ -190,8 +189,11 @@ public:
    using DofTransformation::InvTransformDual;
 
    void TransformPrimal(double *v) const;
+
    void InvTransformPrimal(double *v) const;
+
    void TransformDual(double *v) const;
+
    void InvTransformDual(double *v) const;
 };
 
@@ -221,11 +223,13 @@ protected:
 
 public:
    // Return the 2x2 transformation operator for the given face orientation
-   static const DenseMatrix & GetFaceTransform(int ori) { return T(ori); }
+   static const DenseMatrix &GetFaceTransform(int ori) { return T(ori); }
 
    // Return the 2x2 inverse transformation operator
-   static const DenseMatrix & GetFaceInverseTransform(int ori)
+   static const DenseMatrix &GetFaceInverseTransform(int ori)
    { return TInv(ori); }
+
+   bool IsEmpty() const { return nfdofs < 2; }
 };
 
 /// DoF transformation implementation for the Nedelec basis on triangles
@@ -237,6 +241,7 @@ public:
    using DofTransformation::TransformPrimal;
    using DofTransformation::InvTransformPrimal;
    using DofTransformation::TransformDual;
+   using DofTransformation::InvTransformDual;
 
    void TransformPrimal(double *v) const;
 
@@ -245,7 +250,6 @@ public:
    void TransformDual(double *v) const;
 
    void InvTransformDual(double *v) const;
-   using DofTransformation::InvTransformDual;
 };
 
 /// DoF transformation implementation for the Nedelec basis on tetrahedra
@@ -286,7 +290,6 @@ public:
    void TransformDual(double *v) const;
 
    void InvTransformDual(double *v) const;
-
 };
 
 } // namespace mfem
diff --git a/fem/fe/fe_base.cpp b/fem/fe/fe_base.cpp
index 6f665bfa3..ded2ffc9c 100644
--- a/fem/fe/fe_base.cpp
+++ b/fem/fe/fe_base.cpp
@@ -401,7 +401,7 @@ const DofToQuad &FiniteElement::GetDofToQuad(const IntegrationRule &ir,
          }
       }
    }
-   else
+   else if (range_type == VECTOR)
    {
       d2q->B.SetSize(nqpt*dim*dof);
       d2q->Bt.SetSize(dof*nqpt*dim);
@@ -419,6 +419,10 @@ const DofToQuad &FiniteElement::GetDofToQuad(const IntegrationRule &ir,
          }
       }
    }
+   else
+   {
+      // Skip B and Bt for unknown range type
+   }
    switch (deriv_type)
    {
       case GRAD:
@@ -472,7 +476,7 @@ const DofToQuad &FiniteElement::GetDofToQuad(const IntegrationRule &ir,
             {
                for (int j = 0; j < dof; j++)
                {
-                  d2q->G[i+nqpt*(d+dim*j)] = d2q->Gt[j+dof*(i+nqpt*d)] = curlshape(j, d);
+                  d2q->G[i+nqpt*(d+cdim*j)] = d2q->Gt[j+dof*(i+nqpt*d)] = curlshape(j, d);
                }
             }
          }
@@ -480,7 +484,8 @@ const DofToQuad &FiniteElement::GetDofToQuad(const IntegrationRule &ir,
       }
       case NONE:
       default:
-         MFEM_ABORT("invalid finite element derivative type");
+         // Skip G and Gt for unknown derivative type
+         break;
    }
    dof2quad_array.Append(d2q);
    return *d2q;
diff --git a/fem/fe/fe_base.hpp b/fem/fe/fe_base.hpp
index b533525f0..6582140df 100644
--- a/fem/fe/fe_base.hpp
+++ b/fem/fe/fe_base.hpp
@@ -1288,9 +1288,9 @@ public:
    const DofToQuad &GetDofToQuad(const IntegrationRule &ir,
                                  DofToQuad::Mode mode) const override
    {
-      MFEM_VERIFY(mode != DofToQuad::FULL, "invalid mode requested");
-      return GetTensorDofToQuad(*this, ir, mode, basis1d, true,
-                                dof2quad_array);
+      return (mode == DofToQuad::FULL) ?
+             FiniteElement::GetDofToQuad(ir, mode) :
+             GetTensorDofToQuad(*this, ir, mode, basis1d, true, dof2quad_array);
    }
 
    const DofToQuad &GetDofToQuadOpen(const IntegrationRule &ir,
diff --git a/fem/fespace.cpp b/fem/fespace.cpp
index cb82c6008..59b4b7e31 100644
--- a/fem/fespace.cpp
+++ b/fem/fespace.cpp
@@ -1599,7 +1599,7 @@ void FiniteElementSpace::RefinementOperator
 
       subY.SetSize(lP.Height());
 
-      DofTransformation *doftrans = fespace->GetElementDofs(k, dofs);
+      const DofTransformation *doftrans = fespace->GetElementDofs(k, dofs);
       old_elem_dof->GetRow(emb.parent, old_dofs);
 
       if (!doftrans)
@@ -1620,9 +1620,9 @@ void FiniteElementSpace::RefinementOperator
          old_elem_fos->GetRow(emb.parent, old_Fo);
          old_DoFTrans[geom]->SetFaceOrientations(old_Fo);
 
-         DofTransformation *new_doftrans = NULL;
-         VDofTransformation *vdoftrans =
-            dynamic_cast<VDofTransformation*>(doftrans);
+         const DofTransformation *new_doftrans = NULL;
+         const VDofTransformation *vdoftrans =
+            dynamic_cast<const VDofTransformation *>(doftrans);
          if (vdoftrans)
          {
             new_doftrans = doftrans;
@@ -1675,7 +1675,7 @@ void FiniteElementSpace::RefinementOperator
       const Geometry::Type geom = mesh_ref->GetElementBaseGeometry(k);
       const DenseMatrix &lP = localP[geom](emb.matrix);
 
-      DofTransformation * doftrans = fespace->GetElementDofs(k, f_dofs);
+      const DofTransformation * doftrans = fespace->GetElementDofs(k, f_dofs);
       old_elem_dof->GetRow(emb.parent, c_dofs);
 
       if (!doftrans)
@@ -1710,9 +1710,9 @@ void FiniteElementSpace::RefinementOperator
          old_elem_fos->GetRow(emb.parent, old_Fo);
          old_DoFTrans[geom]->SetFaceOrientations(old_Fo);
 
-         DofTransformation *new_doftrans = NULL;
-         VDofTransformation *vdoftrans =
-            dynamic_cast<VDofTransformation*>(doftrans);
+         const DofTransformation *new_doftrans = NULL;
+         const VDofTransformation *vdoftrans =
+            dynamic_cast<const VDofTransformation *>(doftrans);
          if (vdoftrans)
          {
             new_doftrans = doftrans;
diff --git a/fem/fespace.hpp b/fem/fespace.hpp
index 00b290c09..588de9199 100644
--- a/fem/fespace.hpp
+++ b/fem/fespace.hpp
@@ -271,7 +271,7 @@ protected:
    int own_ext;
    mutable Array<int> face_to_be; // NURBS FE space only
 
-   Array<DofTransformation*> DoFTrans;
+   Array<DofTransformation *> DoFTrans;
    mutable VDofTransformation VDoFTrans;
 
    /** Matrix representing the prolongation from the global conforming dofs to
@@ -1268,11 +1268,9 @@ public:
 /// @brief Return true if the mesh contains only one topology and the elements are tensor elements.
 inline bool UsesTensorBasis(const FiniteElementSpace& fes)
 {
-   Mesh & mesh = *fes.GetMesh();
-   const bool mixed = mesh.GetNumGeometries(mesh.Dimension()) > 1;
-   // Potential issue: empty local mesh --> no element 0.
-   return !mixed &&
-          dynamic_cast<const mfem::TensorBasisElement *>(fes.GetFE(0))!=nullptr;
+   Mesh &mesh = *fes.GetMesh();
+   return mesh.GetNE() > 0 && mesh.GetNumGeometries(mesh.Dimension()) == 1 &&
+          dynamic_cast<const mfem::TensorBasisElement *>(fes.GetFE(0)) != nullptr;
 }
 
 }
diff --git a/fem/hybridization.cpp b/fem/hybridization.cpp
index f9d4699c2..06934064c 100644
--- a/fem/hybridization.cpp
+++ b/fem/hybridization.cpp
@@ -120,10 +120,10 @@ void Hybridization::ConstructC()
             vdofs[s1+j] = o2 + j;
          }
          c_fes->GetFaceVDofs(i, c_vdofs);
-         c_bfi->AssembleFaceMatrix(*c_fes->GetFaceElement(i),
-                                   *fes->GetFE(FTr->Elem1No),
-                                   *fes->GetFE(FTr->Elem2No),
-                                   *FTr, elmat);
+         c_bfi->AssembleFaceMatrix2(*c_fes->GetFaceElement(i),
+                                    *fes->GetFE(FTr->Elem1No),
+                                    *fes->GetFE(FTr->Elem2No),
+                                    *FTr, elmat);
          // zero-out small elements in elmat
          elmat.Threshold(1e-12 * elmat.MaxMaxNorm());
          Ct->AddSubMatrix(vdofs, c_vdofs, elmat, skip_zeros);
@@ -165,7 +165,7 @@ void Hybridization::ConstructC()
                vdofs[j] = o1 + j;
             }
             fe = fes->GetFE(FTr->Elem1No);
-            c_bfi->AssembleFaceMatrix(*face_fe, *fe, *fe, *FTr, elmat);
+            c_bfi->AssembleFaceMatrix2(*face_fe, *fe, *fe, *FTr, elmat);
             // zero-out small elements in elmat
             elmat.Threshold(1e-12 * elmat.MaxMaxNorm());
             Ct->AddSubMatrix(vdofs, c_vdofs, elmat, skip_zeros);
diff --git a/fem/integ/bilininteg_br2.cpp b/fem/integ/bilininteg_br2.cpp
index 159947029..846d72c7c 100644
--- a/fem/integ/bilininteg_br2.cpp
+++ b/fem/integ/bilininteg_br2.cpp
@@ -152,20 +152,7 @@ void DGDiffusionBR2Integrator::AssembleFaceMatrix(
    elmat.SetSize(ndofs);
    elmat = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      if (ndof2)
-      {
-         order = 2*std::max(el1.GetOrder(), el2.GetOrder());
-      }
-      else
-      {
-         order = 2*el1.GetOrder();
-      }
-      ir = &IntRules.Get(Trans.FaceGeom, order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, el2, Trans);
 
    for (int p = 0; p < ir->GetNPoints(); p++)
    {
diff --git a/fem/integ/bilininteg_convection_mf.cpp b/fem/integ/bilininteg_convection_mf.cpp
index bbaf82788..c7078d407 100644
--- a/fem/integ/bilininteg_convection_mf.cpp
+++ b/fem/integ/bilininteg_convection_mf.cpp
@@ -19,31 +19,42 @@ namespace mfem
 
 void ConvectionIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &Trans = *fes.GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFConvectionIntegrator(*this, fes, Q, alpha);
-      }
-      else
-      {
-         ceedOp = new ceed::MFConvectionIntegrator(fes, *ir, Q, alpha);
-      }
+      ceedOp = new ceed::MFConvectionIntegrator(*this, fes, Q, alpha);
       return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *fes.GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: ConvectionIntegrator::AssembleMF only implemented with"
               " libCEED");
 }
 
+void ConvectionIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::MFConvectionIntegrator(*this, fes, Q, alpha, true);
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *fes.GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: ConvectionIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
 void ConvectionIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    if (DeviceCanUseCeed())
diff --git a/fem/integ/bilininteg_convection_pa.cpp b/fem/integ/bilininteg_convection_pa.cpp
index 25928f002..74156c726 100644
--- a/fem/integ/bilininteg_convection_pa.cpp
+++ b/fem/integ/bilininteg_convection_pa.cpp
@@ -116,26 +116,19 @@ void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &Trans = *fes.GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
+   if (mesh->GetNE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAConvectionIntegrator(*this, fes, Q, alpha);
-      }
-      else
-      {
-         ceedOp = new ceed::PAConvectionIntegrator(fes, *ir, Q, alpha);
-      }
+      ceedOp = new ceed::PAConvectionIntegrator(*this, fes, Q, alpha);
       return;
    }
+
+   // Assumes tensor-product elements
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *fes.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    const int dims = el.GetDim();
    const int symmDims = dims;
    nq = ir->GetNPoints();
@@ -166,6 +159,25 @@ void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
+void ConvectionIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PAConvectionIntegrator(*this, fes, Q, alpha, true);
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *fes.GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: ConvectionIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
 void ConvectionIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
diff --git a/fem/integ/bilininteg_curlcurl_mf.cpp b/fem/integ/bilininteg_curlcurl_mf.cpp
new file mode 100644
index 000000000..54c88055b
--- /dev/null
+++ b/fem/integ/bilininteg_curlcurl_mf.cpp
@@ -0,0 +1,89 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/curlcurl/curlcurl.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void CurlCurlIntegrator::AssembleMF(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, MQ); }
+      else if (DQ) { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, DQ); }
+      else { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, Q); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: CurlCurlIntegrator::AssembleMF only implemented with"
+              " libCEED");
+}
+
+void CurlCurlIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, MQ, true); }
+      else if (DQ) { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, DQ, true); }
+      else { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: CurlCurlIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
+void CurlCurlIntegrator::AssembleDiagonalMF(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlCurlIntegrator::AssembleDiagonalMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void CurlCurlIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlCurlIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_curlcurl_pa.cpp b/fem/integ/bilininteg_curlcurl_pa.cpp
index 3d12d978a..7b17fc94d 100644
--- a/fem/integ/bilininteg_curlcurl_pa.cpp
+++ b/fem/integ/bilininteg_curlcurl_pa.cpp
@@ -13,6 +13,7 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/curlcurl/curlcurl.hpp"
 #include "bilininteg_hcurl_kernels.hpp"
 
 namespace mfem
@@ -20,32 +21,35 @@ namespace mfem
 
 void CurlCurlIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement *fel = fes.GetFE(0);
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, MQ); }
+      else if (DQ) { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, DQ); }
+      else { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, Q); }
+      return;
+   }
 
+   // Assumes tensor-product elements
+   const FiniteElement *fel = fes.GetFE(0);
    const VectorTensorFiniteElement *el =
       dynamic_cast<const VectorTensorFiniteElement*>(fel);
    MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*el, *el,
-                                                     *mesh->GetElementTransformation(0));
-
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
    const int dims = el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
-
    nq = ir->GetNPoints();
    dim = mesh->Dimension();
    MFEM_VERIFY(dim == 2 || dim == 3, "");
-
    ne = fes.GetNE();
    geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
    mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
    mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
    dofs1D = mapsC->ndof;
    quad1D = mapsC->nqpt;
-
    MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
 
    QuadratureSpace qs(*mesh, *ir);
@@ -78,131 +82,153 @@ void CurlCurlIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
-void CurlCurlIntegrator::AssembleDiagonalPA(Vector& diag)
+void CurlCurlIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
 {
-   if (dim == 3)
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, MQ, true); }
+      else if (DQ) { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, DQ, true); }
+      else { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: CurlCurlIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void CurlCurlIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
    {
-      if (Device::Allows(Backend::DEVICE_MASK))
+      if (dim == 3)
       {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
+         if (Device::Allows(Backend::DEVICE_MASK))
          {
-            case 0x23:
-               return internal::SmemPACurlCurlAssembleDiagonal3D<2,3>(
-                         dofs1D,
-                         quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
-            case 0x34:
-               return internal::SmemPACurlCurlAssembleDiagonal3D<3,4>(
-                         dofs1D,
-                         quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
-            case 0x45:
-               return internal::SmemPACurlCurlAssembleDiagonal3D<4,5>(
-                         dofs1D,
-                         quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
-            case 0x56:
-               return internal::SmemPACurlCurlAssembleDiagonal3D<5,6>(
-                         dofs1D,
-                         quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
-            default:
-               return internal::SmemPACurlCurlAssembleDiagonal3D(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D<2,3>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+               case 0x34:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D<3,4>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+               case 0x45:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D<4,5>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+               case 0x56:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D<5,6>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+               default:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+            }
          }
+         else
+         {
+            internal::PACurlCurlAssembleDiagonal3D(dofs1D, quad1D, symmetric, ne,
+                                                   mapsO->B, mapsC->B,
+                                                   mapsO->G, mapsC->G,
+                                                   pa_data, diag);
+         }
+      }
+      else if (dim == 2)
+      {
+         internal::PACurlCurlAssembleDiagonal2D(dofs1D, quad1D, ne,
+                                                mapsO->B, mapsC->G, pa_data, diag);
       }
       else
       {
-         internal::PACurlCurlAssembleDiagonal3D(dofs1D, quad1D, symmetric, ne,
-                                                mapsO->B, mapsC->B,
-                                                mapsO->G, mapsC->G,
-                                                pa_data, diag);
+         MFEM_ABORT("Unsupported dimension!");
       }
    }
-   else if (dim == 2)
-   {
-      internal::PACurlCurlAssembleDiagonal2D(dofs1D, quad1D, ne,
-                                             mapsO->B, mapsC->G, pa_data, diag);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
 }
 
 void CurlCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   if (dim == 3)
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
    {
-      if (Device::Allows(Backend::DEVICE_MASK))
+      if (dim == 3)
       {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
+         if (Device::Allows(Backend::DEVICE_MASK))
+         {
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPACurlCurlApply3D<2,3>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+               case 0x34:
+                  return internal::SmemPACurlCurlApply3D<3,4>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+               case 0x45:
+                  return internal::SmemPACurlCurlApply3D<4,5>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+               case 0x56:
+                  return internal::SmemPACurlCurlApply3D<5,6>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+               default:
+                  return internal::SmemPACurlCurlApply3D(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+            }
+         }
+         else
          {
-            case 0x23:
-               return internal::SmemPACurlCurlApply3D<2,3>(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x34:
-               return internal::SmemPACurlCurlApply3D<3,4>(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x45:
-               return internal::SmemPACurlCurlApply3D<4,5>(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x56:
-               return internal::SmemPACurlCurlApply3D<5,6>(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
-            default:
-               return internal::SmemPACurlCurlApply3D(
-                         dofs1D, quad1D, symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
+            internal::PACurlCurlApply3D(dofs1D, quad1D, symmetric, ne, mapsO->B, mapsC->B,
+                                        mapsO->Bt, mapsC->Bt, mapsC->G, mapsC->Gt,
+                                        pa_data, x, y);
          }
       }
+      else if (dim == 2)
+      {
+         internal::PACurlCurlApply2D(dofs1D, quad1D, ne, mapsO->B, mapsO->Bt,
+                                     mapsC->G, mapsC->Gt, pa_data, x, y);
+      }
       else
       {
-         internal::PACurlCurlApply3D(dofs1D, quad1D, symmetric, ne, mapsO->B, mapsC->B,
-                                     mapsO->Bt, mapsC->Bt, mapsC->G, mapsC->Gt,
-                                     pa_data, x, y);
+         MFEM_ABORT("Unsupported dimension!");
       }
    }
-   else if (dim == 2)
-   {
-      internal::PACurlCurlApply2D(dofs1D, quad1D, ne, mapsO->B, mapsO->Bt,
-                                  mapsC->G, mapsC->Gt, pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
 }
 
 } // namespace mfem
diff --git a/fem/integ/bilininteg_dgtrace_pa.cpp b/fem/integ/bilininteg_dgtrace_pa.cpp
index f4b8d837c..284191c13 100644
--- a/fem/integ/bilininteg_dgtrace_pa.cpp
+++ b/fem/integ/bilininteg_dgtrace_pa.cpp
@@ -123,9 +123,7 @@ void DGTraceIntegrator::SetupPA(const FiniteElementSpace &fes, FaceType type)
       *fes.GetTraceElement(0, fes.GetMesh()->GetFaceGeometry(0));
    FaceElementTransformations &T0 =
       *fes.GetMesh()->GetFaceElementTransformations(0);
-   const IntegrationRule *ir = IntRule?
-                               IntRule:
-                               &GetRule(el.GetGeomType(), el.GetOrder(), T0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*fes.GetFE(0), T0);
    const int symmDims = 4;
    nq = ir->GetNPoints();
    dim = mesh->Dimension();
diff --git a/fem/integ/bilininteg_diffusion_mf.cpp b/fem/integ/bilininteg_diffusion_mf.cpp
index 0896b8bf9..0a39a442c 100644
--- a/fem/integ/bilininteg_diffusion_mf.cpp
+++ b/fem/integ/bilininteg_diffusion_mf.cpp
@@ -18,33 +18,46 @@ namespace mfem
 
 void DiffusionIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      MFEM_VERIFY(!VQ && !MQ,
-                  "Only scalar coefficient supported for DiffusionIntegrator"
-                  " with libCEED");
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFDiffusionIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFDiffusionIntegrator(fes, *ir, Q);
-      }
+      if (MQ) { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, MQ); }
+      else if (VQ) { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, VQ); }
+      else { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, Q); }
       return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: DiffusionIntegrator::AssembleMF only implemented with"
               " libCEED");
 }
 
+void DiffusionIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, MQ, true); }
+      else if (VQ) { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, VQ, true); }
+      else { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: DiffusionIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
 void DiffusionIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    if (DeviceCanUseCeed())
diff --git a/fem/integ/bilininteg_diffusion_pa.cpp b/fem/integ/bilininteg_diffusion_pa.cpp
index a966c8520..7cf050870 100644
--- a/fem/integ/bilininteg_diffusion_pa.cpp
+++ b/fem/integ/bilininteg_diffusion_pa.cpp
@@ -22,29 +22,21 @@ void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      MFEM_VERIFY(!VQ && !MQ,
-                  "Only scalar coefficient supported for DiffusionIntegrator"
-                  " with libCEED");
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPADiffusionIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PADiffusionIntegrator(fes, *ir, Q);
-      }
+      if (MQ) { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, MQ); }
+      else if (VQ) { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, VQ); }
+      else { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, Q); }
       return;
    }
+
+   // Assuming the same element type
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    const int dims = el.GetDim();
    const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
    const int nq = ir->GetNPoints();
@@ -73,6 +65,27 @@ void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
                               ir->GetWeights(), geom->J, coeff, pa_data);
 }
 
+void DiffusionIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, MQ, true); }
+      else if (VQ) { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, VQ, true); }
+      else { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: DiffusionIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
 void DiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
diff --git a/fem/integ/bilininteg_divdiv_mf.cpp b/fem/integ/bilininteg_divdiv_mf.cpp
new file mode 100644
index 000000000..7d8ea409e
--- /dev/null
+++ b/fem/integ/bilininteg_divdiv_mf.cpp
@@ -0,0 +1,85 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/divdiv/divdiv.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void DivDivIntegrator::AssembleMF(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::MFDivDivIntegrator(*this, fes, Q);
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DivDivIntegrator::AssembleMF only implemented with"
+              " libCEED");
+}
+
+void DivDivIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::MFDivDivIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DivDivIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
+void DivDivIntegrator::AssembleDiagonalMF(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
+   {
+      MFEM_ABORT("Error: DivDivIntegrator::AssembleDiagonalMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void DivDivIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Error: DivDivIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_divdiv_pa.cpp b/fem/integ/bilininteg_divdiv_pa.cpp
index 8abf233a7..ec85f6c22 100644
--- a/fem/integ/bilininteg_divdiv_pa.cpp
+++ b/fem/integ/bilininteg_divdiv_pa.cpp
@@ -13,6 +13,7 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/divdiv/divdiv.hpp"
 #include "bilininteg_hdiv_kernels.hpp"
 
 namespace mfem
@@ -20,33 +21,34 @@ namespace mfem
 
 void DivDivIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement *fel = fes.GetFE(0);
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PADivDivIntegrator(*this, fes, Q);
+      return;
+   }
 
+   // Assumes tensor-product elements
+   const FiniteElement *fel = fes.GetFE(0);
    const VectorTensorFiniteElement *el =
       dynamic_cast<const VectorTensorFiniteElement*>(fel);
    MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir = IntRule ? IntRule : &MassIntegrator::GetRule
-                               (*el, *el, *mesh->GetElementTransformation(0));
-
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
    const int dims = el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
-
    const int nq = ir->GetNPoints();
    dim = mesh->Dimension();
    MFEM_VERIFY(dim == 2 || dim == 3, "");
-
    ne = fes.GetNE();
    geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
    mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
    mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
    dofs1D = mapsC->ndof;
    quad1D = mapsC->nqpt;
-
    MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
    pa_data.SetSize(nq * ne, Device::GetMemoryType());
 
    QuadratureSpace qs(*mesh, *ir);
@@ -68,31 +70,72 @@ void DivDivIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
-void DivDivIntegrator::AssembleDiagonalPA(Vector& diag)
+void DivDivIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
 {
-   if (dim == 3)
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
    {
-      internal::PADivDivAssembleDiagonal3D(dofs1D, quad1D, ne,
-                                           mapsO->B, mapsC->G, pa_data, diag);
+      delete ceedOp;
+      ceedOp = new ceed::PADivDivIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DivDivIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void DivDivIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
    }
    else
    {
-      internal::PADivDivAssembleDiagonal2D(dofs1D, quad1D, ne,
-                                           mapsO->B, mapsC->G, pa_data, diag);
+      if (dim == 3)
+      {
+         internal::PADivDivAssembleDiagonal3D(dofs1D, quad1D, ne,
+                                              mapsO->B, mapsC->G, pa_data, diag);
+      }
+      else if (dim == 2)
+      {
+         internal::PADivDivAssembleDiagonal2D(dofs1D, quad1D, ne,
+                                              mapsO->B, mapsC->G, pa_data, diag);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension!");
+      }
    }
 }
 
 void DivDivIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   if (dim == 3)
-      internal::PADivDivApply3D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
-                                mapsO->Bt, mapsC->Gt, pa_data, x, y);
-   else if (dim == 2)
-      internal::PADivDivApply2D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
-                                mapsO->Bt, mapsC->Gt, pa_data, x, y);
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
    else
    {
-      MFEM_ABORT("Unsupported dimension!");
+      if (dim == 3)
+      {
+         internal::PADivDivApply3D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
+                                   mapsO->Bt, mapsC->Gt, pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         internal::PADivDivApply2D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
+                                   mapsO->Bt, mapsC->Gt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension!");
+      }
    }
 }
 
diff --git a/fem/integ/bilininteg_gradient_pa.cpp b/fem/integ/bilininteg_gradient_pa.cpp
index 20ef4684d..cb37e981a 100644
--- a/fem/integ/bilininteg_gradient_pa.cpp
+++ b/fem/integ/bilininteg_gradient_pa.cpp
@@ -167,9 +167,8 @@ void GradientIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    Mesh *mesh = trial_fes.GetMesh();
    const FiniteElement &trial_fe = *trial_fes.GetFE(0);
    const FiniteElement &test_fe = *test_fes.GetFE(0);
-   ElementTransformation *trans = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
-                                                            *trans);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe, T);
    const int dims = trial_fe.GetDim();
    const int dimsToStore = dims * dims;
    nq = ir->GetNPoints();
diff --git a/fem/integ/bilininteg_interp_curl_pa.cpp b/fem/integ/bilininteg_interp_curl_pa.cpp
new file mode 100644
index 000000000..cc9502ce0
--- /dev/null
+++ b/fem/integ/bilininteg_interp_curl_pa.cpp
@@ -0,0 +1,65 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../ceed/integrators/interp/interp.hpp"
+
+namespace mfem
+{
+
+void CurlInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                  const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PADiscreteInterpolator(*this, trial_fes, test_fes);
+      return;
+   }
+
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   // const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   // const FiniteElement *test_fel = test_fes.GetFE(0);
+   MFEM_ABORT("Error: CurlInterpolator::AssemblePA only implemented with libCEED");
+}
+
+void CurlInterpolator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlInterpolator::AddMultPA only implemented with"
+                 " libCEED");
+   }
+}
+
+void CurlInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMultTranspose(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlInterpolator::AddMultTransposePA only implemented"
+                 "with libCEED");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_interp_pa.cpp b/fem/integ/bilininteg_interp_grad_pa.cpp
similarity index 55%
rename from fem/integ/bilininteg_interp_pa.cpp
rename to fem/integ/bilininteg_interp_grad_pa.cpp
index 3cac18c65..4ec50e083 100644
--- a/fem/integ/bilininteg_interp_pa.cpp
+++ b/fem/integ/bilininteg_interp_grad_pa.cpp
@@ -13,10 +13,68 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/interp/interp.hpp"
 
 namespace mfem
 {
 
+void GradientInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PADiscreteInterpolator(*this, trial_fes, test_fes);
+      return;
+   }
+
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "Bad dimension!");
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "Bad dimension!");
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(),
+               "Orders do not match!");
+   ne = trial_fes.GetNE();
+
+   const int order = trial_el->GetOrder();
+   dofquad_fe = new H1_SegmentElement(order, trial_el->GetBasisType());
+   mfem::QuadratureFunctions1D qf1d;
+   mfem::IntegrationRule closed_ir;
+   closed_ir.SetSize(order + 1);
+   qf1d.GaussLobatto(order + 1, &closed_ir);
+   mfem::IntegrationRule open_ir;
+   open_ir.SetSize(order);
+   qf1d.GaussLegendre(order, &open_ir);
+
+   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
+   o_dofs1D = maps_O_C->nqpt;
+   if (trial_el->GetBasisType() == BasisType::GaussLobatto)
+   {
+      B_id = true;
+      c_dofs1D = maps_O_C->ndof;
+   }
+   else
+   {
+      B_id = false;
+      maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
+      c_dofs1D = maps_C_C->nqpt;
+   }
+}
+
 // Apply to x corresponding to DOFs in H^1 (domain) the (topological) gradient
 // to get a dof in H(curl) (range). You can think of the range as the "test" space
 // and the domain as the "trial" space, but there's no integration.
@@ -1017,920 +1075,85 @@ static void PAHcurlApplyGradientTranspose3DBId(
    });
 }
 
-void GradientInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                      const FiniteElementSpace &test_fes)
+void GradientInterpolator::AddMultPA(const Vector &x, Vector &y) const
 {
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "Bad dimension!");
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "Bad dimension!");
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(),
-               "Orders do not match!");
-   ne = trial_fes.GetNE();
-
-   const int order = trial_el->GetOrder();
-   dofquad_fe = new H1_SegmentElement(order, trial_el->GetBasisType());
-   mfem::QuadratureFunctions1D qf1d;
-   mfem::IntegrationRule closed_ir;
-   closed_ir.SetSize(order + 1);
-   qf1d.GaussLobatto(order + 1, &closed_ir);
-   mfem::IntegrationRule open_ir;
-   open_ir.SetSize(order);
-   qf1d.GaussLegendre(order, &open_ir);
-
-   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
-   o_dofs1D = maps_O_C->nqpt;
-   if (trial_el->GetBasisType() == BasisType::GaussLobatto)
+   if (DeviceCanUseCeed())
    {
-      B_id = true;
-      c_dofs1D = maps_O_C->ndof;
+      ceedOp->AddMult(x, y);
    }
    else
    {
-      B_id = false;
-      maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
-      c_dofs1D = maps_C_C->nqpt;
-   }
-}
-
-void GradientInterpolator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      if (B_id)
+      if (dim == 3)
       {
-         PAHcurlApplyGradient3DBId(c_dofs1D, o_dofs1D, ne,
+         if (B_id)
+         {
+            PAHcurlApplyGradient3DBId(c_dofs1D, o_dofs1D, ne,
+                                      maps_O_C->G, x, y);
+         }
+         else
+         {
+            PAHcurlApplyGradient3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
                                    maps_O_C->G, x, y);
+         }
       }
-      else
-      {
-         PAHcurlApplyGradient3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                maps_O_C->G, x, y);
-      }
-   }
-   else if (dim == 2)
-   {
-      if (B_id)
+      else if (dim == 2)
       {
-         PAHcurlApplyGradient2DBId(c_dofs1D, o_dofs1D, ne,
-                                   maps_O_C->G, x, y);
+         if (B_id)
+         {
+            PAHcurlApplyGradient2DBId(c_dofs1D, o_dofs1D, ne,
+                                      maps_O_C->G, x, y);
+         }
+         else
+         {
+            PAHcurlApplyGradient2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->G,
+                                   x, y);
+         }
       }
       else
       {
-         PAHcurlApplyGradient2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->G,
-                                x, y);
+         MFEM_ABORT("Bad dimension!");
       }
    }
-   else
-   {
-      mfem_error("Bad dimension!");
-   }
 }
 
 void GradientInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
-   if (dim == 3)
-   {
-      if (B_id)
-      {
-         PAHcurlApplyGradientTranspose3DBId(c_dofs1D, o_dofs1D, ne,
-                                            maps_O_C->G, x, y);
-      }
-      else
-      {
-         PAHcurlApplyGradientTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                         maps_O_C->G, x, y);
-      }
-   }
-   else if (dim == 2)
+   if (DeviceCanUseCeed())
    {
-      if (B_id)
-      {
-         PAHcurlApplyGradientTranspose2DBId(c_dofs1D, o_dofs1D, ne,
-                                            maps_O_C->G, x, y);
-      }
-      else
-      {
-         PAHcurlApplyGradientTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                         maps_O_C->G, x, y);
-      }
+      ceedOp->AddMultTranspose(x, y);
    }
    else
    {
-      mfem_error("Bad dimension!");
-   }
-}
-
-static void PAHcurlVecH1IdentityApply2D(const int c_dofs1D,
-                                        const int o_dofs1D,
-                                        const int NE,
-                                        const Array<double> &Bclosed,
-                                        const Array<double> &Bopen,
-                                        const Vector &pa_data,
-                                        const Vector &x_,
-                                        Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, 2, NE);
-   auto y = Reshape(y_.ReadWrite(), (2 * c_dofs1D * o_dofs1D), NE);
-
-   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[2][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y)
-
-      // contract in y
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               w[j][dx][ey] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w[j][dx][ey] += Bc(ey, dy) * x(dx, dy, j, e);
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += Bo(ex, dx) * w[j][dx][ey];
-               }
-               const int local_index = ey*o_dofs1D + ex;
-               y(local_index, e) += s * vk(j, local_index, e);
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x)
-
-      // contract in y
-      for (int ey = 0; ey < o_dofs1D; ++ey)
+      if (dim == 3)
       {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
+         if (B_id)
          {
-            for (int j=0; j<2; ++j)
-            {
-               w[j][dx][ey] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w[j][dx][ey] += Bo(ey, dy) * x(dx, dy, j, e);
-               }
-            }
+            PAHcurlApplyGradientTranspose3DBId(c_dofs1D, o_dofs1D, ne,
+                                               maps_O_C->G, x, y);
          }
-      }
-
-      // contract in x
-      for (int ey = 0; ey < o_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
+         else
          {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += Bc(ex, dx) * w[j][dx][ey];
-               }
-               const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-               y(local_index, e) += s * vk(j, local_index, e);
-            }
+            PAHcurlApplyGradientTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                            maps_O_C->G, x, y);
          }
       }
-   });
-}
-
-static void PAHcurlVecH1IdentityApplyTranspose2D(const int c_dofs1D,
-                                                 const int o_dofs1D,
-                                                 const int NE,
-                                                 const Array<double> &Bclosed,
-                                                 const Array<double> &Bopen,
-                                                 const Vector &pa_data,
-                                                 const Vector &x_,
-                                                 Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), (2 * c_dofs1D * o_dofs1D), NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, 2, NE);
-
-   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   //constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[2][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y)
-
-      // contract in x
-      for (int ey = 0; ey < c_dofs1D; ++ey)
+      else if (dim == 2)
       {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
-         }
-         for (int ex = 0; ex < o_dofs1D; ++ex)
+         if (B_id)
          {
-            const int local_index = ey*o_dofs1D + ex;
-            const double xd = x(local_index, e);
-
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<2; ++j)
-               {
-                  w[j][dx][ey] += Bo(ex, dx) * xd * vk(j, local_index, e);
-               }
-            }
+            PAHcurlApplyGradientTranspose2DBId(c_dofs1D, o_dofs1D, ne,
+                                               maps_O_C->G, x, y);
          }
-      }
-
-      // contract in y
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
+         else
          {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int ey = 0; ey < c_dofs1D; ++ey)
-               {
-                  s += w[j][dx][ey] * Bc(ey, dy);
-               }
-               y(dx, dy, j, e) += s;
-            }
+            PAHcurlApplyGradientTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                            maps_O_C->G, x, y);
          }
       }
-
-      // dofs that point parallel to y-axis (open in y, closed in x)
-
-      // contract in x
-      for (int ey = 0; ey < o_dofs1D; ++ey)
+      else
       {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
-         }
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-            const double xd = x(local_index, e);
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<2; ++j)
-               {
-                  w[j][dx][ey] += Bc(ex, dx) * xd * vk(j, local_index, e);
-               }
-            }
-         }
+         MFEM_ABORT("Bad dimension!");
       }
-
-      // contract in y
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int ey = 0; ey < o_dofs1D; ++ey)
-               {
-                  s += w[j][dx][ey] * Bo(ey, dy);
-               }
-               y(dx, dy, j, e) += s;
-            }
-         }
-      }
-   });
-}
-
-static void PAHcurlVecH1IdentityApply3D(const int c_dofs1D,
-                                        const int o_dofs1D,
-                                        const int NE,
-                                        const Array<double> &Bclosed,
-                                        const Array<double> &Bopen,
-                                        const Vector &pa_data,
-                                        const Vector &x_,
-                                        Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
-   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-
-   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
-                     NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bo(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bo(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-
-      // contract in z
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bo(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-   });
-}
-
-static void PAHcurlVecH1IdentityApplyTranspose3D(const int c_dofs1D,
-                                                 const int o_dofs1D,
-                                                 const int NE,
-                                                 const Array<double> &Bclosed,
-                                                 const Array<double> &Bopen,
-                                                 const Vector &pa_data,
-                                                 const Vector &x_,
-                                                 Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
-
-   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
-                     NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < o_dofs1D; ++ex)
-               {
-                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bo(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < c_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < c_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < c_dofs1D; ++ex)
-               {
-                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < o_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bo(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < c_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-
-      // contract in x
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < c_dofs1D; ++ex)
-               {
-                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < c_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < o_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bo(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-   });
-}
-
-void IdentityInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                      const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
-
-   ne = trial_fes.GetNE();
-
-   const int order = trial_el->GetOrder();
-   dofquad_fe = new H1_SegmentElement(order);
-   mfem::QuadratureFunctions1D qf1d;
-   mfem::IntegrationRule closed_ir;
-   closed_ir.SetSize(order + 1);
-   qf1d.GaussLobatto(order + 1, &closed_ir);
-   mfem::IntegrationRule open_ir;
-   open_ir.SetSize(order);
-   qf1d.GaussLegendre(order, &open_ir);
-
-   maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
-   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
-
-   o_dofs1D = maps_O_C->nqpt;
-   c_dofs1D = maps_C_C->nqpt;
-   MFEM_VERIFY(maps_O_C->ndof == c_dofs1D &&
-               maps_C_C->ndof == c_dofs1D, "Discrepancy in the number of DOFs");
-
-   const int ndof_test = (dim == 3) ? 3 * c_dofs1D * c_dofs1D * o_dofs1D
-                         : 2 * c_dofs1D * o_dofs1D;
-
-   const IntegrationRule & Nodes = test_el->GetNodes();
-
-   pa_data.SetSize(dim * ndof_test * ne, Device::GetMemoryType());
-   auto op = Reshape(pa_data.HostWrite(), dim, ndof_test, ne);
-
-   const Array<int> &dofmap = test_el->GetDofMap();
-
-   if (dim == 3)
-   {
-      // Note that ND_HexahedronElement uses 6 vectors in tk rather than 3, with
-      // the last 3 having negative signs. Here the signs are all positive, as
-      // signs are applied in ElementRestriction.
-
-      const double tk[9] = { 1.,0.,0.,  0.,1.,0.,  0.,0.,1. };
-
-      for (int c=0; c<3; ++c)
-      {
-         for (int i=0; i<ndof_test/3; ++i)
-         {
-            const int d = (c*ndof_test/3) + i;
-            // ND_HexahedronElement sets dof2tk = (dofmap < 0) ? 3+c : c, but here
-            // no signs should be applied due to ElementRestriction.
-            const int dof2tk = c;
-            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
-
-            for (int e=0; e<ne; ++e)
-            {
-               double v[3];
-               ElementTransformation *tr = mesh->GetElementTransformation(e);
-               tr->SetIntPoint(&Nodes.IntPoint(id));
-               tr->Jacobian().Mult(tk + dof2tk*dim, v);
-
-               for (int j=0; j<3; ++j)
-               {
-                  op(j,d,e) = v[j];
-               }
-            }
-         }
-      }
-   }
-   else // 2D case
-   {
-      const double tk[4] = { 1.,0.,  0.,1. };
-      for (int c=0; c<2; ++c)
-      {
-         for (int i=0; i<ndof_test/2; ++i)
-         {
-            const int d = (c*ndof_test/2) + i;
-            // ND_QuadrilateralElement sets dof2tk = (dofmap < 0) ? 2+c : c, but here
-            // no signs should be applied due to ElementRestriction.
-            const int dof2tk = c;
-            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
-
-            for (int e=0; e<ne; ++e)
-            {
-               double v[2];
-               ElementTransformation *tr = mesh->GetElementTransformation(e);
-               tr->SetIntPoint(&Nodes.IntPoint(id));
-               tr->Jacobian().Mult(tk + dof2tk*dim, v);
-
-               for (int j=0; j<2; ++j)
-               {
-                  op(j,d,e) = v[j];
-               }
-            }
-         }
-      }
-   }
-}
-
-void IdentityInterpolator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      PAHcurlVecH1IdentityApply3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
-                                  pa_data, x, y);
-   }
-   else if (dim == 2)
-   {
-      PAHcurlVecH1IdentityApply2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
-                                  pa_data, x, y);
-   }
-   else
-   {
-      mfem_error("Bad dimension!");
-   }
-}
-
-void IdentityInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      PAHcurlVecH1IdentityApplyTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                           maps_O_C->B, pa_data, x, y);
-   }
-   else if (dim == 2)
-   {
-      PAHcurlVecH1IdentityApplyTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                           maps_O_C->B, pa_data, x, y);
-   }
-   else
-   {
-      mfem_error("Bad dimension!");
    }
 }
 
diff --git a/fem/integ/bilininteg_interp_id_pa.cpp b/fem/integ/bilininteg_interp_id_pa.cpp
new file mode 100644
index 000000000..efabe7c80
--- /dev/null
+++ b/fem/integ/bilininteg_interp_id_pa.cpp
@@ -0,0 +1,843 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../ceed/integrators/interp/interp.hpp"
+
+namespace mfem
+{
+
+void IdentityInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PADiscreteInterpolator(*this, trial_fes, test_fes);
+      return;
+   }
+
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
+
+   ne = trial_fes.GetNE();
+
+   const int order = trial_el->GetOrder();
+   dofquad_fe = new H1_SegmentElement(order);
+   mfem::QuadratureFunctions1D qf1d;
+   mfem::IntegrationRule closed_ir;
+   closed_ir.SetSize(order + 1);
+   qf1d.GaussLobatto(order + 1, &closed_ir);
+   mfem::IntegrationRule open_ir;
+   open_ir.SetSize(order);
+   qf1d.GaussLegendre(order, &open_ir);
+
+   maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
+   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
+
+   o_dofs1D = maps_O_C->nqpt;
+   c_dofs1D = maps_C_C->nqpt;
+   MFEM_VERIFY(maps_O_C->ndof == c_dofs1D &&
+               maps_C_C->ndof == c_dofs1D, "Discrepancy in the number of DOFs");
+
+   const int ndof_test = (dim == 3) ? 3 * c_dofs1D * c_dofs1D * o_dofs1D
+                         : 2 * c_dofs1D * o_dofs1D;
+
+   const IntegrationRule & Nodes = test_el->GetNodes();
+
+   pa_data.SetSize(dim * ndof_test * ne, Device::GetMemoryType());
+   auto op = Reshape(pa_data.HostWrite(), dim, ndof_test, ne);
+
+   const Array<int> &dofmap = test_el->GetDofMap();
+
+   if (dim == 3)
+   {
+      // Note that ND_HexahedronElement uses 6 vectors in tk rather than 3, with
+      // the last 3 having negative signs. Here the signs are all positive, as
+      // signs are applied in ElementRestriction.
+
+      const double tk[9] = { 1.,0.,0.,  0.,1.,0.,  0.,0.,1. };
+
+      for (int c=0; c<3; ++c)
+      {
+         for (int i=0; i<ndof_test/3; ++i)
+         {
+            const int d = (c*ndof_test/3) + i;
+            // ND_HexahedronElement sets dof2tk = (dofmap < 0) ? 3+c : c, but here
+            // no signs should be applied due to ElementRestriction.
+            const int dof2tk = c;
+            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
+
+            for (int e=0; e<ne; ++e)
+            {
+               double v[3];
+               ElementTransformation *tr = mesh->GetElementTransformation(e);
+               tr->SetIntPoint(&Nodes.IntPoint(id));
+               tr->Jacobian().Mult(tk + dof2tk*dim, v);
+
+               for (int j=0; j<3; ++j)
+               {
+                  op(j,d,e) = v[j];
+               }
+            }
+         }
+      }
+   }
+   else // 2D case
+   {
+      const double tk[4] = { 1.,0.,  0.,1. };
+      for (int c=0; c<2; ++c)
+      {
+         for (int i=0; i<ndof_test/2; ++i)
+         {
+            const int d = (c*ndof_test/2) + i;
+            // ND_QuadrilateralElement sets dof2tk = (dofmap < 0) ? 2+c : c, but here
+            // no signs should be applied due to ElementRestriction.
+            const int dof2tk = c;
+            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
+
+            for (int e=0; e<ne; ++e)
+            {
+               double v[2];
+               ElementTransformation *tr = mesh->GetElementTransformation(e);
+               tr->SetIntPoint(&Nodes.IntPoint(id));
+               tr->Jacobian().Mult(tk + dof2tk*dim, v);
+
+               for (int j=0; j<2; ++j)
+               {
+                  op(j,d,e) = v[j];
+               }
+            }
+         }
+      }
+   }
+}
+
+static void PAHcurlVecH1IdentityApply2D(const int c_dofs1D,
+                                        const int o_dofs1D,
+                                        const int NE,
+                                        const Array<double> &Bclosed,
+                                        const Array<double> &Bopen,
+                                        const Vector &pa_data,
+                                        const Vector &x_,
+                                        Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, 2, NE);
+   auto y = Reshape(y_.ReadWrite(), (2 * c_dofs1D * o_dofs1D), NE);
+
+   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[2][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y)
+
+      // contract in y
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               w[j][dx][ey] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w[j][dx][ey] += Bc(ey, dy) * x(dx, dy, j, e);
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += Bo(ex, dx) * w[j][dx][ey];
+               }
+               const int local_index = ey*o_dofs1D + ex;
+               y(local_index, e) += s * vk(j, local_index, e);
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x)
+
+      // contract in y
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               w[j][dx][ey] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w[j][dx][ey] += Bo(ey, dy) * x(dx, dy, j, e);
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += Bc(ex, dx) * w[j][dx][ey];
+               }
+               const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+               y(local_index, e) += s * vk(j, local_index, e);
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApplyTranspose2D(const int c_dofs1D,
+                                                 const int o_dofs1D,
+                                                 const int NE,
+                                                 const Array<double> &Bclosed,
+                                                 const Array<double> &Bopen,
+                                                 const Vector &pa_data,
+                                                 const Vector &x_,
+                                                 Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), (2 * c_dofs1D * o_dofs1D), NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, 2, NE);
+
+   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   //constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[2][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y)
+
+      // contract in x
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
+         }
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            const int local_index = ey*o_dofs1D + ex;
+            const double xd = x(local_index, e);
+
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<2; ++j)
+               {
+                  w[j][dx][ey] += Bo(ex, dx) * xd * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int ey = 0; ey < c_dofs1D; ++ey)
+               {
+                  s += w[j][dx][ey] * Bc(ey, dy);
+               }
+               y(dx, dy, j, e) += s;
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x)
+
+      // contract in x
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
+         }
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+            const double xd = x(local_index, e);
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<2; ++j)
+               {
+                  w[j][dx][ey] += Bc(ex, dx) * xd * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int ey = 0; ey < o_dofs1D; ++ey)
+               {
+                  s += w[j][dx][ey] * Bo(ey, dy);
+               }
+               y(dx, dy, j, e) += s;
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApply3D(const int c_dofs1D,
+                                        const int o_dofs1D,
+                                        const int NE,
+                                        const Array<double> &Bclosed,
+                                        const Array<double> &Bopen,
+                                        const Vector &pa_data,
+                                        const Vector &x_,
+                                        Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
+   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+
+   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
+                     NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bo(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bo(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+
+      // contract in z
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bo(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApplyTranspose3D(const int c_dofs1D,
+                                                 const int o_dofs1D,
+                                                 const int NE,
+                                                 const Array<double> &Bclosed,
+                                                 const Array<double> &Bopen,
+                                                 const Vector &pa_data,
+                                                 const Vector &x_,
+                                                 Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
+
+   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
+                     NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < o_dofs1D; ++ex)
+               {
+                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bo(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < c_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < c_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < c_dofs1D; ++ex)
+               {
+                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < o_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bo(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < c_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+
+      // contract in x
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < c_dofs1D; ++ex)
+               {
+                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < c_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < o_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bo(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+   });
+}
+
+void IdentityInterpolator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      if (dim == 3)
+      {
+         PAHcurlVecH1IdentityApply3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
+                                     pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         PAHcurlVecH1IdentityApply2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
+                                     pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Bad dimension!");
+      }
+   }
+}
+
+void IdentityInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMultTranspose(x, y);
+   }
+   else
+   {
+      if (dim == 3)
+      {
+         PAHcurlVecH1IdentityApplyTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                              maps_O_C->B, pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         PAHcurlVecH1IdentityApplyTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                              maps_O_C->B, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Bad dimension!");
+      }
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_mass_mf.cpp b/fem/integ/bilininteg_mass_mf.cpp
index 34a118b6d..41ab07b94 100644
--- a/fem/integ/bilininteg_mass_mf.cpp
+++ b/fem/integ/bilininteg_mass_mf.cpp
@@ -19,42 +19,40 @@ namespace mfem
 
 void MassIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation *T = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFMassIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFMassIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::MFMassIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: MassIntegrator::AssembleMF only implemented with"
               " libCEED");
 }
 
-void MassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+void MassIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
 {
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Error: MassIntegrator::AddMultMF only implemented with"
-                 " libCEED");
+      delete ceedOp;
+      ceedOp = new ceed::MFMassIntegrator(*this, fes, Q, true);
+      return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: MassIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
 }
 
 void MassIntegrator::AssembleDiagonalMF(Vector &diag)
@@ -70,4 +68,17 @@ void MassIntegrator::AssembleDiagonalMF(Vector &diag)
    }
 }
 
+void MassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Error: MassIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
 } // namespace mfem
diff --git a/fem/integ/bilininteg_mass_pa.cpp b/fem/integ/bilininteg_mass_pa.cpp
index ffdec1edb..0e4cd8f41 100644
--- a/fem/integ/bilininteg_mass_pa.cpp
+++ b/fem/integ/bilininteg_mass_pa.cpp
@@ -23,28 +23,19 @@ void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
-
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation *T0 = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T0);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAMassIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PAMassIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::PAMassIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assuming the same element type
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T =* mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    int map_type = el.GetMapType();
    dim = mesh->Dimension();
    ne = fes.GetMesh()->GetNE();
@@ -116,14 +107,19 @@ void MassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
-
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PAMassIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assuming the same element type
    const FiniteElement &el = *fes.GetBE(0);
    ElementTransformation *T0 = mesh->GetBdrElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T0);
-
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, *T0);
    int map_type = el.GetMapType();
    dim = el.GetDim(); // Dimension of the boundary element, *not* the mesh
    ne = fes.GetMesh()->GetNBE();
diff --git a/fem/integ/bilininteg_mixedcurl_mf.cpp b/fem/integ/bilininteg_mixedcurl_mf.cpp
new file mode 100644
index 000000000..b22cc297e
--- /dev/null
+++ b/fem/integ/bilininteg_mixedcurl_mf.cpp
@@ -0,0 +1,108 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/mixedveccurl/mixedveccurl.hpp"
+
+namespace mfem
+{
+
+void MixedVectorCurlIntegrator::AssembleMF(const FiniteElementSpace &trial_fes,
+                                           const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, Q);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorCurlIntegrator::AssembleMF only implemented with"
+              " libCEED");
+}
+
+void MixedVectorCurlIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Error: MixedVectorCurlIntegrator::AddMultMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void MixedVectorWeakCurlIntegrator::AssembleMF(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, Q);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakCurlIntegrator::AssembleMF only"
+              " implemented with libCEED");
+}
+
+void MixedVectorWeakCurlIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Error: MixedVectorWeakCurlIntegrator::AddMultMF only"
+                 " implemented with libCEED");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_mixedcurl_pa.cpp b/fem/integ/bilininteg_mixedcurl_pa.cpp
index 3d70bc4c9..dd7a9375f 100644
--- a/fem/integ/bilininteg_mixedcurl_pa.cpp
+++ b/fem/integ/bilininteg_mixedcurl_pa.cpp
@@ -13,6 +13,7 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/mixedveccurl/mixedveccurl.hpp"
 #include "bilininteg_hcurl_kernels.hpp"
 #include "bilininteg_hcurlhdiv_kernels.hpp"
 
@@ -36,9 +37,8 @@ void MixedScalarCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
       MFEM_ABORT("Unknown kernel.");
    }
 
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*eltest, *eltest,
-                                                     *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*fel, *eltest, T);
 
    const int dims = el->GetDim();
    MFEM_VERIFY(dims == 2, "");
@@ -111,8 +111,30 @@ void MixedScalarCurlIntegrator::AddMultTransposePA(const Vector &x,
 void MixedVectorCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                            const FiniteElementSpace &test_fes)
 {
-   // Assumes tensor-product elements, with vector test and trial spaces.
    Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, Q);
+      }
+      return;
+   }
+
+   // Assumes tensor-product elements, with vector test and trial spaces.
    const FiniteElement *trial_fel = trial_fes.GetFE(0);
    const FiniteElement *test_fel = test_fes.GetFE(0);
 
@@ -124,9 +146,10 @@ void MixedVectorCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
       dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
    MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
 
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
+                                                            T);
+
    const int dims = trial_el->GetDim();
    MFEM_VERIFY(dims == 3, "");
 
@@ -194,75 +217,90 @@ void MixedVectorCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
 
 void MixedVectorCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
+   if (DeviceCanUseCeed())
    {
-      const int ndata = coeffDim == 1 ? 1 : 9;
-
-      if (Device::Allows(Backend::DEVICE_MASK))
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      if (testType == mfem::FiniteElement::CURL &&
+          trialType == mfem::FiniteElement::CURL && dim == 3)
       {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
+         const int ndata = coeffDim == 1 ? 1 : 9;
+
+         if (Device::Allows(Backend::DEVICE_MASK))
          {
-            case 0x23:
-               return internal::SmemPAHcurlL2Apply3D<2,3>(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
-            case 0x34:
-               return internal::SmemPAHcurlL2Apply3D<3,4>(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
-            case 0x45:
-               return internal::SmemPAHcurlL2Apply3D<4,5>(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
-            case 0x56:
-               return internal::SmemPAHcurlL2Apply3D<5,6>(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
-            default:
-               return internal::SmemPAHcurlL2Apply3D(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPAHcurlL2Apply3D<2,3>(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+               case 0x34:
+                  return internal::SmemPAHcurlL2Apply3D<3,4>(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+               case 0x45:
+                  return internal::SmemPAHcurlL2Apply3D<4,5>(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+               case 0x56:
+                  return internal::SmemPAHcurlL2Apply3D<5,6>(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+               default:
+                  return internal::SmemPAHcurlL2Apply3D(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+            }
+         }
+         else
+         {
+            internal::PAHcurlL2Apply3D(dofs1D, quad1D, ndata, ne, mapsO->B, mapsC->B,
+                                       mapsO->Bt, mapsC->Bt, mapsC->G, pa_data, x, y);
          }
       }
+      else if (testType == mfem::FiniteElement::DIV &&
+               trialType == mfem::FiniteElement::CURL && dim == 3)
+      {
+         internal::PAHcurlHdivApply3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
+                                      mapsC->B, mapsOtest->Bt, mapsCtest->Bt, mapsC->G,
+                                      pa_data, x, y);
+      }
       else
       {
-         internal::PAHcurlL2Apply3D(dofs1D, quad1D, ndata, ne, mapsO->B, mapsC->B,
-                                    mapsO->Bt, mapsC->Bt, mapsC->G, pa_data, x, y);
+         MFEM_ABORT("Unsupported dimension or space!");
       }
    }
-   else if (testType == mfem::FiniteElement::DIV &&
-            trialType == mfem::FiniteElement::CURL && dim == 3)
-   {
-      internal::PAHcurlHdivApply3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
-                                   mapsC->B, mapsOtest->Bt, mapsCtest->Bt, mapsC->G,
-                                   pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension or space!");
-   }
 }
 
 void MixedVectorCurlIntegrator::AddMultTransposePA(const Vector &x,
                                                    Vector &y) const
 {
-   if (testType == mfem::FiniteElement::DIV &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
+   if (DeviceCanUseCeed())
    {
-      internal::PAHcurlHdivApply3DTranspose(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
-                                            mapsC->B, mapsOtest->Bt, mapsCtest->Bt,
-                                            mapsC->Gt, pa_data, x, y);
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " MixedVectorCurlIntegrator.");
    }
    else
    {
-      MFEM_ABORT("Unsupported dimension or space!");
+      if (testType == mfem::FiniteElement::DIV &&
+          trialType == mfem::FiniteElement::CURL && dim == 3)
+      {
+         internal::PAHcurlHdivApply3DTranspose(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
+                                               mapsC->B, mapsOtest->Bt, mapsCtest->Bt,
+                                               mapsC->Gt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension or space!");
+      }
    }
 }
 
@@ -270,8 +308,30 @@ void MixedVectorWeakCurlIntegrator::AssemblePA(
    const FiniteElementSpace &trial_fes,
    const FiniteElementSpace &test_fes)
 {
-   // Assumes tensor-product elements, with vector test and trial spaces.
    Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, Q);
+      }
+      return;
+   }
+
+   // Assumes tensor-product elements, with vector test and trial spaces.
    const FiniteElement *trial_fel = trial_fes.GetFE(0);
    const FiniteElement *test_fel = test_fes.GetFE(0);
 
@@ -283,9 +343,10 @@ void MixedVectorWeakCurlIntegrator::AssemblePA(
       dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
    MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
 
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
+                                                            T);
+
    const int dims = trial_el->GetDim();
    MFEM_VERIFY(dims == 3, "");
 
@@ -349,75 +410,90 @@ void MixedVectorWeakCurlIntegrator::AssemblePA(
 
 void MixedVectorWeakCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
    {
-      const int ndata = coeffDim == 1 ? 1 : 9;
-      if (Device::Allows(Backend::DEVICE_MASK))
+      if (testType == mfem::FiniteElement::CURL &&
+          trialType == mfem::FiniteElement::CURL && dim == 3)
       {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
+         const int ndata = coeffDim == 1 ? 1 : 9;
+         if (Device::Allows(Backend::DEVICE_MASK))
          {
-            case 0x23:
-               return internal::SmemPAHcurlL2Apply3DTranspose<2,3>(
-                         dofs1D, quad1D, ndata,
-                         ne, mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
-            case 0x34:
-               return internal::SmemPAHcurlL2Apply3DTranspose<3,4>(
-                         dofs1D, quad1D, ndata,
-                         ne, mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
-            case 0x45:
-               return internal::SmemPAHcurlL2Apply3DTranspose<4,5>(
-                         dofs1D, quad1D, ndata,
-                         ne, mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
-            case 0x56:
-               return internal::SmemPAHcurlL2Apply3DTranspose<5,6>(
-                         dofs1D, quad1D, ndata,
-                         ne, mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
-            default:
-               return internal::SmemPAHcurlL2Apply3DTranspose(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPAHcurlL2Apply3DTranspose<2,3>(
+                            dofs1D, quad1D, ndata,
+                            ne, mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+               case 0x34:
+                  return internal::SmemPAHcurlL2Apply3DTranspose<3,4>(
+                            dofs1D, quad1D, ndata,
+                            ne, mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+               case 0x45:
+                  return internal::SmemPAHcurlL2Apply3DTranspose<4,5>(
+                            dofs1D, quad1D, ndata,
+                            ne, mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+               case 0x56:
+                  return internal::SmemPAHcurlL2Apply3DTranspose<5,6>(
+                            dofs1D, quad1D, ndata,
+                            ne, mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+               default:
+                  return internal::SmemPAHcurlL2Apply3DTranspose(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+            }
+         }
+         else
+         {
+            internal::PAHcurlL2Apply3DTranspose(dofs1D, quad1D, ndata, ne, mapsO->B,
+                                                mapsC->B, mapsO->Bt, mapsC->Bt,
+                                                mapsC->Gt, pa_data, x, y);
          }
       }
+      else if (testType == mfem::FiniteElement::CURL &&
+               trialType == mfem::FiniteElement::DIV && dim == 3)
+      {
+         internal::PAHcurlHdivApply3DTranspose(dofs1D, dofs1D, quad1D, ne, mapsO->B,
+                                               mapsC->B, mapsO->Bt, mapsC->Bt,
+                                               mapsC->Gt, pa_data, x, y);
+      }
       else
       {
-         internal::PAHcurlL2Apply3DTranspose(dofs1D, quad1D, ndata, ne, mapsO->B,
-                                             mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->Gt,
-                                             pa_data, x, y);
+         MFEM_ABORT("Unsupported dimension or space!");
       }
    }
-   else if (testType == mfem::FiniteElement::CURL &&
-            trialType == mfem::FiniteElement::DIV && dim == 3)
-   {
-      internal::PAHcurlHdivApply3DTranspose(dofs1D, dofs1D, quad1D, ne, mapsO->B,
-                                            mapsC->B, mapsO->Bt, mapsC->Bt,
-                                            mapsC->Gt, pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension or space!");
-   }
 }
 
 void MixedVectorWeakCurlIntegrator::AddMultTransposePA(const Vector &x,
                                                        Vector &y) const
 {
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::DIV && dim == 3)
+   if (DeviceCanUseCeed())
    {
-      internal::PAHcurlHdivApply3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
-                                   mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->G,
-                                   pa_data, x, y);
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " MixedVectorWeakCurlIntegrator.");
    }
    else
    {
-      MFEM_ABORT("Unsupported dimension or space!");
+      if (testType == mfem::FiniteElement::CURL &&
+          trialType == mfem::FiniteElement::DIV && dim == 3)
+      {
+         internal::PAHcurlHdivApply3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
+                                      mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->G,
+                                      pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension or space!");
+      }
    }
 }
 
diff --git a/fem/integ/bilininteg_mixedvecgrad_mf.cpp b/fem/integ/bilininteg_mixedvecgrad_mf.cpp
new file mode 100644
index 000000000..10b3b9686
--- /dev/null
+++ b/fem/integ/bilininteg_mixedvecgrad_mf.cpp
@@ -0,0 +1,174 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/mixedvecgrad/mixedvecgrad.hpp"
+
+namespace mfem
+{
+
+void MixedVectorGradientIntegrator::AssembleMF(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, Q);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorGradientIntegrator::AssembleMF only"
+              " implemented with libCEED");
+}
+
+void MixedVectorGradientIntegrator::AssembleMFBoundary(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, MQ, true);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, DQ, true);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, Q, true);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorGradientIntegrator::AssembleMFBoundary only"
+              " implemented with libCEED");
+}
+
+void MixedVectorGradientIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Error: MixedVectorGradientIntegrator::AddMultMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void MixedVectorWeakDivergenceIntegrator::AssembleMF(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, Q);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AssembleMF only"
+              " implemented with libCEED");
+}
+
+void MixedVectorWeakDivergenceIntegrator::AssembleMFBoundary(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, MQ, true);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, DQ, true);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, Q, true);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AssembleMFBoundary only"
+              " implemented with libCEED");
+}
+
+void MixedVectorWeakDivergenceIntegrator::AddMultMF(const Vector &x,
+                                                    Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AddMultMF only"
+                 " implemented with libCEED");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_mixedvecgrad_pa.cpp b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
index f9e6d3ee8..5acf3367b 100644
--- a/fem/integ/bilininteg_mixedvecgrad_pa.cpp
+++ b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
@@ -13,11 +13,128 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/mixedvecgrad/mixedvecgrad.hpp"
 #include "bilininteg_diffusion_kernels.hpp"
 
 namespace mfem
 {
 
+void MixedVectorGradientIntegrator::AssemblePA(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, Q);
+      }
+      return;
+   }
+
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
+                                                            T);
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
+
+   ne = trial_fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   pa_data.SetSize(symmDims * nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
+
+   // Use the same setup functions as VectorFEMassIntegrator.
+   if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 3)
+   {
+      internal::PADiffusionSetup3D(quad1D, 1, ne, ir->GetWeights(), geom->J,
+                                   coeff, pa_data);
+   }
+   else if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 2)
+   {
+      internal::PADiffusionSetup2D<2>(quad1D, 1, ne, ir->GetWeights(), geom->J,
+                                      coeff, pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
+void MixedVectorGradientIntegrator::AssemblePABoundary(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, MQ, true);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, DQ, true);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, Q, true);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorGradientIntegrator::AssemblePABoundary only"
+              " implemented with libCEED");
+}
+
 // Apply to x corresponding to DOFs in H^1 (trial), whose gradients are
 // integrated against H(curl) test functions corresponding to y.
 static void PAHcurlH1Apply2D(const int D1D,
@@ -656,101 +773,133 @@ static void PAHcurlH1ApplyTranspose3D(const int D1D,
    }); // end of element loop
 }
 
-void MixedVectorGradientIntegrator::AssemblePA(
-   const FiniteElementSpace &trial_fes,
-   const FiniteElementSpace &test_fes)
+void MixedVectorGradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
-
-   ne = trial_fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   pa_data.SetSize(symmDims * nq * ne, Device::GetMemoryType());
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
-
-   // Use the same setup functions as VectorFEMassIntegrator.
-   if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 3)
+   if (DeviceCanUseCeed())
    {
-      internal::PADiffusionSetup3D(quad1D, 1, ne, ir->GetWeights(), geom->J,
-                                   coeff, pa_data);
-   }
-   else if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 2)
-   {
-      internal::PADiffusionSetup2D<2>(quad1D, 1, ne, ir->GetWeights(), geom->J,
-                                      coeff, pa_data);
+      ceedOp->AddMult(x, y);
    }
    else
    {
-      MFEM_ABORT("Unknown kernel.");
+      if (dim == 3)
+      {
+         PAHcurlH1Apply3D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
+                          mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         PAHcurlH1Apply2D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
+                          mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension!");
+      }
    }
 }
 
-void MixedVectorGradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
+void MixedVectorGradientIntegrator::AddMultTransposePA(const Vector &x,
+                                                       Vector &y) const
 {
-   if (dim == 3)
+   if (DeviceCanUseCeed())
    {
-      PAHcurlH1Apply3D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
-                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " MixedVectorGradientIntegrator.");
    }
-   else if (dim == 2)
+   else
    {
-      PAHcurlH1Apply2D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
-                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      if (dim == 3)
+      {
+         PAHcurlH1ApplyTranspose3D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
+                                   mapsC->Bt, mapsC->Gt, pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         PAHcurlH1ApplyTranspose2D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
+                                   mapsC->Bt, mapsC->Gt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension!");
+      }
    }
-   else
+}
+
+void MixedVectorWeakDivergenceIntegrator::AssemblePA(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
    {
-      MFEM_ABORT("Unsupported dimension!");
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, Q);
+      }
+      return;
    }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AssemblePA only"
+              " implemented with libCEED");
 }
 
-void MixedVectorGradientIntegrator::AddMultTransposePA(const Vector &x,
-                                                       Vector &y) const
+void MixedVectorWeakDivergenceIntegrator::AssemblePABoundary(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
 {
-   if (dim == 3)
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
    {
-      PAHcurlH1ApplyTranspose3D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
-                                mapsC->Bt, mapsC->Gt, pa_data, x, y);
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, MQ, true);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, DQ, true);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, Q, true);
+      }
+      return;
    }
-   else if (dim == 2)
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AssemblePABoundary only"
+              " implemented with libCEED");
+}
+
+void MixedVectorWeakDivergenceIntegrator::AddMultPA(const Vector &x,
+                                                    Vector &y) const
+{
+   if (DeviceCanUseCeed())
    {
-      PAHcurlH1ApplyTranspose2D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
-                                mapsC->Bt, mapsC->Gt, pa_data, x, y);
+      ceedOp->AddMult(x, y);
    }
    else
    {
-      MFEM_ABORT("Unsupported dimension!");
+      MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AddMultMF only"
+                 " implemented with libCEED");
    }
 }
 
diff --git a/fem/integ/bilininteg_vecdiffusion_mf.cpp b/fem/integ/bilininteg_vecdiffusion_mf.cpp
index 7cad61496..56139d2ef 100644
--- a/fem/integ/bilininteg_vecdiffusion_mf.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_mf.cpp
@@ -19,45 +19,45 @@ namespace mfem
 
 void VectorDiffusionIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &DiffusionIntegrator::GetRule(el, el);
    if (DeviceCanUseCeed())
    {
-      delete ceedOp;
       MFEM_VERIFY(!VQ && !MQ,
-                  "Only scalar coefficient supported for DiffusionIntegrator"
-                  " with libCEED");
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFDiffusionIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFDiffusionIntegrator(fes, *ir, Q);
-      }
+                  "Only scalar coefficient is supported for matrix-free assembly for VectorDiffusionIntegrator");
+      delete ceedOp;
+      ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: VectorDiffusionIntegrator::AssembleMF only implemented"
               " with libCEED");
 }
 
-void VectorDiffusionIntegrator::AddMultMF(const Vector &x, Vector &y) const
+void VectorDiffusionIntegrator::AssembleMFBoundary(
+   const FiniteElementSpace &fes)
 {
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Error: VectorDiffusionIntegrator::AddMultMF only implemented"
-                 " with libCEED");
+      MFEM_VERIFY(!VQ && !MQ,
+                  "Only scalar coefficient is supported for matrix-free assembly for VectorDiffusionIntegrator");
+      delete ceedOp;
+      ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, Q, true);
+      return;
    }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorDiffusionIntegrator::AssembleMFBoundary only implemented"
+              " with libCEED");
 }
 
 void VectorDiffusionIntegrator::AssembleDiagonalMF(Vector &diag)
@@ -73,4 +73,17 @@ void VectorDiffusionIntegrator::AssembleDiagonalMF(Vector &diag)
    }
 }
 
+void VectorDiffusionIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Error: VectorDiffusionIntegrator::AddMultMF only implemented"
+                 " with libCEED");
+   }
+}
+
 } // namespace mfem
diff --git a/fem/integ/bilininteg_vecdiffusion_pa.cpp b/fem/integ/bilininteg_vecdiffusion_pa.cpp
index 84e4d5b2a..3fe58e1c1 100644
--- a/fem/integ/bilininteg_vecdiffusion_pa.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_pa.cpp
@@ -114,26 +114,21 @@ static void PAVectorDiffusionSetup3D(const int Q1D,
 
 void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement &el = *fes.GetFE(0);
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &DiffusionIntegrator::GetRule(el, el);
+   if (mesh->GetNE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
+      MFEM_VERIFY(!VQ && !MQ,
+                  "Only scalar coefficient is supported for partial assembly for VectorDiffusionIntegrator");
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPADiffusionIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PADiffusionIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::PADiffusionIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assumes tensor-product elements
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    const int dims = el.GetDim();
    const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
    const int nq = ir->GetNPoints();
@@ -209,6 +204,28 @@ void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
+void VectorDiffusionIntegrator::AssemblePABoundary(
+   const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      MFEM_VERIFY(!VQ && !MQ,
+                  "Only scalar coefficient is supported for partial assembly for VectorDiffusionIntegrator");
+      delete ceedOp;
+      ceedOp = new ceed::PADiffusionIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorDiffusionIntegrator::AssemblePABoundary only implemented"
+              " with libCEED");
+}
+
 template<int T_D1D = 0, int T_Q1D = 0>
 static void PAVectorDiffusionDiagonal2D(const int NE,
                                         const Array<double> &b,
diff --git a/fem/integ/bilininteg_vecdiv_pa.cpp b/fem/integ/bilininteg_vecdiv_pa.cpp
index 63f7a3308..cf58df9ea 100644
--- a/fem/integ/bilininteg_vecdiv_pa.cpp
+++ b/fem/integ/bilininteg_vecdiv_pa.cpp
@@ -105,9 +105,8 @@ void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    Mesh *mesh = trial_fes.GetMesh();
    const FiniteElement &trial_fe = *trial_fes.GetFE(0);
    const FiniteElement &test_fe = *test_fes.GetFE(0);
-   ElementTransformation *trans = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
-                                                            *trans);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe, T);
    const int dims = trial_fe.GetDim();
    const int dimsToStore = dims * dims;
    nq = ir->GetNPoints();
diff --git a/fem/integ/bilininteg_vecmass_mf.cpp b/fem/integ/bilininteg_vecmass_mf.cpp
index cc2eb0174..59d7209db 100644
--- a/fem/integ/bilininteg_vecmass_mf.cpp
+++ b/fem/integ/bilininteg_vecmass_mf.cpp
@@ -19,43 +19,40 @@ namespace mfem
 
 void VectorMassIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation *T = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(el, el, *T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFMassIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFMassIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::MFMassIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: VectorMassIntegrator::AssembleMF only implemented with"
               " libCEED");
 }
 
-void VectorMassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+void VectorMassIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
 {
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Error: VectorMassIntegrator::AddMultMF only implemented with"
-                 " libCEED");
+      delete ceedOp;
+      ceedOp = new ceed::MFMassIntegrator(*this, fes, Q, true);
+      return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorMassIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
 }
 
 void VectorMassIntegrator::AssembleDiagonalMF(Vector &diag)
@@ -71,4 +68,17 @@ void VectorMassIntegrator::AssembleDiagonalMF(Vector &diag)
    }
 }
 
+void VectorMassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Error: VectorMassIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
 } // namespace mfem
diff --git a/fem/integ/bilininteg_vecmass_pa.cpp b/fem/integ/bilininteg_vecmass_pa.cpp
index b1c20b4c4..3be9e2283 100644
--- a/fem/integ/bilininteg_vecmass_pa.cpp
+++ b/fem/integ/bilininteg_vecmass_pa.cpp
@@ -19,33 +19,23 @@ namespace mfem
 
 void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation *T = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(el, el, *T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAMassIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PAMassIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::PAMassIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assuming the same element type
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    dim = mesh->Dimension();
    ne = fes.GetMesh()->GetNE();
    nq = ir->GetNPoints();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::COORDINATES |
-                                    GeometricFactors::JACOBIANS);
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
    maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
    dofs1D = maps->ndof;
    quad1D = maps->nqpt;
@@ -106,6 +96,25 @@ void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
+void VectorMassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PAMassIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorMassIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
 template<const int T_D1D = 0, const int T_Q1D = 0>
 static void PAVectorMassAssembleDiagonal2D(const int NE,
                                            const Array<double> &B_,
diff --git a/fem/integ/bilininteg_vectorfediv_pa.cpp b/fem/integ/bilininteg_vectorfediv_pa.cpp
index 2915a253b..4a2c2a055 100644
--- a/fem/integ/bilininteg_vectorfediv_pa.cpp
+++ b/fem/integ/bilininteg_vectorfediv_pa.cpp
@@ -38,9 +38,9 @@ VectorFEDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
       dynamic_cast<const NodalTensorFiniteElement*>(test_fel);
    MFEM_VERIFY(test_el != NULL, "Only NodalTensorFiniteElement is supported!");
 
-   const IntegrationRule *ir = IntRule ? IntRule : &MassIntegrator::GetRule(
-                                  *trial_el, *trial_el,
-                                  *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
+                                                            T);
 
    const int dims = trial_el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
diff --git a/fem/integ/bilininteg_vectorfemass_mf.cpp b/fem/integ/bilininteg_vectorfemass_mf.cpp
new file mode 100644
index 000000000..91d2b6b5a
--- /dev/null
+++ b/fem/integ/bilininteg_vectorfemass_mf.cpp
@@ -0,0 +1,89 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/vecfemass/vecfemass.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void VectorFEMassIntegrator::AssembleMF(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, MQ); }
+      else if (DQ) { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, DQ); }
+      else { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, Q); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorFEMassIntegrator::AssembleMF only implemented with"
+              " libCEED");
+}
+
+void VectorFEMassIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, MQ, true); }
+      else if (DQ) { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, DQ, true); }
+      else { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorFEMassIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
+void VectorFEMassIntegrator::AssembleDiagonalMF(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
+   {
+      MFEM_ABORT("Error: VectorFEMassIntegrator::AssembleDiagonalMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void VectorFEMassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Error: VectorFEMassIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_vectorfemass_pa.cpp b/fem/integ/bilininteg_vectorfemass_pa.cpp
index c07e9f816..a49a9daa7 100644
--- a/fem/integ/bilininteg_vectorfemass_pa.cpp
+++ b/fem/integ/bilininteg_vectorfemass_pa.cpp
@@ -12,6 +12,7 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/vecfemass/vecfemass.hpp"
 #include "bilininteg_diffusion_kernels.hpp"
 #include "bilininteg_hcurl_kernels.hpp"
 #include "bilininteg_hdiv_kernels.hpp"
@@ -23,30 +24,37 @@ namespace mfem
 void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                         const FiniteElementSpace &test_fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      MFEM_VERIFY(&trial_fes == &test_fes,
+                  "VectorFEMassIntegrator with mixed FE spaces is not supported by libCEED!");
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, trial_fes, MQ); }
+      else if (DQ) { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, trial_fes, DQ); }
+      else { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, trial_fes, Q); }
+      return;
+   }
 
+   // Assumes tensor-product elements
    const FiniteElement *trial_fel = trial_fes.GetFE(0);
    const VectorTensorFiniteElement *trial_el =
       dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
    MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
    const FiniteElement *test_fel = test_fes.GetFE(0);
    const VectorTensorFiniteElement *test_el =
       dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
    MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
+                                                            T);
    const int dims = trial_el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
-
    const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
    nq = ir->GetNPoints();
    dim = mesh->Dimension();
    MFEM_VERIFY(dim == 2 || dim == 3, "");
-
    ne = trial_fes.GetNE();
    MFEM_VERIFY(ne == test_fes.GetNE(),
                "Different meshes for test and trial spaces");
@@ -55,13 +63,10 @@ void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
    dofs1D = mapsC->ndof;
    quad1D = mapsC->nqpt;
-
    mapsCtest = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
    mapsOtest = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
    dofs1Dtest = mapsCtest->ndof;
-
    MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
    trial_fetype = trial_el->GetDerivType();
    test_fetype = test_el->GetDerivType();
 
@@ -72,6 +77,7 @@ void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
 
    QuadratureSpace qs(*mesh, *ir);
    CoefficientVector coeff(qs, CoefficientStorage::SYMMETRIC);
+
    if (Q) { coeff.Project(*Q); }
    else if (MQ) { coeff.ProjectTranspose(*MQ); }
    else if (DQ) { coeff.Project(*DQ); }
@@ -138,172 +144,206 @@ void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    }
 }
 
-void VectorFEMassIntegrator::AssembleDiagonalPA(Vector& diag)
+void VectorFEMassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
 {
-   if (dim == 3)
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
    {
-      if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, fes, MQ, true); }
+      else if (DQ) { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, fes, DQ, true); }
+      else { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorFEMassIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void VectorFEMassIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->GetDiagonal(diag);
+   }
+   else
+   {
+      if (dim == 3)
       {
-         if (Device::Allows(Backend::DEVICE_MASK))
+         if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
          {
-            const int ID = (dofs1D << 4) | quad1D;
-            switch (ID)
+            if (Device::Allows(Backend::DEVICE_MASK))
+            {
+               const int ID = (dofs1D << 4) | quad1D;
+               switch (ID)
+               {
+                  case 0x23:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D<2,3>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+                  case 0x34:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D<3,4>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+                  case 0x45:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D<4,5>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+                  case 0x56:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D<5,6>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+                  default:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+               }
+            }
+            else
             {
-               case 0x23:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D<2,3>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
-               case 0x34:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D<3,4>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
-               case 0x45:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D<4,5>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
-               case 0x56:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D<5,6>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
-               default:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
+               internal::PAHcurlMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
+                                                       mapsO->B, mapsC->B, pa_data, diag);
             }
          }
+         else if (trial_fetype == mfem::FiniteElement::DIV &&
+                  test_fetype == trial_fetype)
+         {
+            internal::PAHdivMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
+                                                   mapsO->B, mapsC->B, pa_data, diag);
+         }
          else
          {
-            internal::PAHcurlMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
-                                                    mapsO->B, mapsC->B, pa_data, diag);
+            MFEM_ABORT("Unknown kernel.");
          }
       }
-      else if (trial_fetype == mfem::FiniteElement::DIV &&
-               test_fetype == trial_fetype)
+      else // 2D
       {
-         internal::PAHdivMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
-                                                mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
-      }
-   }
-   else // 2D
-   {
-      if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
-      {
-         internal::PAHcurlMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
-                                                 mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else if (trial_fetype == mfem::FiniteElement::DIV &&
-               test_fetype == trial_fetype)
-      {
-         internal::PAHdivMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
-                                                mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
+         if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
+         {
+            internal::PAHcurlMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
+                                                    mapsO->B, mapsC->B, pa_data, diag);
+         }
+         else if (trial_fetype == mfem::FiniteElement::DIV &&
+                  test_fetype == trial_fetype)
+         {
+            internal::PAHdivMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
+                                                   mapsO->B, mapsC->B, pa_data, diag);
+         }
+         else
+         {
+            MFEM_ABORT("Unknown kernel.");
+         }
       }
    }
 }
 
 void VectorFEMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
-   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
-   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
-   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
-
-   if (dim == 3)
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
    {
-      if (trial_curl && test_curl)
+      const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
+      const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
+      const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
+      const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
+
+      if (dim == 3)
       {
-         if (Device::Allows(Backend::DEVICE_MASK))
+         if (trial_curl && test_curl)
          {
-            const int ID = (dofs1D << 4) | quad1D;
-            switch (ID)
+            if (Device::Allows(Backend::DEVICE_MASK))
+            {
+               const int ID = (dofs1D << 4) | quad1D;
+               switch (ID)
+               {
+                  case 0x23:
+                     return internal::SmemPAHcurlMassApply3D<2,3>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+                  case 0x34:
+                     return internal::SmemPAHcurlMassApply3D<3,4>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+                  case 0x45:
+                     return internal::SmemPAHcurlMassApply3D<4,5>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+                  case 0x56:
+                     return internal::SmemPAHcurlMassApply3D<5,6>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+                  default:
+                     return internal::SmemPAHcurlMassApply3D(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+               }
+            }
+            else
             {
-               case 0x23:
-                  return internal::SmemPAHcurlMassApply3D<2,3>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
-               case 0x34:
-                  return internal::SmemPAHcurlMassApply3D<3,4>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
-               case 0x45:
-                  return internal::SmemPAHcurlMassApply3D<4,5>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
-               case 0x56:
-                  return internal::SmemPAHcurlMassApply3D<5,6>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
-               default:
-                  return internal::SmemPAHcurlMassApply3D(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
+               internal::PAHcurlMassApply3D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                            mapsO->Bt, mapsC->Bt, pa_data, x, y);
             }
          }
+         else if (trial_div && test_div)
+         {
+            internal::PAHdivMassApply(3, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                      mapsO->Bt, mapsC->Bt, pa_data, x, y);
+         }
+         else if (trial_curl && test_div)
+         {
+            const bool scalarCoeff = !(DQ || MQ);
+            internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                             true, false, mapsO->B, mapsC->B, mapsOtest->Bt,
+                                             mapsCtest->Bt, pa_data, x, y);
+         }
+         else if (trial_div && test_curl)
+         {
+            const bool scalarCoeff = !(DQ || MQ);
+            internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                             false, false, mapsO->B, mapsC->B, mapsOtest->Bt,
+                                             mapsCtest->Bt, pa_data, x, y);
+         }
          else
          {
-            internal::PAHcurlMassApply3D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
-                                         mapsO->Bt, mapsC->Bt, pa_data, x, y);
+            MFEM_ABORT("Unknown kernel.");
          }
       }
-      else if (trial_div && test_div)
-      {
-         internal::PAHdivMassApply(3, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
-                                   mapsO->Bt, mapsC->Bt, pa_data, x, y);
-      }
-      else if (trial_curl && test_div)
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                          true, false, mapsO->B, mapsC->B, mapsOtest->Bt,
-                                          mapsCtest->Bt, pa_data, x, y);
-      }
-      else if (trial_div && test_curl)
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                          false, false, mapsO->B, mapsC->B, mapsOtest->Bt,
-                                          mapsCtest->Bt, pa_data, x, y);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
-      }
-   }
-   else // 2D
-   {
-      if (trial_curl && test_curl)
+      else // 2D
       {
-         internal::PAHcurlMassApply2D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+         if (trial_curl && test_curl)
+         {
+            internal::PAHcurlMassApply2D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                         mapsO->Bt, mapsC->Bt, pa_data, x, y);
+         }
+         else if (trial_div && test_div)
+         {
+            internal::PAHdivMassApply(2, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
                                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
-      }
-      else if (trial_div && test_div)
-      {
-         internal::PAHdivMassApply(2, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
-                                   mapsO->Bt,
-                                   mapsC->Bt, pa_data, x, y);
-      }
-      else if ((trial_curl && test_div) || (trial_div && test_curl))
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                          trial_curl, false, mapsO->B, mapsC->B,
-                                          mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
+         }
+         else if ((trial_curl && test_div) || (trial_div && test_curl))
+         {
+            const bool scalarCoeff = !(DQ || MQ);
+            internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                             trial_curl, false, mapsO->B, mapsC->B,
+                                             mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+         }
+         else
+         {
+            MFEM_ABORT("Unknown kernel.");
+         }
       }
    }
 }
@@ -311,35 +351,43 @@ void VectorFEMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
 void VectorFEMassIntegrator::AddMultTransposePA(const Vector &x,
                                                 Vector &y) const
 {
-   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
-   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
-   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
-   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
-
-   bool symmetricSpaces = true;
-   if (dim == 3 && ((trial_div && test_curl) || (trial_curl && test_div)))
-   {
-      const bool scalarCoeff = !(DQ || MQ);
-      internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                       trial_div, true, mapsO->B, mapsC->B,
-                                       mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
-      symmetricSpaces = false;
-   }
-   else if (dim == 2 && ((trial_curl && test_div) || (trial_div && test_curl)))
+   if (DeviceCanUseCeed())
    {
-      const bool scalarCoeff = !(DQ || MQ);
-      internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                       !trial_curl, true, mapsO->B, mapsC->B,
-                                       mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
-      symmetricSpaces = false;
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " VectorFEMassIntegrator.");
    }
-   if (symmetricSpaces)
+   else
    {
-      if (MQ && dynamic_cast<SymmetricMatrixCoefficient*>(MQ) == NULL)
+      const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
+      const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
+      const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
+      const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
+
+      bool symmetricSpaces = true;
+      if (dim == 3 && ((trial_div && test_curl) || (trial_curl && test_div)))
+      {
+         const bool scalarCoeff = !(DQ || MQ);
+         internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                          trial_div, true, mapsO->B, mapsC->B,
+                                          mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+         symmetricSpaces = false;
+      }
+      else if (dim == 2 && ((trial_curl && test_div) || (trial_div && test_curl)))
       {
-         MFEM_ABORT("VectorFEMassIntegrator transpose not implemented for asymmetric MatrixCoefficient");
+         const bool scalarCoeff = !(DQ || MQ);
+         internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                          !trial_curl, true, mapsO->B, mapsC->B,
+                                          mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+         symmetricSpaces = false;
+      }
+      if (symmetricSpaces)
+      {
+         if (MQ && dynamic_cast<SymmetricMatrixCoefficient*>(MQ) == NULL)
+         {
+            MFEM_ABORT("VectorFEMassIntegrator transpose not implemented for asymmetric MatrixCoefficient");
+         }
+         AddMultPA(x, y);
       }
-      AddMultPA(x, y);
    }
 }
 
diff --git a/fem/integ/lininteg_boundary.cpp b/fem/integ/lininteg_boundary.cpp
index 9b785335c..92f1ff8a5 100644
--- a/fem/integ/lininteg_boundary.cpp
+++ b/fem/integ/lininteg_boundary.cpp
@@ -214,30 +214,28 @@ void BoundaryLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                           const Array<int> &markers,
                                           Vector &b)
 {
-   const FiniteElement &fe = *fes.GetBE(0);
-   const int qorder = oa * fe.GetOrder() + ob;
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule &ir = IntRule ? *IntRule : IntRules.Get(gtype, qorder);
    Mesh &mesh = *fes.GetMesh();
+   const FiniteElement &fe = *fes.GetBE(0);
+   ElementTransformation &T = *mesh.GetBdrElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T, oa, ob);
 
-   FaceQuadratureSpace qs(mesh, ir, FaceType::Boundary);
+   FaceQuadratureSpace qs(mesh, *ir, FaceType::Boundary);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
-   BLFEvalAssemble(fes, ir, markers, coeff, false, b);
+   BLFEvalAssemble(fes, *ir, markers, coeff, false, b);
 }
 
 void BoundaryNormalLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                                 const Array<int> &markers,
                                                 Vector &b)
 {
-   const FiniteElement &fe = *fes.GetBE(0);
-   const int qorder = oa * fe.GetOrder() + ob;
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule &ir = IntRule ? *IntRule : IntRules.Get(gtype, qorder);
    Mesh &mesh = *fes.GetMesh();
+   const FiniteElement &fe = *fes.GetBE(0);
+   ElementTransformation &T = *mesh.GetBdrElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T, oa, ob);
 
-   FaceQuadratureSpace qs(mesh, ir, FaceType::Boundary);
+   FaceQuadratureSpace qs(mesh, *ir, FaceType::Boundary);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
-   BLFEvalAssemble(fes, ir, markers, coeff, true, b);
+   BLFEvalAssemble(fes, *ir, markers, coeff, true, b);
 }
 
 } // namespace mfem
diff --git a/fem/integ/lininteg_boundary_flux.cpp b/fem/integ/lininteg_boundary_flux.cpp
index b9f047817..a6e422b94 100644
--- a/fem/integ/lininteg_boundary_flux.cpp
+++ b/fem/integ/lininteg_boundary_flux.cpp
@@ -166,15 +166,14 @@ void VectorFEBoundaryFluxLFIntegrator::AssembleDevice(
    const Array<int> &markers,
    Vector &b)
 {
-   const FiniteElement &fe = *fes.GetBE(0);
-   const int qorder = oa * fe.GetOrder() + ob;
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule &ir = IntRule ? *IntRule : IntRules.Get(gtype, qorder);
    Mesh &mesh = *fes.GetMesh();
+   const FiniteElement &fe = *fes.GetBE(0);
+   ElementTransformation &T = *mesh.GetBdrElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T, oa, ob);
 
-   FaceQuadratureSpace qs(mesh, ir, FaceType::Boundary);
+   FaceQuadratureSpace qs(mesh, *ir, FaceType::Boundary);
    CoefficientVector coeff(F, qs, CoefficientStorage::COMPRESSED);
-   BFLFEvalAssemble(fes, ir, markers, coeff, b);
+   BFLFEvalAssemble(fes, *ir, markers, coeff, b);
 }
 
 } // namespace mfem
diff --git a/fem/integ/lininteg_domain.cpp b/fem/integ/lininteg_domain.cpp
index 6ff7b090d..438da4df2 100644
--- a/fem/integ/lininteg_domain.cpp
+++ b/fem/integ/lininteg_domain.cpp
@@ -242,10 +242,10 @@ void DomainLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                         const Array<int> &markers,
                                         Vector &b)
 {
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = oa * fe.GetOrder() + ob;
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T, oa, ob);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
@@ -256,10 +256,10 @@ void VectorDomainLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                               const Array<int> &markers,
                                               Vector &b)
 {
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = 2 * fe.GetOrder();
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
diff --git a/fem/integ/lininteg_domain_grad.cpp b/fem/integ/lininteg_domain_grad.cpp
index 5cca01a1d..735ea56c4 100644
--- a/fem/integ/lininteg_domain_grad.cpp
+++ b/fem/integ/lininteg_domain_grad.cpp
@@ -321,11 +321,10 @@ void DomainLFGradIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                             const Array<int> &markers,
                                             Vector &b)
 {
-
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = 2 * fe.GetOrder();
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
@@ -336,10 +335,10 @@ void VectorDomainLFGradIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                                   const Array<int> &markers,
                                                   Vector &b)
 {
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = 2 * fe.GetOrder();
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
diff --git a/fem/integ/lininteg_domain_vectorfe.cpp b/fem/integ/lininteg_domain_vectorfe.cpp
index 16d9e866c..0765d58bc 100644
--- a/fem/integ/lininteg_domain_vectorfe.cpp
+++ b/fem/integ/lininteg_domain_vectorfe.cpp
@@ -325,10 +325,10 @@ void VectorFEDomainLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                                 const Array<int> &markers,
                                                 Vector &b)
 {
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = 2 * fe.GetOrder();
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(QF, qs, CoefficientStorage::COMPRESSED);
diff --git a/fem/integ/nonlininteg_vecconvection_mf.cpp b/fem/integ/nonlininteg_vecconvection_mf.cpp
index 4005d6836..370fd7991 100644
--- a/fem/integ/nonlininteg_vecconvection_mf.cpp
+++ b/fem/integ/nonlininteg_vecconvection_mf.cpp
@@ -19,27 +19,22 @@ namespace mfem
 void VectorConvectionNLFIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    MFEM_ASSERT(fes.GetOrdering() == Ordering::byNODES,
-               "PA Only supports Ordering::byNODES!");
+               "MF only supports Ordering::byNODES!");
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T = *mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   if (mesh->GetNE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFVectorConvectionNLIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFVectorConvectionNLFIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::MFVectorConvectionNLIntegrator(*this, fes, Q);
       return;
    }
-   MFEM_ABORT("Not yet implemented.");
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorConvectionNLFIntegrator::AssembleMF only"
+              " implemented with libCEED");
 }
 
 void VectorConvectionNLFIntegrator::AddMultMF(const Vector &x, Vector &y) const
diff --git a/fem/integ/nonlininteg_vecconvection_pa.cpp b/fem/integ/nonlininteg_vecconvection_pa.cpp
index 7bed31800..d8ca8f899 100644
--- a/fem/integ/nonlininteg_vecconvection_pa.cpp
+++ b/fem/integ/nonlininteg_vecconvection_pa.cpp
@@ -21,24 +21,18 @@ void VectorConvectionNLFIntegrator::AssemblePA(const FiniteElementSpace &fes)
    MFEM_ASSERT(fes.GetOrdering() == Ordering::byNODES,
                "PA Only supports Ordering::byNODES!");
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T = *mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   if (mesh->GetNE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAVectorConvectionNLIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PAVectorConvectionNLFIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::PAVectorConvectionNLIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assumes tensor-product elements
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    dim = mesh->Dimension();
    ne = fes.GetMesh()->GetNE();
    nq = ir->GetNPoints();
diff --git a/fem/lininteg.cpp b/fem/lininteg.cpp
index c9b6b4699..25e7c2823 100644
--- a/fem/lininteg.cpp
+++ b/fem/lininteg.cpp
@@ -15,6 +15,22 @@
 namespace mfem
 {
 
+const IntegrationRule &LinearFormIntegrator::GetRule(
+   const FiniteElement &el,
+   ElementTransformation &Tr,
+   int oa, int ob) const
+{
+   return IntRules.Get(el.GetGeomType(), oa * el.GetOrder() + ob);
+}
+
+const IntegrationRule &LinearFormIntegrator::GetRule(
+   const FiniteElement &el,
+   FaceElementTransformations &Tr,
+   int oa, int ob) const
+{
+   return IntRules.Get(Tr.GetGeometryType(), oa * el.GetOrder() + ob);
+}
+
 void LinearFormIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                           const Array<int> &markers,
                                           Vector &b)
@@ -41,17 +57,11 @@ void DomainLFIntegrator::AssembleRHSElementVect(const FiniteElement &el,
 {
    int dof = el.GetDof();
 
-   shape.SetSize(dof);       // vector of size dof
+   shape.SetSize(dof);  // vector of size dof
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // ir = &IntRules.Get(el.GetGeomType(),
-      //                    oa * el.GetOrder() + ob + Tr.OrderW());
-      ir = &IntRules.Get(el.GetGeomType(), oa * el.GetOrder() + ob);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -86,12 +96,7 @@ void DomainLFGradIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2 * el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -128,16 +133,11 @@ void BoundaryLFIntegrator::AssembleRHSElementVect(
 {
    int dof = el.GetDof();
 
-   shape.SetSize(dof);        // vector of size dof
+   shape.SetSize(dof);  // vector of size dof
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -157,16 +157,11 @@ void BoundaryLFIntegrator::AssembleRHSElementVect(
 {
    int dof = el.GetDof();
 
-   shape.SetSize(dof);        // vector of size dof
+   shape.SetSize(dof);  // vector of size dof
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;    // <------ user control
-      ir = &IntRules.Get(Tr.FaceGeom, intorder); // of integration order
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -197,12 +192,7 @@ void BoundaryNormalLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -241,12 +231,7 @@ void BoundaryTangentialLFIntegrator::AssembleRHSElementVect(
       mfem_error("These methods make sense only in 2D problems.");
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -273,17 +258,12 @@ void VectorDomainLFIntegrator::AssembleRHSElementVect(
 
    double val,cf;
 
-   shape.SetSize(dof);       // vector of size dof
+   shape.SetSize(dof);  // vector of size dof
 
    elvect.SetSize(dof * vdim);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -337,12 +317,7 @@ void VectorDomainLFGradIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof*(vdim/sdim));
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2 * el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    Vector pelvect(dof);
    Vector part_x(dim);
@@ -384,12 +359,7 @@ void VectorBoundaryLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof * vdim);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -419,12 +389,7 @@ void VectorBoundaryLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof * vdim);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(Tr.GetGeometryType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -463,13 +428,8 @@ void VectorFEDomainLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // int intorder = 2*el.GetOrder() - 1; // ok for O(h^{k+1}) conv. in L2
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   // Previously: 2 * el.GetOrder() - 1; // ok for O(h^{k+1}) conv. in L2
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -512,12 +472,7 @@ void VectorFEDomainLFCurlIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -554,16 +509,11 @@ void VectorFEDomainLFDivIntegrator::AssembleRHSElementVect(
 {
    int dof = el.GetDof();
 
-   divshape.SetSize(dof);       // vector of size dof
+   divshape.SetSize(dof);  // vector of size dof
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2 * el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -596,11 +546,7 @@ void VectorBoundaryFluxLFIntegrator::AssembleRHSElementVect(
    nor.SetSize (dim);
    elvect.SetSize (dim*dof);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      ir = &IntRules.Get(el.GetGeomType(), el.GetOrder() + 1);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, 1, 1);
 
    elvect = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -618,7 +564,6 @@ void VectorBoundaryFluxLFIntegrator::AssembleRHSElementVect(
    }
 }
 
-
 void VectorFEBoundaryFluxLFIntegrator::AssembleRHSElementVect(
    const FiniteElement &el, ElementTransformation &Tr, Vector &elvect)
 {
@@ -628,12 +573,7 @@ void VectorFEBoundaryFluxLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -667,12 +607,7 @@ void VectorFEBoundaryTangentLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -707,6 +642,20 @@ void VectorFEBoundaryTangentLFIntegrator::AssembleRHSElementVect(
    }
 }
 
+const IntegrationRule &BoundaryFlowIntegrator::GetRule(
+   const FiniteElement &el,
+   FaceElementTransformations &Tr,
+   int oa, int ob) const
+{
+   // Assuming order(u) == order(mesh)
+   int order = 2 * el.GetOrder() + Tr.Elem1->OrderW();
+   if (el.Space() == FunctionSpace::Pk)
+   {
+      order++;
+   }
+   return IntRules.Get(Tr.GetGeometryType(), order);
+}
+
 void BoundaryFlowIntegrator::AssembleRHSElementVect(
    const FiniteElement &el, ElementTransformation &Tr, Vector &elvect)
 {
@@ -719,24 +668,14 @@ void BoundaryFlowIntegrator::AssembleRHSElementVect(
 void BoundaryFlowIntegrator::AssembleRHSElementVect(
    const FiniteElement &el, FaceElementTransformations &Tr, Vector &elvect)
 {
-   int dim, ndof, order;
+   int dim, ndof;
    double un, w, vu_data[3], nor_data[3];
 
    dim  = el.GetDim();
    ndof = el.GetDof();
    Vector vu(vu_data, dim), nor(nor_data, dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // Assuming order(u)==order(mesh)
-      order = Tr.Elem1->OrderW() + 2*el.GetOrder();
-      if (el.Space() == FunctionSpace::Pk)
-      {
-         order++;
-      }
-      ir = &IntRules.Get(Tr.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    shape.SetSize(ndof);
    elvect.SetSize(ndof);
@@ -805,13 +744,7 @@ void DGDirichletLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(ndof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // a simple choice for the integration order; is this OK?
-      int order = 2*el.GetOrder();
-      ir = &IntRules.Get(Tr.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int p = 0; p < ir->GetNPoints(); p++)
    {
@@ -902,12 +835,7 @@ void DGElasticityDirichletLFIntegrator::AssembleRHSElementVect(
    dshape_du.SetSize(ndofs);
    u_dir.SetSize(dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      const int order = 2*el.GetOrder(); // <-----
-      ir = &IntRules.Get(Tr.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int pi = 0; pi < ir->GetNPoints(); ++pi)
    {
@@ -1000,12 +928,10 @@ void DGElasticityDirichletLFIntegrator::AssembleRHSElementVect(
    }
 }
 
-
-
-void WhiteGaussianNoiseDomainLFIntegrator::AssembleRHSElementVect
-(const FiniteElement &el,
- ElementTransformation &Tr,
- Vector &elvect)
+void WhiteGaussianNoiseDomainLFIntegrator::AssembleRHSElementVect(
+   const FiniteElement &el,
+   ElementTransformation &Tr,
+   Vector &elvect)
 {
    int n = el.GetDof();
    elvect.SetSize(n);
@@ -1040,13 +966,18 @@ void WhiteGaussianNoiseDomainLFIntegrator::AssembleRHSElementVect
    }
 }
 
+const IntegrationRule &VectorQuadratureLFIntegrator::GetRule(
+   const FiniteElement &el,
+   ElementTransformation &Tr,
+   int oa, int ob) const
+{
+   return vqfc.GetQuadFunction().GetSpace()->GetIntRule(Tr.ElementNo);
+}
 
 void VectorQuadratureLFIntegrator::AssembleRHSElementVect(
    const FiniteElement &fe, ElementTransformation &Tr, Vector &elvect)
 {
-   const IntegrationRule *ir =
-      &vqfc.GetQuadFunction().GetSpace()->GetIntRule(Tr.ElementNo);
-
+   const IntegrationRule *ir = &GetRule(fe, Tr);
    const int nqp = ir->GetNPoints();
    const int vdim = vqfc.GetVDim();
    const int ndofs = fe.GetDof();
@@ -1071,14 +1002,19 @@ void VectorQuadratureLFIntegrator::AssembleRHSElementVect(
    }
 }
 
+const IntegrationRule &QuadratureLFIntegrator::GetRule(
+   const FiniteElement &el,
+   ElementTransformation &Tr,
+   int oa, int ob) const
+{
+   return qfc.GetQuadFunction().GetSpace()->GetIntRule(Tr.ElementNo);
+}
 
 void QuadratureLFIntegrator::AssembleRHSElementVect(const FiniteElement &fe,
                                                     ElementTransformation &Tr,
                                                     Vector &elvect)
 {
-   const IntegrationRule *ir =
-      &qfc.GetQuadFunction().GetSpace()->GetIntRule(Tr.ElementNo);
-
+   const IntegrationRule *ir = &GetRule(fe, Tr);
    const int nqp = ir->GetNPoints();
    const int ndofs = fe.GetDof();
    Vector shape(ndofs);
diff --git a/fem/lininteg.hpp b/fem/lininteg.hpp
index 02fde00c9..5bcdfdb83 100644
--- a/fem/lininteg.hpp
+++ b/fem/lininteg.hpp
@@ -29,10 +29,20 @@ protected:
    LinearFormIntegrator(const IntegrationRule *ir = NULL) { IntRule = ir; }
 
 public:
-
    /// Method probing for assembly on device
    virtual bool SupportsDevice() const { return false; }
 
+   virtual void SetIntRule(const IntegrationRule *ir) { IntRule = ir; }
+
+   const IntegrationRule *GetIntRule() { return IntRule; }
+
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          ElementTransformation &Tr,
+                                          int oa = 2, int ob = 0) const;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          FaceElementTransformations &Tr,
+                                          int oa = 2, int ob = 0) const;
+
    /// Method defining assembly on device
    virtual void AssembleDevice(const FiniteElementSpace &fes,
                                const Array<int> &markers,
@@ -51,13 +61,9 @@ public:
                                        FaceElementTransformations &Tr,
                                        Vector &elvect);
 
-   virtual void SetIntRule(const IntegrationRule *ir) { IntRule = ir; }
-   const IntegrationRule* GetIntRule() { return IntRule; }
-
-   virtual ~LinearFormIntegrator() { }
+   virtual ~LinearFormIntegrator() {}
 };
 
-
 /// Abstract class for integrators that support delta coefficients
 class DeltaLFIntegrator : public LinearFormIntegrator
 {
@@ -70,7 +76,7 @@ protected:
    DeltaLFIntegrator(Coefficient &q, const IntegrationRule *ir = NULL)
       : LinearFormIntegrator(ir),
         delta(dynamic_cast<DeltaCoefficient*>(&q)),
-        vec_delta(NULL) { }
+        vec_delta(NULL) {}
 
    /** @brief This constructor should be used by derived classes that use a
        VectorDeltaCoefficient. */
@@ -78,7 +84,7 @@ protected:
                      const IntegrationRule *ir = NULL)
       : LinearFormIntegrator(ir),
         delta(NULL),
-        vec_delta(dynamic_cast<VectorDeltaCoefficient*>(&vq)) { }
+        vec_delta(dynamic_cast<VectorDeltaCoefficient*>(&vq)) {}
 
 public:
    /// Returns true if the derived class instance uses a delta coefficient.
@@ -103,23 +109,23 @@ public:
                                          Vector &elvect) = 0;
 };
 
-
 /// Class for domain integration L(v) := (f, v)
 class DomainLFIntegrator : public DeltaLFIntegrator
 {
    Vector shape;
    Coefficient &Q;
    int oa, ob;
+
 public:
    /// Constructs a domain integrator with a given Coefficient
+   /// the old default was a = 1, b = 1
+   /// for simple elliptic problems a = 2, b = -2 is OK
    DomainLFIntegrator(Coefficient &QF, int a = 2, int b = 0)
-   // the old default was a = 1, b = 1
-   // for simple elliptic problems a = 2, b = -2 is OK
-      : DeltaLFIntegrator(QF), Q(QF), oa(a), ob(b) { }
+      : DeltaLFIntegrator(QF), Q(QF), oa(a), ob(b) {}
 
    /// Constructs a domain integrator with a given Coefficient
    DomainLFIntegrator(Coefficient &QF, const IntegrationRule *ir)
-      : DeltaLFIntegrator(QF, ir), Q(QF), oa(1), ob(1) { }
+      : DeltaLFIntegrator(QF, ir), Q(QF), oa(1), ob(1) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -152,7 +158,7 @@ private:
 public:
    /// Constructs the domain integrator (Q, grad v)
    DomainLFGradIntegrator(VectorCoefficient &QF)
-      : DeltaLFIntegrator(QF), Q(QF) { }
+      : DeltaLFIntegrator(QF), Q(QF) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -174,18 +180,18 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /// Class for boundary integration L(v) := (g, v)
 class BoundaryLFIntegrator : public LinearFormIntegrator
 {
    Vector shape;
    Coefficient &Q;
    int oa, ob;
+
 public:
    /** @brief Constructs a boundary integrator with a given Coefficient @a QG.
        Integration order will be @a a * basis_order + @a b. */
    BoundaryLFIntegrator(Coefficient &QG, int a = 1, int b = 1)
-      : Q(QG), oa(a), ob(b) { }
+      : Q(QG), oa(a), ob(b) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -212,10 +218,11 @@ class BoundaryNormalLFIntegrator : public LinearFormIntegrator
    Vector shape;
    VectorCoefficient &Q;
    int oa, ob;
+
 public:
    /// Constructs a boundary integrator with a given Coefficient QG
    BoundaryNormalLFIntegrator(VectorCoefficient &QG, int a = 1, int b = 1)
-      : Q(QG), oa(a), ob(b) { }
+      : Q(QG), oa(a), ob(b) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -237,10 +244,11 @@ class BoundaryTangentialLFIntegrator : public LinearFormIntegrator
    Vector shape;
    VectorCoefficient &Q;
    int oa, ob;
+
 public:
    /// Constructs a boundary integrator with a given Coefficient QG
    BoundaryTangentialLFIntegrator(VectorCoefficient &QG, int a = 1, int b = 1)
-      : Q(QG), oa(a), ob(b) { }
+      : Q(QG), oa(a), ob(b) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -260,7 +268,7 @@ private:
 public:
    /// Constructs a domain integrator with a given VectorCoefficient
    VectorDomainLFIntegrator(VectorCoefficient &QF)
-      : DeltaLFIntegrator(QF), Q(QF) { }
+      : DeltaLFIntegrator(QF), Q(QF) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -294,7 +302,7 @@ private:
 public:
    /// Constructs the domain integrator (Q, grad v)
    VectorDomainLFGradIntegrator(VectorCoefficient &QF)
-      : DeltaLFIntegrator(QF), Q(QF) { }
+      : DeltaLFIntegrator(QF), Q(QF) {}
 
    virtual bool SupportsDevice() const override { return true; }
 
@@ -326,7 +334,7 @@ private:
 
 public:
    /// Constructs a boundary integrator with a given VectorCoefficient QG
-   VectorBoundaryLFIntegrator(VectorCoefficient &QG) : Q(QG) { }
+   VectorBoundaryLFIntegrator(VectorCoefficient &QG) : Q(QG) {}
 
    /** Given a particular boundary Finite Element and a transformation (Tr)
        computes the element boundary vector, elvect. */
@@ -352,7 +360,9 @@ private:
 
 public:
    VectorFEDomainLFIntegrator(VectorCoefficient &F)
-      : DeltaLFIntegrator(F), QF(F) { }
+      : DeltaLFIntegrator(F), QF(F) {}
+
+   virtual bool SupportsDevice() const { return true; }
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -362,8 +372,6 @@ public:
                                          ElementTransformation &Trans,
                                          Vector &elvect);
 
-   virtual bool SupportsDevice() const { return true; }
-
    virtual void AssembleDevice(const FiniteElementSpace &fes,
                                const Array<int> &markers,
                                Vector &b);
@@ -382,7 +390,7 @@ private:
 public:
    /// Constructs the domain integrator (Q, curl v)
    VectorFEDomainLFCurlIntegrator(VectorCoefficient &F)
-      : DeltaLFIntegrator(F), QF(&F) { }
+      : DeltaLFIntegrator(F), QF(&F) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -401,10 +409,11 @@ class VectorFEDomainLFDivIntegrator : public DeltaLFIntegrator
 private:
    Vector divshape;
    Coefficient &Q;
+
 public:
    /// Constructs the domain integrator (Q, div v)
    VectorFEDomainLFDivIntegrator(Coefficient &QF)
-      : DeltaLFIntegrator(QF), Q(QF) { }
+      : DeltaLFIntegrator(QF), Q(QF) {}
 
    /** Given a particular Finite Element and a transformation (Tr)
        computes the element right hand side element vector, elvect. */
@@ -432,7 +441,7 @@ private:
 public:
    VectorBoundaryFluxLFIntegrator(Coefficient &f, double s = 1.0,
                                   const IntegrationRule *ir = NULL)
-      : LinearFormIntegrator(ir), Sign(s), F(&f) { }
+      : LinearFormIntegrator(ir), Sign(s), F(&f) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -453,21 +462,21 @@ private:
 
 public:
    VectorFEBoundaryFluxLFIntegrator(int a = 1, int b = -1)
-      : F(NULL), oa(a), ob(b) { }
+      : F(NULL), oa(a), ob(b) {}
    VectorFEBoundaryFluxLFIntegrator(Coefficient &f, int a = 2, int b = 0)
-      : F(&f), oa(a), ob(b) { }
+      : F(&f), oa(a), ob(b) {}
+
+   virtual bool SupportsDevice() const { return true; }
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
                                        Vector &elvect);
 
-   using LinearFormIntegrator::AssembleRHSElementVect;
-
-   virtual bool SupportsDevice() const { return true; }
-
    virtual void AssembleDevice(const FiniteElementSpace &fes,
                                const Array<int> &markers,
                                Vector &b);
+
+   using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
 /// Class for boundary integration \f$ L(v) = (n \times f, v) \f$
@@ -480,7 +489,7 @@ private:
 public:
    VectorFEBoundaryTangentLFIntegrator(VectorCoefficient &QG,
                                        int a = 2, int b = 0)
-      : f(QG), oa(a), ob(b) { }
+      : f(QG), oa(a), ob(b) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -489,7 +498,6 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /** Class for boundary integration of the linear form:
     (alpha/2) < (u.n) f, w > - beta < |u.n| f, w >,
     where f and u are given scalar and vector coefficients, respectively,
@@ -512,6 +520,11 @@ public:
                           double a, double b)
    { f = &f_; u = &u_; alpha = a; beta = b; }
 
+   using LinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          FaceElementTransformations &Tr,
+                                          int oa = 2, int ob = 0) const;
+
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
                                        Vector &elvect);
@@ -522,7 +535,6 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /** Boundary linear integrator for imposing non-zero Dirichlet boundary
     conditions, to be used in conjunction with DGDiffusionIntegrator.
     Specifically, given the Dirichlet data u_D, the linear form assembles the
@@ -546,13 +558,13 @@ protected:
 
 public:
    DGDirichletLFIntegrator(Coefficient &u, const double s, const double k)
-      : uD(&u), Q(NULL), MQ(NULL), sigma(s), kappa(k) { }
+      : uD(&u), Q(NULL), MQ(NULL), sigma(s), kappa(k) {}
    DGDirichletLFIntegrator(Coefficient &u, Coefficient &q,
                            const double s, const double k)
-      : uD(&u), Q(&q), MQ(NULL), sigma(s), kappa(k) { }
+      : uD(&u), Q(&q), MQ(NULL), sigma(s), kappa(k) {}
    DGDirichletLFIntegrator(Coefficient &u, MatrixCoefficient &q,
                            const double s, const double k)
-      : uD(&u), Q(NULL), MQ(&q), sigma(s), kappa(k) { }
+      : uD(&u), Q(NULL), MQ(&q), sigma(s), kappa(k) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -564,7 +576,6 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /** Boundary linear form integrator for imposing non-zero Dirichlet boundary
     conditions, in a DG elasticity formulation. Specifically, the linear form is
     given by
@@ -597,7 +608,7 @@ public:
    DGElasticityDirichletLFIntegrator(VectorCoefficient &uD_,
                                      Coefficient &lambda_, Coefficient &mu_,
                                      double alpha_, double kappa_)
-      : uD(uD_), lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) { }
+      : uD(uD_), lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -609,7 +620,6 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /** Class for spatial white Gaussian noise integration.
 
     The target problem is the linear SPDE a(u,v) = F(v) with F(v) := <W,v>,
@@ -637,8 +647,8 @@ class WhiteGaussianNoiseDomainLFIntegrator : public LinearFormIntegrator
    std::normal_distribution<double> dist;
 
    bool save_factors = false;
-public:
 
+public:
 #ifdef MFEM_USE_MPI
    /** @brief Sets the @a seed_ of the random number generator. A fixed seed
        allows for a reproducible sequence of white noise vectors. */
@@ -669,13 +679,13 @@ public:
       if (seed_ > 0) { SetSeed(seed_); }
    }
 #endif
+
    /// @brief Sets/resets the @a seed of the random number generator.
    void SetSeed(int seed)
    {
       generator.seed(seed);
    }
 
-   using LinearFormIntegrator::AssembleRHSElementVect;
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
                                        Vector &elvect);
@@ -715,8 +725,9 @@ public:
       }
       L.DeleteAll();
    }
-};
 
+   using LinearFormIntegrator::AssembleRHSElementVect;
+};
 
 /** Class for domain integration of L(v) := (f, v), where
     f=(f1,...,fn) and v=(v1,...,vn). that makes use of
@@ -738,18 +749,23 @@ public:
       }
    }
 
-   using LinearFormIntegrator::AssembleRHSElementVect;
-   virtual void AssembleRHSElementVect(const FiniteElement &fe,
-                                       ElementTransformation &Tr,
-                                       Vector &elvect);
-
    virtual void SetIntRule(const IntegrationRule *ir)
    {
       MFEM_WARNING("Integration rule not used in this class. "
                    "The QuadratureFunction integration rules are used instead");
    }
-};
 
+   using LinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          ElementTransformation &Tr,
+                                          int oa = 2, int ob = 0) const;
+
+   virtual void AssembleRHSElementVect(const FiniteElement &fe,
+                                       ElementTransformation &Tr,
+                                       Vector &elvect);
+
+   using LinearFormIntegrator::AssembleRHSElementVect;
+};
 
 /** Class for domain integration L(v) := (f, v) that makes use
     of QuadratureFunctionCoefficient. */
@@ -770,19 +786,24 @@ public:
       }
    }
 
-   using LinearFormIntegrator::AssembleRHSElementVect;
-   virtual void AssembleRHSElementVect(const FiniteElement &fe,
-                                       ElementTransformation &Tr,
-                                       Vector &elvect);
-
    virtual void SetIntRule(const IntegrationRule *ir)
    {
       MFEM_WARNING("Integration rule not used in this class. "
                    "The QuadratureFunction integration rules are used instead");
    }
+
+   using LinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          ElementTransformation &Tr,
+                                          int oa = 2, int ob = 0) const;
+
+   virtual void AssembleRHSElementVect(const FiniteElement &fe,
+                                       ElementTransformation &Tr,
+                                       Vector &elvect);
+
+   using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
 }
 
-
 #endif
diff --git a/fem/nonlininteg.cpp b/fem/nonlininteg.cpp
index 5ee1febea..a704ee207 100644
--- a/fem/nonlininteg.cpp
+++ b/fem/nonlininteg.cpp
@@ -15,26 +15,44 @@
 namespace mfem
 {
 
+const IntegrationRule &NonlinearFormIntegrator::GetRule(
+   const FiniteElement&, const FiniteElement&,
+   ElementTransformation&) const
+{
+   MFEM_ABORT("NonlinearFormIntegrator::GetRule(...)\n"
+              "   is not implemented for this class.");
+   return IntRules.Get(0, 0);
+}
+
+const IntegrationRule &NonlinearFormIntegrator::GetRule(
+   const FiniteElement&, const FiniteElement&,
+   FaceElementTransformations&) const
+{
+   MFEM_ABORT("NonlinearFormIntegrator::GetRule(...)\n"
+              "   is not implemented for this class.");
+   return IntRules.Get(0, 0);
+}
+
 void NonlinearFormIntegrator::AssemblePA(const FiniteElementSpace&)
 {
    MFEM_ABORT("NonlinearFormIntegrator::AssemblePA(...)\n"
               "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleGradPA(const Vector &x,
-                                             const FiniteElementSpace &fes)
+void NonlinearFormIntegrator::AssembleGradPA(const Vector&,
+                                             const FiniteElementSpace&)
 {
    MFEM_ABORT("NonlinearFormIntegrator::AssembleGradPA(...)\n"
               "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleGradDiagonalPA(Vector &diag) const
+void NonlinearFormIntegrator::AssembleGradDiagonalPA(Vector&) const
 {
    MFEM_ABORT("NonlinearFormIntegrator::AssembleGradDiagonalPA(...)\n"
               "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AddMultPA(const Vector &, Vector &) const
+void NonlinearFormIntegrator::AddMultPA(const Vector&, Vector&) const
 {
    MFEM_ABORT("NonlinearFormIntegrator::AddMultPA(...)\n"
               "   is not implemented for this class.");
@@ -46,119 +64,141 @@ void NonlinearFormIntegrator::AddMultGradPA(const Vector&, Vector&) const
               "   is not implemented for this class.");
 }
 
-double NonlinearFormIntegrator::GetLocalStateEnergyPA(const Vector &x) const
+double NonlinearFormIntegrator::GetLocalStateEnergyPA(const Vector&) const
 {
    MFEM_ABORT("NonlinearFormIntegrator::GetLocalStateEnergyPA(...)\n"
               "   is not implemented for this class.");
    return 0.0;
 }
 
-void NonlinearFormIntegrator::AssembleMF(const FiniteElementSpace &fes)
+void NonlinearFormIntegrator::AssembleMF(const FiniteElementSpace&)
 {
    MFEM_ABORT("NonlinearFormIntegrator::AssembleMF(...)\n"
               "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AddMultMF(const Vector &, Vector &) const
+void NonlinearFormIntegrator::AddMultMF(const Vector&, Vector&) const
 {
    MFEM_ABORT("NonlinearFormIntegrator::AddMultMF(...)\n"
               "   is not implemented for this class.");
 }
 
-double NonlinearFormIntegrator::GetElementEnergy(
-   const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun)
+double NonlinearFormIntegrator::GetElementEnergy(const FiniteElement&,
+                                                 ElementTransformation&,
+                                                 const Vector&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::GetElementEnergy"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::GetElementEnergy(...)"
+              "   is not implemented for this class.");
    return 0.0;
 }
 
-void NonlinearFormIntegrator::AssembleElementVector(
-   const FiniteElement &el, ElementTransformation &Tr,
-   const Vector &elfun, Vector &elvect)
+void NonlinearFormIntegrator::AssembleElementVector(const FiniteElement&,
+                                                    ElementTransformation&,
+                                                    const Vector&,
+                                                    Vector&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementVector"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementVector(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleFaceVector(
-   const FiniteElement &el1, const FiniteElement &el2,
-   FaceElementTransformations &Tr, const Vector &elfun, Vector &elvect)
+void NonlinearFormIntegrator::AssembleFaceVector(const FiniteElement&,
+                                                 const FiniteElement&,
+                                                 FaceElementTransformations&,
+                                                 const Vector&,
+                                                 Vector&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceVector"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceVector(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleElementGrad(
-   const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun,
-   DenseMatrix &elmat)
+void NonlinearFormIntegrator::AssembleElementGrad(const FiniteElement&,
+                                                  ElementTransformation&,
+                                                  const Vector&,
+                                                  DenseMatrix&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementGrad"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementGrad(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleFaceGrad(
-   const FiniteElement &el1, const FiniteElement &el2,
-   FaceElementTransformations &Tr, const Vector &elfun,
-   DenseMatrix &elmat)
+void NonlinearFormIntegrator::AssembleFaceGrad(const FiniteElement&,
+                                               const FiniteElement&,
+                                               FaceElementTransformations&,
+                                               const Vector&,
+                                               DenseMatrix&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceGrad"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceGrad(...)\n"
+              "   is not implemented for this class.");
 }
 
+const IntegrationRule &BlockNonlinearFormIntegrator::GetRule(
+   const FiniteElement&, const FiniteElement&test_fe,
+   ElementTransformation&) const
+{
+   MFEM_ABORT("BlockNonlinearFormIntegrator::GetRule(...)\n"
+              "   is not implemented for this class.");
+   return IntRules.Get(0, 0);
+}
 
-void BlockNonlinearFormIntegrator::AssembleElementVector(
-   const Array<const FiniteElement *> &el,
-   ElementTransformation &Tr,
-   const Array<const Vector *> &elfun,
-   const Array<Vector *> &elvec)
+const IntegrationRule &BlockNonlinearFormIntegrator::GetRule(
+   const FiniteElement&, const FiniteElement&,
+   FaceElementTransformations&) const
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementVector"
-              " is not overloaded!");
+   MFEM_ABORT("BlockNonlinearFormIntegrator::GetRule(...)\n"
+              "   is not implemented for this class.");
+   return IntRules.Get(0, 0);
 }
 
-void BlockNonlinearFormIntegrator::AssembleFaceVector(
-   const Array<const FiniteElement *> &el1,
-   const Array<const FiniteElement *> &el2,
-   FaceElementTransformations &Tr,
-   const Array<const Vector *> &elfun,
-   const Array<Vector *> &elvect)
+double BlockNonlinearFormIntegrator::GetElementEnergy(
+   const Array<const FiniteElement *>&,
+   ElementTransformation&,
+   const Array<const Vector *>&)
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceVector"
-              " is not overloaded!");
+   MFEM_ABORT("BlockNonlinearFormIntegrator::GetElementEnergy(...)\n"
+              "   is not implemented for this class.");
+   return 0.0;
 }
 
-void BlockNonlinearFormIntegrator::AssembleElementGrad(
-   const Array<const FiniteElement*> &el,
-   ElementTransformation &Tr,
-   const Array<const Vector *> &elfun,
-   const Array2D<DenseMatrix *> &elmats)
+void BlockNonlinearFormIntegrator::AssembleElementVector(
+   const Array<const FiniteElement *>&,
+   ElementTransformation&,
+   const Array<const Vector *>&,
+   const Array<Vector *>&)
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementGrad"
-              " is not overloaded!");
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementVector(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BlockNonlinearFormIntegrator::AssembleFaceGrad(
-   const Array<const FiniteElement *>&el1,
-   const Array<const FiniteElement *>&el2,
-   FaceElementTransformations &Tr,
-   const Array<const Vector *> &elfun,
-   const Array2D<DenseMatrix *> &elmats)
+void BlockNonlinearFormIntegrator::AssembleFaceVector(
+   const Array<const FiniteElement *>&,
+   const Array<const FiniteElement *>&,
+   FaceElementTransformations&,
+   const Array<const Vector *>&,
+   const Array<Vector *>&)
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceGrad"
-              " is not overloaded!");
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceVector(...)\n"
+              "   is not implemented for this class.");
 }
 
-double BlockNonlinearFormIntegrator::GetElementEnergy(
-   const Array<const FiniteElement *>&el,
-   ElementTransformation &Tr,
-   const Array<const Vector *>&elfun)
+void BlockNonlinearFormIntegrator::AssembleElementGrad(
+   const Array<const FiniteElement*>&,
+   ElementTransformation&,
+   const Array<const Vector *>&,
+   const Array2D<DenseMatrix *>&)
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::GetElementEnergy"
-              " is not overloaded!");
-   return 0.0;
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementGrad(...)\n"
+              "   is not implemented for this class.");
 }
 
+void BlockNonlinearFormIntegrator::AssembleFaceGrad(
+   const Array<const FiniteElement *>&,
+   const Array<const FiniteElement *>&,
+   FaceElementTransformations&,
+   const Array<const Vector *>&,
+   const Array2D<DenseMatrix *>&)
+{
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceGrad(...)\n"
+              "   is not implemented for this class.");
+}
 
 double InverseHarmonicModel::EvalW(const DenseMatrix &J) const
 {
@@ -260,7 +300,6 @@ void InverseHarmonicModel::AssembleH(
       }
 }
 
-
 inline void NeoHookeanModel::EvalCoeffs() const
 {
    mu = c_mu->Eval(*Ttr, Ttr->GetIntPoint());
@@ -376,6 +415,13 @@ void NeoHookeanModel::AssembleH(const DenseMatrix &J, const DenseMatrix &DS,
             }
 }
 
+const IntegrationRule &HyperelasticNLFIntegrator::GetRule(
+   const FiniteElement &trial_fe, const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() + 3;
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
 
 double HyperelasticNLFIntegrator::GetElementEnergy(const FiniteElement &el,
                                                    ElementTransformation &Ttr,
@@ -390,11 +436,7 @@ double HyperelasticNLFIntegrator::GetElementEnergy(const FiniteElement &el,
    Jpt.SetSize(dim);
    PMatI.UseExternalData(elfun.GetData(), dof, dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (!ir)
-   {
-      ir = &(IntRules.Get(el.GetGeomType(), 2*el.GetOrder() + 3)); // <---
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Ttr);
 
    energy = 0.0;
    model->SetTransformation(Ttr);
@@ -429,11 +471,7 @@ void HyperelasticNLFIntegrator::AssembleElementVector(
    elvect.SetSize(dof*dim);
    PMatO.UseExternalData(elvect.GetData(), dof, dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (!ir)
-   {
-      ir = &(IntRules.Get(el.GetGeomType(), 2*el.GetOrder() + 3)); // <---
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Ttr);
 
    elvect = 0.0;
    model->SetTransformation(Ttr);
@@ -468,11 +506,7 @@ void HyperelasticNLFIntegrator::AssembleElementGrad(const FiniteElement &el,
    PMatI.UseExternalData(elfun.GetData(), dof, dim);
    elmat.SetSize(dof*dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (!ir)
-   {
-      ir = &(IntRules.Get(el.GetGeomType(), 2*el.GetOrder() + 3)); // <---
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Ttr);
 
    elmat = 0.0;
    model->SetTransformation(Ttr);
@@ -490,6 +524,13 @@ void HyperelasticNLFIntegrator::AssembleElementGrad(const FiniteElement &el,
    }
 }
 
+const IntegrationRule &IncompressibleNeoHookeanIntegrator::GetRule(
+   const FiniteElement &trial_fe, const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() + 3;
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
 
 double IncompressibleNeoHookeanIntegrator::GetElementEnergy(
    const Array<const FiniteElement *>&el,
@@ -511,15 +552,14 @@ double IncompressibleNeoHookeanIntegrator::GetElementEnergy(
    J.SetSize(dim);
    PMatI_u.UseExternalData(elfun[0]->GetData(), dof_u, dim);
 
-   int intorder = 2*el[0]->GetOrder() + 3; // <---
-   const IntegrationRule &ir = IntRules.Get(el[0]->GetGeomType(), intorder);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el[0], Tr);
 
    double energy = 0.0;
    double mu = 0.0;
 
-   for (int i = 0; i < ir.GetNPoints(); ++i)
+   for (int i = 0; i < ir->GetNPoints(); ++i)
    {
-      const IntegrationPoint &ip = ir.IntPoint(i);
+      const IntegrationPoint &ip = ir->IntPoint(i);
       Tr.SetIntPoint(&ip);
       CalcInverse(Tr.Jacobian(), J0i);
 
@@ -572,15 +612,14 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementVector(
    Sh_p.SetSize(dof_p);
    elvec[1]->SetSize(dof_p);
 
-   int intorder = 2*el[0]->GetOrder() + 3; // <---
-   const IntegrationRule &ir = IntRules.Get(el[0]->GetGeomType(), intorder);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el[0], Tr);
 
    *elvec[0] = 0.0;
    *elvec[1] = 0.0;
 
-   for (int i = 0; i < ir.GetNPoints(); ++i)
+   for (int i = 0; i < ir->GetNPoints(); ++i)
    {
-      const IntegrationPoint &ip = ir.IntPoint(i);
+      const IntegrationPoint &ip = ir->IntPoint(i);
       Tr.SetIntPoint(&ip);
       CalcInverse(Tr.Jacobian(), J0i);
 
@@ -605,7 +644,6 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementVector(
 
       elvec[1]->Add(ip.weight * Tr.Weight() * (dJ - 1.0), Sh_p);
    }
-
 }
 
 void IncompressibleNeoHookeanIntegrator::AssembleElementGrad(
@@ -639,12 +677,11 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementGrad(
    PMatI_u.UseExternalData(elfun[0]->GetData(), dof_u, dim);
    Sh_p.SetSize(dof_p);
 
-   int intorder = 2*el[0]->GetOrder() + 3; // <---
-   const IntegrationRule &ir = IntRules.Get(el[0]->GetGeomType(), intorder);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el[0], Tr);
 
-   for (int i = 0; i < ir.GetNPoints(); ++i)
+   for (int i = 0; i < ir->GetNPoints(); ++i)
    {
-      const IntegrationPoint &ip = ir.IntPoint(i);
+      const IntegrationPoint &ip = ir->IntPoint(i);
       Tr.SetIntPoint(&ip);
       CalcInverse(Tr.Jacobian(), J0i);
 
@@ -721,16 +758,15 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementGrad(
          }
       }
    }
-
 }
 
-
-const IntegrationRule&
-VectorConvectionNLFIntegrator::GetRule(const FiniteElement &fe,
-                                       ElementTransformation &T)
+const IntegrationRule &VectorConvectionNLFIntegrator::GetRule(
+   const FiniteElement &trial_fe, const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
 {
-   const int order = 2 * fe.GetOrder() + T.OrderGrad(&fe);
-   return IntRules.Get(fe.GetGeomType(), order);
+   int order = Trans.OrderGrad(&trial_fe) + trial_fe.GetOrder() +
+               test_fe.GetOrder();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
 void VectorConvectionNLFIntegrator::AssembleElementVector(
@@ -751,7 +787,9 @@ void VectorConvectionNLFIntegrator::AssembleElementVector(
    ELV.UseExternalData(elvect.GetData(), nd, dim);
 
    Vector vec1(dim), vec2(dim);
+
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+
    ELV = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -841,7 +879,6 @@ void VectorConvectionNLFIntegrator::AssembleElementGrad(
    }
 }
 
-
 void ConvectiveVectorConvectionNLFIntegrator::AssembleElementGrad(
    const FiniteElement &el,
    ElementTransformation &trans,
@@ -890,7 +927,6 @@ void ConvectiveVectorConvectionNLFIntegrator::AssembleElementGrad(
    }
 }
 
-
 void SkewSymmetricVectorConvectionNLFIntegrator::AssembleElementGrad(
    const FiniteElement &el,
    ElementTransformation &trans,
diff --git a/fem/nonlininteg.hpp b/fem/nonlininteg.hpp
index 38b133244..4c2ee2470 100644
--- a/fem/nonlininteg.hpp
+++ b/fem/nonlininteg.hpp
@@ -17,6 +17,7 @@
 #include "coefficient.hpp"
 #include "fespace.hpp"
 #include "ceed/interface/operator.hpp"
+#include "ceed/interface/util.hpp"
 
 namespace mfem
 {
@@ -37,23 +38,43 @@ protected:
       : IntRule(ir), ceedOp(NULL) {}
 
 public:
+   /// Set the memory type used for GeometricFactors and other large allocations
+   /// in PA extensions.
+   void SetPAMemoryType(MemoryType mt) { pa_mt = mt; }
+
+   /// Indicates whether this integrator can use a Ceed backend.
+   virtual bool SupportsCeed() const { return false; }
+
+   /// Access the underlying ceed::Operator for libCEED backends, after the
+   /// integrator has been assembled.
+   ceed::Operator &GetCeedOp() { return *ceedOp; }
+
    /** @brief Prescribe a fixed IntegrationRule to use (when @a ir != NULL) or
        let the integrator choose (when @a ir == NULL). */
    virtual void SetIntRule(const IntegrationRule *ir) { IntRule = ir; }
-
-   /// Prescribe a fixed IntegrationRule to use.
    void SetIntegrationRule(const IntegrationRule &ir) { SetIntRule(&ir); }
 
-   /// Set the memory type used for GeometricFactors and other large allocations
-   /// in PA extensions.
-   void SetPAMemoryType(MemoryType mt) { pa_mt = mt; }
-
    /// Get the integration rule of the integrator (possibly NULL).
    const IntegrationRule *GetIntegrationRule() const { return IntRule; }
 
+   /// Get the integration rule of the integrator as a function of the finite
+   /// element and geometry orders.
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Trans) const;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const;
+   const IntegrationRule &GetRule(const FiniteElement &el,
+                                  ElementTransformation &Trans) const
+   { return GetRule(el, el, Trans); }
+   const IntegrationRule &GetRule(const FiniteElement &el,
+                                  FaceElementTransformations &Trans) const
+   { return GetRule(el, el, Trans); }
+
    /// Method defining partial assembly.
    /** The result of the partial assembly is stored internally so that it can be
-       used later in the methods AddMultPA(). */
+       used later in the methods AddMultPA() and AddMultTransposePA(). */
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
    /** @brief Prepare the integrator for partial assembly (PA) gradient
@@ -132,11 +153,6 @@ public:
                                  FaceElementTransformations &Tr,
                                  const Vector &elfun, DenseMatrix &elmat);
 
-   /// Indicates whether this integrator can use a Ceed backend.
-   virtual bool SupportsCeed() const { return false; }
-
-   ceed::Operator &GetCeedOp() { return *ceedOp; }
-
    virtual ~NonlinearFormIntegrator()
    {
       delete ceedOp;
@@ -149,7 +165,36 @@ public:
     for block state vectors. */
 class BlockNonlinearFormIntegrator
 {
+protected:
+   const IntegrationRule *IntRule;
+
+   BlockNonlinearFormIntegrator(const IntegrationRule *ir = NULL)
+      : IntRule(ir) {}
+
 public:
+   /** @brief Prescribe a fixed IntegrationRule to use (when @a ir != NULL) or
+       let the integrator choose (when @a ir == NULL). */
+   virtual void SetIntRule(const IntegrationRule *ir) { IntRule = ir; }
+   void SetIntegrationRule(const IntegrationRule &ir) { SetIntRule(&ir); }
+
+   /// Get the integration rule of the integrator (possibly NULL).
+   const IntegrationRule *GetIntegrationRule() const { return IntRule; }
+
+   /// Get the integration rule of the integrator as a function of the finite
+   /// element and geometry orders.
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Tr) const;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Tr) const;
+   const IntegrationRule &GetRule(const FiniteElement &el,
+                                  ElementTransformation &Trans) const
+   { return GetRule(el, el, Trans); }
+   const IntegrationRule &GetRule(const FiniteElement &el,
+                                  FaceElementTransformations &Trans) const
+   { return GetRule(el, el, Trans); }
+
    /// Compute the local energy
    virtual double GetElementEnergy(const Array<const FiniteElement *>&el,
                                    ElementTransformation &Tr,
@@ -182,8 +227,7 @@ public:
    virtual ~BlockNonlinearFormIntegrator() {}
 };
 
-
-/// Abstract class for hyperelastic models
+/// Abstract base class for hyperelastic models
 class HyperelasticModel
 {
 protected:
@@ -228,7 +272,6 @@ public:
                           const double weight, DenseMatrix &A) const = 0;
 };
 
-
 /** Inverse-harmonic hyperelastic model with a strain energy density function
     given by the formula: W(J) = (1/2) det(J) Tr((J J^t)^{-1}) where J is the
     deformation gradient. */
@@ -247,7 +290,6 @@ public:
                           const double weight, DenseMatrix &A) const;
 };
 
-
 /** Neo-Hookean hyperelastic model with a strain energy density function given
     by the formula: \f$(\mu/2)(\bar{I}_1 - dim) + (K/2)(det(J)/g - 1)^2\f$ where
     J is the deformation gradient and \f$\bar{I}_1 = (det(J))^{-2/dim} Tr(J
@@ -281,7 +323,6 @@ public:
                           const double weight, DenseMatrix &A) const;
 };
 
-
 /** Hyperelastic integrator for any given HyperelasticModel.
 
     Represents @f$ \int W(Jpt) dx @f$ over a target zone, where W is the
@@ -310,10 +351,11 @@ public:
    /** @param[in] m  HyperelasticModel that will be integrated. */
    HyperelasticNLFIntegrator(HyperelasticModel *m) : model(m) {}
 
-   /** @brief Computes the integral of W(Jacobian(Trt)) over a target zone
-       @param[in] el     Type of FiniteElement.
-       @param[in] Ttr    Represents ref->target coordinates transformation.
-       @param[in] elfun  Physical coordinates of the zone. */
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Trans) const;
+
    virtual double GetElementEnergy(const FiniteElement &el,
                                    ElementTransformation &Ttr,
                                    const Vector &elfun);
@@ -342,24 +384,26 @@ private:
 public:
    IncompressibleNeoHookeanIntegrator(Coefficient &mu_) : c_mu(&mu_) {}
 
+   using BlockNonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Trans) const;
+
    virtual double GetElementEnergy(const Array<const FiniteElement *>&el,
                                    ElementTransformation &Tr,
                                    const Array<const Vector *> &elfun);
 
-   /// Perform the local action of the NonlinearFormIntegrator
    virtual void AssembleElementVector(const Array<const FiniteElement *> &el,
                                       ElementTransformation &Tr,
                                       const Array<const Vector *> &elfun,
                                       const Array<Vector *> &elvec);
 
-   /// Assemble the local gradient matrix
    virtual void AssembleElementGrad(const Array<const FiniteElement*> &el,
                                     ElementTransformation &Tr,
                                     const Array<const Vector *> &elfun,
                                     const Array2D<DenseMatrix *> &elmats);
 };
 
-
 class VectorConvectionNLFIntegrator : public NonlinearFormIntegrator
 {
 private:
@@ -378,8 +422,12 @@ public:
 
    VectorConvectionNLFIntegrator() = default;
 
-   static const IntegrationRule &GetRule(const FiniteElement &fe,
-                                         ElementTransformation &T);
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementVector(const FiniteElement &el,
                                       ElementTransformation &trans,
@@ -400,7 +448,6 @@ public:
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 };
 
-
 /** This class is used to assemble the convective form of the nonlinear term
     arising in the Navier-Stokes equations \f$(u \cdot \nabla v, w )\f$ */
 class ConvectiveVectorConvectionNLFIntegrator :
@@ -422,7 +469,6 @@ public:
                                     DenseMatrix &elmat);
 };
 
-
 /** This class is used to assemble the skew-symmetric form of the nonlinear term
     arising in the Navier-Stokes equations
     \f$.5*(u \cdot \nabla v, w ) - .5*(u \cdot \nabla w, v )\f$ */
diff --git a/fem/transfer.cpp b/fem/transfer.cpp
index 7f95ca9fe..a7dd0731c 100644
--- a/fem/transfer.cpp
+++ b/fem/transfer.cpp
@@ -930,17 +930,13 @@ TransferOperator::TransferOperator(const FiniteElementSpace& lFESpace_,
       P.SetOperatorOwner(false);
       opr = P.Ptr();
    }
-   else if (lFESpace_.GetMesh()->GetNE() > 0
-            && hFESpace_.GetMesh()->GetNE() > 0
-            && lFESpace_.GetVDim() == 1
-            && hFESpace_.GetVDim() == 1
-            && dynamic_cast<const TensorBasisElement*>(lFESpace_.GetFE(0))
-            && dynamic_cast<const TensorBasisElement*>(hFESpace_.GetFE(0))
-            && !isvar_order
-            && (hFESpace_.FEColl()->GetContType() ==
-                mfem::FiniteElementCollection::CONTINUOUS ||
-                hFESpace_.FEColl()->GetContType() ==
-                mfem::FiniteElementCollection::DISCONTINUOUS))
+   else if (UsesTensorBasis(lFESpace_) && UsesTensorBasis(hFESpace_) &&
+            lFESpace_.GetVDim() == 1 && hFESpace_.GetVDim() == 1 &&
+            !isvar_order &&
+            (hFESpace_.FEColl()->GetContType() ==
+             mfem::FiniteElementCollection::CONTINUOUS ||
+             hFESpace_.FEColl()->GetContType() ==
+             mfem::FiniteElementCollection::DISCONTINUOUS))
    {
       opr = new TensorProductPRefinementTransferOperator(lFESpace_, hFESpace_);
    }
diff --git a/general/array.cpp b/general/array.cpp
index 12c3e3c06..e1a81e2d1 100644
--- a/general/array.cpp
+++ b/general/array.cpp
@@ -175,6 +175,7 @@ void Array2D<T>::Print(std::ostream &os, int width_)
    }
 }
 
+template class Array<bool>;
 template class Array<char>;
 template class Array<int>;
 template class Array<long long>;
diff --git a/general/device.cpp b/general/device.cpp
index ccee71cd7..1ea480245 100644
--- a/general/device.cpp
+++ b/general/device.cpp
@@ -481,14 +481,14 @@ static void OccaDeviceSetup(const int dev)
 #endif
 }
 
-static void CeedDeviceSetup(const char* ceed_spec)
+static void CeedDeviceSetup(const char *ceed_spec)
 {
 #ifdef MFEM_USE_CEED
    CeedInit(ceed_spec, &internal::ceed);
    const char *ceed_backend;
    CeedGetResource(internal::ceed, &ceed_backend);
-   if (strcmp(ceed_spec, ceed_backend) && strcmp(ceed_spec, "/cpu/self") &&
-       strcmp(ceed_spec, "/gpu/hip"))
+   size_t ceed_spec_len = strlen(ceed_spec);
+   if (strncmp(ceed_spec, ceed_backend, ceed_spec_len))
    {
       mfem::out << std::endl << "WARNING!!!\n"
                 "libCEED is not using the requested backend!!!\n"
diff --git a/makefile b/makefile
index a606f6dfe..ee5cd6b0d 100644
--- a/makefile
+++ b/makefile
@@ -271,7 +271,6 @@ MFEM_REQ_LIB_DEPS = ENZYME SUPERLU MUMPS METIS FMS CONDUIT SIDRE LAPACK SUNDIALS
  GSLIB OCCA CEED RAJA UMPIRE MKL_CPARDISO AMGX CALIPER PARELAG BENCHMARK\
  MOONOLITH ALGOIM
 
-
 PETSC_ERROR_MSG = $(if $(PETSC_FOUND),,. PETSC config not found: $(PETSC_VARS))
 SLEPC_ERROR_MSG = $(if $(SLEPC_FOUND),,. SLEPC config not found: $(SLEPC_VARS))
 
@@ -409,7 +408,11 @@ endif
 DIRS = general linalg linalg/simd mesh mesh/submesh fem fem/ceed/interface \
        fem/ceed/integrators/mass fem/ceed/integrators/convection \
        fem/ceed/integrators/diffusion fem/ceed/integrators/nlconvection \
-       fem/ceed/solvers fem/fe fem/lor fem/qinterp fem/integ fem/tmop
+       fem/ceed/integrators/vecfemass fem/ceed/integrators/divdiv \
+       fem/ceed/integrators/curlcurl fem/ceed/integrators/mixedvecgrad \
+       fem/ceed/integrators/mixedveccurl fem/ceed/integrators/interp \
+       fem/ceed/integrators/util fem/ceed/solvers \
+       fem/fe fem/lor fem/qinterp fem/integ fem/tmop
 
 ifeq ($(MFEM_USE_MOONOLITH),YES)
    MFEM_CXXFLAGS += $(MOONOLITH_CXX_FLAGS)
@@ -423,7 +426,7 @@ RELSRC_FILES = $(patsubst $(SRC)%,%,$(SOURCE_FILES))
 OBJECT_FILES = $(patsubst $(SRC)%,$(BLD)%,$(SOURCE_FILES:.cpp=.o))
 OKL_DIRS = fem
 
-.PHONY: lib all clean distclean install config status info deps serial parallel	\
+.PHONY: lib all clean distclean install config status info deps serial parallel \
 	debug pdebug cuda hip pcuda cudebug pcudebug hpc style check test unittest \
 	deprecation-warnings
 
@@ -603,6 +606,14 @@ install: $(if $(static),$(BLD)libmfem.a) $(if $(shared),$(BLD)libmfem.$(SO_EXT))
 	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/diffusion/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/diffusion
 	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/nlconvection
 	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/nlconvection/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/nlconvection
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/vecfemass
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/vecfemass/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/vecfemass
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/divdiv
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/divdiv/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/divdiv
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/curlcurl
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/curlcurl/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/curlcurl
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/util
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/util/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/util
 # install config.mk in $(PREFIX_SHARE)
 	mkdir -p $(PREFIX_SHARE)
 	$(MAKE) -C $(BLD)config config-mk CONFIG_MK=config-install.mk
@@ -726,17 +737,16 @@ status info:
 ASTYLE_BIN = astyle
 ASTYLE = $(ASTYLE_BIN) --options=$(SRC)config/mfem.astylerc
 ASTYLE_VER = "Artistic Style Version 3.1"
-FORMAT_FILES = $(foreach dir,$(DIRS) $(EM_DIRS) config,$(dir)/*.?pp)
-FORMAT_FILES += tests/unit/*.?pp
-UNIT_TESTS_SUBDIRS = general linalg mesh fem miniapps ceed
-MINIAPPS_SUBDIRS = dpg/util hooke/operators hooke/preconditioners hooke/materials hooke/kernels
-FORMAT_FILES += $(foreach dir,$(UNIT_TESTS_SUBDIRS),tests/unit/$(dir)/*.?pp)
-FORMAT_FILES += $(foreach dir,$(MINIAPPS_SUBDIRS),miniapps/$(dir)/*.?pp)
-FORMAT_EXCLUDE = general/tinyxml2.cpp tests/unit/catch.hpp
+FORMAT_FILES = $(foreach dir,$(DIRS) $(EM_DIRS) config,$(dir)/*.[ch]pp $(dir)/*.[ch])
+FORMAT_FILES += tests/unit/*.[ch]pp
+FORMAT_FILES += $(foreach dir,$(wildcard tests/unit/*),$(dir)/*.[ch]pp $(dir)/*.[ch])
+FORMAT_FILES += $(foreach dir,$(wildcard miniapps/*/*),$(dir)/*.[ch]pp $(dir)/*.[ch])
+FORMAT_EXCLUDE = general/tinyxml2.cpp tests/unit/catch.hpp fem/picojson.h general/tinyxml2.h
 FORMAT_LIST = $(filter-out $(FORMAT_EXCLUDE),$(wildcard $(FORMAT_FILES)))
 
-COUT_CERR_FILES = $(foreach dir,$(DIRS),$(dir)/*.[ch]pp)
-COUT_CERR_EXCLUDE = '^general/error\.cpp' '^general/globals\.[ch]pp'
+COUT_CERR_FILES = $(foreach dir,$(DIRS),$(dir)/*.[ch]pp $(dir)/*.[ch])
+COUT_CERR_EXCLUDE = general/error.cpp general/globals.cpp general/globals.hpp
+COUT_CERR_LIST = $(filter-out $(COUT_CERR_EXCLUDE),$(wildcard $(COUT_CERR_FILES)))
 
 DEPRECATION_WARNING := \
 "This feature is planned for removal in the next release."\
@@ -772,12 +782,12 @@ style:
 	    "Please make sure the changes are committed");\
 	echo "Checking for use of std::cout...";\
 	$(call mfem_check_command,\
-	   grep cout $(COUT_CERR_FILES) | grep -v $(COUT_CERR_EXCLUDE:%=-e %),\
+	   grep cout $(COUT_CERR_LIST),\
 	   "No use of std::cout found", "Use mfem::out instead of std::cout");\
 	echo "Checking for use of std::cerr...";\
 	$(call mfem_check_command,\
-	   grep cerr $(COUT_CERR_FILES) |\
-	      grep -v $(COUT_CERR_EXCLUDE:%=-e %) -e cerrno,\
+	   grep cerr $(COUT_CERR_LIST) |\
+	      grep -v -e cerrno,\
 	   "No use of std::cerr found", "Use mfem::err instead of std::cerr");\
 	exit $$err_code
 
diff --git a/miniapps/shifted/sbm_solver.hpp b/miniapps/shifted/sbm_solver.hpp
index db16738d5..b8830bf31 100644
--- a/miniapps/shifted/sbm_solver.hpp
+++ b/miniapps/shifted/sbm_solver.hpp
@@ -121,7 +121,6 @@ public:
         par_shared_face_count(0),
         cut_marker(cut_marker_) { }
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -241,7 +240,6 @@ public:
         par_shared_face_count(0),
         cut_marker(cut_marker_) { }
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
diff --git a/tests/unit/ceed/test_ceed.cpp b/tests/unit/ceed/test_ceed.cpp
index 971b68e24..46f5e6bab 100644
--- a/tests/unit/ceed/test_ceed.cpp
+++ b/tests/unit/ceed/test_ceed.cpp
@@ -21,7 +21,15 @@ namespace ceed_test
 
 #ifdef MFEM_USE_CEED
 
-enum class CeedCoeffType { Const, Grid, Quad, VecConst, VecGrid, VecQuad };
+enum class CeedCoeffType { Const,
+                           Grid,
+                           Quad,
+                           VecConst,
+                           VecGrid,
+                           VecQuad,
+                           MatConst,
+                           MatQuad
+                         };
 
 double coeff_function(const Vector &x)
 {
@@ -41,11 +49,24 @@ void velocity_function(const Vector &x, Vector &v)
    }
 }
 
+// Matrix-valued velocity coefficient
+void matrix_velocity_function(const Vector &x, DenseMatrix &m)
+{
+   int dim = x.Size();
+   Vector v(dim);
+   velocity_function(x, v);
+   m.SetSize(dim);
+   m = 0.5;
+   for (int i = 0; i < dim; i++)
+   {
+      m(i, i) = 1.0 + v(i);
+   }
+}
+
 // Vector valued quantity to convect
 void quantity(const Vector &x, Vector &u)
 {
    int dim = x.Size();
-
    switch (dim)
    {
       case 1: u(0) = x[0]*x[0]; break;
@@ -59,7 +80,6 @@ void quantity(const Vector &x, Vector &u)
 void convected_quantity(const Vector &x, Vector &u)
 {
    double a, b, c;
-
    int dim = x.Size();
    switch (dim)
    {
@@ -82,7 +102,7 @@ void convected_quantity(const Vector &x, Vector &u)
    }
 }
 
-std::string getString(AssemblyLevel assembly)
+std::string GetString(AssemblyLevel assembly)
 {
    switch (assembly)
    {
@@ -106,7 +126,7 @@ std::string getString(AssemblyLevel assembly)
    return "";
 }
 
-std::string getString(CeedCoeffType coeff_type)
+std::string GetString(CeedCoeffType coeff_type)
 {
    switch (coeff_type)
    {
@@ -128,6 +148,12 @@ std::string getString(CeedCoeffType coeff_type)
       case CeedCoeffType::VecQuad:
          return "VecQuad";
          break;
+      case CeedCoeffType::MatConst:
+         return "MatConst";
+         break;
+      case CeedCoeffType::MatQuad:
+         return "MatQuad";
+         break;
    }
    MFEM_ABORT("Unknown CeedCoeffType.");
    return "";
@@ -138,10 +164,16 @@ enum class Problem { Mass,
                      Diffusion,
                      VectorMass,
                      VectorDiffusion,
-                     MassDiffusion
+                     MassDiffusion,
+                     HDivMass,
+                     HCurlMass,
+                     DivDiv,
+                     CurlCurl,
+                     MixedVectorGradient,
+                     MixedVectorCurl
                    };
 
-std::string getString(Problem pb)
+std::string GetString(Problem pb)
 {
    switch (pb)
    {
@@ -163,6 +195,24 @@ std::string getString(Problem pb)
       case Problem::MassDiffusion:
          return "MassDiffusion";
          break;
+      case Problem::HDivMass:
+         return "HDivMass";
+         break;
+      case Problem::HCurlMass:
+         return "HCurlMass";
+         break;
+      case Problem::DivDiv:
+         return "DivDiv";
+         break;
+      case Problem::CurlCurl:
+         return "CurlCurl";
+         break;
+      case Problem::MixedVectorGradient:
+         return "MixedVectorGradient";
+         break;
+      case Problem::MixedVectorCurl:
+         return "MixedVectorCurl";
+         break;
    }
    MFEM_ABORT("Unknown Problem.");
    return "";
@@ -170,7 +220,7 @@ std::string getString(Problem pb)
 
 enum class NLProblem {Convection};
 
-std::string getString(NLProblem pb)
+std::string GetString(NLProblem pb)
 {
    switch (pb)
    {
@@ -178,14 +228,15 @@ std::string getString(NLProblem pb)
          return "Convection";
          break;
    }
-   MFEM_ABORT("Unknown Problem.");
+   MFEM_ABORT("Unknown NLProblem.");
    return "";
 }
 
 void InitCoeff(Mesh &mesh, FiniteElementCollection &fec, const int dim,
                const CeedCoeffType coeff_type, GridFunction *&gf,
-               FiniteElementSpace *& coeff_fes,
-               Coefficient *&coeff, VectorCoefficient *&vcoeff)
+               FiniteElementSpace *&coeff_fes,
+               Coefficient *&coeff, VectorCoefficient *&vcoeff,
+               MatrixCoefficient *&mcoeff)
 {
    switch (coeff_type)
    {
@@ -209,7 +260,7 @@ void InitCoeff(Mesh &mesh, FiniteElementCollection &fec, const int dim,
          Vector val(dim);
          for (int i = 0; i < dim; i++)
          {
-            val(i) = 1.0;
+            val(i) = 1.0 + i;
          }
          vcoeff = new VectorConstantCoefficient(val);
          break;
@@ -226,21 +277,38 @@ void InitCoeff(Mesh &mesh, FiniteElementCollection &fec, const int dim,
       case CeedCoeffType::VecQuad:
          vcoeff = new VectorFunctionCoefficient(dim, velocity_function);
          break;
+      case CeedCoeffType::MatConst:
+      {
+         DenseMatrix val(dim);
+         val = 0.5;
+         for (int i = 0; i < dim; i++)
+         {
+            val(i, i) = 1.0 + i;
+         }
+         mcoeff = new MatrixConstantCoefficient(val);
+         break;
+      }
+      case CeedCoeffType::MatQuad:
+         mcoeff = new MatrixFunctionCoefficient(dim, matrix_velocity_function);
+         break;
    }
 }
 
-void test_ceed_operator(const char* input, int order,
+void test_ceed_operator(const char *input, int order,
                         const CeedCoeffType coeff_type, const Problem pb,
-                        const AssemblyLevel assembly)
+                        const AssemblyLevel assembly, bool mixed_p, bool bdr_integ)
 {
-   std::string section = "assembly: " + getString(assembly) + "\n" +
-                         "coeff_type: " + getString(coeff_type) + "\n" +
-                         "pb: " + getString(pb) + "\n" +
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "coeff_type: " + GetString(coeff_type) + "\n" +
+                         "pb: " + GetString(pb) + "\n" +
                          "order: " + std::to_string(order) + "\n" +
+                         (mixed_p ? "mixed_p: true\n" : "") +
+                         (bdr_integ ? "bdr_integ: true\n" : "") +
                          "mesh: " + input;
    INFO(section);
    Mesh mesh(input, 1, 1);
    mesh.EnsureNodes();
+   if (mixed_p) { mesh.EnsureNCMesh(); }
    int dim = mesh.Dimension();
    H1_FECollection fec(order, dim);
 
@@ -249,43 +317,65 @@ void test_ceed_operator(const char* input, int order,
    FiniteElementSpace *coeff_fes = nullptr;
    Coefficient *coeff = nullptr;
    VectorCoefficient *vcoeff = nullptr;
-   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff);
+   MatrixCoefficient *mcoeff = nullptr;
+   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff, mcoeff);
+   MFEM_VERIFY(!mcoeff,
+               "Unexpected matrix-valued coefficient in test_ceed_operator.");
 
    // Build the BilinearForm
    bool vecOp = pb == Problem::VectorMass || pb == Problem::VectorDiffusion;
    const int vdim = vecOp ? dim : 1;
    FiniteElementSpace fes(&mesh, &fec, vdim);
+   if (mixed_p)
+   {
+      fes.SetElementOrder(0, order+1);
+      fes.SetElementOrder(fes.GetNE() - 1, order+1);
+      fes.Update(false);
+   }
 
-   BilinearForm k_test(&fes);
    BilinearForm k_ref(&fes);
+   BilinearForm k_test(&fes);
+   auto AddIntegrator = [&bdr_integ](BilinearForm &k, BilinearFormIntegrator *blfi)
+   {
+      if (bdr_integ)
+      {
+         k.AddBoundaryIntegrator(blfi);
+      }
+      else
+      {
+         k.AddDomainIntegrator(blfi);
+      }
+   };
    switch (pb)
    {
       case Problem::Mass:
-         k_ref.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new MassIntegrator(*coeff));
+         AddIntegrator(k_ref, new MassIntegrator(*coeff));
+         AddIntegrator(k_test, new MassIntegrator(*coeff));
          break;
       case Problem::Convection:
-         k_ref.AddDomainIntegrator(new ConvectionIntegrator(*vcoeff,-1));
-         k_test.AddDomainIntegrator(new ConvectionIntegrator(*vcoeff,-1));
+         AddIntegrator(k_ref, new ConvectionIntegrator(*vcoeff, -1));
+         AddIntegrator(k_test, new ConvectionIntegrator(*vcoeff, -1));
          break;
       case Problem::Diffusion:
-         k_ref.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
+         AddIntegrator(k_ref, new DiffusionIntegrator(*coeff));
+         AddIntegrator(k_test, new DiffusionIntegrator(*coeff));
          break;
       case Problem::VectorMass:
-         k_ref.AddDomainIntegrator(new VectorMassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new VectorMassIntegrator(*coeff));
+         AddIntegrator(k_ref, new VectorMassIntegrator(*coeff));
+         AddIntegrator(k_test, new VectorMassIntegrator(*coeff));
          break;
       case Problem::VectorDiffusion:
-         k_ref.AddDomainIntegrator(new VectorDiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new VectorDiffusionIntegrator(*coeff));
+         AddIntegrator(k_ref, new VectorDiffusionIntegrator(*coeff));
+         AddIntegrator(k_test, new VectorDiffusionIntegrator(*coeff));
          break;
       case Problem::MassDiffusion:
-         k_ref.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_ref.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
+         AddIntegrator(k_ref, new MassIntegrator(*coeff));
+         AddIntegrator(k_test, new MassIntegrator(*coeff));
+         AddIntegrator(k_ref, new DiffusionIntegrator(*coeff));
+         AddIntegrator(k_test, new DiffusionIntegrator(*coeff));
          break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
    }
 
    k_ref.Assemble();
@@ -294,121 +384,499 @@ void test_ceed_operator(const char* input, int order,
    k_test.SetAssemblyLevel(assembly);
    k_test.Assemble();
 
-   // Compare ceed with mfem.
+   // Compare ceed with mfem
    GridFunction x(&fes), y_ref(&fes), y_test(&fes);
+   Vector d_ref(fes.GetTrueVSize()), d_test(fes.GetTrueVSize());
 
    x.Randomize(1);
 
-   k_ref.Mult(x,y_ref);
-   k_test.Mult(x,y_test);
+   k_ref.Mult(x, y_ref);
+   k_test.Mult(x, y_test);
 
    y_test -= y_ref;
 
-   REQUIRE(y_test.Norml2() < 1.e-12);
+   REQUIRE(y_test.Norml2() < 1.e-12 * std::max(y_ref.Norml2(), 1.0));
+
+   if (mesh.Nonconforming())
+   {
+      k_ref.ConformingAssemble();
+   }
+   k_ref.AssembleDiagonal(d_ref);
+   k_test.AssembleDiagonal(d_test);
+
+   d_test -= d_ref;
+
+   // // TODO: Debug
+   // if (mesh.Nonconforming() &&
+   //    d_test.Norml2() > 0.1 * d_ref.Norml2())
+   // {
+   //    out << "\nDIAGONAL ASSEMBLY DELTA\n\n";
+   //    d_test.Print();
+   //    out << "\nDIAGONAL ASSEMBLY REF\n\n";
+   //    d_ref.Print();
+   //    // Vector temp(d_test);
+   //    // temp += d_ref;
+   //    // out << "\nDIAGONAL ASSEMBLY TEST\n\n";
+   //    // temp.Print();
+   // }
+
+   REQUIRE(d_test.Norml2() <
+           (mesh.Nonconforming() ? 1.0 : 1.e-12) * std::max(d_ref.Norml2(), 1.0));
    delete gf;
    delete coeff_fes;
    delete coeff;
    delete vcoeff;
+   delete mcoeff;
 }
 
-void test_mixed_p_ceed_operator(const char* input, int order,
-                                const CeedCoeffType coeff_type, const Problem pb,
-                                const AssemblyLevel assembly)
+void test_ceed_vectorfe_operator(const char *input, int order,
+                                 const CeedCoeffType coeff_type, const Problem pb,
+                                 const AssemblyLevel assembly, bool bdr_integ)
 {
-   std::string section = "assembly: " + getString(assembly) + "\n" +
-                         "coeff_type: " + getString(coeff_type) + "\n" +
-                         "pb: " + getString(pb) + "\n" +
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "coeff_type: " + GetString(coeff_type) + "\n" +
+                         "pb: " + GetString(pb) + "\n" +
                          "order: " + std::to_string(order) + "\n" +
+                         (bdr_integ ? "bdr_integ: true\n" : "") +
                          "mesh: " + input;
    INFO(section);
    Mesh mesh(input, 1, 1);
    mesh.EnsureNodes();
-   mesh.EnsureNCMesh();
    int dim = mesh.Dimension();
-   MFEM_VERIFY(dim == 2, "p-adaptivity only supported in serial 2D.");
-   H1_FECollection fec(order, dim);
+   FiniteElementCollection *fec = nullptr;
+   if ((pb == Problem::HDivMass || pb == Problem::DivDiv) && bdr_integ)
+   {
+      // Boundary RT elements in 2D and 3D are actually L2
+      return;
+   }
+   if (pb == Problem::CurlCurl && dim - bdr_integ < 2)
+   {
+      // No 1D ND curl shape
+      return;
+   }
+   switch (pb)
+   {
+      case Problem::Mass:
+      case Problem::Diffusion:
+         fec = new H1_FECollection(order, dim);
+         break;
+      case Problem::HDivMass:
+      case Problem::DivDiv:
+         fec = new RT_FECollection(order-1, dim);
+         break;
+      case Problem::HCurlMass:
+      case Problem::CurlCurl:
+         fec = new ND_FECollection(order, dim);
+         break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
+   }
 
    // Coefficient Initialization
    GridFunction *gf = nullptr;
    FiniteElementSpace *coeff_fes = nullptr;
    Coefficient *coeff = nullptr;
    VectorCoefficient *vcoeff = nullptr;
-   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff);
+   MatrixCoefficient *mcoeff = nullptr;
+   InitCoeff(mesh, *fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff, mcoeff);
+   if (!coeff && (pb == Problem::Mass || pb == Problem::DivDiv ||
+                  (pb == Problem::CurlCurl && dim - bdr_integ < 3)))
+   {
+      delete gf;
+      delete coeff_fes;
+      delete coeff;
+      delete vcoeff;
+      delete mcoeff;
+      delete fec;
+      return;
+   }
 
    // Build the BilinearForm
-   bool vecOp = pb == Problem::VectorMass || pb == Problem::VectorDiffusion;
-   const int vdim = vecOp ? dim : 1;
-   FiniteElementSpace fes(&mesh, &fec, vdim);
-   fes.SetElementOrder(0, order+1);
-   fes.SetElementOrder(fes.GetNE() - 1, order+1);
-   fes.Update(false);
+   FiniteElementSpace fes(&mesh, fec);
 
-   BilinearForm k_test(&fes);
    BilinearForm k_ref(&fes);
+   BilinearForm k_test(&fes);
+   auto AddIntegrator = [&bdr_integ](BilinearForm &k, BilinearFormIntegrator *blfi)
+   {
+      if (bdr_integ)
+      {
+         k.AddBoundaryIntegrator(blfi);
+      }
+      else
+      {
+         k.AddDomainIntegrator(blfi);
+      }
+   };
    switch (pb)
    {
       case Problem::Mass:
-         k_ref.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new MassIntegrator(*coeff));
-         break;
-      case Problem::Convection:
-         k_ref.AddDomainIntegrator(new ConvectionIntegrator(*vcoeff,-1));
-         k_test.AddDomainIntegrator(new ConvectionIntegrator(*vcoeff,-1));
+         AddIntegrator(k_ref, new MassIntegrator(*coeff));
+         AddIntegrator(k_test, new MassIntegrator(*coeff));
          break;
       case Problem::Diffusion:
-         k_ref.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
+         if (coeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator(*coeff));
+            AddIntegrator(k_test, new DiffusionIntegrator(*coeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator(*vcoeff));
+            AddIntegrator(k_test, new DiffusionIntegrator(*vcoeff));
+         }
+         else if (mcoeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator(*mcoeff));
+            AddIntegrator(k_test, new DiffusionIntegrator(*mcoeff));
+         }
          break;
-      case Problem::VectorMass:
-         k_ref.AddDomainIntegrator(new VectorMassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new VectorMassIntegrator(*coeff));
+      case Problem::HDivMass:
+      case Problem::HCurlMass:
+         if (coeff)
+         {
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*coeff));
+            AddIntegrator(k_test, new VectorFEMassIntegrator(*coeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*vcoeff));
+            AddIntegrator(k_test, new VectorFEMassIntegrator(*vcoeff));
+         }
+         else if (mcoeff)
+         {
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*mcoeff));
+            AddIntegrator(k_test, new VectorFEMassIntegrator(*mcoeff));
+         }
          break;
-      case Problem::VectorDiffusion:
-         k_ref.AddDomainIntegrator(new VectorDiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new VectorDiffusionIntegrator(*coeff));
+      case Problem::DivDiv:
+         AddIntegrator(k_ref, new DivDivIntegrator(*coeff));
+         AddIntegrator(k_test, new DivDivIntegrator(*coeff));
          break;
-      case Problem::MassDiffusion:
-         k_ref.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_ref.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
+      case Problem::CurlCurl:
+         if (coeff)
+         {
+            AddIntegrator(k_ref, new CurlCurlIntegrator(*coeff));
+            AddIntegrator(k_test, new CurlCurlIntegrator(*coeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new CurlCurlIntegrator(*vcoeff));
+            AddIntegrator(k_test, new CurlCurlIntegrator(*vcoeff));
+         }
+         else if (mcoeff)
+         {
+            AddIntegrator(k_ref, new CurlCurlIntegrator(*mcoeff));
+            AddIntegrator(k_test, new CurlCurlIntegrator(*mcoeff));
+         }
          break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
    }
 
+   // Timer for profiling
+   const int trials = 1;
+   const bool debug = false;
+   StopWatch chrono_setup_ref, chrono_setup_test;
+   StopWatch chrono_apply_ref, chrono_apply_test;
+   chrono_setup_ref.Clear();
+   chrono_setup_ref.Start();
+
    k_ref.Assemble();
    k_ref.Finalize();
 
+   chrono_setup_ref.Stop();
+   chrono_setup_test.Clear();
+   chrono_setup_test.Start();
+
    k_test.SetAssemblyLevel(assembly);
    k_test.Assemble();
 
-   // Compare ceed with mfem.
+   chrono_setup_test.Stop();
+
+   // Compare ceed with mfem
    GridFunction x(&fes), y_ref(&fes), y_test(&fes);
+   Vector d_ref(fes.GetTrueVSize()), d_test(fes.GetTrueVSize());
 
    x.Randomize(1);
 
-   k_ref.Mult(x,y_ref);
-   k_test.Mult(x,y_test);
+   chrono_apply_ref.Clear();
+   chrono_apply_ref.Start();
+
+   for (int trial = 0; trial < trials; trial++)
+   {
+      k_ref.Mult(x, y_ref);
+   }
+
+   chrono_apply_ref.Stop();
+   chrono_apply_test.Clear();
+   chrono_apply_test.Start();
+
+   for (int trial = 0; trial < trials; trial++)
+   {
+      k_test.Mult(x, y_test);
+   }
+
+   chrono_apply_test.Stop();
 
    y_test -= y_ref;
 
-   REQUIRE(y_test.Norml2() < 1.e-12);
+   REQUIRE(y_test.Norml2() < 1.e-12 * std::max(y_ref.Norml2(), 1.0));
+
+   if (mesh.Nonconforming())
+   {
+      k_ref.ConformingAssemble();
+   }
+   k_ref.AssembleDiagonal(d_ref);
+   k_test.AssembleDiagonal(d_test);
+
+   d_test -= d_ref;
+
+   // // TODO: Debug
+   // if (!UsesTensorBasis(fes) && order > 1 &&
+   //     (pb == Problem::HCurlMass || pb == Problem::CurlCurl) &&
+   //    d_test.Norml2() > 0.1 * d_ref.Norml2())
+   // {
+   //    out << "\nH(CURL) DIAGONAL ASSEMBLY DELTA\n\n";
+   //    d_test.Print();
+   //    out << "\nH(CURL) DIAGONAL ASSEMBLY REF\n\n";
+   //    d_ref.Print();
+   //    // Vector temp(d_test);
+   //    // temp += d_ref;
+   //    // out << "\nH(CURL) DIAGONAL ASSEMBLY TEST\n\n";
+   //    // temp.Print();
+   // }
+
+   REQUIRE(d_test.Norml2() <
+           (mesh.Nonconforming() ||
+            (!UsesTensorBasis(fes) && order > 1 &&
+             (pb == Problem::HCurlMass || pb == Problem::CurlCurl)) ?
+            1.0 : 1.e-12) * std::max(d_ref.Norml2(), 1.0));
+
+   if (debug)
+   {
+      // Estimates only for !bdr_integ, non-mixed meshes
+      std::size_t mem_test = 0;
+      if (!bdr_integ && mesh.GetNumGeometries(dim) == 1)
+      {
+         const FiniteElement &fe = *fes.GetFE(0);
+         ElementTransformation &T = *mesh.GetElementTransformation(0);
+         const int Q = (*k_ref.GetDBFI())[0]->GetRule(fe, T).GetNPoints();
+         const int P = fe.GetDof();
+         switch (pb)
+         {
+            case Problem::Mass:
+               mem_test = Q * 1 * 8;
+               mem_test += P * 4;
+            case Problem::Diffusion:
+               mem_test = Q * (dim * (dim + 1)) / 2 * 8;
+               mem_test += P * 4;
+               break;
+            case Problem::HDivMass:
+               mem_test = Q * (dim * (dim + 1)) / 2 * 8;
+               mem_test += P * 4;
+            case Problem::DivDiv:
+               mem_test = Q * 1 * 8;
+               mem_test += P * 4;
+               break;
+            case Problem::HCurlMass:
+               mem_test = Q * (dim * (dim + 1)) / 2 * 8;
+               mem_test += P * 3 * 4;  // Tri-diagonal curl orientations
+            case Problem::CurlCurl:
+               mem_test = Q * (dim - bdr_integ < 3 ? 1 : dim * (dim + 1) / 2) * 8;
+               mem_test += P * 3 * 4;
+               break;
+            default:
+               MFEM_ABORT("Unexpected problem type.");
+         }
+         mem_test *= mesh.GetNE();  // Estimate for QFunction memory
+      }
+      std::size_t mem_ref = k_ref.SpMat().NumNonZeroElems() * (8 + 4) +
+                            k_ref.Height() * 4;
+
+      out << "\n" << section << "\n";
+      out << "benchmark (" << fes.GetTrueVSize() << " unknowns)\n"
+          << "    setup: ref = "
+          << chrono_setup_ref.RealTime() * 1e3 << " ms\n"
+          << "           test = "
+          << chrono_setup_test.RealTime() * 1e3 << " ms\n"
+          << "    apply: ref = "
+          << chrono_apply_ref.RealTime() * 1e3 / trials << " ms\n"
+          << "           test = "
+          << chrono_apply_test.RealTime() * 1e3 / trials << " ms\n"
+          << "    mem usage: ref = " << mem_ref / 1e6 << " MB\n"
+          << "               test = " << mem_test / 1e6 << " MB\n";
+   }
    delete gf;
    delete coeff_fes;
    delete coeff;
    delete vcoeff;
+   delete mcoeff;
+   delete fec;
 }
 
-void test_ceed_nloperator(const char* mesh_filename, int order,
+void test_ceed_mixed_operator(const char *input, int order,
+                              const CeedCoeffType coeff_type, const Problem pb,
+                              const AssemblyLevel assembly, bool bdr_integ)
+{
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "coeff_type: " + GetString(coeff_type) + "\n" +
+                         "pb: " + GetString(pb) + "\n" +
+                         "order: " + std::to_string(order) + "\n" +
+                         (bdr_integ ? "bdr_integ: true\n" : "") +
+                         "mesh: " + input;
+   INFO(section);
+   Mesh mesh(input, 1, 1);
+   mesh.EnsureNodes();
+   int dim = mesh.Dimension();
+   FiniteElementCollection *trial_fec = nullptr, *test_fec = nullptr;
+   if (pb == Problem::MixedVectorGradient && dim - bdr_integ < 2)
+   {
+      // MixedVectorGradient is only supported in 2D or 3D
+      return;
+   }
+   if (pb == Problem::MixedVectorCurl && dim - bdr_integ < 3)
+   {
+      // MixedVectorCurl is only supported in 3D
+      return;
+   }
+   switch (pb)
+   {
+      case Problem::MixedVectorGradient:
+         trial_fec = new H1_FECollection(order, dim);
+         test_fec = new ND_FECollection(order, dim);
+         break;
+      case Problem::MixedVectorCurl:
+         trial_fec = new ND_FECollection(order, dim);
+         test_fec = new RT_FECollection(order - 1, dim);
+         break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
+   }
+
+   // Coefficient Initialization
+   GridFunction *gf = nullptr;
+   FiniteElementSpace *coeff_fes = nullptr;
+   Coefficient *coeff = nullptr;
+   VectorCoefficient *vcoeff = nullptr;
+   MatrixCoefficient *mcoeff = nullptr;
+   InitCoeff(mesh, *trial_fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff,
+             mcoeff);
+
+   // Build the BilinearForm
+   FiniteElementSpace trial_fes(&mesh, trial_fec);
+   FiniteElementSpace test_fes(&mesh, test_fec);
+
+   MixedBilinearForm k_ref(&trial_fes, &test_fes);
+   MixedBilinearForm k_test(&trial_fes, &test_fes);
+   MixedBilinearForm k_test_t(&test_fes, &trial_fes);
+   auto AddIntegrator = [&bdr_integ](MixedBilinearForm &k,
+                                     BilinearFormIntegrator *blfi)
+   {
+      if (bdr_integ)
+      {
+         k.AddBoundaryIntegrator(blfi);
+      }
+      else
+      {
+         k.AddDomainIntegrator(blfi);
+      }
+   };
+   switch (pb)
+   {
+      case Problem::MixedVectorGradient:
+         if (coeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorGradientIntegrator(*coeff));
+            AddIntegrator(k_test, new MixedVectorGradientIntegrator(*coeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakDivergenceIntegrator(*coeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorGradientIntegrator(*vcoeff));
+            AddIntegrator(k_test, new MixedVectorGradientIntegrator(*vcoeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakDivergenceIntegrator(*vcoeff));
+         }
+         else if (mcoeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorGradientIntegrator(*mcoeff));
+            AddIntegrator(k_test, new MixedVectorGradientIntegrator(*mcoeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakDivergenceIntegrator(*mcoeff));
+         }
+         break;
+      case Problem::MixedVectorCurl:
+         if (coeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorCurlIntegrator(*coeff));
+            AddIntegrator(k_test, new MixedVectorCurlIntegrator(*coeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakCurlIntegrator(*coeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorCurlIntegrator(*vcoeff));
+            AddIntegrator(k_test, new MixedVectorCurlIntegrator(*vcoeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakCurlIntegrator(*vcoeff));
+         }
+         else if (mcoeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorCurlIntegrator(*mcoeff));
+            AddIntegrator(k_test, new MixedVectorCurlIntegrator(*mcoeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakCurlIntegrator(*mcoeff));
+         }
+         break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
+   }
+
+   k_ref.Assemble();
+   k_ref.Finalize();
+
+   k_test.SetAssemblyLevel(assembly);
+   k_test.Assemble();
+
+   k_test_t.SetAssemblyLevel(assembly);
+   k_test_t.Assemble();
+
+   // Compare ceed with mfem
+   GridFunction x(&trial_fes), y_ref(&test_fes), y_test(&test_fes);
+   GridFunction x_t(&test_fes), y_t_ref(&trial_fes), y_t_test(&trial_fes);
+
+   x.Randomize(1);
+
+   k_ref.Mult(x, y_ref);
+   k_test.Mult(x, y_test);
+
+   y_test -= y_ref;
+
+   REQUIRE(y_test.Norml2() < 1.e-12 * std::max(y_ref.Norml2(), 1.0));
+
+   x_t.Randomize(1);
+
+   k_ref.MultTranspose(x_t, y_t_ref);
+   k_test_t.Mult(x_t, y_t_test);
+
+   y_t_test.Add((pb == Problem::MixedVectorCurl) ? -1.0 : 1.0, y_t_ref);
+
+   REQUIRE(y_t_test.Norml2() < 1.e-12 * std::max(y_t_ref.Norml2(), 1.0));
+   delete gf;
+   delete coeff_fes;
+   delete coeff;
+   delete vcoeff;
+   delete mcoeff;
+   delete trial_fec;
+   delete test_fec;
+}
+
+void test_ceed_nloperator(const char *input, int order,
                           const CeedCoeffType coeff_type,
                           const NLProblem pb, const AssemblyLevel assembly)
 {
-   std::string section = "assembly: " + getString(assembly) + "\n" +
-                         "coeff_type: " + getString(coeff_type) + "\n" +
-                         "pb: " + getString(pb) + "\n" +
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "coeff_type: " + GetString(coeff_type) + "\n" +
+                         "pb: " + GetString(pb) + "\n" +
                          "order: " + std::to_string(order) + "\n" +
-                         "mesh: " + mesh_filename;
+                         "mesh: " + input;
    INFO(section);
-   Mesh mesh(mesh_filename, 1, 1);
+   Mesh mesh(input, 1, 1);
    mesh.EnsureNodes();
    int dim = mesh.Dimension();
    H1_FECollection fec(order, dim);
@@ -418,15 +886,18 @@ void test_ceed_nloperator(const char* mesh_filename, int order,
    FiniteElementSpace *coeff_fes = nullptr;
    Coefficient *coeff = nullptr;
    VectorCoefficient *vcoeff = nullptr;
-   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff);
+   MatrixCoefficient *mcoeff = nullptr;
+   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff, mcoeff);
+   MFEM_VERIFY(!vcoeff && !mcoeff,
+               "Unexpected vector- or matrix-valued coefficient in test_ceed_nloperator.");
 
    // Build the NonlinearForm
    bool vecOp = pb == NLProblem::Convection;
    const int vdim = vecOp ? dim : 1;
    FiniteElementSpace fes(&mesh, &fec, vdim);
 
-   NonlinearForm k_test(&fes);
    NonlinearForm k_ref(&fes);
+   NonlinearForm k_test(&fes);
    switch (pb)
    {
       case NLProblem::Convection:
@@ -435,42 +906,48 @@ void test_ceed_nloperator(const char* mesh_filename, int order,
          break;
    }
 
+   k_ref.Setup();
    k_test.SetAssemblyLevel(assembly);
    k_test.Setup();
-   k_ref.Setup();
 
-   // Compare ceed with mfem.
+   // Compare ceed with mfem
    GridFunction x(&fes), y_ref(&fes), y_test(&fes);
 
    x.Randomize(1);
 
-   k_ref.Mult(x,y_ref);
-   k_test.Mult(x,y_test);
+   k_ref.Mult(x, y_ref);
+   k_test.Mult(x, y_test);
 
    y_test -= y_ref;
 
-   REQUIRE(y_test.Norml2() < 1.e-12);
+   REQUIRE(y_test.Norml2() < 1.e-12 * std::max(y_ref.Norml2(), 1.0));
    delete gf;
    delete coeff_fes;
    delete coeff;
    delete vcoeff;
+   delete mcoeff;
 }
 
 // This function specifically tests convection of a vector valued quantity and
 // using a custom integration rule. The integration rule is chosen s.t. in
 // combination with an appropriate order, it can represent the analytical
 // polynomial functions correctly.
-void test_ceed_convection(const char* mesh_filename, int order,
+void test_ceed_convection(const char *input, int order,
                           const AssemblyLevel assembly)
 {
-   Mesh mesh(mesh_filename, 1, 1);
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "order: " + std::to_string(order) + "\n" +
+                         "mesh: " + input;
+   INFO(section);
+   Mesh mesh(input, 1, 1);
    mesh.EnsureNodes();
    int dim = mesh.Dimension();
    H1_FECollection fec(order, dim);
 
    VectorFunctionCoefficient velocity_coeff(dim, velocity_function);
 
-   FiniteElementSpace fes(&mesh, &fec, dim);
+   FiniteElementSpace fes(&mesh, &fec, 1);
+   FiniteElementSpace vfes(&mesh, &fec, dim);
    BilinearForm conv_op(&fes);
 
    IntegrationRules rules(0, Quadrature1D::GaussLobatto);
@@ -483,7 +960,7 @@ void test_ceed_convection(const char* mesh_filename, int order,
    conv_op.SetAssemblyLevel(assembly);
    conv_op.Assemble();
 
-   GridFunction q(&fes), r(&fes), ex(&fes);
+   GridFunction q(&vfes), r(&vfes), ex(&vfes);
 
    VectorFunctionCoefficient quantity_coeff(dim, quantity);
    q.ProjectCoefficient(quantity_coeff);
@@ -492,9 +969,15 @@ void test_ceed_convection(const char* mesh_filename, int order,
    ex.ProjectCoefficient(convected_quantity_coeff);
 
    r = 0.0;
-   conv_op.Mult(q, r);
+   for (int i = 0; i < dim; i++)
+   {
+      GridFunction qi, ri;
+      qi.MakeRef(&fes, q, i * fes.GetVSize());
+      ri.MakeRef(&fes, r, i * fes.GetVSize());
+      conv_op.Mult(qi, ri);
+   }
 
-   LinearForm f(&fes);
+   LinearForm f(&vfes);
    VectorDomainLFIntegrator *vlf_integ = new VectorDomainLFIntegrator(
       convected_quantity_coeff);
    vlf_integ->SetIntRule(&ir);
@@ -503,7 +986,360 @@ void test_ceed_convection(const char* mesh_filename, int order,
 
    r -= f;
 
-   REQUIRE(r.Norml2() < 1e-12);
+   REQUIRE(r.Norml2() < 1.e-12 * std::max(f.Norml2(), 1.0));
+}
+
+void test_ceed_full_assembly(const char *input, int order,
+                             const AssemblyLevel assembly)
+{
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "order: " + std::to_string(order) + "\n" +
+                         "mesh: " + input;
+   INFO(section);
+   Mesh mesh(input, 1, 1);
+   mesh.EnsureNodes();
+   int dim = mesh.Dimension();
+   H1_FECollection fec(order, dim);
+
+   DenseMatrix val(dim);
+   val = 0.0;
+   for (int i = 0; i < dim; i++)
+   {
+      val(i, i) = 1.0 + i;
+   }
+   MatrixConstantCoefficient diff_coeff(val);
+   ConstantCoefficient mass_coeff(1.0);
+
+   FiniteElementSpace fes(&mesh, &fec, 1);
+   BilinearForm k_test(&fes);
+   BilinearForm k_ref(&fes);
+
+   k_ref.AddDomainIntegrator(new MassIntegrator(mass_coeff));
+   k_test.AddDomainIntegrator(new MassIntegrator(mass_coeff));
+   k_ref.AddBoundaryIntegrator(new MassIntegrator(mass_coeff));
+   k_test.AddBoundaryIntegrator(new MassIntegrator(mass_coeff));
+   k_ref.AddDomainIntegrator(new DiffusionIntegrator(diff_coeff));
+   k_test.AddDomainIntegrator(new DiffusionIntegrator(diff_coeff));
+
+   k_ref.Assemble();
+   k_ref.Finalize();
+
+   k_test.SetAssemblyLevel(assembly);
+   k_test.Assemble();
+
+   SparseMatrix *mat_ref = &k_ref.SpMat();
+   SparseMatrix *mat_test = ceed::CeedOperatorFullAssemble(k_test);
+   SparseMatrix *mat_diff = Add(1.0, *mat_ref, -1.0, *mat_test);
+
+   REQUIRE(mat_diff->MaxNorm() < 1.e-12 * std::max(mat_ref->MaxNorm(), 1.0));
+   delete mat_diff;
+   delete mat_test;
+}
+
+void test_ceed_linear_interpolator(const char *input, int order)
+{
+   std::string section = "order: " + std::to_string(order) + "\n" +
+                         "mesh: " + input;
+   INFO(section);
+   Mesh mesh(input, 1, 1);
+   mesh.EnsureNodes();
+   int dim = mesh.Dimension();
+   H1_FECollection h1_fec(order, dim);
+   ND_FECollection nd_fec(order, dim);
+   RT_FECollection rt_fec(order - 1, dim);
+
+   // Build the DiscreteLinearOperator
+   FiniteElementSpace h1_fes(&mesh, &h1_fec);
+   FiniteElementSpace nd_fes(&mesh, &nd_fec);
+   FiniteElementSpace rt_fes(&mesh, &rt_fec);
+
+   // Discrete gradient
+   DiscreteLinearOperator grad_ref(&h1_fes, &nd_fes);
+   DiscreteLinearOperator grad_test(&h1_fes, &nd_fes);
+   grad_ref.AddDomainInterpolator(new GradientInterpolator);
+   grad_test.AddDomainInterpolator(new GradientInterpolator);
+
+   // Timer for profiling
+   const int trials = 1;
+   const bool debug = false;
+   StopWatch chrono_setup_grad_ref, chrono_setup_grad_test;
+   StopWatch chrono_apply_grad_ref, chrono_apply_grad_test;
+   StopWatch chrono_apply_id_ref, chrono_apply_id_test;
+   chrono_setup_grad_ref.Clear();
+   chrono_setup_grad_ref.Start();
+
+   grad_ref.Assemble();
+   grad_ref.Finalize();
+
+   chrono_setup_grad_ref.Stop();
+   chrono_setup_grad_test.Clear();
+   chrono_setup_grad_test.Start();
+
+   grad_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   grad_test.Assemble();
+
+   chrono_setup_grad_test.Stop();
+
+   // Compare ceed with mfem
+   {
+      GridFunction x(&h1_fes), y_ref(&nd_fes), y_test(&nd_fes);
+      GridFunction x_t(&nd_fes), y_t_ref(&h1_fes), y_t_test(&h1_fes);
+
+      x.Randomize(1);
+
+      chrono_apply_grad_ref.Clear();
+      chrono_apply_grad_ref.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         grad_ref.Mult(x, y_ref);
+      }
+
+      chrono_apply_grad_ref.Stop();
+      chrono_apply_grad_test.Clear();
+      chrono_apply_grad_test.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         grad_test.Mult(x, y_test);
+      }
+
+      chrono_apply_grad_test.Stop();
+
+      y_test -= y_ref;
+
+      REQUIRE(y_test.Norml2() < 1.e-12);
+
+      x_t.Randomize(1);
+
+      chrono_apply_grad_ref.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         grad_ref.MultTranspose(x_t, y_t_ref);
+      }
+
+      chrono_apply_grad_ref.Stop();
+      chrono_apply_grad_test.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         grad_test.MultTranspose(x_t, y_t_test);
+      }
+
+      chrono_apply_grad_test.Stop();
+
+      y_t_test -= y_t_ref;
+
+      REQUIRE(y_t_test.Norml2() < 1.e-12);
+   }
+
+   // Discrete curl
+   if (dim == 3)
+   {
+      DiscreteLinearOperator curl_ref(&nd_fes, &rt_fes);
+      DiscreteLinearOperator curl_test(&nd_fes, &rt_fes);
+      curl_ref.AddDomainInterpolator(new CurlInterpolator);
+      curl_test.AddDomainInterpolator(new CurlInterpolator);
+
+      curl_ref.Assemble();
+      curl_ref.Finalize();
+
+      curl_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+      curl_test.Assemble();
+
+      // Compare ceed with mfem
+      {
+         GridFunction x(&nd_fes), y_ref(&rt_fes), y_test(&rt_fes);
+         GridFunction x_t(&rt_fes), y_t_ref(&nd_fes), y_t_test(&nd_fes);
+
+         x.Randomize(1);
+
+         curl_ref.Mult(x, y_ref);
+         curl_test.Mult(x, y_test);
+
+         y_test -= y_ref;
+
+         REQUIRE(y_test.Norml2() < 1.e-10);
+
+         x_t.Randomize(1);
+
+         curl_ref.MultTranspose(x_t, y_t_ref);
+         curl_test.MultTranspose(x_t, y_t_test);
+
+         y_t_test -= y_t_ref;
+
+         REQUIRE(y_t_test.Norml2() < 1.e-10);
+      }
+   }
+
+   // Prolongation and restriction
+   H1_FECollection fine_h1_fec(order + 1, dim);
+   ND_FECollection fine_nd_fec(order + 1, dim);
+   RT_FECollection fine_rt_fec(order, dim);
+
+   FiniteElementSpace fine_h1_fes(&mesh, &fine_h1_fec);
+   FiniteElementSpace fine_nd_fes(&mesh, &fine_nd_fec);
+   FiniteElementSpace fine_rt_fes(&mesh, &fine_rt_fec);
+
+   DiscreteLinearOperator id_h1_test(&h1_fes, &fine_h1_fes);
+   DiscreteLinearOperator id_nd_test(&nd_fes, &fine_nd_fes);
+   DiscreteLinearOperator id_rt_test(&rt_fes, &fine_rt_fes);
+   id_h1_test.AddDomainInterpolator(new IdentityInterpolator);
+   id_nd_test.AddDomainInterpolator(new IdentityInterpolator);
+   id_rt_test.AddDomainInterpolator(new IdentityInterpolator);
+
+   id_h1_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   id_h1_test.Assemble();
+
+   id_nd_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   id_nd_test.Assemble();
+
+   id_rt_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   id_rt_test.Assemble();
+
+   TransferOperator id_h1_ref(h1_fes, fine_h1_fes);
+   TransferOperator id_nd_ref(nd_fes, fine_nd_fes);
+   TransferOperator id_rt_ref(rt_fes, fine_rt_fes);
+
+   // Compare ceed with mfem
+   for (int t = 0; t < 3; t++)
+   {
+      GridFunction *x = nullptr, *y_t_ref = nullptr, *y_t_test = nullptr;
+      GridFunction *y_exact = nullptr, *y_ref = nullptr, *y_test = nullptr;
+      switch (t)
+      {
+         case 0:
+            x = new GridFunction(&h1_fes);
+            y_t_ref = new GridFunction(&h1_fes);
+            y_t_test = new GridFunction(&h1_fes);
+            y_exact = new GridFunction(&fine_h1_fes);
+            y_ref = new GridFunction(&fine_h1_fes);
+            y_test = new GridFunction(&fine_h1_fes);
+            break;
+         case 1:
+            x = new GridFunction(&nd_fes);
+            y_t_ref = new GridFunction(&nd_fes);
+            y_t_test = new GridFunction(&nd_fes);
+            y_exact = new GridFunction(&fine_nd_fes);
+            y_ref = new GridFunction(&fine_nd_fes);
+            y_test = new GridFunction(&fine_nd_fes);
+            break;
+         case 2:
+            x = new GridFunction(&rt_fes);
+            y_t_ref = new GridFunction(&rt_fes);
+            y_t_test = new GridFunction(&rt_fes);
+            y_exact = new GridFunction(&fine_rt_fes);
+            y_ref = new GridFunction(&fine_rt_fes);
+            y_test = new GridFunction(&fine_rt_fes);
+            break;
+         default:
+            MFEM_ABORT("Unexpected problem type.");
+      }
+
+      if (t == 0)
+      {
+         FunctionCoefficient f_coeff(coeff_function);
+         x->ProjectCoefficient(f_coeff);
+         y_exact->ProjectCoefficient(f_coeff);
+      }
+      else
+      {
+         VectorFunctionCoefficient vf_coeff(dim, velocity_function);
+         x->ProjectCoefficient(vf_coeff);
+         y_exact->ProjectCoefficient(vf_coeff);
+      }
+
+      chrono_apply_id_ref.Clear();
+      chrono_apply_id_ref.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         switch (t)
+         {
+            case 0:
+               id_h1_ref.Mult(*x, *y_ref);
+               id_h1_ref.MultTranspose(*y_exact, *y_t_ref);
+               break;
+            case 1:
+               id_nd_ref.Mult(*x, *y_ref);
+               id_nd_ref.MultTranspose(*y_exact, *y_t_ref);
+               break;
+            case 2:
+               id_rt_ref.Mult(*x, *y_ref);
+               id_rt_ref.MultTranspose(*y_exact, *y_t_ref);
+               break;
+            default:
+               MFEM_ABORT("Unexpected problem type.");
+         }
+      }
+
+      chrono_apply_id_ref.Stop();
+      chrono_apply_id_test.Clear();
+      chrono_apply_id_test.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         switch (t)
+         {
+            case 0:
+               id_h1_test.Mult(*x, *y_test);
+               id_h1_test.MultTranspose(*y_exact, *y_t_test);
+               break;
+            case 1:
+               id_nd_test.Mult(*x, *y_test);
+               id_nd_test.MultTranspose(*y_exact, *y_t_test);
+               break;
+            case 2:
+               id_rt_test.Mult(*x, *y_test);
+               id_rt_test.MultTranspose(*y_exact, *y_t_test);
+               break;
+            default:
+               MFEM_ABORT("Unexpected problem type.");
+         }
+      }
+
+      chrono_apply_id_test.Stop();
+
+      *y_test -= *y_ref;
+
+      REQUIRE(y_test->Norml2() < 1.e-10);
+
+      *y_t_test -= *y_t_ref;
+
+      REQUIRE(y_t_test->Norml2() < 1.e-10);
+      delete x;
+      delete y_t_ref;
+      delete y_t_test;
+      delete y_exact;
+      delete y_ref;
+      delete y_test;
+   }
+
+   if (debug)
+   {
+      out << "\n" << section << "\n";
+      out << "benchmark (unknowns: H1: " << h1_fes.GetTrueVSize()
+          << ", ND: " << nd_fes.GetTrueVSize()
+          << ", RT: " << rt_fes.GetTrueVSize() << ",\n"
+          << "                     fine H1: " << fine_h1_fes.GetTrueVSize()
+          << ", fine ND: " << fine_nd_fes.GetTrueVSize()
+          << ", fine RT: " << fine_rt_fes.GetTrueVSize() << ")\n"
+          << "    discrete gradient interpolator\n"
+          << "    setup: ref = "
+          << chrono_setup_grad_ref.RealTime() * 1e3 << " ms\n"
+          << "           test = "
+          << chrono_setup_grad_test.RealTime() * 1e3 << " ms\n"
+          << "    apply: ref = "
+          << chrono_apply_grad_ref.RealTime() * 1e3 / trials << " ms\n"
+          << "           test = "
+          << chrono_apply_grad_test.RealTime() * 1e3 / trials << " ms\n"
+          << "    identity interpolator\n"
+          << "    apply: ref = "
+          << chrono_apply_id_ref.RealTime() * 1e3 / trials << " ms\n"
+          << "           test = "
+          << chrono_apply_id_test.RealTime() * 1e3 / trials << " ms\n";
+   }
 }
 
 TEST_CASE("CEED mass & diffusion", "[CEED]")
@@ -513,17 +1349,20 @@ TEST_CASE("CEED mass & diffusion", "[CEED]")
                               CeedCoeffType::Quad);
    auto pb = GENERATE(Problem::Mass,Problem::Diffusion,Problem::MassDiffusion,
                       Problem::VectorMass,Problem::VectorDiffusion);
-   auto order = GENERATE(1);
+   auto order = GENERATE(1,2);
+   auto bdr_integ = GENERATE(false,true);
    auto mesh = GENERATE("../../data/inline-quad.mesh",
                         "../../data/inline-hex.mesh",
-                        "../../data/periodic-square.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
                         "../../data/star-q2.mesh",
                         "../../data/fichera-q2.mesh",
                         "../../data/amr-quad.mesh",
                         "../../data/fichera-amr.mesh",
                         "../../data/square-mixed.mesh",
                         "../../data/fichera-mixed.mesh");
-   test_ceed_operator(mesh, order, coeff_type, pb, assembly);
+   bool mixed_p = false;
+   test_ceed_operator(mesh, order, coeff_type, pb, assembly, mixed_p, bdr_integ);
 } // test case
 
 TEST_CASE("CEED p-adaptivity", "[CEED]")
@@ -539,46 +1378,99 @@ TEST_CASE("CEED p-adaptivity", "[CEED]")
                         "../../data/star-q2.mesh",
                         "../../data/amr-quad.mesh",
                         "../../data/square-mixed.mesh");
-   test_mixed_p_ceed_operator(mesh, order, coeff_type, pb, assembly);
+   bool mixed_p = true;
+   bool bdr_integ = false;
+   test_ceed_operator(mesh, order, coeff_type, pb, assembly, mixed_p, bdr_integ);
 } // test case
 
-TEST_CASE("CEED convection low", "[CEED],[Convection]")
+TEST_CASE("CEED vector and matrix coefficients and vector FE operators",
+          "[CEED], [VectorFE]")
 {
    auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
-   auto coeff_type = GENERATE(CeedCoeffType::VecConst,CeedCoeffType::VecGrid,
-                              CeedCoeffType::VecQuad);
+   auto coeff_type = GENERATE(CeedCoeffType::Const,CeedCoeffType::Quad,
+                              CeedCoeffType::VecConst,CeedCoeffType::VecQuad,
+                              CeedCoeffType::MatConst,CeedCoeffType::MatQuad);
+   auto pb = GENERATE(Problem::Mass,Problem::Diffusion,
+                      Problem::HDivMass,Problem::DivDiv,
+                      Problem::HCurlMass,Problem::CurlCurl);
+   auto order = GENERATE(1,3);
+   auto bdr_integ = GENERATE(false,true);
    auto mesh = GENERATE("../../data/inline-quad.mesh",
                         "../../data/inline-hex.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
                         "../../data/star-q2.mesh",
                         "../../data/fichera-q2.mesh",
                         "../../data/amr-quad.mesh",
                         "../../data/fichera-amr.mesh",
                         "../../data/square-mixed.mesh",
                         "../../data/fichera-mixed.mesh");
-   Problem pb = Problem::Convection;
+   test_ceed_vectorfe_operator(mesh, order, coeff_type, pb, assembly, bdr_integ);
+} // test case
 
-   // Test that the CEED and MFEM integrators give the same answer
-   int low_order = 1;
-   test_ceed_operator(mesh, low_order, coeff_type, pb, assembly);
+TEST_CASE("CEED mixed integrators",
+          "[CEED], [MixedVectorIntegrator], [VectorFE]")
+{
+   auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
+   auto coeff_type = GENERATE(CeedCoeffType::Const,CeedCoeffType::Quad,
+                              CeedCoeffType::VecConst,CeedCoeffType::VecQuad,
+                              CeedCoeffType::MatConst,CeedCoeffType::MatQuad);
+   auto pb = GENERATE(Problem::MixedVectorGradient,Problem::MixedVectorCurl);
+   auto order = GENERATE(2);
+   auto bdr_integ = GENERATE(false,true);
+   auto mesh = GENERATE("../../data/inline-quad.mesh",
+                        "../../data/inline-hex.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
+                        "../../data/star-q2.mesh",
+                        "../../data/fichera-q2.mesh",
+                        "../../data/amr-quad.mesh",
+                        "../../data/fichera-amr.mesh",
+                        "../../data/square-mixed.mesh",
+                        "../../data/fichera-mixed.mesh");
+   test_ceed_mixed_operator(mesh, order, coeff_type, pb, assembly, bdr_integ);
 } // test case
 
-TEST_CASE("CEED convection high", "[CEED],[Convection]")
+TEST_CASE("CEED convection low", "[CEED], [Convection]")
 {
    auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
+   auto coeff_type = GENERATE(CeedCoeffType::VecConst,CeedCoeffType::VecGrid,
+                              CeedCoeffType::VecQuad);
    auto mesh = GENERATE("../../data/inline-quad.mesh",
                         "../../data/inline-hex.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
+                        "../../data/periodic-square.mesh",
                         "../../data/star-q2.mesh",
                         "../../data/fichera-q2.mesh",
                         "../../data/amr-quad.mesh",
-                        "../../data/fichera-amr.mesh");
+                        "../../data/fichera-amr.mesh",
+                        "../../data/square-mixed.mesh",
+                        "../../data/fichera-mixed.mesh");
+   Problem pb = Problem::Convection;
+   int low_order = 1;
+   bool mixed_p = false;
+   bool bdr_integ = false;
+   test_ceed_operator(mesh, low_order, coeff_type, pb, assembly, mixed_p,
+                      bdr_integ);
+} // test case
 
+TEST_CASE("CEED convection high", "[CEED], [Convection]")
+{
    // Apply the CEED convection integrator applied to a vector quantity, check
    // that we get the exact answer (with sufficiently high polynomial degree)
+   auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
+   auto mesh = GENERATE("../../data/inline-quad.mesh",
+                        "../../data/periodic-square.mesh",
+                        "../../data/star-q2.mesh",
+                        "../../data/fichera-q2.mesh",
+                        "../../data/amr-quad.mesh",
+                        "../../data/fichera-amr.mesh");
    int high_order = 4;
    test_ceed_convection(mesh, high_order, assembly);
 } // test case
 
-TEST_CASE("CEED non-linear convection", "[CEED],[NLConvection]")
+TEST_CASE("CEED nonlinear convection", "[CEED], [NLConvection]")
 {
    auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
    auto coeff_type = GENERATE(CeedCoeffType::Const,CeedCoeffType::Grid,
@@ -587,6 +1479,8 @@ TEST_CASE("CEED non-linear convection", "[CEED],[NLConvection]")
    auto order = GENERATE(1);
    auto mesh = GENERATE("../../data/inline-quad.mesh",
                         "../../data/inline-hex.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
                         "../../data/periodic-square.mesh",
                         "../../data/star-q2.mesh",
                         "../../data/fichera.mesh",
@@ -595,6 +1489,35 @@ TEST_CASE("CEED non-linear convection", "[CEED],[NLConvection]")
    test_ceed_nloperator(mesh, order, coeff_type, pb, assembly);
 } // test case
 
+TEST_CASE("CEED full assembly", "[CEED]")
+{
+   auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
+   auto mesh = GENERATE("../../data/inline-quad.mesh",
+                        "../../data/inline-hex.mesh",
+                        "../../data/star-q2.mesh",
+                        "../../data/fichera-q2.mesh",
+                        "../../data/amr-quad.mesh",
+                        "../../data/fichera-amr.mesh",
+                        "../../data/square-mixed.mesh",
+                        "../../data/fichera-mixed.mesh");
+   int order = 1;
+   test_ceed_full_assembly(mesh, order, assembly);
+} // test case
+
+TEST_CASE("CEED linear interpolators", "[CEED]")
+{
+   auto mesh = GENERATE("../../data/inline-quad.mesh",
+                        "../../data/inline-hex.mesh",
+                        "../../data/star-q2.mesh",
+                        "../../data/fichera-q2.mesh",
+                        "../../data/amr-quad.mesh",
+                        "../../data/fichera-amr.mesh",
+                        "../../data/square-mixed.mesh",
+                        "../../data/fichera-mixed.mesh");
+   int order = 2;
+   test_ceed_linear_interpolator(mesh, order);
+} // test case
+
 #endif
 
 } // namespace ceed_test
diff --git a/tests/unit/enzyme/compatibility.cpp b/tests/unit/enzyme/compatibility.cpp
index 8cbb658d1..118f11b12 100644
--- a/tests/unit/enzyme/compatibility.cpp
+++ b/tests/unit/enzyme/compatibility.cpp
@@ -8,38 +8,40 @@
 template<typename VectorT>
 void square(const VectorT& v, double& y)
 {
-  for (int i = 0; i < 4; i++) {
-    y += v[i]*v[i];
-  }
+   for (int i = 0; i < 4; i++)
+   {
+      y += v[i]*v[i];
+   }
 }
 
 template<typename VectorT>
 void dsquare(const VectorT& v, double& y, VectorT& dydv)
 {
-  double seed = 1.0;
-  __enzyme_autodiff<void>(square<VectorT>, &v, &dydv, &y, &seed);
+   double seed = 1.0;
+   __enzyme_autodiff<void>(square<VectorT>, &v, &dydv, &y, &seed);
 }
 
 template<typename VectorT>
-void run_test() {
-  VectorT v(4);
-  v[0] = 2.0;
-  v[1] = 3.0;
-  v[2] = 1.0;
-  v[3] = 7.0;
-
-  double yy = 0;
-  VectorT dydv(4);
-  dydv[0] = 0;
-  dydv[1] = 0;
-  dydv[2] = 0;
-  dydv[3] = 0;
-  dsquare(v, yy, dydv);
-
-  REQUIRE(dydv[0] == MFEM_Approx(4.0));
-  REQUIRE(dydv[1] == MFEM_Approx(6.0));
-  REQUIRE(dydv[2] == MFEM_Approx(2.0));
-  REQUIRE(dydv[3] == MFEM_Approx(14.0));
+void run_test()
+{
+   VectorT v(4);
+   v[0] = 2.0;
+   v[1] = 3.0;
+   v[2] = 1.0;
+   v[3] = 7.0;
+
+   double yy = 0;
+   VectorT dydv(4);
+   dydv[0] = 0;
+   dydv[1] = 0;
+   dydv[2] = 0;
+   dydv[3] = 0;
+   dsquare(v, yy, dydv);
+
+   REQUIRE(dydv[0] == MFEM_Approx(4.0));
+   REQUIRE(dydv[1] == MFEM_Approx(6.0));
+   REQUIRE(dydv[2] == MFEM_Approx(2.0));
+   REQUIRE(dydv[3] == MFEM_Approx(14.0));
 }
 
 TEST_CASE("AD Vector implementation", "[Enzyme]")
diff --git a/tests/unit/fem/test_assemblediagonalpa.cpp b/tests/unit/fem/test_assemblediagonalpa.cpp
index 050561e1d..42cdc76ba 100644
--- a/tests/unit/fem/test_assemblediagonalpa.cpp
+++ b/tests/unit/fem/test_assemblediagonalpa.cpp
@@ -447,8 +447,8 @@ TEST_CASE("Hcurl/Hdiv diagonal PA",
                      else
                      {
                         const FiniteElement *fel = fespace.GetFE(0);
-                        const IntegrationRule *intRule = &MassIntegrator::GetRule(*fel, *fel,
-                                                                                  *mesh.GetElementTransformation(0));
+                        ElementTransformation *T = mesh.GetElementTransformation(0);
+                        const IntegrationRule *intRule = &MassIntegrator::GetRuleStatic(*fel, *fel, *T);
 
                         if (spaceType == Hcurl)
                         {
diff --git a/tests/unit/fem/test_pa_coeff.cpp b/tests/unit/fem/test_pa_coeff.cpp
index b45738fad..270359f3c 100644
--- a/tests/unit/fem/test_pa_coeff.cpp
+++ b/tests/unit/fem/test_pa_coeff.cpp
@@ -530,8 +530,8 @@ TEST_CASE("Hcurl/Hdiv PA Coefficient",
                         if (spaceType == Hcurl)
                         {
                            const FiniteElement *fel = fespace.GetFE(0);
-                           const IntegrationRule *intRule = &MassIntegrator::GetRule(*fel, *fel,
-                                                                                     *mesh.GetElementTransformation(0));
+                           ElementTransformation *T = mesh.GetElementTransformation(0);
+                           const IntegrationRule *intRule = &MassIntegrator::GetRuleStatic(*fel, *fel, *T);
 
                            if (coeffType >= 3 && dimension == 3)
                            {
