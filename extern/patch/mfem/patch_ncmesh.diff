diff --git a/.gitignore b/.gitignore
index 03bab0fb3..caab4dc8c 100644
--- a/.gitignore
+++ b/.gitignore
@@ -265,11 +265,14 @@ miniapps/navier/*_output
 miniapps/nurbs/nurbs_ex1
 miniapps/nurbs/nurbs_ex1p
 miniapps/nurbs/nurbs_ex11p
+miniapps/nurbs/nurbs_curveint
 miniapps/nurbs/refined.mesh
 miniapps/nurbs/mesh.*
 miniapps/nurbs/sol.*
 miniapps/nurbs/mode_*
 miniapps/nurbs/Example1*
+miniapps/nurbs/sin-fit.mesh
+miniapps/nurbs/CurveInt
 
 miniapps/performance/ex1
 miniapps/performance/ex1p
diff --git a/CHANGELOG b/CHANGELOG
index 20fcac0f6..f523784d7 100644
--- a/CHANGELOG
+++ b/CHANGELOG
@@ -10,6 +10,7 @@
 
 Version 4.5.3 (development)
 ===========================
+- Added curve interpolation method for NURBS.
 
 New and updated examples and miniapps
 -------------------------------------
@@ -32,6 +33,8 @@ New and updated examples and miniapps
 - Added new SubMesh examples demonstrating source terms and boundary conditions
   transferred from SubMesh objects.
 
+- Added a miniapp for interpolation of NURBS.
+
 - Added a new H(div) solvers miniapp in miniapps/hdiv-linear-solver,
   demonstrating the use of a matrix-free saddle-point solver methodology,
   suitable for high-order discretizations and for GPU acceleration. Examples
@@ -65,6 +68,12 @@ Discretization improvements
 
 - Added support for p-refined meshes in FindPointsGSLIB.
 
+- Introduced support for higher order non conformal Nedelec elements on
+  simplices in ParMesh.
+
+- Introduced support for internal boundary elements in nonconformal adapted
+  meshes.
+
 Linear and nonlinear solvers
 ----------------------------
 - Updated interface to MUMPS direct solver to support multiple right-hand
diff --git a/config/docker/Dockerfile b/config/docker/Dockerfile
index 7ac48c629..30c9fe49f 100644
--- a/config/docker/Dockerfile
+++ b/config/docker/Dockerfile
@@ -19,9 +19,7 @@ RUN apt-get update && \
     apt-get install -y libcurl4-openssl-dev libssl-dev
 
 ENV PATH=$PATH:/opt/mfem-view/bin
-ENV LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/opt/mfem-view/lib:/opt/mfem-view/lib64
 ENV DEBIAN_FRONTEND=noninteractive
 
 # The user will see the view on shell into the container
 WORKDIR /opt/mfem-view
-ENTRYPOINT ["/bin/bash"]
diff --git a/config/docker/Dockerfile.base b/config/docker/Dockerfile.base
index 9dc8b2c13..3f11c92d5 100644
--- a/config/docker/Dockerfile.base
+++ b/config/docker/Dockerfile.base
@@ -34,14 +34,14 @@ RUN cd /opt/mfem-env && \
     . /opt/spack/share/spack/setup-env.sh && \
     spack env activate . && \
     spack develop --path /code mfem@master+examples+miniapps && \
-    spack add mfem@master+examples+miniapps # && \
-#    spack install
+    spack add mfem@master+examples+miniapps && \
+    spack install
 
 # ensure mfem always on various paths
-#RUN cd /opt/mfem-env && \
-#    spack env activate --sh -d . >> /etc/profile.d/z10_spack_environment.sh
+RUN cd /opt/mfem-env && \
+    spack env activate --sh -d . >> /etc/profile.d/z10_spack_environment.sh
 
 # Present the software install when we shell in
 # The view is at /opt/mfem-env/.spack-env/view
-#WORKDIR /opt/software
-#ENTRYPOINT ["/bin/bash", "--rcfile", "/etc/profile", "-l", "-c"]
+WORKDIR /opt/software
+ENTRYPOINT ["/bin/bash", "--rcfile", "/etc/profile", "-l", "-c"]
diff --git a/config/docker/README.md b/config/docker/README.md
index f41cf3dbf..3cc941b39 100644
--- a/config/docker/README.md
+++ b/config/docker/README.md
@@ -7,21 +7,31 @@ You can use this image for a demo of using mfem! ðŸŽ‰ï¸
 Updated containers are built and deployed on merges to the main branch and releases.
 If you want to request a build on demand, you can [manually run the workflow](https://docs.github.com/en/actions/managing-workflow-runs/manually-running-a-workflow) thanks to the workflow dispatch event.
 
-### Usage
+## Usage
 
-Here is how to build the container. Note that we build so it belongs to the same
-namespace as the repository here. "ghcr.io" means "GitHub Container Registry" and
+We provide two containers, which you can either build or use directly from
+[GitHub packages](https://github.com/orgs/mfem/packages?repo_name=mfem).
+
+ - `ghcr.io/mfem/mfem-ubuntu-base`: a "build from scratch" for mfem
+ - `ghcr.io/mfem/mfem-ubuntu`: a quick build that uses the base container
+
+In the above, "ghcr.io" means "GitHub Container Registry" and
 is the [GitHub packages](https://github.com/features/packages) registry that supports
- Docker images and other OCI artifacts. From the root of the repository:
+Docker images and other OCI artifacts. 
+
+### Ubuntu
+
+> Use or build this container for a multi-stage, slimmer base to develop on top of mfem
+
+Note that this container is provided on GitHub packages [here](https://github.com/mfem/mfem/pkgs/container/mfem-ubuntu)
+so you don't need to build it. However, if you want to, you can do the following:
 
 ```bash
 $ docker build -f config/docker/Dockerfile -t ghcr.io/mfem/mfem-ubuntu .
-$ docker build -f config/docker/Dockerfile.base -t ghcr.io/mfem/mfem-ubuntu-base .
 ```
 
-### Shell Ubuntu
-
-To shell into the container:
+Note that this will pull the base image. If you want to rebuild it, see [ubuntu base](#ubuntu-base)
+below. Once you have built (or prefer to pull) you can shell into the container as follows:
 
 ```bash
 $ docker run -it ghcr.io/mfem/mfem-ubuntu
@@ -37,48 +47,32 @@ bin  etc  include  lib  libexec  sbin  share  var
  - Examples are in share/mfem/examples
  - Examples are in share/mfem/miniapps
 
-You can read more about interaction with these examples and miniapps below.
-
-### Shell Ubuntu Base
-
-To shell into the container:
+Using this container, if you want to develop a tool that _uses_ mfem, you can find the libraries / includes in:
 
 ```bash
-$ docker run -it ghcr.io/mfem/mfem-ubuntu-base bash
+$ ls include/ | grep mfem
+mfem
+mfem-performance.hpp
+mfem.hpp
 ```
 
-Off the bat, you can see mfem libraries are in your path so you can jump into development:
+And yes, this is the working directory when you shell into the container!
+You can find the examples here:
+
 
 ```bash
-env | grep mfem
-```
-```bash
-PKG_CONFIG_PATH=/opt/mfem-env/.spack-env/view/lib/pkgconfig:/opt/mfem-env/.spack-env/view/share/pkgconfig:/opt/mfem-env/.spack-env/view/lib64/pkgconfig
-PWD=/opt/mfem-env
-MANPATH=/opt/mfem-env/.spack-env/view/share/man:/opt/mfem-env/.spack-env/view/man:
-CMAKE_PREFIX_PATH=/opt/mfem-env/.spack-env/view
-SPACK_ENV=/opt/mfem-env
-ACLOCAL_PATH=/opt/mfem-env/.spack-env/view/share/aclocal
-LD_LIBRARY_PATH=/opt/mfem-env/.spack-env/view/lib:/opt/mfem-env/.spack-env/view/lib64
-PATH=/opt/mfem-env/.spack-env/view/bin:/opt/view/bin:/opt/spack/bin:/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
+cd share/mfem/examples
 ```
 
-#### Examples and MiniApps
-
-If you want to develop a tool that _uses_ mfem, you can find the built libraries in:
+Try quickly setting the `LD_LIBRARY_PATH` so we can see the shared libraries
+we need:
 
+```bash
+export LD_LIBRARY_PATH=/opt/mfem-view/lib:$LD_LIBRARY_PATH
 ```
-$ ls /opt/mfem-env/.spack-env/view/
-bin  etc  include  lib  libexec  sbin  share  var
-```
-
-And yes, this is the working directory when you shell into the container!
-You can find the examples here:
 
+And then run:
 
-```bash
-cd share/mfem/examples
-```
 ```bash
 $ ./ex0
 Options used:
@@ -97,7 +91,6 @@ Number of unknowns: 101
 Average reduction factor = 0.140201
 ```
 
-Try running a few, and look at the associated .cpp file for the source code!
 You can also explore the "mini apps," also in share/mfem, but under miniapps.
 
 ```bash
@@ -130,18 +123,87 @@ Rule:
 Applying rule...done.
 ```
 
-Have fun!
+Have fun! As a reminder, this container is ideal for developing your own
+applications that might use mfem, or having a nice environment to test out
+examples.
+
+
+### Ubuntu Base
+
+> Use this build for a development environment with spack and mfem
+
+This container is also [provided on GitHub packages](https://github.com/mfem/mfem/pkgs/container/mfem-ubuntu-base), 
+however you can build it locally too:
+
+```bash
+$ docker build -f config/docker/Dockerfile.base -t ghcr.io/mfem/mfem-ubuntu-base .
+```
+
+To shell into the container:
+
+```bash
+$ docker run -it ghcr.io/mfem/mfem-ubuntu-base bash
+```
+
+Change directory to the mfem environment, setup spack, and activate the environment:
 
+```bash
+source /opt/spack/share/spack/setup-env.sh
+cd /opt/mfem-env/
+spack env activate .
+```
+
+Note that this environment is installing to the view at `/opt/view`. Since the environment
+knows to install mfem from `/code` this means that you could make changes in the container (or bind
+`/code` to your container) and then update spack:
+
+```bash
+# Note that concretization takes a hot minute!
+$ spack install
+```
+
+And if you want to load mfem:
+
+```bash
+$ spack load mfem
+$ env | grep mfem
+```
+
+In this development container, you can find the examples and miniapps alongside
+mfem under `/code`:
+
+```bash
+cd /code/examples
+```
+```bash
+$ ./ex0
+```
+```console
+Options used:
+   --mesh ../data/star.mesh
+   --order 1
+Number of unknowns: 101
+   Iteration :   0  (B r, r) = 0.184259
+   Iteration :   1  (B r, r) = 0.102754
+   Iteration :   2  (B r, r) = 0.00558141
+   Iteration :   3  (B r, r) = 1.5247e-05
+   Iteration :   4  (B r, r) = 1.13807e-07
+   Iteration :   5  (B r, r) = 6.27231e-09
+   Iteration :   6  (B r, r) = 3.76268e-11
+   Iteration :   7  (B r, r) = 6.07423e-13
+   Iteration :   8  (B r, r) = 4.10615e-15
+Average reduction factor = 0.140201
+```
 
-#### Your own App
-If you want to develop with your own code base
-(and mfem as is in the container) you can bind to somewhere else in the container (e.g., src)
+This container is likely ideal for someone that wants to develop mfem itself.
+For other use cases, we recommend using the slimmer image. As an example,
+if you want to develop with your own code base (and mfem as is in the container) 
+you can bind to somewhere else in the container (e.g., src)
 
 ```bash
-$ docker run -it ghcr.io/mfem/mfem-ubuntu-base -v $PWD:/src bash
+$ docker run -it ghcr.io/mfem/mfem-ubuntu-base -v $PWD:/code bash
 ```
 
 In the above, we can pretend your project is in the present working directory (PWD) and we are
 binding to source. You can then use the mfem in the container for development, and if you
 want to distribute your library or app in a container, you can use the mfem container as the base.
-
diff --git a/data/p1_prism.msh b/data/p1_prism.msh
new file mode 100644
index 000000000..b05d1470c
--- /dev/null
+++ b/data/p1_prism.msh
@@ -0,0 +1,53 @@
+$MeshFormat
+2.2 0 8
+$EndMeshFormat
+$PhysicalNames
+2
+2 2 "boundaries"
+3 1 "cylinder"
+$EndPhysicalNames
+$Nodes
+15
+1 2.74 0 0
+2 2.74 0 5.48
+3 -7.133049998451843e-15 2.74 0
+4 -2.74 -3.31486008200114e-15 0
+5 4.363887905507124e-15 -2.74 0
+6 2.74 0 2.74
+7 -7.133049998451843e-15 2.74 5.48
+8 -2.74 -3.31486008200114e-15 5.48
+9 4.363887905507124e-15 -2.74 5.48
+10 -5.920473312798202e-16 -4.967313603494313e-16 0
+11 -7.133049998451843e-15 2.74 2.74
+12 -2.74 -3.31486008200114e-15 2.74
+13 4.363887905507124e-15 -2.74 2.74
+14 -5.920473312798202e-16 -4.967313603494313e-16 5.48
+15 -5.920473312798202e-16 -4.967313603494313e-16 2.74
+$EndNodes
+$Elements
+24
+1 2 2 2 1 3 10 1
+2 2 2 2 1 5 10 4
+3 2 2 2 1 4 10 3
+4 2 2 2 1 1 10 5
+5 2 2 2 3 7 14 2
+6 2 2 2 3 9 14 8
+7 2 2 2 3 8 14 7
+8 2 2 2 3 2 14 9
+9 3 2 2 2 1 3 11 6
+10 3 2 2 2 6 11 7 2
+11 3 2 2 2 3 4 12 11
+12 3 2 2 2 11 12 8 7
+13 3 2 2 2 4 5 13 12
+14 3 2 2 2 12 13 9 8
+15 3 2 2 2 5 1 6 13
+16 3 2 2 2 13 6 2 9
+17 6 2 1 1 1 3 10 6 11 15
+18 6 2 1 1 6 11 15 2 7 14
+19 6 2 1 1 4 5 10 12 13 15
+20 6 2 1 1 12 13 15 8 9 14
+21 6 2 1 1 3 4 10 11 12 15
+22 6 2 1 1 11 12 15 7 8 14
+23 6 2 1 1 5 1 10 13 6 15
+24 6 2 1 1 13 6 15 9 2 14
+$EndElements
diff --git a/data/p2_prism.msh b/data/p2_prism.msh
new file mode 100644
index 000000000..0cb3f66d6
--- /dev/null
+++ b/data/p2_prism.msh
@@ -0,0 +1,103 @@
+$MeshFormat
+2.2 0 8
+$EndMeshFormat
+$PhysicalNames
+2
+2 2 "boundaries"
+3 1 "cylinder"
+$EndPhysicalNames
+$Nodes
+65
+1 2.74 0 0
+2 2.74 0 5.48
+3 -7.133049998451843e-15 2.74 0
+4 -2.74 -3.31486008200114e-15 0
+5 4.363887905507124e-15 -2.74 0
+6 1.937472580451138 1.937472580451143 0
+7 -1.937472580451143 1.937472580451137 0
+8 -1.937472580451138 -1.937472580451143 0
+9 1.937472580451142 -1.937472580451139 0
+10 2.74 0 2.74
+11 2.74 0 1.37
+12 2.74 0 4.11
+13 -7.133049998451843e-15 2.74 5.48
+14 -2.74 -3.31486008200114e-15 5.48
+15 4.363887905507124e-15 -2.74 5.48
+16 1.937472580451138 1.937472580451143 5.48
+17 -1.937472580451143 1.937472580451137 5.48
+18 -1.937472580451138 -1.937472580451143 5.48
+19 1.937472580451142 -1.937472580451139 5.48
+20 -5.920473312798202e-16 -4.967313603494313e-16 0
+21 -3.862548664865832e-15 1.37 0
+22 1.37 -2.483656801747156e-16 0
+23 1.885920287113652e-15 -1.37 0
+24 -1.370000000000001 -1.905795721175286e-15 0
+25 -7.133049998451843e-15 2.74 2.74
+26 -2.74 -3.31486008200114e-15 2.74
+27 4.363887905507124e-15 -2.74 2.74
+28 1.677766114831874e-16 2.74 1.37
+29 1.937472580451138 1.937472580451143 2.74
+30 1.937472580451141 1.937472580451143 1.37
+31 1.677766114831874e-16 2.74 4.11
+32 1.937472580451141 1.937472580451143 4.11
+33 -2.74 3.355532229663748e-16 1.37
+34 -1.937472580451143 1.937472580451137 2.74
+35 -1.93747258045114 1.937472580451139 1.37
+36 -2.74 3.355532229663748e-16 4.11
+37 -1.93747258045114 1.937472580451139 4.11
+38 -5.033298344495622e-16 -2.74 1.37
+39 -1.937472580451138 -1.937472580451143 2.74
+40 -1.937472580451141 -1.937472580451141 1.37
+41 -5.033298344495622e-16 -2.74 4.11
+42 -1.937472580451141 -1.937472580451141 4.11
+43 1.937472580451142 -1.937472580451139 2.74
+44 1.937472580451139 -1.937472580451139 1.37
+45 1.937472580451139 -1.937472580451139 4.11
+46 -5.920473312798202e-16 -4.967313603494313e-16 5.48
+47 -3.862548664865832e-15 1.37 5.48
+48 1.37 -2.483656801747157e-16 5.48
+49 1.885920287113652e-15 -1.37 5.48
+50 -1.370000000000001 -1.905795721175286e-15 5.48
+51 -5.920473312798202e-16 -4.967313603494313e-16 2.74
+52 -5.920473312798202e-16 -4.967313603494313e-16 1.37
+53 1.37 -2.483656801747157e-16 2.74
+54 -3.862548664865832e-15 1.37 2.74
+55 1.37 -2.483656801747157e-16 1.37
+56 -2.121353598983164e-16 1.37 1.37
+57 -5.920473312798202e-16 -4.967313603494313e-16 4.11
+58 1.37 -2.483656801747157e-16 4.11
+59 -2.121353598983164e-16 1.37 4.11
+60 -1.37 -1.905795721175286e-15 2.74
+61 1.885920287113652e-15 -1.37 2.74
+62 -1.37 -8.058906869152782e-17 1.37
+63 -5.476885828646913e-16 -1.37 1.37
+64 -1.37 -8.058906869152802e-17 4.11
+65 -5.476885828646913e-16 -1.37 4.11
+$EndNodes
+$Elements
+24
+1 9 2 2 1 3 20 1 21 22 6
+2 9 2 2 1 5 20 4 23 24 8
+3 9 2 2 1 4 20 3 24 21 7
+4 9 2 2 1 1 20 5 22 23 9
+5 9 2 2 3 13 46 2 47 48 16
+6 9 2 2 3 15 46 14 49 50 18
+7 9 2 2 3 14 46 13 50 47 17
+8 9 2 2 3 2 46 15 48 49 19
+9 10 2 2 2 1 3 25 10 6 28 29 11 30
+10 10 2 2 2 10 25 13 2 29 31 16 12 32
+11 10 2 2 2 3 4 26 25 7 33 34 28 35
+12 10 2 2 2 25 26 14 13 34 36 17 31 37
+13 10 2 2 2 4 5 27 26 8 38 39 33 40
+14 10 2 2 2 26 27 15 14 39 41 18 36 42
+15 10 2 2 2 5 1 10 27 9 11 43 38 44
+16 10 2 2 2 27 10 2 15 43 12 19 41 45
+17 13 2 1 1 1 3 20 10 25 51 6 22 11 21 28 52 29 53 54 30 55 56
+18 13 2 1 1 10 25 51 2 13 46 29 53 12 54 31 57 16 48 47 32 58 59
+19 13 2 1 1 4 5 20 26 27 51 8 24 33 23 38 52 39 60 61 40 62 63
+20 13 2 1 1 26 27 51 14 15 46 39 60 36 61 41 57 18 50 49 42 64 65
+21 13 2 1 1 3 4 20 25 26 51 7 21 28 24 33 52 34 54 60 35 56 62
+22 13 2 1 1 25 26 51 13 14 46 34 54 31 60 36 57 17 47 50 37 59 64
+23 13 2 1 1 5 1 20 27 10 51 9 23 38 22 11 52 43 61 53 44 63 55
+24 13 2 1 1 27 10 51 15 2 46 43 61 41 53 12 57 19 49 48 45 65 58
+$EndElements
diff --git a/examples/ex0.cpp b/examples/ex0.cpp
index e11b59860..f9ab4f606 100644
--- a/examples/ex0.cpp
+++ b/examples/ex0.cpp
@@ -22,7 +22,7 @@ using namespace mfem;
 int main(int argc, char *argv[])
 {
    // 1. Parse command line options.
-   const char *mesh_file = "../data/star.mesh";
+   string mesh_file = "../data/star.mesh";
    int order = 1;
 
    OptionsParser args(argc, argv);
diff --git a/examples/ex0p.cpp b/examples/ex0p.cpp
index 9ef0d8642..e3b577d9d 100644
--- a/examples/ex0p.cpp
+++ b/examples/ex0p.cpp
@@ -26,7 +26,7 @@ int main(int argc, char *argv[])
    Hypre::Init();
 
    // 2. Parse command line options.
-   const char *mesh_file = "../data/star.mesh";
+   string mesh_file = "../data/star.mesh";
    int order = 1;
 
    OptionsParser args(argc, argv);
diff --git a/examples/ex13p.cpp b/examples/ex13p.cpp
index da3a7cdba..af3cbc696 100644
--- a/examples/ex13p.cpp
+++ b/examples/ex13p.cpp
@@ -54,6 +54,7 @@ int main(int argc, char *argv[])
    int par_ref_levels = 1;
    int order = 1;
    int nev = 5;
+   bool nc = false;
    bool visualization = 1;
    const char *device_config = "cpu";
 
@@ -69,6 +70,9 @@ int main(int argc, char *argv[])
                   " isoparametric space.");
    args.AddOption(&nev, "-n", "--num-eigs",
                   "Number of desired eigenmodes.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-c",
+                  "--conforming",
+                  "Mark the mesh as nonconforming before partitioning.");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
                   "--no-visualization",
                   "Enable or disable GLVis visualization.");
@@ -107,6 +111,11 @@ int main(int argc, char *argv[])
       mesh->UniformRefinement();
    }
 
+   if (nc)
+   {
+      mesh->EnsureNCMesh(true);
+   }
+
    // 6. Define a parallel mesh by a partitioning of the serial mesh. Refine
    //    this mesh further in parallel to increase the resolution (1 time by
    //    default, or specified on the command line with -rp). Once the parallel
diff --git a/examples/ex3.cpp b/examples/ex3.cpp
index edbfdac7d..d36ec62bf 100644
--- a/examples/ex3.cpp
+++ b/examples/ex3.cpp
@@ -63,6 +63,7 @@ int main(int argc, char *argv[])
    int order = 1;
    bool static_cond = false;
    bool pa = false;
+   bool nc = false;
    const char *device_config = "cpu";
    bool visualization = 1;
 
@@ -77,6 +78,8 @@ int main(int argc, char *argv[])
                   "--no-static-condensation", "Enable static condensation.");
    args.AddOption(&pa, "-pa", "--partial-assembly", "-no-pa",
                   "--no-partial-assembly", "Enable Partial Assembly.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-no-nc",
+                  "--no-non-conforming", "Enable Nonconforming Refinement.");
    args.AddOption(&device_config, "-d", "--device",
                   "Device configuration string, see Device::Configure().");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
@@ -103,19 +106,26 @@ int main(int argc, char *argv[])
    dim = mesh->Dimension();
    int sdim = mesh->SpaceDimension();
 
+
    // 4. Refine the mesh to increase the resolution. In this example we do
    //    'ref_levels' of uniform refinement. We choose 'ref_levels' to be the
    //    largest number that gives a final mesh with no more than 50,000
    //    elements.
+
+   if (nc)
+   {
+      // Can set to false to use conformal refinement for simplices.
+      mesh->EnsureNCMesh(true);
+   }
+   mesh->UniformRefinement();
    {
       int ref_levels =
-         (int)floor(log(50000./mesh->GetNE())/log(2.)/dim);
+         (int)floor(log(1000./mesh->GetNE())/log(2.)/dim);
       for (int l = 0; l < ref_levels; l++)
       {
          mesh->UniformRefinement();
       }
    }
-
    // 5. Define a finite element space on the mesh. Here we use the Nedelec
    //    finite elements of the specified order.
    FiniteElementCollection *fec = new ND_FECollection(order, dim);
diff --git a/examples/ex3p.cpp b/examples/ex3p.cpp
index e24c52809..285fcc8e8 100644
--- a/examples/ex3p.cpp
+++ b/examples/ex3p.cpp
@@ -70,6 +70,7 @@ int main(int argc, char *argv[])
    int order = 1;
    bool static_cond = false;
    bool pa = false;
+   bool nc = false;
    const char *device_config = "cpu";
    bool visualization = true;
 #ifdef MFEM_USE_AMGX
@@ -87,6 +88,8 @@ int main(int argc, char *argv[])
                   "--no-static-condensation", "Enable static condensation.");
    args.AddOption(&pa, "-pa", "--partial-assembly", "-no-pa",
                   "--no-partial-assembly", "Enable Partial Assembly.");
+   args.AddOption(&nc, "-nc", "--non-conforming", "-no-nc",
+                  "--no-non-conforming", "Enable Nonconforming Refinement.");
    args.AddOption(&device_config, "-d", "--device",
                   "Device configuration string, see Device::Configure().");
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
@@ -129,6 +132,12 @@ int main(int argc, char *argv[])
    //    this example we do 'ref_levels' of uniform refinement. We choose
    //    'ref_levels' to be the largest number that gives a final mesh with no
    //    more than 1,000 elements.
+   if (nc)
+   {
+      // Can set to false to use conformal refinement for simplices.
+      mesh->EnsureNCMesh(true);
+   }
+
    {
       int ref_levels = (int)floor(log(1000./mesh->GetNE())/log(2.)/dim);
       for (int l = 0; l < ref_levels; l++)
@@ -137,19 +146,20 @@ int main(int argc, char *argv[])
       }
    }
 
+
    // 6. Define a parallel mesh by a partitioning of the serial mesh. Refine
    //    this mesh further in parallel to increase the resolution. Once the
    //    parallel mesh is defined, the serial mesh can be deleted.
    ParMesh *pmesh = new ParMesh(MPI_COMM_WORLD, *mesh);
+
    delete mesh;
    {
-      int par_ref_levels = 2;
+      int par_ref_levels = 1;
       for (int l = 0; l < par_ref_levels; l++)
       {
          pmesh->UniformRefinement();
       }
    }
-
    // 7. Define a parallel finite element space on the parallel mesh. Here we
    //    use the Nedelec finite elements of the specified order.
    FiniteElementCollection *fec = new ND_FECollection(order, dim);
diff --git a/fem/eltrans.cpp b/fem/eltrans.cpp
index b0bf84145..7d36985de 100644
--- a/fem/eltrans.cpp
+++ b/fem/eltrans.cpp
@@ -488,6 +488,7 @@ int IsoparametricTransformation::OrderGrad(const FiniteElement *fe) const
 void IsoparametricTransformation::Transform (const IntegrationPoint &ip,
                                              Vector &trans)
 {
+   MFEM_ASSERT(FElem != nullptr, "!");
    shape.SetSize(FElem->GetDof());
    trans.SetSize(PointMat.Height());
 
diff --git a/fem/fe_coll.cpp b/fem/fe_coll.cpp
index 1be0c7368..483fb9b8f 100644
--- a/fem/fe_coll.cpp
+++ b/fem/fe_coll.cpp
@@ -1713,7 +1713,7 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
          H1_Elements[Geometry::SEGMENT] = new H1_SegmentElement(p, btype);
       }
 
-      SegDofOrd[0] = new int[2*pm1];
+      SegDofOrd[0] = (pm1 > 0) ? new int[2*pm1] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + pm1;
       for (int i = 0; i < pm1; i++)
       {
@@ -1751,7 +1751,7 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
 
       const int &TriDof = H1_dof[Geometry::TRIANGLE];
       const int &QuadDof = H1_dof[Geometry::SQUARE];
-      TriDofOrd[0] = new int[6*TriDof];
+      TriDofOrd[0] = (TriDof > 0) ? new int[6*TriDof] : nullptr;
       for (int i = 1; i < 6; i++)
       {
          TriDofOrd[i] = TriDofOrd[i-1] + TriDof;
@@ -1772,7 +1772,7 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
          }
       }
 
-      QuadDofOrd[0] = new int[8*QuadDof];
+      QuadDofOrd[0] = (QuadDof > 0) ? new int[8*QuadDof] : nullptr;
       for (int i = 1; i < 8; i++)
       {
          QuadDofOrd[i] = QuadDofOrd[i-1] + QuadDof;
@@ -1855,7 +1855,7 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
          H1_Elements[Geometry::PYRAMID] = new LinearPyramidFiniteElement;
 
          const int &TetDof = H1_dof[Geometry::TETRAHEDRON];
-         TetDofOrd[0] = new int[24*TetDof];
+         TetDofOrd[0] = (TetDof > 0) ? new int[24*TetDof] : nullptr;
          for (int i = 1; i < 24; i++)
          {
             TetDofOrd[i] = TetDofOrd[i-1] + TetDof;
@@ -2127,7 +2127,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
       // No need to set the map_type for Tr_Elements.
 
       const int pp1 = p + 1;
-      SegDofOrd[0] = new int[2*pp1];
+      SegDofOrd[0] = (pp1 > 0) ? new int[2*pp1] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + pp1;
       for (int i = 0; i <= p; i++)
       {
@@ -2160,7 +2160,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
       }
 
       const int TriDof = L2_Elements[Geometry::TRIANGLE]->GetDof();
-      TriDofOrd[0] = new int[6*TriDof];
+      TriDofOrd[0] = (TriDof > 0) ? new int[6*TriDof] : nullptr;
       for (int i = 1; i < 6; i++)
       {
          TriDofOrd[i] = TriDofOrd[i-1] + TriDof;
@@ -2181,7 +2181,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
          }
       }
       const int QuadDof = L2_Elements[Geometry::SQUARE]->GetDof();
-      OtherDofOrd = new int[QuadDof];
+      OtherDofOrd = (QuadDof > 0) ? new int[QuadDof] : nullptr;
       for (int j = 0; j < QuadDof; j++)
       {
          OtherDofOrd[j] = j; // for Or == 0
@@ -2225,7 +2225,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
       const int PriDof = L2_Elements[Geometry::PRISM]->GetDof();
       const int MaxDof = std::max(TetDof, std::max(PriDof, HexDof));
 
-      TetDofOrd[0] = new int[24*TetDof];
+      TetDofOrd[0] = (TetDof > 0) ? new int[24*TetDof] : nullptr;
       for (int i = 1; i < 24; i++)
       {
          TetDofOrd[i] = TetDofOrd[i-1] + TetDof;
@@ -2314,7 +2314,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
             }
          }
       }
-      OtherDofOrd = new int[MaxDof];
+      OtherDofOrd = (MaxDof > 0) ? new int[MaxDof] : nullptr;
       for (int j = 0; j < MaxDof; j++)
       {
          OtherDofOrd[j] = j; // for Or == 0
@@ -2502,7 +2502,7 @@ void RT_FECollection::InitFaces(const int p, const int dim_,
       RT_Elements[Geometry::SEGMENT] = l2_seg;
       RT_dof[Geometry::SEGMENT] = pp1;
 
-      SegDofOrd[0] = new int[2*pp1];
+      SegDofOrd[0] = (pp1 > 0) ? new int[2*pp1] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + pp1;
       for (int i = 0; i <= p; i++)
       {
@@ -2523,7 +2523,7 @@ void RT_FECollection::InitFaces(const int p, const int dim_,
       RT_dof[Geometry::SQUARE] = pp1*pp1;
 
       int TriDof = RT_dof[Geometry::TRIANGLE];
-      TriDofOrd[0] = new int[6*TriDof];
+      TriDofOrd[0] = (TriDof > 0) ? new int[6*TriDof] : nullptr;
       for (int i = 1; i < 6; i++)
       {
          TriDofOrd[i] = TriDofOrd[i-1] + TriDof;
@@ -2553,7 +2553,7 @@ void RT_FECollection::InitFaces(const int p, const int dim_,
       }
 
       int QuadDof = RT_dof[Geometry::SQUARE];
-      QuadDofOrd[0] = new int[8*QuadDof];
+      QuadDofOrd[0] = (QuadDof > 0) ? new int[8*QuadDof] : nullptr;
       for (int i = 1; i < 8; i++)
       {
          QuadDofOrd[i] = QuadDofOrd[i-1] + QuadDof;
@@ -2749,7 +2749,7 @@ ND_FECollection::ND_FECollection(const int p, const int dim,
       ND_Elements[Geometry::SEGMENT] = new ND_SegmentElement(p, ob_type);
       ND_dof[Geometry::SEGMENT] = p;
 
-      SegDofOrd[0] = new int[2*p];
+      SegDofOrd[0] = (p > 0) ? new int[2*p] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + p;
       for (int i = 0; i < p; i++)
       {
@@ -2769,7 +2769,7 @@ ND_FECollection::ND_FECollection(const int p, const int dim,
       ND_dof[Geometry::TRIANGLE] = p*pm1;
 
       int QuadDof = ND_dof[Geometry::SQUARE];
-      QuadDofOrd[0] = new int[8*QuadDof];
+      QuadDofOrd[0] = (QuadDof > 0) ? new int[8*QuadDof] : nullptr;
       for (int i = 1; i < 8; i++)
       {
          QuadDofOrd[i] = QuadDofOrd[i-1] + QuadDof;
@@ -2813,7 +2813,7 @@ ND_FECollection::ND_FECollection(const int p, const int dim,
       }
 
       int TriDof = ND_dof[Geometry::TRIANGLE];
-      TriDofOrd[0] = new int[6*TriDof];
+      TriDofOrd[0] = (TriDof > 0) ? new int[6*TriDof] : nullptr;
       for (int i = 1; i < 6; i++)
       {
          TriDofOrd[i] = TriDofOrd[i-1] + TriDof;
@@ -3163,7 +3163,7 @@ ND_R2D_FECollection::ND_R2D_FECollection(const int p, const int dim,
                                                                  ob_type);
       ND_dof[Geometry::SEGMENT] = 2 * p - 1;
 
-      SegDofOrd[0] = new int[4 * p - 2];
+      SegDofOrd[0] = (4*p > 2) ? new int[4 * p - 2] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + 2 * p - 1;
       for (int i = 0; i < p; i++)
       {
@@ -3347,7 +3347,7 @@ void RT_R2D_FECollection::InitFaces(const int p, const int dim,
       RT_Elements[Geometry::SEGMENT] = l2_seg;
       RT_dof[Geometry::SEGMENT] = pp1;
 
-      SegDofOrd[0] = new int[2*pp1];
+      SegDofOrd[0] = (pp1 > 0) ? new int[2*pp1] : nullptr;
       SegDofOrd[1] = SegDofOrd[0] + pp1;
       for (int i = 0; i <= p; i++)
       {
diff --git a/fem/fespace.cpp b/fem/fespace.cpp
index 68ca200e1..5342b6a75 100644
--- a/fem/fespace.cpp
+++ b/fem/fespace.cpp
@@ -492,13 +492,12 @@ void FiniteElementSpace::BuildDofToArrays()
    }
 }
 
-static void mark_dofs(const Array<int> &dofs, Array<int> &mark_array)
+void
+FiniteElementSpace::MarkDofs(const Array<int> &dofs, Array<int> &mark_array)
 {
-   for (int i = 0; i < dofs.Size(); i++)
+   for (auto d : dofs)
    {
-      int k = dofs[i];
-      if (k < 0) { k = -1 - k; }
-      mark_array[k] = -1;
+      mark_array[d >= 0 ? d : -1 - d] = -1;
    }
 }
 
@@ -506,7 +505,7 @@ void FiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
                                            Array<int> &ess_vdofs,
                                            int component) const
 {
-   Array<int> vdofs, dofs;
+   Array<int> dofs;
 
    ess_vdofs.SetSize(GetVSize());
    ess_vdofs = 0;
@@ -515,19 +514,49 @@ void FiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
    {
       if (bdr_attr_is_ess[GetBdrAttribute(i)-1])
       {
-         if (component < 0)
+         int ncface = -1;
+         if (Nonconforming())
+         {
+            // Need to take care on internal non-conforming "boundaries". Boundary
+            // elements are conforming or slave. The only exception to this
+            // being "ghost boundary elements" which are master faces
+            int f = mesh->GetBdrElementEdgeIndex(i);
+            int inf1, inf2;
+            mesh->GetFaceInfos(f, &inf1, &inf2, &ncface);
+         }
+
+         if (ncface >= 0)
+         {
+            auto face_index = mesh->GetNCMasterFaceIndex(ncface);
+            int inf1, inf2;
+            mesh->GetFaceInfos(face_index, &inf1, &inf2, &ncface);
+            if (face_index >= mesh->GetNumFaces() && ncface < 0)
+            {
+               // Ghost master face, do not process on this rank
+               continue;
+            }
+            else if (component < 0)
+            {
+               GetEntityVDofs(mesh->Dimension() - 1, face_index, dofs);
+            }
+            else
+            {
+               GetEntityDofs(mesh->Dimension() - 1, face_index, dofs);
+               for (auto &d : dofs) { d = DofToVDof(d, component); }
+            }
+         }
+         else if (component < 0)
          {
             // Mark all components.
-            GetBdrElementVDofs(i, vdofs);
-            mark_dofs(vdofs, ess_vdofs);
+            GetBdrElementVDofs(i, dofs);
          }
          else
          {
             GetBdrElementDofs(i, dofs);
-            for (int d = 0; d < dofs.Size(); d++)
-            { dofs[d] = DofToVDof(dofs[d], component); }
-            mark_dofs(dofs, ess_vdofs);
+            for (auto &d : dofs) { d = DofToVDof(d, component); }
          }
+
+         MarkDofs(dofs, ess_vdofs);
       }
    }
 
@@ -542,31 +571,27 @@ void FiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
       {
          if (component < 0)
          {
-            GetVertexVDofs(bdr_verts[i], vdofs);
-            mark_dofs(vdofs, ess_vdofs);
+            GetVertexVDofs(bdr_verts[i], dofs);
          }
          else
          {
             GetVertexDofs(bdr_verts[i], dofs);
-            for (int d = 0; d < dofs.Size(); d++)
-            { dofs[d] = DofToVDof(dofs[d], component); }
-            mark_dofs(dofs, ess_vdofs);
+            for (auto &d : dofs) { d = DofToVDof(d, component); }
          }
+         MarkDofs(dofs, ess_vdofs);
       }
       for (int i = 0; i < bdr_edges.Size(); i++)
       {
          if (component < 0)
          {
-            GetEdgeVDofs(bdr_edges[i], vdofs);
-            mark_dofs(vdofs, ess_vdofs);
+            GetEdgeVDofs(bdr_edges[i], dofs);
          }
          else
          {
             GetEdgeDofs(bdr_edges[i], dofs);
-            for (int d = 0; d < dofs.Size(); d++)
-            { dofs[d] = DofToVDof(dofs[d], component); }
-            mark_dofs(dofs, ess_vdofs);
+            for (auto &d : dofs) { d = DofToVDof(d, component); }
          }
+         MarkDofs(dofs, ess_vdofs);
       }
    }
 }
@@ -585,6 +610,19 @@ void FiniteElementSpace::GetEssentialTrueDofs(const Array<int> &bdr_attr_is_ess,
    else
    {
       R->BooleanMult(ess_vdofs, ess_tdofs);
+#ifdef MFEM_DEBUG
+      // Verify that in boolean arithmetic: P^T ess_dofs = R ess_dofs
+      Array<int> ess_tdofs2(ess_tdofs.Size());
+      GetConformingProlongation()->BooleanMultTranspose(ess_vdofs, ess_tdofs2);
+
+      int counter = 0;
+      for (int i = 0; i < ess_tdofs2.Size(); ++i)
+      {
+         if (bool(ess_tdofs[i]) != bool(ess_tdofs2[i])) { ++counter; }
+      }
+
+      MFEM_VERIFY(counter == 0, "internal MFEM error: counter = " << counter);
+#endif
    }
    MarkerToList(ess_tdofs, ess_tdof_list);
 }
@@ -933,6 +971,15 @@ int FiniteElementSpace::GetEntityDofs(int entity, int index, Array<int> &dofs,
    }
 }
 
+int FiniteElementSpace::GetEntityVDofs(int entity, int index, Array<int> &dofs,
+                                       Geometry::Type master_geom,
+                                       int variant) const
+{
+   int n = GetEntityDofs(entity, index, dofs, master_geom, variant);
+   DofsToVDofs(dofs);
+   return n;
+}
+
 void FiniteElementSpace::BuildConformingInterpolation() const
 {
 #ifdef MFEM_USE_MPI
diff --git a/fem/fespace.hpp b/fem/fespace.hpp
index be962050a..73d10a021 100644
--- a/fem/fespace.hpp
+++ b/fem/fespace.hpp
@@ -382,6 +382,10 @@ protected:
    int GetEntityDofs(int entity, int index, Array<int> &dofs,
                      Geometry::Type master_geom = Geometry::INVALID,
                      int variant = 0) const;
+   /// Helper to get vertex, edge or face VDOFs (entity=0,1,2 resp.).
+   int GetEntityVDofs(int entity, int index, Array<int> &dofs,
+                      Geometry::Type master_geom = Geometry::INVALID,
+                      int variant = 0) const;
 
    // Get degenerate face DOFs: see explanation in method implementation.
    int GetDegenerateFaceDofs(int index, Array<int> &dofs,
@@ -822,6 +826,7 @@ public:
    /// @brief Returns the indices of the degrees of freedom for the specified
    /// face, including the DOFs for the edges and the vertices of the face.
    ///
+   ///
    /// In variable order spaces, multiple variants of DOFs can be returned.
    /// See GetEdgeDofs() for more details.
    /// @return Order of the selected variant, or -1 if there are no more
@@ -1164,6 +1169,15 @@ public:
    static void ListToMarker(const Array<int> &list, int marker_size,
                             Array<int> &marker, int mark_val = -1);
 
+   /**
+    * @brief Helper for looping over entries in mark_array, and setting equal
+    * to -1 if present in dofs. Used in GetEssentialVDofs.
+    *
+    * @param[in] dofs The set of dofs to mark
+    * @param[out] mark_array Array of dofs to mark, indices with
+    */
+   static void MarkDofs(const Array<int> &dofs, Array<int> &mark_array);
+
    /** @brief For a partially conforming FE space, convert a marker array (nonzero
        entries are true) on the partially conforming dofs to a marker array on
        the conforming dofs. A conforming dofs is marked iff at least one of its
diff --git a/fem/gridfunc.cpp b/fem/gridfunc.cpp
index 928b4e2ad..8ac7e590c 100644
--- a/fem/gridfunc.cpp
+++ b/fem/gridfunc.cpp
@@ -836,6 +836,9 @@ double GridFunction::GetValue(ElementTransformation &T,
             FaceElementTransformations * FET =
                fes->GetMesh()->GetBdrFaceTransformations(T.ElementNo);
 
+            MFEM_ASSERT(FET != nullptr,
+                        "FaceElementTransformation must be valid for a boundary element");
+
             // Boundary elements and Boundary Faces may have different
             // orientations so adjust the integration point if necessary.
             int o = 0;
@@ -975,6 +978,9 @@ void GridFunction::GetVectorValue(ElementTransformation &T,
             FaceElementTransformations * FET =
                fes->GetMesh()->GetBdrFaceTransformations(T.ElementNo);
 
+            MFEM_ASSERT(FET != nullptr,
+                        "FaceElementTransformation must be valid for a boundary element");
+
             // Boundary elements and Boundary Faces may have different
             // orientations so adjust the integration point if necessary.
             int o = 0;
@@ -999,6 +1005,8 @@ void GridFunction::GetVectorValue(ElementTransformation &T,
          FaceElementTransformations * FET =
             dynamic_cast<FaceElementTransformations *>(&T);
 
+         MFEM_ASSERT(FET != nullptr,
+                     "FaceElementTransformation must be valid for a boundary element");
          // Evaluate in neighboring element for both continuous and
          // discontinuous fields (the integration point in T1 should have
          // already been set).
@@ -1116,11 +1124,10 @@ int GridFunction::GetFaceVectorValues(
    int i, int side, const IntegrationRule &ir,
    DenseMatrix &vals, DenseMatrix &tr) const
 {
-   int n, di;
+   int di;
    FaceElementTransformations *Transf;
 
-   n = ir.GetNPoints();
-   IntegrationRule eir(n);  // ---
+   IntegrationRule eir(ir.GetNPoints());  // ---
    Transf = fes->GetMesh()->GetFaceElementTransformations(i, 0);
    if (side == 2)
    {
@@ -1142,12 +1149,14 @@ int GridFunction::GetFaceVectorValues(
    if (di == 0)
    {
       Transf = fes->GetMesh()->GetFaceElementTransformations(i, 5);
+      MFEM_ASSERT(Transf != nullptr, "!");
       Transf->Loc1.Transform(ir, eir);
       GetVectorValues(*Transf->Elem1, eir, vals, &tr);
    }
    else
    {
       Transf = fes->GetMesh()->GetFaceElementTransformations(i, 10);
+      MFEM_ASSERT(Transf != nullptr, "!");
       Transf->Loc2.Transform(ir, eir);
       GetVectorValues(*Transf->Elem2, eir, vals, &tr);
    }
diff --git a/fem/pfespace.cpp b/fem/pfespace.cpp
index 8e4de18d6..ff97b1427 100644
--- a/fem/pfespace.cpp
+++ b/fem/pfespace.cpp
@@ -90,18 +90,18 @@ ParNURBSExtension *ParFiniteElementSpace::MakeLocalNURBSext(
 void ParFiniteElementSpace::ParInit(ParMesh *pm)
 {
    pmesh = pm;
-   pncmesh = NULL;
+   pncmesh = nullptr;
 
    MyComm = pmesh->GetComm();
    NRanks = pmesh->GetNRanks();
    MyRank = pmesh->GetMyRank();
 
-   gcomm = NULL;
+   gcomm = nullptr;
 
-   P = NULL;
-   Pconf = NULL;
+   P = nullptr;
+   Pconf = nullptr;
    nonconf_P = false;
-   R = NULL;
+   R = nullptr;
 
    num_face_nbr_dofs = -1;
 
@@ -161,18 +161,18 @@ void ParFiniteElementSpace::Construct()
 
       // calculate number of ghost DOFs
       ngvdofs = pncmesh->GetNGhostVertices()
-                * fec->DofForGeometry(Geometry::POINT);
+                * fec->DofForGeometry(Geometry::Type::POINT);
 
       if (pmesh->Dimension() > 1)
       {
          ngedofs = pncmesh->GetNGhostEdges()
-                   * fec->DofForGeometry(Geometry::SEGMENT);
+                   * fec->DofForGeometry(Geometry::Type::SEGMENT);
       }
 
       if (pmesh->Dimension() > 2)
       {
-         int stride = fec->DofForGeometry(Geometry::SQUARE);
-         ngfdofs = pncmesh->GetNGhostFaces() * stride;
+         ngfdofs = pncmesh->GetNGhostFaces()
+                   * fec->DofForGeometry(Geometry::Type::SQUARE);
       }
 
       // total number of ghost DOFs. Ghost DOFs start at index 'ndofs', i.e.,
@@ -532,12 +532,14 @@ ParFiniteElementSpace::GetBdrElementDofs(int i, Array<int> &dofs) const
 int ParFiniteElementSpace::GetFaceDofs(int i, Array<int> &dofs,
                                        int variant) const
 {
-   if (face_dof && variant == 0)
+   if (face_dof != nullptr && variant == 0)
    {
       face_dof->GetRow(i, dofs);
       return fec->GetOrder();
    }
+
    int p = FiniteElementSpace::GetFaceDofs(i, dofs, variant);
+
    if (Conforming())
    {
       ApplyLDofSigns(dofs);
@@ -1065,6 +1067,38 @@ void ParFiniteElementSpace::GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
 {
    FiniteElementSpace::GetEssentialVDofs(bdr_attr_is_ess, ess_dofs, component);
 
+   if (mesh->Nonconforming())
+   {
+      // In a nonconforming mesh, there can be internal boundary elements that
+      // can only be marked from ghost child faces. These are constructed during the
+      // ExchangeFaceNbrData phase
+
+      Array<int> dofs;
+      for (const auto &kv : pncmesh->GetGhostBoundaryElements())
+      {
+         if (bdr_attr_is_ess[kv.first - 1])
+         {
+            if (component < 0)
+            {
+               for (auto f : kv.second)
+               {
+                  GetEntityVDofs(mesh->Dimension() - 1, f, dofs);
+                  MarkDofs(dofs, ess_dofs);
+               }
+            }
+            else
+            {
+               for (auto f : kv.second)
+               {
+                  GetEntityDofs(mesh->Dimension() - 1, f, dofs);
+                  for (auto &d : dofs) { d = DofToVDof(d, component); }
+                  MarkDofs(dofs, ess_dofs);
+               }
+            }
+         }
+      }
+   }
+
    // Make sure that processors without boundary elements mark
    // their boundary dofs (if they have any).
    Synchronize(ess_dofs);
@@ -1083,18 +1117,28 @@ void ParFiniteElementSpace::GetEssentialTrueDofs(const Array<int>
 #ifdef MFEM_DEBUG
    // Verify that in boolean arithmetic: P^T ess_dofs = R ess_dofs.
    Array<int> true_ess_dofs2(true_ess_dofs.Size());
-   HypreParMatrix *Pt = Dof_TrueDof_Matrix()->Transpose();
+   auto Pt = std::unique_ptr<HypreParMatrix>(Dof_TrueDof_Matrix()->Transpose());
+
    const int *ess_dofs_data = ess_dofs.HostRead();
    Pt->BooleanMult(1, ess_dofs_data, 0, true_ess_dofs2);
-   delete Pt;
    int counter = 0;
    const int *ted = true_ess_dofs.HostRead();
+   std::string error_msg = "failed dof: ";
    for (int i = 0; i < true_ess_dofs.Size(); i++)
    {
-      if (bool(ted[i]) != bool(true_ess_dofs2[i])) { counter++; }
+      if (bool(ted[i]) != bool(true_ess_dofs2[i]))
+      {
+         error_msg += std::to_string(i) += "(R ";
+         error_msg += std::to_string(bool(ted[i])) += " P^T ";
+         error_msg += std::to_string(bool(true_ess_dofs2[i])) += ") ";
+         ++counter;
+      }
    }
+   MFEM_ASSERT(R->Height() == P->Width(), "!");
+   MFEM_ASSERT(R->Width() == P->Height(), "!");
+   MFEM_ASSERT(R->Width() == ess_dofs.Size(), "!");
    MFEM_VERIFY(counter == 0, "internal MFEM error: counter = " << counter
-               << ", rank = " << MyRank);
+               << ", rank = " << MyRank << ", " << error_msg);
 #endif
 
    MarkerToList(true_ess_dofs, ess_tdof_list);
@@ -1264,6 +1308,7 @@ void ParFiniteElementSpace::ExchangeFaceNbrData()
    // element)
    face_nbr_element_dof.MakeI(recv_el_off[num_face_nbrs]);
 
+
    int *send_I = send_nbr_elem_dof.GetI();
    int *recv_I = face_nbr_element_dof.GetI();
    for (int fn = 0; fn < num_face_nbrs; fn++)
@@ -1815,9 +1860,13 @@ int ParFiniteElementSpace::PackDof(int entity, int index, int edof) const
 static int bisect(const int* array, int size, int value)
 {
    const int* end = array + size;
-   const int* pos = std::lower_bound(array, end, value);
-   MFEM_VERIFY(pos != end, "value not found");
-   return pos - array;
+   const int* pos = std::upper_bound(array, end, value);
+   MFEM_VERIFY(pos != array, "value not found");
+   if (pos == end)
+   {
+      MFEM_VERIFY(*(array+size - 1) == value, "Last entry must be exact")
+   }
+   return pos - array - 1;
 }
 
 /** Dissect a DOF number to obtain the entity type (0=vertex, 1=edge, 2=face),
@@ -1853,7 +1902,8 @@ void ParFiniteElementSpace::UnpackDof(int dof,
          else // mixed faces or var-order space
          {
             const Table &table = var_face_dofs;
-            MFEM_ASSERT(table.Size(), "");
+
+            MFEM_ASSERT(table.Size() > 0, "");
             int jpos = bisect(table.GetJ(), table.Size_of_connections(), dof);
             index = bisect(table.GetI(), table.Size(), jpos);
             edof = dof - table.GetRow(index)[0];
@@ -1921,9 +1971,8 @@ struct PMatrixRow
    void AddRow(const PMatrixRow &other, double coef)
    {
       elems.reserve(elems.size() + other.elems.size());
-      for (unsigned i = 0; i < other.elems.size(); i++)
+      for (const PMatrixElement &oei : other.elems)
       {
-         const PMatrixElement &oei = other.elems[i];
          elems.push_back(
             PMatrixElement(oei.column, oei.stride, coef * oei.value));
       }
@@ -1983,7 +2032,6 @@ class NeighborRowMessage : public VarMessage<314>
 public:
    typedef NCMesh::MeshId MeshId;
    typedef ParNCMesh::GroupId GroupId;
-
    struct RowInfo
    {
       int entity, index, edof;
@@ -1995,8 +2043,6 @@ public:
 
       RowInfo(int ent, int idx, int edof, GroupId grp)
          : entity(ent), index(idx), edof(edof), group(grp) {}
-
-      typedef std::vector<RowInfo> List;
    };
 
    NeighborRowMessage() : pncmesh(NULL) {}
@@ -2007,7 +2053,7 @@ public:
       rows.push_back(RowInfo(entity, index, edof, group, row));
    }
 
-   const RowInfo::List& GetRows() const { return rows; }
+   const std::vector<RowInfo>& GetRows() const { return rows; }
 
    void SetNCMesh(ParNCMesh* pnc) { pncmesh = pnc; }
    void SetFEC(const FiniteElementCollection* fec_) { this->fec = fec_; }
@@ -2015,7 +2061,7 @@ public:
    typedef std::map<int, NeighborRowMessage> Map;
 
 protected:
-   RowInfo::List rows;
+   std::vector<RowInfo> rows;
 
    ParNCMesh *pncmesh;
    const FiniteElementCollection* fec;
@@ -2024,7 +2070,6 @@ protected:
    virtual void Decode(int);
 };
 
-
 void NeighborRowMessage::Encode(int rank)
 {
    std::ostringstream stream;
@@ -2061,6 +2106,7 @@ void NeighborRowMessage::Encode(int rank)
       for (int i = 0; i < ids.Size(); i++)
       {
          const MeshId &id = ids[i];
+
          const RowInfo &ri = rows[row_idx[ent][i]];
          MFEM_ASSERT(ent == ri.entity, "");
 
@@ -2112,35 +2158,58 @@ void NeighborRowMessage::Decode(int rank)
    rows.reserve(nrows);
 
    // read rows
+   // ent = {0,1,2} means vertex, edge and face entity
    for (int ent = 0, gi = 0; ent < 3; ent++)
    {
+      // extract the vertex list, edge list or face list.
       const Array<MeshId> &ids = ent_ids[ent];
       for (int i = 0; i < ids.Size(); i++)
       {
          const MeshId &id = ids[i];
+         // read the particular element dof value off the stream.
          int edof = bin_io::read<int>(stream);
 
-         // handle orientation and sign change
-         const int *ind = NULL;
+         // Handle orientation and sign change.
+         // This flips the sign on dofs where necessary, and for edges and faces
+         // also reorders if flipped, i.e. an edge with
+         //    1 -> 2 -> 3 -> 4
+         // might become
+         //    -4 -> -3 -> -2 -> -1
+         // This cannot treat all face dofs, as they can have rotations and
+         // reflections.
+         const int *ind = nullptr;
+         Geometry::Type geom = Geometry::Type::INVALID;
          if (ent == 1)
          {
+            // edge NC orientation is element defined.
             int eo = pncmesh->GetEdgeNCOrientation(id);
             ind = fec->DofOrderForOrientation(Geometry::SEGMENT, eo);
          }
          else if (ent == 2)
          {
-            Geometry::Type geom = pncmesh->GetFaceGeometry(id.index);
+            geom = pncmesh->GetFaceGeometry(id.index);
             int fo = pncmesh->GetFaceOrientation(id.index);
             ind = fec->DofOrderForOrientation(geom, fo);
          }
 
-         double s = 1.0;
+#ifdef MFEM_DEBUG_PMATRIX
+         mfem::out << "Rank " << pncmesh->MyRank << " receiving from " << rank
+                   << ": ent " << ent << ", index " << id.index
+                   << ", edof " << edof << " (id " << id.element << "/"
+                   << int(id.local) << ")" << std::endl;
+#endif
+
+         // If edof arrived with a negative index, flip it, and the scaling.
+         double s = (edof < 0) ? -1.0 : 1.0;
+         edof = (edof < 0) ? -1 - edof : edof;
+
          if (ind && (edof = ind[edof]) < 0)
          {
             edof = -1 - edof;
-            s = -1.0;
+            s *= -1.0;
          }
 
+         // Create a row for this entity, recording the index of the mesh element
          rows.push_back(RowInfo(ent, id.index, edof, group_ids[gi++]));
          rows.back().row.read(stream, s);
 
@@ -2150,6 +2219,65 @@ void NeighborRowMessage::Decode(int rank)
                    << rows.back().index << ", edof " << rows.back().edof
                    << std::endl;
 #endif
+
+         if (ent == 2 && fec->GetContType() == FiniteElementCollection::TANGENTIAL
+             && !Geometry::IsTensorProduct(geom))
+         {
+            // ND face dofs need to be processed together, as the transformation
+            // is given by a 2x2 matrix, so we manually apply an extra increment
+            // to the loop counter and add in a new row. Once these rows are placed, they
+            // represent the Identity transformation. To map across the
+            // processor boundary, we also need to apply a Primal Transformation
+            // (see doftrans.hpp) to a notional "global dof" orientation.
+            // For simplicity we perform the action of these 2x2 matrices
+            // manually using the AddRow capability, followed by a Collapse.
+
+            // To perform the operations, we add and subtract initial versions
+            // of the rows, that represent [1 0; 0 1] in row major notation.
+            // The first row represents the 1 at (0,0) in [1 0; 0 1]
+            // The second row represents the 1 at (1,1) in [1 0; 0 1]
+
+            // We can safely bind this reference as rows was reserved above so
+            // there is no hidden copying that could result in a dangling reference.
+            auto &first_row = rows.back().row;
+            // This is the first "fundamental unit" used in the transformation.
+            const auto initial_first_row = first_row;
+            // Extract the next dof too, and apply any dof order transformation expected.
+            const MeshId &next_id = ids[++i];
+            int fo = pncmesh->GetFaceOrientation(next_id.index);
+            ind = fec->DofOrderForOrientation(geom, fo);
+
+            s = 1.0;
+            edof = bin_io::read<int>(stream);
+            if (ind && (edof = ind[edof]) < 0)
+            {
+               edof = -1 - edof;
+               s = -1.0;
+            }
+            rows.push_back(RowInfo(ent, next_id.index, edof, group_ids[gi++]));
+            rows.back().row.read(stream, s);
+
+            auto &second_row = rows.back().row;
+
+            // This is the second "fundamental unit" used in the transformation.
+            const auto initial_second_row = second_row;
+
+            const auto T = [&fo]()
+            {
+               auto T = ND_DofTransformation::GetFaceTransform(fo);
+               T(0,0) -= 1;
+               T(1,1) -= 1;
+               return T;
+            }();
+
+            first_row.AddRow(initial_first_row, T(0,0));
+            first_row.AddRow(initial_second_row, T(0,1));
+            second_row.AddRow(initial_first_row, T(1,0));
+            second_row.AddRow(initial_second_row, T(1,1));
+
+            first_row.Collapse();
+            second_row.Collapse();
+         }
       }
    }
 }
@@ -2162,10 +2290,8 @@ ParFiniteElementSpace::ScheduleSendRow(const PMatrixRow &row, int dof,
    int ent, idx, edof;
    UnpackDof(dof, ent, idx, edof);
 
-   const ParNCMesh::CommGroup &group = pncmesh->GetGroup(group_id);
-   for (unsigned i = 0; i < group.size(); i++)
+   for (const auto &rank : pncmesh->GetGroup(group_id))
    {
-      int rank = group[i];
       if (rank != MyRank)
       {
          NeighborRowMessage &msg = send_msg[rank];
@@ -2279,13 +2405,7 @@ int ParFiniteElementSpace
                                        Array<int> *dof_tdof,
                                        bool partial) const
 {
-   // TODO: general face DOF transformations in NeighborRowMessage::Decode()
-   MFEM_VERIFY(!(fec->GetOrder() >= 2
-                 && pmesh->HasGeometry(Geometry::TETRAHEDRON)
-                 && fec->GetContType() == FiniteElementCollection::TANGENTIAL),
-               "Nedelec NC tets of order >= 2 are not supported yet.");
-
-   bool dg = (nvdofs == 0 && nedofs == 0 && nfdofs == 0);
+   const bool dg = (nvdofs == 0 && nedofs == 0 && nfdofs == 0);
 
 #ifdef MFEM_PMATRIX_STATS
    n_msgs_sent = n_msgs_recv = 0;
@@ -2294,7 +2414,7 @@ int ParFiniteElementSpace
 
    // *** STEP 1: build master-slave dependency lists ***
 
-   int total_dofs = ndofs + ngdofs;
+   const int total_dofs = ndofs + ngdofs;
    SparseMatrix deps(ndofs, total_dofs);
 
    if (!dg && !partial)
@@ -2305,16 +2425,14 @@ int ParFiniteElementSpace
       for (int entity = 0; entity <= 2; entity++)
       {
          const NCMesh::NCList &list = pncmesh->GetNCList(entity);
-         if (!list.masters.Size()) { continue; }
+         if (list.masters.Size() == 0) { continue; }
 
          IsoparametricTransformation T;
          DenseMatrix I;
 
          // process masters that we own or that affect our edges/faces
-         for (int mi = 0; mi < list.masters.Size(); mi++)
+         for (const auto &mf : list.masters)
          {
-            const NCMesh::Master &mf = list.masters[mi];
-
             // get master DOFs
             if (pncmesh->IsGhost(entity, mf.index))
             {
@@ -2325,10 +2443,10 @@ int ParFiniteElementSpace
                GetEntityDofs(entity, mf.index, master_dofs, mf.Geom());
             }
 
-            if (!master_dofs.Size()) { continue; }
+            if (master_dofs.Size() == 0) { continue; }
 
-            const FiniteElement* fe = fec->FiniteElementForGeometry(mf.Geom());
-            if (!fe) { continue; }
+            const FiniteElement * const fe = fec->FiniteElementForGeometry(mf.Geom());
+            if (fe == nullptr) { continue; }
 
             switch (mf.Geom())
             {
@@ -2344,7 +2462,7 @@ int ParFiniteElementSpace
                const NCMesh::Slave &sf = list.slaves[si];
                if (pncmesh->IsGhost(entity, sf.index)) { continue; }
 
-               const int variant = 0; // TODO parallel var-order
+               constexpr int variant = 0; // TODO parallel var-order
                GetEntityDofs(entity, sf.index, slave_dofs, mf.Geom(), variant);
                if (!slave_dofs.Size()) { continue; }
 
@@ -2371,37 +2489,37 @@ int ParFiniteElementSpace
    {
       Array<int> dofs;
 
-      // initialize dof_group[], dof_owner[]
-      for (int entity = 0; entity <= 2; entity++)
+      auto initialize_group_and_owner = [&dof_group, &dof_owner, &dofs,
+                                                     this](int entity, const MeshId &id)
       {
-         const NCMesh::NCList &list = pncmesh->GetNCList(entity);
-
-         int lsize[3] =
-         { list.conforming.Size(), list.masters.Size(), list.slaves.Size() };
+         if (id.index < 0) { return; }
 
-         for (int l = 0; l < 3; l++)
-         {
-            for (int i = 0; i < lsize[l]; i++)
-            {
-               const MeshId &id =
-                  (l == 0) ? list.conforming[i] :
-                  (l == 1) ? (const MeshId&) list.masters[i]
-                  /*    */ : (const MeshId&) list.slaves[i];
-
-               if (id.index < 0) { continue; }
+         GroupId owner = pncmesh->GetEntityOwnerId(entity, id.index);
+         GroupId group = pncmesh->GetEntityGroupId(entity, id.index);
 
-               GroupId owner = pncmesh->GetEntityOwnerId(entity, id.index);
-               GroupId group = pncmesh->GetEntityGroupId(entity, id.index);
+         GetBareDofs(entity, id.index, dofs);
 
-               GetBareDofs(entity, id.index, dofs);
+         for (auto dof : dofs)
+         {
+            dof_owner[dof] = owner;
+            dof_group[dof] = group;
+         }
+      };
 
-               for (int j = 0; j < dofs.Size(); j++)
-               {
-                  int dof = dofs[j];
-                  dof_owner[dof] = owner;
-                  dof_group[dof] = group;
-               }
-            }
+      // initialize dof_group[], dof_owner[] in sequence
+      for (int entity : {0,1,2})
+      {
+         for (const auto &id : pncmesh->GetNCList(entity).conforming)
+         {
+            initialize_group_and_owner(entity, id);
+         }
+         for (const auto &id : pncmesh->GetNCList(entity).masters)
+         {
+            initialize_group_and_owner(entity, id);
+         }
+         for (const auto &id : pncmesh->GetNCList(entity).slaves)
+         {
+            initialize_group_and_owner(entity, id);
          }
       }
    }
@@ -2413,15 +2531,50 @@ int ParFiniteElementSpace
 
    // DOFs that stayed independent and are ours are true DOFs
    int num_true_dofs = 0;
-   for (int i = 0; i < ndofs; i++)
+   for (int i = 0; i < ndofs; ++i)
    {
       if (dof_owner[i] == 0 && deps.RowSize(i) == 0)
       {
-         num_true_dofs++;
+         ++num_true_dofs;
          finalized[i] = true;
       }
    }
 
+#ifdef MFEM_DEBUG_PMATRIX
+   // Helper for dumping diagnostics on one dof
+   auto dof_diagnostics = [&](int dof, bool print_diagnostic)
+   {
+      const auto &comm_group = pncmesh->GetGroup(dof_group[dof]);
+      std::stringstream msg;
+      msg << std::boolalpha;
+      msg << "R" << Mpi::WorldRank() << " dof " << dof
+          << " owner_rank " << pncmesh->GetGroup(dof_owner[dof])[0] << " CommGroup {";
+      for (const auto &x : comm_group)
+      {
+         msg << x << ' ';
+      }
+      msg << "} finalized " << finalized[dof];
+
+      Array<int> cols;
+      if (dof < ndofs)
+      {
+         Vector row;
+         deps.GetRow(dof, cols, row);
+         msg << " deps cols {";
+         for (const auto &x : cols)
+         {
+            msg << x << ' ';
+         }
+         msg << '}';
+      }
+
+      int entity, index, edof;
+      UnpackDof(dof, entity, index, edof);
+      msg << " entity " << entity << " index " << index << " edof " << edof;
+      return msg.str();
+   };
+#endif
+
    // calculate global offsets
    HYPRE_BigInt loc_sizes[2] = { ndofs*vdim, num_true_dofs*vdim };
    Array<HYPRE_BigInt>* offsets[2] = { &dof_offs, &tdof_offs };
@@ -2441,12 +2594,14 @@ int ParFiniteElementSpace
       *dof_tdof = -1;
    }
 
+
+
    std::vector<PMatrixRow> pmatrix(total_dofs);
 
-   bool bynodes = (ordering == Ordering::byNODES);
-   int vdim_factor = bynodes ? 1 : vdim;
-   int dof_stride = bynodes ? ndofs : 1;
-   int tdof_stride = bynodes ? num_true_dofs : 1;
+   const bool bynodes = (ordering == Ordering::byNODES);
+   const int vdim_factor = bynodes ? 1 : vdim;
+   const int dof_stride = bynodes ? ndofs : 1;
+   const int tdof_stride = bynodes ? num_true_dofs : 1;
 
    // big container for all messages we send (the list is for iterations)
    std::list<NeighborRowMessage::Map> send_msg;
@@ -2468,13 +2623,13 @@ int ParFiniteElementSpace
 
          for (int vd = 0; vd < vdim; vd++)
          {
-            int vdof = dof*vdim_factor + vd*dof_stride;
-            int vtdof = tdof*vdim_factor + vd*tdof_stride;
+            const int vdof = dof*vdim_factor + vd*dof_stride;
+            const int vtdof = tdof*vdim_factor + vd*tdof_stride;
 
             if (R_) { (*R_)->Add(vtdof, vdof, 1.0); }
             if (dof_tdof) { (*dof_tdof)[vdof] = vtdof; }
          }
-         tdof++;
+         ++tdof;
       }
    }
 
@@ -2515,14 +2670,12 @@ int ParFiniteElementSpace
          n_rows_recv += recv_msg.GetRows().size();
 #endif
 
-         const NeighborRowMessage::RowInfo::List &rows = recv_msg.GetRows();
-         for (unsigned i = 0; i < rows.size(); i++)
+         for (const auto &ri : recv_msg.GetRows())
          {
-            const NeighborRowMessage::RowInfo &ri = rows[i];
-            int dof = PackDof(ri.entity, ri.index, ri.edof);
+            const int dof = PackDof(ri.entity, ri.index, ri.edof);
             pmatrix[dof] = ri.row;
 
-            if (dof < ndofs && !finalized[dof]) { num_finalized++; }
+            if (dof < ndofs && !finalized[dof]) { ++num_finalized; }
             finalized[dof] = true;
 
             if (ri.group >= 0 && dof_group[dof] != ri.group)
@@ -2540,13 +2693,14 @@ int ParFiniteElementSpace
          done = true;
          for (int dof = 0; dof < ndofs; dof++)
          {
-            if (finalized[dof]) { continue; }
-
-            bool owned = (dof_owner[dof] == 0);
-            bool shared = (dof_group[dof] != 0);
-
-            if (owned && DofFinalizable(dof, finalized, deps))
+            const bool owned = (dof_owner[dof] == 0);
+            if (!finalized[dof]
+                && owned
+                && DofFinalizable(dof, finalized, deps))
             {
+               int ent, idx, edof;
+               UnpackDof(dof, ent, idx, edof);
+
                const int* dep_col = deps.GetRowColumns(dof);
                const double* dep_coef = deps.GetRowEntries(dof);
                int num_dep = deps.RowSize(dof);
@@ -2561,10 +2715,11 @@ int ParFiniteElementSpace
                pmatrix[dof] = buffer;
 
                finalized[dof] = true;
-               num_finalized++;
+               ++num_finalized;
                done = false;
 
                // send row to neighbors who need it
+               const bool shared = (dof_group[dof] != 0);
                if (shared)
                {
                   ScheduleSendRow(pmatrix[dof], dof, dof_group[dof],
@@ -2575,7 +2730,7 @@ int ParFiniteElementSpace
       }
 
 #ifdef MFEM_DEBUG_PMATRIX
-      /*static int dump = 0;
+      static int dump = 0;
       if (dump < 10)
       {
          char fname[100];
@@ -2583,7 +2738,7 @@ int ParFiniteElementSpace
          std::ofstream f(fname);
          DebugDumpDOFs(f, deps, dof_group, dof_owner, finalized);
          dump++;
-      }*/
+      }
 #endif
 
       // send current batch of messages
@@ -2608,10 +2763,9 @@ int ParFiniteElementSpace
    }
 
    // make sure we can discard all send buffers
-   for (std::list<NeighborRowMessage::Map>::iterator
-        it = send_msg.begin(); it != send_msg.end(); ++it)
+   for (auto &msg : send_msg)
    {
-      NeighborRowMessage::WaitAllSent(*it);
+      NeighborRowMessage::WaitAllSent(msg);
    }
 
 #ifdef MFEM_PMATRIX_STATS
diff --git a/fem/pfespace.hpp b/fem/pfespace.hpp
index 61448c3b7..c8d83e1f7 100644
--- a/fem/pfespace.hpp
+++ b/fem/pfespace.hpp
@@ -123,8 +123,8 @@ private:
    void GetGhostVertexDofs(const MeshId &id, Array<int> &dofs) const;
    void GetGhostEdgeDofs(const MeshId &edge_id, Array<int> &dofs) const;
    void GetGhostFaceDofs(const MeshId &face_id, Array<int> &dofs) const;
-
    void GetGhostDofs(int entity, const MeshId &id, Array<int> &dofs) const;
+
    /// Return the dofs associated with the interior of the given mesh entity.
    void GetBareDofs(int entity, int index, Array<int> &dofs) const;
 
@@ -189,15 +189,15 @@ private:
    /// Updates the internal mesh pointer. @warning @a new_mesh must be
    /// <b>topologically identical</b> to the existing mesh. Used if the address
    /// of the Mesh object has changed, e.g. in @a Mesh::Swap.
-   virtual void UpdateMeshPointer(Mesh *new_mesh);
+   void UpdateMeshPointer(Mesh *new_mesh) override;
 
    /// Copies the prolongation and restriction matrices from @a fes.
    ///
    /// Used for low order preconditioning on non-conforming meshes. If the DOFs
    /// require a permutation, it will be supplied by non-NULL @a perm. NULL @a
    /// perm indicates that no permutation is required.
-   virtual void CopyProlongationAndRestriction(const FiniteElementSpace &fes,
-                                               const Array<int> *perm);
+   void CopyProlongationAndRestriction(const FiniteElementSpace &fes,
+                                       const Array<int> *perm) override;
 
 public:
    // Face-neighbor data
@@ -281,42 +281,42 @@ public:
    { return Dof_TrueDof_Matrix()->GetGlobalNumCols(); }
 
    /// Return the number of local vector true dofs.
-   virtual int GetTrueVSize() const { return ltdof_size; }
+   int GetTrueVSize() const override { return ltdof_size; }
 
    /// Returns indexes of degrees of freedom in array dofs for i'th element.
-   virtual DofTransformation *GetElementDofs(int i, Array<int> &dofs) const;
+   DofTransformation *GetElementDofs(int i, Array<int> &dofs) const override;
 
    /// Returns indexes of degrees of freedom in array dofs for i'th element and
    /// returns the DofTransformation data in a user-provided object.
-   virtual void GetElementDofs(int i, Array<int> &dofs,
-                               DofTransformation &doftrans) const;
+   void GetElementDofs(int i, Array<int> &dofs,
+                       DofTransformation &doftrans) const override;
 
    /// Returns indexes of degrees of freedom for i'th boundary element.
-   virtual DofTransformation *GetBdrElementDofs(int i, Array<int> &dofs) const;
+   DofTransformation *GetBdrElementDofs(int i, Array<int> &dofs) const override;
 
    /// Returns indexes of degrees of freedom for i'th boundary element and
    /// returns the DofTransformation data in a user-provided object.
-   virtual void GetBdrElementDofs(int i, Array<int> &dofs,
-                                  DofTransformation &doftrans) const;
+   void GetBdrElementDofs(int i, Array<int> &dofs,
+                          DofTransformation &doftrans) const override;
 
    /** Returns the indexes of the degrees of freedom for i'th face
        including the dofs for the edges and the vertices of the face. */
-   virtual int GetFaceDofs(int i, Array<int> &dofs, int variant = 0) const;
+   int GetFaceDofs(int i, Array<int> &dofs, int variant = 0) const override;
 
    /** Returns pointer to the FiniteElement in the FiniteElementCollection
        associated with i'th element in the mesh object. If @a i is greater than
        or equal to the number of local mesh elements, @a i will be interpreted
        as a shifted index of a face neighbor element. */
-   virtual const FiniteElement *GetFE(int i) const;
+   const FiniteElement *GetFE(int i) const override;
 
    /** Returns an Operator that converts L-vectors to E-vectors on each face.
        The parallel version is different from the serial one because of the
        presence of shared faces. Shared faces are treated as interior faces,
        the returned operator handles the communication needed to get the
        shared face values from other MPI ranks */
-   virtual const FaceRestriction *GetFaceRestriction(
+   const FaceRestriction *GetFaceRestriction(
       ElementDofOrdering f_ordering, FaceType type,
-      L2FaceValues mul = L2FaceValues::DoubleValued) const;
+      L2FaceValues mul = L2FaceValues::DoubleValued) const override;
 
    void GetSharedEdgeDofs(int group, int ei, Array<int> &dofs) const;
    void GetSharedTriangleDofs(int group, int fi, Array<int> &dofs) const;
@@ -327,10 +327,10 @@ public:
    { if (!P) { Build_Dof_TrueDof_Matrix(); } return P; }
 
    /// Get the P matrix which prolongates a true dof vector to local dof vector.
-   virtual const Operator *GetProlongationMatrix() const;
+   const Operator *GetProlongationMatrix() const override;
 
    /// Get the R matrix which restricts a local dof vector to true dof vector.
-   virtual const SparseMatrix *GetRestrictionMatrix() const
+   const SparseMatrix *GetRestrictionMatrix() const override
    { Dof_TrueDof_Matrix(); return R; }
 
    /** @brief For a non-conforming mesh, construct and return the interpolation
@@ -363,15 +363,15 @@ public:
    void Synchronize(Array<int> &ldof_marker) const;
 
    /// Determine the boundary degrees of freedom
-   virtual void GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
-                                  Array<int> &ess_dofs,
-                                  int component = -1) const;
+   void GetEssentialVDofs(const Array<int> &bdr_attr_is_ess,
+                          Array<int> &ess_dofs,
+                          int component = -1) const override;
 
    /** Get a list of essential true dofs, ess_tdof_list, corresponding to the
        boundary attributes marked in the array bdr_attr_is_ess. */
-   virtual void GetEssentialTrueDofs(const Array<int> &bdr_attr_is_ess,
-                                     Array<int> &ess_tdof_list,
-                                     int component = -1);
+   void GetEssentialTrueDofs(const Array<int> &bdr_attr_is_ess,
+                             Array<int> &ess_tdof_list,
+                             int component = -1) override;
 
    /** If the given ldof is owned by the current processor, return its local
        tdof number, otherwise return -1 */
@@ -409,15 +409,15 @@ public:
    // Transfer parallel true-dof data from coarse_fes, defined on a coarse mesh,
    // to this FE space, defined on a refined mesh. See full documentation in the
    // base class, FiniteElementSpace::GetTrueTransferOperator.
-   virtual void GetTrueTransferOperator(const FiniteElementSpace &coarse_fes,
-                                        OperatorHandle &T) const;
+   void GetTrueTransferOperator(const FiniteElementSpace &coarse_fes,
+                                OperatorHandle &T) const override;
 
    /** Reflect changes in the mesh. Calculate one of the refinement/derefinement
        /rebalance matrices, unless want_transform is false. */
-   virtual void Update(bool want_transform = true);
+   void Update(bool want_transform = true) override;
 
    /// Free ParGridFunction transformation matrix (if any), to save memory.
-   virtual void UpdatesFinished()
+   void UpdatesFinished() override
    {
       FiniteElementSpace::UpdatesFinished();
       old_dof_offsets.DeleteAll();
@@ -445,9 +445,9 @@ public:
 
    const GroupCommunicator &GetGroupCommunicator() const;
 
-   virtual void Mult(const Vector &x, Vector &y) const;
+   void Mult(const Vector &x, Vector &y) const override;
 
-   virtual void MultTranspose(const Vector &x, Vector &y) const;
+   void MultTranspose(const Vector &x, Vector &y) const override;
 };
 
 /// Auxiliary device class used by ParFiniteElementSpace.
@@ -495,9 +495,9 @@ public:
 
    virtual ~DeviceConformingProlongationOperator();
 
-   virtual void Mult(const Vector &x, Vector &y) const;
+   void Mult(const Vector &x, Vector &y) const override;
 
-   virtual void MultTranspose(const Vector &x, Vector &y) const;
+   void MultTranspose(const Vector &x, Vector &y) const override;
 };
 
 }
diff --git a/fem/pgridfunc.cpp b/fem/pgridfunc.cpp
index d49187457..9970fddee 100644
--- a/fem/pgridfunc.cpp
+++ b/fem/pgridfunc.cpp
@@ -469,17 +469,17 @@ void ParGridFunction::GetVectorValue(ElementTransformation &T,
    }
 
    Array<int> vdofs;
-   DofTransformation * doftrans = pfes->GetFaceNbrElementVDofs(nbr_el_no,
-                                                               vdofs);
-   const FiniteElement *fe = pfes->GetFaceNbrFE(nbr_el_no);
-
-   int dof = fe->GetDof();
+   DofTransformation * doftrans = pfes->GetFaceNbrElementVDofs(nbr_el_no, vdofs);
    Vector loc_data;
    face_nbr_data.GetSubVector(vdofs, loc_data);
    if (doftrans)
    {
       doftrans->InvTransformPrimal(loc_data);
    }
+
+   const FiniteElement *fe = pfes->GetFaceNbrFE(nbr_el_no);
+   int dof = fe->GetDof();
+
    if (fe->GetRangeType() == FiniteElement::SCALAR)
    {
       Vector shape(dof);
diff --git a/general/hash.hpp b/general/hash.hpp
index 288d51288..b517172aa 100644
--- a/general/hash.hpp
+++ b/general/hash.hpp
@@ -335,6 +335,8 @@ public:
 
    iterator begin() { return iterator(Base::begin()); }
    iterator end() { return iterator(); }
+   const_iterator begin() const { return const_iterator(Base::cbegin()); }
+   const_iterator end() const { return const_iterator(); }
 
    const_iterator cbegin() const { return const_iterator(Base::cbegin()); }
    const_iterator cend() const { return const_iterator(); }
diff --git a/general/optparser.cpp b/general/optparser.cpp
index 5ba65e8b8..a59854899 100644
--- a/general/optparser.cpp
+++ b/general/optparser.cpp
@@ -207,6 +207,9 @@ void OptionsParser::Parse()
                case STRING:
                   *(const char **)(options[j].var_ptr) = argv[i++];
                   break;
+               case STD_STRING:
+                  *(std::string *)(options[j].var_ptr) = argv[i++];
+                  break;
                case ENABLE:
                   *(bool *)(options[j].var_ptr) = true;
                   option_check[j+1] = 1;  // Do not allow the DISABLE Option
@@ -284,6 +287,10 @@ void OptionsParser::WriteValue(const Option &opt, std::ostream &os)
          os << *(const char **)(opt.var_ptr);
          break;
 
+      case STD_STRING:
+         out << *(std::string *)(opt.var_ptr);
+         break;
+
       case ARRAY:
       {
          Array<int> &list = *(Array<int>*)(opt.var_ptr);
@@ -401,8 +408,9 @@ void OptionsParser::PrintHelp(ostream &os) const
    static const char *seprtr = ", ";
    static const char *descr_sep = "\n\t";
    static const char *line_sep = "";
-   static const char *types[] = { " <int>", " <double>", " <string>", "", "",
-                                  " '<int>...'", " '<double>...'"
+   static const char *types[] = { " <int>", " <double>", " <string>",
+                                  " <string>", "", "", " '<int>...'",
+                                  " '<double>...'"
                                 };
 
    os << indent << "-h" << seprtr << "--help" << descr_sep
diff --git a/general/optparser.hpp b/general/optparser.hpp
index b437794cc..eecf0f74a 100644
--- a/general/optparser.hpp
+++ b/general/optparser.hpp
@@ -31,7 +31,7 @@ class Vector;
 class OptionsParser
 {
 public:
-   enum OptionType { INT, DOUBLE, STRING, ENABLE, DISABLE, ARRAY, VECTOR };
+   enum OptionType { INT, DOUBLE, STRING, STD_STRING, ENABLE, DISABLE, ARRAY, VECTOR };
 
 private:
    struct Option
@@ -115,6 +115,15 @@ public:
                             required));
    }
 
+   /// Add a string (std::string) option and set 'var' to receive the value.
+   void AddOption(std::string *var, const char *short_name,
+                  const char *long_name, const char *description,
+                  bool required = false)
+   {
+      options.Append(Option(STD_STRING, var, short_name, long_name, description,
+                            required));
+   }
+
    /** Add an integer array (separated by spaces) option and set 'var' to
        receive the values. */
    void AddOption(Array<int> * var, const char *short_name,
diff --git a/general/table.cpp b/general/table.cpp
index 4c0bb68ee..da4c0187b 100644
--- a/general/table.cpp
+++ b/general/table.cpp
@@ -218,7 +218,8 @@ void Table::SetIJ(int *newI, int *newJ, int newsize)
 
 int Table::Push(int i, int j)
 {
-   MFEM_ASSERT( i >=0 && i<size, "Index out of bounds.  i = "<<i);
+   MFEM_ASSERT( i >=0 &&
+                i<size, "Index out of bounds.  i = " << i << " size " << size);
 
    for (int k = I[i], end = I[i+1]; k < end; k++)
    {
diff --git a/linalg/densemat.cpp b/linalg/densemat.cpp
index c4b71a770..44b40fa82 100644
--- a/linalg/densemat.cpp
+++ b/linalg/densemat.cpp
@@ -4173,6 +4173,28 @@ DenseMatrixSVD::DenseMatrixSVD(int h, int w,
    Init();
 }
 
+DenseMatrixSVD::DenseMatrixSVD(DenseMatrix &M,
+                               char left_singular_vectors,
+                               char right_singular_vectors)
+{
+   m = M.Height();
+   n = M.Width();
+   jobu = left_singular_vectors;
+   jobvt = right_singular_vectors;
+   Init();
+}
+
+DenseMatrixSVD::DenseMatrixSVD(int h, int w,
+                               char left_singular_vectors,
+                               char right_singular_vectors)
+{
+   m = h;
+   n = w;
+   jobu = left_singular_vectors;
+   jobvt = right_singular_vectors;
+   Init();
+}
+
 void DenseMatrixSVD::Init()
 {
    sv.SetSize(min(m, n));
@@ -4195,12 +4217,22 @@ void DenseMatrixSVD::Eval(DenseMatrix &M)
 #endif
    double * datau = nullptr;
    double * datavt = nullptr;
-   if (jobu == 'S')
+   if (jobu == 'A')
+   {
+      U.SetSize(m,m);
+      datau = U.Data();
+   }
+   else if (jobu == 'S')
    {
       U.SetSize(m,min(m,n));
       datau = U.Data();
    }
-   if (jobvt == 'S')
+   if (jobvt == 'A')
+   {
+      Vt.SetSize(n,n);
+      datavt = Vt.Data();
+   }
+   else if (jobvt == 'S')
    {
       Vt.SetSize(min(m,n),n);
       datavt = Vt.Data();
diff --git a/linalg/densemat.hpp b/linalg/densemat.hpp
index 0b3b9a75f..d1f047295 100644
--- a/linalg/densemat.hpp
+++ b/linalg/densemat.hpp
@@ -939,7 +939,12 @@ public:
    ~DenseMatrixGeneralizedEigensystem();
 };
 
+/**
+ @brief Class for Singular Value Decomposition of a DenseMatrix
 
+ Singular Value Decomposition (SVD) of a DenseMatrix with the use of the DGESVD
+ driver from LAPACK.
+ */
 class DenseMatrixSVD
 {
    DenseMatrix Mc;
@@ -955,16 +960,129 @@ class DenseMatrixSVD
 
    void Init();
 public:
+
+   /**
+    @brief Constructor for the DenseMatrixSVD
+
+    Constructor for the DenseMatrixSVD with LAPACK. The parameters for the left
+    and right singular vectors can be choosen according to the parameters for
+    the LAPACK DGESVD.
+
+    @param [in] M matrix to set the size to n=M.Height(), m=M.Width()
+    @param [in] left_singular_vectors optional parameter to define if first
+    left singular vectors should be computed
+    @param [in] right_singular_vectors optional parameter to define if first
+    right singular vectors should be computed
+    */
+   MFEM_DEPRECATED DenseMatrixSVD(DenseMatrix &M,
+                                  bool left_singular_vectors=false,
+                                  bool right_singular_vectors=false);
+
+   /**
+    @brief Constructor for the DenseMatrixSVD
+
+    Constructor for the DenseMatrixSVD with LAPACK. The parameters for the left
+    and right singular
+    vectors can be choosen according to the parameters for the LAPACK DGESVD.
+
+    @param [in] h height of the matrix
+    @param [in] w width of the matrix
+    @param [in] left_singular_vectors optional parameter to define if first
+    left singular vectors should be computed
+    @param [in] right_singular_vectors optional parameter to define if first
+    right singular vectors should be computed
+    */
+   MFEM_DEPRECATED DenseMatrixSVD(int h, int w,
+                                  bool left_singular_vectors=false,
+                                  bool right_singular_vectors=false);
+
+   /**
+    @brief Constructor for the DenseMatrixSVD
+
+    Constructor for the DenseMatrixSVD with LAPACK. The parameters for the left
+    and right singular vectors can be choosen according to the parameters for
+    the LAPACK DGESVD.
+
+    @param [in] M matrix to set the size to n=M.Height(), m=M.Width()
+    @param [in] left_singular_vectors optional parameter to define which left
+    singular vectors should be computed
+    @param [in] right_singular_vectors optional parameter to define which right
+    singular vectors should be computed
+
+    Options for computation of singular vectors:
+
+    'A': All singular vectors are computed (default)
+
+    'S': The first min(n,m) singular vectors are computed
+
+    'N': No singular vectors are computed
+    */
    DenseMatrixSVD(DenseMatrix &M,
-                  bool left_singular_vectors=false,
-                  bool right_singlular_vectors=false);
+                  char left_singular_vectors='A',
+                  char right_singular_vectors='A');
+
+   /**
+    @brief Constructor for the DenseMatrixSVD
+
+    Constructor for the DenseMatrixSVD with LAPACK. The parameters for the left
+    and right singular vectors can be choosen according to the
+    parameters for the LAPACK DGESVD.
+
+    @param [in] h height of the matrix
+    @param [in] w width of the matrix
+    @param [in] left_singular_vectors optional parameter to define which left
+    singular vectors should be computed
+    @param [in] right_singular_vectors optional parameter to define which right
+    singular vectors should be computed
+
+    Options for computation of singular vectors:
+
+    'A': All singular vectors are computed (default)
+
+    'S': The first min(n,m) singular vectors are computed
+
+    'N': No singular vectors are computed
+    */
    DenseMatrixSVD(int h, int w,
-                  bool left_singular_vectors=false,
-                  bool right_singlular_vectors=false);
+                  char left_singular_vectors='A',
+                  char right_singular_vectors='A');
+
+   /**
+    @brief Evaluate the SVD
+
+    Call of the DGESVD driver from LAPACK for the DenseMatrix M. The singular
+    vectors are computed according to the setup in the call of the constructor.
+
+    @param [in] M DenseMatrix the SVD should be evaluated for
+    */
    void Eval(DenseMatrix &M);
+
+   /**
+    @brief Return singular values
+
+    @return sv Vector containing all singular values
+    */
    Vector &Singularvalues() { return sv; }
+
+   /**
+    @brief Return specific singular value
+
+    @return sv(i) i-th singular value
+    */
    double Singularvalue(int i) { return sv(i); }
+
+   /**
+    @brief Return left singular vectors
+
+    @return U DenseMatrix containing left singular vectors
+    */
    DenseMatrix &LeftSingularvectors() { return U; }
+
+   /**
+    @brief Return right singular vectors
+
+    @return Vt DenseMatrix containing right singular vectors
+    */
    DenseMatrix &RightSingularvectors() { return Vt; }
    ~DenseMatrixSVD();
 };
diff --git a/mesh/element.hpp b/mesh/element.hpp
index c37205eb1..2376c9dc3 100644
--- a/mesh/element.hpp
+++ b/mesh/element.hpp
@@ -57,12 +57,15 @@ public:
    /// Set element's attribute.
    inline void SetAttribute(const int attr) { attribute = attr; }
 
-   /// Set the indices the element according to the input.
-   virtual void SetVertices(const int *ind);
-
-   /// Returns element's vertices.
+   /// Get the indices defining the vertices
    virtual void GetVertices(Array<int> &v) const = 0;
 
+   /// Set the indices defining the vertices
+   virtual void SetVertices(const Array<int> &v) = 0;
+
+   /// Set the indices the element according to the input.
+   virtual void SetVertices(const int *ind) = 0;
+
    /// @note The returned array should NOT be deleted by the caller.
    virtual int *GetVertices() = 0;
 
diff --git a/mesh/hexahedron.cpp b/mesh/hexahedron.cpp
index beeab3b6a..e86e209c1 100644
--- a/mesh/hexahedron.cpp
+++ b/mesh/hexahedron.cpp
@@ -43,10 +43,18 @@ Hexahedron::Hexahedron(int ind1, int ind2, int ind3, int ind4,
 void Hexahedron::GetVertices(Array<int> &v) const
 {
    v.SetSize(8);
-   for (int i = 0; i < 8; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 8, v.begin());
+}
+
+void Hexahedron::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 8, "!");
+   std::copy(v.begin(), v.end(), indices);
+}
+
+void Hexahedron::SetVertices(const int *ind)
+{
+   std::copy(ind, ind + 8, indices);
 }
 
 TriLinear3DFiniteElement HexahedronFE;
diff --git a/mesh/hexahedron.hpp b/mesh/hexahedron.hpp
index a8186c0c8..450cac0ce 100644
--- a/mesh/hexahedron.hpp
+++ b/mesh/hexahedron.hpp
@@ -37,35 +37,42 @@ public:
               int ind5, int ind6, int ind7, int ind8, int attr = 1);
 
    /// Return element's type
-   Type GetType() const { return Element::HEXAHEDRON; }
+   Type GetType() const override { return Element::HEXAHEDRON; }
 
-   /// Returns the indices of the element's vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int GetNVertices() const { return 8; }
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int GetNEdges() const { return 12; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual const int *GetEdgeVertices(int ei) const
+   int GetNVertices() const override { return 8; }
+
+   int GetNEdges() const override { return 12; }
+
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 4; return 6; }
 
-   virtual int GetNFaces() const { return 6; }
+   int GetNFaces() const override { return 6; }
 
-   virtual int GetNFaceVertices(int) const { return 4; }
+   int GetNFaceVertices(int) const override { return 4; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Hexahedron(indices, attribute); }
 
-   virtual ~Hexahedron() { }
+   virtual ~Hexahedron() = default;
 };
 
 extern MFEM_EXPORT class TriLinear3DFiniteElement HexahedronFE;
diff --git a/mesh/mesh.cpp b/mesh/mesh.cpp
index b3b9ecc80..d4bb73a95 100644
--- a/mesh/mesh.cpp
+++ b/mesh/mesh.cpp
@@ -1110,6 +1110,7 @@ FaceElementTransformations *Mesh::GetBdrFaceTransformations(int BdrElemNo)
    {
       return NULL;
    }
+
    tr = GetFaceElementTransformations(fn, 21);
    tr->Attribute = boundary[BdrElemNo]->GetAttribute();
    tr->ElementNo = BdrElemNo;
@@ -1432,6 +1433,7 @@ Geometry::Type Mesh::GetFaceGeometry(int Face) const
          }
          // ghost face
          const int nc_face_id = faces_info[Face].NCFace;
+
          MFEM_ASSERT(nc_face_id >= 0, "parent ghost faces are not supported");
          return faces[nc_faces_info[nc_face_id].MasterFace]->GetGeometryType();
    }
@@ -1445,7 +1447,7 @@ Element::Type Mesh::GetFaceElementType(int Face) const
 
 Array<int> Mesh::GetFaceToBdrElMap() const
 {
-   Array<int> face_to_be(NumOfFaces);
+   Array<int> face_to_be(GetNumFaces());
    face_to_be = -1;
    for (int i = 0; i < NumOfBdrElements; i++)
    {
@@ -1907,14 +1909,11 @@ int Mesh::AddBdrPoint(int v, int attr)
 
 void Mesh::GenerateBoundaryElements()
 {
-   int i, j;
    Array<int> &be2face = (Dim == 2) ? be_to_edge : be_to_face;
 
-   // GenerateFaces();
-
-   for (i = 0; i < boundary.Size(); i++)
+   for (auto &b : boundary)
    {
-      FreeElement(boundary[i]);
+      FreeElement(b);
    }
 
    if (Dim == 3)
@@ -1925,14 +1924,14 @@ void Mesh::GenerateBoundaryElements()
 
    // count the 'NumOfBdrElements'
    NumOfBdrElements = 0;
-   for (i = 0; i < faces_info.Size(); i++)
+   for (const auto &fi : faces_info)
    {
-      if (faces_info[i].Elem2No < 0) { NumOfBdrElements++; }
+      if (fi.Elem2No < 0) { ++NumOfBdrElements; }
    }
 
    boundary.SetSize(NumOfBdrElements);
    be2face.SetSize(NumOfBdrElements);
-   for (j = i = 0; i < faces_info.Size(); i++)
+   for (int j = 0, i = 0; i < faces_info.Size(); ++i)
    {
       if (faces_info[i].Elem2No < 0)
       {
@@ -3753,8 +3752,8 @@ Mesh& Mesh::operator=(Mesh &&mesh)
    return *this;
 }
 
-Mesh Mesh::LoadFromFile(const char *filename, int generate_edges, int refine,
-                        bool fix_orientation)
+Mesh Mesh::LoadFromFile(const std::string &filename, int generate_edges,
+                        int refine, bool fix_orientation)
 {
    Mesh mesh;
    named_ifgzstream imesh(filename);
@@ -3808,7 +3807,7 @@ Mesh Mesh::MakeRefined(Mesh &orig_mesh, const Array<int> &ref_factors,
    return mesh;
 }
 
-Mesh::Mesh(const char *filename, int generate_edges, int refine,
+Mesh::Mesh(const std::string &filename, int generate_edges, int refine,
            bool fix_orientation)
 {
    // Initialization as in the default constructor
@@ -4391,7 +4390,7 @@ Mesh::Mesh(Mesh *orig_mesh, int ref_factor, int ref_type)
    MakeRefined_(*orig_mesh, ref_factors, ref_type);
 }
 
-void Mesh::MakeRefined_(Mesh &orig_mesh, const Array<int> ref_factors,
+void Mesh::MakeRefined_(Mesh &orig_mesh, const Array<int> &ref_factors,
                         int ref_type)
 {
    SetEmpty();
@@ -6004,22 +6003,22 @@ int Mesh::CheckBdrElementOrientation(bool fix_it)
             {
                // swap vertices 0 and 1 so that we don't change the marked edge:
                // (0,1,2) -> (1,0,2)
-               mfem::Swap<int>(bv[0], bv[1]);
+               std::swap(bv[0], bv[1]);
                if (bel_to_edge)
                {
                   int *be = bel_to_edge->GetRow(i);
-                  mfem::Swap<int>(be[1], be[2]);
+                  std::swap(be[1], be[2]);
                }
                break;
             }
             case Element::QUADRILATERAL:
             {
-               mfem::Swap<int>(bv[0], bv[2]);
+               std::swap(bv[0], bv[2]);
                if (bel_to_edge)
                {
                   int *be = bel_to_edge->GetRow(i);
-                  mfem::Swap<int>(be[0], be[1]);
-                  mfem::Swap<int>(be[2], be[3]);
+                  std::swap(be[0], be[1]);
+                  std::swap(be[2], be[3]);
                }
                break;
             }
@@ -6735,9 +6734,9 @@ void Mesh::AddQuadFaceElement(int lf, int gf, int el,
 
 void Mesh::GenerateFaces()
 {
-   int i, nfaces = GetNumFaces();
+   int nfaces = GetNumFaces();
 
-   for (i = 0; i < faces.Size(); i++)
+   for (int i = 0; i < faces.Size(); ++i)
    {
       FreeElement(faces[i]);
    }
@@ -6745,16 +6744,17 @@ void Mesh::GenerateFaces()
    // (re)generate the interior faces and the info for them
    faces.SetSize(nfaces);
    faces_info.SetSize(nfaces);
-   for (i = 0; i < nfaces; i++)
+   for (int i = 0; i < nfaces; ++i)
    {
       faces[i] = NULL;
       faces_info[i].Elem1No = -1;
       faces_info[i].NCFace = -1;
    }
-   for (i = 0; i < NumOfElements; i++)
+
+   Array<int> v;
+   for (int i = 0; i < NumOfElements; ++i)
    {
-      const int *v = elements[i]->GetVertices();
-      const int *ef;
+      elements[i]->GetVertices(v);
       if (Dim == 1)
       {
          AddPointFaceElement(0, v[0], i);
@@ -6762,7 +6762,7 @@ void Mesh::GenerateFaces()
       }
       else if (Dim == 2)
       {
-         ef = el_to_edge->GetRow(i);
+         const int * const ef = el_to_edge->GetRow(i);
          const int ne = elements[i]->GetNEdges();
          for (int j = 0; j < ne; j++)
          {
@@ -6772,7 +6772,7 @@ void Mesh::GenerateFaces()
       }
       else
       {
-         ef = el_to_face->GetRow(i);
+         const int * const ef = el_to_face->GetRow(i);
          switch (GetElementType(i))
          {
             case Element::TETRAHEDRON:
@@ -6838,9 +6838,9 @@ void Mesh::GenerateNCFaceInfo()
 {
    MFEM_VERIFY(ncmesh, "missing NCMesh.");
 
-   for (int i = 0; i < faces_info.Size(); i++)
+   for (auto &x : faces_info)
    {
-      faces_info[i].NCFace = -1;
+      x.NCFace = -1;
    }
 
    const NCMesh::NCList &list =
@@ -6852,9 +6852,8 @@ void Mesh::GenerateNCFaceInfo()
    int nfaces = GetNumFaces();
 
    // add records for master faces
-   for (int i = 0; i < list.masters.Size(); i++)
+   for (const NCMesh::Master &master : list.masters)
    {
-      const NCMesh::Master &master = list.masters[i];
       if (master.index >= nfaces) { continue; }
 
       FaceInfo &master_fi = faces_info[master.index];
@@ -6866,10 +6865,8 @@ void Mesh::GenerateNCFaceInfo()
    }
 
    // add records for slave faces
-   for (int i = 0; i < list.slaves.Size(); i++)
+   for (const NCMesh::Slave &slave : list.slaves)
    {
-      const NCMesh::Slave &slave = list.slaves[i];
-
       if (slave.index < 0 || // degenerate slave face
           slave.index >= nfaces || // ghost slave
           slave.master >= nfaces) // has ghost master
@@ -6952,7 +6949,7 @@ STable3D *Mesh::GetFacesTable()
             break;
          }
          default:
-            MFEM_ABORT("Unexpected type of Element.");
+            MFEM_ABORT("Unexpected type of Element: " << GetElementType(i));
       }
    }
    return faces_tbl;
@@ -6960,7 +6957,7 @@ STable3D *Mesh::GetFacesTable()
 
 STable3D *Mesh::GetElementToFaceTable(int ret_ftbl)
 {
-   int i, *v;
+   Array<int> v;
    STable3D *faces_tbl;
 
    if (el_to_face != NULL)
@@ -6969,9 +6966,9 @@ STable3D *Mesh::GetElementToFaceTable(int ret_ftbl)
    }
    el_to_face = new Table(NumOfElements, 6);  // must be 6 for hexahedra
    faces_tbl = new STable3D(NumOfVertices);
-   for (i = 0; i < NumOfElements; i++)
+   for (int i = 0; i < NumOfElements; i++)
    {
-      v = elements[i]->GetVertices();
+      elements[i]->GetVertices(v);
       switch (GetElementType(i))
       {
          case Element::TETRAHEDRON:
@@ -7035,9 +7032,10 @@ STable3D *Mesh::GetElementToFaceTable(int ret_ftbl)
    el_to_face->Finalize();
    NumOfFaces = faces_tbl->NumberOfElements();
    be_to_face.SetSize(NumOfBdrElements);
-   for (i = 0; i < NumOfBdrElements; i++)
+
+   for (int i = 0; i < NumOfBdrElements; i++)
    {
-      v = boundary[i]->GetVertices();
+      boundary[i]->GetVertices(v);
       switch (GetBdrElementType(i))
       {
          case Element::TRIANGLE:
@@ -10471,7 +10469,7 @@ void Mesh::PrintTopo(std::ostream &os,const Array<int> &e_to_k) const
    os << "\nvertices\n" << NumOfVertices << '\n';
 }
 
-void Mesh::Save(const char *fname, int precision) const
+void Mesh::Save(const std::string &fname, int precision) const
 {
    ofstream ofs(fname);
    ofs.precision(precision);
diff --git a/mesh/mesh.hpp b/mesh/mesh.hpp
index fa73b8279..532777422 100644
--- a/mesh/mesh.hpp
+++ b/mesh/mesh.hpp
@@ -568,7 +568,7 @@ protected:
    void Make1D(int n, double sx = 1.0);
 
    /// Internal function used in Mesh::MakeRefined
-   void MakeRefined_(Mesh &orig_mesh, const Array<int> ref_factors,
+   void MakeRefined_(Mesh &orig_mesh, const Array<int> &ref_factors,
                      int ref_type);
 
    /// Initialize vertices/elements/boundary/tables from a nonconforming mesh.
@@ -646,8 +646,8 @@ public:
    /** Creates mesh by reading a file in MFEM, Netgen, or VTK format. If
        generate_edges = 0 (default) edges are not generated, if 1 edges are
        generated. See also @a Mesh::LoadFromFile. */
-   explicit Mesh(const char *filename, int generate_edges = 0, int refine = 1,
-                 bool fix_orientation = true);
+   explicit Mesh(const std::string &filename, int generate_edges = 0,
+                 int refine = 1, bool fix_orientation = true);
 
    /** Creates mesh by reading data stream in MFEM, Netgen, or VTK format. If
        generate_edges = 0 (default) edges are not generated, if 1 edges are
@@ -700,7 +700,7 @@ public:
        @note @a filename is not cached by the Mesh object and can be
        safely deleted following this function call.
    */
-   static Mesh LoadFromFile(const char *filename,
+   static Mesh LoadFromFile(const std::string &filename,
                             int generate_edges = 0, int refine = 1,
                             bool fix_orientation = true);
 
@@ -1167,6 +1167,14 @@ public:
    /// the Element object itself should not be deleted by the caller.
    Element *GetBdrElement(int i) { return boundary[i]; }
 
+   inline int GetNCMasterFaceIndex(int i) const
+   {
+      MFEM_ASSERT(i < nc_faces_info.Size() &&
+                  i >= 0, i << " not in [0, " << nc_faces_info.Size() << ")");
+      const auto &ncf = nc_faces_info[i];
+      MFEM_VERIFY(ncf.Slave, "If the master face is requested, must be slave");
+      return ncf.MasterFace;
+   }
    const Element *GetFace(int i) const { return faces[i]; }
 
    /// @}
@@ -1655,7 +1663,7 @@ public:
                           };
 
    /** @brief This structure is used as a human readable output format that
-       decipheres the information contained in Mesh::FaceInfo when using the
+       deciphers the information contained in Mesh::FaceInfo when using the
        Mesh::GetFaceInformation() method.
 
        The element indices in this structure don't need further processing,
@@ -2006,7 +2014,7 @@ public:
 
    /// Save the mesh to a file using Mesh::Print. The given @a precision will be
    /// used for ASCII output.
-   virtual void Save(const char *fname, int precision=16) const;
+   virtual void Save(const std::string &fname, int precision=16) const;
 
    /// Print the mesh to the given stream using the adios2 bp format
 #ifdef MFEM_USE_ADIOS2
diff --git a/mesh/ncmesh.cpp b/mesh/ncmesh.cpp
index d15dbed23..550e104dd 100644
--- a/mesh/ncmesh.cpp
+++ b/mesh/ncmesh.cpp
@@ -2176,9 +2176,9 @@ void NCMesh::UpdateVertices()
    //   - ghost (non-local) vertices (code -3)
    //   - vertices beyond the ghost layer (code -4)
 
-   for (auto node = nodes.begin(); node != nodes.end(); ++node)
+   for (auto & node : nodes)
    {
-      node->vert_index = -4; // assume beyond ghost layer
+      node.vert_index = -4; // assume beyond ghost layer
    }
 
    for (int i = 0; i < leaf_elements.Size(); i++)
@@ -2208,11 +2208,11 @@ void NCMesh::UpdateVertices()
    // STEP 2: assign indices of top-level local vertices, in original order
 
    NVertices = 0;
-   for (auto node = nodes.begin(); node != nodes.end(); ++node)
+   for (auto &node : nodes)
    {
-      if (node->vert_index == -1)
+      if (node.vert_index == -1)
       {
-         node->vert_index = NVertices++;
+         node.vert_index = NVertices++;
       }
    }
 
@@ -2308,20 +2308,20 @@ void NCMesh::UpdateVertices()
       }
 
       vertex_nodeId.SetSize(NVertices);
-      for (auto node = nodes.begin(); node != nodes.end(); ++node)
+      for (auto &node : nodes)
       {
-         if (node->HasVertex() && node->vert_index >= 0)
+         if (node.HasVertex() && node.vert_index >= 0)
          {
-            vertex_nodeId[node->vert_index] = node.index();
+            vertex_nodeId[node.vert_index] = node.index();
          }
       }
 
       NGhostVertices = 0;
-      for (auto node = nodes.begin(); node != nodes.end(); ++node)
+      for (auto &node : nodes)
       {
-         if (node->HasVertex() && node->vert_index < 0)
+         if (node.HasVertex() && node.vert_index < 0)
          {
-            node->vert_index = NVertices + (NGhostVertices++);
+            node.vert_index = NVertices + (NGhostVertices++);
          }
       }
    }
@@ -2449,18 +2449,21 @@ void NCMesh::GetMeshComponents(Mesh &mesh) const
    // left uninitialized here; they will be initialized later by the Mesh from
    // Nodes -- here we just make sure mesh.vertices has the correct size.
 
-   for (int i = 0; i < mesh.NumOfElements; i++)
+   for (auto elem : mesh.elements)
    {
-      mesh.FreeElement(mesh.elements[i]);
+      mesh.FreeElement(elem);
    }
    mesh.elements.SetSize(0);
 
-   for (int i = 0; i < mesh.NumOfBdrElements; i++)
+   for (auto elem : mesh.boundary)
    {
-      mesh.FreeElement(mesh.boundary[i]);
+      mesh.FreeElement(elem);
    }
    mesh.boundary.SetSize(0);
 
+   // Save off boundary face vertices to make boundary elements later.
+   std::map<int, mfem::Array<int>> unique_boundary_faces;
+
    // create an mfem::Element for each leaf Element
    for (int i = 0; i < NElements; i++)
    {
@@ -2478,65 +2481,83 @@ void NCMesh::GetMeshComponents(Mesh &mesh) const
          elem->GetVertices()[j] = nodes[node[j]].vert_index;
       }
 
-      // create boundary elements
-      // TODO: use boundary_faces?
-      for (int k = 0; k < gi.nf; k++)
+      // Loop over faces and collect those marked as boundaries
+      for (int k = 0; k < gi.nf; ++k)
       {
-         const int* fv = gi.faces[k];
          const int nfv = gi.nfv[k];
-         const Face* face = faces.Find(node[fv[0]], node[fv[1]],
-                                       node[fv[2]], node[fv[3]]);
-         if (face->Boundary())
+         const int * const fv = gi.faces[k];
+         const auto id = faces.FindId(node[fv[0]], node[fv[1]], node[fv[2]],
+                                      node[fv[3]]);
+         if (id >= 0 && faces[id].Boundary())
          {
-            if ((nc_elem.geom == Geometry::CUBE) ||
-                ((nc_elem.geom == Geometry::PRISM ||
-                  nc_elem.geom == Geometry::PYRAMID) && nfv == 4))
-            {
-               auto* quad = (Quadrilateral*) mesh.NewElement(Geometry::SQUARE);
-               quad->SetAttribute(face->attribute);
-               for (int j = 0; j < 4; j++)
-               {
-                  quad->GetVertices()[j] = nodes[node[fv[j]]].vert_index;
-               }
-               mesh.boundary.Append(quad);
-            }
-            else if (nc_elem.geom == Geometry::PRISM ||
-                     nc_elem.geom == Geometry::PYRAMID ||
-                     nc_elem.geom == Geometry::TETRAHEDRON)
+            const auto &face = faces[id];
+            if (face.elem[0] >= 0 && face.elem[1] >= 0 &&
+                nc_elem.rank != std::min(elements[face.elem[0]].rank,
+                                         elements[face.elem[1]].rank))
             {
-               MFEM_ASSERT(nfv == 3, "");
-               auto* tri = (Triangle*) mesh.NewElement(Geometry::TRIANGLE);
-               tri->SetAttribute(face->attribute);
-               for (int j = 0; j < 3; j++)
-               {
-                  tri->GetVertices()[j] = nodes[node[fv[j]]].vert_index;
-               }
-               mesh.boundary.Append(tri);
+               // This is a conformal internal face, but this element is not the lowest
+               // ranking attached processor, thus not the owner of the face.
+               // Consequently, we do not add this face to avoid double
+               // counting.
+               continue;
             }
-            else if (nc_elem.geom == Geometry::SQUARE ||
-                     nc_elem.geom == Geometry::TRIANGLE)
+
+            // Add in all boundary faces that are actual boundaries or not masters of another face.
+            // The fv[2] in the edge split is on purpose.
+            if ((nfv == 4 &&
+                 QuadFaceNotMaster(node[fv[0]], node[fv[1]], node[fv[2]], node[fv[3]]))
+                || (nfv == 3 && TriFaceNotMaster(node[fv[0]], node[fv[1]], node[fv[2]]))
+                || (nfv == 2 &&
+                    EdgeSplitLevel(node[fv[0]], node[fv[2]] /* [2] not an error */) == 0))
             {
-               auto* segment = (Segment*) mesh.NewElement(Geometry::SEGMENT);
-               segment->SetAttribute(face->attribute);
-               for (int j = 0; j < 2; j++)
+               // This face has no split faces below, it is conformal or a
+               // slave.
+               unique_boundary_faces[id].SetSize(nfv);
+               for (int v = 0; v < nfv; ++v)
                {
-                  segment->GetVertices()[j] = nodes[node[fv[2*j]]].vert_index;
+                  // Using a map overwrites if a face is visited twice.
+                  // The nfv==2 is necessary because faces of 2D are storing the
+                  // second index in the 2 slot, not the 1 slot.
+                  unique_boundary_faces[id][v] = nodes[node[fv[(nfv==2) ? 2*v : v]]].vert_index;
                }
-               mesh.boundary.Append(segment);
-            }
-            else
-            {
-               MFEM_ASSERT(nc_elem.geom == Geometry::SEGMENT, "");
-               auto* point = (mfem::Point*) mesh.NewElement(Geometry::POINT);
-               point->SetAttribute(face->attribute);
-               point->GetVertices()[0] = nodes[node[fv[0]]].vert_index;
-               mesh.boundary.Append(point);
             }
          }
       }
    }
+
+   auto geom_from_nfv = [](int nfv)
+   {
+      switch (nfv)
+      {
+         case 1: return Geometry::POINT;
+         case 2: return Geometry::SEGMENT;
+         case 3: return Geometry::TRIANGLE;
+         case 4: return Geometry::SQUARE;
+      }
+      return Geometry::INVALID;
+   };
+
+   for (const auto &fv : unique_boundary_faces)
+   {
+      const auto f = fv.first;
+      const auto &v = fv.second;
+      const auto &face = faces.At(f);
+
+      auto geom = geom_from_nfv(v.Size());
+
+      MFEM_ASSERT(geom != Geometry::INVALID,
+                  "nfv: " << v.Size() <<
+                  " does not match a valid face geometry: Quad, Tri, Segment, Point");
+
+      // Add a new boundary element, with matching attribute and vertices
+      mesh.boundary.Append(mesh.NewElement(geom));
+      auto * const be = mesh.boundary.Last();
+      be->SetAttribute(face.attribute);
+      be->SetVertices(v);
+   }
 }
 
+
 void NCMesh::OnMeshUpdated(Mesh *mesh)
 {
    //// PART 1: pull indices of regular edges/faces from the Mesh
@@ -2545,13 +2566,13 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
    NFaces = mesh->GetNumFaces();
    if (Dim < 2) { NFaces = 0; }
    // clear Node::edge_index and Face::index
-   for (auto node = nodes.begin(); node != nodes.end(); ++node)
+   for (auto &node : nodes)
    {
-      if (node->HasEdge()) { node->edge_index = -1; }
+      if (node.HasEdge()) { node.edge_index = -1; }
    }
-   for (auto face = faces.begin(); face != faces.end(); ++face)
+   for (auto &face : faces)
    {
-      face->index = -1;
+      face.index = -1;
    }
 
    // get edge enumeration from the Mesh
@@ -2615,19 +2636,19 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
 
    // count ghost edges and assign their indices
    NGhostEdges = 0;
-   for (auto node = nodes.begin(); node != nodes.end(); ++node)
+   for (auto &node : nodes)
    {
-      if (node->HasEdge() && node->edge_index < 0)
+      if (node.HasEdge() && node.edge_index < 0)
       {
-         node->edge_index = NEdges + (NGhostEdges++);
+         node.edge_index = NEdges + (NGhostEdges++);
       }
    }
 
    // count ghost faces
    NGhostFaces = 0;
-   for (auto face = faces.begin(); face != faces.end(); ++face)
+   for (auto &face : faces)
    {
-      if (face->index < 0) { NGhostFaces++; }
+      if (face.index < 0) { NGhostFaces++; }
    }
 
    if (Dim == 2)
@@ -2651,13 +2672,14 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
       for (int j = 0; j < gi.nf; j++)
       {
          const int *fv = gi.faces[j];
-         Face* face = faces.Find(el.node[fv[0]], el.node[fv[1]],
-                                 el.node[fv[2]], el.node[fv[3]]);
-         MFEM_ASSERT(face, "face not found!");
+         int fid = faces.FindId(el.node[fv[0]], el.node[fv[1]],
+                                el.node[fv[2]], el.node[fv[3]]);
+         MFEM_ASSERT(fid >= 0, "face not found!");
+         auto &face = faces[fid];
 
-         if (face->index < 0)
+         if (face.index < 0)
          {
-            face->index = NFaces + (nghosts++);
+            face.index = NFaces + (nghosts++);
 
             // store the face geometry
             static const Geometry::Type types[5] =
@@ -2665,15 +2687,15 @@ void NCMesh::OnMeshUpdated(Mesh *mesh)
                Geometry::INVALID, Geometry::INVALID,
                Geometry::SEGMENT, Geometry::TRIANGLE, Geometry::SQUARE
             };
-            face_geom[face->index] = types[gi.nfv[j]];
+            face_geom[face.index] = types[gi.nfv[j]];
          }
       }
    }
 
    // assign valid indices also to faces beyond the ghost layer
-   for (auto face = faces.begin(); face != faces.end(); ++face)
+   for (auto &face : faces)
    {
-      if (face->index < 0) { face->index = NFaces + (nghosts++); }
+      if (face.index < 0) { face.index = NFaces + (nghosts++); }
    }
    MFEM_ASSERT(nghosts == NGhostFaces, "");
 }
@@ -2741,7 +2763,7 @@ bool NCMesh::TriFaceSplit(int v1, int v2, int v3, int mid[3]) const
 
    if (mid) { mid[0] = e1, mid[1] = e2, mid[2] = e3; }
 
-   // NOTE: face (v1, v2, v3) still needs to be checked
+   // This is necessary but not sufficient to determine if a face has been split.
    return true;
 }
 
@@ -3452,7 +3474,7 @@ const NCMesh::MeshId& NCMesh::NCList::LookUp(int index, int *type) const
 
    if (!type)
    {
-      MFEM_VERIFY(key >= 0, "entity not found.");
+      MFEM_VERIFY(key >= 0, "index " << index << " not found.");
    }
    else // return entity type if requested, don't abort when not found
    {
@@ -5195,9 +5217,8 @@ void NCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
    {
       GetFaceList(); // make sure 'boundary_faces' is up to date
 
-      for (int i = 0; i < boundary_faces.Size(); i++)
+      for (int face : boundary_faces)
       {
-         int face = boundary_faces[i];
          if (bdr_attr_is_ess[faces[face].attribute - 1])
          {
             int node[4];
@@ -5226,9 +5247,8 @@ void NCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
    {
       GetEdgeList(); // make sure 'boundary_faces' is up to date
 
-      for (int i = 0; i < boundary_faces.Size(); i++)
+      for (int face : boundary_faces)
       {
-         int face = boundary_faces[i];
          Face &fc = faces[face];
          if (bdr_attr_is_ess[fc.attribute - 1])
          {
@@ -5245,18 +5265,35 @@ void NCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
    bdr_edges.Unique();
 }
 
-static int max4(int a, int b, int c, int d)
-{
-   return std::max(std::max(a, b), std::max(c, d));
-}
-static int max6(int a, int b, int c, int d, int e, int f)
+namespace
 {
-   return std::max(max4(a, b, c, d), std::max(e, f));
-}
-static int max8(int a, int b, int c, int d, int e, int f, int g, int h)
+/**
+ * @brief Base case of convenience variadic max function.
+ *
+ * @tparam T Base type
+ * @param arg Recursion base value
+ * @return T value to max over
+ */
+template<typename T>
+T max(T&& arg)
+{
+   return arg;
+}
+/**
+ * @brief Convenience variadic max function.
+ *
+ * @tparam T Base Type
+ * @tparam Ts Parameter pack of other types
+ * @param arg Singular argument
+ * @param args Pack of arguments
+ * @return T maximum value
+ */
+template<typename T, typename... Ts>
+T max(T arg, Ts... args)
 {
-   return std::max(max4(a, b, c, d), max4(e, f, g, h));
+   return std::max(std::forward<T>(arg), max(args...));
 }
+} // namespace
 
 int NCMesh::EdgeSplitLevel(int vn1, int vn2) const
 {
@@ -5271,15 +5308,13 @@ int NCMesh::TriFaceSplitLevel(int vn1, int vn2, int vn3) const
    if (TriFaceSplit(vn1, vn2, vn3, mid) &&
        faces.FindId(vn1, vn2, vn3) < 0)
    {
-      return 1 + max4(TriFaceSplitLevel(vn1, mid[0], mid[2]),
-                      TriFaceSplitLevel(mid[0], vn2, mid[1]),
-                      TriFaceSplitLevel(mid[2], mid[1], vn3),
-                      TriFaceSplitLevel(mid[0], mid[1], mid[2]));
-   }
-   else // not split
-   {
-      return 0;
+      return 1 + max(TriFaceSplitLevel(vn1, mid[0], mid[2]),
+                     TriFaceSplitLevel(mid[0], vn2, mid[1]),
+                     TriFaceSplitLevel(mid[2], mid[1], vn3),
+                     TriFaceSplitLevel(mid[0], mid[1], mid[2]));
    }
+
+   return 0; // not split
 }
 
 void NCMesh::QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4,
@@ -5309,6 +5344,13 @@ void NCMesh::QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4,
    }
 }
 
+int NCMesh::QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4) const
+{
+   int h_level, v_level;
+   QuadFaceSplitLevel(vn1, vn2, vn3, vn4, h_level, v_level);
+   return h_level + v_level;
+}
+
 void NCMesh::CountSplits(int elem, int splits[3]) const
 {
    const Element &el = elements[elem];
@@ -5345,57 +5387,52 @@ void NCMesh::CountSplits(int elem, int splits[3]) const
 
    if (el.Geom() == Geometry::CUBE)
    {
-      splits[0] = max8(flevel[0][0], flevel[1][0], flevel[3][0], flevel[5][0],
-                       elevel[0], elevel[2], elevel[4], elevel[6]);
+      splits[0] = max(flevel[0][0], flevel[1][0], flevel[3][0], flevel[5][0],
+                      elevel[0], elevel[2], elevel[4], elevel[6]);
 
-      splits[1] = max8(flevel[0][1], flevel[2][0], flevel[4][0], flevel[5][1],
-                       elevel[1], elevel[3], elevel[5], elevel[7]);
+      splits[1] = max(flevel[0][1], flevel[2][0], flevel[4][0], flevel[5][1],
+                      elevel[1], elevel[3], elevel[5], elevel[7]);
 
-      splits[2] = max8(flevel[1][1], flevel[2][1], flevel[3][1], flevel[4][1],
-                       elevel[8], elevel[9], elevel[10], elevel[11]);
+      splits[2] = max(flevel[1][1], flevel[2][1], flevel[3][1], flevel[4][1],
+                      elevel[8], elevel[9], elevel[10], elevel[11]);
    }
    else if (el.Geom() == Geometry::PRISM)
    {
-      splits[0] = splits[1] =
-                     std::max(
-                        max6(flevel[0][0], flevel[1][0], 0,
-                             flevel[2][0], flevel[3][0], flevel[4][0]),
-                        max6(elevel[0], elevel[1], elevel[2],
-                             elevel[3], elevel[4], elevel[5]));
+      splits[0] = splits[1] = max(flevel[0][0], flevel[1][0], 0,
+                                  flevel[2][0], flevel[3][0], flevel[4][0],
+                                  elevel[0], elevel[1], elevel[2],
+                                  elevel[3], elevel[4], elevel[5]);
 
-      splits[2] = max6(flevel[2][1], flevel[3][1], flevel[4][1],
-                       elevel[6], elevel[7], elevel[8]);
+      splits[2] = max(flevel[2][1], flevel[3][1], flevel[4][1],
+                      elevel[6], elevel[7], elevel[8]);
    }
    else if (el.Geom() == Geometry::PYRAMID)
    {
-      splits[0] = std::max(
-                     max6(flevel[0][0], flevel[1][0], 0,
-                          flevel[2][0], flevel[3][0], flevel[4][0]),
-                     max8(elevel[0], elevel[1], elevel[2],
-                          elevel[3], elevel[4], elevel[5],
-                          elevel[6], elevel[7]));
+      splits[0] = max(flevel[0][0], flevel[1][0], 0,
+                      flevel[2][0], flevel[3][0], flevel[4][0],
+                      elevel[0], elevel[1], elevel[2],
+                      elevel[3], elevel[4], elevel[5],
+                      elevel[6], elevel[7]);
 
       splits[1] = splits[0];
       splits[2] = splits[0];
    }
    else if (el.Geom() == Geometry::TETRAHEDRON)
    {
-      splits[0] = std::max(
-                     max4(flevel[0][0], flevel[1][0], flevel[2][0], flevel[3][0]),
-                     max6(elevel[0], elevel[1], elevel[2],
-                          elevel[3], elevel[4], elevel[5]));
+      splits[0] = max(flevel[0][0], flevel[1][0], flevel[2][0], flevel[3][0],
+                      elevel[0], elevel[1], elevel[2], elevel[3], elevel[4], elevel[5]);
 
       splits[1] = splits[0];
       splits[2] = splits[0];
    }
    else if (el.Geom() == Geometry::SQUARE)
    {
-      splits[0] = std::max(elevel[0], elevel[2]);
-      splits[1] = std::max(elevel[1], elevel[3]);
+      splits[0] = max(elevel[0], elevel[2]);
+      splits[1] = max(elevel[1], elevel[3]);
    }
    else if (el.Geom() == Geometry::TRIANGLE)
    {
-      splits[0] = std::max(elevel[0], std::max(elevel[1], elevel[2]));
+      splits[0] = max(elevel[0], elevel[1], elevel[2]);
       splits[1] = splits[0];
    }
    else
@@ -6368,17 +6405,17 @@ void NCMesh::DebugDump(std::ostream &os) const
 
    // dump faces
    os << faces.Size() << "\n";
-   for (auto face = faces.cbegin(); face != faces.cend(); ++face)
+   for (const auto &face : faces)
    {
-      int elem = face->elem[0];
-      if (elem < 0) { elem = face->elem[1]; }
+      int elem = face.elem[0];
+      if (elem < 0) { elem = face.elem[1]; }
       MFEM_ASSERT(elem >= 0, "");
       const Element &el = elements[elem];
 
       int lf = find_local_face(el.Geom(),
-                               find_node(el, face->p1),
-                               find_node(el, face->p2),
-                               find_node(el, face->p3));
+                               find_node(el, face.p1),
+                               find_node(el, face.p2),
+                               find_node(el, face.p3));
 
       const int* fv = GI[el.Geom()].faces[lf];
       const int nfv = GI[el.Geom()].nfv[lf];
@@ -6388,7 +6425,7 @@ void NCMesh::DebugDump(std::ostream &os) const
       {
          os << " " << el.node[fv[i]];
       }
-      //os << " # face " << face.index() << ", index " << face->index << "\n";
+      //os << " # face " << face.index() << ", index " << face.index << "\n";
       os << "\n";
    }
 }
diff --git a/mesh/ncmesh.hpp b/mesh/ncmesh.hpp
index ddd423bfa..227aa4152 100644
--- a/mesh/ncmesh.hpp
+++ b/mesh/ncmesh.hpp
@@ -412,7 +412,6 @@ protected: // non-public interface for the Mesh class
        by calling Mesh::SetCurvature or otherwise setting the Nodes. */
    void MakeTopologyOnly() { coordinates.DeleteAll(); }
 
-
 protected: // implementation
 
    int Dim, spaceDim; ///< dimensions of the elements and the vertex coordinates
@@ -550,7 +549,6 @@ protected: // implementation
 
    Table element_vertex; ///< leaf-element to vertex table, see FindSetNeighbors
 
-
    /// Update the leaf elements indices in leaf_elements
    void UpdateLeafElements();
 
@@ -668,10 +666,79 @@ protected: // implementation
 
    mfem::Element* NewMeshElement(int geom) const;
 
-   int QuadFaceSplitType(int v1, int v2, int v3, int v4, int mid[5]
+   /**
+    * @brief Given a quad face defined by four vertices, establish which edges
+    * of this face have been split, and if so optionally return the mid points
+    * of those edges.
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @param n4 The fourth node defining the face
+    * @param mid optional return of the edge mid points.
+    * @return int 0 -- no split, 1 -- "vertical" split, 2 -- "horizontal" split
+    */
+   int QuadFaceSplitType(int n1, int n2, int n3, int n4, int mid[5]
                          = NULL /*optional output of mid-edge nodes*/) const;
 
-   bool TriFaceSplit(int v1, int v2, int v3, int mid[3] = NULL) const;
+   /**
+    * @brief Given a tri face defined by three vertices, establish whether the
+    * edges that make up this face have been split, and if so optionally return
+    * the midpoints.
+    * @details This is a necessary condition for this face to have been split,
+    * but is not sufficient. Consider a triangle attached to three refined
+    * triangles, in this scenario all edges can be split but this face not be
+    * split. In this case, it is necessary to check if there is a face made up
+    * of the returned midpoint nodes.
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @param mid optional return of the edge mid points.
+    * @return true Splits for all edges have been found
+    * @return false
+    */
+   bool TriFaceSplit(int n1, int n2, int n3, int mid[3] = NULL) const;
+
+   /**
+    * @brief Determine if a Triangle face is not a master
+    * @details This check requires looking for the edges making up the triangle
+    * being split, if nodes exist at their midpoints, and there are vertices at
+    * them, this implies the face COULD be split. To determine if it is, we then
+    * check whether these midpoints have all been connected, this is required to
+    * discriminate between an internal master face surrounded by nonconformal
+    * refinements and a conformal boundary face surrounded by refinements.
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @return true The face is not a master
+    * @return false The face is a master
+    */
+   inline bool TriFaceNotMaster(int n1, int n2, int n3) const
+   {
+      int mid[3];
+      return !TriFaceSplit(n1, n2, n3, mid) // The edges aren't split
+             // OR none of the midpoints are connected.
+             || (nodes.FindId(mid[0], mid[1]) < 0 &&
+                 nodes.FindId(mid[0], mid[2]) < 0 &&
+                 nodes.FindId(mid[1], mid[2]) < 0);
+   }
+
+   /**
+    * @brief Determine if  a Quad face is not a master
+    *
+    * @param n1 The first node defining the face
+    * @param n2 The second node defining the face
+    * @param n3 The third node defining the face
+    * @param n4 The fourth node defining the face
+    * @return true The quad face is not a master
+    * @return false The quad face is a master
+    */
+   inline bool QuadFaceNotMaster(int n1, int n2, int n3, int n4) const
+   {
+      return QuadFaceSplitType(n1, n2, n3, n4) == 0;
+   }
 
    void ForceRefinement(int vn1, int vn2, int vn3, int vn4);
 
@@ -932,9 +999,7 @@ protected: // implementation
    void InitDerefTransforms();
    void SetDerefMatrixCodes(int parent, Array<int> &fine_coarse);
 
-
    // vertex temporary data, used by GetMeshComponents
-
    struct TmpVertex
    {
       bool valid, visited;
@@ -953,10 +1018,56 @@ protected: // implementation
 
    void FindFaceNodes(int face, int node[4]);
 
+   /**
+    * @brief Return the number of splits of this edge that have occurred in the
+    * NCMesh. If zero, this means the segment is not the master of any other segments.
+    *
+    * @param vn1 The first vertex making up the segment
+    * @param vn2 The second vertex making up the segment
+    * @return int The depth of splits of this segment that are present in the mesh.
+    */
    int EdgeSplitLevel(int vn1, int vn2) const;
+   /**
+    * @brief Return the number of splits of this triangle that have occurred in
+    * the NCMesh. If zero, this means the triangle is neither split, nor the
+    * master of a split face.
+    *
+    * @param vn1 The first vertex making up the triangle
+    * @param vn2 The second vertex making up the triangle
+    * @param vn3 The third vertex making up the triangle
+    * @return int The depth of splits of this triangle that are present in the mesh.
+    */
    int TriFaceSplitLevel(int vn1, int vn2, int vn3) const;
+   /**
+    * @brief Computes the number of horizontal and vertical splits of this quad
+    * that have occurred in the NCMesh. If zero, this means the quad is not
+    * the master of any other quad.
+    *
+    * @param vn1 The first vertex making up the quad
+    * @param vn2 The second vertex making up the quad
+    * @param vn3 The third vertex making up the quad
+    * @param vn4 The fourth vertex making up the quad
+    * @param h_level The number of "horizontal" splits of the quad
+    * @param v_level The number of "vertical" splits of the quad
+    */
    void QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4,
                            int& h_level, int& v_level) const;
+   /**
+    * @brief Returns the total number of splits of this quad that have occurred
+    * in the NCMesh. If zero, this means the quad is not
+    * the master of any other quad.
+    * @details This is a convenience wrapper that sums the horizontal and
+    * vertical levels from the full method.
+    *
+    * @param vn1 The first vertex making up the quad
+    * @param vn2 The second vertex making up the quad
+    * @param vn3 The third vertex making up the quad
+    * @param vn4 The fourth vertex making up the quad
+    * @return int The depth of splits of this triangle that are present in the
+    * mesh. NB: An isotropic refinement has a level of 2, one horizontal split,
+    * followed by a vertical split.
+    */
+   int QuadFaceSplitLevel(int vn1, int vn2, int vn3, int vn4) const;
 
    void CountSplits(int elem, int splits[3]) const;
    void GetLimitRefinements(Array<Refinement> &refinements, int max_level);
@@ -993,7 +1104,6 @@ protected: // implementation
    /// Load the deprecated MFEM mesh v1.1 format for backward compatibility.
    void LoadLegacyFormat(std::istream &input, int &curved, int &is_nc);
 
-
    // geometry
 
    /// This holds in one place the constants about the geometries we support
diff --git a/mesh/pmesh.cpp b/mesh/pmesh.cpp
index c39098f82..545a8af8f 100644
--- a/mesh/pmesh.cpp
+++ b/mesh/pmesh.cpp
@@ -34,7 +34,6 @@ ParMesh::ParMesh(const ParMesh &pmesh, bool copy_nodes)
      group_sedge(pmesh.group_sedge),
      group_stria(pmesh.group_stria),
      group_squad(pmesh.group_squad),
-     face_nbr_el_to_face(NULL),
      glob_elem_offset(-1),
      glob_offset_sequence(-1),
      gtopo(pmesh.gtopo)
@@ -106,8 +105,7 @@ ParMesh& ParMesh::operator=(ParMesh &&mesh)
 
 ParMesh::ParMesh(MPI_Comm comm, Mesh &mesh, int *partitioning_,
                  int part_method)
-   : face_nbr_el_to_face(NULL)
-   , glob_elem_offset(-1)
+   : glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(comm)
 {
@@ -352,11 +350,8 @@ int ParMesh::BuildLocalVertices(const mfem::Mesh &mesh,
 int ParMesh::BuildLocalElements(const Mesh& mesh, const int* partitioning,
                                 const Array<int>& vert_global_local)
 {
-   int nelems = 0;
-   for (int i = 0; i < mesh.GetNE(); i++)
-   {
-      if (partitioning[i] == MyRank) { nelems++; }
-   }
+   const int nelems = std::count_if(partitioning,
+   partitioning + mesh.GetNE(), [this](int i) { return i == MyRank;});
 
    elements.SetSize(nelems);
 
@@ -375,7 +370,7 @@ int ParMesh::BuildLocalElements(const Mesh& mesh, const int* partitioning,
          {
             v[j] = vert_global_local[v[j]];
          }
-         element_counter++;
+         ++element_counter;
       }
    }
 
@@ -388,7 +383,6 @@ int ParMesh::BuildLocalBoundary(const Mesh& mesh, const int* partitioning,
                                 Table*& edge_element)
 {
    int nbdry = 0;
-
    if (mesh.NURBSext)
    {
       activeBdrElem.SetSize(mesh.GetNBE());
@@ -856,7 +850,6 @@ ParMesh::ParMesh(const ParNCMesh &pncmesh)
    : MyComm(pncmesh.MyComm)
    , NRanks(pncmesh.NRanks)
    , MyRank(pncmesh.MyRank)
-   , face_nbr_el_to_face(NULL)
    , glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(MyComm)
@@ -908,7 +901,7 @@ void ParMesh::FinalizeParTopo()
    sface_lface.SetSize(nst + shared_quads.Size());
    if (sface_lface.Size())
    {
-      STable3D *faces_tbl = GetFacesTable();
+      auto faces_tbl = std::unique_ptr<STable3D>(GetFacesTable());
       for (int st = 0; st < nst; st++)
       {
          const int *v = shared_trias[st].v;
@@ -919,13 +912,11 @@ void ParMesh::FinalizeParTopo()
          const int *v = shared_quads[sq].v;
          sface_lface[nst+sq] = (*faces_tbl)(v[0], v[1], v[2], v[3]);
       }
-      delete faces_tbl;
    }
 }
 
 ParMesh::ParMesh(MPI_Comm comm, istream &input, bool refine)
-   : face_nbr_el_to_face(NULL)
-   , glob_elem_offset(-1)
+   : glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(comm)
 {
@@ -1136,7 +1127,7 @@ void ParMesh::MakeRefined_(ParMesh &orig_mesh, int ref_factor, int ref_type)
    MyComm = orig_mesh.GetComm();
    NRanks = orig_mesh.GetNRanks();
    MyRank = orig_mesh.GetMyRank();
-   face_nbr_el_to_face = NULL;
+   face_nbr_el_to_face = nullptr;
    glob_elem_offset = -1;
    glob_offset_sequence = -1;
    gtopo = orig_mesh.gtopo;
@@ -2126,11 +2117,14 @@ void ParMesh::ExchangeFaceNbrData()
 
    if (Nonconforming())
    {
-      // with ParNCMesh we can set up face neighbors without communication
+      // with ParNCMesh we can set up face neighbors mostly without communication
       pncmesh->GetFaceNeighbors(*this);
       have_face_nbr_data = true;
 
-      ExchangeFaceNbrNodes();
+      // Internal boundary elements with an NC mesh requires extra "ghost
+      // boundary element" information for enforcing essential boundaries.
+      pncmesh->ComputeGhostBoundaryElements(*this);
+
       return;
    }
 
@@ -2195,7 +2189,7 @@ void ParMesh::ExchangeFaceNbrData()
 
    if (Dim == 3)
    {
-      GetFaceNbrElementToFaceTable();
+      BuildFaceNbrElementToFaceTable();
    }
 
    if (del_tables) { delete gr_sface; }
@@ -2323,6 +2317,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
    el_marker = -1;
    vertex_marker = -1;
    const int nst = shared_trias.Size();
+
    for (int fn = 0; fn < num_face_nbrs; fn++)
    {
       int nbr_group = face_nbr_group[fn];
@@ -2460,8 +2455,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
 
    // convert the element data into face_nbr_elements
    face_nbr_elements.SetSize(face_nbr_elements_offset[num_face_nbrs]);
-   face_nbr_el_ori.Clear();
-   face_nbr_el_ori.SetSize(face_nbr_elements_offset[num_face_nbrs], 6);
+   face_nbr_el_ori.reset(new Table(face_nbr_elements_offset[num_face_nbrs], 6));
    while (true)
    {
       int fn;
@@ -2492,7 +2486,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
          if (Dim == 3)
          {
             int nf = el->GetNFaces();
-            int * fn_ori = face_nbr_el_ori.GetRow(elem_off);
+            int * fn_ori = face_nbr_el_ori->GetRow(elem_off);
             for (int j = 0; j < nf; j++)
             {
                fn_ori[j] = recv_elemdata[j];
@@ -2502,7 +2496,7 @@ void ParMesh::ExchangeFaceNbrData(Table *gr_sface, int *s2l_face)
          face_nbr_elements[elem_off++] = el;
       }
    }
-   face_nbr_el_ori.Finalize();
+   face_nbr_el_ori->Finalize();
 
    MPI_Waitall(num_face_nbrs, send_requests, statuses);
 
@@ -2724,191 +2718,118 @@ STable3D *ParMesh::GetSharedFacesTable()
    return sfaces_tbl;
 }
 
-STable3D *ParMesh::GetFaceNbrElementToFaceTable(int ret_ftbl)
+template <int N>
+void
+ParMesh::AddTriFaces(const Array<int> &elem_vertices,
+                     const std::unique_ptr<STable3D> &faces,
+                     const std::unique_ptr<STable3D> &shared_faces,
+                     int elem, int start, int end, const int fverts[][N])
 {
-   int i, *v;
-   STable3D * faces_tbl = GetFacesTable();
-   STable3D * sfaces_tbl = GetSharedFacesTable();
-
-   if (face_nbr_el_to_face != NULL)
+   for (int i = start; i < end; ++i)
    {
-      delete face_nbr_el_to_face;
+      // Reference face vertices.
+      const auto fv = fverts[i];
+      // Element specific face vertices.
+      const Vert3 elem_fv(elem_vertices[fv[0]], elem_vertices[fv[1]],
+                          elem_vertices[fv[2]]);
+
+      // Check amongst the faces of elements local to this rank for this set of vertices
+      const int lf = faces->Index(elem_fv.v[0], elem_fv.v[1], elem_fv.v[2]);
+
+      // If the face wasn't found amonst processor local elements, search the
+      // ghosts for this set of vertices.
+      const int sf = lf < 0 ? shared_faces->Index(elem_fv.v[0], elem_fv.v[1],
+                                                  elem_fv.v[2]) : -1;
+      // If find local face -> use that
+      //    else if find shared face -> shift and use that
+      //       else no face found -> set to -1
+      const int face_to_add = lf < 0 ? (sf >= 0 ? sf + NumOfFaces : -1) : lf;
+
+      MFEM_ASSERT(sf >= 0 ||
+                  lf >= 0, "Face must be from a local or a face neighbor element");
+
+      // Add this discovered face to the list of faces of this face neighbor element
+      face_nbr_el_to_face->Push(elem, face_to_add);
    }
-   face_nbr_el_to_face = new Table(face_nbr_elements.Size(), 6);
-   for (i = 0; i < face_nbr_elements.Size(); i++)
+}
+
+void ParMesh::BuildFaceNbrElementToFaceTable()
+{
+   const auto faces = std::unique_ptr<STable3D>(GetFacesTable());
+   const auto shared_faces = std::unique_ptr<STable3D>(GetSharedFacesTable());
+
+   face_nbr_el_to_face.reset(new Table(face_nbr_elements.Size(), 6));
+
+   mfem::Array<int> v;
+
+   // Helper for adding quadrilateral faces.
+   auto add_quad_faces = [&faces, &shared_faces, &v, this]
+                         (int elem, int start, int end, const int fverts[][4])
    {
-      v = face_nbr_elements[i]->GetVertices();
-      switch (face_nbr_elements[i]->GetType())
+      for (int i = start; i < end; ++i)
       {
-         case Element::TETRAHEDRON:
+         const int * const fv = fverts[i];
+         int k = 0;
+         int max = v[fv[0]];
+
+         if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
+         if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
+         if (max < v[fv[3]]) { k = 3; }
+
+         int v0 = -1, v1 = -1, v2 = -1;
+         switch (k)
          {
-            for (int j = 0; j < 4; j++)
+            case 0:
+               v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
+               break;
+            case 1:
+               v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
+               break;
+            case 2:
+               v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
+               break;
+            case 3:
+               v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
+               break;
+         }
+         int lf = faces->Index(v0, v1, v2);
+         if (lf < 0)
+         {
+            lf = shared_faces->Index(v0, v1, v2);
+            if (lf >= 0)
             {
-               const int *fv = tet_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
+               lf += NumOfFaces;
             }
+         }
+         face_nbr_el_to_face->Push(elem, lf);
+      }
+   };
+
+   for (int i = 0; i < face_nbr_elements.Size(); i++)
+   {
+      face_nbr_elements[i]->GetVertices(v);
+      switch (face_nbr_elements[i]->GetType())
+      {
+         case Element::TETRAHEDRON:
+         {
+            AddTriFaces(v, faces, shared_faces, i, 0, 4, tet_t::FaceVert);
             break;
          }
          case Element::WEDGE:
          {
-            for (int j = 0; j < 2; j++)
-            {
-               const int *fv = pri_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
-            for (int j = 2; j < 5; j++)
-            {
-               const int *fv = pri_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            AddTriFaces(v, faces, shared_faces, i, 0, 2, pri_t::FaceVert);
+            add_quad_faces(i, 2, 5, pri_t::FaceVert);
             break;
          }
          case Element::PYRAMID:
          {
-            for (int j = 0; j < 1; j++)
-            {
-               const int *fv = pyr_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
-            for (int j = 1; j < 5; j++)
-            {
-               const int *fv = pyr_t::FaceVert[j];
-               int lf = faces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v[fv[0]], v[fv[1]], v[fv[2]]);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            add_quad_faces(i, 0, 1, pyr_t::FaceVert);
+            AddTriFaces(v, faces, shared_faces, i, 1, 5, pyr_t::FaceVert);
             break;
          }
          case Element::HEXAHEDRON:
          {
-            // find the face by the vertices with the smallest 3 numbers
-            // z = 0, y = 0, x = 1, y = 1, x = 0, z = 1
-            for (int j = 0; j < 6; j++)
-            {
-               const int *fv = hex_t::FaceVert[j];
-               int k = 0;
-               int max = v[fv[0]];
-
-               if (max < v[fv[1]]) { max = v[fv[1]], k = 1; }
-               if (max < v[fv[2]]) { max = v[fv[2]], k = 2; }
-               if (max < v[fv[3]]) { k = 3; }
-
-               int v0 = -1, v1 = -1, v2 = -1;
-               switch (k)
-               {
-                  case 0:
-                     v0 = v[fv[1]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 1:
-                     v0 = v[fv[0]]; v1 = v[fv[2]]; v2 = v[fv[3]];
-                     break;
-                  case 2:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[3]];
-                     break;
-                  case 3:
-                     v0 = v[fv[0]]; v1 = v[fv[1]]; v2 = v[fv[2]];
-                     break;
-               }
-               int lf = faces_tbl->Index(v0, v1, v2);
-               if (lf < 0)
-               {
-                  lf = sfaces_tbl->Index(v0, v1, v2);
-                  if (lf >= 0)
-                  {
-                     lf += NumOfFaces;
-                  }
-               }
-               face_nbr_el_to_face->Push(i, lf);
-            }
+            add_quad_faces(i, 0, 6, hex_t::FaceVert);
             break;
          }
          default:
@@ -2916,14 +2837,6 @@ STable3D *ParMesh::GetFaceNbrElementToFaceTable(int ret_ftbl)
       }
    }
    face_nbr_el_to_face->Finalize();
-
-   delete sfaces_tbl;
-   if (ret_ftbl)
-   {
-      return faces_tbl;
-   }
-   delete faces_tbl;
-   return NULL;
 }
 
 int ParMesh::GetFaceNbrRank(int fn) const
@@ -2944,33 +2857,31 @@ int ParMesh::GetFaceNbrRank(int fn) const
 }
 
 void
-ParMesh::GetFaceNbrElementFaces(int i, Array<int> &fcs, Array<int> &cor) const
+ParMesh::GetFaceNbrElementFaces(int i, Array<int> &faces,
+                                Array<int> &orientations) const
 {
-   int n, j;
    int el_nbr = i - GetNE();
-   if (face_nbr_el_to_face)
+   if (face_nbr_el_to_face != nullptr && el_nbr < face_nbr_el_to_face->Size())
    {
-      face_nbr_el_to_face->GetRow(el_nbr, fcs);
+      face_nbr_el_to_face->GetRow(el_nbr, faces);
    }
    else
    {
       MFEM_ABORT("ParMesh::GetFaceNbrElementFaces(...) : "
                  "face_nbr_el_to_face not generated.");
    }
-   if (el_nbr < face_nbr_el_ori.Size())
+
+   if (face_nbr_el_ori != nullptr && el_nbr < face_nbr_el_ori->Size())
    {
-      const int * row = face_nbr_el_ori.GetRow(el_nbr);
-      n = fcs.Size();
-      cor.SetSize(n);
-      for (j=0; j<n; j++)
-      {
-         cor[j] = row[j];
-      }
+      face_nbr_el_ori->GetRow(el_nbr, orientations);
    }
    else
    {
-      MFEM_ABORT("ParMesh::GetFaceNbrElementFaces(...) : "
-                 "face_nbr_el_to_face not generated.");
+      // No face_nbr_el_ori was generated, make the orientations invalid.
+      // This will cause errors if the face orientations are necessary to
+      // evaluate the basis in face neighbor elements.
+      orientations.SetSize(faces.Size());
+      orientations = -1;
    }
 }
 
@@ -3230,7 +3141,7 @@ int ParMesh::GetSharedFace(int sface) const
    {
       MFEM_ASSERT(Dim > 1, "");
       const NCMesh::NCList &shared = pncmesh->GetSharedList(Dim-1);
-      int csize = (int) shared.conforming.Size();
+      int csize = shared.conforming.Size();
       return sface < csize
              ? shared.conforming[sface].index
              : shared.slaves[sface - csize].index;
@@ -4596,7 +4507,7 @@ void ParMesh::UniformRefinement3D()
 
    DSTable v_to_v(NumOfVertices);
    GetVertexToVertexTable(v_to_v);
-   STable3D *faces_tbl = GetFacesTable();
+   auto faces_tbl = std::unique_ptr<STable3D>(GetFacesTable());
 
    // call Mesh::UniformRefinement3D_base so that it won't update the nodes
    Array<int> f2qf;
@@ -4611,7 +4522,6 @@ void ParMesh::UniformRefinement3D()
    // update the groups
    UniformRefineGroups3D(old_nv, old_nedges, v_to_v, *faces_tbl,
                          f2qf.Size() ? &f2qf : NULL);
-   delete faces_tbl;
 
    UpdateNodes();
 }
@@ -4955,7 +4865,7 @@ void ParMesh::Print(std::ostream &os) const
    }
 }
 
-void ParMesh::Save(const char *fname, int precision) const
+void ParMesh::Save(const std::string &fname, int precision) const
 {
    ostringstream fname_with_suffix;
    fname_with_suffix << fname << "." << setfill('0') << setw(6) << MyRank;
@@ -5618,7 +5528,7 @@ Mesh ParMesh::GetSerialMesh(int save_rank) const
    return serialmesh;
 }
 
-void ParMesh::SaveAsOne(const char *fname, int precision) const
+void ParMesh::SaveAsOne(const std::string &fname, int precision) const
 {
    ofstream ofs;
    if (MyRank == 0)
@@ -6511,7 +6421,7 @@ static void PrintVertex(const Vertex &v, int space_dim, ostream &os)
    }
 }
 
-void ParMesh::PrintSharedEntities(const char *fname_prefix) const
+void ParMesh::PrintSharedEntities(const std::string &fname_prefix) const
 {
    stringstream out_name;
    out_name << fname_prefix << '_' << setw(5) << setfill('0') << MyRank
@@ -6713,6 +6623,8 @@ void ParMesh::Swap(ParMesh &other)
    mfem::Swap(face_nbr_vertices, other.face_nbr_vertices);
    mfem::Swap(send_face_nbr_elements, other.send_face_nbr_elements);
    mfem::Swap(send_face_nbr_vertices, other.send_face_nbr_vertices);
+   std::swap(face_nbr_el_ori, other.face_nbr_el_ori);
+   std::swap(face_nbr_el_to_face, other.face_nbr_el_to_face);
 
    // Nodes, NCMesh, and NURBSExtension are taken care of by Mesh::Swap
    mfem::Swap(pncmesh, other.pncmesh);
@@ -6733,8 +6645,7 @@ void ParMesh::Destroy()
    }
    shared_edges.DeleteAll();
 
-   delete face_nbr_el_to_face;
-   face_nbr_el_to_face = NULL;
+   face_nbr_el_to_face = nullptr;
 }
 
 ParMesh::~ParMesh()
diff --git a/mesh/pmesh.hpp b/mesh/pmesh.hpp
index af65a992c..4a1092985 100644
--- a/mesh/pmesh.hpp
+++ b/mesh/pmesh.hpp
@@ -77,8 +77,11 @@ protected:
    // sface ids: all triangles first, then all quads
    Array<int> sface_lface;
 
-   Table *face_nbr_el_to_face;
-   Table  face_nbr_el_ori; // orientations for each face (from nbr processor)
+   /// Table that maps from face neighbor element number, to the face numbers of
+   /// that element.
+   std::unique_ptr<Table> face_nbr_el_to_face;
+   /// orientations for each face (from nbr processor)
+   std::unique_ptr<Table> face_nbr_el_ori;
 
    IsoparametricTransformation FaceNbrTransformation;
 
@@ -115,7 +118,32 @@ protected:
    bool DecodeFaceSplittings(HashTable<Hashed2> &v_to_v, const int *v,
                              const Array<unsigned> &codes, int &pos);
 
-   STable3D *GetFaceNbrElementToFaceTable(int ret_ftbl = 0);
+   // Given a completed FacesTable and SharedFacesTable, construct a table that
+   // maps from face neighbor element number, to the set of faces of that
+   // element. Store the resulting data in the member variable
+   // face_nbr_el_to_face. If the mesh is nonconforming, this also builds the
+   // the face_nbr_el_ori variable from the faces_info.
+   void BuildFaceNbrElementToFaceTable();
+
+   /**
+    * @brief Helper function for adding triangle face neighbor element to face
+    * table entries. Have to use a template here rather than lambda capture
+    * because the FaceVert entries in Geometry have inner size of 3 for tets and
+    * 4 for everything else.
+    *
+    * @tparam N Inner dimension on the fvert variable, 3 for tet, 4 otherwise
+    * @param v Set of vertices for this element
+    * @param faces Table of faces interior to this rank
+    * @param shared_faces Table of faces shared by this rank and another
+    * @param elem The face neighbor element
+    * @param start Starting index into fverts
+    * @param end End index into fverts
+    * @param fverts Array of face vertices for this particular geometry.
+    */
+   template <int N>
+   void AddTriFaces(const Array<int> &v, const std::unique_ptr<STable3D> &faces,
+                    const std::unique_ptr<STable3D> &shared_faces,
+                    int elem, int start, int end, const int fverts[][N]);
 
    void GetFaceNbrElementTransformation(
       int i, IsoparametricTransformation *ElTr);
@@ -289,7 +317,7 @@ protected:
 
 public:
    /// Default constructor. Create an empty @a ParMesh.
-   ParMesh() : MyComm(0), NRanks(0), MyRank(-1), face_nbr_el_to_face(NULL),
+   ParMesh() : MyComm(0), NRanks(0), MyRank(-1),
       glob_elem_offset(-1), glob_offset_sequence(-1),
       have_face_nbr_data(false), pncmesh(NULL) { }
 
@@ -467,7 +495,8 @@ public:
    int GetFaceNbrRank(int fn) const;
 
    /** Similar to Mesh::GetElementFaces */
-   void GetFaceNbrElementFaces(int i, Array<int> &fcs, Array<int> &cor) const;
+   void GetFaceNbrElementFaces(int i, Array<int> &faces,
+                               Array<int> &orientation) const;
 
    /** Similar to Mesh::GetFaceToElementTable with added face-neighbor elements
        with indices offset by the local number of elements. */
@@ -557,6 +586,8 @@ public:
    /// Return the local face index for the given shared face.
    int GetSharedFace(int sface) const;
 
+
+
    /** @brief Returns the number of local faces according to the requested type,
        does not count master non-conforming faces.
 
@@ -598,7 +629,7 @@ public:
    /// given suffixes according to the MPI rank. The mesh will be written to the
    /// files using ParMesh::Print. The given @a precision will be used for ASCII
    /// output.
-   void Save(const char *fname, int precision=16) const override;
+   void Save(const std::string &fname, int precision=16) const override;
 
 #ifdef MFEM_USE_ADIOS2
    /** Print the part of the mesh in the calling processor using adios2 bp
@@ -627,7 +658,7 @@ public:
 
    /// Save the mesh as a single file (using ParMesh::PrintAsOne). The given
    /// @a precision is used for ASCII output.
-   void SaveAsOne(const char *fname, int precision=16) const;
+   void SaveAsOne(const std::string &fname, int precision=16) const;
 
    /// Old mesh format (Netgen/Truegrid) version of 'PrintAsOne'
    void PrintAsOneXG(std::ostream &out = mfem::out);
@@ -665,7 +696,7 @@ public:
                   InverseElementTransformation *inv_trans = NULL) override;
 
    /// Debugging method
-   void PrintSharedEntities(const char *fname_prefix) const;
+   void PrintSharedEntities(const std::string &fname_prefix) const;
 
    virtual ~ParMesh();
 
diff --git a/mesh/pncmesh.cpp b/mesh/pncmesh.cpp
index 4a14d0c1d..edddf1ce6 100644
--- a/mesh/pncmesh.cpp
+++ b/mesh/pncmesh.cpp
@@ -16,10 +16,12 @@
 #include "mesh_headers.hpp"
 #include "pncmesh.hpp"
 #include "../general/binaryio.hpp"
+#include "../general/communication.hpp"
 
 #include <numeric> // std::accumulate
 #include <map>
 #include <climits> // INT_MIN, INT_MAX
+#include <array>
 
 namespace mfem
 {
@@ -435,25 +437,21 @@ void ParNCMesh::CreateGroups(int nentities, Array<Connection> &index_rank,
    entity_group = 0;
 
    CommGroup group;
-   group.reserve(128);
 
-   int begin = 0, end = 0;
-   while (begin < index_rank.Size())
+   for (auto begin = index_rank.begin(); begin != index_rank.end(); /* nothing */)
    {
-      int index = index_rank[begin].from;
-      if (index >= nentities)
-      {
-         break; // probably creating entity_conf_group (no ghosts)
-      }
-      while (end < index_rank.Size() && index_rank[end].from == index)
-      {
-         end++;
-      }
-      group.resize(end - begin);
-      for (int i = begin; i < end; i++)
-      {
-         group[i - begin] = index_rank[i].to;
-      }
+      const auto &index = begin->from;
+      if (index >= nentities) { break; }
+
+      // Locate the next connection that is not from this index
+      const auto end = std::find_if(begin, index_rank.end(),
+      [&index](const mfem::Connection &c) { return c.from != index;});
+
+      // For each connection from this index, collect the ranks connected.
+      group.resize(std::distance(begin, end));
+      std::transform(begin, end, group.begin(), [](const mfem::Connection &c) { return c.to; });
+
+      // assign this entity's group and advance the search start
       entity_group[index] = GetGroupId(group);
       begin = end;
    }
@@ -461,9 +459,9 @@ void ParNCMesh::CreateGroups(int nentities, Array<Connection> &index_rank,
 
 void ParNCMesh::AddConnections(int entity, int index, const Array<int> &ranks)
 {
-   for (int i = 0; i < ranks.Size(); i++)
+   for (auto rank : ranks)
    {
-      entity_index_rank[entity].Append(Connection(index, ranks[i]));
+      entity_index_rank[entity].Append(Connection(index, rank));
    }
 }
 
@@ -480,9 +478,8 @@ void ParNCMesh::CalculatePMatrixGroups()
    ranks.Reserve(256);
 
    // connect slave edges to master edges and their vertices
-   for (int i = 0; i < shared_edges.masters.Size(); i++)
+   for (const auto &master_edge : shared_edges.masters)
    {
-      const Master &master_edge = shared_edges.masters[i];
       ranks.SetSize(0);
       for (int j = master_edge.slaves_begin; j < master_edge.slaves_end; j++)
       {
@@ -502,9 +499,8 @@ void ParNCMesh::CalculatePMatrixGroups()
    }
 
    // connect slave faces to master faces and their edges and vertices
-   for (int i = 0; i < shared_faces.masters.Size(); i++)
+   for (const auto &master_face : shared_faces.masters)
    {
-      const Master &master_face = shared_faces.masters[i];
       ranks.SetSize(0);
       for (int j = master_face.slaves_begin; j < master_face.slaves_end; j++)
       {
@@ -581,17 +577,17 @@ void ParNCMesh::CalcFaceOrientations()
    face_orient.SetSize(NFaces);
    face_orient = 0;
 
-   for (auto face = faces.begin(); face != faces.end(); ++face)
+   for (auto face : faces)
    {
-      if (face->elem[0] >= 0 && face->elem[1] >= 0 && face->index < NFaces)
+      if (face.elem[0] >= 0 && face.elem[1] >= 0 && face.index < NFaces)
       {
-         Element *e1 = &elements[face->elem[0]];
-         Element *e2 = &elements[face->elem[1]];
+         Element *e1 = &elements[face.elem[0]];
+         Element *e2 = &elements[face.elem[1]];
 
          if (e1->rank == e2->rank) { continue; }
          if (e1->rank > e2->rank) { std::swap(e1, e2); }
 
-         face_orient[face->index] = get_face_orientation(*face, *e1, *e2);
+         face_orient[face.index] = get_face_orientation(face, *e1, *e2);
       }
    }
 }
@@ -602,16 +598,16 @@ void ParNCMesh::GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
 {
    NCMesh::GetBoundaryClosure(bdr_attr_is_ess, bdr_vertices, bdr_edges);
 
-   int i, j;
    // filter out ghost vertices
-   for (i = j = 0; i < bdr_vertices.Size(); i++)
+   int j = 0;
+   for (int i = j = 0; i < bdr_vertices.Size(); i++)
    {
       if (bdr_vertices[i] < NVertices) { bdr_vertices[j++] = bdr_vertices[i]; }
    }
    bdr_vertices.SetSize(j);
 
    // filter out ghost edges
-   for (i = j = 0; i < bdr_edges.Size(); i++)
+   for (int i = j = 0; i < bdr_edges.Size(); i++)
    {
       if (bdr_edges[i] < NEdges) { bdr_edges[j++] = bdr_edges[i]; }
    }
@@ -893,6 +889,7 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
 
    Array<Element*> fnbr;
    Array<Connection> send_elems;
+   std::map<int, std::vector<int>> recv_elems;
 
    // Counts the number of slave faces of a master. This may be larger than the
    // number of shared slaves if there exist degenerate slave-faces from face-edge constraints.
@@ -907,8 +904,13 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
    fnbr.Reserve(bound);
    send_elems.Reserve(bound);
 
+   // If there are face neighbor elements with triangular faces, the
+   // `face_nbr_el_ori` structure will need to be built. This requires
+   // communication so we attempt to avoid it by checking first.
+   bool face_nbr_w_tri_faces = false;
+
    // go over all shared faces and collect face neighbor elements
-   for (int i = 0; i < shared.conforming.Size(); i++)
+   for (int i = 0; i < shared.conforming.Size(); ++i)
    {
       const MeshId &cf = shared.conforming[i];
       Face* face = GetFace(elements[cf.element], cf.local);
@@ -920,8 +922,12 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
       if (e[0]->rank == MyRank) { std::swap(e[0], e[1]); }
       MFEM_ASSERT(e[0]->rank != MyRank && e[1]->rank == MyRank, "");
 
+      face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[0]->geom));
+      face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[1]->geom));
+
       fnbr.Append(e[0]);
       send_elems.Append(Connection(e[0]->rank, e[1]->index));
+      recv_elems[e[0]->rank].push_back(e[0]->index);
    }
 
    for (int i = 0; i < shared.masters.Size(); i++)
@@ -944,8 +950,12 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
          }
          if (loc0) { std::swap(e[0], e[1]); }
 
+         face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[0]->geom));
+         face_nbr_w_tri_faces |= !Geometry::IsTensorProduct(Geometry::Type(e[1]->geom));
+
          fnbr.Append(e[0]);
          send_elems.Append(Connection(e[0]->rank, e[1]->index));
+         recv_elems[e[0]->rank].push_back(e[0]->index);
       }
    }
 
@@ -1028,6 +1038,13 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
    send_elems.Sort();
    send_elems.Unique();
 
+   for (auto &kv : recv_elems)
+   {
+      std::sort(kv.second.begin(), kv.second.end());
+      kv.second.erase(std::unique(kv.second.begin(), kv.second.end()),
+                      kv.second.end());
+   }
+
    for (int i = 0, last_rank = -1; i < send_elems.Size(); i++)
    {
       Connection &c = send_elems[i];
@@ -1181,10 +1198,173 @@ void ParNCMesh::GetFaceNeighbors(ParMesh &pmesh)
       }
    }
 
+
+   // In 3D some extra orientation data structures can be needed.
+   if (Dim == 3)
+   {
+      // Populates face_nbr_el_to_face, always needed.
+      pmesh.BuildFaceNbrElementToFaceTable();
+
+      if (face_nbr_w_tri_faces)
+      {
+         // There are face neighbor elements with triangular faces, need to
+         // perform communication to ensure the orientation is valid.
+         using RankToOrientation = std::map<int, std::vector<std::array<int, 6>>>;
+         constexpr std::array<int, 6> unset_ori{{-1,-1,-1,-1,-1,-1}};
+         const int rank = pmesh.GetMyRank();
+
+         // Loop over send elems, compute the orientation and place in the buffer to
+         // send to each processor. Note elements are lexicographically sorted
+         // with rank and element number, and this ordering holds across processors.
+         RankToOrientation send_rank_to_face_neighbor_orientations;
+         Array<int> orientations, faces;
+
+         // send_elems goes from rank of the receiving processor, to the index
+         // of the face neighbor element on this processor.
+         for (const auto &se : send_elems)
+         {
+            const auto &true_rank = pmesh.face_nbr_group[se.from];
+            pmesh.GetElementFaces(se.to, faces, orientations);
+
+            // Place a new entry of unset orientations
+            send_rank_to_face_neighbor_orientations[true_rank].emplace_back(unset_ori);
+
+            // Copy the entries, any unset faces will remain -1.
+            std::copy(orientations.begin(), orientations.end(),
+                      send_rank_to_face_neighbor_orientations[true_rank].back().begin());
+         }
+
+         // Initialize the receive buffers and resize to match the expected
+         // number of elements coming in. The copy ensures the appropriate rank
+         // pairings are in place, and for a purely conformal interface, the
+         // resize is a no-op.
+         auto recv_rank_to_face_neighbor_orientations =
+            send_rank_to_face_neighbor_orientations;
+         for (auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            kv.second.resize(recv_elems[kv.first].size());
+         }
+
+         // For asynchronous send/recv, will use arrays of requests to monitor the
+         // status of the connections.
+         std::vector<MPI_Request> send_requests, recv_requests;
+         std::vector<MPI_Status> status(nranks);
+
+         // NOTE: This is CRITICAL, to ensure the addresses of these requests
+         // do not change between the send/recv and the wait.
+         send_requests.reserve(nranks);
+         recv_requests.reserve(nranks);
+
+         // Shared face communication is bidirectional -> any rank to whom
+         // orientations must be sent, will need to send orientations back.
+         // The orientation data is contiguous because std::array<int,6> is an
+         // aggregate.
+
+         // Loop over each communication pairing, and dispatch the buffer loaded
+         // with  all the orientation data.
+         for (const auto &kv : send_rank_to_face_neighbor_orientations)
+         {
+            send_requests.emplace_back(); // instantiate a request for tracking.
+
+            // low rank sends on low, high rank sends on high.
+            const int send_tag = (rank < kv.first)
+                                 ? std::min(rank, kv.first)
+                                 : std::max(rank, kv.first);
+            MPI_Isend(&kv.second[0][0], int(kv.second.size() * 6),
+                      MPI_INT, kv.first, send_tag, pmesh.MyComm, &send_requests.back());
+         }
+
+         // Loop over the communication pairing again, and receive the
+         // symmetric buffer from the other processor.
+         for (auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            recv_requests.emplace_back(); // instantiate a request for tracking
+
+            // low rank receives on high, high rank receives on low.
+            const int recv_tag = (rank < kv.first)
+                                 ? std::max(rank, kv.first)
+                                 : std::min(rank, kv.first);
+            MPI_Irecv(&kv.second[0][0], int(kv.second.size() * 6),
+                      MPI_INT, kv.first, recv_tag, pmesh.MyComm, &recv_requests.back());
+         }
+
+         // Wait until all receive buffers are full before beginning to process.
+         MPI_Waitall(int(recv_requests.size()), recv_requests.data(), status.data());
+
+         pmesh.face_nbr_el_ori.reset(new Table(pmesh.face_nbr_elements.Size(), 6));
+         int elem = 0;
+         for (const auto &kv : recv_rank_to_face_neighbor_orientations)
+         {
+            // All elements associated to this face-neighbor rank
+            for (const auto &eo : kv.second)
+            {
+               std::copy(eo.begin(), eo.end(), pmesh.face_nbr_el_ori->GetRow(elem));
+               ++elem;
+            }
+         }
+         pmesh.face_nbr_el_ori->Finalize();
+
+         // Must wait for all send buffers to be released before the scope closes.
+         MPI_Waitall(int(send_requests.size()), send_requests.data(), status.data());
+      }
+   }
    // NOTE: this function skips ParMesh::send_face_nbr_vertices and
    // ParMesh::face_nbr_vertices_offset, these are not used outside of ParMesh
 }
 
+void ParNCMesh::ComputeGhostBoundaryElements(const ParMesh &mesh)
+{
+   // 1D cannot have ghost boundary elements
+   if (Dim == 1) { return; }
+
+   // ParNCMesh requires additional treatment of "ghost boundary elements" in
+   // the scenario where a parent face has only ghost children. A local mesh
+   // will fail to identify essential boundary conditions without the use of
+   // these ghost boundary elements, as they will not be added into the list of
+   // local boundary elements, whose masters will eventually be found.
+
+   ghost_boundary_elements.clear();
+   for (int n = NElements; n < NGhostElements + NElements; ++n)
+   {
+      const auto &nc_elem = elements[leaf_elements[n]];
+
+      const int * const node = nc_elem.node;
+      GeomInfo& gi = GI[(int) nc_elem.geom];
+
+      // Loop over faces and find those that are masters of internal boundaries
+      for (int k = 0; k < gi.nf; ++k)
+      {
+         const int * const fv = gi.faces[k];
+         const auto id = faces.FindId(node[fv[0]], node[fv[1]], node[fv[2]],
+                                      node[fv[3]]);
+
+         if (id >= 0 && faces[id].Boundary() && faces[id].index >= NFaces)
+         {
+            // Found a ghost face, and it is a boundary element.
+            // Need to check if it's a slave, and if it's internal.
+            const auto &face = faces[id];
+
+            // A conformal face
+            if (face.elem[0] >= 0 && face.elem[1] >= 0) { continue; }
+
+            // A ghost face not indexed by the mesh -> no useful information
+            if (face.index >= mesh.faces_info.Size()) { continue; }
+
+            MFEM_ASSERT(face.index >= 0, face.index);
+            const auto &finfo = mesh.faces_info[face.index];
+            if (mesh.IsSlaveFace(finfo)) // slave face
+            {
+               int master_face = mesh.GetNCMasterFaceIndex(finfo.NCFace);
+               if (master_face < mesh.GetNFaces())
+               {
+                  ghost_boundary_elements[face.attribute].insert(master_face);
+               }
+            }
+         }
+      }
+   }
+}
+
 void ParNCMesh::ClearAuxPM()
 {
    for (int i = 0; i < aux_pm_store.Size(); i++)
@@ -1825,10 +2005,9 @@ void ParNCMesh::RedistributeElements(Array<int> &new_ranks, int target_elements,
    NeighborElementRankMessage::RecvAll(recv_ghost_ranks, MyComm);
 
    // read new ranks for the ghost layer from messages received
-   NeighborElementRankMessage::Map::iterator it;
-   for (it = recv_ghost_ranks.begin(); it != recv_ghost_ranks.end(); ++it)
+   for (auto &kv : recv_ghost_ranks)
    {
-      NeighborElementRankMessage &msg = it->second;
+      NeighborElementRankMessage &msg = kv.second;
       for (int i = 0; i < msg.Size(); i++)
       {
          int ghost_index = elements[msg.elements[i]].index;
@@ -2355,9 +2534,8 @@ void ParNCMesh::AdjustMeshIds(Array<MeshId> ids[], int rank)
 
    // find vertices/edges of master faces shared with 'rank', and modify their
    // MeshIds so their element/local matches the element of the master face
-   for (int i = 0; i < shared_faces.masters.Size(); i++)
+   for (const MeshId &face_id : shared_faces.masters)
    {
-      const MeshId &face_id = shared_faces.masters[i];
       if (contains_rank[entity_pmat_group[2][face_id.index]])
       {
          int v[4], e[4], eo[4], pos, k;
diff --git a/mesh/pncmesh.hpp b/mesh/pncmesh.hpp
index ed919f14c..9c425b631 100644
--- a/mesh/pncmesh.hpp
+++ b/mesh/pncmesh.hpp
@@ -82,23 +82,23 @@ public:
    /** An override of NCMesh::Refine, which is called eventually, after making
        sure that refinements that occur on the processor boundary are sent to
        the neighbor processors so they can keep their ghost layers up to date.*/
-   virtual void Refine(const Array<Refinement> &refinements);
+   void Refine(const Array<Refinement> &refinements) override;
 
    /// Parallel version of NCMesh::LimitNCLevel.
-   virtual void LimitNCLevel(int max_nc_level);
+   void LimitNCLevel(int max_nc_level) override;
 
    /** Parallel version of NCMesh::CheckDerefinementNCLevel. */
-   virtual void CheckDerefinementNCLevel(const Table &deref_table,
-                                         Array<int> &level_ok, int max_nc_level);
+   void CheckDerefinementNCLevel(const Table &deref_table,
+                                 Array<int> &level_ok, int max_nc_level) override;
 
    /** Parallel reimplementation of NCMesh::Derefine, keeps ghost layers
        in sync. The interface is identical. */
-   virtual void Derefine(const Array<int> &derefs);
+   void Derefine(const Array<int> &derefs) override;
 
    /** Gets partitioning for the coarse mesh if the current fine mesh were to
        be derefined. */
-   virtual void GetFineToCoarsePartitioning(const Array<int> &derefs,
-                                            Array<int> &new_ranks) const;
+   void GetFineToCoarsePartitioning(const Array<int> &derefs,
+                                    Array<int> &new_ranks) const;
 
    /** Migrate leaf elements of the global refinement hierarchy (including ghost
        elements) so that each processor owns the same number of leaves (+-1).
@@ -108,15 +108,13 @@ public:
        passed. */
    void Rebalance(const Array<int> *custom_partition = NULL);
 
-
    // interface for ParFiniteElementSpace
-
    int GetNElements() const { return NElements; }
 
    int GetNGhostVertices() const { return NGhostVertices; }
    int GetNGhostEdges() const { return NGhostEdges; }
    int GetNGhostFaces() const { return NGhostFaces; }
-   int GetNGhostElements() const { return NGhostElements; }
+   int GetNGhostElements() const override { return NGhostElements; }
 
    // Return a list of vertices/edges/faces shared by this processor and at
    // least one other processor. These are subsets of NCMesh::<entity>_list. */
@@ -141,8 +139,8 @@ public:
       return (index < NFaces) ? face_orient[index] : 0;
    }
 
-   typedef short GroupId;
-   typedef std::vector<int> CommGroup;
+   using GroupId = short;
+   using CommGroup = std::vector<int>;
 
    /// Return vertex/edge/face ('entity' == 0/1/2, resp.) owner.
    GroupId GetEntityOwnerId(int entity, int index)
@@ -232,12 +230,12 @@ public:
 
    /** Extension of NCMesh::GetBoundaryClosure. Filters out ghost vertices and
        ghost edges from 'bdr_vertices' and 'bdr_edges'. */
-   virtual void GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
-                                   Array<int> &bdr_vertices,
-                                   Array<int> &bdr_edges);
+   void GetBoundaryClosure(const Array<int> &bdr_attr_is_ess,
+                           Array<int> &bdr_vertices,
+                           Array<int> &bdr_edges) override;
 
    /// Save memory by releasing all non-essential and cached data.
-   virtual void Trim();
+   void Trim() override;
 
    /// Return total number of bytes allocated.
    std::size_t MemoryUsage(bool with_base = true) const;
@@ -248,6 +246,17 @@ public:
        The debug mesh will have element attributes set to element rank + 1. */
    void GetDebugMesh(Mesh &debug_mesh) const;
 
+   /**
+    * @brief Get the Ghost Boundary Elements object, explicitly behind a const
+    * interface to avoid external modification. See ComputeGhostBoundaryElements
+    * for information on ghost boundary elements and their importance.
+    *
+    * @return std::map<int, std::set<int>> Container from boundary attribute
+    * value to set of codimension 1 objects that are parents of ghost
+    * children with this attribute.
+    */
+   std::map<int, std::set<int>> GetGhostBoundaryElements() const { return ghost_boundary_elements; }
+
 protected: // interface for ParMesh
 
    friend class ParMesh;
@@ -261,14 +270,42 @@ protected: // interface for ParMesh
        communication. */
    void GetFaceNeighbors(class ParMesh &pmesh);
 
+   /**
+    * @brief Given a ParMesh with all FaceNbrData computed, populate the
+    * ghost_boundary_elements.
+    * @details The ghost_boundary_elements container is accessed via
+    * GetGhostBoundaryElements, and represents a collection of parent faces that
+    * are coincident to a given boundary element, but whose child faces are all
+    * ghosts. Boundary elements must be child faces or conformal faces, in
+    * order to calculate functionals and boundary condition integrals. However,
+    * essential boundary conditions, must be imposed via the parent faces, in
+    * order to correctly constrain all face internal DOFs. This is accomplished
+    * by traversing from child faces to parent faces, but these dofs cannot be
+    * constrained if the parent face is a ghost.
+    *
+    * The corollary to this is that a parent face with only ghost children, will
+    * never be marked as part of an internal boundary during the usual boundary
+    * element traversal. Consequently, the ghost boundary elements keep track of
+    * these ghost boundary elements, by collecting them once the face neighbor
+    * data has been exchanged. A ParFiniteElementSpace is then able to loop over
+    * these DOF additionally during GetEssentialVDofs.
+    *
+    * NOTE: Users do not need to call this method, it will be called during
+    * ExchangeFaceNbrData once the relevant predicate information has been
+    * established.
+    *
+    * @param mesh The mesh for whom the ghost boundary elements should be
+    * established.
+    */
+   void ComputeGhostBoundaryElements(const ParMesh &mesh);
 
 protected: // implementation
 
    MPI_Comm MyComm;
    int NRanks;
 
-   typedef std::vector<CommGroup> GroupList;
-   typedef std::map<CommGroup, GroupId> GroupMap;
+   using GroupList = std::vector<CommGroup>;
+   using GroupMap = std::map<CommGroup, GroupId>;
 
    GroupList groups;  // comm group list; NOTE: groups[0] = { MyRank }
    GroupMap group_id; // search index over groups
@@ -299,7 +336,14 @@ protected: // implementation
    Array<int> ghost_layer;    ///< list of elements whose 'element_type' == 2.
    Array<int> boundary_layer; ///< list of type 3 elements
 
-   virtual void Update();
+   /// Master face internal boundary elements that are attached to the processor
+   /// boundary which cannot be found by looping over the boundary elements alone.
+   /// This variable maps from boundary attributes, to a collection of boundary
+   /// faces (i.e. codimension 1 objects) that are parents of ghost child faces
+   /// with this attribute.
+   std::map<int, std::set<int>> ghost_boundary_elements;
+
+   void Update() override;
 
    /// Return the processor number for a global element number.
    int Partition(long index, long total_elements) const
@@ -313,13 +357,13 @@ protected: // implementation
    long PartitionFirstIndex(int rank, long total_elements) const
    { return (rank * total_elements + NRanks-1) / NRanks; }
 
-   virtual void BuildFaceList();
-   virtual void BuildEdgeList();
-   virtual void BuildVertexList();
+   void BuildFaceList() override;
+   void BuildEdgeList() override;
+   void BuildVertexList() override;
 
-   virtual void ElementSharesFace(int elem, int local, int face);
-   virtual void ElementSharesEdge(int elem, int local, int enode);
-   virtual void ElementSharesVertex(int elem, int local, int vnode);
+   void ElementSharesFace(int elem, int local, int face) override;
+   void ElementSharesEdge(int elem, int local, int enode) override;
+   void ElementSharesVertex(int elem, int local, int vnode) override;
 
    GroupId GetGroupId(const CommGroup &group);
    GroupId GetSingletonGroup(int rank);
@@ -451,8 +495,8 @@ protected: // implementation
    protected:
       ParNCMesh* pncmesh;
 
-      virtual void Encode(int);
-      virtual void Decode(int);
+      void Encode(int) override;
+      void Decode(int) override;
    };
 
    /** Used by ParNCMesh::Refine() to inform neighbors about refinements at
@@ -513,8 +557,8 @@ protected: // implementation
    protected:
       ElementSet eset;
 
-      virtual void Encode(int);
-      virtual void Decode(int);
+      void Encode(int) override;
+      void Decode(int) override;
    };
 
    /** Assign new Element::rank to leaf elements and send them to their new
diff --git a/mesh/point.cpp b/mesh/point.cpp
index ecf6a4dd0..473655b11 100644
--- a/mesh/point.cpp
+++ b/mesh/point.cpp
@@ -21,12 +21,24 @@ Point::Point( const int *ind, int attr ) : Element(Geometry::POINT)
    indices[0] = ind[0];
 }
 
-void Point::GetVertices( Array<int> &v ) const
+void Point::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 1 );
+   v.SetSize(1);
    v[0] = indices[0];
 }
 
+void Point::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 1, "!");
+   indices[0] = v[0];
+}
+
+
+void Point::SetVertices(const int *ind)
+{
+   indices[0] = ind[0];
+}
+
 PointFiniteElement PointFE;
 
 }
diff --git a/mesh/point.hpp b/mesh/point.hpp
index f154e205e..be00c9c84 100644
--- a/mesh/point.hpp
+++ b/mesh/point.hpp
@@ -33,33 +33,40 @@ public:
    Point( const int *ind, int attr = -1 );
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::POINT; }
+   Type GetType() const override { return Element::POINT; }
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices( Array<int> &v ) const;
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
 
-   virtual int * GetVertices () { return indices; }
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int GetNVertices() const { return 1; }
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int GetNEdges() const { return (0); }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual const int *GetEdgeVertices(int ei) const { return NULL; }
+   int GetNVertices() const override { return 1; }
+
+   int GetNEdges() const override { return (0); }
+
+   const int *GetEdgeVertices(int ei) const override { return NULL; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const { return NULL; }
+   const int *GetFaceVertices(int fi) const override { return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Point (indices, attribute); }
 
-   virtual ~Point() { }
+   virtual ~Point() = default;
 };
 
 class PointFiniteElement;
diff --git a/mesh/pyramid.cpp b/mesh/pyramid.cpp
index d67841564..f64f2afe9 100644
--- a/mesh/pyramid.cpp
+++ b/mesh/pyramid.cpp
@@ -48,10 +48,13 @@ void Pyramid::SetVertices(const int *ind)
 void Pyramid::GetVertices(Array<int> &v) const
 {
    v.SetSize(5);
-   for (int i = 0; i < 5; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 5, v.begin());
+}
+
+void Pyramid::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 5, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 int Pyramid::GetNFaces(int &nFaceVertices) const
diff --git a/mesh/pyramid.hpp b/mesh/pyramid.hpp
index 8e171a31d..adcc540ed 100644
--- a/mesh/pyramid.hpp
+++ b/mesh/pyramid.hpp
@@ -37,38 +37,42 @@ public:
            int attr = 1);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::PYRAMID; }
+   Type GetType() const override { return Element::PYRAMID; }
 
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 5; }
+   int GetNVertices() const override { return 5; }
 
-   virtual int GetNEdges() const { return 8; }
+   int GetNEdges() const override { return 8; }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const;
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override;
 
-   virtual int GetNFaces() const { return 5; }
+   int GetNFaces() const override { return 5; }
 
-   virtual int GetNFaceVertices(int fi) const
+   int GetNFaceVertices(int fi) const override
    { return ( ( fi < 1 ) ? 4 : 3); }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Pyramid(indices, attribute); }
 
-   virtual ~Pyramid() { }
+   virtual ~Pyramid() = default;
 };
 
 extern class LinearPyramidFiniteElement PyramidFE;
diff --git a/mesh/quadrilateral.cpp b/mesh/quadrilateral.cpp
index 1a69cf179..29fa3bbe1 100644
--- a/mesh/quadrilateral.cpp
+++ b/mesh/quadrilateral.cpp
@@ -37,19 +37,20 @@ Quadrilateral::Quadrilateral( int ind1, int ind2, int ind3, int ind4,
 
 void Quadrilateral::SetVertices(const int *ind)
 {
-   for (int i=0; i<4; i++)
-   {
-      indices[i] = ind[i];
-   }
+   std::copy(ind, ind + 4, indices);
 }
 
-void Quadrilateral::GetVertices( Array<int> &v ) const
+void Quadrilateral::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 4 );
-   for (int i=0; i<4; i++)
-   {
-      v[i] = indices[i];
-   }
+   v.SetSize(4);
+   std::copy(indices, indices + 4, v.begin());
+}
+
+
+void Quadrilateral::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 4, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 BiLinear2DFiniteElement QuadrilateralFE;
diff --git a/mesh/quadrilateral.hpp b/mesh/quadrilateral.hpp
index 9f6b9a442..70fcbfdcc 100644
--- a/mesh/quadrilateral.hpp
+++ b/mesh/quadrilateral.hpp
@@ -36,37 +36,41 @@ public:
    Quadrilateral(int ind1, int ind2, int ind3, int ind4, int attr = 1);
 
    /// Return element's type
-   Type GetType() const { return Element::QUADRILATERAL; }
+   Type GetType() const override { return Element::QUADRILATERAL; }
 
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   /// Returns the indices of the element's vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 4; }
+   int GetNVertices() const override { return 4; }
 
-   virtual int GetNEdges() const { return (4); }
+   int GetNEdges() const override { return (4); }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const { return NULL; }
+   const int *GetFaceVertices(int fi) const override { return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Quadrilateral(indices, attribute); }
 
-   virtual ~Quadrilateral() { }
+   virtual ~Quadrilateral() = default;
 };
 
 extern MFEM_EXPORT class BiLinear2DFiniteElement QuadrilateralFE;
diff --git a/mesh/segment.cpp b/mesh/segment.cpp
index 717245907..910614770 100644
--- a/mesh/segment.cpp
+++ b/mesh/segment.cpp
@@ -37,13 +37,16 @@ void Segment::SetVertices(const int *ind)
    indices[1] = ind[1];
 }
 
-void Segment::GetVertices( Array<int> &v ) const
+void Segment::GetVertices(Array<int> &v) const
 {
-   v.SetSize( 2 );
-   for (int i=0; i<2; i++)
-   {
-      v[i] = indices[i];
-   }
+   v.SetSize(2);
+   std::copy(indices, indices + 2, v.begin());
+}
+
+void Segment::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 2, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 Linear1DFiniteElement SegmentFE;
diff --git a/mesh/segment.hpp b/mesh/segment.hpp
index 6ca918758..aafc4909f 100644
--- a/mesh/segment.hpp
+++ b/mesh/segment.hpp
@@ -35,37 +35,41 @@ public:
    /// Constructs triangle by specifying the indices and the attribute.
    Segment(int ind1, int ind2, int attr = 1);
 
-   /// Set the indices the element according to the input.
-   virtual void SetVertices(const int *ind);
-
    /// Return element's type.
-   virtual Type GetType() const { return Element::SEGMENT; }
+   Type GetType() const override { return Element::SEGMENT; }
+
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 2; }
+   int GetNVertices() const override { return 2; }
 
-   virtual int GetNEdges() const { return (0); }
+   int GetNEdges() const override { return 0; }
 
-   virtual const int *GetEdgeVertices(int ei) const { return NULL; }
+   const int *GetEdgeVertices(int ei) const override { return NULL; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const { return NULL; }
+   const int *GetFaceVertices(int fi) const override { return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Segment(indices, attribute); }
 
-   virtual ~Segment() { }
+   virtual ~Segment() = default;
 };
 
 class Linear1DFiniteElement;
diff --git a/mesh/tetrahedron.cpp b/mesh/tetrahedron.cpp
index 7c9c8de7a..22eecbd42 100644
--- a/mesh/tetrahedron.cpp
+++ b/mesh/tetrahedron.cpp
@@ -327,10 +327,13 @@ void Tetrahedron::GetPointMatrix(unsigned transform, DenseMatrix &pm)
 void Tetrahedron::GetVertices(Array<int> &v) const
 {
    v.SetSize(4);
-   for (int i = 0; i < 4; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 4, v.begin());
+}
+
+void Tetrahedron::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 4, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 Element *Tetrahedron::Duplicate(Mesh *m) const
diff --git a/mesh/tetrahedron.hpp b/mesh/tetrahedron.hpp
index b72e5db55..8fc64481d 100644
--- a/mesh/tetrahedron.hpp
+++ b/mesh/tetrahedron.hpp
@@ -56,7 +56,7 @@ public:
              int ref_flag = 0);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::TETRAHEDRON; }
+   Type GetType() const override { return Element::TETRAHEDRON; }
 
    void  ParseRefinementFlag(int refinement_edges[2], int &type,
                              int &flag) const;
@@ -69,52 +69,56 @@ public:
    void SetRefinementFlag(int rf) { refinement_flag = rf; }
 
    /// Return 1 if the element needs refinement in order to get conforming mesh.
-   virtual int NeedRefinement(HashTable<Hashed2> &v_to_v) const;
-
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   int NeedRefinement(HashTable<Hashed2> &v_to_v) const override;
 
    /** Reorder the vertices so that the longest edge is from vertex 0
        to vertex 1. If called it should be once from the mesh constructor,
        because the order may be used later for setting the edges. **/
-   virtual void MarkEdge(const DSTable &v_to_v, const int *length);
+   void MarkEdge(const DSTable &v_to_v, const int *length) override;
 
-   virtual void ResetTransform(int tr) { transform = tr; }
-   virtual unsigned GetTransform() const { return transform; }
+   void ResetTransform(int tr) override { transform = tr; }
+   unsigned GetTransform() const override { return transform; }
 
    /// Add 'tr' to the current chain of coarse-fine transformations.
-   virtual void PushTransform(int tr)
+   void PushTransform(int tr) override
    { transform = (transform << 3) | (tr + 1); }
 
    /// Calculate point matrix corresponding to a chain of transformations.
    static void GetPointMatrix(unsigned transform, DenseMatrix &pm);
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   virtual int *GetVertices() { return indices; }
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
+
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 4; }
+   int GetNVertices() const override { return 4; }
 
-   virtual int GetNEdges() const { return (6); }
+   int GetNEdges() const override { return (6); }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 3; return 4; }
 
-   virtual int GetNFaces() const { return 4; }
+   int GetNFaces() const override { return 4; }
 
-   virtual int GetNFaceVertices(int) const { return 3; }
+   int GetNFaceVertices(int) const override { return 3; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const;
+   Element *Duplicate(Mesh *m) const override;
 
-   virtual ~Tetrahedron() { }
+   virtual ~Tetrahedron() = default;
 };
 
 // Defined in fe.cpp to ensure construction before 'mfem::Geometries'.
diff --git a/mesh/triangle.cpp b/mesh/triangle.cpp
index 5ce32cb31..eb7493398 100644
--- a/mesh/triangle.cpp
+++ b/mesh/triangle.cpp
@@ -188,10 +188,13 @@ void Triangle::GetPointMatrix(unsigned transform, DenseMatrix &pm)
 void Triangle::GetVertices(Array<int> &v) const
 {
    v.SetSize(3);
-   for (int i = 0; i < 3; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 3, v.begin());
+}
+
+void Triangle::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 3, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 } // namespace mfem
diff --git a/mesh/triangle.hpp b/mesh/triangle.hpp
index 363bd4503..0724c5082 100644
--- a/mesh/triangle.hpp
+++ b/mesh/triangle.hpp
@@ -39,13 +39,10 @@ public:
    Triangle(int ind1, int ind2, int ind3, int attr = 1);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::TRIANGLE; }
+   Type GetType() const override { return Element::TRIANGLE; }
 
    /// Return 1 if the element needs refinement in order to get conforming mesh.
-   virtual int NeedRefinement(HashTable<Hashed2> &v_to_v) const;
-
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   int NeedRefinement(HashTable<Hashed2> &v_to_v) const override;
 
    /** Reorder the vertices so that the longest edge is from vertex 0
        to vertex 1. If called it should be once from the mesh constructor,
@@ -55,46 +52,54 @@ public:
    static void MarkEdge(int *indices, const DSTable &v_to_v, const int *length);
 
    /// Mark the longest edge by assuming/changing the order of the vertices.
-   virtual void MarkEdge(const DSTable &v_to_v, const int *length)
+   void MarkEdge(const DSTable &v_to_v, const int *length) override
    { MarkEdge(indices, v_to_v, length); }
 
-   virtual void ResetTransform(int tr) { transform = tr; }
-   virtual unsigned GetTransform() const { return transform; }
+   void ResetTransform(int tr) override { transform = tr; }
+   unsigned GetTransform() const override { return transform; }
 
    /// Add 'tr' to the current chain of coarse-fine transformations.
-   virtual void PushTransform(int tr)
+   void PushTransform(int tr) override
    { transform = (transform << 3) | (tr + 1); }
 
    /// Calculate point matrix corresponding to a chain of transformations.
    static void GetPointMatrix(unsigned transform, DenseMatrix &pm);
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
+
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
+
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int *GetVertices() { return indices; }
 
-   virtual int GetNVertices() const { return 3; }
+   int GetNVertices() const override { return 3; }
 
-   virtual int GetNEdges() const { return (3); }
+   int GetNEdges() const override { return (3); }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override
    { nFaceVertices = 0; return 0; }
 
-   virtual int GetNFaces() const { return 0; }
+   int GetNFaces() const override { return 0; }
 
-   virtual int GetNFaceVertices(int) const { return 0; }
+   int GetNFaceVertices(int) const override { return 0; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { MFEM_ABORT("not implemented"); return NULL; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Triangle(indices, attribute); }
 
-   virtual ~Triangle() { }
+   virtual ~Triangle() = default;
 };
 
 // Defined in fe.cpp to ensure construction before 'mfem::Geometries'.
diff --git a/mesh/wedge.cpp b/mesh/wedge.cpp
index 898da7653..b1aea933d 100644
--- a/mesh/wedge.cpp
+++ b/mesh/wedge.cpp
@@ -50,10 +50,13 @@ void Wedge::SetVertices(const int *ind)
 void Wedge::GetVertices(Array<int> &v) const
 {
    v.SetSize(6);
-   for (int i = 0; i < 6; i++)
-   {
-      v[i] = indices[i];
-   }
+   std::copy(indices, indices + 6, v.begin());
+}
+
+void Wedge::SetVertices(const Array<int> &v)
+{
+   MFEM_ASSERT(v.Size() == 6, "!");
+   std::copy(v.begin(), v.end(), indices);
 }
 
 int Wedge::GetNFaces(int &nFaceVertices) const
diff --git a/mesh/wedge.hpp b/mesh/wedge.hpp
index fb8583f8e..2eae6d104 100644
--- a/mesh/wedge.hpp
+++ b/mesh/wedge.hpp
@@ -37,38 +37,42 @@ public:
          int attr = 1);
 
    /// Return element's type.
-   virtual Type GetType() const { return Element::WEDGE; }
+   Type GetType() const override { return Element::WEDGE; }
 
-   /// Set the vertices according to the given input.
-   virtual void SetVertices(const int *ind);
+   /// Get the indices defining the vertices
+   void GetVertices(Array<int> &v) const override;
+
+   /// Set the indices defining the vertices
+   void SetVertices(const Array<int> &v) override;
 
-   /// Returns the indices of the element's  vertices.
-   virtual void GetVertices(Array<int> &v) const;
+   /// @note The returned array should NOT be deleted by the caller.
+   int * GetVertices () override { return indices; }
 
-   virtual int *GetVertices() { return indices; }
+   /// Set the vertices according to the given input.
+   void SetVertices(const int *ind) override;
 
-   virtual int GetNVertices() const { return 6; }
+   int GetNVertices() const override { return 6; }
 
-   virtual int GetNEdges() const { return 9; }
+   int GetNEdges() const override { return 9; }
 
-   virtual const int *GetEdgeVertices(int ei) const
+   const int *GetEdgeVertices(int ei) const override
    { return geom_t::Edges[ei]; }
 
    /// @deprecated Use GetNFaces(void) and GetNFaceVertices(int) instead.
-   MFEM_DEPRECATED virtual int GetNFaces(int &nFaceVertices) const;
+   MFEM_DEPRECATED int GetNFaces(int &nFaceVertices) const override;
 
-   virtual int GetNFaces() const { return 5; }
+   int GetNFaces() const override { return 5; }
 
-   virtual int GetNFaceVertices(int fi) const
+   int GetNFaceVertices(int fi) const override
    { return (fi < 2) ? 3 : 4; }
 
-   virtual const int *GetFaceVertices(int fi) const
+   const int *GetFaceVertices(int fi) const override
    { return geom_t::FaceVert[fi]; }
 
-   virtual Element *Duplicate(Mesh *m) const
+   Element *Duplicate(Mesh *m) const override
    { return new Wedge(indices, attribute); }
 
-   virtual ~Wedge() { }
+   virtual ~Wedge() = default;
 };
 
 extern MFEM_EXPORT class LinearWedgeFiniteElement WedgeFE;
diff --git a/miniapps/nurbs/CMakeLists.txt b/miniapps/nurbs/CMakeLists.txt
index ba349fd3e..3ab26345d 100644
--- a/miniapps/nurbs/CMakeLists.txt
+++ b/miniapps/nurbs/CMakeLists.txt
@@ -63,6 +63,14 @@ if (MFEM_ENABLE_TESTING)
   add_test(NAME nurbs_ex1_weak_patch_format_r1_ser
     COMMAND $<TARGET_FILE:nurbs_ex1> -no-vis
     -m ${PROJECT_SOURCE_DIR}/data/square-disc-nurbs-patch.mesh -o 2 --weak-bc -r 1)
+
+  add_test(NAME nurbs_curveint_unit_weight_ser
+    COMMAND $<TARGET_FILE:nurbs_curveint> -no-vis -no-visit
+    -uw -n 9)
+
+  add_test(NAME nurbs_curveint_non_unit_weight_ser
+    COMMAND $<TARGET_FILE:nurbs_curveint> -no-vis -no-visit
+    -nw -n 9)
 endif()
 
 if (MFEM_USE_MPI)
diff --git a/miniapps/nurbs/makefile b/miniapps/nurbs/makefile
index 1aec3ca84..3fd2c7438 100644
--- a/miniapps/nurbs/makefile
+++ b/miniapps/nurbs/makefile
@@ -21,7 +21,7 @@ CONFIG_MK = $(MFEM_BUILD_DIR)/config/config.mk
 MFEM_LIB_FILE = mfem_is_not_built
 -include $(CONFIG_MK)
 
-SEQ_MINIAPPS = nurbs_ex1
+SEQ_MINIAPPS = nurbs_ex1 nurbs_curveint
 PAR_MINIAPPS = nurbs_ex1p nurbs_ex11p
 ifeq ($(MFEM_USE_MPI),NO)
    MINIAPPS = $(SEQ_MINIAPPS)
@@ -78,6 +78,13 @@ nurbs_ex1-test-seq: nurbs_ex1
 	@$(call mfem-test,$<,, NURBS miniapp,$(EX1_ARGS_10))
 	@$(call mfem-test,$<,, NURBS miniapp,$(EX1_ARGS_11))
 
+CI_ARGS_1 := -uw -n 9 -no-visit
+CI_ARGS_2 := -nw -n 9 -no-visit
+
+nurbs_curveint-test-seq: nurbs_curveint
+	@$(call mfem-test,$<,, NURBS miniapp,$(CI_ARGS_1))
+	@$(call mfem-test,$<,, NURBS miniapp,$(CI_ARGS_2))
+
 EX1P_ARGS_1 :=
 EX1P_ARGS_2 := -m ../../data/pipe-nurbs-2d.mesh -o 2 -no-ibp
 EX1P_ARGS_3 := -m ../../data/ball-nurbs.mesh -o 2 --weak-bc -r 0
@@ -109,5 +116,6 @@ clean-build:
 	rm -rf *.dSYM *.TVD.*breakpoints
 
 clean-exec:
-	@rm -f refined.mesh mesh.* sol.* mode_*
+	@rm -f refined.mesh sin-fit.mesh mesh.* sol.* mode_*
 	@rm -rf Example1*
+	@rm -rf CurveInt
diff --git a/miniapps/nurbs/nurbs_curveint.cpp b/miniapps/nurbs/nurbs_curveint.cpp
index 0ddae996f..5afa2924f 100644
--- a/miniapps/nurbs/nurbs_curveint.cpp
+++ b/miniapps/nurbs/nurbs_curveint.cpp
@@ -1,12 +1,26 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+//
+//        ------------------------------------------------------------
+//        NURBS CurveInt Miniapp: Interpolate a Curve in a NURBS Patch
+//        ------------------------------------------------------------
+//
 // Compile with: make nurbs_curveint
 //
 // Sample runs:  ./nurbs_curveint -uw -n 9
 //               ./nurbs_curveint -nw -n 9
-
 //
-// Description:  This example code demonstrates the use of MFEM to interpolate
-//               a curve in a NURBS patch. We first define a square shaped
-//               NURBS patch. We then interpolate a sine function on the bottom
+// Description:  This example code demonstrates the use of MFEM to interpolate a
+//               curve in a NURBS patch. We first define a square shaped NURBS
+//               patch. We then interpolate a sine function on the bottom
 //               edge. The results can be viewed in VisIt.
 //
 //               We use curve interpolation for curves with all weights being 1,
@@ -53,6 +67,8 @@ int main(int argc, char *argv[])
    int ncp        = 9;
    int order      = 2;
    bool ifbspline = true;
+   bool visualization = true;
+   bool visit = true;
 
    args.AddOption(&l, "-l", "--box-side-length",
                   "Height and width of the box");
@@ -65,8 +81,13 @@ int main(int argc, char *argv[])
    args.AddOption(&ifbspline, "-uw", "--unit-weight", "-nw",
                   "--non-unit-weight",
                   "Use a unit-weight for B-splines (default) or not: for general NURBS");
+   args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
+                  "--no-visualization",
+                  "Enable or disable GLVis visualization. This is a dummy option to enable testing.");
+   args.AddOption(&visit, "-visit", "--visit", "-no-visit", "--no-visit",
+                  "Enable or disable VisIt visualization.");
 
-   // Parse and print commandline options
+   // Parse and print command line options
    args.Parse();
    if (!args.Good())
    {
@@ -129,9 +150,8 @@ int main(int argc, char *argv[])
    }
    patch.KnotInsert(0, *kv);
 
-   // We locate the controlpoints at the location of the
-   // maxima of the knotvectors. This works very well
-   // for patches with unit weights.
+   // We locate the control points at the location of the maxima of the
+   // knot vectors. This works very well for patches with unit weights.
    kv->FindMaxima(i_args,xi_args, u_args);
 
    for (int i = 0; i < ncp; i++)
@@ -153,7 +173,7 @@ int main(int argc, char *argv[])
    if (!ifbspline)
    {
       // Convert to homogeneous coordinates. FindInterpolant returns
-      // cartesian coordinates.
+      // Cartesian coordinates.
       for (int i = 0; i < ncp; i++)
       {
          patch(i,0,0) *= patch(i,0,2);
@@ -210,16 +230,21 @@ int main(int argc, char *argv[])
    Mesh *mesh = new Mesh(mesh_file.c_str(), 1, 1);
    mesh->PrintInfo();
 
-   // Print mesh to file for visualisation
-   VisItDataCollection dc = VisItDataCollection("mesh", mesh);
-   dc.SetPrefixPath("solution");
-   dc.SetCycle(0);
-   dc.SetTime(0.0);
-   dc.Save();
+   if (visit)
+   {
+      // Print mesh to file for visualization
+      VisItDataCollection dc = VisItDataCollection("mesh", mesh);
+      dc.SetPrefixPath("CurveInt");
+      dc.SetCycle(0);
+      dc.SetTime(0.0);
+      dc.Save();
+   }
 
+   delete mesh;
    delete kv_o1;
    delete kv;
-   delete mesh;
+   delete xy[0];
+   delete xy[1];
 
    return 0;
-}
\ No newline at end of file
+}
diff --git a/tests/unit/CMakeLists.txt b/tests/unit/CMakeLists.txt
index dc0e9fea8..678abb706 100644
--- a/tests/unit/CMakeLists.txt
+++ b/tests/unit/CMakeLists.txt
@@ -43,6 +43,7 @@ set(UNIT_TESTS_SRCS
   linalg/test_operator.cpp
   linalg/test_vector.cpp
   mesh/test_face_orientations.cpp
+  mesh/mesh_test_utils.cpp
   mesh/test_fms.cpp
   mesh/test_mesh.cpp
   mesh/test_ncmesh.cpp
diff --git a/tests/unit/fem/test_pa_kernels.cpp b/tests/unit/fem/test_pa_kernels.cpp
index 673653596..1077d998a 100644
--- a/tests/unit/fem/test_pa_kernels.cpp
+++ b/tests/unit/fem/test_pa_kernels.cpp
@@ -385,17 +385,17 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    }
    int dim = mesh.Dimension();
 
-   FiniteElementCollection *fec;
+   std::unique_ptr<FiniteElementCollection> fec;
    if (prob)
    {
       auto basis = prob==3 ? BasisType::Positive : BasisType::GaussLobatto;
-      fec = new L2_FECollection(order, dim, basis);
+      fec.reset(new L2_FECollection(order, dim, basis));
    }
    else
    {
-      fec = new H1_FECollection(order, dim);
+      fec.reset(new H1_FECollection(order, dim));
    }
-   FiniteElementSpace fespace(&mesh, fec);
+   FiniteElementSpace fespace(&mesh, fec.get());
 
    L2_FECollection vel_fec(order, dim, BasisType::GaussLobatto);
    FiniteElementSpace vel_fespace(&mesh, &vel_fec, dim);
@@ -405,21 +405,21 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    BilinearForm k_pa(&fespace);
    BilinearForm k_fa(&fespace);
 
-   VectorCoefficient *vel_coeff;
-   Coefficient *rho;
+   std::unique_ptr<VectorCoefficient> vel_coeff;
+   std::unique_ptr<Coefficient> rho;
 
    // prob: 0: CG, 1: DG continuous coeff, 2: DG discontinuous coeff
    if (prob >= 2)
    {
       vel_gf.Randomize(1);
-      vel_coeff = new VectorGridFunctionCoefficient(&vel_gf);
+      vel_coeff.reset(new VectorGridFunctionCoefficient(&vel_gf));
       rho_gf.Randomize(1);
-      rho = new GridFunctionCoefficient(&rho_gf);
+      rho.reset(new GridFunctionCoefficient(&rho_gf));
    }
    else
    {
-      vel_coeff = new VectorFunctionCoefficient(dim, velocity_function);
-      rho = new ConstantCoefficient(1.0);
+      vel_coeff.reset(new VectorFunctionCoefficient(dim, velocity_function));
+      rho.reset(new ConstantCoefficient(1.0));
    }
 
 
@@ -451,10 +451,6 @@ void test_pa_convection(const std::string &meshname, int order, int prob,
    y_pa -= y_fa;
 
    REQUIRE(y_pa.Norml2() < 1.e-12);
-
-   delete vel_coeff;
-   delete rho;
-   delete fec;
 }
 
 // Basic unit tests for convection
@@ -468,7 +464,7 @@ TEST_CASE("PA Convection", "[PartialAssembly], [CUDA]")
    auto prob = GENERATE(0, 1, 2, 3);
    auto order = GENERATE(2);
    // refinement > 0 => Non-conforming mesh
-   auto refinement = GENERATE(0,1);
+   auto refinement = GENERATE(0, 1);
 
    SECTION("2D")
    {
diff --git a/tests/unit/linalg/test_operator.cpp b/tests/unit/linalg/test_operator.cpp
index 8ed47de3f..8e6fe0fd0 100644
--- a/tests/unit/linalg/test_operator.cpp
+++ b/tests/unit/linalg/test_operator.cpp
@@ -31,23 +31,19 @@ TEST_CASE("Operator", "[Operator]")
    {
       // When cg is in a product (on the right), we require cg->iterative_mode to be false.
 
-      ProductOperator *product = NULL;
-      RAPOperator *rap = NULL;
-      TripleProductOperator *triple = NULL;
-
       // First, test that the failing version throws an exception.
       cg.iterative_mode = true;
-      REQUIRE_THROWS(product = new ProductOperator(&A, &cg, false, false));
-      REQUIRE_THROWS(triple = new TripleProductOperator(&A, &cg, &cg, false, false,
-                                                        false));
-      REQUIRE_THROWS(rap = new RAPOperator(A, cg, cg));
+      REQUIRE_THROWS(ProductOperator(&A, &cg, false, false));
+      REQUIRE_THROWS(TripleProductOperator(&A, &cg, &cg, false, false,
+                                           false));
+      REQUIRE_THROWS(RAPOperator(A, cg, cg));
 
       // Second, test that the correct version does not throw.
       cg.iterative_mode = false;
-      REQUIRE_NOTHROW(product = new ProductOperator(&A, &cg, false, false));
-      REQUIRE_NOTHROW(triple = new TripleProductOperator(&A, &cg, &cg, false, false,
-                                                         false));
-      REQUIRE_NOTHROW(rap = new RAPOperator(A, cg, cg));
+      REQUIRE_NOTHROW(ProductOperator(&A, &cg, false, false));
+      REQUIRE_NOTHROW(TripleProductOperator(&A, &cg, &cg, false, false,
+                                            false));
+      REQUIRE_NOTHROW(RAPOperator(A, cg, cg));
    }
 }
 
diff --git a/tests/unit/mesh/mesh_test_utils.cpp b/tests/unit/mesh/mesh_test_utils.cpp
new file mode 100644
index 000000000..65fb2e01d
--- /dev/null
+++ b/tests/unit/mesh/mesh_test_utils.cpp
@@ -0,0 +1,207 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mesh_test_utils.hpp"
+
+namespace mfem
+{
+
+int CheckPoisson(Mesh &mesh, int order, int disabled_boundary_attribute)
+{
+   constexpr int dim = 3;
+
+   H1_FECollection fec(order, dim);
+   FiniteElementSpace fes(&mesh, &fec);
+
+   GridFunction sol(&fes);
+
+   ConstantCoefficient one(1.0);
+   BilinearForm a(&fes);
+   a.AddDomainIntegrator(new DiffusionIntegrator(one));
+   a.Assemble();
+
+   LinearForm b(&fes);
+   b.AddDomainIntegrator(new DomainLFIntegrator(one));
+   b.Assemble();
+
+   // Add in essential boundary conditions
+   Array<int> ess_tdof_list;
+   REQUIRE(mesh.bdr_attributes.Max() > 0);
+
+   // Mark all boundaries essential
+   Array<int> bdr_attr_is_ess(mesh.bdr_attributes.Max());
+   bdr_attr_is_ess = 1;
+   if (disabled_boundary_attribute >= 0)
+   {
+      bdr_attr_is_ess[mesh.bdr_attributes.Find(disabled_boundary_attribute)] = 0;
+   }
+
+   fes.GetEssentialTrueDofs(bdr_attr_is_ess, ess_tdof_list);
+   REQUIRE(ess_tdof_list.Size() > 0);
+
+   ConstantCoefficient zero(0.0);
+   sol.ProjectCoefficient(zero);
+   Vector B, X;
+   OperatorPtr A;
+   a.FormLinearSystem(ess_tdof_list, sol, b, A, X, B);
+
+   // Solve the system
+   CG(*A, B, X, 2, 1000, 1e-20, 0.0);
+
+   // Recover the solution
+   a.RecoverFEMSolution(X, b, sol);
+
+   // Check that X solves the system A X = B.
+   A->AddMult(X, B, -1.0);
+   auto residual_norm = B.Norml2();
+   bool satisfy_system = residual_norm < 1e-10;
+   CAPTURE(residual_norm);
+   CHECK(satisfy_system);
+
+   bool satisfy_bc = true;
+   Vector tvec;
+   sol.GetTrueDofs(tvec);
+   for (auto dof : ess_tdof_list)
+   {
+      if (tvec[dof] != 0.0)
+      {
+         satisfy_bc = false;
+         break;
+      }
+   }
+   CHECK(satisfy_bc);
+   return ess_tdof_list.Size();
+};
+
+#ifdef MFEM_USE_MPI
+
+void CheckPoisson(ParMesh &pmesh, int order,
+                  int disabled_boundary_attribute)
+{
+   constexpr int dim = 3;
+
+   H1_FECollection fec(order, dim);
+   ParFiniteElementSpace pfes(&pmesh, &fec);
+
+   ParGridFunction sol(&pfes);
+
+   ConstantCoefficient one(1.0);
+   ParBilinearForm a(&pfes);
+   a.AddDomainIntegrator(new DiffusionIntegrator(one));
+   a.Assemble();
+   ParLinearForm b(&pfes);
+   b.AddDomainIntegrator(new DomainLFIntegrator(one));
+   b.Assemble();
+
+   // Add in essential boundary conditions
+   Array<int> ess_tdof_list;
+   REQUIRE(pmesh.bdr_attributes.Max() > 0);
+
+   Array<int> bdr_attr_is_ess(pmesh.bdr_attributes.Max());
+   bdr_attr_is_ess = 1;
+   if (disabled_boundary_attribute >= 0)
+   {
+      CAPTURE(disabled_boundary_attribute);
+      bdr_attr_is_ess[pmesh.bdr_attributes.Find(disabled_boundary_attribute)] = 0;
+   }
+
+   pfes.GetEssentialTrueDofs(bdr_attr_is_ess, ess_tdof_list);
+   int num_ess_dof = ess_tdof_list.Size();
+   MPI_Allreduce(MPI_IN_PLACE, &num_ess_dof, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+   REQUIRE(num_ess_dof > 0);
+
+
+   ConstantCoefficient zero(0.0);
+   sol.ProjectCoefficient(zero);
+   Vector B, X;
+   OperatorPtr A;
+   const bool copy_interior = true; // interior(sol) --> interior(X)
+   a.FormLinearSystem(ess_tdof_list, sol, b, A, X, B, copy_interior);
+
+   // Solve the system
+   CGSolver cg(MPI_COMM_WORLD);
+   // HypreBoomerAMG preconditioner;
+   cg.SetMaxIter(2000);
+   cg.SetRelTol(1e-12);
+   cg.SetPrintLevel(0);
+   cg.SetOperator(*A);
+   // cg.SetPreconditioner(preconditioner);
+   cg.Mult(B, X);
+   // Recover the solution
+   a.RecoverFEMSolution(X, b, sol);
+
+   // Check that X solves the system A X = B.
+   A->AddMult(X, B, -1.0);
+   auto residual_norm = B.Norml2();
+   bool satisfy_system = residual_norm < 1e-10;
+   CAPTURE(residual_norm);
+   CHECK(satisfy_system);
+
+   // Initialize the bdr_dof to be checked
+   Vector tvec;
+   sol.GetTrueDofs(tvec);
+   bool satisfy_bc = true;
+   for (auto dof : ess_tdof_list)
+   {
+      if (tvec[dof] != 0.0)
+      {
+         satisfy_bc = false;
+         break;
+      }
+   }
+   CHECK(satisfy_bc);
+};
+
+std::unique_ptr<ParMesh> CheckParMeshNBE(Mesh &smesh,
+                                         const std::unique_ptr<int[]> &partition)
+{
+   auto pmesh = std::unique_ptr<ParMesh>(new ParMesh(MPI_COMM_WORLD, smesh,
+                                                     partition.get()));
+
+   int nbe = pmesh->GetNBE();
+   MPI_Allreduce(MPI_IN_PLACE, &nbe, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(nbe == smesh.GetNBE());
+   return pmesh;
+};
+
+bool CheckFaceInternal(ParMesh& pmesh, int f,
+                       const std::map<int, int> &local_to_shared)
+{
+   int e1, e2;
+   pmesh.GetFaceElements(f, &e1, &e2);
+   int inf1, inf2, ncface;
+   pmesh.GetFaceInfos(f, &inf1, &inf2, &ncface);
+
+   if (e2 < 0 && inf2 >=0)
+   {
+      // Shared face on processor boundary -> Need to discover the neighbor
+      // attributes
+      auto FET = pmesh.GetSharedFaceTransformations(local_to_shared.at(f));
+
+      if (FET->Elem1->Attribute != FET->Elem2->Attribute && f < pmesh.GetNumFaces())
+      {
+         // shared face on domain attribute boundary, which this rank owns
+         return true;
+      }
+   }
+
+   if (e2 >= 0 && pmesh.GetAttribute(e1) != pmesh.GetAttribute(e2))
+   {
+      // local face on domain attribute boundary
+      return true;
+   }
+   return false;
+};
+
+#endif
+
+} // namespace mfem
diff --git a/tests/unit/mesh/mesh_test_utils.hpp b/tests/unit/mesh/mesh_test_utils.hpp
new file mode 100644
index 000000000..e4088a788
--- /dev/null
+++ b/tests/unit/mesh/mesh_test_utils.hpp
@@ -0,0 +1,78 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_MESH_TEST_UTILS
+#define MFEM_MESH_TEST_UTILS
+
+
+#include "mfem.hpp"
+#include "unit_tests.hpp"
+
+namespace mfem
+{
+
+/**
+ * @brief Helper function for performing an H1 Poisson solve on a serial mesh, with
+ * homogeneous essential boundary conditions. Optionally can disable a boundary.
+ *
+ * @param mesh The SERIAL mesh to perform the Poisson solve on
+ * @param order The polynomial order of the basis
+ * @param disabled_boundary_attribute Optional boundary attribute to NOT apply
+ * homogeneous Dirichlet boundary condition on. Default of -1 means no boundary
+ * is disabled.
+ * @return int The number of DOF that are fixed by the essential boundary condition.
+ */
+int CheckPoisson(Mesh &mesh, int order, int disabled_boundary_attribute = -1);
+
+#ifdef MFEM_USE_MPI
+
+/**
+ * @brief Helper function for performing an H1 Poisson solve on a parallel mesh, with
+ * homogeneous essential boundary conditions. Optionally can disable a boundary.
+ *
+ * @param mesh The PARALLEL mesh to perform the Poisson solve on
+ * @param order The polynomial order of the basis
+ * @param disabled_boundary_attribute Optional boundary attribute to NOT apply
+ * homogeneous Dirichlet boundary condition on. Default of -1 means no boundary
+ * is disabled.
+ * @return int The number of DOF that are fixed by the essential boundary condition.
+ */
+void CheckPoisson(ParMesh &pmesh, int order,
+                  int disabled_boundary_attribute = -1);
+
+/**
+ * @brief Check that a Parmesh generates the same number of boundary elements as
+ * the serial mesh.
+ *
+ * @param smesh Serial mesh to be built from and compared against
+ * @param partition Optional partition
+ * @return std::unique_ptr<ParMesh> Pointer to the mesh in question.
+ */
+std::unique_ptr<ParMesh> CheckParMeshNBE(Mesh &smesh,
+                                         const std::unique_ptr<int[]> &partition = nullptr);
+
+/**
+ * @brief Helper function to track if a face index is internal
+ *
+ * @param pmesh The mesh containing the face
+ * @param f The face index
+ * @param local_to_shared A map from local faces to shared faces
+ * @return true the face is between domain attributes (and owned by this rank)
+ * @return false the face is not between domain attributes or not owned by this rank
+ */
+bool CheckFaceInternal(ParMesh& pmesh, int f,
+                       const std::map<int, int> &local_to_shared);
+
+#endif
+
+} // namespace mfem
+
+#endif // MFEM_MESH_TEST_UTILS
\ No newline at end of file
diff --git a/tests/unit/mesh/test_ncmesh.cpp b/tests/unit/mesh/test_ncmesh.cpp
index e78c68401..1af8d5ece 100644
--- a/tests/unit/mesh/test_ncmesh.cpp
+++ b/tests/unit/mesh/test_ncmesh.cpp
@@ -10,6 +10,7 @@
 // CONTRIBUTING.md for details.
 
 #include "mfem.hpp"
+#include "mesh_test_utils.hpp"
 #include "unit_tests.hpp"
 
 namespace mfem
@@ -113,7 +114,6 @@ TEST_CASE("NCMesh PA diagonal", "[NCMesh]")
 
 } // test case
 
-
 TEST_CASE("NCMesh 3D Refined Volume", "[NCMesh]")
 {
    auto mesh_fname = GENERATE("../../data/ref-tetrahedron.mesh",
@@ -145,7 +145,6 @@ TEST_CASE("NCMesh 3D Refined Volume", "[NCMesh]")
    REQUIRE(summed_volume == MFEM_Approx(original_volume));
 } // test case
 
-
 TEST_CASE("NCMesh 3D Derefined Volume", "[NCMesh]")
 {
    auto mesh_fname = GENERATE("../../data/ref-tetrahedron.mesh",
@@ -294,128 +293,132 @@ TEST_CASE("pNCMesh PA diagonal",  "[Parallel], [NCMesh]")
          MPI_Barrier(MPI_COMM_WORLD);
       }
    }
-
 } // test case
 
-TEST_CASE("FaceEdgeConstraint",  "[Parallel], [NCMesh]")
+
+// Given a parallel and a serial mesh, perform an L2 projection and check the
+// solutions match exactly.
+void CheckL2Projection(ParMesh& pmesh, Mesh& smesh, int order,
+                       std::function<double(Vector const&)> exact_soln)
 {
-   constexpr int refining_rank = 0;
-   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+   REQUIRE(pmesh.GetGlobalNE() == smesh.GetNE());
+   REQUIRE(pmesh.Dimension() == smesh.Dimension());
+   REQUIRE(pmesh.SpaceDimension() == smesh.SpaceDimension());
 
-   REQUIRE(smesh.GetNE() == 1);
-   {
-      // Start the test with two tetrahedra attached by triangle.
-      auto single_edge_refine = Array<Refinement>(1);
-      single_edge_refine[0].index = 0;
-      single_edge_refine[0].ref_type = Refinement::X;
+   // Make an H1 space, then a mass matrix operator and invert it.
+   // If all non-conformal constraints have been conveyed correctly, the
+   // resulting DOF should match exactly on the serial and the parallel
+   // solution.
 
-      smesh.GeneralRefinement(single_edge_refine, 0); // conformal
-   }
+   H1_FECollection fec(order, smesh.Dimension());
+   ConstantCoefficient one(1.0);
+   FunctionCoefficient rhs_coef(exact_soln);
 
-   auto exact_soln = [](const Vector& x)
-   {
-      // sin(|| x - d ||^2) -> non polynomial but very smooth.
-      Vector d(3);
-      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
-      d -= x;
-      return std::sin(d * d);
-   };
+   constexpr double linear_tol = 1e-16;
 
-   // Given a parallel and a serial mesh, perform an L2 projection and check the
-   // solutions match exactly.
-   auto check_l2_projection = [&exact_soln](ParMesh& pmesh, Mesh& smesh, int order)
+   // serial solve
+   auto serror = [&]
    {
+      FiniteElementSpace fes(&smesh, &fec);
+      // solution vectors
+      GridFunction x(&fes);
+      x = 0.0;
 
-      REQUIRE(pmesh.GetGlobalNE() == smesh.GetNE());
-      REQUIRE(pmesh.Dimension() == smesh.Dimension());
-      REQUIRE(pmesh.SpaceDimension() == smesh.SpaceDimension());
-
-      // Make an H1 space, then a mass matrix operator and invert it.
-      // If all non-conformal constraints have been conveyed correctly, the
-      // resulting DOF should match exactly on the serial and the parallel
-      // solution.
+      double snorm = x.ComputeL2Error(rhs_coef);
 
-      H1_FECollection fec(order, smesh.Dimension());
-      ConstantCoefficient one(1.0);
-      FunctionCoefficient rhs_coef(exact_soln);
+      LinearForm b(&fes);
+      b.AddDomainIntegrator(new DomainLFIntegrator(rhs_coef));
+      b.Assemble();
 
-      constexpr double linear_tol = 1e-16;
+      BilinearForm a(&fes);
+      a.AddDomainIntegrator(new MassIntegrator(one));
+      a.Assemble();
 
-      // serial solve
-      auto serror = [&]
-      {
-         FiniteElementSpace fes(&smesh, &fec);
-         // solution vectors
-         GridFunction x(&fes);
-         x = 0.0;
-
-         LinearForm b(&fes);
-         b.AddDomainIntegrator(new DomainLFIntegrator(rhs_coef));
-         b.Assemble();
-
-         BilinearForm a(&fes);
-         a.AddDomainIntegrator(new MassIntegrator(one));
-         a.Assemble();
-
-         SparseMatrix A;
-         Vector B, X;
+      SparseMatrix A;
+      Vector B, X;
 
-         Array<int> empty_tdof_list;
-         a.FormLinearSystem(empty_tdof_list, x, b, A, X, B);
+      Array<int> empty_tdof_list;
+      a.FormLinearSystem(empty_tdof_list, x, b, A, X, B);
 
 #ifndef MFEM_USE_SUITESPARSE
-         // 9. Define a simple symmetric Gauss-Seidel preconditioner and use it to
-         //    solve the system AX=B with PCG.
-         GSSmoother M(A);
-         PCG(A, M, B, X, -1, 500, linear_tol, 0.0);
+      // 9. Define a simple symmetric Gauss-Seidel preconditioner and use it to
+      //    solve the system AX=B with PCG.
+      GSSmoother M(A);
+      PCG(A, M, B, X, -1, 500, linear_tol, 0.0);
 #else
-         // 9. If MFEM was compiled with SuiteSparse, use UMFPACK to solve the system.
-         UMFPackSolver umf_solver;
-         umf_solver.Control[UMFPACK_ORDERING] = UMFPACK_ORDERING_METIS;
-         umf_solver.SetOperator(A);
-         umf_solver.Mult(B, X);
+      // 9. If MFEM was compiled with SuiteSparse, use UMFPACK to solve the system.
+      UMFPackSolver umf_solver;
+      umf_solver.Control[UMFPACK_ORDERING] = UMFPACK_ORDERING_METIS;
+      umf_solver.SetOperator(A);
+      umf_solver.Mult(B, X);
 #endif
 
-         a.RecoverFEMSolution(X, b, x);
-         return x.ComputeL2Error(rhs_coef);
-      }();
+      a.RecoverFEMSolution(X, b, x);
 
-      auto perror = [&]
-      {
-         // parallel solve
-         ParFiniteElementSpace fes(&pmesh, &fec);
-         ParLinearForm b(&fes);
+      return x.ComputeL2Error(rhs_coef) / snorm;
+   }();
 
-         ParGridFunction x(&fes);
-         x = 0.0;
+   auto perror = [&]
+   {
+      // parallel solve
+      ParFiniteElementSpace fes(&pmesh, &fec);
+      ParLinearForm b(&fes);
+
+      ParGridFunction x(&fes);
+      x = 0.0;
+
+      double pnorm = x.ComputeL2Error(rhs_coef);
+      b.AddDomainIntegrator(new DomainLFIntegrator(rhs_coef));
+      b.Assemble();
+
+      ParBilinearForm a(&fes);
+      a.AddDomainIntegrator(new MassIntegrator(one));
+      a.Assemble();
+
+      HypreParMatrix A;
+      Vector B, X;
+      Array<int> empty_tdof_list;
+      a.FormLinearSystem(empty_tdof_list, x, b, A, X, B);
+
+      HypreBoomerAMG amg(A);
+      HyprePCG pcg(A);
+      amg.SetPrintLevel(-1);
+      pcg.SetTol(linear_tol);
+      pcg.SetMaxIter(500);
+      pcg.SetPrintLevel(-1);
+      pcg.SetPreconditioner(amg);
+      pcg.Mult(B, X);
+      a.RecoverFEMSolution(X, b, x);
+
+      return x.ComputeL2Error(rhs_coef) / pnorm;
+   }();
+
+   constexpr double test_tol = 1e-9;
+   CHECK(std::abs(serror - perror) < test_tol);
+};
 
-         b.AddDomainIntegrator(new DomainLFIntegrator(rhs_coef));
-         b.Assemble();
+TEST_CASE("FaceEdgeConstraint",  "[Parallel], [NCMesh]")
+{
+   constexpr int refining_rank = 0;
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
 
-         ParBilinearForm a(&fes);
-         a.AddDomainIntegrator(new MassIntegrator(one));
-         a.Assemble();
+   REQUIRE(smesh.GetNE() == 1);
+   {
+      // Start the test with two tetrahedra attached by triangle.
+      auto single_edge_refine = Array<Refinement>(1);
+      single_edge_refine[0].index = 0;
+      single_edge_refine[0].ref_type = Refinement::X;
 
-         HypreParMatrix A;
-         Vector B, X;
-         Array<int> empty_tdof_list;
-         a.FormLinearSystem(empty_tdof_list, x, b, A, X, B);
-
-         HypreBoomerAMG amg(A);
-         HyprePCG pcg(A);
-         amg.SetPrintLevel(-1);
-         pcg.SetTol(linear_tol);
-         pcg.SetMaxIter(500);
-         pcg.SetPrintLevel(-1);
-         pcg.SetPreconditioner(amg);
-         pcg.Mult(B, X);
-         a.RecoverFEMSolution(X, b, x);
-         return x.ComputeL2Error(rhs_coef);
-      }();
-
-      constexpr double test_tol = 1e-9;
-      CHECK(std::abs(serror - perror) < test_tol);
+      smesh.GeneralRefinement(single_edge_refine, 0); // conformal
+   }
 
+   auto exact_soln = [](const Vector& x)
+   {
+      // sin(|| x - d ||^2) -> non polynomial but very smooth.
+      Vector d(3);
+      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
+      d -= x;
+      return std::sin(d * d);
    };
 
    REQUIRE(smesh.GetNE() == 2);
@@ -498,28 +501,1560 @@ TEST_CASE("FaceEdgeConstraint",  "[Parallel], [NCMesh]")
       for (int iface = 0; iface < sttmp.GetNumFaces(); ++iface)
       {
          const auto face_transform = sttmp.GetFaceElementTransformations(iface);
-
          CHECK(face_transform->CheckConsistency(0) < 1e-12);
       }
 
       for (int iface = 0; iface < ttmp.GetNumFacesWithGhost(); ++iface)
       {
          const auto face_transform = ttmp.GetFaceElementTransformations(iface);
-
          CHECK(face_transform->CheckConsistency(0) < 1e-12);
       }
 
       // Use P4 to ensure there's a few fully interior DOF.
-      check_l2_projection(ttmp, sttmp, 4);
+      CheckL2Projection(ttmp, sttmp, 4, exact_soln);
 
       ttmp.ExchangeFaceNbrData();
       ttmp.Rebalance();
 
-      check_l2_projection(ttmp, sttmp, 4);
+      CheckL2Projection(ttmp, sttmp, 4, exact_soln);
    }
 } // test case
 
+Mesh CylinderMesh(Geometry::Type el_type, bool quadratic, int variant = 0)
+{
+   double c[3];
 
-#endif // MFEM_USE_MPI
+   int nnodes = (el_type == Geometry::CUBE) ? 24 : 15;
+   int nelems = 8; // Geometry::PRISM
+   if (el_type == Geometry::CUBE)        { nelems = 10; }
+   if (el_type == Geometry::TETRAHEDRON) { nelems = 24; }
+
+   Mesh mesh(3, nnodes, nelems);
+
+   for (int i=0; i<3; i++)
+   {
+      if (el_type != Geometry::CUBE)
+      {
+         c[0] = 0.0;  c[1] = 0.0;  c[2] = 2.74 * i;
+         mesh.AddVertex(c);
+      }
+
+      for (int j=0; j<4; j++)
+      {
+         if (el_type == Geometry::CUBE)
+         {
+            c[0] = 1.14 * ((j + 1) % 2) * (1 - j);
+            c[1] = 1.14 * (j % 2) * (2 - j);
+            c[2] = 2.74 * i;
+            mesh.AddVertex(c);
+         }
+
+         c[0] = 2.74 * ((j + 1) % 2) * (1 - j);
+         c[1] = 2.74 * (j % 2) * (2 - j);
+         c[2] = 2.74 * i;
+         mesh.AddVertex(c);
+      }
+   }
+
+   for (int i=0; i<2; i++)
+   {
+      if (el_type == Geometry::CUBE)
+      {
+         mesh.AddHex(8*i, 8*i+2, 8*i+4, 8*i+6,
+                     8*(i+1), 8*(i+1)+2, 8*(i+1)+4, 8*(i+1)+6);
+      }
+
+      for (int j=0; j<4; j++)
+      {
+         if (el_type == Geometry::PRISM)
+         {
+            switch (variant)
+            {
+               case 0:
+                  mesh.AddWedge(5*i, 5*i+j+1, 5*i+(j+1)%4+1,
+                                5*(i+1), 5*(i+1)+j+1, 5*(i+1)+(j+1)%4+1);
+                  break;
+               case 1:
+                  mesh.AddWedge(5*i, 5*i+j+1, 5*i+(j+1)%4+1,
+                                5*(i+1), 5*(i+1)+j+1, 5*(i+1)+(j+1)%4+1);
+                  break;
+               case 2:
+                  mesh.AddWedge(5*i+(j+1)%4+1, 5*i, 5*i+j+1,
+                                5*(i+1)+(j+1)%4+1, 5*(i+1), 5*(i+1)+j+1);
+                  break;
+            }
+         }
+         else if (el_type == Geometry::CUBE)
+         {
+            mesh.AddHex(8*i+2*j, 8*i+2*j+1, 8*i+(2*j+3)%8, 8*i+(2*j+2)%8,
+                        8*(i+1)+2*j, 8*(i+1)+2*j+1, 8*(i+1)+(2*j+3)%8,
+                        8*(i+1)+(2*j+2)%8);
+         }
+         else if (el_type == Geometry::TETRAHEDRON)
+         {
+            mesh.AddTet(5*i, 5*i+j+1, 5*i+(j+1)%4+1, 5*(i+1));
+            mesh.AddTet(5*i+j+1, 5*i+(j+1)%4+1, 5*(i+1), 5*(i+1)+j+1);
+            mesh.AddTet(5*i+(j+1)%4+1, 5*(i+1), 5*(i+1)+j+1, 5*(i+1)+(j+1)%4+1);
+         }
+      }
+   }
+
+   mesh.FinalizeTopology();
+
+   if (quadratic)
+   {
+      mesh.SetCurvature(2);
+
+      if (el_type == Geometry::CUBE)
+      {
+         auto quad_cyl_hex = [](const Vector& x, Vector& d)
+         {
+            d.SetSize(3);
+            d = x;
+            const double Rmax = 2.74;
+            const double Rmin = 1.14;
+            double ax = std::abs(x[0]);
+            if (ax <= 1e-6) { return; }
+            double ay = std::abs(x[1]);
+            if (ay <= 1e-6) { return; }
+            double r = ax + ay;
+            if (r <= Rmin + 1e-6) { return; }
+
+            double sx = std::copysign(1.0, x[0]);
+            double sy = std::copysign(1.0, x[1]);
+
+            double R = (Rmax - Rmin) * Rmax / (r - Rmin);
+            double r2 = r * r;
+            double R2 = R * R;
+
+            double acosarg = 0.5 * (r + std::sqrt(2.0 * R2 - r2)) / R;
+            double tR = std::acos(std::min(acosarg, 1.0));
+            double tQ = (1.0 + sx * sy * (ay - ax) / r);
+            double tP = 0.25 * M_PI * (3.0 - (2.0 + sx) * sy);
+
+            double t = tR + (0.25 * M_PI - tR) * tQ + tP;
+
+            double s0 = std::sqrt(2.0 * R2 - r2);
+            double s1 = 0.25 * std::pow(r + s0, 2);
+            double s = std::sqrt(R2 - s1);
+
+            d[0] = R * std::cos(t) - sx * s;
+            d[1] = R * std::sin(t) - sy * s;
+
+            return;
+         };
+
+         mesh.Transform(quad_cyl_hex);
+      }
+      else
+      {
+         auto quad_cyl = [](const Vector& x, Vector& d)
+         {
+            d.SetSize(3);
+            d = x;
+            double ax = std::abs(x[0]);
+            double ay = std::abs(x[1]);
+            double r = ax + ay;
+            if (r < 1e-6) { return; }
+
+            double sx = std::copysign(1.0, x[0]);
+            double sy = std::copysign(1.0, x[1]);
+
+            double t = ((2.0 - (1.0 + sx) * sy) * ax +
+                        (2.0 - sy) * ay) * 0.5 * M_PI / r;
+            d[0] = r * std::cos(t);
+            d[1] = r * std::sin(t);
+
+            return;
+         };
+
+         mesh.Transform(quad_cyl);
+      }
+   }
+
+   mesh.Finalize(true);
+
+   return mesh;
+}
+
+TEST_CASE("P2Q1PureTetHexPri",  "[Parallel], [NCMesh]")
+{
+   auto exact_soln = [](const Vector& x)
+   {
+      // sin(|| x - d ||^2) -> non polynomial but very smooth.
+      Vector d(3);
+      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
+      d -= x;
+      return std::sin(d * d);
+   };
+
+   auto el_type = GENERATE(Geometry::TETRAHEDRON,
+                           Geometry::CUBE,
+                           Geometry::PRISM);
+   int variant = GENERATE(0,1,2);
+
+   if (variant > 0 && el_type != Geometry::PRISM)
+   {
+      return;
+   }
+
+   CAPTURE(el_type, variant);
+
+   auto smesh = CylinderMesh(el_type, false, variant);
+
+   for (auto ref : {0,1,2})
+   {
+      if (ref == 1) { smesh.UniformRefinement(); }
+
+      smesh.EnsureNCMesh(true);
+
+      if (ref == 2) { smesh.UniformRefinement(); }
+
+      smesh.Finalize();
+
+      auto pmesh = ParMesh(MPI_COMM_WORLD, smesh);
+
+      // P2 ensures there are triangles without dofs
+      CheckL2Projection(pmesh, smesh, 2, exact_soln);
+   }
+} // test case
+
+TEST_CASE("PNQ2PureTetHexPri",  "[Parallel], [NCMesh]")
+{
+   auto exact_soln = [](const Vector& x)
+   {
+      // sin(|| x - d ||^2) -> non polynomial but very smooth.
+      Vector d(3);
+      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
+      d -= x;
+      return std::sin(d * d);
+   };
+
+   auto el_type = GENERATE(Geometry::TETRAHEDRON,
+                           Geometry::CUBE,
+                           Geometry::PRISM);
+   int variant = GENERATE(0,1,2);
+
+   if (variant > 0 && el_type != Geometry::PRISM)
+   {
+      return;
+   }
+
+   CAPTURE(el_type, variant);
+
+   auto smesh = CylinderMesh(el_type, true);
+
+   for (auto ref : {0,1,2})
+   {
+      if (ref == 1) { smesh.UniformRefinement(); }
+
+      smesh.EnsureNCMesh(true);
+
+      if (ref == 2) { smesh.UniformRefinement(); }
+
+      smesh.Finalize();
+
+      auto pmesh = ParMesh(MPI_COMM_WORLD, smesh);
+
+      for (int p = 1; p < 3; ++p)
+      {
+         CheckL2Projection(pmesh, smesh, p, exact_soln);
+      }
+   }
+} // test case
+
+/**
+ * @brief Test GetVectorValue on face neighbor elements for nonconformal meshes
+ *
+ * @param smesh The serial mesh to start from
+ * @param nc_level Depth of refinement on processor boundaries
+ * @param skip Refine every "skip" processor boundary element
+ * @param use_ND Whether to use Nedelec elements (which are sensitive to orientation)
+ */
+void TestVectorValueInVolume(Mesh &smesh, int nc_level, int skip, bool use_ND)
+{
+   auto vector_exact_soln = [](const Vector& x, Vector& v)
+   {
+      Vector d(3);
+      d[0] = -0.5; d[1] = -1; d[2] = -2; // arbitrary
+      v = (d -= x);
+   };
+
+   smesh.Finalize();
+   smesh.EnsureNCMesh(true); // uncomment this to trigger the failure
+
+   auto pmesh = ParMesh(MPI_COMM_WORLD, smesh);
+
+   // Apply refinement on face neighbors to achieve a given nc level mismatch.
+   for (int i = 0; i < nc_level; ++i)
+   {
+      // To refine the face neighbors, need to know where they are.
+      pmesh.ExchangeFaceNbrData();
+      Array<int> elem_to_refine;
+      // Refine only on odd ranks.
+      if ((Mpi::WorldRank() + 1) % 2 == 0)
+      {
+         // Refine a subset of all shared faces. Using a subset helps to
+         // mix in conformal faces with nonconformal faces.
+         for (int n = 0; n < pmesh.GetNSharedFaces(); ++n)
+         {
+            if (n % skip != 0) { continue; }
+            const int local_face = pmesh.GetSharedFace(n);
+            const auto &face_info = pmesh.GetFaceInformation(local_face);
+            REQUIRE(face_info.IsShared());
+            REQUIRE(face_info.element[1].location == Mesh::ElementLocation::FaceNbr);
+            elem_to_refine.Append(face_info.element[0].index);
+         }
+      }
+      pmesh.GeneralRefinement(elem_to_refine);
+   }
+
+   // Do not rebalance again! The test is also checking for nc refinements
+   // along the processor boundary.
+
+   // Create a grid function of the mesh coordinates
+   pmesh.ExchangeFaceNbrData();
+   pmesh.EnsureNodes();
+   REQUIRE(pmesh.OwnsNodes());
+   GridFunction * const coords = pmesh.GetNodes();
+   dynamic_cast<ParGridFunction *>(pmesh.GetNodes())->ExchangeFaceNbrData();
+
+   // Project the linear function onto the mesh. Quadratic ND tetrahedral
+   // elements are the first to require face orientations.
+   const int order = 2, dim = 3;
+   std::unique_ptr<FiniteElementCollection> fec;
+   if (use_ND)
+   {
+      fec = std::unique_ptr<ND_FECollection>(new ND_FECollection(order, dim));
+   }
+   else
+   {
+      fec = std::unique_ptr<RT_FECollection>(new RT_FECollection(order, dim));
+   }
+   ParFiniteElementSpace pnd_fes(&pmesh, fec.get());
+
+   ParGridFunction psol(&pnd_fes);
+
+   VectorFunctionCoefficient func(3, vector_exact_soln);
+   psol.ProjectCoefficient(func);
+   psol.ExchangeFaceNbrData();
+
+   mfem::Vector value(3), exact(3), position(3);
+   const IntegrationRule &ir = mfem::IntRules.Get(Geometry::Type::TETRAHEDRON,
+                                                  order + 1);
+
+   // Check that non-ghost elements match up on the serial and parallel spaces.
+   for (int n = 0; n < pmesh.GetNE(); ++n)
+   {
+      constexpr double tol = 1e-12;
+      for (const auto &ip : ir)
+      {
+         coords->GetVectorValue(n, ip, position);
+         psol.GetVectorValue(n, ip, value);
+
+         vector_exact_soln(position, exact);
+
+         REQUIRE(value.Size() == exact.Size());
+         CHECK((value -= exact).Normlinf() < tol);
+      }
+   }
+
+   // Loop over face neighbor elements and check the vector values match in the
+   // face neighbor elements.
+   for (int n = 0; n < pmesh.GetNSharedFaces(); ++n)
+   {
+      const int local_face = pmesh.GetSharedFace(n);
+      const auto &face_info = pmesh.GetFaceInformation(local_face);
+      REQUIRE(face_info.IsShared());
+      REQUIRE(face_info.element[1].location == Mesh::ElementLocation::FaceNbr);
+
+      auto &T = *pmesh.GetFaceNbrElementTransformation(face_info.element[1].index);
+
+      constexpr double tol = 1e-12;
+      for (const auto &ip : ir)
+      {
+         T.SetIntPoint(&ip);
+         coords->GetVectorValue(T, ip, position);
+         psol.GetVectorValue(T, ip, value);
+
+         vector_exact_soln(position, exact);
+
+         REQUIRE(value.Size() == exact.Size());
+         CHECK((value -= exact).Normlinf() < tol);
+      }
+   }
+}
+
+TEST_CASE("GetVectorValueInFaceNeighborElement", "[Parallel], [NCMesh]")
+{
+   // The aim of this test is to verify the correct behaviour of the
+   // GetVectorValue method when called on face neighbor elements in a non
+   // conforming mesh.
+   auto smesh = Mesh("../../data/beam-tet.mesh");
+
+   for (int nc_level : {0,1,2,3})
+   {
+      for (int skip : {1,2})
+      {
+         for (bool use_ND : {false, true})
+         {
+            TestVectorValueInVolume(smesh, nc_level, skip, use_ND);
+         }
+      }
+   }
+}
+
+TEST_CASE("InteriorBoundaryReferenceTets", "[Parallel], [NCMesh]")
+{
+   auto p = GENERATE(1);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+   REQUIRE(smesh.GetNBE() == 4);
+
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(0, 1);
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 3);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Introduce an internal boundary element
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+         break;
+      }
+   }
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   // Exactly one boundary element must be added
+   REQUIRE(smesh.GetNBE() == 2 * 3 + 1);
+
+   smesh.EnsureNCMesh(true);
+
+   auto pmesh = CheckParMeshNBE(smesh);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   REQUIRE(pmesh->Nonconforming());
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+   CHECK(num_internal == 1);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+
+   for (int refined_elem : {0, 1})
+   {
+      // Now NC refine one of the attached elements, this should result in 4
+      // internal boundary elements.
+      Array<int> el_to_refine;
+      el_to_refine.Append(refined_elem);
+
+      Mesh modified_smesh(smesh);
+      modified_smesh.GeneralRefinement(el_to_refine);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      CHECK(modified_smesh.GetNBE() == 3 /* external boundaries of unrefined  */
+            + 4 /* internal boundaries */
+            + (3 * 4) /* external boundaries of refined */);
+
+      // Force the partition to have the edge case of a parent and child being
+      // divided across the processor boundary. This necessitates the
+      // GhostBoundaryElement treatment.
+      auto partition = std::unique_ptr<int[]>(new int[modified_smesh.GetNE()]);
+      srand(314159);
+      for (int i = 0; i < modified_smesh.GetNE(); ++i)
+      {
+         // Randomly assign to any processor but zero.
+         partition[i] = Mpi::WorldSize() > 1 ? 1 + rand() % (Mpi::WorldSize() - 1) : 0;
+      }
+      if (Mpi::WorldSize() > 0)
+      {
+         // Make sure on rankÂ 1 there is a parent face with only ghost child
+         // faces. This can cause issues with higher order dofs being uncontrolled.
+         partition[refined_elem == 0 ? modified_smesh.GetNE() - 1 : 0] = 0;
+      }
+
+      pmesh = CheckParMeshNBE(modified_smesh, partition);
+      pmesh->Finalize();
+      pmesh->FinalizeTopology();
+      pmesh->ExchangeFaceNbrData();
+
+      auto check_faces = [&]()
+      {
+         // repopulate the local to shared map.
+         local_to_shared.clear();
+         for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+         {
+            local_to_shared[pmesh->GetSharedFace(i)] = i;
+         }
+
+         // Count the number of internal faces via the boundary elements
+         num_internal = 0;
+         for (int n = 0; n < pmesh->GetNBE(); ++n)
+         {
+            int f, o;
+            pmesh->GetBdrElementFace(n, &f, &o);
+            if (CheckFaceInternal(*pmesh, f, local_to_shared))
+            {
+               ++num_internal;
+            }
+         }
+         MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+         CHECK(num_internal == 4);
+
+         CAPTURE(refined_elem);
+         CheckPoisson(*pmesh, p, smesh.bdr_attributes.Max());
+         CheckPoisson(*pmesh, p);
+      };
+
+      check_faces();
+      pmesh->Rebalance();
+      pmesh->ExchangeFaceNbrData();
+      check_faces();
+   }
+}
+
+TEST_CASE("InteriorBoundaryInlineTetRefines", "[Parallel], [NCMesh]")
+{
+   int p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/inline-tet.mesh");
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Mark even and odd elements with different attributes
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      smesh.SetAttribute(i, (i % 2) + 1);
+   }
+
+   smesh.SetAttributes();
+   int initial_nbe = smesh.GetNBE();
+
+   // Introduce internal boundary elements
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   smesh.EnsureNCMesh(true);
+
+   // Boundary elements must've been added to make the test valid
+   int num_internal_serial = smesh.GetNBE() - initial_nbe;
+   REQUIRE(num_internal_serial > 0);
+
+   auto partition = std::unique_ptr<int[]>(new int[smesh.GetNE()]);
+
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      partition[i] = i % Mpi::WorldSize(); // checkerboard partition
+   }
+
+   auto pmesh = CheckParMeshNBE(smesh, partition);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, new_attribute);
+   CheckPoisson(*pmesh, p);
+
+   // Mark every third element for refinement
+   Array<int> elem_to_refine;
+   const int factor = 3;
+   for (int i = 0; i < smesh.GetNE()/factor; ++i)
+   {
+      elem_to_refine.Append(factor * i);
+   }
+   smesh.GeneralRefinement(elem_to_refine);
+
+   pmesh = CheckParMeshNBE(smesh);
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   // repopulate the local to shared map.
+   local_to_shared.clear();
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal boundary elements
+   num_internal_serial = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal_serial;
+      }
+   }
+
+   num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+}
+
+TEST_CASE("InteriorBoundaryReferenceCubes", "[Parallel], [NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+   smesh.EnsureNCMesh();
+
+   REQUIRE(smesh.GetNBE() == 6);
+
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(0, 1);
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 5);
+
+   // Throw away the NCMesh, will restart NC later.
+   delete smesh.ncmesh;
+   smesh.ncmesh = nullptr;
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Introduce an internal boundary element
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+         break;
+      }
+   }
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   // Exactly one boundary element must be added
+   REQUIRE(smesh.GetNBE() == 2 * 5 + 1);
+
+   auto pmesh = CheckParMeshNBE(smesh);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   REQUIRE(pmesh->Conforming());
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+   CHECK(num_internal == 1);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+
+   for (int refined_elem : {0, 1})
+   {
+      // Now NC refine one of the attached elements, this should result in 4
+      // internal boundary elements.
+      Array<int> el_to_refine;
+      el_to_refine.Append(refined_elem);
+
+      Mesh modified_smesh(smesh);
+      modified_smesh.GeneralRefinement(el_to_refine);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      CHECK(modified_smesh.GetNBE() == 5 /* external boundaries of unrefined  */
+            + 4 /* internal boundaries */
+            + (5 * 4) /* external boundaries of refined */);
+
+      // Force the partition to have the edge case of a parent and child being
+      // divided across the processor boundary. This necessitates the
+      // GhostBoundaryElement treatment.
+      auto partition = std::unique_ptr<int[]>(new int[modified_smesh.GetNE()]);
+      srand(314159);
+      for (int i = 0; i < modified_smesh.GetNE(); ++i)
+      {
+         // Randomly assign to any processor but zero.
+         partition[i] = Mpi::WorldSize() > 1 ? 1 + rand() % (Mpi::WorldSize() - 1) : 0;
+      }
+      if (Mpi::WorldSize() > 0)
+      {
+         // Make sure on rankÂ 1 there is a parent face with only ghost child
+         // faces. This can cause issues with higher order dofs being uncontrolled.
+         partition[refined_elem == 0 ? modified_smesh.GetNE() - 1 : 0] = 0;
+      }
+
+      pmesh = CheckParMeshNBE(modified_smesh, partition);
+      pmesh->Finalize();
+      pmesh->FinalizeTopology();
+      pmesh->ExchangeFaceNbrData();
+
+      auto check_faces = [&]()
+      {
+         // repopulate the local to shared map.
+         local_to_shared.clear();
+         for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+         {
+            local_to_shared[pmesh->GetSharedFace(i)] = i;
+         }
+
+         // Count the number of internal faces via the boundary elements
+         num_internal = 0;
+         for (int n = 0; n < pmesh->GetNBE(); ++n)
+         {
+            int f, o;
+            pmesh->GetBdrElementFace(n, &f, &o);
+            if (CheckFaceInternal(*pmesh, f, local_to_shared))
+            {
+               ++num_internal;
+            }
+         }
+         MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+         CHECK(num_internal == 4);
+
+         CAPTURE(refined_elem);
+         CheckPoisson(*pmesh, p, smesh.bdr_attributes.Max());
+         CheckPoisson(*pmesh, p);
+      };
+
+      check_faces();
+      pmesh->Rebalance();
+      pmesh->ExchangeFaceNbrData();
+      check_faces();
+   }
+}
+
+TEST_CASE("InteriorBoundaryInlineHexRefines", "[Parallel], [NCMesh]")
+{
+   int p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/inline-hex.mesh");
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Mark even and odd elements with different attributes
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      smesh.SetAttribute(i, (i % 2) + 1);
+   }
+
+   smesh.SetAttributes();
+   int initial_nbe = smesh.GetNBE();
+
+   // Introduce internal boundary elements
+   const int new_attribute = smesh.bdr_attributes.Max() + 1;
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(new_attribute);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology(); // Finalize to build relevant tables
+   smesh.Finalize();
+
+   // Boundary elements must've been added to make the test valid
+   int num_internal_serial = smesh.GetNBE() - initial_nbe;
+   REQUIRE(num_internal_serial > 0);
+
+   auto partition = std::unique_ptr<int[]>(new int[smesh.GetNE()]);
+
+   for (int i = 0; i < smesh.GetNE(); ++i)
+   {
+      partition[i] = i % Mpi::WorldSize(); // checkerboard partition
+   }
+
+   auto pmesh = CheckParMeshNBE(smesh, partition);
+
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   std::map<int, int> local_to_shared;
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal faces via the boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, new_attribute);
+   CheckPoisson(*pmesh, p);
+
+   // Mark every third element for refinement
+   Array<int> elem_to_refine;
+   const int factor = 3;
+   for (int i = 0; i < smesh.GetNE()/factor; ++i)
+   {
+      elem_to_refine.Append(factor * i);
+   }
+   smesh.GeneralRefinement(elem_to_refine);
+
+   pmesh = CheckParMeshNBE(smesh);
+   pmesh->FinalizeTopology();
+   pmesh->Finalize();
+   pmesh->ExchangeFaceNbrData();
+
+   // repopulate the local to shared map.
+   local_to_shared.clear();
+   for (int i = 0; i < pmesh->GetNSharedFaces(); ++i)
+   {
+      local_to_shared[pmesh->GetSharedFace(i)] = i;
+   }
+
+   // Count the number of internal boundary elements
+   num_internal_serial = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal_serial;
+      }
+   }
+
+   num_internal = 0;
+   for (int n = 0; n < pmesh->GetNBE(); ++n)
+   {
+      int f, o;
+      pmesh->GetBdrElementFace(n, &f, &o);
+      if (CheckFaceInternal(*pmesh, f, local_to_shared))
+      {
+         ++num_internal;
+      }
+   }
+   MPI_Allreduce(MPI_IN_PLACE, &num_internal, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
+
+   CHECK(num_internal == num_internal_serial);
+
+   CheckPoisson(*pmesh, p, pmesh->bdr_attributes.Max());
+   CheckPoisson(*pmesh, p);
+}
+
+#endif // MFEM_USE_MPI
+
+TEST_CASE("ReferenceCubeInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+
+   CheckPoisson(smesh, p);
+
+   smesh.EnsureNCMesh();
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 5);
+
+   delete smesh.ncmesh;
+   smesh.ncmesh = nullptr;
+
+   // Introduce an internal boundary element
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(7);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 5 + 1);
+
+   smesh.EnsureNCMesh();
+   CHECK(smesh.GetNBE() == 2 * 5 + 1);
+
+   int without_internal, with_internal;
+   with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+   without_internal = CheckPoisson(smesh, p,
+                                   smesh.bdr_attributes.Max()); // Exclude the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal + 1); break;
+      case 3:
+         CHECK(with_internal == without_internal + 4); break;
+   }
+
+   auto ref_type = char(GENERATE(//Refinement::Y, Refinement::Z, Refinement::YZ,
+                           Refinement::XYZ));
+
+   for (auto ref : {0,1})
+   {
+      refs[0].index = ref;
+
+      auto ssmesh = Mesh(smesh);
+
+      CAPTURE(ref_type);
+
+      // Now NC refine one of the attached elements, this should result in 2
+      // internal boundary elements.
+      refs[0].ref_type = ref_type;
+
+      ssmesh.GeneralRefinement(refs);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      if (ref_type == 2 /* Y */ || ref_type == 4 /* Z */)
+      {
+         CHECK(ssmesh.GetNBE() == 5 /* external boundaries of unrefined element  */
+               + 2 /* internal boundaries */
+               + (2 * 4) /* external boundaries of refined elements */);
+      }
+      else if (ref_type == 6)
+      {
+         CHECK(ssmesh.GetNBE() == 5 /* external boundaries of unrefined element  */
+               + 4 /* internal boundaries */
+               + (4 * 3) /* external boundaries of refined elements */);
+      }
+      else if (ref_type == 7)
+      {
+         CHECK(ssmesh.GetNBE() == 5 /* external boundaries of unrefined element  */
+               + 4 /* internal boundaries */
+               + (4 * 3 + 4 * 2) /* external boundaries of refined elements */);
+      }
+      else
+      {
+         MFEM_ABORT("!");
+      }
+
+      // Count the number of internal boundary elements
+      int num_internal = 0;
+      for (int n = 0; n < ssmesh.GetNBE(); ++n)
+      {
+         int f, o;
+         ssmesh.GetBdrElementFace(n, &f, &o);
+         int e1, e2;
+         ssmesh.GetFaceElements(f, &e1, &e2);
+         if (e1 >= 0 && e2 >= 0 && ssmesh.GetAttribute(e1) != ssmesh.GetAttribute(e2))
+         {
+            ++num_internal;
+         }
+      }
+      CHECK(num_internal == (ref_type <= 4 ? 2 : 4));
+
+      ssmesh.FinalizeTopology();
+      ssmesh.Finalize();
+
+      without_internal = CheckPoisson(ssmesh, p,
+                                      ssmesh.bdr_attributes.Max()); // Exclude the internal boundary
+      with_internal = CheckPoisson(ssmesh, p); // Include the internal boundary
+
+      // All slaves dofs that are introduced on the face are constrained by
+      // the master dofs, thus the additional constraints on the internal
+      // boundary are purely on the master face, which matches the initial
+      // unrefined case.
+      switch (p)
+      {
+         case 1:
+            CHECK(with_internal == without_internal); break;
+         case 2:
+            CHECK(with_internal == without_internal + 1); break;
+         case 3:
+            CHECK(with_internal == without_internal + 4); break;
+      }
+   }
+}
+
+TEST_CASE("RefinedCubesInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+   smesh.EnsureNCMesh();
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNBE() == 2 * 5);
+
+   delete smesh.ncmesh;
+   smesh.ncmesh = nullptr;
+
+   smesh.UniformRefinement();
+
+   // Introduce four internal boundary elements
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(7);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Exactly four boundary elements must be added
+   CHECK(smesh.GetNBE() == 2 * 5 * 4 + 4);
+
+   smesh.EnsureNCMesh();
+   CHECK(smesh.GetNBE() == 2 * 5 * 4 + 4);
+
+   int without_internal = CheckPoisson(smesh, p,
+                                       7); // Exclude the internal boundary
+   int with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal + 1); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3 * 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 5 * 5); break;
+   }
+
+   // Mark all elements on one side of the attribute boundary to refine
+   refs.DeleteAll();
+   for (int n = 0; n < smesh.GetNE(); ++n)
+   {
+      if (smesh.GetAttribute(n) == 2)
+      {
+         refs.Append(Refinement{n, Refinement::XYZ});
+      }
+   }
+
+   smesh.GeneralRefinement(refs);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // There should now be 16 internal boundary elements, where there were 4 before
+
+   CHECK(smesh.GetNBE() == 5 * 4 /* external boundaries of unrefined domain  */
+         + 4 * 4 /* internal boundaries */
+         + 5 * 16 /* external boundaries of refined elements */);
+
+
+   // Count the number of internal boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal;
+      }
+   }
+   CHECK(num_internal == 16);
+
+
+   without_internal = CheckPoisson(smesh, p,
+                                   smesh.bdr_attributes.Max()); // Exclude the internal boundary
+   with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal + 1); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3 * 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 5 * 5); break;
+   }
+}
+
+TEST_CASE("ReferenceTetInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNE() == 2);
+   REQUIRE(smesh.GetNBE() == 2 * 3);
+
+   // Introduce an internal boundary element
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(5);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   // Exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 3 + 1);
+
+   smesh.EnsureNCMesh(true);
+
+   // Still exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 3 + 1);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   auto without_internal = CheckPoisson(smesh, p,
+                                        5); // Exclude the internal boundary
+   auto with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal); break;
+      case 3:
+         CHECK(with_internal == without_internal + 1); break;
+   }
+
+   // Now NC refine one of the attached elements, this should result in 2
+   // internal boundary elements.
+   for (int ref : {0, 1})
+   {
+      refs[0].index = ref;
+      refs[0].ref_type = Refinement::XYZ;
+      auto ssmesh = Mesh(smesh);
+      ssmesh.GeneralRefinement(refs);
+
+      // There should now be four internal boundary elements, where there was one
+      // before.
+      CHECK(ssmesh.GetNBE() == 3 /* external boundaries of unrefined element  */
+            + 4 /* internal boundaries */
+            + (3 * 4) /* external boundaries of refined element */);
+
+      // Count the number of internal boundary elements
+      int num_internal = 0;
+      for (int n = 0; n < ssmesh.GetNBE(); ++n)
+      {
+         int f, o;
+         ssmesh.GetBdrElementFace(n, &f, &o);
+         int e1, e2;
+         ssmesh.GetFaceElements(f, &e1, &e2);
+         if (e1 >= 0 && e2 >= 0 && ssmesh.GetAttribute(e1) != ssmesh.GetAttribute(e2))
+         {
+            ++num_internal;
+         }
+      }
+      CHECK(num_internal == 4);
+
+      without_internal = CheckPoisson(ssmesh, p, 5); // Exclude the internal boundary
+      with_internal = CheckPoisson(ssmesh, p); // Include the internal boundary
+
+      switch (p)
+      {
+         case 1:
+            CHECK(with_internal == without_internal); break;
+         case 2:
+            CHECK(with_internal == without_internal); break;
+         case 3:
+            CHECK(with_internal == without_internal + 1); break;
+      }
+   }
+}
+
+TEST_CASE("RefinedTetsInternalBoundaries", "[NCMesh]")
+{
+   auto p = GENERATE(1,2,3);
+   CAPTURE(p);
+
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+   Array<Refinement> refs;
+   refs.Append(Refinement(0, Refinement::X));
+   smesh.GeneralRefinement(refs);
+
+   // Now have a pair of elements, make the second element a different
+   // attribute.
+   smesh.SetAttribute(1, 2);
+
+   REQUIRE(smesh.GetNE() == 2);
+   REQUIRE(smesh.GetNBE() == 2 * 3);
+
+   smesh.UniformRefinement();
+
+   CHECK(smesh.GetNBE() == 2 * 3 * 4);
+
+   // Introduce internal boundary elements
+   for (int f = 0; f < smesh.GetNumFaces(); ++f)
+   {
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         // This is the internal face between attributes.
+         auto *new_elem = smesh.GetFace(f)->Duplicate(&smesh);
+         new_elem->SetAttribute(5);
+         smesh.AddBdrElement(new_elem);
+      }
+   }
+
+   // Exactly four boundary elements must be added
+   CHECK(smesh.GetNBE() == 2 * 3 * 4 + 4);
+
+   smesh.EnsureNCMesh(true);
+
+   // Still exactly one boundary element must be added
+   CHECK(smesh.GetNBE() == 2 * 3 * 4 + 4);
+
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   auto without_internal = CheckPoisson(smesh, p,
+                                        5); // Exclude the internal boundary
+   auto with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 10); break;
+   }
+
+   // Now NC refine all elements with the 2 attribute.
+
+   // Mark all elements on one side of the attribute boundary to refine
+   refs.DeleteAll();
+   for (int n = 0; n < smesh.GetNE(); ++n)
+   {
+      if (smesh.GetAttribute(n) == 2)
+      {
+         refs.Append(Refinement{n, Refinement::XYZ});
+      }
+   }
+
+   smesh.GeneralRefinement(refs);
+
+   // There should now be four internal boundary elements, where there was one
+   // before.
+   CHECK(smesh.GetNBE() == 3 * 4 /* external boundaries of unrefined elements  */
+         + 4 * 4 /* internal boundaries */
+         + (3 * 4 * 4) /* external boundaries of refined elements */);
+
+   // Count the number of internal boundary elements
+   int num_internal = 0;
+   for (int n = 0; n < smesh.GetNBE(); ++n)
+   {
+      int f, o;
+      smesh.GetBdrElementFace(n, &f, &o);
+      int e1, e2;
+      smesh.GetFaceElements(f, &e1, &e2);
+      if (e1 >= 0 && e2 >= 0 && smesh.GetAttribute(e1) != smesh.GetAttribute(e2))
+      {
+         ++num_internal;
+      }
+   }
+   CHECK(num_internal == 4 * 4);
+
+   without_internal = CheckPoisson(smesh, p, 5); // Exclude the internal boundary
+   with_internal = CheckPoisson(smesh, p); // Include the internal boundary
+
+   switch (p)
+   {
+      case 1:
+         CHECK(with_internal == without_internal); break;
+      case 2:
+         CHECK(with_internal == without_internal + 3); break;
+      case 3:
+         CHECK(with_internal == without_internal + 10); break;
+   }
+}
+
+TEST_CASE("PoissonOnReferenceCubeNC", "[NCMesh]")
+{
+   auto smesh = Mesh("../../data/ref-cube.mesh");
+   smesh.EnsureNCMesh();
+   Array<Refinement> refs(1);
+   refs[0].index = 0;
+   refs[0].ref_type = Refinement::X;
+   smesh.GeneralRefinement(refs);
+
+   // Now have two elements.
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   auto p = GENERATE(1, 2, 3);
+   CAPTURE(p);
+
+   // Check that Poisson can be solved on the domain
+   CheckPoisson(smesh, p);
+
+   auto ref_type = char(GENERATE(Refinement::X, Refinement::Y, Refinement::Z,
+                                 Refinement::XY, Refinement::XZ, Refinement::YZ,
+                                 Refinement::XYZ));
+   CAPTURE(ref_type);
+   for (auto refined_elem : {0}) // The left or the right element
+   {
+      refs[0].index = refined_elem;
+      auto ssmesh = Mesh(smesh);
+
+      // Now NC refine one of the attached elements
+      refs[0].ref_type = ref_type;
+
+      ssmesh.GeneralRefinement(refs);
+      ssmesh.FinalizeTopology();
+      ssmesh.Finalize();
+
+      CAPTURE(refined_elem);
+      CheckPoisson(ssmesh, p);
+   }
+}
+
+TEST_CASE("PoissonOnReferenceTetNC", "[NCMesh]")
+{
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+   auto p = GENERATE(1, 2, 3);
+   CAPTURE(p);
+
+   CheckPoisson(smesh, p);
+
+   Array<Refinement> refs(1);
+   refs[0].index = 0;
+   refs[0].ref_type = Refinement::X;
+
+   smesh.GeneralRefinement(refs);
+
+   // Now have two elements.
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Check that Poisson can be solved on the pair of tets
+   CheckPoisson(smesh, p);
+
+   auto nc = GENERATE(false, true);
+   CAPTURE(nc);
+
+   smesh.EnsureNCMesh(GENERATE(false, true));
+
+   for (auto refined_elem : {0, 1})
+   {
+      auto ssmesh = Mesh(smesh);
+
+      refs[0].index = refined_elem;
+      refs[0].ref_type = Refinement::XYZ;
+
+      ssmesh.GeneralRefinement(refs);
+      ssmesh.FinalizeTopology();
+      ssmesh.Finalize();
+
+      CAPTURE(refined_elem);
+      CheckPoisson(ssmesh, p);
+   }
+}
+
+TEST_CASE("TetBoundaryRefinement", "[NCMesh]")
+{
+   auto smesh = Mesh("../../data/ref-tetrahedron.mesh");
+
+
+   smesh.FinalizeTopology();
+   smesh.Finalize(true);
+   smesh.UniformRefinement();
+
+   smesh.EnsureNCMesh(true);
+
+   CHECK(smesh.GetNBE() == 4 * 4);
+
+   // Loop over elements and mark for refinement if any vertices match the
+   // original
+   Array<int> vertices, elements;
+   // reference vertices of (0,0,0), (1,0,0), (0,1,0), (0,0,1) are [0,3]
+   auto original_vert = [](int i) { return i >= 0 && i <= 3; };
+   for (int n = 0; n < smesh.GetNE(); ++n)
+   {
+      smesh.GetElementVertices(n, vertices);
+      if (std::any_of(vertices.begin(), vertices.end(), original_vert))
+      {
+         elements.Append(n);
+      }
+   }
+
+   smesh.GeneralRefinement(elements);
+   smesh.FinalizeTopology();
+   smesh.Finalize();
+
+   // Each side of the tetrahedron should now have 1 original face, and then 3 *
+   // 4 nonconformally generated faces.
+   CHECK(smesh.GetNBE() == 4 * (1 + 3 * 4));
+}
 
 } // namespace mfem
