diff --git a/data/equilateral-pyramid.mesh b/data/equilateral-pyramid.mesh
new file mode 100644
index 000000000..4fb4752f4
--- /dev/null
+++ b/data/equilateral-pyramid.mesh
@@ -0,0 +1,38 @@
+MFEM mesh v1.0
+
+#
+# MFEM Geometry Types (see fem/geom.hpp):
+#
+# POINT       = 0
+# SEGMENT     = 1
+# TRIANGLE    = 2
+# SQUARE      = 3
+# TETRAHEDRON = 4
+# CUBE        = 5
+# PRISM       = 6
+# PYRAMID     = 7
+#
+
+dimension
+3
+
+elements
+1
+1 7 0 1 2 3 4
+
+boundary
+5
+1 3 3 2 1 0
+2 2 0 1 4
+3 2 1 2 4
+4 2 2 3 4
+5 2 3 0 4
+
+vertices
+5
+3
+-0.5 -0.5 0
+0.5 -0.5 0
+0.5 0.5 0
+-0.5 0.5 0
+0 0 0.7071067811865475
diff --git a/data/fichera-mixed-16.mesh b/data/fichera-mixed-16.mesh
new file mode 100644
index 000000000..6b3ea9cf5
--- /dev/null
+++ b/data/fichera-mixed-16.mesh
@@ -0,0 +1,108 @@
+MFEM mesh v1.0
+
+#
+# MFEM Geometry Types (see fem/geom.hpp):
+#
+# POINT       = 0
+# SEGMENT     = 1
+# TRIANGLE    = 2
+# SQUARE      = 3
+# TETRAHEDRON = 4
+# CUBE        = 5
+# PRISM       = 6
+# PYRAMID     = 7
+#
+
+dimension
+3
+
+elements
+16
+1 5 12 13 16 15 21 22 25 24
+1 6  9 12  8 18 21 17
+1 6 11  8 12 20 17 21
+1 6  3  2 12  6  5 15
+1 6 11 12  2 14 15  5
+1 6  3 12  0  4 13  1
+1 6  9  0 12 10  1 13
+1 7 12 13 22 21 19
+1 7 15 16 13 12  7
+1 7 12 21 24 15 23
+1 7  9 12 21 18 19
+1 7 11 20 21 12 23
+1 7  9 10 13 12 19
+1 7 11 12 15 14 23
+1 7  3  6 15 12  7
+1 7  3 12 13  4  7
+
+boundary
+39
+ 1 3  5  6  3  2
+ 2 2  6  7  3
+ 2 2  7  4  3
+ 3 3  3  4  1  0
+ 4 2 11 12  8
+ 4 2  9  8 12
+ 5 2  3 12  2
+ 5 2 11  2 12
+ 6 3  0  1 10  9
+ 7 2 10 19  9
+ 7 2 18  9 19
+ 8 3  8  9 18 17
+ 9 2  4 13  1
+ 9 2 10  1 13
+10 2  4  7 13
+10 2 16 13  7
+11 3 13 16 25 22
+12 2 10 13 19
+12 2 22 19 13
+13 2  6 15  7
+13 2 16  7 15
+14 2  6  5 15
+14 2 14 15  5
+15 2 14 23 15
+15 2 24 15 23
+16 3 16 15 24 25
+17 3  5  2 11 14
+18 2  3  0 12
+18 2  9 12  0
+19 3 11  8 17 20
+20 2 14 11 23
+20 2 20 23 11
+21 2 18 21 17
+21 2 20 17 21
+22 2 18 19 21
+22 2 22 21 19
+23 3 21 22 25 24
+24 2 20 21 23
+24 2 24 23 21
+
+vertices
+26
+3
+0 -1 -1
+1 -1 -1
+-1 0 -1
+0 0 -1
+1 0 -1
+-1 1 -1
+0 1 -1
+1 1 -1
+-1 -1 0
+0 -1 0
+1 -1 0
+-1 0 0
+0 0 0
+1 0 0
+-1 1 0
+0 1 0
+1 1 0
+-1 -1 1
+0 -1 1
+1 -1 1
+-1 0 1
+0 0 1
+1 0 1
+-1 1 1
+0 1 1
+1 1 1
diff --git a/fem/CMakeLists.txt b/fem/CMakeLists.txt
index 2eacb1234..b3c46f4c8 100644
--- a/fem/CMakeLists.txt
+++ b/fem/CMakeLists.txt
@@ -73,6 +73,7 @@ set(SRCS
   fe/fe_nd.cpp
   fe/fe_nurbs.cpp
   fe/fe_pos.cpp
+  fe/fe_pyramid.cpp
   fe/fe_rt.cpp
   fe/fe_ser.cpp
   fe_coll.cpp
@@ -185,6 +186,7 @@ set(HDRS
   fe/fe_nd.hpp
   fe/fe_nurbs.hpp
   fe/fe_pos.hpp
+  fe/fe_pyramid.hpp
   fe/fe_rt.hpp
   fe/fe_ser.hpp
   fe_coll.hpp
diff --git a/fem/doftrans.cpp b/fem/doftrans.cpp
index 7181fa0fe..841c19cd8 100644
--- a/fem/doftrans.cpp
+++ b/fem/doftrans.cpp
@@ -201,13 +201,16 @@ const DenseTensor ND_DofTransformation
 ::TInv(const_cast<real_t *>(TInv_data), 2, 2, 6);
 
 ND_DofTransformation::ND_DofTransformation(int size, int p, int num_edges,
-                                           int num_tri_faces)
+                                           int num_faces,
+                                           int face_types[])
    : StatelessDofTransformation(size)
    , order(p)
    , nedofs(p)
-   , nfdofs(p*(p-1))
+   , ntdofs(p*(p-1))
+   , nqdofs(2*p*(p-1))
    , nedges(num_edges)
-   , nfaces(num_tri_faces)
+   , nfaces(num_faces)
+   , ftypes(face_types)
 {
 }
 
@@ -221,6 +224,7 @@ void ND_DofTransformation::TransformPrimal(const Array<int> & Fo,
                "Face orientation array is shorter than the number of faces in "
                "ND_DofTransformation");
 
+   int of = 0;
    real_t data[2];
    Vector v2(data, 2);
    DenseMatrix T2;
@@ -228,11 +232,19 @@ void ND_DofTransformation::TransformPrimal(const Array<int> & Fo,
    // Transform face DoFs
    for (int f=0; f<nfaces; f++)
    {
-      for (int i=0; i<nfdofs/2; i++)
+      if (ftypes[f] == Geometry::TRIANGLE)
       {
-         v2 = &v[nedges*nedofs + f*nfdofs + 2*i];
-         T2.UseExternalData(const_cast<real_t *>(T.GetData(Fo[f])), 2, 2);
-         T2.Mult(v2, &v[nedges*nedofs + f*nfdofs + 2*i]);
+         for (int i=0; i<ntdofs/2; i++)
+         {
+            v2 = &v[nedges*nedofs + of + 2*i];
+            T2.UseExternalData(const_cast<real_t *>(T.GetData(Fo[f])), 2, 2);
+            T2.Mult(v2, &v[nedges*nedofs + of + 2*i]);
+         }
+         of += ntdofs;
+      }
+      else
+      {
+         of += nqdofs;
       }
    }
 }
@@ -247,6 +259,7 @@ void ND_DofTransformation::InvTransformPrimal(const Array<int> & Fo,
                "Face orientation array is shorter than the number of faces in "
                "ND_DofTransformation");
 
+   int of = 0;
    real_t data[2];
    Vector v2(data, 2);
    DenseMatrix T2Inv;
@@ -254,11 +267,19 @@ void ND_DofTransformation::InvTransformPrimal(const Array<int> & Fo,
    // Transform face DoFs
    for (int f=0; f<nfaces; f++)
    {
-      for (int i=0; i<nfdofs/2; i++)
+      if (ftypes[f] == Geometry::TRIANGLE)
       {
-         v2 = &v[nedges*nedofs + f*nfdofs + 2*i];
-         T2Inv.UseExternalData(const_cast<real_t *>(TInv.GetData(Fo[f])), 2, 2);
-         T2Inv.Mult(v2, &v[nedges*nedofs + f*nfdofs + 2*i]);
+         for (int i=0; i<ntdofs/2; i++)
+         {
+            v2 = &v[nedges*nedofs + of + 2*i];
+            T2Inv.UseExternalData(const_cast<real_t *>(TInv.GetData(Fo[f])), 2, 2);
+            T2Inv.Mult(v2, &v[nedges*nedofs + of + 2*i]);
+         }
+         of += ntdofs;
+      }
+      else
+      {
+         of += nqdofs;
       }
    }
 }
@@ -272,6 +293,7 @@ void ND_DofTransformation::TransformDual(const Array<int> & Fo, real_t *v) const
                "Face orientation array is shorter than the number of faces in "
                "ND_DofTransformation");
 
+   int of = 0;
    real_t data[2];
    Vector v2(data, 2);
    DenseMatrix T2Inv;
@@ -279,12 +301,21 @@ void ND_DofTransformation::TransformDual(const Array<int> & Fo, real_t *v) const
    // Transform face DoFs
    for (int f=0; f<nfaces; f++)
    {
-      for (int i=0; i<nfdofs/2; i++)
+      if (ftypes[f] == Geometry::TRIANGLE)
       {
-         v2 = &v[nedges*nedofs + f*nfdofs + 2*i];
-         T2Inv.UseExternalData(const_cast<real_t *>(TInv.GetData(Fo[f])), 2, 2);
-         T2Inv.MultTranspose(v2, &v[nedges*nedofs + f*nfdofs + 2*i]);
+         for (int i=0; i<ntdofs/2; i++)
+         {
+            v2 = &v[nedges*nedofs + of + 2*i];
+            T2Inv.UseExternalData(const_cast<real_t *>(TInv.GetData(Fo[f])), 2, 2);
+            T2Inv.MultTranspose(v2, &v[nedges*nedofs + of + 2*i]);
+         }
+         of += ntdofs;
+      }
+      else
+      {
+         of += nqdofs;
       }
+
    }
 }
 
@@ -298,6 +329,7 @@ void ND_DofTransformation::InvTransformDual(const Array<int> & Fo,
                "Face orientation array is shorter than the number of faces in "
                "ND_DofTransformation");
 
+   int of = 0;
    real_t data[2];
    Vector v2(data, 2);
    DenseMatrix T2;
@@ -305,11 +337,19 @@ void ND_DofTransformation::InvTransformDual(const Array<int> & Fo,
    // Transform face DoFs
    for (int f=0; f<nfaces; f++)
    {
-      for (int i=0; i<nfdofs/2; i++)
+      if (ftypes[f] == Geometry::TRIANGLE)
+      {
+         for (int i=0; i<ntdofs/2; i++)
+         {
+            v2 = &v[nedges*nedofs + of + 2*i];
+            T2.UseExternalData(const_cast<real_t *>(T.GetData(Fo[f])), 2, 2);
+            T2.MultTranspose(v2, &v[nedges*nedofs + of + 2*i]);
+         }
+         of += ntdofs;
+      }
+      else
       {
-         v2 = &v[nedges*nedofs + f*nfdofs + 2*i];
-         T2.UseExternalData(const_cast<real_t *>(T.GetData(Fo[f])), 2, 2);
-         T2.MultTranspose(v2, &v[nedges*nedofs + f*nfdofs + 2*i]);
+         of += nqdofs;
       }
    }
 }
diff --git a/fem/doftrans.hpp b/fem/doftrans.hpp
index a9e5bd81e..12feef7d8 100644
--- a/fem/doftrans.hpp
+++ b/fem/doftrans.hpp
@@ -306,13 +306,16 @@ private:
    static const DenseTensor T, TInv;
 
 protected:
-   const int order;  // basis function order
-   const int nedofs; // number of DoFs per edge
-   const int nfdofs; // number of DoFs per face
-   const int nedges; // number of edges per element
-   const int nfaces; // number of triangular faces per element
+   const int  order;  // basis function order
+   const int  nedofs; // number of DoFs per edge
+   const int  ntdofs; // number of DoFs per triangular face
+   const int  nqdofs; // number of DoFs per quadrilateral face
+   const int  nedges; // number of edges per element
+   const int  nfaces; // number of faces per element
+   const int *ftypes; // Pointer to array of Geometry::Type for each face
 
-   ND_DofTransformation(int size, int order, int num_edges, int num_tri_faces);
+   ND_DofTransformation(int size, int order, int num_edges, int num_faces,
+                        int *face_types);
 
 public:
    // Return the 2x2 transformation operator for the given face orientation
@@ -322,7 +325,7 @@ public:
    static const DenseMatrix & GetFaceInverseTransform(int ori)
    { return TInv(ori); }
 
-   bool IsIdentity() const override { return nfdofs < 2; }
+   bool IsIdentity() const override { return ntdofs < 2; }
 
    void TransformPrimal(const Array<int> & Fo, real_t *v) const override;
    void InvTransformPrimal(const Array<int> & Fo, real_t *v) const override;
@@ -334,9 +337,11 @@ public:
 /// triangles
 class ND_TriDofTransformation : public ND_DofTransformation
 {
+private:
+   const int face_type[1] = { Geometry::TRIANGLE };
 public:
    ND_TriDofTransformation(int order)
-      : ND_DofTransformation(order*(order + 2), order, 3, 1)
+      : ND_DofTransformation(order*(order + 2), order, 3, 1, (int *)face_type)
    {}
 };
 
@@ -345,7 +350,9 @@ class ND_TetDofTransformation : public ND_DofTransformation
 {
 public:
    ND_TetDofTransformation(int order)
-      : ND_DofTransformation(order*(order + 2)*(order + 3)/2, order, 6, 4)
+      : ND_DofTransformation(order*(order + 2)*(order + 3)/2, order, 6, 4,
+                             (int *)Geometry::Constants<Geometry::TETRAHEDRON>::
+                             FaceTypes)
    {}
 };
 
@@ -355,7 +362,21 @@ class ND_WedgeDofTransformation : public ND_DofTransformation
 public:
    ND_WedgeDofTransformation(int order)
       : ND_DofTransformation(3 * order * ((order + 1) * (order + 2))/2,
-                             order, 9, 2)
+                             order, 9, 5,
+                             (int *)Geometry::Constants<Geometry::PRISM>::
+                             FaceTypes)
+   {}
+};
+
+/// DoF transformation implementation for the Nedelec basis on pyramid elements
+class ND_PyramidDofTransformation : public ND_DofTransformation
+{
+public:
+   ND_PyramidDofTransformation(int order)
+      : ND_DofTransformation(2 * order * (order * (order + 1) + 2),
+                             order, 8, 5,
+                             (int *)Geometry::Constants<Geometry::PYRAMID>::
+                             FaceTypes)
    {}
 };
 
diff --git a/fem/eltrans.cpp b/fem/eltrans.cpp
index 4ce070dda..6146a3c62 100644
--- a/fem/eltrans.cpp
+++ b/fem/eltrans.cpp
@@ -444,6 +444,8 @@ int IsoparametricTransformation::OrderJ() const
          return (FElem->GetOrder()-1);
       case FunctionSpace::Qk:
          return (FElem->GetOrder());
+      case FunctionSpace::Uk:
+         return (FElem->GetOrder());
       default:
          MFEM_ABORT("unsupported finite element");
    }
@@ -458,6 +460,8 @@ int IsoparametricTransformation::OrderW() const
          return (FElem->GetOrder() - 1) * FElem->GetDim();
       case FunctionSpace::Qk:
          return (FElem->GetOrder() * FElem->GetDim() - 1);
+      case FunctionSpace::Uk:
+         return (FElem->GetOrder() * FElem->GetDim());
       default:
          MFEM_ABORT("unsupported finite element");
    }
@@ -477,6 +481,8 @@ int IsoparametricTransformation::OrderGrad(const FiniteElement *fe) const
             return ((k-1)*(d-1)+(l-1));
          case FunctionSpace::Qk:
             return (k*(d-1)+(l-1));
+         case FunctionSpace::Uk:
+            return (k*(d-1)+(l-1));
          default:
             MFEM_ABORT("unsupported finite element");
       }
diff --git a/fem/fe/fe_base.cpp b/fem/fe/fe_base.cpp
index 12b596ca6..100ca5294 100644
--- a/fem/fe/fe_base.cpp
+++ b/fem/fe/fe_base.cpp
@@ -2168,6 +2168,64 @@ void Poly_1D::CalcDBinomTerms(const int p, const real_t x, const real_t y,
    }
 }
 
+void Poly_1D::CalcDxBinomTerms(const int p, const real_t x, const real_t y,
+                               real_t *u)
+{
+   if (p == 0)
+   {
+      u[0] = 0.;
+   }
+   else
+   {
+      int i;
+      const int *b = Binom(p);
+      real_t z = 1.;
+
+      for (i = 1; i < p; i++)
+      {
+         u[i] = i * b[i]*z;
+         z *= x;
+      }
+      u[p] = i * z;
+      z = y;
+      for (i--; i > 0; i--)
+      {
+         u[i] *= z;
+         z *= y;
+      }
+      u[0] = 0;
+   }
+}
+
+void Poly_1D::CalcDyBinomTerms(const int p, const real_t x, const real_t y,
+                               real_t *u)
+{
+   if (p == 0)
+   {
+      u[0] = 0.;
+   }
+   else
+   {
+      int i;
+      const int *b = Binom(p);
+      real_t z = x;
+
+      for (i = 1; i < p; i++)
+      {
+         u[i] = b[i]*z;
+         z *= x;
+      }
+      u[p] = 0.;
+      z = 1.;
+      for (i--; i > 0; i--)
+      {
+         u[i] *= (p - i) * z;
+         z *= y;
+      }
+      u[0] = p * z;
+   }
+}
+
 void Poly_1D::CalcLegendre(const int p, const real_t x, real_t *u)
 {
    // use the recursive definition for [-1,1]:
diff --git a/fem/fe/fe_base.hpp b/fem/fe/fe_base.hpp
index 169ff7979..c2dc701a8 100644
--- a/fem/fe/fe_base.hpp
+++ b/fem/fe/fe_base.hpp
@@ -223,9 +223,10 @@ class FunctionSpace
 public:
    enum
    {
-      Pk, ///< Polynomials of order k
-      Qk, ///< Tensor products of polynomials of order k
-      rQk ///< Refined tensor products of polynomials of order k
+      Pk,  ///< Polynomials of order k
+      Qk,  ///< Tensor products of polynomials of order k
+      rQk, ///< Refined tensor products of polynomials of order k
+      Uk   ///< Rational polynomials of order k
    };
 };
 
@@ -1158,6 +1159,16 @@ public:
        in the already allocated @a d array.*/
    static void CalcDBinomTerms(const int p, const real_t x, const real_t y,
                                real_t *d);
+   /** @brief Compute the derivatives (w.r.t. x) of the terms in the expansion
+       of the binomial (x + y)^p.  Store the results in the already allocated
+       @a d array.*/
+   static void CalcDxBinomTerms(const int p, const real_t x, const real_t y,
+                                real_t *d);
+   /** @brief Compute the derivatives (w.r.t. y) of the terms in the expansion
+       of the binomial (x + y)^p.  Store the results in the already allocated
+       @a d array.*/
+   static void CalcDyBinomTerms(const int p, const real_t x, const real_t y,
+                                real_t *d);
 
    /** @brief Compute the values of the Bernstein basis functions of order
        @a p at coordinate @a x and store the results in the already allocated
diff --git a/fem/fe/fe_fixed_order.cpp b/fem/fe/fe_fixed_order.cpp
index 0556e3456..036217161 100644
--- a/fem/fe/fe_fixed_order.cpp
+++ b/fem/fe/fe_fixed_order.cpp
@@ -1341,7 +1341,7 @@ const
 
 
 LinearPyramidFiniteElement::LinearPyramidFiniteElement()
-   : NodalFiniteElement(3, Geometry::PYRAMID, 5, 1)
+   : NodalFiniteElement(3, Geometry::PYRAMID, 5, 1, FunctionSpace::Uk)
 {
    Nodes.IntPoint(0).x = 0.0;
    Nodes.IntPoint(0).y = 0.0;
@@ -3015,7 +3015,7 @@ void P0WdgFiniteElement::CalcDShape(const IntegrationPoint &ip,
 
 
 P0PyrFiniteElement::P0PyrFiniteElement()
-   : NodalFiniteElement(3, Geometry::PYRAMID, 1, 0, FunctionSpace::Qk)
+   : NodalFiniteElement(3, Geometry::PYRAMID, 1, 0, FunctionSpace::Uk)
 {
    Nodes.IntPoint(0).x = 0.375;
    Nodes.IntPoint(0).y = 0.375;
@@ -4866,7 +4866,11 @@ void Nedelec1PyrFiniteElement::CalcVShape(const IntegrationPoint &ip,
    {
       // We must return the limit of the basis functions as z->1.  In order to
       // remain inside the pyramid in this limit the x and y coordinates must
-      // be approaching 0. The resulting limiting basis function values are:
+      // be approaching 0. Unfortunately we obtain different limits if we
+      // approach (0,0,1) from different directions. The values provided below
+      // are the limits as x->(1-z)/2 and y->(1-z)/2 i.e. along the line from
+      // the center of the base of the pyramid towards the apex. The resulting
+      // limiting basis function values are:
       shape(0,0) =   0.;
       shape(0,1) =   0.;
       shape(0,2) =   0.;
@@ -4883,21 +4887,21 @@ void Nedelec1PyrFiniteElement::CalcVShape(const IntegrationPoint &ip,
       shape(3,1) =   0.;
       shape(3,2) =   0.;
 
-      shape(4,0) =   1.;
-      shape(4,1) =   1.;
-      shape(4,2) =   1.;
+      shape(4,0) =   0.5;
+      shape(4,1) =   0.5;
+      shape(4,2) =   0.75;
 
-      shape(5,0) = - 1.;
-      shape(5,1) =   0.;
-      shape(5,2) =   0.;
+      shape(5,0) = - 0.5;
+      shape(5,1) =   0.5;
+      shape(5,2) =   0.25;
 
-      shape(6,0) =   0.;
-      shape(6,1) =   0.;
-      shape(6,2) =   0.;
+      shape(6,0) = - 0.5;
+      shape(6,1) = - 0.5;
+      shape(6,2) = - 0.25;
 
-      shape(7,0) =   0.;
-      shape(7,1) = - 1.;
-      shape(7,2) =   0.;
+      shape(7,0) =   0.5;
+      shape(7,1) = - 0.5;
+      shape(7,2) =   0.25;
 
       return;
    }
@@ -4946,6 +4950,532 @@ const
 
    real_t tol = 1e-6;
 
+   if (oz <= tol)
+   {
+      // We must return the limit of the basis function derivatives as z->1.
+      // In order to remain inside the pyramid in this limit the x and y
+      // coordinates must be approaching 0. The resulting limiting basis
+      // function values are:
+      curl_shape(0,0) = - 0.5;
+      curl_shape(0,1) = - 1.5;
+      curl_shape(0,2) =   1.;
+
+      curl_shape(1,0) =   0.5;
+      curl_shape(1,1) = - 0.5;
+      curl_shape(1,2) =   1.;
+
+      curl_shape(2,0) =   0.5;
+      curl_shape(2,1) = - 0.5;
+      curl_shape(2,2) = - 1.;
+
+      curl_shape(3,0) =   1.5;
+      curl_shape(3,1) =   0.5;
+      curl_shape(3,2) = - 1.;
+
+      curl_shape(4,0) = - 1.;
+      curl_shape(4,1) =   1.;
+      curl_shape(4,2) =   0.;
+
+      curl_shape(5,0) = - 1.;
+      curl_shape(5,1) = - 1.;
+      curl_shape(5,2) =   0.;
+
+      curl_shape(6,0) =   1.;
+      curl_shape(6,1) = - 1.;
+      curl_shape(6,2) =   0.;
+
+      curl_shape(7,0) =   1.;
+      curl_shape(7,1) =   1.;
+      curl_shape(7,2) =   0.;
+
+      return;
+   }
+
+   real_t ozi = 1. / oz;
+
+   curl_shape(0,0) = - x * ozi;
+   curl_shape(0,1) = - 2. + y * ozi;
+   curl_shape(0,2) =   1.;
+
+   curl_shape(1,0) =   x * ozi;
+   curl_shape(1,1) = - y * ozi;
+   curl_shape(1,2) =   1.;
+
+   curl_shape(2,0) =   x * ozi;
+   curl_shape(2,1) = - y * ozi;
+   curl_shape(2,2) = - 1.;
+
+   curl_shape(3,0) =   (2. - x  - z2) * ozi;
+   curl_shape(3,1) =   y * ozi;
+   curl_shape(3,2) = - 1.;
+
+   curl_shape(4,0) = - 2. * ox * ozi;
+   curl_shape(4,1) =   2. * oy * ozi;
+   curl_shape(4,2) =   0.;
+
+   curl_shape(5,0) = - 2. * x * ozi;
+   curl_shape(5,1) = - 2. * oy * ozi;
+   curl_shape(5,2) =   0.;
+
+   curl_shape(6,0) =   2. * x * ozi;
+   curl_shape(6,1) = - 2. * y * ozi;
+   curl_shape(6,2) =   0.;
+
+   curl_shape(7,0) =   2. * ox * ozi;
+   curl_shape(7,1) =   2. * y * ozi;
+   curl_shape(7,2) =   0.;
+}
+
+const real_t Nedelec1PyrFiniteElement::tk[8][3] =
+{{1,0,0}, {0,1,0}, {1,0,0}, {0,1,0}, {0,0,1}, {-1,0,1}, {-1,-1,1}, {0,-1,1}};
+
+void Nedelec1PyrFiniteElement::GetLocalInterpolation (
+   ElementTransformation &Trans, DenseMatrix &I) const
+{
+   int k, j;
+#ifdef MFEM_THREAD_SAFE
+   DenseMatrix vshape(dof, dim);
+#endif
+
+#ifdef MFEM_DEBUG
+   for (k = 0; k < dof; k++)
+   {
+      CalcVShape (Nodes.IntPoint(k), vshape);
+      for (j = 0; j < dof; j++)
+      {
+         real_t d = ( vshape(j,0)*tk[k][0] + vshape(j,1)*tk[k][1] +
+                      vshape(j,2)*tk[k][2] );
+         if (j == k) { d -= 1.0; }
+         if (fabs(d) > 1.0e-12)
+         {
+            mfem::err << "Nedelec1PyrFiniteElement::GetLocalInterpolation (...)\n"
+                      " k = " << k << ", j = " << j << ", d = " << d << endl;
+            mfem_error();
+         }
+      }
+   }
+#endif
+
+   IntegrationPoint ip;
+   ip.x = ip.y = ip.z = 0.0;
+   Trans.SetIntPoint (&ip);
+   // Trans must be linear
+   const DenseMatrix &J = Trans.Jacobian();
+   real_t vk[3];
+   Vector xk (vk, 3);
+
+   for (k = 0; k < dof; k++)
+   {
+      Trans.Transform (Nodes.IntPoint (k), xk);
+      ip.x = vk[0]; ip.y = vk[1]; ip.z = vk[2];
+      CalcVShape (ip, vshape);
+      //  vk = J tk
+      vk[0] = J(0,0)*tk[k][0]+J(0,1)*tk[k][1]+J(0,2)*tk[k][2];
+      vk[1] = J(1,0)*tk[k][0]+J(1,1)*tk[k][1]+J(1,2)*tk[k][2];
+      vk[2] = J(2,0)*tk[k][0]+J(2,1)*tk[k][1]+J(2,2)*tk[k][2];
+      for (j = 0; j < dof; j++)
+         if (fabs (I(k,j) = (vshape(j,0)*vk[0]+vshape(j,1)*vk[1]+
+                             vshape(j,2)*vk[2])) < 1.0e-12)
+         {
+            I(k,j) = 0.0;
+         }
+   }
+}
+
+void Nedelec1PyrFiniteElement::Project (
+   VectorCoefficient &vc, ElementTransformation &Trans,
+   Vector &dofs) const
+{
+   real_t vk[3];
+   Vector xk (vk, 3);
+
+   for (int k = 0; k < dof; k++)
+   {
+      Trans.SetIntPoint (&Nodes.IntPoint (k));
+      const DenseMatrix &J = Trans.Jacobian();
+
+      vc.Eval (xk, Trans, Nodes.IntPoint (k));
+      //  xk^t J tk
+      dofs(k) =
+         vk[0] * ( J(0,0)*tk[k][0]+J(0,1)*tk[k][1]+J(0,2)*tk[k][2] ) +
+         vk[1] * ( J(1,0)*tk[k][0]+J(1,1)*tk[k][1]+J(1,2)*tk[k][2] ) +
+         vk[2] * ( J(2,0)*tk[k][0]+J(2,1)*tk[k][1]+J(2,2)*tk[k][2] );
+   }
+}
+
+void Nedelec1PyrFiniteElement::ProjectGrad(const FiniteElement &fe,
+                                           ElementTransformation &Trans,
+                                           DenseMatrix &grad) const
+{
+   DenseMatrix dshape(fe.GetDof(), 3);
+   Vector grad_k(fe.GetDof());
+
+   grad.SetSize(dof, fe.GetDof());
+   for (int k = 0; k < dof; k++)
+   {
+      fe.CalcDShape(Nodes.IntPoint(k), dshape);
+      dshape.Mult(tk[k], grad_k);
+      for (int j = 0; j < grad_k.Size(); j++)
+      {
+         grad(k,j) = (fabs(grad_k(j)) < 1e-12) ? 0.0 : grad_k(j);
+      }
+   }
+}
+
+
+Nedelec2PyrFiniteElement::Nedelec2PyrFiniteElement()
+   : VectorFiniteElement(3, Geometry::PYRAMID, 28, 2, H_CURL)
+{
+   const real_t *eop = poly1d.OpenPoints(2 - 1);
+   const real_t  fop = 1. / 3.;
+
+   // not real nodes ...
+   Nodes.IntPoint(0).Set3(eop[0], 0., 0.);
+   Nodes.IntPoint(1).Set3(eop[1], 0., 0.);
+
+   Nodes.IntPoint(2).Set3(1.0, eop[0], 0.);
+   Nodes.IntPoint(3).Set3(1.0, eop[1], 0.);
+
+   Nodes.IntPoint(4).Set3(eop[0], 1.0, 0.);
+   Nodes.IntPoint(5).Set3(eop[1], 1.0, 0.);
+
+   Nodes.IntPoint(6).Set3(0., eop[0], 0.);
+   Nodes.IntPoint(7).Set3(0., eop[1], 0.);
+
+   Nodes.IntPoint(8).Set3(0., 0., eop[0]);
+   Nodes.IntPoint(9).Set3(0., 0., eop[1]);
+
+   Nodes.IntPoint(10).Set3(eop[1], 0., eop[0]);
+   Nodes.IntPoint(11).Set3(eop[0], 0., eop[1]);
+
+   Nodes.IntPoint(12).Set3(eop[1], eop[1], eop[0]);
+   Nodes.IntPoint(13).Set3(eop[0], eop[0], eop[1]);
+
+   Nodes.IntPoint(14).Set3(0., eop[1], eop[0]);
+   Nodes.IntPoint(15).Set3(0., eop[0], eop[1]);
+
+   Nodes.IntPoint(16).Set3(eop[0], 0.5, 0.);
+   Nodes.IntPoint(17).Set3(eop[1], 0.5, 0.);
+
+   Nodes.IntPoint(18).Set3(0.5, eop[0], 0.);
+   Nodes.IntPoint(19).Set3(0.5, eop[1], 0.);
+
+   Nodes.IntPoint(20).Set3(fop, 0., fop);
+   Nodes.IntPoint(21).Set3(fop, 0., fop);
+
+   Nodes.IntPoint(22).Set3(2.*fop, fop, fop);
+   Nodes.IntPoint(23).Set3(2.*fop, fop, fop);
+
+   Nodes.IntPoint(24).Set3(fop, 2.*fop, fop);
+   Nodes.IntPoint(25).Set3(fop, 2.*fop, fop);
+
+   Nodes.IntPoint(26).Set3(0., fop, fop);
+   Nodes.IntPoint(27).Set3(0., fop, fop);
+
+   {
+      int n = 28;
+      DenseMatrix I(n,n);
+      DenseMatrix vecs(n,3);
+      I = 0.0;
+
+      for (int i=0; i<n; i++)
+      {
+         CalcVShape(Nodes.IntPoint(i), vecs);
+         for (int j=0; j<n; j++)
+         {
+            I(j,i) = vecs(j,0)*tk[i][0]+vecs(j,1)*tk[i][1]+vecs(j,2)*tk[i][2];
+         }
+      }
+   }
+}
+
+void Nedelec2PyrFiniteElement::CalcVShape(const IntegrationPoint &ip,
+                                          DenseMatrix &shape) const
+{
+   shape = 0.0;
+
+   const real_t one = 1.0;
+   const real_t x = ip.x, y = ip.y, z = ip.z;
+   const real_t ox = one - x - z, oy = one - y - z, oz = one - z;
+   const real_t sq3 = sqrt(3.0);
+   const real_t tol = 1e-6;
+
+   if (oz <= tol)
+   {
+      // We must return the limit of the basis functions as z->1.  In order to
+      // remain inside the pyramid in this limit the x and y coordinates must
+      // be approaching 0. The resulting limiting basis function values are:
+      shape(0,0) =   0.;
+      shape(0,1) =   0.;
+      shape(0,2) =   0.;
+
+      shape(1,0) =   0.;
+      shape(1,1) =   0.;
+      shape(1,2) =   0.;
+
+      shape(2,0) =   0.;
+      shape(2,1) =   0.;
+      shape(2,2) =   0.;
+
+      shape(3,0) =   0.;
+      shape(3,1) =   0.;
+      shape(3,2) =   0.;
+
+      shape(4,0) =   0.;
+      shape(4,1) =   0.;
+      shape(4,2) =   0.;
+
+      shape(5,0) =   0.;
+      shape(5,1) =   0.;
+      shape(5,2) =   0.;
+
+      shape(6,0) =   0.;
+      shape(6,1) =   0.;
+      shape(6,2) =   0.;
+
+      shape(7,0) =   0.;
+      shape(7,1) =   0.;
+      shape(7,2) =   0.;
+
+      return;
+   }
+
+   const real_t ozi = one / oz;
+
+   const real_t me0120[3] = {oy, 0., x * oy * ozi};
+   const real_t me1120[3] = {(x - ox) * oy, 0., (x - ox) * x * oy * ozi};
+
+   const real_t me0121[3] = {y, 0., x * y * ozi};
+   const real_t me1121[3] = {(x - ox) * y, 0., (x - ox) * x * y * ozi};
+
+   const real_t me0210[3] = {0., ox, ox * y * ozi};
+   const real_t me1210[3] = {0., ox * (y - oy), ox * y * (y - oy) * ozi};
+
+   const real_t me0211[3] = {0., x, x * y * ozi};
+   const real_t me1211[3] = {0., x * (y - oy), x * y * (y - oy) * ozi};
+
+   const real_t te01[3] = {oy * z * ozi, ox * z * ozi,
+                           (ox * oy + (x * oy + ox * y) * z) * ozi * ozi
+                          };
+   const real_t te11[3] = {oy * z * (z * oz - ox * oy) * ozi * ozi,
+                           ox * z * (z * oz - ox * oy) * ozi * ozi,
+                           (ox * oy + z * (x * oy + ox * y)) *
+                           (z * oz - ox * oy) * ozi * ozi * ozi
+                          };
+
+   const real_t te02[3] = {-oy * z * ozi, x * z * ozi,
+                           x * (y * z + oy * oz) * ozi * ozi
+                          };
+   const real_t te12[3] = {oy * z * (x * oy - z * oz) * ozi * ozi,
+                           -x * z * (x * oy - z * oz) * ozi * ozi,
+                           -x * (y * z + oy * oz) * (x * oy - z * oz)
+                           * ozi * ozi * ozi
+                          };
+
+   const real_t te03[3] = {-y * z * ozi, -x * z * ozi,
+                           x * y * (one - 2. * z) * ozi * ozi
+                          };
+   const real_t te13[3] = {y * z * (x * y - z * oz) * ozi * ozi,
+                           x * z * (x * y - z * oz) * ozi * ozi,
+                           -x * y * (one - 2. * z) * (x * y - z * oz)
+                           * ozi * ozi * ozi
+                          };
+
+   const real_t te04[3] = {y * z * ozi, -ox * z * ozi,
+                           y * (x * z + ox * oz) * ozi * ozi
+                          };
+   const real_t te14[3] = {-y * z * (ox * y - z * oz) * ozi * ozi,
+                           ox * z * (ox * y - z * oz) * ozi * ozi,
+                           -y * (x * z + ox * oz) * (ox * y - z * oz)
+                           * ozi * ozi * ozi
+                          };
+
+   const real_t qI02[3] = {-y * oy * ozi, 0., -x * y * oy * ozi * ozi};
+   const real_t qI12[3] = {-(x - ox) * y * oy * ozi * ozi, 0.,
+                           -(x - ox) * x * y * oy * ozi * ozi * ozi
+                          };
+
+   const real_t qII02[3] = {0., -x * ox * ozi, -x * y * ox * ozi * ozi};
+   const real_t qII12[3] = {0., -x * ox * (y - oy) * ozi * ozi,
+                            -x * ox * y * (y - oy) * ozi * ozi * ozi
+                           };
+
+   const real_t tI120[3] = {oy * z, 0., x * oy * z * ozi};
+   const real_t tI121[3] = {y * z, 0., x * y * z * ozi};
+   const real_t tI210[3] = {0., ox * z, ox * y * z * ozi};
+   const real_t tI211[3] = {0., x * z, x * y * z * ozi};
+
+   const real_t tII120[3] = {-ox * oy * z * ozi, 0., x * ox * oy * ozi};
+   const real_t tII121[3] = {-ox * y * z * ozi, 0., x * ox * y * ozi};
+   const real_t tII210[3] = {0., -ox * oy * z * ozi, ox * y * oy * ozi};
+   const real_t tII211[3] = {0., -x * oy * z * ozi, x * y * oy * ozi};
+
+   // Edge 0,1
+   for (int d=0; d<3; d++)
+   {
+      shape(0,d) = 0.5 * me0120[d] + qI02[d]
+                   - sq3 * (0.5 * me1120[d] + qI12[d]) - 1.5 * tI120[d];
+   }
+   for (int d=0; d<3; d++)
+   {
+      shape(1,d) = 0.5 * me0120[d] + qI02[d]
+                   + sq3 * (0.5 * me1120[d] + qI12[d]) - 1.5 * tI120[d];
+   }
+
+   // Edge 1,2
+   for (int d=0; d<3; d++)
+   {
+      shape(2,d) = 0.5 * me0211[d] + qII02[d]
+                   - sq3 * (0.5 * me1211[d] + qII12[d]) - 1.5 * tI211[d];
+   }
+   for (int d=0; d<3; d++)
+   {
+      shape(3,d) = 0.5 * me0211[d] + qII02[d]
+                   + sq3 * (0.5 * me1211[d] + qII12[d]) - 1.5 * tI211[d];
+   }
+
+   // Edge 3,2
+   for (int d=0; d<3; d++)
+   {
+      shape(4,d) = 0.5 * me0121[d] + qI02[d]
+                   - sq3 * (0.5 * me1121[d] + qI12[d]) - 1.5 * tI121[d];
+   }
+   for (int d=0; d<3; d++)
+   {
+      shape(5,d) = 0.5 * me0121[d] + qI02[d]
+                   + sq3 * (0.5 * me1121[d] + qI12[d]) - 1.5 * tI121[d];
+   }
+
+   // Edge 0,3
+   for (int d=0; d<3; d++)
+   {
+      shape(6,d) = 0.5 * me0210[d] + qII02[d]
+                   - sq3 * (0.5 * me1210[d] + qII12[d]) - 1.5 * tI210[d];
+   }
+   for (int d=0; d<3; d++)
+   {
+      shape(7,d) = 0.5 * me0210[d] + qII02[d]
+                   + sq3 * (0.5 * me1210[d] + qII12[d]) - 1.5 * tI210[d];
+   }
+
+   // Edge 0,4
+   for (int d=0; d<3; d++)
+   {
+      shape(8,d) = 0.5 * te01[d] - sq3 * 0.5 * te11[d]
+                   - 1.5 * (tI120[d] + tII120[d] + tI210[d] + tII210[d]);
+   }
+   for (int d=0; d<3; d++)
+   {
+      shape(9,d) = 0.5 * te01[d] + sq3 * 0.5 * te11[d]
+                   - 1.5 * (tI120[d] + tII120[d] + tI210[d] + tII210[d]);
+   }
+
+   // Edge 1,4
+   for (int d=0; d<3; d++)
+   {
+      shape(10,d) = 0.5 * te02[d] - sq3 * 0.5 * te12[d]
+                    - 1.5 * (tII120[d] + tI211[d] + tII211[d]);
+   }
+   for (int d=0; d<3; d++)
+   {
+      shape(11,d) = 0.5 * te02[d] + sq3 * 0.5 * te12[d]
+                    - 1.5 * (tII120[d] + tI211[d] + tII211[d]);
+   }
+
+   // Edge 2,4
+   for (int d=0; d<3; d++)
+   {
+      shape(12,d) = 0.5 * te03[d] - sq3 * 0.5 * te13[d]
+                    - 1.5 * (tII211[d] + tII121[d]);
+   }
+   for (int d=0; d<3; d++)
+   {
+      shape(13,d) = 0.5 * te03[d] + sq3 * 0.5 * te13[d]
+                    - 1.5 * (tII211[d] + tII121[d]);
+   }
+
+   // Edge 3,4
+   for (int d=0; d<3; d++)
+   {
+      shape(14,d) = 0.5 * te04[d] - sq3 * 0.5 * te14[d]
+                    - 1.5 * (tI121[d] + tII121[d] + tII210[d]);
+   }
+   for (int d=0; d<3; d++)
+   {
+      shape(15,d) = 0.5 * te04[d] + sq3 * 0.5 * te14[d]
+                    - 1.5 * (tI121[d] + tII121[d] + tII210[d]);
+   }
+
+   // Quadrilateral face
+   for (int d=0; d<3; d++)
+   {
+      shape(16,d) = -2. * qI02[d] + 2. * sq3 * qI12[d];
+   }
+   for (int d=0; d<3; d++)
+   {
+      shape(17,d) = -2. * qI02[d] - 2. * sq3 * qI12[d];
+   }
+
+   for (int d=0; d<3; d++)
+   {
+      shape(18,d) = 2. * qII02[d] - 2. * sq3 * qII12[d];
+   }
+   for (int d=0; d<3; d++)
+   {
+      shape(19,d) = 2. * qII02[d] + 2. * sq3 * qII12[d];
+   }
+
+   // Triangular face 0,1,4
+   for (int d=0; d<3; d++)
+   {
+      shape(20,d) = 3. * tI120[d] - 3. * tII120[d];
+   }
+   for (int d=0; d<3; d++)
+   {
+      shape(21,d) = 3. * tI120[d] + 6. * tII120[d];
+   }
+
+   // Triangular face 1,2,4
+   for (int d=0; d<3; d++)
+   {
+      shape(22,d) = 3. * tI211[d] - 3. * tII211[d];
+   }
+   for (int d=0; d<3; d++)
+   {
+      shape(23,d) = 3. * tI211[d] + 6. * tII211[d];
+   }
+
+   // Triangular face 2,3,4
+   for (int d=0; d<3; d++)
+   {
+      shape(24,d) = -6. * tI121[d] - 3. * tII121[d];
+   }
+   for (int d=0; d<3; d++)
+   {
+      shape(25,d) = 3. * tI121[d] + 6. * tII121[d];
+   }
+
+   // Triangular face 3,0,4
+   for (int d=0; d<3; d++)
+   {
+      shape(26,d) = -6. * tI210[d] - 3. * tII210[d];
+   }
+   for (int d=0; d<3; d++)
+   {
+      shape(27,d) = 3. * tI210[d] + 6. * tII210[d];
+   }
+}
+
+void Nedelec2PyrFiniteElement::CalcCurlShape(const IntegrationPoint &ip,
+                                             DenseMatrix &curl_shape)
+const
+{
+   const real_t one = 1.0;
+   const real_t x = ip.x, y = ip.y, z = ip.z, z2 = 2. * z;
+   const real_t ox = one - x - z, oy = one - y - z, oz = one - z;
+
+   const real_t tol = 1e-6;
+
    if (oz <= tol)
    {
       // We must return the limit of the basis function derivatives as z->1.
@@ -4987,7 +5517,7 @@ const
       return;
    }
 
-   real_t ozi = 1. / oz;
+   real_t ozi = one / oz;
 
    curl_shape(0,0) = - x * ozi;
    curl_shape(0,1) = - 2. + y * ozi;
@@ -5022,10 +5552,18 @@ const
    curl_shape(7,2) =   0.;
 }
 
-const real_t Nedelec1PyrFiniteElement::tk[8][3] =
-{{1,0,0}, {0,1,0}, {1,0,0}, {0,1,0}, {0,0,1}, {-1,0,1}, {-1,-1,1}, {0,-1,1}};
+const real_t Nedelec2PyrFiniteElement::tk[28][3] =
+{
+   {1,0,0}, {1,0,0}, {0,1,0}, {0,1,0},
+   {1,0,0}, {1,0,0}, {0,1,0}, {0,1,0},
+   {0,0,1}, {0,0,1}, {-1,0,1}, {-1,0,1},
+   {-1,-1,1}, {-1,-1,1}, {0,-1,1}, {0,-1,1},
+   {1,0,0}, {1,0,0}, {0,-1,0}, {0,-1,0},
+   {1,0,0}, {0,0,1}, {0,1,0}, {-1,0,1},
+   {-1,0,0}, {-1,-1,1}, {0,-1,0}, {0,-1,1}
+};
 
-void Nedelec1PyrFiniteElement::GetLocalInterpolation (
+void Nedelec2PyrFiniteElement::GetLocalInterpolation (
    ElementTransformation &Trans, DenseMatrix &I) const
 {
    int k, j;
@@ -5078,7 +5616,7 @@ void Nedelec1PyrFiniteElement::GetLocalInterpolation (
    }
 }
 
-void Nedelec1PyrFiniteElement::Project (
+void Nedelec2PyrFiniteElement::Project (
    VectorCoefficient &vc, ElementTransformation &Trans,
    Vector &dofs) const
 {
@@ -5099,7 +5637,7 @@ void Nedelec1PyrFiniteElement::Project (
    }
 }
 
-void Nedelec1PyrFiniteElement::ProjectGrad(const FiniteElement &fe,
+void Nedelec2PyrFiniteElement::ProjectGrad(const FiniteElement &fe,
                                            ElementTransformation &Trans,
                                            DenseMatrix &grad) const
 {
@@ -6073,7 +6611,7 @@ void RT0PyrFiniteElement::CalcDivShape(const IntegrationPoint &ip,
 }
 
 const real_t RT0PyrFiniteElement::nk[5][3] =
-{{0.,0.,-1.}, {0,-.5,0}, {.5,0,.5}, {0,.5,.5}, {-.5,0,0}};
+{{0.,0.,-1}, {0,-1,0}, {1,0,1}, {0,1,1}, {-1,0,0}};
 
 void RT0PyrFiniteElement::GetLocalInterpolation (
    ElementTransformation &Trans, DenseMatrix &I) const
diff --git a/fem/fe/fe_fixed_order.hpp b/fem/fe/fe_fixed_order.hpp
index 6b9855338..7a47896ca 100644
--- a/fem/fe/fe_fixed_order.hpp
+++ b/fem/fe/fe_fixed_order.hpp
@@ -1018,6 +1018,34 @@ public:
 };
 
 
+/// A 3D 2nd order Nedelec element on a pyramid
+class Nedelec2PyrFiniteElement : public VectorFiniteElement
+{
+private:
+   static const real_t tk[28][3];
+
+public:
+   /// Construct the Nedelec2PyrFiniteElement
+   Nedelec2PyrFiniteElement();
+   virtual void CalcVShape(const IntegrationPoint &ip,
+                           DenseMatrix &shape) const;
+   virtual void CalcVShape(ElementTransformation &Trans,
+                           DenseMatrix &shape) const
+   { CalcVShape_ND(Trans, shape); }
+   virtual void CalcCurlShape(const IntegrationPoint &ip,
+                              DenseMatrix &curl_shape) const;
+   virtual void GetLocalInterpolation (ElementTransformation &Trans,
+                                       DenseMatrix &I) const;
+   using FiniteElement::Project;
+   virtual void Project (VectorCoefficient &vc,
+                         ElementTransformation &Trans, Vector &dofs) const;
+
+   virtual void ProjectGrad(const FiniteElement &fe,
+                            ElementTransformation &Trans,
+                            DenseMatrix &grad) const;
+};
+
+
 /// A 3D 0th order Raviert-Thomas element on a cube
 class RT0HexFiniteElement : public VectorFiniteElement
 {
diff --git a/fem/fe/fe_h1.cpp b/fem/fe/fe_h1.cpp
index c3957514d..93d45ad91 100644
--- a/fem/fe/fe_h1.cpp
+++ b/fem/fe/fe_h1.cpp
@@ -1040,4 +1040,824 @@ void H1_WedgeElement::CalcDShape(const IntegrationPoint &ip,
    }
 }
 
+H1_FuentesPyramidElement::H1_FuentesPyramidElement(const int p, const int btype)
+   : NodalFiniteElement(3, Geometry::PYRAMID,
+                        p * (p * p + 3) + 1, // Fuentes et al
+                        p, FunctionSpace::Uk)
+{
+   zmax = 0.0;
+
+   const real_t *cp = poly1d.ClosedPoints(p, VerifyNodal(VerifyClosed(btype)));
+
+#ifndef MFEM_THREAD_SAFE
+   tmp_i.SetSize(p + 1);
+   tmp1_ij.SetSize(p + 1, p + 1);
+   tmp2_ij.SetSize(p + 1, dim);
+   tmp_ijk.SetSize(p + 1, p + 1, dim);
+   tmp_u.SetSize(dof);
+   tmp_du.SetSize(dof, dim);
+#else
+   Vector tmp_i(p + 1);
+   DenseMatrix tmp1_ij(p + 1, p + 1);
+#endif
+
+   // vertices
+   Nodes.IntPoint(0).Set3(cp[0], cp[0], cp[0]);
+   Nodes.IntPoint(1).Set3(cp[p], cp[0], cp[0]);
+   Nodes.IntPoint(2).Set3(cp[p], cp[p], cp[0]);
+   Nodes.IntPoint(3).Set3(cp[0], cp[p], cp[0]);
+   Nodes.IntPoint(4).Set3(cp[0], cp[0], cp[p]);
+
+   // edges
+   int o = 5;
+   for (int i = 1; i < p; i++)  // (0,1)
+   {
+      Nodes.IntPoint(o++).Set3(cp[i], cp[0], cp[0]);
+   }
+   for (int i = 1; i < p; i++)  // (1,2)
+   {
+      Nodes.IntPoint(o++).Set3(cp[p], cp[i], cp[0]);
+   }
+   for (int i = 1; i < p; i++)  // (3,2)
+   {
+      Nodes.IntPoint(o++).Set3(cp[i], cp[p], cp[0]);
+   }
+   for (int i = 1; i < p; i++)  // (0,3)
+   {
+      Nodes.IntPoint(o++).Set3(cp[0], cp[i], cp[0]);
+   }
+   for (int i = 1; i < p; i++)  // (0,4)
+   {
+      Nodes.IntPoint(o++).Set3(cp[0], cp[0], cp[i]);
+   }
+   for (int i = 1; i < p; i++)  // (1,4)
+   {
+      Nodes.IntPoint(o++).Set3(cp[p-i], cp[0], cp[i]);
+   }
+   for (int i = 1; i < p; i++)  // (2,4)
+   {
+      Nodes.IntPoint(o++).Set3(cp[p-i], cp[p-i], cp[i]);
+   }
+   for (int i = 1; i < p; i++)  // (3,4)
+   {
+      Nodes.IntPoint(o++).Set3(cp[0], cp[p-i], cp[i]);
+   }
+
+   // quadrilateral face
+   for (int j = 1; j < p; j++)
+   {
+      for (int i = 1; i < p; i++)
+      {
+         Nodes.IntPoint(o++).Set3(cp[i], cp[p-j], cp[0]);
+      }
+   }
+
+   // triangular faces
+   for (int j = 1; j < p; j++)
+      for (int i = 1; i + j < p; i++)  // (0,1,4)
+      {
+         real_t w = cp[i] + cp[j] + cp[p-i-j];
+         Nodes.IntPoint(o++).Set3(cp[i]/w, cp[0], cp[j]/w);
+      }
+   for (int j = 1; j < p; j++)
+      for (int i = 1; i + j < p; i++)  // (1,2,4)
+      {
+         real_t w = cp[i] + cp[j] + cp[p-i-j];
+         Nodes.IntPoint(o++).Set3((cp[i] + cp[p-i-j])/w, cp[i]/w, cp[j]/w);
+      }
+   for (int j = 1; j < p; j++)
+      for (int i = 1; i + j < p; i++)  // (2,3,4)
+      {
+         real_t w = cp[i] + cp[j] + cp[p-i-j];
+         Nodes.IntPoint(o++).Set3(cp[p-i-j]/w, (cp[i] + cp[p-i-j])/w, cp[j]/w);
+      }
+   for (int j = 1; j < p; j++)
+      for (int i = 1; i + j < p; i++)  // (3,0,4)
+      {
+         real_t w = cp[i] + cp[j] + cp[p-i-j];
+         Nodes.IntPoint(o++).Set3(cp[0], cp[p-i-j]/w, cp[j]/w);
+      }
+
+   // Points based on Fuentes' interior bubbles
+   for (int k = 1; k < p; k++)
+   {
+      for (int j = 1; j < p; j++)
+      {
+         for (int i = 1; i < p; i++)
+         {
+            Nodes.IntPoint(o++).Set3(cp[i] * (1.0 - cp[k]),
+                                     cp[j] * (1.0 - cp[k]),
+                                     cp[k]);
+         }
+      }
+   }
+
+   MFEM_ASSERT(o == dof,
+               "Number of nodes does not match the "
+               "number of degrees of freedom");
+   DenseMatrix T(dof);
+
+   for (int m = 0; m < dof; m++)
+   {
+      const IntegrationPoint &ip = Nodes.IntPoint(m);
+      Vector col(T.GetColumn(m), dof);
+      calcBasis(order, ip, tmp_i, tmp1_ij, col);
+   }
+
+   Ti.Factor(T);
+}
+
+void H1_FuentesPyramidElement::CalcShape(const IntegrationPoint &ip,
+                                         Vector &shape) const
+{
+   const int p = order;
+
+#ifdef MFEM_THREAD_SAFE
+   Vector tmp_i(p + 1);
+   Vector tmp_u(dof);
+   DenseMatrix tmp1_ij(p + 1, p + 1);
+#endif
+
+   calcBasis(p, ip, tmp_i, tmp1_ij, tmp_u);
+
+   Ti.Mult(tmp_u, shape);
+}
+
+void H1_FuentesPyramidElement::CalcDShape(const IntegrationPoint &ip,
+                                          DenseMatrix &dshape) const
+{
+   const int p = order;
+
+#ifdef MFEM_THREAD_SAFE
+   Vector tmp_i(p + 1);
+   DenseMatrix tmp1_ij(p + 1, p + 1);
+   DenseMatrix tmp2_ij(p + 1, dim);
+   DenseTensor tmp_ijk(p + 1, p + 1, dim);
+   DenseMatrix tmp_du(dof, dim);
+#endif
+
+   calcGradBasis(p, ip, tmp_i, tmp2_ij, tmp1_ij, tmp_ijk, tmp_du);
+   Ti.Mult(tmp_du, dshape);
+}
+
+void H1_FuentesPyramidElement::CalcRawShape(const IntegrationPoint &ip,
+                                            Vector &shape) const
+{
+   const int p = order;
+
+#ifdef MFEM_THREAD_SAFE
+   Vector tmp_i(p + 1);
+   DenseMatrix tmp1_ij(p + 1, p + 1);
+#endif
+
+   calcBasis(p, ip, tmp_i, tmp1_ij, shape);
+}
+
+void H1_FuentesPyramidElement::CalcRawDShape(const IntegrationPoint &ip,
+                                             DenseMatrix &dshape) const
+{
+   const int p = order;
+
+#ifdef MFEM_THREAD_SAFE
+   Vector tmp_i(p + 1);
+   DenseMatrix tmp1_ij(p + 1, p + 1);
+   DenseMatrix tmp2_ij(p + 1, dim);
+   DenseTensor tmp_ijk(p + 1, p + 1, dim);
+#endif
+
+   calcGradBasis(p, ip, tmp_i, tmp2_ij, tmp1_ij, tmp_ijk, dshape);
+}
+
+void H1_FuentesPyramidElement::calcBasis(const int p,
+                                         const IntegrationPoint &ip,
+                                         Vector &phi_i, DenseMatrix &phi_ij,
+                                         Vector &u) const
+{
+   real_t x = ip.x;
+   real_t y = ip.y;
+   real_t z = ip.z;
+   Vector xy({x,y});
+
+   zmax = std::max(z, zmax);
+
+   real_t mu;
+
+   int o = 0;
+
+   // Vertices
+   u[0] = lam1(x, y, z);
+   u[1] = lam2(x, y, z);
+   u[2] = lam3(x, y, z);
+   u[3] = lam4(x, y, z);
+   u[4] = lam5(x, y, z);
+
+   o += 5;
+
+   // Mixed edges (base edges)
+   if (CheckZ(z) && p >= 2)
+   {
+      // (a,b) = (1,2), c = 0
+      phi_E(p, nu01(z, xy, 1), phi_i);
+      mu = mu0(z, xy, 2);
+      for (int i = 2; i <= p; i++, o++)
+      {
+         u[o] = mu * phi_i[i];
+      }
+      // (a,b) = (1,2), c = 1
+      mu = mu1(z, xy, 2);
+      for (int i = 2; i <= p; i++, o++)
+      {
+         u[o] = mu * phi_i[i];
+      }
+      // (a,b) = (2,1), c = 0
+      phi_E(p, nu01(z, xy, 2), phi_i);
+      mu = mu0(z, xy, 1);
+      for (int i = 2; i <= p; i++, o++)
+      {
+         u[o] = mu * phi_i[i];
+      }
+      // (a,b) = (2,1), c = 1
+      mu = mu1(z, xy, 1);
+      for (int i = 2; i <= p; i++, o++)
+      {
+         u[o] = mu * phi_i[i];
+      }
+   }
+   else
+   {
+      for (int i = 0; i < 4 * (p - 1); i++, o++)
+      {
+         u[o] = 0.0;
+      }
+   }
+
+   // Triangle edges (upright edges)
+   if (p >= 2)
+   {
+      phi_E(p, lam15(x, y, z), phi_i);
+      for (int i = 2; i<= p; i++, o++)
+      {
+         u[o] = phi_i[i];
+      }
+      phi_E(p, lam25(x, y, z), phi_i);
+      for (int i = 2; i<= p; i++, o++)
+      {
+         u[o] = phi_i[i];
+      }
+      phi_E(p, lam35(x, y, z), phi_i);
+      for (int i = 2; i<= p; i++, o++)
+      {
+         u[o] = phi_i[i];
+      }
+      phi_E(p, lam45(x, y, z), phi_i);
+      for (int i = 2; i<= p; i++, o++)
+      {
+         u[o] = phi_i[i];
+      }
+   }
+
+   // Quadrilateral face
+   if (CheckZ(z) && p >= 2)
+   {
+      phi_Q(p, mu01(z, xy, 1), mu01(z, xy, 2), phi_ij);
+      mu = mu0(z);
+      for (int j = 2; j <= p; j++)
+      {
+         for (int i = 2; i <= p; i++, o++)
+         {
+            u[o] = mu * phi_ij(i,j);
+         }
+      }
+   }
+   else
+   {
+      for (int j = 2; j <= p; j++)
+      {
+         for (int i = 2; i <= p; i++, o++)
+         {
+            u[o] = 0.0;
+         }
+      }
+   }
+
+   // Triangular faces
+   if (CheckZ(z) && p >= 3)
+   {
+      // (a,b) = (1,2), c = 0
+      phi_T(p, nu012(z, xy, 1), phi_ij);
+      mu = mu0(z, xy, 2);
+      for (int i = 2; i < p; i++)
+         for (int j = 1; i + j <= p; j++, o++)
+         {
+            u[o] = mu * phi_ij(i,j);
+         }
+      // (a,b) = (1,2), c = 1
+      mu = mu1(z, xy, 2);
+      for (int i = 2; i < p; i++)
+         for (int j = 1; i + j <= p; j++, o++)
+         {
+            u[o] = mu * phi_ij(i,j);
+         }
+      // (a,b) = (2,1), c = 0
+      phi_T(p, nu012(z, xy, 2), phi_ij);
+      mu = mu0(z, xy, 1);
+      for (int i = 2; i < p; i++)
+         for (int j = 1; i + j <= p; j++, o++)
+         {
+            u[o] = mu * phi_ij(i,j);
+         }
+      // (a,b) = (2,1), c = 1
+      mu = mu1(z, xy, 1);
+      for (int i = 2; i < p; i++)
+         for (int j = 1; i + j <= p; j++, o++)
+         {
+            u[o] = mu * phi_ij(i,j);
+         }
+   }
+   else
+   {
+      for (int i = 0; i < 2 * (p - 1) * (p - 2); i++, o++)
+      {
+         u[o] = 0.0;
+      }
+   }
+
+   // Interior
+   if (CheckZ(z) && p >= 2)
+   {
+      phi_Q(p, mu01(z, xy, 1), mu01(z, xy, 2), phi_ij);
+      phi_E(p, mu01(z), phi_i);
+      for (int k = 2; k <= p; k++)
+      {
+         for (int j = 2; j <= p; j++)
+         {
+            for (int i = 2; i <= p; i++, o++)
+            {
+               u[o] = phi_ij(i,j) * phi_i(k);
+            }
+         }
+      }
+   }
+   else
+   {
+      for (int i = 0; i < (p - 1) * (p - 1) * (p - 1); i++, o++)
+      {
+         u[o]= 0.0;
+      }
+   }
+}
+
+void H1_FuentesPyramidElement::calcGradBasis(const int p,
+                                             const IntegrationPoint &ip,
+                                             Vector &phi_i,
+                                             DenseMatrix &dphi_i,
+                                             DenseMatrix &phi_ij,
+                                             DenseTensor &dphi_ij,
+                                             DenseMatrix &du) const
+{
+   real_t x = ip.x;
+   real_t y = ip.y;
+   real_t z = ip.z;
+   Vector xy({x,y});
+
+   zmax = std::max(z, zmax);
+
+   real_t mu;
+   Vector dmu(3);
+   Vector dlam(3);
+
+   int o = 0;
+
+   // Vertices
+   dlam = grad_lam1(x, y, z);
+   for (int d=0; d<3; d++) { du(0, d) = dlam(d); }
+   dlam = grad_lam2(x, y, z);
+   for (int d=0; d<3; d++) { du(1, d) = dlam(d); }
+   dlam = grad_lam3(x, y, z);
+   for (int d=0; d<3; d++) { du(2, d) = dlam(d); }
+   dlam = grad_lam4(x, y, z);
+   for (int d=0; d<3; d++) { du(3, d) = dlam(d); }
+   dlam = grad_lam5(x, y, z);
+   for (int d=0; d<3; d++) { du(4, d) = dlam(d); }
+
+   o += 5;
+
+   // Mixed edges (base edges)
+   if (CheckZ(z) && p >= 2)
+   {
+      // (a,b) = (1,2), c = 0
+      phi_E(p, nu01(z, xy, 1), grad_nu01(z, xy, 1), phi_i, dphi_i);
+      mu = mu0(z, xy, 2);
+      dmu = grad_mu0(z, xy, 2);;
+      for (int i = 2; i <= p; i++, o++)
+         for (int d=0; d<3; d++)
+         {
+            du(o, d) = dmu(d) * phi_i[i] + mu * dphi_i(i, d);
+         }
+
+      // (a,b) = (1,2), c = 1
+      mu = mu1(z, xy, 2);
+      dmu = grad_mu1(z, xy, 2);;
+      for (int i = 2; i <= p; i++, o++)
+         for (int d=0; d<3; d++)
+         {
+            du(o, d) = dmu(d) * phi_i[i] + mu * dphi_i(i, d);
+         }
+
+      // (a,b) = (2,1), c = 0
+      phi_E(p, nu01(z, xy, 2), grad_nu01(z, xy, 2), phi_i, dphi_i);
+      mu = mu0(z, xy, 1);
+      dmu = grad_mu0(z, xy, 1);;
+      for (int i = 2; i <= p; i++, o++)
+         for (int d=0; d<3; d++)
+         {
+            du(o, d) = dmu(d) * phi_i[i] + mu * dphi_i(i, d);
+         }
+
+      // (a,b) = (2,1), c = 1
+      mu = mu1(z, xy, 1);
+      dmu = grad_mu1(z, xy, 1);;
+      for (int i = 2; i <= p; i++, o++)
+         for (int d=0; d<3; d++)
+         {
+            du(o, d) = dmu(d) * phi_i[i] + mu * dphi_i(i, d);
+         }
+   }
+   else
+   {
+      for (int i = 0; i < 4 * (p - 1); i++, o++)
+         for (int d=0; d<3; d++)
+         {
+            du(o, d) = 0.0;
+         }
+   }
+
+   // Triangle edges (upright edges)
+   if (p >= 2)
+   {
+      phi_E(p, lam15(x, y, z), grad_lam15(x,y,z), phi_i, dphi_i);
+      for (int i = 2; i<= p; i++, o++)
+         for (int d=0; d<3; d++)
+         {
+            du(o, d) = dphi_i(i, d);
+         }
+
+      phi_E(p, lam25(x, y, z), grad_lam25(x, y, z), phi_i, dphi_i);
+      for (int i = 2; i<= p; i++, o++)
+         for (int d=0; d<3; d++)
+         {
+            du(o, d) = dphi_i(i, d);
+         }
+
+      phi_E(p, lam35(x, y, z), grad_lam35(x, y, z), phi_i, dphi_i);
+      for (int i = 2; i<= p; i++, o++)
+         for (int d=0; d<3; d++)
+         {
+            du(o, d) = dphi_i(i, d);
+         }
+
+      phi_E(p, lam45(x, y, z), grad_lam45(x, y, z), phi_i, dphi_i);
+      for (int i = 2; i<= p; i++, o++)
+         for (int d=0; d<3; d++)
+         {
+            du(o, d) = dphi_i(i, d);
+         }
+   }
+
+   // Quadrilateral face
+   if (CheckZ(z) && p >= 2)
+   {
+      phi_Q(p, mu01(z, xy, 1), grad_mu01(z, xy, 1),
+            mu01(z, xy, 2), grad_mu01(z, xy, 2), phi_ij, dphi_ij);
+      mu = mu0(z);
+      dmu = grad_mu0(z);
+      for (int j = 2; j <= p; j++)
+         for (int i = 2; i <= p; i++, o++)
+            for (int d=0; d<3; d++)
+            {
+               du(o, d) = dmu(d) * phi_ij(i, j) + mu * dphi_ij(i, j, d);
+            }
+   }
+   else
+   {
+      for (int j = 2; j <= p; j++)
+         for (int i = 2; i <= p; i++, o++)
+            for (int d=0; d<3; d++)
+            {
+               du(o, d) = 0.0;
+            }
+   }
+
+   // Triangular faces
+   if (CheckZ(z) && p >= 3)
+   {
+      // (a,b) = (1,2), c = 0
+      phi_T(p, nu012(z, xy, 1), grad_nu012(z, xy, 1), phi_ij, dphi_ij);
+      mu = mu0(z, xy, 2);
+      dmu = grad_mu0(z, xy, 2);
+      for (int i = 2; i < p; i++)
+         for (int j = 1; i + j <= p; j++, o++)
+            for (int d=0; d<3; d++)
+            {
+               du(o, d) = dmu(d) * phi_ij(i, j) + mu * dphi_ij(i, j, d);
+            }
+
+      // (a,b) = (1,2), c = 1
+      mu = mu1(z, xy, 2);
+      dmu = grad_mu1(z, xy, 2);
+      for (int i = 2; i < p; i++)
+         for (int j = 1; i + j <= p; j++, o++)
+            for (int d=0; d<3; d++)
+            {
+               du(o, d) = dmu(d) * phi_ij(i, j) + mu * dphi_ij(i, j, d);
+            }
+
+      // (a,b) = (2,1), c = 0
+      phi_T(p, nu012(z, xy, 2), grad_nu012(z, xy, 2), phi_ij, dphi_ij);
+      mu = mu0(z, xy, 1);
+      dmu = grad_mu0(z, xy, 1);
+      for (int i = 2; i < p; i++)
+         for (int j = 1; i + j <= p; j++, o++)
+            for (int d=0; d<3; d++)
+            {
+               du(o, d) = dmu(d) * phi_ij(i, j) + mu * dphi_ij(i, j, d);
+            }
+
+      // (a,b) = (2,1), c = 1
+      mu = mu1(z, xy, 1);
+      dmu = grad_mu1(z, xy, 1);
+      for (int i = 2; i < p; i++)
+         for (int j = 1; i + j <= p; j++, o++)
+            for (int d=0; d<3; d++)
+            {
+               du(o, d) = dmu(d) * phi_ij(i, j) + mu * dphi_ij(i, j, d);
+            }
+   }
+   else
+   {
+      for (int i = 0; i < 2 * (p - 1) * (p - 2); i++, o++)
+         for (int d=0; d<3; d++)
+         {
+            du(o, d) = 0.0;
+         }
+   }
+
+   // Interior
+   if (CheckZ(z) && p >= 2)
+   {
+      phi_Q(p, mu01(z, xy, 1), grad_mu01(z, xy, 1),
+            mu01(z, xy, 2), grad_mu01(z, xy, 2), phi_ij, dphi_ij);
+      phi_E(p, mu01(z), grad_mu01(z), phi_i, dphi_i);
+      for (int k = 2; k <= p; k++)
+         for (int j = 2; j <= p; j++)
+            for (int i = 2; i <= p; i++, o++)
+               for (int d=0; d<3; d++)
+                  du(o, d) = dphi_ij(i, j, d) * phi_i(k) +
+                             phi_ij(i, j) * dphi_i(k, d);
+   }
+   else
+   {
+      for (int i = 0; i < (p - 1) * (p - 1) * (p - 1); i++, o++)
+         for (int d=0; d<3; d++)
+         {
+            du(o, d) = 0.0;
+         }
+   }
+}
+
+H1_BergotPyramidElement::H1_BergotPyramidElement(const int p, const int btype)
+   : NodalFiniteElement(3, Geometry::PYRAMID,
+                        (p + 1) * (p + 2) * (2 * p + 3) / 6, // Bergot (JSC)
+                        p, FunctionSpace::Uk)
+{
+   const real_t *cp = poly1d.ClosedPoints(p, VerifyNodal(VerifyClosed(btype)));
+
+#ifndef MFEM_THREAD_SAFE
+   shape_x.SetSize(p + 1);
+   shape_y.SetSize(p + 1);
+   shape_z.SetSize(p + 1);
+   dshape_x.SetSize(p + 1);
+   dshape_y.SetSize(p + 1);
+   dshape_z.SetSize(p + 1);
+   dshape_z_dt.SetSize(p + 1);
+   ddshape_x.SetSize(p + 1);
+   ddshape_y.SetSize(p + 1);
+   ddshape_z.SetSize(p + 1);
+   u.SetSize(dof);
+   du.SetSize(dof, dim);
+   ddu.SetSize(dof, (dim * (dim + 1)) / 2);
+#else
+   Vector shape_x(p + 1), shape_y(p + 1), shape_z(p + 1);
+#endif
+
+   // vertices
+   Nodes.IntPoint(0).Set3(cp[0], cp[0], cp[0]);
+   Nodes.IntPoint(1).Set3(cp[p], cp[0], cp[0]);
+   Nodes.IntPoint(2).Set3(cp[p], cp[p], cp[0]);
+   Nodes.IntPoint(3).Set3(cp[0], cp[p], cp[0]);
+   Nodes.IntPoint(4).Set3(cp[0], cp[0], cp[p]);
+
+   // edges
+   int o = 5;
+   for (int i = 1; i < p; i++)  // (0,1)
+   {
+      Nodes.IntPoint(o++).Set3(cp[i], cp[0], cp[0]);
+   }
+   for (int i = 1; i < p; i++)  // (1,2)
+   {
+      Nodes.IntPoint(o++).Set3(cp[p], cp[i], cp[0]);
+   }
+   for (int i = 1; i < p; i++)  // (3,2)
+   {
+      Nodes.IntPoint(o++).Set3(cp[i], cp[p], cp[0]);
+   }
+   for (int i = 1; i < p; i++)  // (0,3)
+   {
+      Nodes.IntPoint(o++).Set3(cp[0], cp[i], cp[0]);
+   }
+   for (int i = 1; i < p; i++)  // (0,4)
+   {
+      Nodes.IntPoint(o++).Set3(cp[0], cp[0], cp[i]);
+   }
+   for (int i = 1; i < p; i++)  // (1,4)
+   {
+      Nodes.IntPoint(o++).Set3(cp[p-i], cp[0], cp[i]);
+   }
+   for (int i = 1; i < p; i++)  // (2,4)
+   {
+      Nodes.IntPoint(o++).Set3(cp[p-i], cp[p-i], cp[i]);
+   }
+   for (int i = 1; i < p; i++)  // (3,4)
+   {
+      Nodes.IntPoint(o++).Set3(cp[0], cp[p-i], cp[i]);
+   }
+
+   // quadrilateral face
+   for (int j = 1; j < p; j++)
+   {
+      for (int i = 1; i < p; i++)
+      {
+         Nodes.IntPoint(o++).Set3(cp[i], cp[j], cp[0]);
+      }
+   }
+
+   // triangular faces
+   for (int j = 1; j < p; j++)
+      for (int i = 1; i + j < p; i++)  // (0,1,4)
+      {
+         real_t w = cp[i] + cp[j] + cp[p-i-j];
+         Nodes.IntPoint(o++).Set3(cp[i]/w, cp[0], cp[j]/w);
+      }
+   for (int j = 1; j < p; j++)
+      for (int i = 1; i + j < p; i++)  // (1,2,4)
+      {
+         real_t w = cp[i] + cp[j] + cp[p-i-j];
+         Nodes.IntPoint(o++).Set3(1.0 - cp[j]/w, cp[i]/w, cp[j]/w);
+      }
+   for (int j = 1; j < p; j++)
+      for (int i = 1; i + j < p; i++)  // (3,4,2)
+      {
+         real_t w = cp[i] + cp[j] + cp[p-i-j];
+         Nodes.IntPoint(o++).Set3(cp[j]/w, 1.0 - cp[i]/w, cp[i]/w);
+      }
+   for (int j = 1; j < p; j++)
+      for (int i = 1; i + j < p; i++)  // (0,4,3)
+      {
+         real_t w = cp[i] + cp[j] + cp[p-i-j];
+         Nodes.IntPoint(o++).Set3(cp[0], cp[j]/w, cp[i]/w);
+      }
+
+   // interior
+   for (int k = 1; k < p - 1; k++)
+   {
+      for (int j = 1; j < p - k; j++)
+      {
+         real_t wjk = cp[j] + cp[k] + cp[p-j-k];
+         for (int i = 1; i < p - k; i++)
+         {
+            real_t wik = cp[i] + cp[k] + cp[p-i-k];
+            real_t w = wik * wjk * cp[p-k];
+            Nodes.IntPoint(o++).Set3(cp[i] * (cp[j] + cp[p-j-k]) / w,
+                                     cp[j] * (cp[i] + cp[p-i-k]) / w,
+                                     cp[k] * cp[p-k] / w);
+         }
+      }
+   }
+
+   MFEM_ASSERT(o == dof,
+               "Number of nodes does not match the "
+               "number of degrees of freedom");
+   DenseMatrix T(dof);
+
+   for (int m = 0; m < dof; m++)
+   {
+      const IntegrationPoint &ip = Nodes.IntPoint(m);
+
+      real_t x = (ip.z < 1.0) ? (ip.x / (1.0 - ip.z)) : 0.0;
+      real_t y = (ip.z < 1.0) ? (ip.y / (1.0 - ip.z)) : 0.0;
+      real_t z = ip.z;
+
+      poly1d.CalcLegendre(p, x, shape_x.GetData());
+      poly1d.CalcLegendre(p, y, shape_y.GetData());
+
+      o = 0;
+      for (int i = 0; i <= p; i++)
+      {
+         for (int j = 0; j <= p; j++)
+         {
+            int maxij = std::max(i, j);
+            FuentesPyramid::CalcScaledJacobi(p-maxij, 2.0 * (maxij + 1.0),
+                                             z, 1.0, shape_z);
+
+            for (int k = 0; k <= p - maxij; k++)
+            {
+               T(o++, m) = shape_x(i) * shape_y(j) * shape_z(k) *
+                           pow(1.0 - ip.z, maxij);
+            }
+         }
+      }
+   }
+
+   Ti.Factor(T);
+}
+
+void H1_BergotPyramidElement::CalcShape(const IntegrationPoint &ip,
+                                        Vector &shape) const
+{
+   const int p = order;
+
+#ifdef MFEM_THREAD_SAFE
+   Vector shape_x(order+1);
+   Vector shape_y(order+1);
+   Vector shape_z(order+1);
+   Vector u(dof);
+#endif
+
+   real_t x = (ip.z < 1.0) ? (ip.x / (1.0 - ip.z)) : 0.0;
+   real_t y = (ip.z < 1.0) ? (ip.y / (1.0 - ip.z)) : 0.0;
+   real_t z = ip.z;
+
+   poly1d.CalcLegendre(p, x, shape_x.GetData());
+   poly1d.CalcLegendre(p, y, shape_y.GetData());
+
+   int o = 0;
+   for (int i = 0; i <= p; i++)
+      for (int j = 0; j <= p; j++)
+      {
+         int maxij = std::max(i, j);
+         FuentesPyramid::CalcScaledJacobi(p-maxij, 2.0 * (maxij + 1.0), z, 1.0,
+                                          shape_z);
+         for (int k = 0; k <= p - maxij; k++)
+            u[o++] = shape_x(i) * shape_y(j) * shape_z(k) *
+                     pow(1.0 - ip.z, maxij);
+      }
+
+   Ti.Mult(u, shape);
+}
+
+void H1_BergotPyramidElement::CalcDShape(const IntegrationPoint &ip,
+                                         DenseMatrix &dshape) const
+{
+   const int p = order;
+
+#ifdef MFEM_THREAD_SAFE
+   Vector shape_x(p + 1), shape_y(p + 1), shape_z(p + 1);
+   Vector dshape_x(p + 1), dshape_y(p + 1), dshape_z(p + 1), dshape_z_dt(p + 1), u(p + 1);
+   DenseMatrix du(dof, dim);
+#endif
+   real_t x = (ip.z < 1.0) ? (ip.x / (1.0 - ip.z)) : 0.0;
+   real_t y = (ip.z < 1.0) ? (ip.y / (1.0 - ip.z)) : 0.0;
+   real_t z = ip.z;
+
+   poly1d.CalcLegendre(p, x, shape_x.GetData(), dshape_x.GetData());
+   poly1d.CalcLegendre(p, y, shape_y.GetData(), dshape_y.GetData());
+
+   int o = 0;
+   for (int i = 0; i <= p; i++)
+      for (int j = 0; j <= p; j++)
+      {
+         int maxij = std::max(i, j);
+         FuentesPyramid::CalcScaledJacobi(p-maxij, 2.0 * (maxij + 1.0), z, 1.0,
+                                          shape_z, dshape_z, dshape_z_dt);
+
+         for (int k = 0; k <= p - maxij; k++, o++)
+         {
+            du(o,0) = dshape_x(i) * shape_y(j) * shape_z(k) *
+                      pow(1.0 - ip.z, maxij - 1);
+            du(o,1) = shape_x(i) * dshape_y(j) * shape_z(k) *
+                      pow(1.0 - ip.z, maxij - 1);
+            du(o,2) = shape_x(i) * shape_y(j) * dshape_z(k) *
+                      pow(1.0 - ip.z, maxij) +
+                      (ip.x * dshape_x(i) * shape_y(j) +
+                       ip.y * shape_x(i) * dshape_y(j)) *
+                      shape_z(k) * pow(1.0 - ip.z, maxij - 2) -
+                      maxij * shape_x(i) * shape_y(j) * shape_z(k) *
+                      pow(1.0 - ip.z, maxij - 1);
+         }
+      }
+
+   Ti.Mult(du, dshape);
+}
+
+
 }
diff --git a/fem/fe/fe_h1.hpp b/fem/fe/fe_h1.hpp
index 4eb61bd5b..ccc23dd1a 100644
--- a/fem/fe/fe_h1.hpp
+++ b/fem/fe/fe_h1.hpp
@@ -13,6 +13,7 @@
 #define MFEM_FE_H1
 
 #include "fe_base.hpp"
+#include "fe_pyramid.hpp"
 
 namespace mfem
 {
@@ -148,6 +149,70 @@ public:
                    DenseMatrix &dshape) const override;
 };
 
+class H1_FuentesPyramidElement
+   : public NodalFiniteElement, public FuentesPyramid
+{
+private:
+   mutable real_t zmax;
+
+#ifndef MFEM_THREAD_SAFE
+   mutable Vector tmp_i, tmp_u;
+   mutable DenseMatrix tmp1_ij, tmp2_ij, tmp_du;
+   mutable DenseTensor tmp_ijk;
+#endif
+   DenseMatrixInverse Ti;
+   /*
+    static void calcBasis(const int p, const IntegrationPoint &ip,
+                          Vector *tmp_x, double *tmp_y, double *tmp_z,
+                          double *u);
+   */
+   void calcBasis(const int p, const IntegrationPoint &ip,
+                  Vector &phi_i, DenseMatrix &phi_ij, Vector &u) const;
+   void calcGradBasis(const int p, const IntegrationPoint &ip,
+                      Vector &phi_i, DenseMatrix &dphi_i,
+                      DenseMatrix &phi_ij, DenseTensor &dphi_ij,
+                      DenseMatrix &du) const;
+   /*
+   {
+       calcBasis(p, ip, tmp_x, tmp_y.GetData(), tmp_z.GetData(),
+                 u.GetData());
+    }
+   */
+   // static void calcDBasis(const int p, const IntegrationPoint &ip,
+   //                      DenseMatrix &du);
+
+public:
+   H1_FuentesPyramidElement(const int p,
+                            const int btype = BasisType::GaussLobatto);
+   virtual void CalcShape(const IntegrationPoint &ip, Vector &shape) const;
+   virtual void CalcDShape(const IntegrationPoint &ip,
+                           DenseMatrix &dshape) const;
+   void CalcRawShape(const IntegrationPoint &ip, Vector &shape) const;
+   void CalcRawDShape(const IntegrationPoint &ip,
+                      DenseMatrix &dshape) const;
+
+   real_t GetZetaMax() const { return zmax; }
+};
+
+class H1_BergotPyramidElement : public NodalFiniteElement
+{
+private:
+#ifndef MFEM_THREAD_SAFE
+   mutable Vector shape_x, shape_y, shape_z;
+   mutable Vector dshape_x, dshape_y, dshape_z, dshape_z_dt, u;
+   mutable Vector ddshape_x, ddshape_y, ddshape_z;
+   mutable DenseMatrix du, ddu;
+#endif
+   DenseMatrixInverse Ti;
+
+public:
+   H1_BergotPyramidElement(const int p,
+                           const int btype = BasisType::GaussLobatto);
+   virtual void CalcShape(const IntegrationPoint &ip, Vector &shape) const;
+   virtual void CalcDShape(const IntegrationPoint &ip,
+                           DenseMatrix &dshape) const;
+};
+
 } // namespace mfem
 
 #endif
diff --git a/fem/fe/fe_l2.cpp b/fem/fe/fe_l2.cpp
index be27b7b02..8fe51340c 100644
--- a/fem/fe/fe_l2.cpp
+++ b/fem/fe/fe_l2.cpp
@@ -923,4 +923,320 @@ void L2_WedgeElement::CalcDShape(const IntegrationPoint &ip,
    }
 }
 
+L2_FuentesPyramidElement::L2_FuentesPyramidElement(const int p, const int btype)
+   : NodalFiniteElement(3, Geometry::PYRAMID, ((p + 1)*(p + 1)*(p + 1)),
+                        p, FunctionSpace::Uk)
+{
+   const real_t *op = poly1d.OpenPoints(p, VerifyOpen(btype));
+
+   // These basis functions are not independent on a closed set of
+   // interpolation points when p >= 1. For this reason we force the points
+   // to be open in the z direction whenever closed points are requested.
+   // This should be regarded as a limitation of this choice of basis function.
+   // If a truly closed set of points is needed consider using
+   // L2_BergotPyramidElement instead.
+   real_t a = 1.0;
+   if (IsClosedType(btype) && p > 0)
+   {
+      a = (poly1d.GetPoints(p, BasisType::GaussLegendre))[p];
+   }
+
+
+#ifndef MFEM_THREAD_SAFE
+   shape_x.SetSize(p + 1);
+   shape_y.SetSize(p + 1);
+   shape_z.SetSize(p + 1);
+   dshape_x.SetSize(p + 1);
+   dshape_y.SetSize(p + 1);
+   dshape_z.SetSize(p + 1);
+   u.SetSize(dof);
+   du.SetSize(dof, dim);
+#else
+   Vector shape_x(p + 1);
+   Vector shape_y(p + 1);
+   Vector shape_z(p + 1);
+#endif
+
+   int o = 0;
+   for (int k = 0; k <= p; k++)
+      for (int j = 0; j <= p; j++)
+         for (int i = 0; i <= p; i++)
+         {
+            Nodes.IntPoint(o++).Set3(op[i] * (1.0 - a * op[k]),
+                                     op[j] * (1.0 - a * op[k]),
+                                     a * op[k]);
+         }
+
+   MFEM_ASSERT(o == dof,
+               "Number of nodes does not match the "
+               "number of degrees of freedom");
+   DenseMatrix T(dof);
+
+   for (int m = 0; m < dof; m++)
+   {
+      const IntegrationPoint &ip = Nodes.IntPoint(m);
+      real_t x = ip.x;
+      real_t y = ip.y;
+      real_t z = ip.z;
+      Vector xy({x,y});
+      CalcHomogenizedScaLegendre(p, mu0(z, xy, 1), mu1(z, xy, 1), shape_x);
+      CalcHomogenizedScaLegendre(p, mu0(z, xy, 2), mu1(z, xy, 2), shape_y);
+      CalcHomogenizedScaLegendre(p, mu0(z), mu1(z), shape_z);
+
+      o = 0;
+      for (int k = 0; k <= p; k++)
+      {
+         for (int j = 0; j <= p; j++)
+         {
+            for (int i = 0; i <= p; i++, o++)
+            {
+               T(o, m) = shape_x[i] * shape_y[j] * shape_z[k];
+            }
+         }
+      }
+   }
+
+   Ti.Factor(T);
+}
+
+void L2_FuentesPyramidElement::CalcShape(const IntegrationPoint &ip,
+                                         Vector &shape) const
+{
+   const int p = order;
+
+#ifdef MFEM_THREAD_SAFE
+   Vector shape_x(p + 1);
+   Vector shape_y(p + 1);
+   Vector shape_z(p + 1);
+   Vector u(dof);
+#endif
+   real_t x = ip.x;
+   real_t y = ip.y;
+   real_t z = ip.z;
+   Vector xy({x,y});
+
+   if (z < 1.0)
+   {
+      CalcHomogenizedScaLegendre(p, mu0(z, xy, 1), mu1(z, xy, 1), shape_x);
+      CalcHomogenizedScaLegendre(p, mu0(z, xy, 2), mu1(z, xy, 2), shape_y);
+   }
+   else
+   {
+      shape_x = 0.0; shape_x(0) = 1.0;
+      shape_y = 0.0; shape_y(0) = 1.0;
+   }
+   CalcHomogenizedScaLegendre(p, mu0(z), mu1(z), shape_z);
+
+   int o = 0;
+   for (int k = 0; k <= p; k++)
+      for (int j = 0; j <= p; j++)
+         for (int i = 0; i <= p; i++, o++)
+         {
+            u[o] = shape_x[i] * shape_y[j] * shape_z[k];
+         }
+
+   Ti.Mult(u, shape);
+}
+
+void L2_FuentesPyramidElement::CalcDShape(const IntegrationPoint &ip,
+                                          DenseMatrix &dshape) const
+{
+   const int p = order;
+
+#ifdef MFEM_THREAD_SAFE
+   Vector shape_x(p + 1);
+   Vector shape_y(p + 1);
+   Vector shape_z(p + 1);
+   Vector dshape_x(p + 1);
+   Vector dshape_y(p + 1);
+   Vector dshape_z(p + 1);
+   DenseMatrix du(dof, dim);
+#endif
+
+   Poly_1D::CalcLegendre(p, ip.x / (1.0 - ip.z), shape_x.GetData(),
+                         dshape_x.GetData());
+   Poly_1D::CalcLegendre(p, ip.y / (1.0 - ip.z), shape_y.GetData(),
+                         dshape_y.GetData());
+   Poly_1D::CalcLegendre(p, ip.z, shape_z.GetData(), dshape_z.GetData());
+
+   int o = 0;
+   for (int k = 0; k <= p; k++)
+      for (int j = 0; j <= p; j++)
+         for (int i = 0; i <= p; i++, o++)
+         {
+            du(o, 0) = dshape_x[i] * shape_y[j] * shape_z[k] / (1.0 - ip.z);
+            du(o, 1) = shape_x[i] * dshape_y[j] * shape_z[k] / (1.0 - ip.z);
+            du(o, 2) = shape_x[i] * shape_y[j] * dshape_z[k] +
+                       (ip.x * dshape_x[i] * shape_y[j] +
+                        ip.y * shape_x[i] * dshape_y[j]) *
+                       shape_z[k] / pow(1.0 - ip.z, 2);
+         }
+   Ti.Mult(du, dshape);
+}
+
+L2_BergotPyramidElement::L2_BergotPyramidElement(const int p, const int btype)
+   : NodalFiniteElement(3, Geometry::PYRAMID, (p + 1)*(p + 2)*(2*p + 3)/6,
+                        p, FunctionSpace::Pk)
+{
+   const real_t *op = poly1d.OpenPoints(p, VerifyOpen(btype));
+
+#ifndef MFEM_THREAD_SAFE
+   shape_x.SetSize(p + 1);
+   shape_y.SetSize(p + 1);
+   shape_z.SetSize(p + 1);
+   dshape_x.SetSize(p + 1);
+   dshape_y.SetSize(p + 1);
+   dshape_z.SetSize(p + 1);
+   dshape_z_dt.SetSize(p + 1);
+   u.SetSize(dof);
+   du.SetSize(dof, dim);
+#else
+   Vector shape_x(p + 1);
+   Vector shape_y(p + 1);
+   Vector shape_z(p + 1);
+#endif
+
+   int o = 0;
+   for (int k = 0; k <= p; k++)
+      for (int j = 0; j <= p - k; j++)
+      {
+         const real_t wjk = op[j] + op[k] + op[p-j-k];
+         for (int i = 0; i <= p - k; i++)
+         {
+            const real_t wik = op[i] + op[k] + op[p-i-k];
+            const real_t w = wik * wjk * op[p-k];
+            Nodes.IntPoint(o++).Set3(op[i] * (op[j] + op[p-j-k]) / w,
+                                     op[j] * (op[j] + op[p-j-k]) / w,
+                                     op[k] * op[p-k] / w);
+         }
+      }
+
+   MFEM_ASSERT(o == dof,
+               "Number of nodes does not match the "
+               "number of degrees of freedom");
+   DenseMatrix T(dof);
+
+   for (int m = 0; m < dof; m++)
+   {
+      const IntegrationPoint &ip = Nodes.IntPoint(m);
+
+      const real_t x = (ip.z < 1.0) ? (ip.x / (1.0 - ip.z)) : 0.0;
+      const real_t y = (ip.z < 1.0) ? (ip.y / (1.0 - ip.z)) : 0.0;
+      const real_t z = ip.z;
+
+      poly1d.CalcLegendre(p, x, shape_x.GetData());
+      poly1d.CalcLegendre(p, y, shape_y.GetData());
+
+      o = 0;
+      for (int i = 0; i <= p; i++)
+      {
+         for (int j = 0; j <= p; j++)
+         {
+            int maxij = std::max(i, j);
+            FuentesPyramid::CalcScaledJacobi(p-maxij, 2.0 * (maxij + 1.0),
+                                             z, 1.0, shape_z);
+
+            for (int k = 0; k <= p - maxij; k++)
+            {
+               T(o++, m) = shape_x(i) * shape_y(j) * shape_z(k) *
+                           pow(1.0 - ip.z, maxij);
+            }
+         }
+      }
+   }
+
+   Ti.Factor(T);
+}
+
+void L2_BergotPyramidElement::CalcShape(const IntegrationPoint &ip,
+                                        Vector &shape) const
+{
+   const int p = order;
+
+#ifdef MFEM_THREAD_SAFE
+   Vector shape_x(p + 1);
+   Vector shape_y(p + 1);
+   Vector shape_z(p + 1);
+   Vector u(dof);
+#endif
+
+   const real_t x = (ip.z < 1.0) ? (ip.x / (1.0 - ip.z)) : 0.0;
+   const real_t y = (ip.z < 1.0) ? (ip.y / (1.0 - ip.z)) : 0.0;
+   const real_t z = ip.z;
+
+   poly1d.CalcLegendre(p, x, shape_x.GetData());
+   poly1d.CalcLegendre(p, y, shape_y.GetData());
+
+   int o = 0;
+   for (int i = 0; i <= p; i++)
+   {
+      for (int j = 0; j <= p; j++)
+      {
+         int maxij = std::max(i, j);
+         FuentesPyramid::CalcScaledJacobi(p-maxij, 2.0 * (maxij + 1.0), z, 1.0,
+                                          shape_z);
+
+         for (int k = 0; k <= p - maxij; k++)
+         {
+            u[o++] = shape_x(i) * shape_y(j) * shape_z(k) *
+                     pow(1.0 - ip.z, maxij);
+         }
+      }
+   }
+
+   Ti.Mult(u, shape);
+}
+
+void L2_BergotPyramidElement::CalcDShape(const IntegrationPoint &ip,
+                                         DenseMatrix &dshape) const
+{
+   const int p = order;
+
+#ifdef MFEM_THREAD_SAFE
+   Vector shape_x(p + 1);
+   Vector shape_y(p + 1);
+   Vector shape_z(p + 1);
+   Vector dshape_x(p + 1);
+   Vector dshape_y(p + 1);
+   Vector dshape_z(p + 1);
+   Vector dshape_z_dt(p + 1);
+   DenseMatrix du(dof, dim);
+#endif
+
+   const real_t x = (ip.z < 1.0) ? (ip.x / (1.0 - ip.z)) : 0.0;
+   const real_t y = (ip.z < 1.0) ? (ip.y / (1.0 - ip.z)) : 0.0;
+   const real_t z = ip.z;
+
+   Poly_1D::CalcLegendre(p, x, shape_x.GetData(), dshape_x.GetData());
+   Poly_1D::CalcLegendre(p, y, shape_y.GetData(), dshape_y.GetData());
+
+   int o = 0;
+   for (int i = 0; i <= p; i++)
+   {
+      for (int j = 0; j <= p; j++)
+      {
+         int maxij = std::max(i, j);
+         FuentesPyramid::CalcScaledJacobi(p-maxij, 2.0 * (maxij + 1.0), z, 1.0,
+                                          shape_z, dshape_z, dshape_z_dt);
+
+         for (int k = 0; k <= p - maxij; k++, o++)
+         {
+            du(o,0) = dshape_x(i) * shape_y(j) * shape_z(k) *
+                      pow(1.0 - ip.z, maxij - 1);
+            du(o,1) = shape_x(i) * dshape_y(j) * shape_z(k) *
+                      pow(1.0 - ip.z, maxij - 1);
+            du(o,2) = shape_x(i) * shape_y(j) * dshape_z(k) *
+                      pow(1.0 - ip.z, maxij) +
+                      (ip.x * dshape_x(i) * shape_y(j) +
+                       ip.y * shape_x(i) * dshape_y(j)) *
+                      shape_z(k) * pow(1.0 - ip.z, maxij - 2) -
+                      ((maxij > 0) ? (maxij * shape_x(i) * shape_y(j) * shape_z(k) *
+                                      pow(1.0 - ip.z, maxij - 1)) : 0.0);
+         }
+      }
+   }
+
+   Ti.Mult(du, dshape);
+}
+
 }
diff --git a/fem/fe/fe_l2.hpp b/fem/fe/fe_l2.hpp
index c39029a0c..fe42680ee 100644
--- a/fem/fe/fe_l2.hpp
+++ b/fem/fe/fe_l2.hpp
@@ -13,6 +13,7 @@
 #define MFEM_FE_L2
 
 #include "fe_base.hpp"
+#include "fe_pyramid.hpp"
 
 namespace mfem
 {
@@ -183,6 +184,49 @@ public:
                    DenseMatrix &dshape) const override;
 };
 
+/// Arbitrary order L2 elements in 3D on a pyramid
+class L2_FuentesPyramidElement
+   : public NodalFiniteElement, public FuentesPyramid
+{
+private:
+#ifndef MFEM_THREAD_SAFE
+   mutable Vector shape_x, shape_y, shape_z;
+   mutable Vector dshape_x, dshape_y, dshape_z;
+   mutable Vector u;
+   mutable DenseMatrix du;
+#endif
+   DenseMatrixInverse Ti;
+
+public:
+   /// Construct the L2_PyramidElement of order @a p and BasisType @a btype
+   L2_FuentesPyramidElement(const int p,
+                            const int btype = BasisType::GaussLegendre);
+   virtual void CalcShape(const IntegrationPoint &ip, Vector &shape) const;
+   virtual void CalcDShape(const IntegrationPoint &ip,
+                           DenseMatrix &dshape) const;
+};
+
+/// Arbitrary order L2 elements in 3D on a pyramid
+class L2_BergotPyramidElement : public NodalFiniteElement
+{
+private:
+#ifndef MFEM_THREAD_SAFE
+   mutable Vector shape_x, shape_y, shape_z;
+   mutable Vector dshape_x, dshape_y, dshape_z, dshape_z_dt;
+   mutable Vector u;
+   mutable DenseMatrix du;
+#endif
+   DenseMatrixInverse Ti;
+
+public:
+   /// Construct the L2_PyramidElement of order @a p and BasisType @a btype
+   L2_BergotPyramidElement(const int p,
+                           const int btype = BasisType::GaussLegendre);
+   virtual void CalcShape(const IntegrationPoint &ip, Vector &shape) const;
+   virtual void CalcDShape(const IntegrationPoint &ip,
+                           DenseMatrix &dshape) const;
+};
+
 } // namespace mfem
 
 #endif
diff --git a/fem/fe/fe_nd.cpp b/fem/fe/fe_nd.cpp
index 8c9cb806c..2f8eaa0b3 100644
--- a/fem/fe/fe_nd.cpp
+++ b/fem/fe/fe_nd.cpp
@@ -1581,6 +1581,954 @@ void ND_WedgeElement::CalcCurlShape(const IntegrationPoint &ip,
    }
 }
 
+const real_t ND_FuentesPyramidElement::tk[27] =
+{
+   1., 0., 0.,   0., 1., 0.,  0., 0., 1.,
+   -1., 0., 1.,  -1.,-1., 1.,  0.,-1., 1.,
+   -1., 0., 0.,   0.,-1., 0., -M_SQRT1_2,-M_SQRT1_2,M_SQRT2
+};
+
+ND_FuentesPyramidElement::ND_FuentesPyramidElement(const int p,
+                                                   const int cb_type,
+                                                   const int ob_type)
+   : VectorFiniteElement(3, Geometry::PYRAMID, p * (3 * p * p + 5), p,
+                         H_CURL, FunctionSpace::Pk),
+     dof2tk(dof), doftrans(p)
+{
+   zmax = 0.0;
+
+   const real_t *eop = poly1d.OpenPoints(p - 1);
+   const real_t *top = (p > 1) ? poly1d.OpenPoints(p - 2) : NULL;
+   const real_t *qop = poly1d.OpenPoints(p - 1, ob_type);
+   const real_t *qcp = poly1d.ClosedPoints(p, cb_type);
+
+   const int pm2 = p - 2;
+
+#ifndef MFEM_THREAD_SAFE
+   tmp_E_E_ij.SetSize(p, dim);
+   tmp_dE_E_ij.SetSize(p, dim);
+   tmp_E_Q1_ijk.SetSize(p, p + 1, dim);
+   tmp_dE_Q1_ijk.SetSize(p, p + 1, dim);
+   tmp_E_Q2_ijk.SetSize(p, p + 1, dim);
+   tmp_dE_Q2_ijk.SetSize(p, p + 1, dim);
+   tmp_E_T_ijk.SetSize(p - 1, p, dim);
+   tmp_dE_T_ijk.SetSize(p - 1, p, dim);
+   tmp_phi_Q1_ij.SetSize(p + 1, p + 1);
+   tmp_dphi_Q1_ij.SetSize(p + 1, p + 1, dim);
+   tmp_phi_Q2_ij.SetSize(p + 1, p + 1);
+   tmp_dphi_Q2_ij.SetSize(p + 1, p + 1, dim);
+   tmp_phi_E_i.SetSize(p + 1);
+   tmp_dphi_E_i.SetSize(p + 1, dim);
+   u.SetSize(dof, dim);
+   curlu.SetSize(dof, dim);
+#else
+   DenseMatrix tmp_E_E_ij(p, dim);
+   DenseTensor tmp_E_Q1_ijk(p, p + 1, dim);
+   DenseTensor tmp_dE_Q1_ijk(p, p + 1, dim);
+   DenseTensor tmp_E_Q2_ijk(p, p + 1, dim);
+   DenseTensor tmp_dE_Q2_ijk(p, p + 1, dim);
+   DenseTensor tmp_E_T_ijk(p - 1, p, dim);
+   DenseTensor tmp_dE_T_ijk(p - 1, p, dim);
+   DenseMatrix tmp_phi_Q1_ij(p + 1, p + 1);
+   DenseTensor tmp_dphi_Q1_ij(p + 1, p + 1, dim);
+   DenseMatrix tmp_phi_Q2_ij(p + 1, p + 1);
+   Vector      tmp_phi_E_i(p + 1);
+   DenseMatrix tmp_dphi_E_i(p + 1, dim);
+   DenseMatrix u(dof, dim);
+#endif
+
+   int o = 0;
+
+   // edges
+   for (int i = 0; i < p; i++) // (0, 1)
+   {
+      Nodes.IntPoint(o).Set3(eop[i], 0., 0.);
+      dof2tk[o++] = 0;
+   }
+   for (int i = 0; i < p; i++) // (1, 2)
+   {
+      Nodes.IntPoint(o).Set3(1., eop[i], 0.);
+      dof2tk[o++] = 1;
+   }
+   for (int i = 0; i < p; i++) // (3, 2)
+   {
+      Nodes.IntPoint(o).Set3(eop[i], 1., 0.);
+      dof2tk[o++] = 0;
+   }
+   for (int i = 0; i < p; i++) // (0, 3)
+   {
+      Nodes.IntPoint(o).Set3(0., eop[i], 0.);
+      dof2tk[o++] = 1;
+   }
+   for (int i = 0; i < p; i++) // (0, 4)
+   {
+      Nodes.IntPoint(o).Set3(0., 0., eop[i]);
+      dof2tk[o++] = 2;
+   }
+   for (int i = 0; i < p; i++) // (1, 4)
+   {
+      Nodes.IntPoint(o).Set3(1. - eop[i], 0., eop[i]);
+      dof2tk[o++] = 3;
+   }
+   for (int i = 0; i < p; i++) // (2, 4)
+   {
+      Nodes.IntPoint(o).Set3(1. - eop[i], 1. - eop[i], eop[i]);
+      dof2tk[o++] = 4;
+   }
+   for (int i = 0; i < p; i++) // (3, 4)
+   {
+      Nodes.IntPoint(o).Set3(0., 1. - eop[i], eop[i]);
+      dof2tk[o++] = 5;
+   }
+
+   // quadrilateral face (3, 2, 1, 0)
+   // x-components
+   for (int j = 1; j < p; j++)
+      for (int i = 0; i < p; i++)
+      {
+         Nodes.IntPoint(o).Set3(qop[i], qcp[p-j], 0.);
+         dof2tk[o++] = 0; // (1 0 0)
+      }
+
+   // y-components
+   for (int j = 0; j < p; j++)
+      for (int i = 1; i < p; i++)
+      {
+         Nodes.IntPoint(o).Set3(qcp[i], qop[p-1-j], 0.);
+         dof2tk[o++] = 7; // (0 -1 0)
+      }
+
+   // triangular faces
+   for (int j = 0; j <= pm2; j++)  // (0, 1, 4)
+      for (int i = 0; i + j <= pm2; i++)
+      {
+         real_t w = top[i] + top[j] + top[pm2-i-j];
+         Nodes.IntPoint(o).Set3(top[i]/w, 0., top[j]/w);
+         dof2tk[o++] = 0;
+         Nodes.IntPoint(o).Set3(top[i]/w, 0., top[j]/w);
+         dof2tk[o++] = 2;
+      }
+   for (int j = 0; j <= pm2; j++)  // (1, 2, 4)
+      for (int i = 0; i + j <= pm2; i++)
+      {
+         real_t w = top[i] + top[j] + top[pm2-i-j];
+         Nodes.IntPoint(o).Set3((top[i] + top[pm2-i-j])/w, top[i]/w, top[j]/w);
+         dof2tk[o++] = 1;
+         Nodes.IntPoint(o).Set3((top[i] + top[pm2-i-j])/w, top[i]/w, top[j]/w);
+         dof2tk[o++] = 3;
+      }
+   for (int j = 0; j <= pm2; j++)  // (2, 3, 4)
+      for (int i = 0; i + j <= pm2; i++)
+      {
+         real_t w = top[i] + top[j] + top[pm2-i-j];
+         Nodes.IntPoint(o).Set3(top[pm2-i-j]/w, (top[i] + top[pm2-i-j])/w,
+                                top[j]/w);
+         dof2tk[o++] = 6;
+         Nodes.IntPoint(o).Set3(top[pm2-i-j]/w, (top[i] + top[pm2-i-j])/w,
+                                top[j]/w);
+         dof2tk[o++] = 4;
+      }
+   for (int j = 0; j <= pm2; j++)  // (3, 0, 4)
+      for (int i = 0; i + j <= pm2; i++)
+      {
+         real_t w = top[i] + top[j] + top[pm2-i-j];
+         Nodes.IntPoint(o).Set3(0., top[pm2-i-j]/w, top[j]/w);
+         dof2tk[o++] = 7;
+         Nodes.IntPoint(o).Set3(0., top[pm2-i-j]/w, top[j]/w);
+         dof2tk[o++] = 5;
+      }
+
+   // interior
+   // x-components
+   for (int k = 1; k < p; k++)
+      for (int j = 1; j < p; j++)
+         for (int i = 0; i < p; i++)
+         {
+            real_t w = 1.0 - qcp[k];
+            Nodes.IntPoint(o).Set3(qop[i]*w, qcp[j]*w, qcp[k]);
+            dof2tk[o++] = 0;
+         }
+   // y-components
+   for (int k = 1; k < p; k++)
+      for (int j = 0; j < p; j++)
+         for (int i = 1; i < p; i++)
+         {
+            real_t w = 1.0 - qcp[k];
+            Nodes.IntPoint(o).Set3(qcp[i]*w, qop[j]*w, qcp[k]);
+            dof2tk[o++] = 1;
+         }
+   // z-components
+   for (int k = 0; k < p; k++)
+      for (int j = 1; j < p; j++)
+         for (int i = 1; i < p; i++)
+         {
+            real_t w = 1.0 - qop[k];
+            Nodes.IntPoint(o).Set3(qcp[i]*w, qcp[j]*w, qop[k]);
+            dof2tk[o++] = 8;
+         }
+
+   DenseMatrix T(dof);
+
+   for (int m = 0; m < dof; m++)
+   {
+      const IntegrationPoint &ip = Nodes.IntPoint(m);
+      calcBasis(p, ip, tmp_E_E_ij, tmp_E_Q1_ijk, tmp_E_Q2_ijk, tmp_E_T_ijk,
+                tmp_phi_Q1_ij, tmp_dphi_Q1_ij, tmp_phi_Q2_ij,
+                tmp_phi_E_i, tmp_dphi_E_i, u);
+
+      const Vector tm({tk[3*dof2tk[m]], tk[3*dof2tk[m]+1], tk[3*dof2tk[m]+2]});
+      u.Mult(tm, T.GetColumn(m));
+   }
+
+   Ti.Factor(T);
+}
+
+void ND_FuentesPyramidElement::CalcVShape(const IntegrationPoint &ip,
+                                          DenseMatrix &shape) const
+{
+   const int p = order;
+
+#ifdef MFEM_THREAD_SAFE
+   DenseMatrix tmp_E_E_ij(p, dim);
+   DenseTensor tmp_E_Q1_ijk(p, p + 1, dim);
+   DenseTensor tmp_E_Q2_ijk(p, p + 1, dim);
+   DenseTensor tmp_E_T_ijk(p - 1, p, dim);
+   DenseMatrix tmp_phi_Q1_ij(p + 1, p + 1);
+   DenseTensor tmp_dphi_Q1_ij(p + 1, p + 1, dim);
+   DenseMatrix tmp_phi_Q2_ij(p + 1, p + 1);
+   Vector      tmp_phi_E_i(p + 1);
+   DenseMatrix tmp_dphi_E_i(p + 1, dim);
+   DenseMatrix u(dof, dim);
+#endif
+
+   calcBasis(p, ip, tmp_E_E_ij, tmp_E_Q1_ijk, tmp_E_Q2_ijk, tmp_E_T_ijk,
+             tmp_phi_Q1_ij, tmp_dphi_Q1_ij, tmp_phi_Q2_ij,
+             tmp_phi_E_i, tmp_dphi_E_i, u);
+
+   Ti.Mult(u, shape);
+}
+
+void ND_FuentesPyramidElement::CalcCurlShape(const IntegrationPoint &ip,
+                                             DenseMatrix &curl_shape) const
+{
+   const int p = order;
+
+#ifdef MFEM_THREAD_SAFE
+   DenseMatrix tmp_E_E_ij(p, dim);
+   DenseMatrix tmp_dE_E_ij(p, dim);
+   DenseTensor tmp_E_Q1_ijk(p, p + 1, dim);
+   DenseTensor tmp_dE_Q1_ijk(p, p + 1, dim);
+   DenseTensor tmp_E_Q2_ijk(p, p + 1, dim);
+   DenseTensor tmp_dE_Q2_ijk(p, p + 1, dim);
+   DenseTensor tmp_E_T_ijk(p - 1, p, dim);
+   DenseTensor tmp_dE_T_ijk(p - 1, p, dim);
+   DenseMatrix tmp_phi_Q2_ij(p + 1, p + 1);
+   DenseTensor tmp_dphi_Q2_ij(p + 1, p + 1, dim);
+   Vector      tmp_phi_E_i(p + 1);
+   DenseMatrix tmp_dphi_E_i(p + 1, dim);
+   DenseMatrix curlu(dof, dim);
+#endif
+
+   calcCurlBasis(p, ip, tmp_E_E_ij, tmp_dE_E_ij, tmp_E_Q1_ijk, tmp_dE_Q1_ijk,
+                 tmp_E_Q2_ijk, tmp_dE_Q2_ijk, tmp_E_T_ijk, tmp_dE_T_ijk,
+                 tmp_phi_Q2_ij, tmp_dphi_Q2_ij, tmp_phi_E_i, tmp_dphi_E_i,
+                 curlu);
+
+   Ti.Mult(curlu, curl_shape);
+}
+
+void ND_FuentesPyramidElement::CalcRawVShape(const IntegrationPoint &ip,
+                                             DenseMatrix &shape) const
+{
+   const int p = order;
+
+#ifdef MFEM_THREAD_SAFE
+   DenseMatrix tmp_E_E_ij(p, dim);
+   DenseTensor tmp_E_Q1_ijk(p, p + 1, dim);
+   DenseTensor tmp_E_Q2_ijk(p, p + 1, dim);
+   DenseTensor tmp_E_T_ijk(p - 1, p, dim);
+   DenseMatrix tmp_phi_Q1_ij(p + 1, p + 1);
+   DenseTensor tmp_dphi_Q1_ij(p + 1, p + 1, dim);
+   DenseMatrix tmp_phi_Q2_ij(p + 1, p + 1);
+   Vector      tmp_phi_E_i(p + 1);
+   DenseMatrix tmp_dphi_E_i(p + 1, dim);
+#endif
+
+   calcBasis(p, ip, tmp_E_E_ij, tmp_E_Q1_ijk, tmp_E_Q2_ijk, tmp_E_T_ijk,
+             tmp_phi_Q1_ij, tmp_dphi_Q1_ij, tmp_phi_Q2_ij,
+             tmp_phi_E_i, tmp_dphi_E_i, shape);
+}
+
+void ND_FuentesPyramidElement::CalcRawCurlShape(const IntegrationPoint &ip,
+                                                DenseMatrix &dshape) const
+{
+   const int p = order;
+
+#ifdef MFEM_THREAD_SAFE
+   DenseMatrix tmp_E_E_ij(p, dim);
+   DenseMatrix tmp_dE_E_ij(p, dim);
+   DenseTensor tmp_E_Q1_ijk(p, p + 1, dim);
+   DenseTensor tmp_dE_Q1_ijk(p, p + 1, dim);
+   DenseTensor tmp_E_Q2_ijk(p, p + 1, dim);
+   DenseTensor tmp_dE_Q2_ijk(p, p + 1, dim);
+   DenseTensor tmp_E_T_ijk(p - 1, p, dim);
+   DenseTensor tmp_dE_T_ijk(p - 1, p, dim);
+   DenseMatrix tmp_phi_Q2_ij(p + 1, p + 1);
+   DenseTensor tmp_dphi_Q2_ij(p + 1, p + 1, dim);
+   Vector      tmp_phi_E_i(p + 1);
+   DenseMatrix tmp_dphi_E_i(p + 1, dim);
+#endif
+
+   calcCurlBasis(p, ip, tmp_E_E_ij, tmp_dE_E_ij, tmp_E_Q1_ijk, tmp_dE_Q1_ijk,
+                 tmp_E_Q2_ijk, tmp_dE_Q2_ijk, tmp_E_T_ijk, tmp_dE_T_ijk,
+                 tmp_phi_Q2_ij, tmp_dphi_Q2_ij, tmp_phi_E_i, tmp_dphi_E_i,
+                 dshape);
+}
+
+void ND_FuentesPyramidElement::calcBasis(const int p,
+                                         const IntegrationPoint &ip,
+                                         DenseMatrix & E_E_ik,
+                                         DenseTensor & E_Q1_ijk,
+                                         DenseTensor & E_Q2_ijk,
+                                         DenseTensor & E_T_ijk,
+                                         DenseMatrix & phi_Q1_ij,
+                                         DenseTensor & dphi_Q1_ij,
+                                         DenseMatrix & phi_Q2_ij,
+                                         Vector      & phi_E_k,
+                                         DenseMatrix & dphi_E_k,
+                                         DenseMatrix &W) const
+{
+   real_t x = ip.x;
+   real_t y = ip.y;
+   real_t z = ip.z;
+   Vector xy({x,y}), dmu(3);
+   real_t mu, mu2;
+
+   if (std::fabs(1.0 - z) < apex_tol)
+   {
+      z = 1.0 - apex_tol;
+      y = 0.5 * (1.0 - z);
+      x = 0.5 * (1.0 - z);
+      xy(0) = x; xy(1) = y;
+   }
+   zmax = std::max(z, zmax);
+
+   W = 0.0;
+
+   int o = 0;
+
+   // Mixed Edges
+   if (z < 1.0)
+   {
+      // (a, b) = (1, 2), c = 0
+      mu = mu0(z, xy, 2);
+      E_E(p, nu01(z, xy, 1), nu01_grad_nu01(z, xy, 1), E_E_ik);
+      for (int i=0; i<p; i++, o++)
+         for (int k=0; k<3; k++)
+         {
+            W(o, k) = mu * E_E_ik(i, k);
+         }
+
+      // (a, b) = (1, 2), c = 1
+      mu = mu1(z, xy, 2);
+      for (int i=0; i<p; i++, o++)
+         for (int k=0; k<3; k++)
+         {
+            W(o, k) = mu * E_E_ik(i, k);
+         }
+
+      // (a, b) = (2, 1), c = 0
+      mu = mu0(z, xy, 1);
+      E_E(p, nu01(z, xy, 2), nu01_grad_nu01(z, xy, 2), E_E_ik);
+      for (int i=0; i<p; i++, o++)
+         for (int k=0; k<3; k++)
+         {
+            W(o, k) = mu * E_E_ik(i, k);
+         }
+
+      // (a, b) = (2, 1), c = 1
+      mu = mu1(z, xy, 1);
+      for (int i=0; i<p; i++, o++)
+         for (int k=0; k<3; k++)
+         {
+            W(o, k) = mu * E_E_ik(i, k);
+         }
+   }
+
+   // Triangle Edges
+   if (z < 1.0)
+   {
+      E_E(p, lam15(x, y, z), lam15_grad_lam15(x, y, z), E_E_ik);
+      for (int i=0; i<p; i++, o++)
+         for (int k=0; k<3; k++)
+         {
+            W(o, k) = E_E_ik(i, k);
+         }
+
+      E_E(p, lam25(x, y, z), lam25_grad_lam25(x, y, z), E_E_ik);
+      for (int i=0; i<p; i++, o++)
+         for (int k=0; k<3; k++)
+         {
+            W(o, k) = E_E_ik(i, k);
+         }
+
+      E_E(p, lam35(x, y, z), lam35_grad_lam35(x, y, z), E_E_ik);
+      for (int i=0; i<p; i++, o++)
+         for (int k=0; k<3; k++)
+         {
+            W(o, k) = E_E_ik(i, k);
+         }
+
+      E_E(p, lam45(x, y, z), lam45_grad_lam45(x, y, z), E_E_ik);
+      for (int i=0; i<p; i++, o++)
+         for (int k=0; k<3; k++)
+         {
+            W(o, k) = E_E_ik(i, k);
+         }
+   }
+
+   // Quadrilateral Face
+   if (z < 1.0 && p >= 2)
+   {
+      mu = mu0(z);
+      mu2 = mu * mu;
+
+      // Family I
+      E_Q(p, mu01(z, xy, 1), mu01_grad_mu01(z, xy, 1), mu01(z, xy, 2),
+          E_Q1_ijk);
+      for (int j=2; j<=p; j++)
+         for (int i=0; i<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               W(o, k) = mu2 * E_Q1_ijk(i, j, k);
+            }
+
+      // Family II
+      E_Q(p, mu01(z, xy, 2), mu01_grad_mu01(z, xy, 2), mu01(z, xy, 1),
+          E_Q2_ijk);
+      for (int j=2; j<=p; j++)
+         for (int i=0; i<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               W(o, k) = mu2 * E_Q2_ijk(i, j, k);
+            }
+   }
+
+   // Triangular Faces
+   if (z < 1.0 && p >= 2)
+   {
+      // Family I
+      // (a, b) = (1, 2), c = 0
+      mu = mu0(z, xy, 2);
+      E_T(p, nu012(z, xy, 1), nu01_grad_nu01(z, xy, 1), E_T_ijk);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               W(o, k) = mu * E_T_ijk(i, j, k);
+            }
+
+      // (a, b) = (1, 2), c = 1
+      mu = mu1(z, xy, 2);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               W(o, k) = mu * E_T_ijk(i, j, k);
+            }
+
+      // (a, b) = (2, 1), c = 0
+      mu = mu0(z, xy, 1);
+      E_T(p, nu012(z, xy, 2), nu01_grad_nu01(z, xy, 2), E_T_ijk);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               W(o, k) = mu * E_T_ijk(i, j, k);
+            }
+
+      // (a, b) = (2, 1), c = 1
+      mu = mu1(z, xy, 1);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               W(o, k) = mu * E_T_ijk(i, j, k);
+            }
+
+      // Family II
+      // (a, b) = (1, 2), c = 0
+      mu = mu0(z, xy, 2);
+      E_T(p, nu120(z, xy, 1), nu12_grad_nu12(z, xy, 1), E_T_ijk);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               W(o, k) = mu * E_T_ijk(i, j, k);
+            }
+
+      // (a, b) = (1, 2), c = 1
+      mu = mu1(z, xy, 2);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               W(o, k) = mu * E_T_ijk(i, j, k);
+            }
+
+      // (a, b) = (2, 1), c = 0
+      mu = mu0(z, xy, 1);
+      E_T(p, nu120(z, xy, 2), nu12_grad_nu12(z, xy, 2), E_T_ijk);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               W(o, k) = mu * E_T_ijk(i, j, k);
+            }
+
+      // (a, b) = (2, 1), c = 1
+      mu = mu1(z, xy, 1);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               W(o, k) = mu * E_T_ijk(i, j, k);
+            }
+   }
+
+   // Interior
+   if (z < 1.0 && p >= 2)
+   {
+      // Family I
+      phi_Q(p, mu01(z, xy, 1), grad_mu01(z, xy, 1), mu01(z, xy, 2),
+            grad_mu01(z, xy, 2), phi_Q1_ij, dphi_Q1_ij);
+      phi_E(p, mu01(z), grad_mu01(z), phi_E_k, dphi_E_k);
+      for (int k=2; k<=p; k++)
+         for (int j=2; j<=p; j++)
+            for (int i=2; i<=p; i++, o++)
+               for (int l=0; l<3; l++)
+                  W(o, l) = dphi_Q1_ij(i, j, l) * phi_E_k(k) +
+                            phi_Q1_ij(i, j) * dphi_E_k(k, l);
+
+      // Family II
+      mu = mu0(z);
+      for (int k=2; k<=p; k++)
+         for (int j=2; j<=p; j++)
+            for (int i=0; i<p; i++, o++)
+               for (int l=0; l<3; l++)
+               {
+                  W(o, l) = mu * E_Q1_ijk(i, j, l) * phi_E_k(k);
+               }
+
+      // Family III
+      for (int k=2; k<=p; k++)
+         for (int j=2; j<=p; j++)
+            for (int i=0; i<p; i++, o++)
+               for (int l=0; l<3; l++)
+               {
+                  W(o, l) = mu * E_Q2_ijk(i, j, l) * phi_E_k(k);
+               }
+
+      // Family IV
+      // Re-using mu from Family I
+      dmu = grad_mu0(z);
+      phi_Q(p, mu01(z, xy, 2), mu01(z, xy, 1), phi_Q2_ij);
+      for (int j=2; j<=p; j++)
+         for (int i=2; i<=p; i++, o++)
+         {
+            const int n = std::max(i,j);
+            const real_t nmu = n * pow(mu, n-1);
+            for (int l=0; l<3; l++)
+            {
+               W(o, l) = nmu * phi_Q2_ij(i, j) * dmu(l);
+            }
+         }
+   }
+}
+
+void ND_FuentesPyramidElement::calcCurlBasis(const int p,
+                                             const IntegrationPoint &ip,
+                                             DenseMatrix & E_E_ik,
+                                             DenseMatrix & dE_E_ik,
+                                             DenseTensor & E_Q1_ijk,
+                                             DenseTensor & dE_Q1_ijk,
+                                             DenseTensor & E_Q2_ijk,
+                                             DenseTensor & dE_Q2_ijk,
+                                             DenseTensor & E_T_ijk,
+                                             DenseTensor & dE_T_ijk,
+                                             DenseMatrix & phi_Q2_ij,
+                                             DenseTensor & dphi_Q2_ij,
+                                             Vector      & phi_E_k,
+                                             DenseMatrix & dphi_E_k,
+                                             DenseMatrix & dW) const
+{
+   real_t x = ip.x;
+   real_t y = ip.y;
+   real_t z = ip.z;
+   Vector xy({x,y}), dmu(3);
+   Vector dmuxE(3), E(3), dphi(3), muphi(3);
+
+   real_t mu, mu2;
+
+   if (std::fabs(1.0 - z) < apex_tol)
+   {
+      z = 1.0 - apex_tol;
+      y = 0.5 * (1.0 - z);
+      x = 0.5 * (1.0 - z);
+      xy(0) = x; xy(1) = y;
+   }
+   zmax = std::max(z, zmax);
+
+   dW = 0.0;
+
+   int o = 0;
+
+   // Mixed Edges
+   if (z < 1.0)
+   {
+      // (a, b) = (1, 2), c = 0
+      mu = mu0(z, xy, 2);
+      dmu = grad_mu0(z, xy, 2);
+      E_E(p, nu01(z, xy, 1), grad_nu01(z, xy, 1), E_E_ik, dE_E_ik);
+      for (int i=0; i<p; i++, o++)
+      {
+         E(0) = E_E_ik(i, 0); E(1) = E_E_ik(i, 1); E(2) = E_E_ik(i, 2);
+         dmu.cross3D(E, dmuxE);
+         for (int k=0; k<3; k++)
+         {
+            dW(o, k) = mu * dE_E_ik(i, k) + dmuxE(k);
+         }
+      }
+
+      // (a, b) = (1, 2), c = 1
+      mu = mu1(z, xy, 2);
+      dmu = grad_mu1(z, xy, 2);
+      for (int i=0; i<p; i++, o++)
+      {
+         E(0) = E_E_ik(i, 0); E(1) = E_E_ik(i, 1); E(2) = E_E_ik(i, 2);
+         dmu.cross3D(E, dmuxE);
+         for (int k=0; k<3; k++)
+         {
+            dW(o, k) = mu * dE_E_ik(i, k) + dmuxE(k);
+         }
+      }
+
+      // (a, b) = (2, 1), c = 0
+      mu = mu0(z, xy, 1);
+      dmu = grad_mu0(z, xy, 1);
+      E_E(p, nu01(z, xy, 2), grad_nu01(z, xy, 2), E_E_ik, dE_E_ik);
+      for (int i=0; i<p; i++, o++)
+      {
+         E(0) = E_E_ik(i, 0); E(1) = E_E_ik(i, 1); E(2) = E_E_ik(i, 2);
+         dmu.cross3D(E, dmuxE);
+         for (int k=0; k<3; k++)
+         {
+            dW(o, k) = mu * dE_E_ik(i, k) + dmuxE(k);
+         }
+      }
+
+      // (a, b) = (2, 1), c = 1
+      mu = mu1(z, xy, 1);
+      dmu = grad_mu1(z, xy, 1);
+      for (int i=0; i<p; i++, o++)
+      {
+         E(0) = E_E_ik(i, 0); E(1) = E_E_ik(i, 1); E(2) = E_E_ik(i, 2);
+         dmu.cross3D(E, dmuxE);
+         for (int k=0; k<3; k++)
+         {
+            dW(o, k) = mu * dE_E_ik(i, k) + dmuxE(k);
+         }
+      }
+   }
+
+   // Triangle Edges
+   if (z < 1.0)
+   {
+      E_E(p, lam15(x, y, z), grad_lam15(x, y, z), E_E_ik, dE_E_ik);
+      for (int i=0; i<p; i++, o++)
+         for (int k=0; k<3; k++)
+         {
+            dW(o, k) = dE_E_ik(i, k);
+         }
+
+      E_E(p, lam25(x, y, z), grad_lam25(x, y, z), E_E_ik, dE_E_ik);
+      for (int i=0; i<p; i++, o++)
+         for (int k=0; k<3; k++)
+         {
+            dW(o, k) = dE_E_ik(i, k);
+         }
+
+      E_E(p, lam35(x, y, z), grad_lam35(x, y, z), E_E_ik, dE_E_ik);
+      for (int i=0; i<p; i++, o++)
+         for (int k=0; k<3; k++)
+         {
+            dW(o, k) = dE_E_ik(i, k);
+         }
+
+      E_E(p, lam45(x, y, z), grad_lam45(x, y, z), E_E_ik, dE_E_ik);
+      for (int i=0; i<p; i++, o++)
+         for (int k=0; k<3; k++)
+         {
+            dW(o, k) = dE_E_ik(i, k);
+         }
+   }
+
+   // Quadrilateral Face
+   if (z < 1.0 && p >= 2)
+   {
+      mu = mu0(z);
+      mu2 = mu * mu;
+      dmu = grad_mu0(z);
+
+      // Family I
+      E_Q(p, mu01(z, xy, 1), grad_mu01(z, xy, 1),
+          mu01(z, xy, 2), grad_mu01(z, xy, 2), E_Q1_ijk, dE_Q1_ijk);
+      for (int j=2; j<=p; j++)
+         for (int i=0; i<p; i++, o++)
+         {
+            E(0) = E_Q1_ijk(i, j, 0);
+            E(1) = E_Q1_ijk(i, j, 1);
+            E(2) = E_Q1_ijk(i, j, 2);
+            dmu.cross3D(E, dmuxE);
+            for (int k=0; k<3; k++)
+            {
+               dW(o, k) = mu2 * dE_Q1_ijk(i, j, k) + 2.0 * mu * dmuxE(k);
+            }
+         }
+
+      // Family II
+      E_Q(p, mu01(z, xy, 2), grad_mu01(z, xy, 2),
+          mu01(z, xy, 1), grad_mu01(z, xy, 1), E_Q2_ijk, dE_Q2_ijk);
+      for (int j=2; j<=p; j++)
+         for (int i=0; i<p; i++, o++)
+         {
+            E(0) = E_Q2_ijk(i, j, 0);
+            E(1) = E_Q2_ijk(i, j, 1);
+            E(2) = E_Q2_ijk(i, j, 2);
+            dmu.cross3D(E, dmuxE);
+            for (int k=0; k<3; k++)
+            {
+               dW(o, k) = mu2 * dE_Q2_ijk(i, j, k) + 2.0 * mu * dmuxE(k);
+            }
+         }
+   }
+
+   // Triangular Faces
+   if (z < 1.0 && p >= 2)
+   {
+      // Family I
+      // (a, b) = (1, 2), c = 0
+      mu = mu0(z, xy, 2);
+      dmu = grad_mu0(z, xy, 2);
+      E_T(p, nu012(z, xy, 1), grad_nu012(z, xy, 1), E_T_ijk, dE_T_ijk);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+         {
+            E(0) = E_T_ijk(i, j, 0);
+            E(1) = E_T_ijk(i, j, 1);
+            E(2) = E_T_ijk(i, j, 2);
+            dmu.cross3D(E, dmuxE);
+            for (int k=0; k<3; k++)
+            {
+               dW(o, k) = mu * dE_T_ijk(i, j, k) + dmuxE(k);
+            }
+         }
+
+      // (a, b) = (1, 2), c = 1
+      mu = mu1(z, xy, 2);
+      dmu = grad_mu1(z, xy, 2);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+         {
+            E(0) = E_T_ijk(i, j, 0);
+            E(1) = E_T_ijk(i, j, 1);
+            E(2) = E_T_ijk(i, j, 2);
+            dmu.cross3D(E, dmuxE);
+            for (int k=0; k<3; k++)
+            {
+               dW(o, k) = mu * dE_T_ijk(i, j, k) + dmuxE(k);
+            }
+         }
+
+      // (a, b) = (2, 1), c = 0
+      mu = mu0(z, xy, 1);
+      dmu = grad_mu0(z, xy, 1);
+      E_T(p, nu012(z, xy, 2), grad_nu012(z, xy, 2), E_T_ijk, dE_T_ijk);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+         {
+            E(0) = E_T_ijk(i, j, 0);
+            E(1) = E_T_ijk(i, j, 1);
+            E(2) = E_T_ijk(i, j, 2);
+            dmu.cross3D(E, dmuxE);
+            for (int k=0; k<3; k++)
+            {
+               dW(o, k) = mu * dE_T_ijk(i, j, k) + dmuxE(k);
+            }
+         }
+
+      // (a, b) = (2, 1), c = 1
+      mu = mu1(z, xy, 1);
+      dmu = grad_mu1(z, xy, 1);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+         {
+            E(0) = E_T_ijk(i, j, 0);
+            E(1) = E_T_ijk(i, j, 1);
+            E(2) = E_T_ijk(i, j, 2);
+            dmu.cross3D(E, dmuxE);
+            for (int k=0; k<3; k++)
+            {
+               dW(o, k) = mu * dE_T_ijk(i, j, k) + dmuxE(k);
+            }
+         }
+
+      // Family II
+      // (a, b) = (1, 2), c = 0
+      mu = mu0(z, xy, 2);
+      dmu = grad_mu0(z, xy, 2);
+      E_T(p, nu120(z, xy, 1), grad_nu120(z, xy, 1), E_T_ijk, dE_T_ijk);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+         {
+            E(0) = E_T_ijk(i, j, 0);
+            E(1) = E_T_ijk(i, j, 1);
+            E(2) = E_T_ijk(i, j, 2);
+            dmu.cross3D(E, dmuxE);
+            for (int k=0; k<3; k++)
+            {
+               dW(o, k) = mu * dE_T_ijk(i, j, k) + dmuxE(k);
+            }
+         }
+
+      // (a, b) = (1, 2), c = 1
+      mu = mu1(z, xy, 2);
+      dmu = grad_mu1(z, xy, 2);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+         {
+            E(0) = E_T_ijk(i, j, 0);
+            E(1) = E_T_ijk(i, j, 1);
+            E(2) = E_T_ijk(i, j, 2);
+            dmu.cross3D(E, dmuxE);
+            for (int k=0; k<3; k++)
+            {
+               dW(o, k) = mu * dE_T_ijk(i, j, k) + dmuxE(k);
+            }
+         }
+
+      // (a, b) = (2, 1), c = 0
+      mu = mu0(z, xy, 1);
+      dmu = grad_mu0(z, xy, 1);
+      E_T(p, nu120(z, xy, 2), grad_nu120(z, xy, 2), E_T_ijk, dE_T_ijk);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+         {
+            E(0) = E_T_ijk(i, j, 0);
+            E(1) = E_T_ijk(i, j, 1);
+            E(2) = E_T_ijk(i, j, 2);
+            dmu.cross3D(E, dmuxE);
+            for (int k=0; k<3; k++)
+            {
+               dW(o, k) = mu * dE_T_ijk(i, j, k) + dmuxE(k);
+            }
+         }
+
+      // (a, b) = (2, 1), c = 1
+      mu = mu1(z, xy, 1);
+      dmu = grad_mu1(z, xy, 1);
+      for (int j=1; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+         {
+            E(0) = E_T_ijk(i, j, 0);
+            E(1) = E_T_ijk(i, j, 1);
+            E(2) = E_T_ijk(i, j, 2);
+            dmu.cross3D(E, dmuxE);
+            for (int k=0; k<3; k++)
+            {
+               dW(o, k) = mu * dE_T_ijk(i, j, k) + dmuxE(k);
+            }
+         }
+   }
+
+   // Interior
+   if (z < 1.0 && p >= 2)
+   {
+      // Family I
+      // Curl is zero so skip these functions
+      o += (p - 1) * (p - 1) * (p - 1);
+
+      // Family II
+      mu = mu0(z);
+      dmu = grad_mu0(z);
+      phi_E(p, mu01(z), grad_mu01(z), phi_E_k, dphi_E_k);
+      for (int k=2; k<=p; k++)
+      {
+         dphi(0) = dphi_E_k(k, 0);
+         dphi(1) = dphi_E_k(k, 1);
+         dphi(2) = dphi_E_k(k, 2);
+         add(mu, dphi, phi_E_k(k), dmu, muphi);
+
+         for (int j=2; j<=p; j++)
+            for (int i=0; i<p; i++, o++)
+            {
+               E(0) = E_Q1_ijk(i, j, 0);
+               E(1) = E_Q1_ijk(i, j, 1);
+               E(2) = E_Q1_ijk(i, j, 2);
+               muphi.cross3D(E, dmuxE);
+               for (int l=0; l<3; l++)
+               {
+                  dW(o, l) = mu * dE_Q1_ijk(i, j, l) * phi_E_k(k) + dmuxE(l);
+               }
+            }
+      }
+
+      // Family III
+      for (int k=2; k<=p; k++)
+      {
+         dphi(0) = dphi_E_k(k, 0);
+         dphi(1) = dphi_E_k(k, 1);
+         dphi(2) = dphi_E_k(k, 2);
+         add(mu, dphi, phi_E_k(k), dmu, muphi);
+
+         for (int j=2; j<=p; j++)
+            for (int i=0; i<p; i++, o++)
+            {
+               E(0) = E_Q2_ijk(i, j, 0);
+               E(1) = E_Q2_ijk(i, j, 1);
+               E(2) = E_Q2_ijk(i, j, 2);
+               muphi.cross3D(E, dmuxE);
+               for (int l=0; l<3; l++)
+               {
+                  dW(o, l) = mu * dE_Q2_ijk(i, j, l) * phi_E_k(k) + dmuxE(l);
+               }
+            }
+      }
+
+      // Family IV
+      // Re-using mu from Family II
+      dmu = grad_mu0(z);
+      phi_Q(p, mu01(z, xy, 2), grad_mu01(z, xy, 2), mu01(z, xy, 1),
+            grad_mu01(z, xy, 1), phi_Q2_ij, dphi_Q2_ij);
+      for (int j=2; j<=p; j++)
+         for (int i=2; i<=p; i++, o++)
+         {
+            const int n = std::max(i,j);
+            const real_t nmu = n * pow(mu, n-1);
+
+            dphi(0) = dphi_Q2_ij(i, j, 0);
+            dphi(1) = dphi_Q2_ij(i, j, 1);
+            dphi(2) = dphi_Q2_ij(i, j, 2);
+            dphi.cross3D(dmu, muphi);
+
+            for (int l=0; l<3; l++)
+            {
+               dW(o, l) = nmu * muphi(l);
+            }
+         }
+   }
+}
+
 ND_R1D_PointElement::ND_R1D_PointElement(int p)
    : VectorFiniteElement(1, Geometry::POINT, 2, p,
                          H_CURL, FunctionSpace::Pk)
diff --git a/fem/fe/fe_nd.hpp b/fem/fe/fe_nd.hpp
index 14a5c65e7..bb286b6dc 100644
--- a/fem/fe/fe_nd.hpp
+++ b/fem/fe/fe_nd.hpp
@@ -14,6 +14,7 @@
 
 #include "fe_base.hpp"
 #include "fe_h1.hpp"
+#include "fe_pyramid.hpp"
 
 namespace mfem
 {
@@ -415,6 +416,118 @@ public:
 };
 
 
+class ND_FuentesPyramidElement
+   : public VectorFiniteElement, public FuentesPyramid
+{
+private:
+   static const real_t tk[27];
+
+   mutable real_t zmax;
+
+#ifndef MFEM_THREAD_SAFE
+   mutable DenseMatrix tmp_E_E_ij;
+   mutable DenseMatrix tmp_dE_E_ij;
+   mutable DenseTensor tmp_E_Q1_ijk;
+   mutable DenseTensor tmp_dE_Q1_ijk;
+   mutable DenseTensor tmp_E_Q2_ijk;
+   mutable DenseTensor tmp_dE_Q2_ijk;
+   mutable DenseTensor tmp_E_T_ijk;
+   mutable DenseTensor tmp_dE_T_ijk;
+   mutable DenseMatrix tmp_phi_Q1_ij;
+   mutable DenseTensor tmp_dphi_Q1_ij;
+   mutable DenseMatrix tmp_phi_Q2_ij;
+   mutable DenseTensor tmp_dphi_Q2_ij;
+   mutable Vector      tmp_phi_E_i;
+   mutable DenseMatrix tmp_dphi_E_i;
+   mutable DenseMatrix u;
+   mutable DenseMatrix curlu;
+#endif
+   Array<int> dof2tk;
+   DenseMatrixInverse Ti;
+
+   ND_PyramidDofTransformation doftrans;
+
+   void calcBasis(const int p, const IntegrationPoint & ip,
+                  DenseMatrix & E_E_ik,
+                  DenseTensor & E_Q1_ijk,
+                  DenseTensor & E_Q2_ijk,
+                  DenseTensor & E_T_ijk,
+                  DenseMatrix & phi_Q1_ij,
+                  DenseTensor & dphi_Q1_ij,
+                  DenseMatrix & phi_Q2_ij,
+                  Vector      & phi_E_k,
+                  DenseMatrix & dphi_E_k,
+                  DenseMatrix & W) const;
+
+   void calcCurlBasis(const int p, const IntegrationPoint & ip,
+                      DenseMatrix & E_E_ik,
+                      DenseMatrix & dE_E_ik,
+                      DenseTensor & E_Q1_ijk,
+                      DenseTensor & dE_Q1_ijk,
+                      DenseTensor & E_Q2_ijk,
+                      DenseTensor & dE_Q2_ijk,
+                      DenseTensor & E_T_ijk,
+                      DenseTensor & dE_T_ijk,
+                      DenseMatrix & phi_Q2_ij,
+                      DenseTensor & dphi_Q2_ij,
+                      Vector      & phi_E_k,
+                      DenseMatrix & dphi_E_k,
+                      DenseMatrix & dW) const;
+
+public:
+   ND_FuentesPyramidElement(const int p,
+                            const int cb_type = BasisType::GaussLobatto,
+                            const int ob_type = BasisType::GaussLegendre);
+   virtual void CalcVShape(const IntegrationPoint &ip,
+                           DenseMatrix &shape) const;
+   virtual void CalcVShape(ElementTransformation &Trans,
+                           DenseMatrix &shape) const
+   { CalcVShape_ND(Trans, shape); }
+   virtual void CalcCurlShape(const IntegrationPoint &ip,
+                              DenseMatrix &curl_shape) const;
+   virtual void GetLocalInterpolation(ElementTransformation &Trans,
+                                      DenseMatrix &I) const
+   { LocalInterpolation_ND(*this, tk, dof2tk, Trans, I); }
+   virtual void GetLocalRestriction(ElementTransformation &Trans,
+                                    DenseMatrix &R) const
+   { LocalRestriction_ND(tk, dof2tk, Trans, R); }
+   virtual void GetTransferMatrix(const FiniteElement &fe,
+                                  ElementTransformation &Trans,
+                                  DenseMatrix &I) const
+   { LocalInterpolation_ND(CheckVectorFE(fe), tk, dof2tk, Trans, I); }
+
+   using FiniteElement::Project;
+
+   virtual void Project(VectorCoefficient &vc,
+                        ElementTransformation &Trans, Vector &dofs) const
+   { Project_ND(tk, dof2tk, vc, Trans, dofs); }
+   virtual void ProjectMatrixCoefficient(
+      MatrixCoefficient &mc, ElementTransformation &T, Vector &dofs) const
+   { ProjectMatrixCoefficient_ND(tk, dof2tk, mc, T, dofs); }
+   virtual void Project(const FiniteElement &fe, ElementTransformation &Trans,
+                        DenseMatrix &I) const
+   { Project_ND(tk, dof2tk, fe, Trans, I); }
+
+   virtual void ProjectGrad(const FiniteElement &fe,
+                            ElementTransformation &Trans,
+                            DenseMatrix &grad) const
+   { ProjectGrad_ND(tk, dof2tk, fe, Trans, grad); }
+
+   virtual void ProjectCurl(const FiniteElement &fe,
+                            ElementTransformation &Trans,
+                            DenseMatrix &curl) const
+   { ProjectCurl_ND(tk, dof2tk, fe, Trans, curl); }
+
+   void CalcRawVShape(const IntegrationPoint &ip,
+                      DenseMatrix &shape) const;
+
+   void CalcRawCurlShape(const IntegrationPoint &ip,
+                         DenseMatrix &dshape) const;
+
+   real_t GetZetaMax() const { return zmax; }
+};
+
+
 /// A 0D Nedelec finite element for the boundary of a 1D domain
 /** ND_R1D_PointElement provides a representation of the trace of a three
     component Nedelec basis restricted to 1D.
diff --git a/fem/fe/fe_pos.cpp b/fem/fe/fe_pos.cpp
index 56c3c0e28..7dec7a86a 100644
--- a/fem/fe/fe_pos.cpp
+++ b/fem/fe/fe_pos.cpp
@@ -1042,6 +1042,435 @@ void H1Pos_WedgeElement::CalcDShape(const IntegrationPoint &ip,
    }
 }
 
+H1Pos_PyramidElement::H1Pos_PyramidElement(const int p)
+   : PositiveFiniteElement(3, Geometry::PYRAMID,
+                           ((p + 1)*(p + 2)*(2 * p + 3))/6, p,
+                           FunctionSpace::Uk),
+     nterms(((p + 1)*(p + 2)*(p + 3)*(p + 4))/24)
+{
+#ifndef MFEM_THREAD_SAFE
+   m_shape_1d.SetSize(order + 1);
+   m_shape.SetSize(nterms);
+   m_dshape.SetSize(nterms, dim);
+#endif
+
+   Index idx;
+
+   // vertices
+   dof_map[idx(p,0,0,0,0)] = 0;
+   Nodes.IntPoint(0).Set3(0., 0., 0.);
+   dof_map[idx(0,p,0,0,0)] = 1;
+   Nodes.IntPoint(1).Set3(1., 0., 0.);
+   dof_map[idx(0,0,p,0,0)] = 2;
+   Nodes.IntPoint(2).Set3(1., 1., 0.);
+   dof_map[idx(0,0,0,p,0)] = 3;
+   Nodes.IntPoint(3).Set3(0., 1., 0.);
+   dof_map[idx(0,0,0,0,p)] = 4;
+   Nodes.IntPoint(4).Set3(0., 0., 1.);
+
+   // edges (see Geometry::Constants<Geometry::PYRAMID>::Edges
+   // in fem/geom.cpp)
+   int o = 5;
+   for (int i = 1; i < p; i++)  // (0,1)
+   {
+      dof_map[idx(p-i,i,0,0,0)] = o;
+      Nodes.IntPoint(o++).Set3(real_t(i)/p, 0., 0.);
+   }
+   for (int i = 1; i < p; i++)  // (1,2)
+   {
+      dof_map[idx(0,p-i,i,0,0)] = o;
+      Nodes.IntPoint(o++).Set3(1.0, real_t(i)/p, 0.);
+   }
+   for (int i = 1; i < p; i++)  // (3,2)
+   {
+      dof_map[idx(0,0,i,p-i,0)] = o;
+      Nodes.IntPoint(o++).Set3(real_t(i)/p, 1., 0.);
+   }
+   for (int i = 1; i < p; i++)  // (0,3)
+   {
+      dof_map[idx(p-i,0,0,i,0)] = o;
+      Nodes.IntPoint(o++).Set3(0., real_t(i)/p, 0.);
+   }
+   for (int i = 1; i < p; i++)  // (0,4)
+   {
+      dof_map[idx(p-i,0,0,0,i)] = o;
+      Nodes.IntPoint(o++).Set3(0., 0., real_t(i)/p);
+   }
+   for (int i = 1; i < p; i++)  // (1,4)
+   {
+      dof_map[idx(0,p-i,0,0,i)] = o;
+      Nodes.IntPoint(o++).Set3(real_t(p-i)/p, 0., real_t(i)/p);
+   }
+   for (int i = 1; i < p; i++)  // (2,4)
+   {
+      dof_map[idx(0,0,p-i,0,i)] = o;
+      Nodes.IntPoint(o++).Set3(real_t(p-i)/p, real_t(p-i)/p, real_t(i)/p);
+   }
+   for (int i = 1; i < p; i++)  // (3,4)
+   {
+      dof_map[idx(0,0,0,p-i,i)] = o;
+      Nodes.IntPoint(o++).Set3(0., real_t(p-i)/p, real_t(i)/p);
+   }
+
+   // faces (see Geometry::Constants<Geometry::PYRAMID>::FaceVert
+   // in fem/geom.cpp)
+   for (int j = 1; j < p; j++)
+   {
+      int i1 = j;
+      int i2 = 0;
+      int i3 = 0;
+      int i4 = p - j;
+      const int i5 = 0;
+
+      for (int i = 1; i <= p - j; i++)  // (3,2,1,0)
+      {
+         i3++;
+         i4--;
+         dof_map[idx(i1,i2,i3,i4,i5)] = o;
+         Nodes.IntPoint(o++).Set3(real_t(i)/p, real_t(p-j)/p, 0);
+      }
+      for (int i = p - j + 1; i < p; i++)  // (3,2,1,0)
+      {
+         i1--;
+         i2++;
+         dof_map[idx(i1,i2,i3,i4,i5)] = o;
+         Nodes.IntPoint(o++).Set3(real_t(i)/p, real_t(p-j)/p, 0);
+      }
+   }
+   for (int j = 1; j < p; j++)
+      for (int i = 1; i + j < p; i++)  // (0, 1, 4)
+      {
+         dof_map[idx(p-i-j,i,0,0,j)] = o;
+         Nodes.IntPoint(o++).Set3(real_t(i)/p, 0., real_t(j)/p);
+      }
+   for (int j = 1; j < p; j++)
+      for (int i = 1; i + j < p; i++)  // (1, 2, 4)
+      {
+         dof_map[idx(0,p-i-j,i,0,j)] = o;
+         Nodes.IntPoint(o++).Set3(real_t(p-j)/p, real_t(i)/p, real_t(j)/p);
+      }
+   for (int j = 1; j < p; j++)
+      for (int i = 1; i + j < p; i++)  // (2, 3, 4)
+      {
+         dof_map[idx(0,0,p-i-j,i,j)] = o;
+         Nodes.IntPoint(o++).Set3(real_t(p-i-j)/p, real_t(p-j)/p, real_t(j)/p);
+      }
+   for (int j = 1; j < p; j++)
+      for (int i = 1; i + j < p; i++)  // (3, 0, 4)
+      {
+         dof_map[idx(i,0,0,p-i-j,j)] = o;
+         Nodes.IntPoint(o++).Set3(0., real_t(p-i-j)/p, real_t(j)/p);
+      }
+
+   // interior
+   for (int k = 1; k < p; k++)
+      for (int j = 1; j + k < p; j++)
+      {
+         int i1 = p - j - k;
+         int i2 = 0;
+         int i3 = 0;
+         int i4 = j;
+         const int i5 = k;
+
+         for (int i = 1; i <= j; i++)
+         {
+            i3++;
+            i4--;
+            dof_map[idx(i1,i2,i3,i4,i5)] = o;
+            Nodes.IntPoint(o++).Set3(real_t(i)/p, real_t(j)/p, 0);
+         }
+         for (int i = j + 1; i + k < p; i++)
+         {
+            i1--;
+            i2++;
+            dof_map[idx(i1,i2,i3,i4,i5)] = o;
+            Nodes.IntPoint(o++).Set3(real_t(i)/p, real_t(j)/p, 0);
+         }
+      }
+}
+
+// static method
+void H1Pos_PyramidElement::CalcShape(const int p, const real_t x,
+                                     const real_t y, const real_t z,
+                                     real_t *shape_1d,
+                                     real_t *shape)
+{
+   const int lshape = ((p + 1)*(p + 2)*(p + 3)*(p + 4))/24;
+   for (int i=0; i<lshape; i++) { shape[i] = 0.0; }
+
+   const real_t l1 = lam1(x, y, z);
+   const real_t l2 = lam2(x, y, z);
+   const real_t l3 = lam3(x, y, z);
+   const real_t l4 = lam4(x, y, z);
+   const real_t l5 = lam5(x, y, z);
+
+   // The basis functions are the terms in the expansion:
+   //   (l1 + l2 + l3 + l4 + l5)^p =
+   //      \sum_{l=0}^p \binom{p}{l} l5^l
+   //         \sum_{k=0}^{p-l} \binom{p-l}{k} l4^k
+   //            \sum_{j=0}^{p-l-k} \binom{p-l-k}{j} l3^j
+   //               \sum_{i=0}^{p-l-k-j} \binom{p-l-k-j}{i} l2^i l1^{p-l-k-j-i}
+   Index idx;
+   const int *bp = Poly_1D::Binom(p);
+   real_t l5i5 = 1.;
+   for (int i5 = 0; i5 <= p; i5++)
+   {
+      const int *bpi5 = Poly_1D::Binom(p - i5);
+      const real_t ei5 = bp[i5]*l5i5;
+      real_t l4i4 = 1.;
+      for (int i4 = 0; i4 <= p - i5; i4++)
+      {
+         const int *bpi45 = Poly_1D::Binom(p - i5 - i4);
+         const real_t ei45 = ei5*bpi5[i4]*l4i4;
+         real_t l3i3 = 1.;
+         for (int i3 = 0; i3 <= p - i5 - i4; i3++)
+         {
+            Poly_1D::CalcBinomTerms(p - i5 - i4 - i3, l2, l1, shape_1d);
+            real_t ei345 = ei45*bpi45[i3]*l3i3;
+            for (int i2 = 0; i2 <= p - i5 - i4 - i3; i2++)
+            {
+               const int i1 = p - i5 - i4 - i3 - i2;
+               const int o = idx(i1,i2,i3,i4,i5);
+               shape_1d[i2] *= ei345;
+               shape[o] += shape_1d[i2];
+            }
+            l3i3 *= l3;
+         }
+         l4i4 *= l4;
+      }
+      l5i5 *= l5;
+   }
+}
+
+// static method
+void H1Pos_PyramidElement::CalcDShape(const int p, const real_t x,
+                                      const real_t y, const real_t z,
+                                      real_t *dshape_1d, real_t *dshape)
+{
+   const int nterms = ((p + 1)*(p + 2)*(p + 3)*(p + 4))/24;
+   for (int i=0; i<3*nterms; i++) { dshape[i] = 0.0; }
+
+   const real_t l1 = lam1(x, y, z);
+   const real_t l2 = lam2(x, y, z);
+   const real_t l3 = lam3(x, y, z);
+   const real_t l4 = lam4(x, y, z);
+   const real_t l5 = lam5(x, y, z);
+
+   const Vector dl1 = grad_lam1(x, y, z);
+   const Vector dl2 = grad_lam2(x, y, z);
+   const Vector dl3 = grad_lam3(x, y, z);
+   const Vector dl4 = grad_lam4(x, y, z);
+   const Vector dl5 = grad_lam5(x, y, z);
+
+   // The basis functions are the terms in the expansion:
+   //   (l1 + l2 + l3 + l4 + l5)^p
+   // We will compute the derivative by first computing the derivatives
+   // of these terms w.r.t each of the l1, l2, l3, l4, and l5 and summing
+   // the results together.
+   Index idx;
+
+   // Derivative w.r.t. l1 times grad(l1)
+   const int *bp = Poly_1D::Binom(p);
+   real_t l5i5 = 1.;
+   for (int i5 = 0; i5 <= p; i5++)
+   {
+      const int *bpi5 = Poly_1D::Binom(p - i5);
+      const real_t ei5 = bp[i5]*l5i5;
+      real_t l4i4 = 1.;
+      for (int i4 = 0; i4 <= p - i5; i4++)
+      {
+         const int *bpi45 = Poly_1D::Binom(p - i5 - i4);
+         const real_t ei45 = ei5*bpi5[i4]*l4i4;
+         real_t l3i3 = 1.;
+         for (int i3 = 0; i3 <= p - i5 - i4; i3++)
+         {
+            Poly_1D::CalcDyBinomTerms(p - i5 - i4 - i3, l2, l1, dshape_1d);
+            real_t ei345 = ei45*bpi45[i3]*l3i3;
+            for (int i2 = 0; i2 <= p - i5 - i4 - i3; i2++)
+            {
+               const int i1 = p - i5 - i4 - i3 - i2;
+               const int o = idx(i1,i2,i3,i4,i5);
+               const real_t dshape_dl1 = dshape_1d[i2]*ei345;
+               for (int d = 0; d < 3; d++)
+               {
+                  dshape[o + d * nterms] += dshape_dl1 * dl1[d];
+               }
+            }
+            l3i3 *= l3;
+         }
+         l4i4 *= l4;
+      }
+      l5i5 *= l5;
+   }
+
+   // Derivative w.r.t. l2 times grad(l2)
+   l5i5 = 1.;
+   for (int i5 = 0; i5 <= p; i5++)
+   {
+      const int *bpi5 = Poly_1D::Binom(p - i5);
+      const real_t ei5 = bp[i5]*l5i5;
+      real_t l4i4 = 1.;
+      for (int i4 = 0; i4 <= p - i5; i4++)
+      {
+         const int *bpi45 = Poly_1D::Binom(p - i5 - i4);
+         const real_t ei45 = ei5*bpi5[i4]*l4i4;
+         real_t l3i3 = 1.;
+         for (int i3 = 0; i3 <= p - i5 - i4; i3++)
+         {
+            Poly_1D::CalcDxBinomTerms(p - i5 - i4 - i3, l2, l1, dshape_1d);
+            real_t ei345 = ei45*bpi45[i3]*l3i3;
+            for (int i2 = 0; i2 <= p - i5 - i4 - i3; i2++)
+            {
+               const int i1 = p - i5 - i4 - i3 - i2;
+               const int o = idx(i1,i2,i3,i4,i5);
+               const real_t dshape_dl2 = dshape_1d[i2]*ei345;
+               for (int d = 0; d < 3; d++)
+               {
+                  dshape[o + d * nterms] += dshape_dl2*dl2[d];
+               }
+            }
+            l3i3 *= l3;
+         }
+         l4i4 *= l4;
+      }
+      l5i5 *= l5;
+   }
+
+   // Derivative w.r.t. l3 times grad(l3)
+   l5i5 = 1.;
+   for (int i5 = 0; i5 <= p; i5++)
+   {
+      const int *bpi5 = Poly_1D::Binom(p - i5);
+      const real_t ei5 = bp[i5]*l5i5;
+      real_t l4i4 = 1.;
+      for (int i4 = 0; i4 <= p - i5; i4++)
+      {
+         const int *bpi45 = Poly_1D::Binom(p - i5 - i4);
+         const real_t ei45 = ei5*bpi5[i4]*l4i4;
+         real_t l3i3 = 1.;
+         for (int i3 = 1; i3 <= p - i5 - i4; i3++)
+         {
+            Poly_1D::CalcBinomTerms(p - i5 - i4 - i3, l2, l1, dshape_1d);
+            real_t ei345 = i3*ei45*bpi45[i3]*l3i3;
+            for (int i2 = 0; i2 <= p - i5 - i4 - i3; i2++)
+            {
+               const int i1 = p - i5 - i4 - i3 - i2;
+               const int o = idx(i1,i2,i3,i4,i5);
+               const real_t dshape_dl3 = dshape_1d[i2]*ei345;
+               for (int d = 0; d < 3; d++)
+               {
+                  dshape[o + d * nterms] += dshape_dl3*dl3[d];
+               }
+            }
+            l3i3 *= l3;
+         }
+         l4i4 *= l4;
+      }
+      l5i5 *= l5;
+   }
+
+   // Derivative w.r.t. l4 times grad(l4)
+   l5i5 = 1.;
+   for (int i5 = 0; i5 <= p; i5++)
+   {
+      const int *bpi5 = Poly_1D::Binom(p - i5);
+      const real_t ei5 = bp[i5]*l5i5;
+      real_t l4i4 = 1.;
+      for (int i4 = 1; i4 <= p - i5; i4++)
+      {
+         const int *bpi45 = Poly_1D::Binom(p - i5 - i4);
+         const real_t ei45 = i4*ei5*bpi5[i4]*l4i4;
+         real_t l3i3 = 1.;
+         for (int i3 = 0; i3 <= p - i5 - i4; i3++)
+         {
+            Poly_1D::CalcBinomTerms(p - i5 - i4 - i3, l2, l1, dshape_1d);
+            real_t ei345 = ei45*bpi45[i3]*l3i3;
+            for (int i2 = 0; i2 <= p - i5 - i4 - i3; i2++)
+            {
+               const int i1 = p - i5 - i4 - i3 - i2;
+               const int o = idx(i1,i2,i3,i4,i5);
+               const real_t dshape_dl4 = dshape_1d[i2]*ei345;
+               for (int d = 0; d < 3; d++)
+               {
+                  dshape[o + d * nterms] += dshape_dl4*dl4[d];
+               }
+            }
+            l3i3 *= l3;
+         }
+         l4i4 *= l4;
+      }
+      l5i5 *= l5;
+   }
+
+   // Derivative w.r.t. l5 times grad(l5)
+   l5i5 = 1.;
+   for (int i5 = 1; i5 <= p; i5++)
+   {
+      const int *bpi5 = Poly_1D::Binom(p - i5);
+      const real_t ei5 = i5*bp[i5]*l5i5;
+      real_t l4i4 = 1.;
+      for (int i4 = 0; i4 <= p - i5; i4++)
+      {
+         const int *bpi45 = Poly_1D::Binom(p - i5 - i4);
+         const real_t ei45 = ei5*bpi5[i4]*l4i4;
+         real_t l3i3 = 1.;
+         for (int i3 = 0; i3 <= p - i5 - i4; i3++)
+         {
+            Poly_1D::CalcBinomTerms(p - i5 - i4 - i3, l2, l1, dshape_1d);
+            real_t ei345 = ei45*bpi45[i3]*l3i3;
+            for (int i2 = 0; i2 <= p - i5 - i4 - i3; i2++)
+            {
+               const int i1 = p - i5 - i4 - i3 - i2;
+               const int o = idx(i1,i2,i3,i4,i5);
+               const real_t dshape_dl5 = dshape_1d[i2]*ei345;
+               for (int d = 0; d < 3; d++)
+               {
+                  dshape[o + d * nterms] += dshape_dl5*dl5[d];
+               }
+            }
+            l3i3 *= l3;
+         }
+         l4i4 *= l4;
+      }
+      l5i5 *= l5;
+   }
+}
+
+void H1Pos_PyramidElement::CalcShape(const IntegrationPoint &ip,
+                                     Vector &shape) const
+{
+#ifdef MFEM_THREAD_SAFE
+   Vector m_shape_1d(order + 1);
+   Vector m_shape(nterms);
+#endif
+
+   CalcShape(order, ip.x, ip.y, ip.z, m_shape_1d.GetData(), m_shape.GetData());
+
+   for (auto const& it : dof_map)
+   {
+      if (it.first < m_shape.Size()) { shape[it.second] = m_shape[it.first]; }
+   }
+}
+
+void H1Pos_PyramidElement::CalcDShape(const IntegrationPoint &ip,
+                                      DenseMatrix &dshape) const
+{
+#ifdef MFEM_THREAD_SAFE
+   Vector m_shape_1d(order + 1);
+   DenseMatrix m_dshape(nterms, 3);
+#endif
+
+   CalcDShape(order, ip.x, ip.y, ip.z,
+              m_shape_1d.GetData(), m_dshape.GetData());
+
+   for (auto const& it : dof_map)
+      for (int d=0; d<3; d++)
+      {
+         dshape(it.second, d) = m_dshape(it.first, d);
+      }
+
+}
+
 L2Pos_SegmentElement::L2Pos_SegmentElement(const int p)
    : PositiveTensorFiniteElement(1, p, L2_DOF_MAP)
 {
@@ -1448,4 +1877,327 @@ void L2Pos_WedgeElement::CalcDShape(const IntegrationPoint &ip,
    }
 }
 
+L2Pos_PyramidElement::L2Pos_PyramidElement(const int p)
+   : PositiveFiniteElement(3, Geometry::PYRAMID,
+                           ((p + 1)*(p + 2)*(2 * p + 3))/6, p,
+                           FunctionSpace::Uk),
+     nterms(((p + 1)*(p + 2)*(p + 3)*(p + 4))/24)
+{
+#ifndef MFEM_THREAD_SAFE
+   m_shape_1d.SetSize(order + 1);
+   m_shape.SetSize(nterms);
+   m_dshape.SetSize(nterms, dim);
+#endif
+
+   Index idx;
+
+   // interior
+   for (int o = 0, k = 0; k <= p; k++)
+      for (int j = 0; j + k <= p; j++)
+      {
+         int i1 = p - j - k;
+         int i2 = 0;
+         int i3 = -1;
+         int i4 = j + 1;
+         const int i5 = k;
+
+         for (int i = 0; i <= j; i++)
+         {
+            i3++;
+            i4--;
+            dof_map[idx(i1,i2,i3,i4,i5)] = o;
+            Nodes.IntPoint(o++).Set3(real_t(i)/p, real_t(j)/p, 0);
+         }
+         for (int i = j + 1; i + k <= p; i++)
+         {
+            i1--;
+            i2++;
+            dof_map[idx(i1,i2,i3,i4,i5)] = o;
+            Nodes.IntPoint(o++).Set3(real_t(i)/p, real_t(j)/p, 0);
+         }
+      }
+}
+
+// static method
+void L2Pos_PyramidElement::CalcShape(const int p, const real_t x,
+                                     const real_t y, const real_t z,
+                                     real_t *shape_1d,
+                                     real_t *shape)
+{
+   const int lshape = ((p + 1)*(p + 2)*(p + 3)*(p + 4))/24;
+   for (int i=0; i<lshape; i++) { shape[i] = 0.0; }
+
+   const real_t l1 = lam1(x, y, z);
+   const real_t l2 = lam2(x, y, z);
+   const real_t l3 = lam3(x, y, z);
+   const real_t l4 = lam4(x, y, z);
+   const real_t l5 = lam5(x, y, z);
+
+   // The basis functions are the terms in the expansion:
+   //   (l1 + l2 + l3 + l4 + l5)^p =
+   //      \sum_{l=0}^p \binom{p}{l} l5^l
+   //         \sum_{k=0}^{p-l} \binom{p-l}{k} l4^k
+   //            \sum_{j=0}^{p-l-k} \binom{p-l-k}{j} l3^j
+   //               \sum_{i=0}^{p-l-k-j} \binom{p-l-k-j}{i} l2^i l1^{p-l-k-j-i}
+   Index idx;
+   const int *bp = Poly_1D::Binom(p);
+   real_t l5i5 = 1.;
+   for (int i5 = 0; i5 <= p; i5++)
+   {
+      const int *bpi5 = Poly_1D::Binom(p - i5);
+      const real_t ei5 = bp[i5]*l5i5;
+      real_t l4i4 = 1.;
+      for (int i4 = 0; i4 <= p - i5; i4++)
+      {
+         const int *bpi45 = Poly_1D::Binom(p - i5 - i4);
+         const real_t ei45 = ei5*bpi5[i4]*l4i4;
+         real_t l3i3 = 1.;
+         for (int i3 = 0; i3 <= p - i5 - i4; i3++)
+         {
+            Poly_1D::CalcBinomTerms(p - i5 - i4 - i3, l2, l1, shape_1d);
+            real_t ei345 = ei45*bpi45[i3]*l3i3;
+            for (int i2 = 0; i2 <= p - i5 - i4 - i3; i2++)
+            {
+               const int i1 = p - i5 - i4 - i3 - i2;
+               const int o = idx(i1,i2,i3,i4,i5);
+               shape_1d[i2] *= ei345;
+               shape[o] += shape_1d[i2];
+            }
+            l3i3 *= l3;
+         }
+         l4i4 *= l4;
+      }
+      l5i5 *= l5;
+   }
+}
+
+// static method
+void L2Pos_PyramidElement::CalcDShape(const int p, const real_t x,
+                                      const real_t y, const real_t z,
+                                      real_t *dshape_1d, real_t *dshape)
+{
+   const int nterms = ((p + 1)*(p + 2)*(p + 3)*(p + 4))/24;
+   for (int i=0; i<3*nterms; i++) { dshape[i] = 0.0; }
+
+   const real_t l1 = lam1(x, y, z);
+   const real_t l2 = lam2(x, y, z);
+   const real_t l3 = lam3(x, y, z);
+   const real_t l4 = lam4(x, y, z);
+   const real_t l5 = lam5(x, y, z);
+
+   const Vector dl1 = grad_lam1(x, y, z);
+   const Vector dl2 = grad_lam2(x, y, z);
+   const Vector dl3 = grad_lam3(x, y, z);
+   const Vector dl4 = grad_lam4(x, y, z);
+   const Vector dl5 = grad_lam5(x, y, z);
+
+   // The basis functions are the terms in the expansion:
+   //   (l1 + l2 + l3 + l4 + l5)^p
+   // We will compute the derivative by first computing the derivatives
+   // of these terms w.r.t each of the l1, l2, l3, l4, and l5 and summing
+   // the results together.
+   Index idx;
+
+   // Derivative w.r.t. l1 times grad(l1)
+   const int *bp = Poly_1D::Binom(p);
+   real_t l5i5 = 1.;
+   for (int i5 = 0; i5 <= p; i5++)
+   {
+      const int *bpi5 = Poly_1D::Binom(p - i5);
+      const real_t ei5 = bp[i5]*l5i5;
+      real_t l4i4 = 1.;
+      for (int i4 = 0; i4 <= p - i5; i4++)
+      {
+         const int *bpi45 = Poly_1D::Binom(p - i5 - i4);
+         const real_t ei45 = ei5*bpi5[i4]*l4i4;
+         real_t l3i3 = 1.;
+         for (int i3 = 0; i3 <= p - i5 - i4; i3++)
+         {
+            Poly_1D::CalcDyBinomTerms(p - i5 - i4 - i3, l2, l1, dshape_1d);
+            real_t ei345 = ei45*bpi45[i3]*l3i3;
+            for (int i2 = 0; i2 <= p - i5 - i4 - i3; i2++)
+            {
+               const int i1 = p - i5 - i4 - i3 - i2;
+               const int o = idx(i1,i2,i3,i4,i5);
+               const real_t dshape_dl1 = dshape_1d[i2]*ei345;
+               for (int d = 0; d < 3; d++)
+               {
+                  dshape[o + d * nterms] += dshape_dl1 * dl1[d];
+               }
+            }
+            l3i3 *= l3;
+         }
+         l4i4 *= l4;
+      }
+      l5i5 *= l5;
+   }
+
+   // Derivative w.r.t. l2 times grad(l2)
+   l5i5 = 1.;
+   for (int i5 = 0; i5 <= p; i5++)
+   {
+      const int *bpi5 = Poly_1D::Binom(p - i5);
+      const real_t ei5 = bp[i5]*l5i5;
+      real_t l4i4 = 1.;
+      for (int i4 = 0; i4 <= p - i5; i4++)
+      {
+         const int *bpi45 = Poly_1D::Binom(p - i5 - i4);
+         const real_t ei45 = ei5*bpi5[i4]*l4i4;
+         real_t l3i3 = 1.;
+         for (int i3 = 0; i3 <= p - i5 - i4; i3++)
+         {
+            Poly_1D::CalcDxBinomTerms(p - i5 - i4 - i3, l2, l1, dshape_1d);
+            real_t ei345 = ei45*bpi45[i3]*l3i3;
+            for (int i2 = 0; i2 <= p - i5 - i4 - i3; i2++)
+            {
+               const int i1 = p - i5 - i4 - i3 - i2;
+               const int o = idx(i1,i2,i3,i4,i5);
+               const real_t dshape_dl2 = dshape_1d[i2]*ei345;
+               for (int d = 0; d < 3; d++)
+               {
+                  dshape[o + d * nterms] += dshape_dl2*dl2[d];
+               }
+            }
+            l3i3 *= l3;
+         }
+         l4i4 *= l4;
+      }
+      l5i5 *= l5;
+   }
+
+   // Derivative w.r.t. l3 times grad(l3)
+   l5i5 = 1.;
+   for (int i5 = 0; i5 <= p; i5++)
+   {
+      const int *bpi5 = Poly_1D::Binom(p - i5);
+      const real_t ei5 = bp[i5]*l5i5;
+      real_t l4i4 = 1.;
+      for (int i4 = 0; i4 <= p - i5; i4++)
+      {
+         const int *bpi45 = Poly_1D::Binom(p - i5 - i4);
+         const real_t ei45 = ei5*bpi5[i4]*l4i4;
+         real_t l3i3 = 1.;
+         for (int i3 = 1; i3 <= p - i5 - i4; i3++)
+         {
+            Poly_1D::CalcBinomTerms(p - i5 - i4 - i3, l2, l1, dshape_1d);
+            real_t ei345 = i3*ei45*bpi45[i3]*l3i3;
+            for (int i2 = 0; i2 <= p - i5 - i4 - i3; i2++)
+            {
+               const int i1 = p - i5 - i4 - i3 - i2;
+               const int o = idx(i1,i2,i3,i4,i5);
+               const real_t dshape_dl3 = dshape_1d[i2]*ei345;
+               for (int d = 0; d < 3; d++)
+               {
+                  dshape[o + d * nterms] += dshape_dl3*dl3[d];
+               }
+            }
+            l3i3 *= l3;
+         }
+         l4i4 *= l4;
+      }
+      l5i5 *= l5;
+   }
+
+   // Derivative w.r.t. l4 times grad(l4)
+   l5i5 = 1.;
+   for (int i5 = 0; i5 <= p; i5++)
+   {
+      const int *bpi5 = Poly_1D::Binom(p - i5);
+      const real_t ei5 = bp[i5]*l5i5;
+      real_t l4i4 = 1.;
+      for (int i4 = 1; i4 <= p - i5; i4++)
+      {
+         const int *bpi45 = Poly_1D::Binom(p - i5 - i4);
+         const real_t ei45 = i4*ei5*bpi5[i4]*l4i4;
+         real_t l3i3 = 1.;
+         for (int i3 = 0; i3 <= p - i5 - i4; i3++)
+         {
+            Poly_1D::CalcBinomTerms(p - i5 - i4 - i3, l2, l1, dshape_1d);
+            real_t ei345 = ei45*bpi45[i3]*l3i3;
+            for (int i2 = 0; i2 <= p - i5 - i4 - i3; i2++)
+            {
+               const int i1 = p - i5 - i4 - i3 - i2;
+               const int o = idx(i1,i2,i3,i4,i5);
+               const real_t dshape_dl4 = dshape_1d[i2]*ei345;
+               for (int d = 0; d < 3; d++)
+               {
+                  dshape[o + d * nterms] += dshape_dl4*dl4[d];
+               }
+            }
+            l3i3 *= l3;
+         }
+         l4i4 *= l4;
+      }
+      l5i5 *= l5;
+   }
+
+   // Derivative w.r.t. l5 times grad(l5)
+   l5i5 = 1.;
+   for (int i5 = 1; i5 <= p; i5++)
+   {
+      const int *bpi5 = Poly_1D::Binom(p - i5);
+      const real_t ei5 = i5*bp[i5]*l5i5;
+      real_t l4i4 = 1.;
+      for (int i4 = 0; i4 <= p - i5; i4++)
+      {
+         const int *bpi45 = Poly_1D::Binom(p - i5 - i4);
+         const real_t ei45 = ei5*bpi5[i4]*l4i4;
+         real_t l3i3 = 1.;
+         for (int i3 = 0; i3 <= p - i5 - i4; i3++)
+         {
+            Poly_1D::CalcBinomTerms(p - i5 - i4 - i3, l2, l1, dshape_1d);
+            real_t ei345 = ei45*bpi45[i3]*l3i3;
+            for (int i2 = 0; i2 <= p - i5 - i4 - i3; i2++)
+            {
+               const int i1 = p - i5 - i4 - i3 - i2;
+               const int o = idx(i1,i2,i3,i4,i5);
+               const real_t dshape_dl5 = dshape_1d[i2]*ei345;
+               for (int d = 0; d < 3; d++)
+               {
+                  dshape[o + d * nterms] += dshape_dl5*dl5[d];
+               }
+            }
+            l3i3 *= l3;
+         }
+         l4i4 *= l4;
+      }
+      l5i5 *= l5;
+   }
+}
+
+void L2Pos_PyramidElement::CalcShape(const IntegrationPoint &ip,
+                                     Vector &shape) const
+{
+#ifdef MFEM_THREAD_SAFE
+   Vector m_shape_1d(order + 1);
+   Vector m_shape(nterms);
+#endif
+
+   CalcShape(order, ip.x, ip.y, ip.z, m_shape_1d.GetData(), m_shape.GetData());
+
+   for (auto const& it : dof_map)
+   {
+      if (it.first < m_shape.Size()) { shape[it.second] = m_shape[it.first]; }
+   }
+}
+
+void L2Pos_PyramidElement::CalcDShape(const IntegrationPoint &ip,
+                                      DenseMatrix &dshape) const
+{
+#ifdef MFEM_THREAD_SAFE
+   Vector m_shape_1d(order + 1);
+   DenseMatrix m_dshape(nterms, 3);
+#endif
+
+   CalcDShape(order, ip.x, ip.y, ip.z,
+              m_shape_1d.GetData(), m_dshape.GetData());
+
+   for (auto const& it : dof_map)
+      for (int d=0; d<3; d++)
+      {
+         dshape(it.second, d) = m_dshape(it.first, d);
+      }
+
+}
+
 }
diff --git a/fem/fe/fe_pos.hpp b/fem/fe/fe_pos.hpp
index d3c4c972c..29e477335 100644
--- a/fem/fe/fe_pos.hpp
+++ b/fem/fe/fe_pos.hpp
@@ -13,6 +13,7 @@
 #define MFEM_FE_POS
 
 #include "fe_base.hpp"
+#include "fe_pyramid.hpp"
 
 namespace mfem
 {
@@ -256,6 +257,62 @@ public:
 };
 
 
+/// Arbitrary order H1 elements in 3D utilizing the Bernstein basis on a pyramid
+class H1Pos_PyramidElement : public PositiveFiniteElement, FuentesPyramid
+{
+protected:
+   const int nterms;
+#ifndef MFEM_THREAD_SAFE
+   mutable Vector m_shape_1d;
+   mutable Vector m_shape;
+   mutable DenseMatrix m_dshape;
+#endif
+   std::map<int,int> dof_map;
+
+   struct Index
+   {
+      Index() = default;
+      int operator()(int i1, int i2, int i3, int i4, int i5)
+      {
+         const int p = i1 + i2 + i3 + i4 + i5;
+         const int min24 = std::min(i2,i4);
+         i1 += min24;
+         i2 -= min24;
+         i3 += min24;
+         i4 -= min24;
+         return i2 + i3 * (p - i4 - i5) - i4 * i5 * (p + 2)
+                - ((i3 - 3) * i3) / 2 + i4 * ((p + 1) * (p + 2)) / 2
+                + (i4 * i5 * (i4 + i5)) / 2 + ((i4 - 1) * i4 * (i4 +1)) / 6
+                - (p + 2) * ((i4 - 1) * i4) / 2
+                + (i5 * (5 + 2 * p - i5) * (i5 * i5 - i5 * (5 + 2 * p)
+                                            + 2 * (5 + 5 * p + p * p))) / 24;
+      }
+   };
+
+public:
+   /// Construct the H1Pos_PyramidElement of order @a p
+   H1Pos_PyramidElement(const int p);
+
+   // The size of shape is (p+1)(p+2)(p+3)(p+4)/24.
+   // The size of shape_1d should be at least p+1.
+   static void CalcShape(const int p, const real_t x, const real_t y,
+                         const real_t z, real_t *shape_1d, real_t *shape);
+
+   // The size of dshape is (p+1)(p+2)(p+3)(p+4)/24 by 3.
+   // The size of dshape_1d should be at least p+1.
+   static void CalcDShape(const int p, const real_t x, const real_t y,
+                          const real_t z, real_t *dshape_1d, real_t *dshape);
+
+   virtual void CalcShape(const IntegrationPoint &ip, Vector &shape) const;
+   virtual void CalcDShape(const IntegrationPoint &ip,
+                           DenseMatrix &dshape) const;
+
+   // Returns (p+1)(p+2)(p+3)(p+4)/24 which is the size of the temporary arrays
+   // needed above
+   int GetNumTerms() const { return nterms; }
+};
+
+
 /// Arbitrary order L2 elements in 1D utilizing the Bernstein basis on a segment
 class L2Pos_SegmentElement : public PositiveTensorFiniteElement
 {
@@ -369,6 +426,61 @@ public:
                    DenseMatrix &dshape) const override;
 };
 
+/// Arbitrary order L2 elements in 3D utilizing the Bernstein basis on a pyramid
+class L2Pos_PyramidElement : public PositiveFiniteElement, FuentesPyramid
+{
+protected:
+   const int nterms;
+#ifndef MFEM_THREAD_SAFE
+   mutable Vector m_shape_1d;
+   mutable Vector m_shape;
+   mutable DenseMatrix m_dshape;
+#endif
+   std::map<int,int> dof_map;
+
+   struct Index
+   {
+      Index() = default;
+      int operator()(int i1, int i2, int i3, int i4, int i5)
+      {
+         const int p = i1 + i2 + i3 + i4 + i5;
+         const int min24 = std::min(i2,i4);
+         i1 += min24;
+         i2 -= min24;
+         i3 += min24;
+         i4 -= min24;
+         return i2 + i3 * (p - i4 - i5) - i4 * i5 * (p + 2)
+                - ((i3 - 3) * i3) / 2 + i4 * ((p + 1) * (p + 2)) / 2
+                + (i4 * i5 * (i4 + i5)) / 2 + ((i4 - 1) * i4 * (i4 +1)) / 6
+                - (p + 2) * ((i4 - 1) * i4) / 2
+                + (i5 * (5 + 2 * p - i5) * (i5 * i5 - i5 * (5 + 2 * p)
+                                            + 2 * (5 + 5 * p + p * p))) / 24;
+      }
+   };
+
+   // Returns (p+1)(p+2)(p+3)(p+4)/24 which is the size of the temporary arrays
+   // needed below
+   int GetNumTerms() const { return nterms; }
+
+   // The size of shape is (p+1)(p+2)(p+3)(p+4)/24.
+   // The size of shape_1d should be at least p+1.
+   static void CalcShape(const int p, const real_t x, const real_t y,
+                         const real_t z, real_t *shape_1d, real_t *shape);
+
+   // The size of dshape is (p+1)(p+2)(p+3)(p+4)/24 by 3.
+   // The size of dshape_1d should be at least p+1.
+   static void CalcDShape(const int p, const real_t x, const real_t y,
+                          const real_t z, real_t *dshape_1d, real_t *dshape);
+
+public:
+   /// Construct the L2Pos_PyramidElement of order @a p
+   L2Pos_PyramidElement(const int p);
+
+   virtual void CalcShape(const IntegrationPoint &ip, Vector &shape) const;
+   virtual void CalcDShape(const IntegrationPoint &ip,
+                           DenseMatrix &dshape) const;
+};
+
 } // namespace mfem
 
 #endif
diff --git a/fem/fe/fe_pyramid.cpp b/fem/fe/fe_pyramid.cpp
new file mode 100644
index 000000000..7d1e5a8c6
--- /dev/null
+++ b/fem/fe/fe_pyramid.cpp
@@ -0,0 +1,1584 @@
+// Copyright (c) 2010-2025, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+// Finite Element classes on Pyramid shaped elements
+
+#include "fe_pyramid.hpp"
+
+namespace mfem
+{
+
+using namespace std;
+
+Vector FuentesPyramid::grad_lam1(real_t x, real_t y, real_t z)
+{
+   return Vector({CheckZ(z) ? - (1.0 - y - z) / (1.0 - z) : -0.5,
+                  CheckZ(z) ? - (1.0 - x - z) / (1.0 - z) : -0.5,
+                  CheckZ(z) ? x * y / ((1.0 - z) * (1.0 - z)) - 1.0 : -0.75});
+}
+
+Vector FuentesPyramid::grad_lam2(real_t x, real_t y, real_t z)
+{
+   return Vector({CheckZ(z) ? (1.0 - y - z) / (1.0 - z) : 0.5,
+                  CheckZ(z) ? - x / (1.0 - z) : -0.5,
+                  CheckZ(z) ? - x * y / ((1.0 - z) * (1.0 - z)) : -0.25});
+}
+
+Vector FuentesPyramid::grad_lam3(real_t x, real_t y, real_t z)
+{
+   return Vector({CheckZ(z) ? y / (1.0 - z) : 0.5,
+                  CheckZ(z) ? x / (1.0 - z) : 0.5,
+                  CheckZ(z) ? x * y / ((1.0 - z) * (1.0 - z)) : 0.25});
+}
+
+Vector FuentesPyramid::grad_lam4(real_t x, real_t y, real_t z)
+{
+   return Vector({CheckZ(z) ? - y / (1.0 - z) : -0.5,
+                  CheckZ(z) ? (1.0 - x - z) / (1.0 - z) : 0.5,
+                  CheckZ(z) ? - x * y / ((1.0 - z) * (1.0 - z)) : -0.25});
+}
+
+Vector FuentesPyramid::grad_lam5(real_t x, real_t y, real_t z)
+{
+   return Vector({0.0, 0.0, 1.0});
+}
+
+DenseMatrix FuentesPyramid::grad_lam15(real_t x, real_t y, real_t z)
+{
+   DenseMatrix dlam(2, 3);
+   dlam.SetRow(0, grad_lam1(x, y, z));
+   dlam.SetRow(1, grad_lam5(x, y, z));
+   return dlam;
+}
+
+DenseMatrix FuentesPyramid::grad_lam25(real_t x, real_t y, real_t z)
+{
+   DenseMatrix dlam(2, 3);
+   dlam.SetRow(0, grad_lam2(x, y, z));
+   dlam.SetRow(1, grad_lam5(x, y, z));
+   return dlam;
+}
+
+DenseMatrix FuentesPyramid::grad_lam35(real_t x, real_t y, real_t z)
+{
+   DenseMatrix dlam(2, 3);
+   dlam.SetRow(0, grad_lam3(x, y, z));
+   dlam.SetRow(1, grad_lam5(x, y, z));
+   return dlam;
+}
+
+DenseMatrix FuentesPyramid::grad_lam45(real_t x, real_t y, real_t z)
+{
+   DenseMatrix dlam(2, 3);
+   dlam.SetRow(0, grad_lam4(x, y, z));
+   dlam.SetRow(1, grad_lam5(x, y, z));
+   return dlam;
+}
+
+Vector FuentesPyramid::lam15_grad_lam15(real_t x, real_t y, real_t z)
+{
+   Vector lam = lam15(x, y, z);
+   Vector lamdlam(3);
+   add(lam(0), grad_lam5(x, y, z), -lam(1), grad_lam1(x, y, z), lamdlam);
+   return lamdlam;
+}
+
+Vector FuentesPyramid::lam25_grad_lam25(real_t x, real_t y, real_t z)
+{
+   Vector lam = lam25(x, y, z);
+   Vector lamdlam(3);
+   add(lam(0), grad_lam5(x, y, z), -lam(1), grad_lam2(x, y, z), lamdlam);
+   return lamdlam;
+}
+
+Vector FuentesPyramid::lam35_grad_lam35(real_t x, real_t y, real_t z)
+{
+   Vector lam = lam35(x, y, z);
+   Vector lamdlam(3);
+   add(lam(0), grad_lam5(x, y, z), -lam(1), grad_lam3(x, y, z), lamdlam);
+   return lamdlam;
+}
+
+Vector FuentesPyramid::lam45_grad_lam45(real_t x, real_t y, real_t z)
+{
+   Vector lam = lam45(x, y, z);
+   Vector lamdlam(3);
+   add(lam(0), grad_lam5(x, y, z), -lam(1), grad_lam4(x, y, z), lamdlam);
+   return lamdlam;
+}
+
+Vector FuentesPyramid::lam125_grad_lam125(real_t x, real_t y, real_t z)
+{
+   Vector lgl({-x * z / (one - z), y - one, z});
+   lgl *= (one - y - z) / (one - z);
+   return lgl;
+}
+
+Vector FuentesPyramid::lam235_grad_lam235(real_t x, real_t y, real_t z)
+{
+   Vector lgl({x, -y * z / (one - z), z});
+   lgl *= x / (one - z);
+   return lgl;
+}
+
+Vector FuentesPyramid::lam345_grad_lam345(real_t x, real_t y, real_t z)
+{
+   Vector lgl({-x * z / (one - z), y, z});
+   lgl *= y / (one - z);
+   return lgl;
+}
+
+Vector FuentesPyramid::lam435_grad_lam435(real_t x, real_t y, real_t z)
+{
+   Vector lgl({x * z / (one - z), -y, -z});
+   lgl *= y / (one - z);
+   return lgl;
+}
+
+Vector FuentesPyramid::lam415_grad_lam415(real_t x, real_t y, real_t z)
+{
+   Vector lgl({x - one, -y * z / (one - z), z});
+   lgl *= (one - x - z) / (one - z);
+   return lgl;
+}
+
+Vector FuentesPyramid::lam145_grad_lam145(real_t x, real_t y, real_t z)
+{
+   Vector lgl({one - x, y * z / (one - z), -z});
+   lgl *= (one - x - z) / (one - z);
+   return lgl;
+}
+
+real_t FuentesPyramid::div_lam125_grad_lam125(real_t x, real_t y, real_t z)
+{ return (1.0 - z - y) / (1.0 - z); }
+
+real_t FuentesPyramid::div_lam235_grad_lam235(real_t x, real_t y, real_t z)
+{ return x / (1.0 - z); }
+
+real_t FuentesPyramid::div_lam345_grad_lam345(real_t x, real_t y, real_t z)
+{ return y / (1.0 - z); }
+
+real_t FuentesPyramid::div_lam435_grad_lam435(real_t x, real_t y, real_t z)
+{ return -y / (1.0 - z); }
+
+real_t FuentesPyramid::div_lam415_grad_lam415(real_t x, real_t y, real_t z)
+{ return (1.0 - z - x) / (1.0 - z); }
+
+real_t FuentesPyramid::div_lam145_grad_lam145(real_t x, real_t y, real_t z)
+{ return -(1.0 - z - x) / (1.0 - z); }
+
+DenseMatrix FuentesPyramid::grad_mu01(real_t z)
+{
+   DenseMatrix dmu(2, 3);
+   dmu.SetRow(0, grad_mu0(z));
+   dmu.SetRow(1, grad_mu1(z));
+   return dmu;
+}
+
+Vector FuentesPyramid::grad_mu0(real_t z, const Vector xy, unsigned int ab)
+{
+   Vector dmu({0.0, 0.0, - xy[ab-1] / pow(1.0 - z, 2)});
+   dmu[ab-1] = -1.0 / (1.0 - z);
+   return dmu;
+}
+
+Vector FuentesPyramid::grad_mu1(real_t z, const Vector xy, unsigned int ab)
+{
+   Vector dmu({0.0, 0.0, xy[ab-1] / pow(1.0 - z, 2)});
+   dmu[ab-1] = 1.0 / (1.0 - z);
+   return dmu;
+}
+
+DenseMatrix FuentesPyramid::grad_mu01(real_t z, Vector xy, unsigned int ab)
+{
+   DenseMatrix dmu(2, 3);
+   dmu.SetRow(0, grad_mu0(z, xy, ab));
+   dmu.SetRow(1, grad_mu1(z, xy, ab));
+   return dmu;
+}
+
+Vector FuentesPyramid::mu01_grad_mu01(real_t z, Vector xy, unsigned int ab)
+{
+   Vector mu = mu01(z, xy, ab);
+   Vector mudmu(3);
+   add(mu(0), grad_mu1(z, xy, ab), -mu(1), grad_mu0(z, xy, ab), mudmu);
+   return mudmu;
+}
+
+Vector FuentesPyramid::grad_nu0(real_t z, const Vector xy, unsigned int ab)
+{
+   Vector dnu({0.0, 0.0, -1.0}); dnu[ab-1] = -1.0;
+   return dnu;
+}
+
+Vector FuentesPyramid::grad_nu1(real_t z, const Vector xy, unsigned int ab)
+{
+   Vector dnu({0.0, 0.0, 0.0}); dnu[ab-1] = 1.0;
+   return dnu;
+}
+
+Vector FuentesPyramid::grad_nu2(real_t z, const Vector xy, unsigned int ab)
+{
+   return Vector({0.0, 0.0, 1.0});
+}
+
+DenseMatrix FuentesPyramid::grad_nu01(real_t z, Vector xy, unsigned int ab)
+{
+   DenseMatrix dnu(2, 3);
+   dnu.SetRow(0, grad_nu0(z, xy, ab));
+   dnu.SetRow(1, grad_nu1(z, xy, ab));
+   return dnu;
+}
+
+DenseMatrix FuentesPyramid::grad_nu012(real_t z, Vector xy, unsigned int ab)
+{
+   DenseMatrix dnu(3, 3);
+   dnu.SetRow(0, grad_nu0(z, xy, ab));
+   dnu.SetRow(1, grad_nu1(z, xy, ab));
+   dnu.SetRow(2, grad_nu2(z, xy, ab));
+   return dnu;
+}
+
+DenseMatrix FuentesPyramid::grad_nu120(real_t z, Vector xy, unsigned int ab)
+{
+   DenseMatrix dnu(3, 3);
+   dnu.SetRow(0, grad_nu1(z, xy, ab));
+   dnu.SetRow(1, grad_nu2(z, xy, ab));
+   dnu.SetRow(2, grad_nu0(z, xy, ab));
+   return dnu;
+}
+
+Vector FuentesPyramid::nu01_grad_nu01(real_t z, Vector xy, unsigned int ab)
+{
+   Vector nu = nu01(z, xy, ab);
+   Vector nudnu(3);
+   add(nu(0), grad_nu1(z, xy, ab), -nu(1), grad_nu0(z, xy, ab), nudnu);
+   return nudnu;
+}
+
+Vector FuentesPyramid::nu12_grad_nu12(real_t z, Vector xy, unsigned int ab)
+{
+   Vector nu = nu12(z, xy, ab);
+   Vector nudnu(3);
+   add(nu(0), grad_nu2(z, xy, ab), -nu(1), grad_nu1(z, xy, ab), nudnu);
+   return nudnu;
+}
+
+Vector FuentesPyramid::nu012_grad_nu012(real_t z, Vector xy, unsigned int ab)
+{
+   Vector nu(nu012(z, xy, ab));
+   Vector dnu0(grad_nu0(z, xy, ab));
+   Vector dnu1(grad_nu1(z, xy, ab));
+   Vector dnu2(grad_nu2(z, xy, ab));
+
+   Vector v01(3), v12(3), v20(3);
+   dnu0.cross3D(dnu1, v01);
+   dnu1.cross3D(dnu2, v12);
+   dnu2.cross3D(dnu0, v20);
+
+   Vector nudnu(3);
+   add(nu(0), v12, nu(1), v20, nudnu);
+   nudnu.Add(nu(2), v01);
+   return nudnu;
+}
+
+void FuentesPyramid::CalcScaledLegendre(int p, real_t x, real_t t,
+                                        real_t *u)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   if (t > 0.0)
+   {
+      Poly_1D::CalcLegendre(p, x / t, u);
+      for (int i = 1; i <= p; i++)
+      {
+         u[i] *= pow(t, i);
+      }
+   }
+   else
+   {
+      // This assumes x = 0 as well as t = 0 since x \in [0,t]
+      u[0] = 1.0;
+      for (int i = 1; i <= p; i++) { u[i] = 0.0; }
+   }
+}
+
+void FuentesPyramid::CalcScaledLegendre(int p, real_t x, real_t t,
+                                        real_t *u,
+                                        real_t *dudx, real_t *dudt)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   if (t > 0.0)
+   {
+      Poly_1D::CalcLegendre(p, x / t, u, dudx);
+      dudx[0] = 0.0;
+      dudt[0] = - dudx[0] * x / t;
+      for (int i = 1; i <= p; i++)
+      {
+         u[i]    *= pow(t, i);
+         dudx[i] *= pow(t, i - 1);
+         dudt[i]  = (u[i] * i - dudx[i] * x) / t;
+      }
+   }
+   else
+   {
+      // This assumes x = 0 as well as t = 0 since x \in [0,t]
+      u[0]    = 1.0;
+      dudx[0] = 0.0;
+      dudt[0] = 0.0;
+      if (p >=1)
+      {
+         u[1]    =  0.0;
+         dudx[1] =  2.0;
+         dudt[1] = -1.0;
+      }
+      for (int i = 2; i <= p; i++)
+      {
+         u[i] = 0.0;
+         dudx[i] = 0.0;
+         dudt[i] = 0.0;
+      }
+   }
+}
+
+void FuentesPyramid::CalcScaledLegendre(int p, real_t x, real_t t,
+                                        Vector &u)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   CalcScaledLegendre(p, x, t, u.GetData());
+}
+
+void FuentesPyramid::CalcScaledLegendre(int p, real_t x, real_t t,
+                                        Vector &u, Vector &dudx, Vector &dudt)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   MFEM_ASSERT(dudx.Size() >= p+1, "Size of dudx is too small");
+   MFEM_ASSERT(dudt.Size() >= p+1, "Size of dudt is too small");
+   CalcScaledLegendre(p, x, t, u.GetData(), dudx.GetData(), dudt.GetData());
+}
+
+void FuentesPyramid::CalcIntegratedLegendre(int p, real_t x, real_t t,
+                                            real_t *u)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   if (t > 0.0)
+   {
+      CalcScaledLegendre(p, x, t, u);
+      for (int i = p; i >= 2; i--)
+      {
+         u[i] = (u[i] - t * t * u[i-2]) / (4.0 * i - 2.0);
+      }
+      if (p >= 1)
+      {
+         u[1] = x;
+      }
+      u[0] = 0.0;
+   }
+   else
+   {
+      for (int i = 0; i <= p; i++)
+      {
+         u[i] = 0.0;
+      }
+   }
+}
+
+void FuentesPyramid::CalcIntegratedLegendre(int p, real_t x, real_t t,
+                                            real_t *u,
+                                            real_t *dudx, real_t *dudt)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   if (t > 0.0)
+   {
+      CalcScaledLegendre(p, x, t, u, dudx, dudt);
+      for (int i = p; i >= 2; i--)
+      {
+         u[i] = (u[i] - t * t * u[i-2]) / (4.0 * i - 2.0);
+         dudx[i] = (dudx[i] - t * t * dudx[i-2]) / (4.0 * i - 2.0);
+         dudt[i] = (dudt[i] - t * t * dudt[i-2] - 2.0 * t * u[i-2]) /
+                   (4.0 * i - 2.0);
+      }
+      if (p >= 1)
+      {
+         u[1] = x; dudx[1] = 1.0; dudt[1] = 0.0;
+      }
+      u[0] = 0.0; dudx[0] = 0.0; dudt[0] = 0.0;
+   }
+   else
+   {
+      for (int i = 0; i <= p; i++)
+      {
+         u[i] = 0.0;
+         dudx[i] = 0.0;
+         dudt[i] = 0.0;
+      }
+   }
+}
+
+void FuentesPyramid::CalcIntegratedLegendre(int p, real_t x,
+                                            real_t t, Vector &u)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   CalcIntegratedLegendre(p, x, t, u.GetData());
+}
+
+void FuentesPyramid::CalcIntegratedLegendre(int p, real_t x,
+                                            real_t t, Vector &u,
+                                            Vector &dudx, Vector &dudt)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   MFEM_ASSERT(dudx.Size() >= p+1, "Size of dudx is too small");
+   MFEM_ASSERT(dudt.Size() >= p+1, "Size of dudt is too small");
+   CalcIntegratedLegendre(p, x, t, u.GetData(),
+                          dudx.GetData(), dudt.GetData());
+}
+
+void FuentesPyramid::CalcHomogenizedScaLegendre(int p, real_t s0, real_t s1,
+                                                real_t *u)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   CalcScaledLegendre(p, s1, s0 + s1, u);
+}
+
+void FuentesPyramid::CalcHomogenizedScaLegendre(int p,
+                                                real_t s0, real_t s1,
+                                                real_t *u,
+                                                real_t *duds0, real_t *duds1)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   CalcScaledLegendre(p, s1, s0+s1, u, duds1, duds0);
+   for (int i = 0; i <= p; i++) { duds1[i] += duds0[i]; }
+}
+
+void FuentesPyramid::CalcHomogenizedScaLegendre(int p, real_t s0, real_t s1,
+                                                Vector &u)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   CalcHomogenizedScaLegendre(p, s0, s1, u.GetData());
+}
+
+void FuentesPyramid::CalcHomogenizedScaLegendre(int p,
+                                                real_t s0, real_t s1,
+                                                Vector &u,
+                                                Vector &duds0, Vector &duds1)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   MFEM_ASSERT(duds0.Size() >= p+1, "Size of duds0 is too small");
+   MFEM_ASSERT(duds1.Size() >= p+1, "Size of duds1 is too small");
+   CalcHomogenizedScaLegendre(p, s0, s1, u.GetData(),
+                              duds0.GetData(), duds1.GetData());
+}
+
+void FuentesPyramid::CalcHomogenizedIntLegendre(int p,
+                                                real_t t0, real_t t1,
+                                                real_t *u)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   CalcIntegratedLegendre(p, t1, t0 + t1, u);
+}
+
+void FuentesPyramid::CalcHomogenizedIntLegendre(int p,
+                                                real_t t0, real_t t1,
+                                                real_t *u,
+                                                real_t *dudt0, real_t *dudt1)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   CalcIntegratedLegendre(p, t1, t0+t1, u, dudt1, dudt0);
+   for (int i = 0; i <= p; i++) { dudt1[i] += dudt0[i]; }
+}
+
+void FuentesPyramid::CalcHomogenizedIntLegendre(int p,
+                                                real_t t0, real_t t1,
+                                                Vector &u)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   CalcHomogenizedIntLegendre(p, t0, t1, u.GetData());
+}
+
+void FuentesPyramid::CalcHomogenizedIntLegendre(int p,
+                                                real_t t0, real_t t1,
+                                                Vector &u,
+                                                Vector &dudt0, Vector &dudt1)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   MFEM_ASSERT(dudt0.Size() >= p+1, "Size of dudt0 is too small");
+   MFEM_ASSERT(dudt1.Size() >= p+1, "Size of dudt1 is too small");
+   CalcHomogenizedIntLegendre(p, t0, t1, u.GetData(),
+                              dudt0.GetData(), dudt1.GetData());
+}
+
+void FuentesPyramid::CalcIntegratedJacobi(int p, real_t alpha,
+                                          real_t x, real_t t,
+                                          real_t *u)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   if (t > 0.0)
+   {
+      CalcScaledJacobi(p, alpha, x, t, u);
+      for (int i = p; i >= 2; i--)
+      {
+         real_t d0 = 2.0 * i + alpha;
+         real_t d1 = d0 - 1.0;
+         real_t d2 = d0 - 2.0;
+         real_t a = (alpha + i) / (d0 * d1);
+         real_t b = alpha / (d0 * d2);
+         real_t c = (real_t)(i - 1) / (d1 * d2);
+         u[i] = a * u[i] + b * t * u[i - 1] - c * t * t * u[i - 2];
+      }
+      if (p >= 1)
+      {
+         u[1] = x;
+      }
+      u[0] = 0.0;
+   }
+   else
+   {
+      u[0] = 1.0;
+      for (int i = 1; i <= p; i++)
+      {
+         u[i] = 0.0;
+      }
+   }
+}
+
+void FuentesPyramid::CalcIntegratedJacobi(int p, real_t alpha,
+                                          real_t x, real_t t,
+                                          real_t *u,
+                                          real_t *dudx,
+                                          real_t *dudt)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   CalcScaledJacobi(p, alpha, x, t, u, dudx, dudt);
+   for (int i = p; i >= 2; i--)
+   {
+      real_t d0 = 2.0 * i + alpha;
+      real_t d1 = d0 - 1.0;
+      real_t d2 = d0 - 2.0;
+      real_t a = (alpha + i) / (d0 * d1);
+      real_t b = alpha / (d0 * d2);
+      real_t c = (real_t)(i - 1) / (d1 * d2);
+      u[i]    = a * u[i] + b * t * u[i - 1] - c * t * t * u[i - 2];
+      dudx[i] = a * dudx[i] + b * t * dudx[i - 1] - c * t * t * dudx[i - 2];
+      dudt[i] = a * dudt[i] + b * t * dudt[i - 1] + b * u[i - 1]
+                - c * t * t * dudt[i - 2] - 2.0 * c * t * u[i - 2];
+   }
+   if (p >= 1)
+   {
+      u[1]    = x;
+      dudx[1] = 1.0;
+      dudt[1] = 0.0;
+   }
+   u[0]    = 0.0;
+   dudx[0] = 0.0;
+   dudt[0] = 0.0;
+}
+
+void FuentesPyramid::CalcScaledJacobi(int p, real_t alpha,
+                                      real_t x, real_t t,
+                                      real_t *u)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+
+   u[0] = 1.0;
+   if (p >= 1)
+   {
+      u[1] = (2.0 + alpha) * x - t;
+   }
+   for (int i = 2; i <= p; i++)
+   {
+      real_t a = 2.0 * i * (alpha + i) * (2.0 * i + alpha - 2.0);
+      real_t b = 2.0 * i + alpha - 1.0;
+      real_t c = (2.0 * i + alpha) * (2.0 * i + alpha - 2.0);
+      real_t d = 2.0 * (alpha + i - 1.0) * (i - 1) * (2.0 * i + alpha);
+      u[i] = (b * (c * (2.0 * x - t) + alpha * alpha * t) * u[i - 1]
+              - d * t * t * u[i - 2]) / a;
+   }
+}
+
+void FuentesPyramid::CalcScaledJacobi(int p, real_t alpha,
+                                      real_t x, real_t t,
+                                      real_t *u, real_t *dudx, real_t *dudt)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+
+   u[0]    = 1.0;
+   dudx[0] = 0.0;
+   dudt[0] = 0.0;
+   if (p >= 1)
+   {
+      u[1]    = (2.0 + alpha) * x - t;
+      dudx[1] =  2.0 + alpha;
+      dudt[1] = -1.0;
+   }
+   for (int i = 2; i <= p; i++)
+   {
+      real_t a = 2.0 * i * (alpha + i) * (2.0 * i + alpha - 2.0);
+      real_t b = 2.0 * i + alpha - 1.0;
+      real_t c = (2.0 * i + alpha) * (2.0 * i + alpha - 2.0);
+      real_t d = 2.0 * (alpha + i - 1.0) * (i - 1) * (2.0 * i + alpha);
+      u[i] = (b * (c * (2.0 * x - t) + alpha * alpha * t) * u[i - 1]
+              - d * t * t * u[i - 2]) / a;
+      dudx[i] = (b * ((c * (2.0 * x - t) + alpha * alpha * t) * dudx[i - 1] +
+                      2.0 * c * u[i - 1])
+                 - d * t * t * dudx[i - 2]) / a;
+      dudt[i] = (b * ((c * (2.0 * x - t) + alpha * alpha * t) * dudt[i - 1] +
+                      (alpha * alpha - c) * u[i - 1])
+                 - d * t * t * dudt[i - 2] - 2.0 * d * t * u[i - 2]) / a;
+   }
+}
+
+void FuentesPyramid::CalcScaledJacobi(int p, real_t alpha,
+                                      real_t x, real_t t,
+                                      Vector &u)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   CalcScaledJacobi(p, alpha, x, t, u.GetData());
+}
+
+void FuentesPyramid::CalcScaledJacobi(int p, real_t alpha,
+                                      real_t x, real_t t,
+                                      Vector &u, Vector &dudx, Vector &dudt)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   MFEM_ASSERT(dudx.Size() >= p+1, "Size of dudx is too small");
+   MFEM_ASSERT(dudt.Size() >= p+1, "Size of dudt is too small");
+   CalcScaledJacobi(p, alpha, x, t, u.GetData(),
+                    dudx.GetData(), dudt.GetData());
+}
+
+void FuentesPyramid::CalcHomogenizedScaJacobi(int p, real_t alpha,
+                                              real_t t0, real_t t1,
+                                              real_t *u,
+                                              real_t *dudt0, real_t *dudt1)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   CalcScaledJacobi(p, alpha, t1, t0+t1, u, dudt1, dudt0);
+   for (int i = 0; i <= p; i++) { dudt1[i] += dudt0[i]; }
+}
+
+void FuentesPyramid::CalcHomogenizedScaJacobi(int p, real_t alpha,
+                                              real_t t0, real_t t1,
+                                              Vector &u)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   CalcHomogenizedScaJacobi(p, alpha, t0, t1, u.GetData());
+}
+
+void FuentesPyramid::CalcHomogenizedScaJacobi(int p, real_t alpha,
+                                              real_t t0, real_t t1,
+                                              Vector &u,
+                                              Vector &dudt0, Vector &dudt1)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   MFEM_ASSERT(dudt0.Size() >= p+1, "Size of dudt0 is too small");
+   MFEM_ASSERT(dudt1.Size() >= p+1, "Size of dudt1 is too small");
+   CalcHomogenizedScaJacobi(p, alpha, t0, t1, u.GetData(),
+                            dudt0.GetData(), dudt1.GetData());
+}
+
+void FuentesPyramid::CalcHomogenizedIntJacobi(int p, real_t alpha,
+                                              real_t t0, real_t t1,
+                                              real_t *u,
+                                              real_t *dudt0, real_t *dudt1)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   CalcIntegratedJacobi(p, alpha, t1, t0+t1, u, dudt1, dudt0);
+   for (int i = 0; i <= p; i++) { dudt1[i] += dudt0[i]; }
+}
+
+void FuentesPyramid::CalcHomogenizedIntJacobi(int p, real_t alpha,
+                                              real_t t0, real_t t1,
+                                              Vector &u)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   CalcHomogenizedIntJacobi(p, alpha, t0, t1, u.GetData());
+}
+
+void FuentesPyramid::CalcHomogenizedIntJacobi(int p, real_t alpha,
+                                              real_t t0, real_t t1,
+                                              Vector &u,
+                                              Vector &dudt0, Vector &dudt1)
+{
+   MFEM_ASSERT(p >= 0, "Polynomial order must be zero or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   MFEM_ASSERT(dudt0.Size() >= p+1, "Size of dudt0 is too small");
+   MFEM_ASSERT(dudt1.Size() >= p+1, "Size of dudt1 is too small");
+   CalcHomogenizedIntJacobi(p, alpha, t0, t1, u.GetData(),
+                            dudt0.GetData(), dudt1.GetData());
+}
+
+void FuentesPyramid::phi_E(int p, real_t s0, real_t s1,
+                           real_t *u)
+{
+   MFEM_ASSERT(p >= 2, "Polynomial order must be two or larger");
+   CalcHomogenizedIntLegendre(p, s0, s1, u);
+}
+
+void FuentesPyramid::phi_E(int p, real_t s0, real_t s1,
+                           real_t *u, real_t *duds0, real_t *duds1)
+{
+   MFEM_ASSERT(p >= 2, "Polynomial order must be two or larger");
+   CalcHomogenizedIntLegendre(p, s0, s1, u, duds0, duds1);
+}
+
+void FuentesPyramid::phi_E(int p, Vector s, Vector &u)
+{
+   MFEM_ASSERT(p >= 2, "Polynomial order must be two or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   phi_E(p, s[0], s[1], u.GetData());
+}
+
+void FuentesPyramid::phi_E(int p, Vector s, Vector &u, DenseMatrix &duds)
+{
+   MFEM_ASSERT(p >= 2, "Polynomial order must be two or larger");
+   MFEM_ASSERT(s.Size() >= 2, "Size of s must be 2 or larger");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   MFEM_ASSERT(duds.Height() >= p+1, "First dimension of duds is too small");
+   MFEM_ASSERT(duds.Width() >= 2,
+               "Second dimension of duds must be 2 or larger");
+   phi_E(p, s[0], s[1], u.GetData(), duds.GetColumn(0), duds.GetColumn(1));
+}
+
+void FuentesPyramid::phi_E(int p, Vector s, const DenseMatrix &grad_s,
+                           Vector &u, DenseMatrix &grad_u) const
+{
+   MFEM_ASSERT(p >= 2, "Polynomial order must be two or larger");
+   MFEM_ASSERT(s.Size() >= 2, "Size of s must be 2 or larger");
+   MFEM_ASSERT(grad_s.Height() >= 2,
+               "First dimension of grad_s must be 2");
+   MFEM_ASSERT(grad_s.Width() >= 3,
+               "Second dimension of grad_s must be 3");
+   MFEM_ASSERT(u.Size() >= p+1, "Size of u is too small");
+   MFEM_ASSERT(grad_u.Height() >= p+1,
+               "First dimension of grad_u is too small");
+   MFEM_ASSERT(grad_u.Width() == grad_s.Width(),
+               "Second dimension of grad_u must match that of grad_s");
+#ifdef MFEM_THREAD_SAFE
+   DenseMatrix phi_E_mtmp;
+#endif
+   DenseMatrix &duds = phi_E_mtmp;
+   duds.SetSize(p + 1, grad_s.Height());
+
+   phi_E(p, s[0], s[1], u.GetData(), duds.GetColumn(0), duds.GetColumn(1));
+   Mult(duds, grad_s, grad_u);
+}
+
+void FuentesPyramid::phi_Q(int p, Vector s, Vector t, DenseMatrix &u) const
+{
+   MFEM_ASSERT(p >= 2, "Polynomial order must be two or larger");
+   MFEM_ASSERT(s.Size() >= 2, "Size of s must be 2 or larger");
+   MFEM_ASSERT(t.Size() >= 2, "Size of t must be 2 or larger");
+   MFEM_ASSERT(u.Height() >= p+1, "First dimension of u is too small");
+   MFEM_ASSERT(u.Width() >= p+1, "Second dimension of u is too small");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector phi_Q_vtmp1;
+   Vector phi_Q_vtmp2;
+#endif
+   Vector &phi_E_i = phi_Q_vtmp1;
+   Vector &phi_E_j = phi_Q_vtmp2;
+
+   phi_E_i.SetSize(p+1);
+   phi_E(p, s, phi_E_i);
+
+   phi_E_j.SetSize(p+1);
+   phi_E(p, t, phi_E_j);
+
+   for (int j=0; j<=p; j++)
+      for (int i=0; i<=p; i++)
+      {
+         u(i,j) = phi_E_i[i] * phi_E_j[j];
+      }
+}
+
+void FuentesPyramid::phi_Q(int p, Vector s, const DenseMatrix &grad_s,
+                           Vector t, const DenseMatrix &grad_t,
+                           DenseMatrix &u, DenseTensor &grad_u) const
+{
+   MFEM_ASSERT(p >= 2, "Polynomial order must be two or larger");
+   MFEM_ASSERT(s.Size() >= 2, "Size of s must be 2 or larger");
+   MFEM_ASSERT(grad_s.Height() >= 2,
+               "First dimension of grad_s must be 2 or larger");
+   MFEM_ASSERT(grad_s.Width() >= 3,
+               "Second dimension of grad_s must be 3 or larger");
+   MFEM_ASSERT(t.Size() >= 2, "Size of t must be 2 or larger");
+   MFEM_ASSERT(grad_t.Height() >= 2,
+               "First dimension of grad_t must be 2 or larger");
+   MFEM_ASSERT(grad_t.Width() >= 3,
+               "Second dimension of grad_t must be 3 or larger");
+   MFEM_ASSERT(u.Height() >= p+1, "First dimension of u is too small");
+   MFEM_ASSERT(u.Width() >= p+1, "First dimension of u is too small");
+   MFEM_ASSERT(grad_u.SizeI() >= p+1,
+               "First dimension of grad_u is too small");
+   MFEM_ASSERT(grad_u.SizeJ() >= p+1,
+               "Second dimension of grad_u is too small");
+   MFEM_ASSERT(grad_u.SizeK() >= 3,
+               "Third dimension of grad_u must be 3 or larger");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector phi_Q_vtmp1;
+   Vector phi_Q_vtmp2;
+   DenseMatrix phi_Q_mtmp1;
+   DenseMatrix phi_Q_mtmp2;
+#endif
+   Vector       &phi_E_i = phi_Q_vtmp1;
+   Vector       &phi_E_j = phi_Q_vtmp2;
+   DenseMatrix &dphi_E_i = phi_Q_mtmp1;
+   DenseMatrix &dphi_E_j = phi_Q_mtmp2;
+
+   phi_E_i.SetSize(p+1);
+   dphi_E_i.SetSize(p+1, grad_s.Width());
+   phi_E(p, s, grad_s, phi_E_i, dphi_E_i);
+
+   phi_E_j.SetSize(p+1);
+   dphi_E_j.SetSize(p+1, grad_t.Width());
+   phi_E(p, t, grad_t, phi_E_j, dphi_E_j);
+
+   for (int j=0; j<=p; j++)
+      for (int i=0; i<=p; i++)
+      {
+         u(i,j) = phi_E_i[i] * phi_E_j[j];
+
+         for (int k=0; k<3; k++)
+            grad_u(i,j,k) =
+               phi_E_i(i) * dphi_E_j(j,k) + dphi_E_i(i,k) * phi_E_j(j);
+      }
+}
+
+void FuentesPyramid::phi_T(int p, Vector s, DenseMatrix &u) const
+{
+   MFEM_ASSERT(p >= 3, "Polynomial order must be three or larger");
+   MFEM_ASSERT(s.Size() >= 3, "Size of s must be 3 or larger");
+   MFEM_ASSERT(u.Height() >= p, "First dimension of u is too small");
+   MFEM_ASSERT(u.Width() >= p-1, "Second dimension of u is too small");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector phi_T_vtmp1;
+   Vector phi_T_vtmp2;
+#endif
+   Vector &phi_E_i = phi_T_vtmp1;
+   Vector &L_j     = phi_T_vtmp2;
+
+   phi_E_i.SetSize(p);
+   phi_E(p-1, s, phi_E_i);
+
+   L_j.SetSize(p-1);
+
+   u = 0.0;
+   for (int i = 2; i < p; i++)
+   {
+      const real_t alpha = 2.0 * i;
+      CalcHomogenizedIntJacobi(p-2, alpha, s[0] + s[1], s[2], L_j);
+
+      for (int j = 1; i + j <= p; j++)
+      {
+         u(i,j) = phi_E_i[i] * L_j[j];
+      }
+   }
+}
+
+void FuentesPyramid::phi_T(int p, Vector s, const DenseMatrix &grad_s,
+                           DenseMatrix &u, DenseTensor &grad_u) const
+{
+   MFEM_ASSERT(p >= 3, "Polynomial order must be three or larger");
+   MFEM_ASSERT(s.Size() >= 3, "Size of s must be 3 or larger");
+   MFEM_ASSERT(grad_s.Height() >= 3,
+               "First dimension of grad_s must be 2 or larger");
+   MFEM_ASSERT(grad_s.Width() >= 3,
+               "Second dimension of grad_s must be 3 or larger");
+   MFEM_ASSERT(u.Height() >= p, "First dimension of u is too small");
+   MFEM_ASSERT(u.Width() >= p-1, "Second dimension of u is too small");
+   MFEM_ASSERT(grad_u.SizeI() >= p,
+               "First dimension of grad_u is too small");
+   MFEM_ASSERT(grad_u.SizeJ() >= p-1,
+               "Second dimension of grad_u is too small");
+   MFEM_ASSERT(grad_u.SizeK() >= 3,
+               "Third dimension of grad_u must be 3 or larger");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector phi_T_vtmp1;
+   Vector phi_T_vtmp2;
+   Vector phi_T_vtmp3;
+   Vector phi_T_vtmp4;
+   DenseMatrix phi_T_mtmp1;
+#endif
+   Vector      &phi_E_i  = phi_T_vtmp1;
+   DenseMatrix &dphi_E_i = phi_T_mtmp1;
+   Vector      &L_j      = phi_T_vtmp2;
+   Vector      &dL_j_dx  = phi_T_vtmp3;
+   Vector      &dL_j_dt  = phi_T_vtmp4;
+
+   phi_E_i.SetSize(p);
+   dphi_E_i.SetSize(p, 3);
+   phi_E(p-1, s, grad_s, phi_E_i, dphi_E_i);
+
+   L_j.SetSize(p-1);
+   dL_j_dx.SetSize(p-1);
+   dL_j_dt.SetSize(p-1);
+
+   u = 0.0;
+   grad_u = 0.0;
+   for (int i = 2; i < p; i++)
+   {
+      const real_t alpha = 2.0 * i;
+      CalcHomogenizedIntJacobi(p-2, alpha, s[0] + s[1], s[2], L_j,
+                               dL_j_dx, dL_j_dt);
+
+      for (int j = 1; i + j <= p; j++)
+      {
+         u(i,j) = phi_E_i[i] * L_j[j];
+
+         for (int d=0; d<3; d++)
+            grad_u(i, j, d) = dphi_E_i(i, d) * L_j[j] +
+                              phi_E_i[i] * (dL_j_dx[j] * (grad_s(0, d) +
+                                                          grad_s(1, d)) +
+                                            dL_j_dt[j] * grad_s(2, d));
+      }
+   }
+}
+
+void FuentesPyramid::E_E(int p, Vector s, Vector sds, DenseMatrix &u) const
+{
+   MFEM_ASSERT(p >= 1, "Polynomial order must be one or larger");
+   MFEM_ASSERT(s.Size() >= 2, "Size of s must be 2 or larger");
+   MFEM_ASSERT(sds.Size() >= 3, "Size of sds must be 3 or larger");
+   MFEM_ASSERT(u.Height() >= p, "First dimension of u is too small");
+   MFEM_ASSERT(u.Width() >= 3, "Second dimension of u must be 3 or larger");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector E_E_vtmp;
+#endif
+   Vector &P_i = E_E_vtmp;
+
+   P_i.SetSize(p);
+   CalcHomogenizedScaLegendre(p - 1, s[0], s[1], P_i);
+   for (int i=0; i<p; i++)
+   {
+      u(i,0) = P_i(i) * sds(0);
+      u(i,1) = P_i(i) * sds(1);
+      u(i,2) = P_i(i) * sds(2);
+   }
+}
+
+void FuentesPyramid::E_E(int p, Vector s, const DenseMatrix &grad_s,
+                         DenseMatrix &u, DenseMatrix &curl_u) const
+{
+   MFEM_ASSERT(p >= 1, "Polynomial order must be one or larger");
+   MFEM_ASSERT(s.Size() >= 2, "Size of s must be 2 or larger");
+   MFEM_ASSERT(grad_s.Height() >= 2,
+               "First dimension of grad_s must be 2 or larger");
+   MFEM_ASSERT(grad_s.Width() >= 3,
+               "Second dimension of grad_s must be 3 or larger");
+   MFEM_ASSERT(u.Height() >= p, "First dimension of u is too small");
+   MFEM_ASSERT(u.Width() >= 3, "Second dimension of u must be 3 or larger");
+   MFEM_ASSERT(curl_u.Height() >= p,
+               "First dimension of curl_u is too small");
+   MFEM_ASSERT(curl_u.Width() >= 3,
+               "Second dimension of curl_u must be 3 or larger");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector E_E_vtmp;
+#endif
+   Vector &P_i = E_E_vtmp;
+
+   P_i.SetSize(p);
+   CalcHomogenizedScaLegendre(p - 1, s[0], s[1], P_i);
+
+   Vector grad_s0({grad_s(0,0), grad_s(0,1), grad_s(0,2)});
+   Vector grad_s1({grad_s(1,0), grad_s(1,1), grad_s(1,2)});
+   Vector sds(3);
+   add(s(0), grad_s1, -s(1), grad_s0, sds);
+
+   Vector dsxds(3);
+   grad_s0.cross3D(grad_s1, dsxds);
+
+   for (int i=0; i<p; i++)
+   {
+      u(i,0) = P_i(i) * sds(0);
+      u(i,1) = P_i(i) * sds(1);
+      u(i,2) = P_i(i) * sds(2);
+
+      curl_u(i, 0) = (i + 2) * P_i(i) * dsxds(0);
+      curl_u(i, 1) = (i + 2) * P_i(i) * dsxds(1);
+      curl_u(i, 2) = (i + 2) * P_i(i) * dsxds(2);
+   }
+}
+
+void FuentesPyramid::E_Q(int p, Vector s, Vector sds, Vector t,
+                         DenseTensor &u) const
+{
+   MFEM_ASSERT(p >= 2, "Polynomial order must be two or larger");
+   MFEM_ASSERT(s.Size() >= 2, "Size of s must be 2 or larger");
+   MFEM_ASSERT(sds.Size() >= 3, "Size of sds must be 3 or larger");
+   MFEM_ASSERT(t.Size() >= 2, "Size of t must be 2 or larger");
+   MFEM_ASSERT(u.SizeI() >= p, "First dimension of u is too small");
+   MFEM_ASSERT(u.SizeJ() >= p+1, "Second dimension of u is too small");
+   MFEM_ASSERT(u.SizeK() >= 3, "Third dimension of u must be 3 or larger");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector      E_Q_vtmp;
+   DenseMatrix E_Q_mtmp1;
+#endif
+
+   DenseMatrix &E_E_i   = E_Q_mtmp1;
+   Vector      &phi_E_j = E_Q_vtmp;
+
+   E_E_i.SetSize(p, 3);
+   E_E(p, s, sds, E_E_i);
+
+   phi_E_j.SetSize(p + 1);
+   phi_E(p, t, phi_E_j);
+
+   for (int k=0; k<3; k++)
+   {
+      u(k).SetCol(0, 0.0);
+      u(k).SetCol(1, 0.0);
+   }
+
+   for (int j=2; j<=p; j++)
+      for (int i=0; i<p; i++)
+         for (int k=0; k<3; k++)
+         {
+            u(i, j, k) = phi_E_j(j) * E_E_i(i, k);
+         }
+}
+
+void FuentesPyramid::E_Q(int p, Vector s, const DenseMatrix &grad_s,
+                         Vector t, const DenseMatrix &grad_t,
+                         DenseTensor &u, DenseTensor &curl_u) const
+{
+   MFEM_ASSERT(p >= 2, "Polynomial order must be two or larger");
+   MFEM_ASSERT(s.Size() >= 2, "Size of s must be 2 or larger");
+   MFEM_ASSERT(grad_s.Height() >= 2,
+               "First dimension of grad_s must be 2");
+   MFEM_ASSERT(grad_s.Width() >= 3,
+               "Second dimension of grad_s must be 3");
+   MFEM_ASSERT(t.Size() >= 2, "Size of t must be 2 or larger");
+   MFEM_ASSERT(grad_t.Height() >= 2,
+               "First dimension of grad_t must be 2");
+   MFEM_ASSERT(grad_t.Width() >= 3,
+               "Second dimension of grad_t must be 3");
+   MFEM_ASSERT(u.SizeI() >= p, "First dimension of u is too small");
+   MFEM_ASSERT(u.SizeJ() >= p+1, "Second dimension of u is too small");
+   MFEM_ASSERT(u.SizeK() >= 3, "Third dimension of u must be 3 or larger");
+   MFEM_ASSERT(curl_u.SizeI() >= p, "First dimension of curl_u is too small");
+   MFEM_ASSERT(curl_u.SizeJ() >= p+1,
+               "Second dimension of curl_u is too small");
+   MFEM_ASSERT(curl_u.SizeK() >= 3,
+               "Third dimension of curl_u must be 3 or larger");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector      E_Q_vtmp;
+   DenseMatrix E_Q_mtmp1;
+   DenseMatrix E_Q_mtmp2;
+   DenseMatrix E_Q_mtmp3;
+#endif
+   Vector      &phi_E_j  = E_Q_vtmp;
+   DenseMatrix &dphi_E_j = E_Q_mtmp1;
+   DenseMatrix &E_E_i    = E_Q_mtmp2;
+   DenseMatrix &dE_E_i   = E_Q_mtmp3;
+
+   phi_E_j.SetSize(p + 1);
+   dphi_E_j.SetSize(p + 1, grad_t.Width());
+   phi_E(p, t, grad_t, phi_E_j, dphi_E_j);
+
+   E_E_i.SetSize(p, 3);
+   dE_E_i.SetSize(p, 3);
+   E_E(p, s, grad_s, E_E_i, dE_E_i);
+
+   for (int k=0; k<3; k++)
+   {
+      u(k).SetCol(0, 0.0);
+      u(k).SetCol(1, 0.0);
+      curl_u(k).SetCol(0, 0.0);
+      curl_u(k).SetCol(1, 0.0);
+   }
+
+   for (int j=2; j<=p; j++)
+      for (int i=0; i<p; i++)
+      {
+         for (int k=0; k<3; k++)
+         {
+            u(i, j, k) = phi_E_j(j) * E_E_i(i, k);
+         }
+
+         curl_u(i, j, 0) = phi_E_j(j) * dE_E_i(i, 0)
+                           + dphi_E_j(j, 1) * E_E_i(i, 2)
+                           - dphi_E_j(j, 2) * E_E_i(i, 1);
+         curl_u(i, j, 1) = phi_E_j(j) * dE_E_i(i, 1)
+                           + dphi_E_j(j, 2) * E_E_i(i, 0)
+                           - dphi_E_j(j, 0) * E_E_i(i, 2);
+         curl_u(i, j, 2) = phi_E_j(j) * dE_E_i(i, 2)
+                           + dphi_E_j(j, 0) * E_E_i(i, 1)
+                           - dphi_E_j(j, 1) * E_E_i(i, 0);
+      }
+}
+
+void FuentesPyramid::E_T(int p, Vector s, Vector sds, DenseTensor &u) const
+{
+   MFEM_ASSERT(p >= 2, "Polynomial order must be two or larger");
+   MFEM_ASSERT(s.Size() >= 3, "Size of s must be 3 or larger");
+   MFEM_ASSERT(sds.Size() >= 3, "Size of sds must be 3 or larger");
+   MFEM_ASSERT(u.SizeI() >= p - 1, "First dimension of u is too small");
+   MFEM_ASSERT(u.SizeJ() >= p, "Second dimension of u is too small");
+   MFEM_ASSERT(u.SizeK() >= 3, "Third dimension of u must be 3 or larger");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector      E_T_vtmp1;
+   DenseMatrix E_T_mtmp1;
+#endif
+   Vector &L_j = E_T_vtmp1;
+   DenseMatrix &E_E_i = E_T_mtmp1;
+
+   E_E_i.SetSize(p - 1, 3);
+   E_E(p - 1, s, sds, E_E_i);
+
+   L_j.SetSize(p);
+   for (int i=0; i<p-1; i++)
+   {
+      const real_t alpha = 2.0 * i + 1.0;
+      CalcHomogenizedIntJacobi(p - 1, alpha, s[0] + s[1], s[2], L_j);
+
+      u(i, 0, 0) = 0.0; u(i, 0, 1) = 0.0; u(i, 0, 2) = 0.0;
+      for (int j=1; i+j<p; j++)
+         for (int k=0; k<3; k++)
+         {
+            u(i, j, k) = L_j(j) * E_E_i(i, k);
+         }
+   }
+}
+
+void FuentesPyramid::E_T(int p, Vector s, const DenseMatrix & grad_s,
+                         DenseTensor &u, DenseTensor &curl_u) const
+{
+   MFEM_ASSERT(p >= 2, "Polynomial order must be two or larger");
+   MFEM_ASSERT(s.Size() >= 3, "Size of s must be 3 or larger");
+   MFEM_ASSERT(grad_s.Height() >= 3,
+               "First dimension of grad_s must be 3");
+   MFEM_ASSERT(grad_s.Width() >= 3,
+               "Second dimension of grad_s must be 3");
+   MFEM_ASSERT(u.SizeI() >= p - 1, "First dimension of u is too small");
+   MFEM_ASSERT(u.SizeJ() >= p, "Second dimension of u is too small");
+   MFEM_ASSERT(u.SizeK() >= 3, "Third dimension of u must be 3 or larger");
+   MFEM_ASSERT(curl_u.SizeI() >= p - 1,
+               "First dimension of curl_u is too small");
+   MFEM_ASSERT(curl_u.SizeJ() >= p,
+               "Second dimension of curl_u is too small");
+   MFEM_ASSERT(curl_u.SizeK() >= 3,
+               "Third dimension of curl_u must be 3 or larger");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector      E_T_vtmp1;
+   Vector      E_T_vtmp2;
+   Vector      E_T_vtmp3;
+   DenseMatrix E_T_mtmp1;
+   DenseMatrix E_T_mtmp2;
+#endif
+   Vector &L_j = E_T_vtmp1;
+   Vector &dL_j_dx = E_T_vtmp2;
+   Vector &dL_j_dt = E_T_vtmp3;
+   DenseMatrix & E_E_i = E_T_mtmp1;
+   DenseMatrix &dE_E_i = E_T_mtmp2;
+
+   Vector dL(3), grad_L(3);
+
+   E_E_i.SetSize(p - 1, 3);
+   dE_E_i.SetSize(p - 1, 3);
+   E_E(p - 1, s, grad_s, E_E_i, dE_E_i);
+
+   L_j.SetSize(p);
+   dL_j_dx.SetSize(p);
+   dL_j_dt.SetSize(p);
+   for (int i=0; i<p-1; i++)
+   {
+      const real_t alpha = 2.0 * i + 1.0;
+      CalcHomogenizedIntJacobi(p - 1, alpha, s[0] + s[1], s[2], L_j,
+                               dL_j_dx, dL_j_dt);
+
+      u(i, 0, 0) = 0.0; u(i, 0, 1) = 0.0; u(i, 0, 2) = 0.0;
+      curl_u(i, 0, 0) = 0.0; curl_u(i, 0, 1) = 0.0; curl_u(i, 0, 2) = 0.0;
+      for (int j=1; i+j<p; j++)
+      {
+         dL(0) = dL_j_dx(j); dL(1) = dL_j_dx(j); dL(2) = dL_j_dt(j);
+
+         grad_s.MultTranspose(dL, grad_L);
+
+         for (int k=0; k<3; k++)
+         {
+            u(i, j, k) = L_j(j) * E_E_i(i, k);
+            curl_u(i, j, k) = L_j(j) * dE_E_i(i, k);
+         }
+         curl_u(i, j, 0) += grad_L(1) * E_E_i(i, 2) - grad_L(2) * E_E_i(i, 1);
+         curl_u(i, j, 1) += grad_L(2) * E_E_i(i, 0) - grad_L(0) * E_E_i(i, 2);
+         curl_u(i, j, 2) += grad_L(0) * E_E_i(i, 1) - grad_L(1) * E_E_i(i, 0);
+      }
+   }
+}
+
+void FuentesPyramid::V_Q(int p, Vector s, Vector sds,
+                         Vector t, Vector tdt, DenseTensor &u) const
+{
+   MFEM_ASSERT(p >= 1, "Polynomial order must be one or larger");
+   MFEM_ASSERT(s.Size() >= 2, "Size of s must be 2 or larger");
+   MFEM_ASSERT(sds.Size() >= 3, "Size of sds must be 3 or larger");
+   MFEM_ASSERT(t.Size() >= 2, "Size of t must be 2 or larger");
+   MFEM_ASSERT(tdt.Size() >= 3, "Size of tdt must be 3 or larger");
+   MFEM_ASSERT(u.SizeI() >= p, "First dimension of u is too small");
+   MFEM_ASSERT(u.SizeJ() >= p, "Second dimension of u is too small");
+   MFEM_ASSERT(u.SizeK() >= 3, "Third dimension of u must be 3 or larger");
+
+#ifdef MFEM_THREAD_SAFE
+   DenseMatrix V_Q_mtmp1;
+   DenseMatrix V_Q_mtmp2;
+#endif
+   DenseMatrix &E_E_i = V_Q_mtmp1;
+   DenseMatrix &E_E_j = V_Q_mtmp2;
+
+   E_E_i.SetSize(p, 3);
+   E_E(p, s, sds, E_E_i);
+
+   E_E_j.SetSize(p, 3);
+   E_E(p, t, tdt, E_E_j);
+
+   for (int j=0; j<p; j++)
+      for (int i=0; i<p; i++)
+      {
+         u(i, j, 0) = E_E_i(i, 1) * E_E_j(j, 2) - E_E_i(i, 2) * E_E_j(j, 1);
+         u(i, j, 1) = E_E_i(i, 2) * E_E_j(j, 0) - E_E_i(i, 0) * E_E_j(j, 2);
+         u(i, j, 2) = E_E_i(i, 0) * E_E_j(j, 1) - E_E_i(i, 1) * E_E_j(j, 0);
+      }
+}
+
+void FuentesPyramid::V_T(int p, Vector s, Vector sdsxds, DenseTensor &u) const
+{
+   MFEM_ASSERT(p >= 1, "Polynomial order must be one or larger");
+   MFEM_ASSERT(s.Size() >= 2, "Size of s must be 2 or larger");
+   MFEM_ASSERT(sdsxds.Size() >= 3, "Size of sdsxds must be 3 or larger");
+   MFEM_ASSERT(u.SizeI() >= p, "First dimension of u is too small");
+   MFEM_ASSERT(u.SizeJ() >= p, "Second dimension of u is too small");
+   MFEM_ASSERT(u.SizeK() >= 3, "Third dimension of u must be 3 or larger");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector V_T_vtmp1;
+   Vector V_T_vtmp2;
+#endif
+   Vector &P_i = V_T_vtmp1;
+   Vector &P_j = V_T_vtmp2;
+
+   P_i.SetSize(p);
+   CalcHomogenizedScaLegendre(p-1, s[0], s[1], P_i);
+
+   P_j.SetSize(p);
+   for (int i=0; i<p; i++)
+   {
+      const real_t alpha = 2.0 * i + 1.0;
+      CalcHomogenizedScaJacobi(p-1, alpha, s[0] + s[1], s[2], P_j);
+      for (int j=0; i + j < p; j++)
+      {
+         const real_t vij = P_i(i) * P_j(j);
+         u(i,j,0) = vij * sdsxds(0);
+         u(i,j,1) = vij * sdsxds(1);
+         u(i,j,2) = vij * sdsxds(2);
+      }
+   }
+}
+
+void FuentesPyramid::V_T(int p, Vector s, Vector sdsxds, real_t dsdsxds,
+                         DenseTensor &u, DenseMatrix &du) const
+{
+   MFEM_ASSERT(p >= 1, "Polynomial order must be one or larger");
+   MFEM_ASSERT(s.Size() >= 2, "Size of s must be 2 or larger");
+   MFEM_ASSERT(sdsxds.Size() >= 3, "Size of sdsxds must be 3 or larger");
+   MFEM_ASSERT(u.SizeI() >= p, "First dimension of u is too small");
+   MFEM_ASSERT(u.SizeJ() >= p, "Second dimension of u is too small");
+   MFEM_ASSERT(u.SizeK() >= 3, "Third dimension of u must be 3 or larger");
+   MFEM_ASSERT(du.Height() >= p, "First dimension of du is too small");
+   MFEM_ASSERT(du.Width() >= p, "Second dimension of du is too small");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector V_T_vtmp1;
+   Vector V_T_vtmp2;
+#endif
+   Vector &P_i = V_T_vtmp1;
+   Vector &P_j = V_T_vtmp2;
+
+   P_i.SetSize(p);
+   CalcHomogenizedScaLegendre(p-1, s[0], s[1], P_i);
+
+   P_j.SetSize(p);
+   for (int i=0; i<p; i++)
+   {
+      const real_t alpha = 2.0 * i + 1.0;
+      CalcHomogenizedScaJacobi(p-1, alpha, s[0] + s[1], s[2], P_j);
+      for (int j=0; i + j < p; j++)
+      {
+         const real_t vij = P_i(i) * P_j(j);
+         u(i,j,0) = vij * sdsxds(0);
+         u(i,j,1) = vij * sdsxds(1);
+         u(i,j,2) = vij * sdsxds(2);
+
+         du(i,j) = (i+j+3) * vij * dsdsxds;
+      }
+   }
+}
+
+void FuentesPyramid::VT_T(int p, Vector s, Vector sds, Vector sdsxds,
+                          real_t mu, Vector grad_mu, DenseTensor &u) const
+{
+   MFEM_ASSERT(p >= 1, "Polynomial order must be one or larger");
+   MFEM_ASSERT(s.Size() >= 2, "Size of s must be 2 or larger");
+   MFEM_ASSERT(sds.Size() >= 3, "Size of sds must be 3 or larger");
+   MFEM_ASSERT(sdsxds.Size() >= 3, "Size of sdsxds must be 3 or larger");
+   MFEM_ASSERT(grad_mu.Size() >= 3, "Size of grad_mu must be 3 or larger");
+   MFEM_ASSERT(u.SizeI() >= p, "First dimension of u is too small");
+   MFEM_ASSERT(u.SizeJ() >= p, "Second dimension of u is too small");
+   MFEM_ASSERT(u.SizeK() >= 3, "Third dimension of u must be 3 or larger");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector      VT_T_vtmp1;
+   Vector      VT_T_vtmp2;
+   DenseMatrix VT_T_mtmp1;
+   DenseTensor VT_T_ttmp1;
+#endif
+
+   Vector ms({mu * s(0), mu * s(1), s(2)});
+   Vector s2(s.GetData(), 2);
+
+   Vector &P_i = VT_T_vtmp1;
+   P_i.SetSize(p);
+   CalcHomogenizedScaLegendre(p-1, ms[0], ms[1], P_i);
+
+   DenseMatrix &EE0 = VT_T_mtmp1;
+   EE0.SetSize(1,3);
+   Vector EE(EE0.GetData(), 3);
+   E_E(1, s2, sds, EE0);
+
+   Vector dmuxEE(3);
+   grad_mu.cross3D(EE, dmuxEE);
+
+   DenseTensor &VT00 = VT_T_ttmp1;
+   VT00.SetSize(1,1,3);
+   V_T(1, s, sdsxds, VT00);
+
+   Vector &J_j = VT_T_vtmp2;
+   J_j.SetSize(p);
+
+   u = 0.0;
+
+   for (int i=0; i<p; i++)
+   {
+      CalcHomogenizedScaJacobi(p-i-1, 2*i+1, ms[0] + ms[1], ms[2], J_j);
+      for (int j=0; i+j<p; j++)
+         for (int k=0; k<3; k++)
+            u(i, j, k) = P_i(i) * J_j(j) *
+                         (mu * VT00(0,0,k) + s(2) * dmuxEE(k));
+   }
+}
+
+void FuentesPyramid::VT_T(int p, Vector s, Vector sds, Vector sdsxds,
+                          Vector grad_s2, real_t mu, Vector grad_mu,
+                          DenseTensor &u, DenseMatrix &du) const
+{
+   MFEM_ASSERT(p >= 1, "Polynomial order must be one or larger");
+   MFEM_ASSERT(s.Size() >= 2, "Size of s must be 2 or larger");
+   MFEM_ASSERT(sds.Size() >= 3, "Size of sds must be 3 or larger");
+   MFEM_ASSERT(sdsxds.Size() >= 3, "Size of sdsxds must be 3 or larger");
+   MFEM_ASSERT(grad_s2.Size() >= 3, "Size of grad_s2 must be 3 or larger");
+   MFEM_ASSERT(grad_mu.Size() >= 3, "Size of grad_mu must be 3 or larger");
+   MFEM_ASSERT(u.SizeI() >= p, "First dimension of u is too small");
+   MFEM_ASSERT(u.SizeJ() >= p, "Second dimension of u is too small");
+   MFEM_ASSERT(u.SizeK() >= 3, "Third dimension of u must be 3 or larger");
+   MFEM_ASSERT(du.Height() >= p, "First dimension of du is too small");
+   MFEM_ASSERT(du.Width() >= p, "Second dimension of du is too small");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector      VT_T_vtmp1;
+   Vector      VT_T_vtmp2;
+   DenseMatrix VT_T_mtmp1;
+   DenseTensor VT_T_ttmp1;
+#endif
+
+   Vector ms({mu * s(0), mu * s(1), s(2)});
+   Vector s2(s.GetData(), 2);
+
+   Vector &P_i = VT_T_vtmp1;
+   P_i.SetSize(p);
+   CalcHomogenizedScaLegendre(p-1, ms[0], ms[1], P_i);
+
+   DenseMatrix &EE0 = VT_T_mtmp1;
+   EE0.SetSize(1,3);
+   Vector EE(EE0.GetData(), 3);
+   E_E(1, s2, sds, EE0);
+
+   Vector dmuxEE(3);
+   grad_mu.cross3D(EE, dmuxEE);
+
+   Vector EExds2(3);
+   EE.cross3D(grad_s2, EExds2);
+
+   DenseTensor &VT00 = VT_T_ttmp1;
+   VT00.SetSize(1,1,3);
+   V_T(1, s, sdsxds, VT00);
+
+   Vector &J_j = VT_T_vtmp2;
+   J_j.SetSize(p);
+
+   Vector EV(3);
+
+   u = 0.0;
+   du = 0.0;
+
+   for (int i=0; i<p; i++)
+   {
+      CalcHomogenizedScaJacobi(p-i-1, 2*i+1, ms[0] + ms[1], ms[2], J_j);
+      for (int j=0; i+j<p; j++)
+      {
+         for (int k=0; k<3; k++)
+         {
+            u(i, j, k) = P_i(i) * J_j(j) *
+                         (mu * VT00(0, 0, k) + s(2) * dmuxEE(k));
+
+            EV(k) = (i+j+3) * EExds2(k) - VT00(0, 0, k);
+         }
+
+         du(i, j) = P_i(i) * J_j(j) * (grad_mu * EV);
+      }
+   }
+}
+
+void FuentesPyramid::V_L(int p, Vector sx, const DenseMatrix &grad_sx,
+                         Vector sy, const DenseMatrix &grad_sy,
+                         real_t t, Vector grad_t,
+                         DenseTensor &u) const
+{
+   MFEM_ASSERT(p >= 2, "Polynomial order must be two or larger");
+   MFEM_ASSERT(sx.Size() >= 2, "Size of sx must be 2 or larger");
+   MFEM_ASSERT(grad_sx.Height() >= 2,
+               "First dimension of grad_sx must be 2 or larger");
+   MFEM_ASSERT(grad_sx.Width() >= 3,
+               "Second dimension of grad_sx must be 3 or larger");
+   MFEM_ASSERT(sy.Size() >= 2, "Size of sy must be 2 or larger");
+   MFEM_ASSERT(grad_sy.Height() >= 2,
+               "First dimension of grad_sy must be 2 or larger");
+   MFEM_ASSERT(grad_sy.Width() >= 3,
+               "Second dimension of grad_sy must be 3 or larger");
+   MFEM_ASSERT(grad_t.Size() >= 3, "Size of grad_t must be 3 or larger");
+   MFEM_ASSERT(u.SizeI() >= p+1, "First dimension of u is too small");
+   MFEM_ASSERT(u.SizeJ() >= p+1, "Second dimension of u is too small");
+   MFEM_ASSERT(u.SizeK() >= 3, "Third dimension of u must be 3 or larger");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector      V_L_vtmp1;
+   Vector      V_L_vtmp2;
+   DenseMatrix V_L_mtmp1;
+   DenseMatrix V_L_mtmp2;
+#endif
+   Vector       &phi_E_i = V_L_vtmp1;
+   Vector       &phi_E_j = V_L_vtmp2;
+   DenseMatrix &dphi_E_i = V_L_mtmp1;
+   DenseMatrix &dphi_E_j = V_L_mtmp2;
+
+   Vector grad_t3(grad_t.GetData(), 3);
+
+   phi_E_i.SetSize(p+1);
+   dphi_E_i.SetSize(p+1, grad_sx.Width());
+   phi_E(p, sx, grad_sx, phi_E_i, dphi_E_i);
+
+   phi_E_j.SetSize(p+1);
+   dphi_E_j.SetSize(p+1, grad_sy.Width());
+   phi_E(p, sy, grad_sy, phi_E_j, dphi_E_j);
+
+   Vector dphii(3);
+   Vector dphij(3);
+   Vector dphidphi(3);
+   Vector phidphi(3);
+   Vector dtphidphi(3);
+
+   for (int j=2; j<=p; j++)
+   {
+      for (int l=0; l<3; l++) { dphij[l] = dphi_E_j(j, l); }
+      for (int i=2; i<=p; i++)
+      {
+         for (int l=0; l<3; l++) { dphii[l] = dphi_E_i(i, l); }
+
+         dphii.cross3D(dphij, dphidphi);
+
+         add(phi_E_i(i), dphij, -phi_E_j(j), dphii, phidphi);
+
+         grad_t3.cross3D(phidphi, dtphidphi);
+
+         for (int l=0; l<3; l++)
+         {
+            u(i, j, l) = t * (t * dphidphi(l) + dtphidphi(l));
+         }
+      }
+   }
+}
+
+void FuentesPyramid::V_R(int p, Vector s, const DenseMatrix &grad_s,
+                         real_t mu, Vector dmu, real_t t, Vector dt,
+                         DenseMatrix &u) const
+{
+   MFEM_ASSERT(p >= 2, "Polynomial order must be two or larger");
+   MFEM_ASSERT(s.Size() >= 2, "Size of s must be 2 or larger");
+   MFEM_ASSERT(grad_s.Height() >= 2,
+               "First dimension of grad_s must be 2");
+   MFEM_ASSERT(grad_s.Width() >= 3,
+               "Second dimension of grad_s must be 3");
+   MFEM_ASSERT(dmu.Size() >= 3, "Size of dmu must be 3 or larger");
+   MFEM_ASSERT(dt.Size() >= 3, "Size of dt must be 3 or larger");
+   MFEM_ASSERT(u.Height() >= p+1, "First dimension of u is too small");
+   MFEM_ASSERT(u.Width() >= 3, "Second dimension of u is too small");
+
+#ifdef MFEM_THREAD_SAFE
+   Vector      V_R_vtmp;
+   DenseMatrix V_R_mtmp;
+#endif
+   Vector       &phi_E_i = V_R_vtmp;
+   DenseMatrix &dphi_E_i = V_R_mtmp;
+
+   phi_E_i.SetSize(p+1);
+   dphi_E_i.SetSize(p+1, grad_s.Width());
+   phi_E(p, s, grad_s, phi_E_i, dphi_E_i);
+
+   u.SetRow(0, 0.0);
+   u.SetRow(1, 0.0);
+
+   Vector dmu3(dmu.GetData(), 3);
+   Vector dt3(dt.GetData(), 3);
+   Vector dphit2(3);
+   Vector dphixdmu(3);
+   Vector dphi(3);
+
+   for (int i=2; i<=p; i++)
+   {
+      // dphi_E_i.GetRow(i, dphi);
+      for (int l=0; l<3; l++) { dphi[l] = dphi_E_i(i, l); }
+      add(t * t, dphi, 2.0 * t * phi_E_i(i), dt3, dphit2);
+      dphit2.cross3D(dmu3, dphixdmu);
+      // u.SetRow(i, dphixdmu);
+      for (int l=0; l<3; l++) { u(i, l) = dphixdmu(l); }
+   }
+}
+
+} // namespace mfem
diff --git a/fem/fe/fe_pyramid.hpp b/fem/fe/fe_pyramid.hpp
new file mode 100644
index 000000000..1d17e7324
--- /dev/null
+++ b/fem/fe/fe_pyramid.hpp
@@ -0,0 +1,489 @@
+// Copyright (c) 2010-2025, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_FE_PYRAMID
+#define MFEM_FE_PYRAMID
+
+#include "fe_base.hpp"
+
+namespace mfem
+{
+
+class FuentesPyramid
+{
+private:
+#ifndef MFEM_THREAD_SAFE
+   mutable DenseMatrix phi_E_mtmp;
+   mutable Vector      phi_Q_vtmp1;
+   mutable Vector      phi_Q_vtmp2;
+   mutable DenseMatrix phi_Q_mtmp1;
+   mutable DenseMatrix phi_Q_mtmp2;
+   mutable Vector      phi_T_vtmp1;
+   mutable Vector      phi_T_vtmp2;
+   mutable Vector      phi_T_vtmp3;
+   mutable Vector      phi_T_vtmp4;
+   mutable DenseMatrix phi_T_mtmp1;
+   mutable Vector      E_E_vtmp;
+   mutable Vector      E_Q_vtmp;
+   mutable DenseMatrix E_Q_mtmp1;
+   mutable DenseMatrix E_Q_mtmp2;
+   mutable DenseMatrix E_Q_mtmp3;
+   mutable Vector      E_T_vtmp1;
+   mutable Vector      E_T_vtmp2;
+   mutable Vector      E_T_vtmp3;
+   mutable DenseMatrix E_T_mtmp1;
+   mutable DenseMatrix E_T_mtmp2;
+   mutable DenseMatrix V_Q_mtmp1;
+   mutable DenseMatrix V_Q_mtmp2;
+   mutable Vector      V_T_vtmp1;
+   mutable Vector      V_T_vtmp2;
+   mutable DenseMatrix V_T_mtmp1;
+   mutable Vector      VT_T_vtmp1;
+   mutable Vector      VT_T_vtmp2;
+   mutable DenseMatrix VT_T_mtmp1;
+   mutable DenseTensor VT_T_ttmp1;
+   mutable Vector      V_L_vtmp1;
+   mutable Vector      V_L_vtmp2;
+   mutable DenseMatrix V_L_mtmp1;
+   mutable DenseMatrix V_L_mtmp2;
+   mutable Vector      V_R_vtmp;
+   mutable DenseMatrix V_R_mtmp;
+#endif
+
+protected:
+   static constexpr real_t one  = 1.0;
+   static constexpr real_t zero = 0.0;
+   static constexpr real_t apex_tol = 1e-8;
+
+public:
+   FuentesPyramid() = default;
+
+   static bool CheckZ(real_t z) { return std::abs(z - 1.0) > apex_tol; }
+
+   /// Pyramid "Affine" Coordinates
+   static real_t lam1(real_t x, real_t y, real_t z)
+   { return CheckZ(z) ? (1.0 - x - z) * (1.0 - y - z) / (1.0 - z): 0.0; }
+   static real_t lam2(real_t x, real_t y, real_t z)
+   { return CheckZ(z) ? x * (1.0 - y - z) / (1.0 - z): 0.0; }
+   static real_t lam3(real_t x, real_t y, real_t z)
+   { return CheckZ(z) ? x * y / (1.0 - z): 0.0; }
+   static real_t lam4(real_t x, real_t y, real_t z)
+   { return CheckZ(z) ? (1.0 - x - z) * y / (1.0 - z): 0.0; }
+   static real_t lam5(real_t x, real_t y, real_t z)
+   { return CheckZ(z) ? z : 1.0; }
+
+   /// Gradients of the "Affine" Coordinates
+   static Vector grad_lam1(real_t x, real_t y, real_t z);
+   static Vector grad_lam2(real_t x, real_t y, real_t z);
+   static Vector grad_lam3(real_t x, real_t y, real_t z);
+   static Vector grad_lam4(real_t x, real_t y, real_t z);
+   static Vector grad_lam5(real_t x, real_t y, real_t z);
+
+   /// Two component vectors associated with edges touching the apex
+   static Vector lam15(real_t x, real_t y, real_t z)
+   { return Vector({lam1(x, y, z), lam5(x, y, z)}); }
+   static Vector lam25(real_t x, real_t y, real_t z)
+   { return Vector({lam2(x, y, z), lam5(x, y, z)}); }
+   static Vector lam35(real_t x, real_t y, real_t z)
+   { return Vector({lam3(x, y, z), lam5(x, y, z)}); }
+   static Vector lam45(real_t x, real_t y, real_t z)
+   { return Vector({lam4(x, y, z), lam5(x, y, z)}); }
+
+   /// Gradients of the above two component vectors
+   static DenseMatrix grad_lam15(real_t x, real_t y, real_t z);
+   static DenseMatrix grad_lam25(real_t x, real_t y, real_t z);
+   static DenseMatrix grad_lam35(real_t x, real_t y, real_t z);
+   static DenseMatrix grad_lam45(real_t x, real_t y, real_t z);
+
+   static Vector lam15_grad_lam15(real_t x, real_t y, real_t z);
+   static Vector lam25_grad_lam25(real_t x, real_t y, real_t z);
+   static Vector lam35_grad_lam35(real_t x, real_t y, real_t z);
+   static Vector lam45_grad_lam45(real_t x, real_t y, real_t z);
+
+   /// Three component vectors associated with triangular faces
+   static Vector lam125(real_t x, real_t y, real_t z)
+   { return Vector({lam1(x, y, z), lam2(x, y, z), lam5(x, y, z)}); }
+   static Vector lam235(real_t x, real_t y, real_t z)
+   { return Vector({lam2(x, y, z), lam3(x, y, z), lam5(x, y, z)}); }
+   static Vector lam345(real_t x, real_t y, real_t z)
+   { return Vector({lam3(x, y, z), lam4(x, y, z), lam5(x, y, z)}); }
+   static Vector lam435(real_t x, real_t y, real_t z)
+   { return Vector({lam4(x, y, z), lam3(x, y, z), lam5(x, y, z)}); }
+   static Vector lam415(real_t x, real_t y, real_t z)
+   { return Vector({lam4(x, y, z), lam1(x, y, z), lam5(x, y, z)}); }
+   static Vector lam145(real_t x, real_t y, real_t z)
+   { return Vector({lam1(x, y, z), lam4(x, y, z), lam5(x, y, z)}); }
+
+   /// Vector functions related to the normals to the triangular faces
+   static Vector lam125_grad_lam125(real_t x, real_t y, real_t z);
+   static Vector lam235_grad_lam235(real_t x, real_t y, real_t z);
+   static Vector lam345_grad_lam345(real_t x, real_t y, real_t z);
+   static Vector lam435_grad_lam435(real_t x, real_t y, real_t z);
+   static Vector lam415_grad_lam415(real_t x, real_t y, real_t z);
+   static Vector lam145_grad_lam145(real_t x, real_t y, real_t z);
+
+   /// Divergences of the above "normal" vector functions divided by 3
+   static real_t div_lam125_grad_lam125(real_t x, real_t y, real_t z);
+   static real_t div_lam235_grad_lam235(real_t x, real_t y, real_t z);
+   static real_t div_lam345_grad_lam345(real_t x, real_t y, real_t z);
+   static real_t div_lam435_grad_lam435(real_t x, real_t y, real_t z);
+   static real_t div_lam415_grad_lam415(real_t x, real_t y, real_t z);
+   static real_t div_lam145_grad_lam145(real_t x, real_t y, real_t z);
+
+   static real_t mu0(real_t z)
+   { return 1.0 - z; }
+   static real_t mu1(real_t z)
+   { return z; }
+
+   static Vector grad_mu0(real_t z)
+   { return Vector({0.0, 0.0, -1.0}); }
+   static Vector grad_mu1(real_t z)
+   { return Vector({0.0, 0.0, 1.0}); }
+
+   static Vector mu01(real_t z)
+   { return Vector({mu0(z), mu1(z)}); }
+
+   static DenseMatrix grad_mu01(real_t z);
+
+   static real_t mu0(real_t z, const Vector &xy, unsigned int ab)
+   { return 1.0 - xy[ab-1] / (1.0 - z); }
+   static real_t mu1(real_t z, const Vector &xy, unsigned int ab)
+   { return xy[ab-1] / (1.0 - z); }
+
+   static Vector grad_mu0(real_t z, const Vector xy, unsigned int ab);
+   static Vector grad_mu1(real_t z, const Vector xy, unsigned int ab);
+
+   static Vector mu01(real_t z, Vector xy, unsigned int ab)
+   { return Vector({mu0(z, xy, ab), mu1(z, xy, ab)}); }
+
+   static DenseMatrix grad_mu01(real_t z, Vector xy, unsigned int ab);
+   static Vector mu01_grad_mu01(real_t z, Vector xy, unsigned int ab);
+
+   static real_t nu0(real_t z, Vector xy, unsigned int ab)
+   { return 1.0 - xy[ab-1] - z; }
+   static real_t nu1(real_t z, Vector xy, unsigned int ab) { return xy[ab-1]; }
+   static real_t nu2(real_t z, Vector xy, unsigned int ab) { return z; }
+
+   static Vector grad_nu0(real_t z, const Vector xy, unsigned int ab);
+   static Vector grad_nu1(real_t z, const Vector xy, unsigned int ab);
+   static Vector grad_nu2(real_t z, const Vector xy, unsigned int ab);
+
+   static Vector nu01(real_t z, Vector xy, unsigned int ab)
+   { return Vector({nu0(z, xy, ab), nu1(z, xy, ab)}); }
+   static Vector nu12(real_t z, Vector xy, unsigned int ab)
+   { return Vector({nu1(z, xy, ab), nu2(z, xy, ab)}); }
+   static Vector nu012(real_t z, Vector xy, unsigned int ab)
+   { return Vector({nu0(z, xy, ab), nu1(z, xy, ab), nu2(z, xy, ab)}); }
+   static Vector nu120(real_t z, Vector xy, unsigned int ab)
+   { return Vector({nu1(z, xy, ab), nu2(z, xy, ab), nu0(z, xy, ab)}); }
+
+   static DenseMatrix grad_nu01(real_t z, Vector xy, unsigned int ab);
+   static DenseMatrix grad_nu012(real_t z, Vector xy, unsigned int ab);
+   static DenseMatrix grad_nu120(real_t z, Vector xy, unsigned int ab);
+
+   static Vector nu01_grad_nu01(real_t z, Vector xy, unsigned int ab);
+   static Vector nu12_grad_nu12(real_t z, Vector xy, unsigned int ab);
+   static Vector nu012_grad_nu012(real_t z, Vector xy, unsigned int ab);
+
+   /// Shifted and Scaled Legendre Polynomials
+   /** Implements a scaled and shifted set of Legendre polynomials
+
+         $P_i(x;t) = P_i(x / t) * t^i$
+
+       where @a t >= 0.0, @a x $\in [0,t]$, and $P_i$ is the shifted Legendre
+       polynomial defined on $[0,1]$ rather than the usual $[-1,1]$. The
+       entries stored in @a u correspond to the values of
+       $P_0$, $P_1$, ... $P_p$.
+
+       @a u must be at least @a p + 1 in length
+   */
+   static void CalcScaledLegendre(int p, real_t x, real_t t,
+                                  real_t *u);
+   static void CalcScaledLegendre(int p, real_t x, real_t t,
+                                  real_t *u, real_t *dudx, real_t *dudt);
+
+   static void CalcScaledLegendre(int p, real_t x, real_t t,
+                                  Vector &u);
+   static void CalcScaledLegendre(int p, real_t x, real_t t,
+                                  Vector &u, Vector &dudx, Vector &dudt);
+
+   /// Integrated Legendre Polynomials
+   /** These are the integrals of the shifted and scaled Legendre polynomials
+       provided above and defined as:
+
+         $L_i(x;t) = \int_0^x P_{i-1}(y;t)dy\mbox{ for }i>=1$
+
+       These polynomials are computed as:
+
+         $L_0(x;t) = 0$, $L_1(x;t) = x$,
+
+         $2(2i-1)L_i(x;t) = P_i(x;t) - t^2 P_{i-2}(x;t)\mbox{ for }i>=2$
+
+       @a u must be at least @a p + 1 in length
+    */
+   static void CalcIntegratedLegendre(int p, real_t x,
+                                      real_t t, real_t *u);
+   static void CalcIntegratedLegendre(int p, real_t x,
+                                      real_t t, real_t *u,
+                                      real_t *dudx, real_t *dudt);
+
+   static void CalcIntegratedLegendre(int p, real_t x,
+                                      real_t t, Vector &u);
+   static void CalcIntegratedLegendre(int p, real_t x,
+                                      real_t t, Vector &u,
+                                      Vector &dudx, Vector &dudt);
+
+   /** @a u must be at least @a p + 1 in length */
+   static void CalcHomogenizedScaLegendre(int p, real_t s0, real_t s1,
+                                          real_t *u);
+   static void CalcHomogenizedScaLegendre(int p,
+                                          real_t s0, real_t s1,
+                                          real_t *u,
+                                          real_t *duds0, real_t *duds1);
+   static void CalcHomogenizedScaLegendre(int p, real_t s0, real_t s1,
+                                          Vector &u);
+   static void CalcHomogenizedScaLegendre(int p,
+                                          real_t s0, real_t s1,
+                                          Vector &u,
+                                          Vector &duds0, Vector &duds1);
+
+   /** @a u must be at least @a p + 1 in length */
+   static void CalcHomogenizedIntLegendre(int p,
+                                          real_t t0, real_t t1,
+                                          real_t *u);
+   static void CalcHomogenizedIntLegendre(int p,
+                                          real_t t0, real_t t1,
+                                          real_t *u,
+                                          real_t *dudt0, real_t *dudt1);
+   static void CalcHomogenizedIntLegendre(int p,
+                                          real_t t0, real_t t1,
+                                          Vector &u);
+   static void CalcHomogenizedIntLegendre(int p,
+                                          real_t t0, real_t t1,
+                                          Vector &u,
+                                          Vector &dudt0, Vector &dudt1);
+
+   /// Shifted and Scaled Jacobi Polynomials
+   /** Implements a scaled and shifted set of Jacobi polynomials
+
+         $P^\alpha_i(x / t) * t^i$
+
+       where @a alpha $= \alpha >-1$, @a t $>= 0.0$, @a x $\in [0,t]$, and
+       $P^\alpha_i$ is the shifted Jacobi polynomial defined on $[0,1]$ rather
+       than the usual $[-1,1]$. The entries stored in @a u correspond to the
+       values of $P^\alpha_0$, $P^\alpha_1$, ... $P^\alpha_p$.
+
+       @note Jacobi polynomials typically posses two parameters,
+       $P^{\alpha, \beta}_i$, but we only consider the special case where
+       $\beta=0$.
+
+       @a u must be at least @a p + 1 in length
+   */
+   static void CalcScaledJacobi(int p, real_t alpha,
+                                real_t x, real_t t,
+                                real_t *u);
+   static void CalcScaledJacobi(int p, real_t alpha,
+                                real_t x, real_t t,
+                                real_t *u, real_t *dudx, real_t *dudt);
+
+   static void CalcScaledJacobi(int p, real_t alpha,
+                                real_t x, real_t t,
+                                Vector &u);
+   static void CalcScaledJacobi(int p, real_t alpha,
+                                real_t x, real_t t,
+                                Vector &u, Vector &dudx, Vector &dudt);
+
+   /// Integrated Jacobi Polynomials
+   /** These are the integrals of the shifted and scaled Jacobi polynomials
+       provided above and defined as:
+
+         $L^\alpha_i(x;t) = \int_0^x P^\alpha_{i-1}(y;t)dy\mbox{ for }i>=1$
+
+       These polynomials are computed as:
+
+         $L^\alpha_0(x;t) = 0$, $L^\alpha_1(x;t) = x$,
+
+         $L^\alpha_i(x;t) = a_i P^\alpha_i(x;t) + b_i t P^\alpha_{i-1}(x;t)
+                        - c_i t^2 P^\alpha_{i-2}(x;t)\mbox{ for }i>=2$
+
+       With
+
+         $a_i = (i + \alpha) / (2i + \alpha - 1)(2i + \alpha)$
+
+         $b_i = \alpha / (2i + \alpha - 2)(2i + \alpha)$
+
+         $c_i = (i - 1) / (2i + \alpha - 2)(2i + \alpha - 1)$
+
+       @a u must be at least @a p + 1 in length
+    */
+   static void CalcIntegratedJacobi(int p, real_t alpha,
+                                    real_t x, real_t t,
+                                    real_t *u);
+   static void CalcIntegratedJacobi(int p, real_t alpha,
+                                    real_t x, real_t t,
+                                    real_t *u, real_t *dudx, real_t *dudt);
+
+   static void CalcIntegratedJacobi(int p, real_t alpha,
+                                    real_t x, real_t t,
+                                    Vector &u)
+   { CalcIntegratedJacobi(p, alpha, x, t, u.GetData()); }
+   static void CalcIntegratedJacobi(int p, real_t alpha,
+                                    real_t x, real_t t,
+                                    Vector &u, Vector &dudx, Vector &dudt)
+   {
+      CalcIntegratedJacobi(p, alpha, x, t, u.GetData(),
+                           dudx.GetData(), dudt.GetData());
+   }
+
+   /** @a u must be at least @a p + 1 in length */
+   static void CalcHomogenizedScaJacobi(int p, real_t alpha,
+                                        real_t t0, real_t t1,
+                                        real_t *u)
+   { CalcScaledJacobi(p, alpha, t1, t0 + t1, u); }
+   static void CalcHomogenizedScaJacobi(int p, real_t alpha,
+                                        real_t t0, real_t t1,
+                                        real_t *u,
+                                        real_t *dudt0, real_t *dudt1);
+   static void CalcHomogenizedScaJacobi(int p, real_t alpha,
+                                        real_t t0, real_t t1,
+                                        Vector &u);
+   static void CalcHomogenizedScaJacobi(int p, real_t alpha,
+                                        real_t t0, real_t t1,
+                                        Vector &u,
+                                        Vector &dudt0, Vector &dudt1);
+
+   /** @a u must be at least @a p + 1 in length */
+   static void CalcHomogenizedIntJacobi(int p, real_t alpha,
+                                        real_t t0, real_t t1,
+                                        real_t *u)
+   { CalcIntegratedJacobi(p, alpha, t1, t0 + t1, u); }
+   static void CalcHomogenizedIntJacobi(int p, real_t alpha,
+                                        real_t t0, real_t t1,
+                                        real_t *u,
+                                        real_t *dudt0, real_t *dudt1);
+   static void CalcHomogenizedIntJacobi(int p, real_t alpha,
+                                        real_t t0, real_t t1,
+                                        Vector &u);
+   static void CalcHomogenizedIntJacobi(int p, real_t alpha,
+                                        real_t t0, real_t t1,
+                                        Vector &u,
+                                        Vector &dudt0, Vector &dudt1);
+
+   /** @a u must be at least @a p + 1 in length */
+   static void phi_E(int p, real_t s0, real_t s1, real_t *u);
+   static void phi_E(int p, real_t s0, real_t s1, real_t *u,
+                     real_t *duds0, real_t *duds1);
+   static void phi_E(int p, Vector s, Vector &u);
+   static void phi_E(int p, Vector s, Vector &u, DenseMatrix &duds);
+
+   /** @a grad_s must be 2x3 */
+   void phi_E(int p, Vector s, const DenseMatrix &grad_s,
+              Vector &u, DenseMatrix &grad_u) const;
+
+   /** @a u must be at least (p+1)x(p+1) in size */
+   void phi_Q(int p, Vector s, Vector t, DenseMatrix &u) const;
+   void phi_Q(int p, Vector s, const DenseMatrix &grad_s,
+              Vector t, const DenseMatrix &grad_t,
+              DenseMatrix &u, DenseTensor &grad_u) const;
+   void phi_T(int p, Vector nu, DenseMatrix &u) const;
+   void phi_T(int p, Vector nu, const DenseMatrix &grad_nu,
+              DenseMatrix &u, DenseTensor &grad_u) const;
+   /*
+   static void E_E(int p, real_t s0, real_t s1, real_t *u,
+                   real_t *duds0, real_t *duds1);
+   */
+   // static void E_E(int p, real_t s0, real_t s1, real_t *u);
+
+   /** This is a vector-valued function associated with an edge of a pyramid
+
+   The vector @a s contains two coordinate values and @a ds is related to the
+   gradient of these coordinates with respect to the reference coordinates i.e.
+      sds = s0 grad s1 - s1 grad s0
+   */
+   void E_E(int p, Vector s, Vector sds, DenseMatrix &u) const;
+   void E_E(int p, Vector s, const DenseMatrix &grad_s, DenseMatrix &u,
+            DenseMatrix &curl_u) const;
+
+   void E_Q(int p, Vector s, Vector ds, Vector t,
+            DenseTensor &u) const;
+   void E_Q(int p, Vector s, const DenseMatrix &grad_s,
+            Vector t, const DenseMatrix &grad_t,
+            DenseTensor &u, DenseTensor &curl_u) const;
+
+   void E_T(int p, Vector s, Vector sds, DenseTensor &u) const;
+   void E_T(int p, Vector s, const DenseMatrix &grad_s,
+            DenseTensor &u, DenseTensor &curl_u) const;
+
+   /** This is a vector-valued function associated with the quadrilateral face
+       of a pyramid
+
+   The vectors @a s and @a t contain pairs of coordinate values and @a ds and
+   @a dt are related to derivatives of these coordinates:
+
+      ds = s0 grad s1 - s1 grad s0
+
+      dt = t0 grad t1 - t1 grad t0
+   */
+   void V_Q(int p, Vector s, Vector ds, Vector t, Vector dt,
+            DenseTensor &u) const;
+
+   /** This is a vector-valued function associated with the triangular faces of
+       a pyramid
+
+   The vector @a s contains three coordinate values and @a sdsxds is related to
+   derivatives of these coordinates with respect to the reference coordinates:
+
+      sdsxds = s0 grad s1 x grad s2 + s1 grad s2 x grad s0 +
+               s2 grad s0 x grad s1
+   */
+   void V_T(int p, Vector s, Vector sdsxds, DenseTensor &u) const;
+
+   /** This computes V_T as above and its divergence
+
+   The vector @a s contains three coordinate values and @a sdsxds is related to
+   derivatives of these coordinates with respect to the reference coordinates:
+
+      sdsxds = s0 grad s1 x grad s2 + s1 grad s2 x grad s0 +
+               s2 grad s0 x grad s1
+
+   The scalar @a dsdsxds is the divergence of sdsxds:
+
+      dsdsxds = grad s0 dot (grad s1 x grad s2)
+   */
+   void V_T(int p, Vector s, Vector sdsxds, real_t dsdsxds,
+            DenseTensor &u, DenseMatrix &du) const;
+
+   void VT_T(int p, Vector s, Vector sds, Vector sdsxds,
+             real_t mu, Vector grad_mu, DenseTensor &u) const;
+   void VT_T(int p, Vector s, Vector sds, Vector sdsxds,
+             Vector grad_s2, real_t mu, Vector grad_mu,
+             DenseTensor &u, DenseMatrix &du) const;
+
+   /** This implements $V^\unlhd_{ij}$ from the Fuentes paper
+
+      @a u must be at least (p+1)x(p+1)x3
+   */
+   void V_L(int p, Vector sx, const DenseMatrix &grad_sx,
+            Vector sy, const DenseMatrix &grad_sy,
+            real_t t, Vector grad_t, DenseTensor &u) const;
+
+   /** This implements $V^\unrhd_i$ from the Fuentes paper
+
+      @a u must be at least (p+1)x3 */
+   void V_R(int p, Vector s, const DenseMatrix &grad_s,
+            real_t mu, Vector grad_mu,
+            real_t t, Vector grad_t, DenseMatrix &u) const;
+};
+
+} // namespace mfem
+
+#endif
+
diff --git a/fem/fe/fe_rt.cpp b/fem/fe/fe_rt.cpp
index 06ff1541f..225deb3e6 100644
--- a/fem/fe/fe_rt.cpp
+++ b/fem/fe/fe_rt.cpp
@@ -1264,6 +1264,743 @@ void RT_WedgeElement::CalcDivShape(const IntegrationPoint &ip,
    }
 }
 
+const real_t RT_FuentesPyramidElement::nk[24] =
+{
+   0,0,-1,  0,-1,0,  1,0,1,  0,1,1,  -1,0,0,
+   M_SQRT2,0,M_SQRT1_2, 0,M_SQRT2,M_SQRT1_2, 0,0,1
+};
+
+RT_FuentesPyramidElement::RT_FuentesPyramidElement(const int p)
+   : VectorFiniteElement(3, Geometry::PYRAMID, (p + 1)*(3*p*(p + 2) + 5),
+                         p + 1, H_DIV, FunctionSpace::Pk),
+     dof2nk(dof)
+{
+   zmax = 0.0;
+
+   const real_t *iop = poly1d.OpenPoints(p);
+   const real_t *icp = poly1d.ClosedPoints(p + 1);
+   const real_t *bop = poly1d.OpenPoints(p);
+
+#ifndef MFEM_THREAD_SAFE
+   tmp1_i.SetSize(p + 2);
+   tmp1_ij.SetSize(p + 2, p + 2);
+   tmp2_ij.SetSize(p + 2, dim);
+   tmp3_ij.SetSize(p + 2, dim);
+   tmp4_ij.SetSize(p + 1, p + 1);
+   tmp1_ijk.SetSize(p + 1, p + 1, dim);
+   tmp2_ijk.SetSize(p + 1, p + 1, dim);
+   tmp3_ijk.SetSize(p + 1, p + 1, dim);
+   tmp4_ijk.SetSize(p + 1, p + 2, dim);
+   tmp5_ijk.SetSize(p + 1, p + 2, dim);
+   tmp6_ijk.SetSize(p + 2, p + 2, dim);
+   tmp7_ijk.SetSize(p + 2, p + 2, dim);
+   u.SetSize(dof, dim);
+   divu.SetSize(dof);
+#else
+   Vector      tmp1_i(p + 2);
+   DenseMatrix tmp1_ij(p + 2, p + 2);
+   DenseMatrix tmp2_ij(p + 2, dim);
+   DenseMatrix tmp3_ij(p + 2, dim);
+   DenseTensor tmp1_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp2_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp3_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp4_ijk(p + 1, p + 2, dim);
+   DenseTensor tmp5_ijk(p + 1, p + 2, dim);
+   DenseTensor tmp6_ijk(p + 2, p + 2, dim);
+   DenseTensor tmp7_ijk(p + 2, p + 2, dim);
+   DenseMatrix u(dof, dim);
+#endif
+
+   int o = 0;
+
+   // quadrilateral face
+   for (int j = 0; j <= p; j++)
+      for (int i = 0; i <= p; i++)  // (3,2,1,0)
+      {
+         Nodes.IntPoint(o).Set3(bop[i], bop[p-j], 0.);
+         dof2nk[o++] = 0;
+      }
+   // triangular faces
+   for (int j = 0; j <= p; j++)
+      for (int i = 0; i + j <= p; i++)  // (0,1,4)
+      {
+         real_t w = bop[i] + bop[j] + bop[p-i-j];
+         Nodes.IntPoint(o).Set3(bop[i]/w, 0., bop[j]/w);
+         dof2nk[o++] = 1;
+      }
+   for (int j = 0; j <= p; j++)
+      for (int i = 0; i + j <= p; i++)  // (1,2,4)
+      {
+         real_t w = bop[i] + bop[j] + bop[p-i-j];
+         Nodes.IntPoint(o).Set3(1.-bop[j]/w, bop[i]/w, bop[j]/w);
+         dof2nk[o++] = 2;
+      }
+   for (int j = 0; j <= p; j++)
+      for (int i = p - j; i >= 0; i--)  // (2,3,4)
+      {
+         real_t w = bop[i] + bop[j] + bop[p-i-j];
+         Nodes.IntPoint(o).Set3(bop[i]/w, 1.0-bop[j]/w, bop[j]/w);
+         dof2nk[o++] = 3;
+      }
+   for (int j = 0; j <= p; j++)
+      for (int i = p - j; i >= 0; i--)  // (3,0,4)
+      {
+         real_t w = bop[i] + bop[j] + bop[p-i-j];
+         Nodes.IntPoint(o).Set3(0., bop[i]/w, bop[j]/w);
+         dof2nk[o++] = 4;
+      }
+
+   // interior
+   // x-components
+   for (int k = 0; k <= p; k++)
+      for (int j = 0; j <= p; j++)
+         for (int i = 1; i <= p; i++)
+         {
+            real_t w = 1.0 - iop[k];
+            Nodes.IntPoint(o).Set3(icp[i]*w, iop[j]*w, iop[k]);
+            dof2nk[o++] = 5;
+         }
+   // y-components
+   for (int k = 0; k <= p; k++)
+      for (int j = 1; j <= p; j++)
+         for (int i = 0; i <= p; i++)
+         {
+            real_t w = 1.0 - iop[k];
+            Nodes.IntPoint(o).Set3(iop[i]*w, icp[j]*w, iop[k]);
+            dof2nk[o++] = 6;
+         }
+   // z-components
+   for (int k = 1; k <= p; k++)
+      for (int j = 0; j <= p; j++)
+         for (int i = 0; i <= p; i++)
+         {
+            real_t w = 1.0 - icp[k];
+            Nodes.IntPoint(o).Set3(iop[i]*w, iop[j]*w, icp[k]);
+            dof2nk[o++] = 7;
+         }
+
+   DenseMatrix T(dof);
+
+   for (int m = 0; m < dof; m++)
+   {
+      const IntegrationPoint &ip = Nodes.IntPoint(m);
+      const Vector nm({nk[3*dof2nk[m]], nk[3*dof2nk[m]+1], nk[3*dof2nk[m]+2]});
+      calcBasis(order, ip, tmp1_i, tmp1_ij, tmp2_ij,
+                tmp1_ijk, tmp2_ijk, tmp3_ijk, tmp4_ijk, tmp5_ijk, tmp6_ijk,
+                tmp7_ijk,
+                tmp3_ij, u);
+      u.Mult(nm, T.GetColumn(m));
+   }
+
+   Ti.Factor(T);
+}
+
+void RT_FuentesPyramidElement::CalcVShape(const IntegrationPoint &ip,
+                                          DenseMatrix &shape) const
+{
+#ifdef MFEM_THREAD_SAFE
+   const int p = order - 1;
+
+   Vector      tmp1_i(p + 2);
+   DenseMatrix tmp1_ij(p + 2, p + 2);
+   DenseMatrix tmp2_ij(p + 2, dim);
+   DenseMatrix tmp3_ij(p + 2, dim);
+   DenseTensor tmp1_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp2_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp3_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp4_ijk(p + 1, p + 2, dim);
+   DenseTensor tmp5_ijk(p + 1, p + 2, dim);
+   DenseTensor tmp6_ijk(p + 2, p + 2, dim);
+   DenseTensor tmp7_ijk(p + 2, p + 2, dim);
+   DenseMatrix u(dof, dim);
+#endif
+
+   calcBasis(order, ip, tmp1_i, tmp1_ij, tmp2_ij,
+             tmp1_ijk, tmp2_ijk, tmp3_ijk, tmp4_ijk, tmp5_ijk, tmp6_ijk,
+             tmp7_ijk, tmp3_ij, u);
+
+   Ti.Mult(u, shape);
+}
+
+void RT_FuentesPyramidElement::CalcRawVShape(const IntegrationPoint &ip,
+                                             DenseMatrix &shape) const
+{
+#ifdef MFEM_THREAD_SAFE
+   const int p = order - 1;
+
+   Vector      tmp1_i(p + 2);
+   DenseMatrix tmp1_ij(p + 2, p + 2);
+   DenseMatrix tmp2_ij(p + 2, dim);
+   DenseMatrix tmp3_ij(p + 2, dim);
+   DenseTensor tmp1_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp2_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp3_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp4_ijk(p + 1, p + 2, dim);
+   DenseTensor tmp5_ijk(p + 1, p + 2, dim);
+   DenseTensor tmp6_ijk(p + 2, p + 2, dim);
+   DenseTensor tmp7_ijk(p + 2, p + 2, dim);
+#endif
+
+   calcBasis(order, ip, tmp1_i, tmp1_ij, tmp2_ij,
+             tmp1_ijk, tmp2_ijk, tmp3_ijk, tmp4_ijk, tmp5_ijk, tmp6_ijk,
+             tmp7_ijk, tmp3_ij, shape);
+}
+
+void RT_FuentesPyramidElement::CalcDivShape(const IntegrationPoint &ip,
+                                            Vector &divshape) const
+{
+#ifdef MFEM_THREAD_SAFE
+   const int p = order - 1;
+
+   Vector      tmp1_i(p + 2);
+   DenseMatrix tmp1_ij(p + 2, p + 2);
+   DenseMatrix tmp2_ij(p + 2, dim);
+   DenseMatrix tmp3_ij(p + 2, dim);
+   DenseMatrix tmp4_ij(p + 1, p + 1);
+   DenseTensor tmp1_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp2_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp3_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp4_ijk(p + 1, p + 2, dim);
+   DenseTensor tmp5_ijk(p + 1, p + 2, dim);
+   DenseTensor tmp6_ijk(p + 2, p + 2, dim);
+   DenseTensor tmp7_ijk(p + 2, p + 2, dim);
+   Vector divu(dof);
+#endif
+   divu = 0.0;
+
+   calcDivBasis(order, ip, tmp1_i, tmp1_ij, tmp2_ij,
+                tmp1_ijk, tmp2_ijk, tmp3_ijk, tmp4_ij, tmp4_ijk, tmp5_ijk,
+                tmp6_ijk, tmp7_ijk, tmp3_ij, divu);
+
+   Ti.Mult(divu, divshape);
+}
+
+void RT_FuentesPyramidElement::CalcRawDivShape(const IntegrationPoint &ip,
+                                               Vector &dshape) const
+{
+#ifdef MFEM_THREAD_SAFE
+   const int p = order - 1;
+
+   Vector      tmp1_i(p + 2);
+   DenseMatrix tmp1_ij(p + 2, p + 2);
+   DenseMatrix tmp2_ij(p + 2, dim);
+   DenseMatrix tmp3_ij(p + 2, dim);
+   DenseMatrix tmp4_ij(p + 1, p + 1);
+   DenseTensor tmp1_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp2_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp3_ijk(p + 1, p + 1, dim);
+   DenseTensor tmp4_ijk(p + 1, p + 2, dim);
+   DenseTensor tmp5_ijk(p + 1, p + 2, dim);
+   DenseTensor tmp6_ijk(p + 2, p + 2, dim);
+   DenseTensor tmp7_ijk(p + 2, p + 2, dim);
+#endif
+
+   calcDivBasis(order, ip, tmp1_i, tmp1_ij, tmp2_ij,
+                tmp1_ijk, tmp2_ijk, tmp3_ijk, tmp4_ij, tmp4_ijk, tmp5_ijk,
+                tmp6_ijk, tmp7_ijk, tmp3_ij, dshape);
+}
+
+void RT_FuentesPyramidElement::calcBasis(const int p,
+                                         const IntegrationPoint &ip,
+                                         Vector &phi_k,
+                                         DenseMatrix &phi_ij,
+                                         DenseMatrix &dphi_k,
+                                         DenseTensor &VQ_ijk,
+                                         DenseTensor &VT_ijk,
+                                         DenseTensor &VTT_ijk,
+                                         DenseTensor &E_ijk,
+                                         DenseTensor &dE_ijk,
+                                         DenseTensor &dphi_ijk,
+                                         DenseTensor &VL_ijk,
+                                         DenseMatrix &VR_ij,
+                                         DenseMatrix &F) const
+{
+   real_t x = ip.x;
+   real_t y = ip.y;
+   real_t z = ip.z;
+   Vector xy({x,y});
+   real_t mu;
+
+   if (std::fabs(1.0 - z) < apex_tol)
+   {
+      z = 1.0 - apex_tol;
+      y = 0.5 * (1.0 - z);
+      x = 0.5 * (1.0 - z);
+      xy(0) = x; xy(1) = y;
+   }
+   zmax = std::max(z, zmax);
+
+   F = 0.0;
+
+   int o = 0;
+
+   // Quadrilateral face
+   if (z < 1.0)
+   {
+      V_Q(p, mu01(z, xy, 1), mu01_grad_mu01(z, xy, 1),
+          mu01(z, xy, 2), mu01_grad_mu01(z, xy, 2),
+          VQ_ijk);
+
+      const real_t muz3 = pow(mu0(z), 3);
+
+      for (int j=0; j<p; j++)
+         for (int i=0; i<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               F(o, k) = muz3 * VQ_ijk(i, j, k);
+            }
+   }
+
+   // Triangular faces
+   if (z < 1.0)
+   {
+      Vector dmuz;
+
+      // (a,b) = (1,2), c = 0
+      V_T(p, nu012(z, xy, 1), nu012_grad_nu012(z, xy, 1), VT_ijk);
+      mu = mu0(z, xy, 2);
+      dmuz.Destroy(); dmuz = grad_mu0(z, xy, 2);
+      VT_T(p, nu012(z, xy, 1), nu01_grad_nu01(z, xy, 1),
+           nu012_grad_nu012(z, xy, 1), mu, dmuz, VTT_ijk);
+      for (int j=0; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               F(o, k) = 0.5 * (mu * VT_ijk(i, j, k) + VTT_ijk(i, j, k));
+            }
+
+      // (a,b) = (1,2), c = 1
+      mu = mu1(z, xy, 2);
+      dmuz.Destroy(); dmuz = grad_mu1(z, xy, 2);
+      VT_T(p, nu012(z, xy, 1), nu01_grad_nu01(z, xy, 1),
+           nu012_grad_nu012(z, xy, 1), mu, dmuz, VTT_ijk);
+      for (int j=0; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               F(o, k) = 0.5 * (mu * VT_ijk(i, j, k) + VTT_ijk(i, j, k));
+            }
+
+      // (a,b) = (2,1), c = 0
+      V_T(p, nu012(z, xy, 2), nu012_grad_nu012(z, xy, 2), VT_ijk);
+      mu = mu0(z, xy, 1);
+      dmuz.Destroy(); dmuz = grad_mu0(z, xy, 1);
+      VT_T(p, nu012(z, xy, 2), nu01_grad_nu01(z, xy, 2),
+           nu012_grad_nu012(z, xy, 2), mu, dmuz, VTT_ijk);
+      for (int j=0; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               F(o, k) = 0.5 * (mu * VT_ijk(i, j, k) + VTT_ijk(i, j, k));
+            }
+
+      // (a,b) = (2,1), c = 1
+      mu = mu1(z, xy, 1);
+      dmuz.Destroy(); dmuz = grad_mu1(z, xy, 1);
+      VT_T(p, nu012(z, xy, 2), nu01_grad_nu01(z, xy, 2),
+           nu012_grad_nu012(z, xy, 2), mu, dmuz, VTT_ijk);
+      for (int j=0; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               F(o, k) = 0.5 * (mu * VT_ijk(i, j, k) + VTT_ijk(i, j, k));
+            }
+   }
+
+   // Interior
+   // Family I
+   if (z < 1.0 && p >= 2)
+   {
+      E_Q(p, mu01(z, xy, 1), grad_mu01(z, xy, 1),
+          mu01(z, xy, 2), grad_mu01(z, xy, 2), E_ijk, dE_ijk);
+      phi_E(p, mu01(z), grad_mu01(z), phi_k, dphi_k);
+      const real_t muz = mu0(z);
+      const Vector dmuz(grad_mu0(z));
+
+      Vector dmuphi(3), E(3), v(3);
+
+      for (int k=2; k<=p; k++)
+      {
+         dmuphi(0) = muz * dphi_k(k,0) + dmuz(0) * phi_k(k);
+         dmuphi(1) = muz * dphi_k(k,1) + dmuz(1) * phi_k(k);
+         dmuphi(2) = muz * dphi_k(k,2) + dmuz(2) * phi_k(k);
+         for (int j=2; j<=p; j++)
+            for (int i=0; i<p; i++, o++)
+            {
+               E(0) = E_ijk(i,j,0); E(1) = E_ijk(i,j,1); E(2) = E_ijk(i,j,2);
+               dmuphi.cross3D(E, v);
+               for (int l=0; l<3; l++)
+               {
+                  F(o, l) = muz * phi_k(k) * dE_ijk(i,j,l) + v(l);
+               }
+            }
+      }
+   }
+
+   // Family II
+   if (z < 1.0 && p >= 2)
+   {
+      E_Q(p, mu01(z, xy, 2), grad_mu01(z, xy, 2),
+          mu01(z, xy, 1), grad_mu01(z, xy, 1), E_ijk, dE_ijk);
+      // Re-using phi_E from Family I
+      // phi_E(p, mu01(z), grad_mu01(z), phi_k, dphi_k);
+      const real_t muz = mu0(z);
+      const Vector dmuz(grad_mu0(z));
+
+      Vector dmuphi(3), E(3), v(3);
+
+      for (int k=2; k<=p; k++)
+      {
+         dmuphi(0) = muz * dphi_k(k,0) + dmuz(0) * phi_k(k);
+         dmuphi(1) = muz * dphi_k(k,1) + dmuz(1) * phi_k(k);
+         dmuphi(2) = muz * dphi_k(k,2) + dmuz(2) * phi_k(k);
+         for (int j=2; j<=p; j++)
+            for (int i=0; i<p; i++, o++)
+            {
+               E(0) = E_ijk(i,j,0); E(1) = E_ijk(i,j,1); E(2) = E_ijk(i,j,2);
+               dmuphi.cross3D(E, v);
+               for (int l=0; l<3; l++)
+               {
+                  F(o, l) = muz * phi_k(k) * dE_ijk(i,j,l) + v(l);
+               }
+            }
+      }
+   }
+   // Family III
+   if (z < 1.0 && p >= 2)
+   {
+      phi_Q(p, mu01(z, xy, 2), grad_mu01(z, xy, 2),
+            mu01(z, xy, 1), grad_mu01(z, xy, 1), phi_ij, dphi_ijk);
+      const real_t muz = mu0(z);
+      const Vector dmuz(grad_mu0(z));
+
+      for (int j=2; j<=p; j++)
+         for (int i=2; i<=p; i++, o++)
+         {
+            const int n = std::max(i,j);
+            const real_t nmu = n * pow(muz, n-1);
+            F(o, 0) = nmu * (dphi_ijk(i,j,1) * dmuz(2) -
+                             dphi_ijk(i,j,2) * dmuz(1));
+            F(o, 1) = nmu * (dphi_ijk(i,j,2) * dmuz(0) -
+                             dphi_ijk(i,j,0) * dmuz(2));
+            F(o, 2) = nmu * (dphi_ijk(i,j,0) * dmuz(1) -
+                             dphi_ijk(i,j,1) * dmuz(0));
+         }
+   }
+   // Family IV
+   if (z < 1.0 && p >= 2)
+   {
+      // Re-using V_Q from Quadrilateral Face
+      phi_E(p, mu01(z), phi_k);
+
+      const real_t muz2 = pow(mu0(z), 2);
+
+      for (int k=2; k<=p; k++)
+         for (int j=0; j<p; j++)
+            for (int i=0; i<p; i++, o++)
+               for (int l=0; l<3; l++)
+               {
+                  F(o, l) = muz2 * VQ_ijk(i, j, l) * phi_k(k);
+               }
+
+   }
+   // Family V
+   if (z < 1.0 && p >= 2)
+   {
+      V_L(p, mu01(z, xy, 1), grad_mu01(z, xy, 1),
+          mu01(z, xy, 2), grad_mu01(z, xy, 2), mu0(z), grad_mu0(z), VL_ijk);
+
+      const real_t muz = mu1(z);
+
+      for (int j=2; j<=p; j++)
+         for (int i=2; i<=p; i++, o++)
+         {
+            const int n = std::max(i, j);
+            const real_t muzi = pow(muz, n-1);
+            for (int l=0; l<3; l++)
+            {
+               F(o, l) = muzi * VL_ijk(i, j, l);
+            }
+         }
+   }
+   // Family VI
+   if (z < 1.0 && p >= 2)
+   {
+      V_R(p, mu01(z, xy, 1), grad_mu01(z, xy, 1),
+          mu1(z, xy, 2), grad_mu1(z, xy, 2), mu0(z), grad_mu0(z), VR_ij);
+
+      const real_t muz = mu1(z);
+
+      for (int i=2; i<=p; i++, o++)
+      {
+         const real_t muzi = pow(muz, i-1);
+         for (int l=0; l<3; l++)
+         {
+            F(o, l) = muzi * VR_ij(i, l);
+         }
+      }
+   }
+   // Family VII
+   if (z < 1.0 && p >= 2)
+   {
+      V_R(p, mu01(z, xy, 2), grad_mu01(z, xy, 2),
+          mu1(z, xy, 1), grad_mu1(z,xy,1), mu0(z), grad_mu0(z), VR_ij);
+
+      const real_t muz = mu1(z);
+
+      for (int i=2; i<=p; i++, o++)
+      {
+         const real_t muzi = pow(muz, i-1);
+         for (int l=0; l<3; l++)
+         {
+            F(o, l) = muzi * VR_ij(i, l);
+         }
+      }
+   }
+}
+
+void RT_FuentesPyramidElement::calcDivBasis(const int p,
+                                            const IntegrationPoint &ip,
+                                            Vector &phi_k,
+                                            DenseMatrix &phi_ij,
+                                            DenseMatrix &dphi_k,
+                                            DenseTensor &VQ_ijk,
+                                            DenseTensor &VT_ijk,
+                                            DenseTensor &VTT_ijk,
+                                            DenseMatrix &dVTT_ij,
+                                            DenseTensor &E_ijk,
+                                            DenseTensor &dE_ijk,
+                                            DenseTensor &dphi_ijk,
+                                            DenseTensor &VL_ijk,
+                                            DenseMatrix &VR_ij,
+                                            Vector &dF) const
+{
+   real_t x = ip.x;
+   real_t y = ip.y;
+   real_t z = ip.z;
+   Vector xy({x,y});
+   real_t mu;
+
+   bool limz1 = false;
+   if (std::fabs(1.0 - z) < apex_tol)
+   {
+      limz1 = true;
+      z = 1.0 - apex_tol;
+      y = 0.5 * (1.0 - z);
+      x = 0.5 * (1.0 - z);
+      xy(0) = x; xy(1) = y;
+   }
+   zmax = std::max(z, zmax);
+
+   dF = 0.0;
+
+   int o = 0;
+
+   // Quadrilateral face
+   {
+      V_Q(p, mu01(z, xy, 1), mu01_grad_mu01(z, xy, 1),
+          mu01(z, xy, 2), mu01_grad_mu01(z, xy, 2),
+          VQ_ijk);
+
+      const real_t muz2 = pow(mu0(z), 2);
+      const Vector dmuz = grad_mu0(z);
+
+      const int o0 = o;
+      for (int j=0; j<p; j++)
+         for (int i=0; i<p; i++, o++)
+            for (int k=0; k<3; k++)
+            {
+               dF(o) += 3.0 * muz2 * dmuz(k) * VQ_ijk(i, j, k);
+            }
+
+      // Overwrite lowest order quadrilateral face DoF with known limiting
+      // value
+      if (limz1)
+      {
+         dF(o0) = -3.0;
+      }
+   }
+
+   // Triangular faces
+   {
+      Vector dmuz;
+
+      // (a,b) = (1,2), c = 0
+      V_T(p, nu012(z, xy, 1), nu012_grad_nu012(z, xy, 1), VT_ijk);
+      mu = mu0(z, xy, 2);
+      dmuz.Destroy(); dmuz = grad_mu0(z, xy, 2);
+      VT_T(p, nu012(z, xy, 1), nu01_grad_nu01(z, xy, 1),
+           nu012_grad_nu012(z, xy, 1), grad_nu2(z, xy, 1), mu, dmuz,
+           VTT_ijk, dVTT_ij);
+      const int o1 = o;
+      for (int j=0; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+         {
+            dF(o) = 0.5 * dVTT_ij(i, j);
+            for (int k=0; k<3; k++)
+            {
+               dF(o) += 0.5 * dmuz(k) * VT_ijk(i, j, k);
+            }
+         }
+
+      // (a,b) = (1,2), c = 1
+      mu = mu1(z, xy, 2);
+      dmuz.Destroy(); dmuz = grad_mu1(z, xy, 2);
+      VT_T(p, nu012(z, xy, 1), nu01_grad_nu01(z, xy, 1),
+           nu012_grad_nu012(z, xy, 1), grad_nu2(z, xy, 1), mu, dmuz,
+           VTT_ijk, dVTT_ij);
+      const int o2 = o;
+      for (int j=0; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+         {
+            dF(o) = 0.5 * dVTT_ij(i, j);
+            for (int k=0; k<3; k++)
+            {
+               dF(o) += 0.5 * dmuz(k) * VT_ijk(i, j, k);
+            }
+         }
+
+      // (a,b) = (2,1), c = 0
+      V_T(p, nu012(z, xy, 2), nu012_grad_nu012(z, xy, 2), VT_ijk);
+      mu = mu0(z, xy, 1);
+      dmuz.Destroy(); dmuz = grad_mu0(z, xy, 1);
+      VT_T(p, nu012(z, xy, 2), nu01_grad_nu01(z, xy, 2),
+           nu012_grad_nu012(z, xy, 2), grad_nu2(z, xy, 2), mu, dmuz,
+           VTT_ijk, dVTT_ij);
+      const int o3 = o;
+      for (int j=0; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+         {
+            dF(o) = 0.5 * dVTT_ij(i, j);
+            for (int k=0; k<3; k++)
+            {
+               dF(o) += 0.5 * dmuz(k) * VT_ijk(i, j, k);
+            }
+         }
+
+      // (a,b) = (2,1), c = 1
+      mu = mu1(z, xy, 1);
+      dmuz.Destroy(); dmuz = grad_mu1(z, xy, 1);
+      VT_T(p, nu012(z, xy, 2), nu01_grad_nu01(z, xy, 2),
+           nu012_grad_nu012(z, xy, 2), grad_nu2(z, xy, 2), mu, dmuz,
+           VTT_ijk, dVTT_ij);
+      const int o4 = o;
+      for (int j=0; j<p; j++)
+         for (int i=0; i+j<p; i++, o++)
+         {
+            dF(o) = 0.5 * dVTT_ij(i, j);
+            for (int k=0; k<3; k++)
+            {
+               dF(o) += 0.5 * dmuz(k) * VT_ijk(i, j, k);
+            }
+         }
+
+      // Overwrite lowest order triangular face DoFs with known limiting values
+      if (limz1)
+      {
+         dF(o1) =  1.5;
+         dF(o2) = -1.5;
+         dF(o3) = -1.5;
+         dF(o4) =  1.5;
+      }
+   }
+
+   // Interior
+   // Family I
+   if (p >= 2)
+   {
+      // Divergence is zero so skip ahead
+      o += (p-1) * (p-1) * p;
+   }
+
+   // Family II
+   if (p >= 2)
+   {
+      // Divergence is zero so skip ahead
+      o += (p-1) * (p-1) * p;
+   }
+   // Family III
+   if (p >= 2)
+   {
+      // Divergence is zero so skip ahead
+      o += (p-1) * (p-1);
+   }
+   // Family IV
+   if (p >= 2)
+   {
+      // Re-using V_Q from Quadrilateral Face
+      phi_E(p, mu01(z), grad_mu01(z), phi_k, dphi_k);
+
+      const real_t muz2 = pow(mu0(z), 2);
+      const Vector dmuz = grad_mu0(z);
+
+      for (int k=2; k<=p; k++)
+         for (int j=0; j<p; j++)
+            for (int i=0; i<p; i++, o++)
+               for (int l=0; l<3; l++)
+               {
+                  dF(o) += (muz2 * dphi_k(k, l) +
+                            2.0 * mu0(z) * phi_k(k) * dmuz(l)) * VQ_ijk(i, j, l);
+               }
+   }
+   // Family V
+   if (p >= 2)
+   {
+      V_L(p, mu01(z, xy, 1), grad_mu01(z, xy, 1),
+          mu01(z, xy, 2), grad_mu01(z, xy, 2), mu0(z), grad_mu0(z), VL_ijk);
+
+      const real_t muz = mu1(z);
+      const Vector dmuz = grad_mu1(z);
+
+      for (int j=2; j<=p; j++)
+         for (int i=2; i<=p; i++, o++)
+         {
+            const int n = std::max(i, j);
+            const real_t muzi = pow(muz, n-2);
+            for (int l=0; l<3; l++)
+            {
+               dF(o) += (n-1) * muzi * dmuz(l) * VL_ijk(i, j, l);
+            }
+         }
+   }
+   // Family VI
+   if (p >= 2)
+   {
+      V_R(p, mu01(z, xy, 1), grad_mu01(z, xy, 1),
+          mu1(z, xy, 2), grad_mu1(z, xy, 2), mu0(z), grad_mu0(z), VR_ij);
+
+      const real_t muz = mu1(z);
+      const Vector dmuz = grad_mu1(z);
+
+      for (int i=2; i<=p; i++, o++)
+      {
+         const real_t muzi = pow(muz, i-2);
+         for (int l=0; l<3; l++)
+         {
+            dF(o) += (i-1) * muzi * dmuz(l) * VR_ij(i, l);
+         }
+      }
+   }
+   // Family VII
+   if (p >= 2)
+   {
+      V_R(p, mu01(z, xy, 2), grad_mu01(z, xy, 2),
+          mu1(z, xy, 1), grad_mu1(z,xy,1), mu0(z), grad_mu0(z), VR_ij);
+
+      const real_t muz = mu1(z);
+      const Vector dmuz = grad_mu1(z);
+
+      for (int i=2; i<=p; i++, o++)
+      {
+         const real_t muzi = pow(muz, i-2);
+         for (int l=0; l<3; l++)
+         {
+            dF(o) += (i-1) * muzi * dmuz(l) * VR_ij(i, l);
+         }
+      }
+   }
+}
+
 const real_t RT_R1D_SegmentElement::nk[9] = { 1.,0.,0., 0.,1.,0., 0.,0.,1. };
 
 RT_R1D_SegmentElement::RT_R1D_SegmentElement(const int p,
diff --git a/fem/fe/fe_rt.hpp b/fem/fe/fe_rt.hpp
index abdd2ec19..2bae1fba8 100644
--- a/fem/fe/fe_rt.hpp
+++ b/fem/fe/fe_rt.hpp
@@ -15,6 +15,7 @@
 #include "fe_base.hpp"
 #include "fe_h1.hpp"
 #include "fe_l2.hpp"
+#include "fe_pyramid.hpp"
 
 namespace mfem
 {
@@ -334,6 +335,101 @@ public:
    { ProjectCurl_RT(nk, dof2nk, fe, Trans, curl); }
 };
 
+class RT_FuentesPyramidElement
+   : public VectorFiniteElement, public FuentesPyramid
+{
+private:
+   static const real_t nk[24];
+
+   mutable real_t zmax;
+
+#ifndef MFEM_THREAD_SAFE
+   mutable Vector      tmp1_i;
+   mutable DenseMatrix tmp1_ij;
+   mutable DenseMatrix tmp2_ij;
+   mutable DenseMatrix tmp3_ij;
+   mutable DenseMatrix tmp4_ij;
+   mutable DenseTensor tmp1_ijk;
+   mutable DenseTensor tmp2_ijk;
+   mutable DenseTensor tmp3_ijk;
+   mutable DenseTensor tmp4_ijk;
+   mutable DenseTensor tmp5_ijk;
+   mutable DenseTensor tmp6_ijk;
+   mutable DenseTensor tmp7_ijk;
+   mutable DenseMatrix u;
+   mutable Vector      divu;
+#endif
+   Array<int> dof2nk;
+   DenseMatrixInverse Ti;
+
+   void calcBasis(const int p, const IntegrationPoint &ip,
+                  Vector &phi_k,
+                  DenseMatrix &phi_ij,
+                  DenseMatrix &dphi_k,
+                  DenseTensor &VQ_ijk,
+                  DenseTensor &VT_ijk,
+                  DenseTensor &VTT_ijk,
+                  DenseTensor &E_ijk, DenseTensor &dE_ijk,
+                  DenseTensor &dphi_ijk,
+                  DenseTensor &VL_ijk,
+                  DenseMatrix &VR_ij,
+                  DenseMatrix &F) const;
+
+   void calcDivBasis(const int p, const IntegrationPoint &ip,
+                     Vector &phi_k,
+                     DenseMatrix &phi_ij,
+                     DenseMatrix &dphi_k,
+                     DenseTensor &VQ_ijk,
+                     DenseTensor &VT_ijk,
+                     DenseTensor &VTT_ijk, DenseMatrix &dVTT_ij,
+                     DenseTensor &E_ijk, DenseTensor &dE_ijk,
+                     DenseTensor &dphi_ijk,
+                     DenseTensor &VL_ijk,
+                     DenseMatrix &VR_ij,
+                     Vector &dF) const;
+
+public:
+   RT_FuentesPyramidElement(const int p);
+   virtual void CalcVShape(const IntegrationPoint &ip,
+                           DenseMatrix &shape) const;
+   virtual void CalcVShape(ElementTransformation &Trans,
+                           DenseMatrix &shape) const
+   { CalcVShape_RT(Trans, shape); }
+   virtual void CalcDivShape(const IntegrationPoint &ip,
+                             Vector &divshape) const;
+   virtual void GetLocalInterpolation(ElementTransformation &Trans,
+                                      DenseMatrix &I) const
+   { LocalInterpolation_RT(*this, nk, dof2nk, Trans, I); }
+   virtual void GetLocalRestriction(ElementTransformation &Trans,
+                                    DenseMatrix &R) const
+   { LocalRestriction_RT(nk, dof2nk, Trans, R); }
+   virtual void GetTransferMatrix(const FiniteElement &fe,
+                                  ElementTransformation &Trans,
+                                  DenseMatrix &I) const
+   { LocalInterpolation_RT(CheckVectorFE(fe), nk, dof2nk, Trans, I); }
+   using FiniteElement::Project;
+   virtual void Project(VectorCoefficient &vc,
+                        ElementTransformation &Trans, Vector &dofs) const
+   { Project_RT(nk, dof2nk, vc, Trans, dofs); }
+   virtual void ProjectMatrixCoefficient(
+      MatrixCoefficient &mc, ElementTransformation &T, Vector &dofs) const
+   { ProjectMatrixCoefficient_RT(nk, dof2nk, mc, T, dofs); }
+   virtual void Project(const FiniteElement &fe, ElementTransformation &Trans,
+                        DenseMatrix &I) const
+   { Project_RT(nk, dof2nk, fe, Trans, I); }
+   virtual void ProjectCurl(const FiniteElement &fe,
+                            ElementTransformation &Trans,
+                            DenseMatrix &curl) const
+   { ProjectCurl_RT(nk, dof2nk, fe, Trans, curl); }
+
+   void CalcRawVShape(const IntegrationPoint &ip,
+                      DenseMatrix &shape) const;
+
+   void CalcRawDivShape(const IntegrationPoint &ip,
+                        Vector &dshape) const;
+
+   real_t GetZetaMax() const { return zmax; }
+};
 
 /// Arbitrary order, three component, Raviart-Thomas elements in 1D on a segment
 /** RT_R1D_SegmentElement provides a representation of a three component
diff --git a/fem/fe_coll.cpp b/fem/fe_coll.cpp
index 15e5aa224..1d2759a98 100644
--- a/fem/fe_coll.cpp
+++ b/fem/fe_coll.cpp
@@ -106,8 +106,6 @@ int FiniteElementCollection::HasFaceDofs(Geometry::Type geom, int p) const
       case Geometry::CUBE:
          return GetNumDof(Geometry::SQUARE, p);
       case Geometry::PRISM:
-         return max(GetNumDof(Geometry::TRIANGLE, p),
-                    GetNumDof(Geometry::SQUARE, p));
       case Geometry::PYRAMID:
          return max(GetNumDof(Geometry::TRIANGLE, p),
                     GetNumDof(Geometry::SQUARE, p));
@@ -1673,7 +1671,8 @@ const int *RT1_3DFECollection::DofOrderForOrientation(Geometry::Type GeomType,
 }
 
 
-H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
+H1_FECollection::H1_FECollection(const int p, const int dim, const int btype,
+                                 const int pyrtype)
    : FiniteElementCollection(p)
    , dim(dim)
 {
@@ -1874,12 +1873,25 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
          H1_dof[Geometry::TETRAHEDRON] = (TriDof*pm3)/3;
          H1_dof[Geometry::CUBE] = QuadDof*pm1;
          H1_dof[Geometry::PRISM] = TriDof*pm1;
-         H1_dof[Geometry::PYRAMID] = 0;
+         if (pyrtype == 0 || b_type == BasisType::Positive)
+         {
+            H1_dof[Geometry::PYRAMID] = pm2*pm1*(2*p-3)/6; // Bergot (JSC)
+         }
+         else if (pyrtype == 1)
+         {
+            H1_dof[Geometry::PYRAMID] = pm1*pm1*pm1; // Fuentes
+         }
+         else
+         {
+            H1_dof[Geometry::PYRAMID] = (p-1)*(p-2)/2;
+            // H1_dof[Geometry::PYRAMID] = 0;
+         }
          if (b_type == BasisType::Positive)
          {
             H1_Elements[Geometry::TETRAHEDRON] = new H1Pos_TetrahedronElement(p);
             H1_Elements[Geometry::CUBE] = new H1Pos_HexahedronElement(p);
             H1_Elements[Geometry::PRISM] = new H1Pos_WedgeElement(p);
+            H1_Elements[Geometry::PYRAMID] = new H1Pos_PyramidElement(p);
          }
          else
          {
@@ -1887,8 +1899,16 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
                new H1_TetrahedronElement(p, btype);
             H1_Elements[Geometry::CUBE] = new H1_HexahedronElement(p, btype);
             H1_Elements[Geometry::PRISM] = new H1_WedgeElement(p, btype);
+            if (pyrtype == 0)
+            {
+               H1_Elements[Geometry::PYRAMID] = new H1_BergotPyramidElement(p, btype);
+            }
+            else
+            {
+               H1_Elements[Geometry::PYRAMID] = new H1_FuentesPyramidElement(p, btype);
+            }
          }
-         H1_Elements[Geometry::PYRAMID] = new LinearPyramidFiniteElement;
+         // H1_Elements[Geometry::PYRAMID] = new LinearPyramidFiniteElement;
 
          const int &TetDof = H1_dof[Geometry::TETRAHEDRON];
          TetDofOrd[0] = (TetDof > 0) ? new int[24*TetDof] : nullptr;
@@ -1986,6 +2006,8 @@ H1_FECollection::H1_FECollection(const int p, const int dim, const int btype)
 const FiniteElement *
 H1_FECollection::FiniteElementForGeometry(Geometry::Type GeomType) const
 {
+   return H1_Elements[GeomType];
+   /*
    if (GeomType != Geometry::PYRAMID || this->GetOrder() == 1)
    {
       return H1_Elements[GeomType];
@@ -1997,6 +2019,7 @@ H1_FECollection::FiniteElementForGeometry(Geometry::Type GeomType) const
                  "for order > 1.");
       return NULL;
    }
+   */
 }
 
 const int *H1_FECollection::DofOrderForOrientation(Geometry::Type GeomType,
@@ -2099,7 +2122,7 @@ H1_Trace_FECollection::H1_Trace_FECollection(const int p, const int dim,
 
 
 L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
-                                 const int map_type)
+                                 const int map_type, const int pyr_type)
    : FiniteElementCollection(p)
    , dim(dim)
    , m_type(map_type)
@@ -2230,6 +2253,7 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
          L2_Elements[Geometry::TETRAHEDRON] = new L2Pos_TetrahedronElement(p);
          L2_Elements[Geometry::CUBE] = new L2Pos_HexahedronElement(p);
          L2_Elements[Geometry::PRISM] = new L2Pos_WedgeElement(p);
+         L2_Elements[Geometry::PYRAMID] = new L2Pos_PyramidElement(p);
       }
       else
       {
@@ -2237,13 +2261,25 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
             new L2_TetrahedronElement(p, btype);
          L2_Elements[Geometry::CUBE] = new L2_HexahedronElement(p, btype);
          L2_Elements[Geometry::PRISM] = new L2_WedgeElement(p, btype);
+         if (pyr_type == 0)
+         {
+            L2_Elements[Geometry::PYRAMID] = new L2_BergotPyramidElement(p, btype);
+         }
+         else
+         {
+            L2_Elements[Geometry::PYRAMID] = new L2_FuentesPyramidElement(p, btype);
+         }
       }
-      L2_Elements[Geometry::PYRAMID] = new P0PyrFiniteElement;
+      // L2_Elements[Geometry::PYRAMID] = new P0PyrFiniteElement;
 
       L2_Elements[Geometry::TETRAHEDRON]->SetMapType(map_type);
       L2_Elements[Geometry::CUBE]->SetMapType(map_type);
       L2_Elements[Geometry::PRISM]->SetMapType(map_type);
       L2_Elements[Geometry::PYRAMID]->SetMapType(map_type);
+      if (b_type != BasisType::Positive)
+      {
+         L2_Elements[Geometry::PYRAMID]->SetMapType(map_type);
+      }
       // Trace element use the default Gauss-Legendre nodal points for positive basis
       if (b_type == BasisType::Positive)
       {
@@ -2259,7 +2295,9 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
       const int TetDof = L2_Elements[Geometry::TETRAHEDRON]->GetDof();
       const int HexDof = L2_Elements[Geometry::CUBE]->GetDof();
       const int PriDof = L2_Elements[Geometry::PRISM]->GetDof();
-      const int MaxDof = std::max(TetDof, std::max(PriDof, HexDof));
+      const int PyrDof = L2_Elements[Geometry::PYRAMID]->GetDof();
+      const int MaxDof = std::max(std::max(TetDof, PyrDof),
+                                  std::max(PriDof, HexDof));
 
       TetDofOrd[0] = (TetDof > 0) ? new int[24*TetDof] : nullptr;
       for (int i = 1; i < 24; i++)
@@ -2367,6 +2405,8 @@ L2_FECollection::L2_FECollection(const int p, const int dim, const int btype,
 const FiniteElement *
 L2_FECollection::FiniteElementForGeometry(Geometry::Type GeomType) const
 {
+   return L2_Elements[GeomType];
+   /*
    if (GeomType != Geometry::PYRAMID || this->GetOrder() == 0)
    {
       return L2_Elements[GeomType];
@@ -2378,6 +2418,7 @@ L2_FECollection::FiniteElementForGeometry(Geometry::Type GeomType) const
                  "for order > 0.");
       return NULL;
    }
+   */
 }
 
 const int *L2_FECollection::DofOrderForOrientation(Geometry::Type GeomType,
@@ -2475,8 +2516,9 @@ RT_FECollection::RT_FECollection(const int order, const int dim,
       RT_Elements[Geometry::PRISM] = new RT_WedgeElement(p);
       RT_dof[Geometry::PRISM] = p*pp1*(3*p + 4)/2;
 
-      RT_Elements[Geometry::PYRAMID] = new RT0PyrFiniteElement(false);
-      RT_dof[Geometry::PYRAMID] = 0;
+      // RT_Elements[Geometry::PYRAMID] = new RT0PyrFiniteElement(false);
+      RT_Elements[Geometry::PYRAMID] = new RT_FuentesPyramidElement(p);
+      RT_dof[Geometry::PYRAMID] = 3*p*pp1*pp1;
    }
    else
    {
@@ -2623,17 +2665,20 @@ void RT_FECollection::InitFaces(const int p, const int dim_,
 const FiniteElement *
 RT_FECollection::FiniteElementForGeometry(Geometry::Type GeomType) const
 {
-   if (GeomType != Geometry::PYRAMID || this->GetOrder() == 1)
-   {
-      return RT_Elements[GeomType];
-   }
-   else
-   {
-      if (error_mode == RETURN_NULL) { return nullptr; }
-      MFEM_ABORT("RT Pyramid basis functions are not yet supported "
-                 "for order > 0.");
-      return NULL;
-   }
+   /*
+    if (GeomType != Geometry::PYRAMID || this->GetOrder() == 1)
+    {
+       return RT_Elements[GeomType];
+    }
+    else
+    {
+       if (error_mode == RETURN_NULL) { return nullptr; }
+       MFEM_ABORT("RT Pyramid basis functions are not yet supported "
+                  "for order > 0.");
+       return NULL;
+    }
+   */
+   return RT_Elements[GeomType];
 }
 
 const int *RT_FECollection::DofOrderForOrientation(Geometry::Type GeomType,
@@ -2901,25 +2946,30 @@ ND_FECollection::ND_FECollection(const int p, const int dim,
       ND_Elements[Geometry::PRISM] = new ND_WedgeElement(p);
       ND_dof[Geometry::PRISM] = p*pm1*(3*p-4)/2;
 
-      ND_Elements[Geometry::PYRAMID] = new Nedelec1PyrFiniteElement;
-      ND_dof[Geometry::PYRAMID] = 0;
+      // ND_Elements[Geometry::PYRAMID] = new Nedelec1PyrFiniteElement;
+      // ND_dof[Geometry::PYRAMID] = 0;
+      ND_Elements[Geometry::PYRAMID] = new ND_FuentesPyramidElement(p);
+      ND_dof[Geometry::PYRAMID] = 3*p*pm1*pm1;
    }
 }
 
 const FiniteElement *
 ND_FECollection::FiniteElementForGeometry(Geometry::Type GeomType) const
 {
-   if (GeomType != Geometry::PYRAMID || this->GetOrder() == 1)
-   {
-      return ND_Elements[GeomType];
-   }
-   else
-   {
-      if (error_mode == RETURN_NULL) { return nullptr; }
-      MFEM_ABORT("ND Pyramid basis functions are not yet supported "
-                 "for order > 1.");
-      return NULL;
-   }
+   /*
+    if (GeomType != Geometry::PYRAMID || this->GetOrder() == 1)
+    {
+       return ND_Elements[GeomType];
+    }
+    else
+    {
+       if (error_mode == RETURN_NULL) { return nullptr; }
+       MFEM_ABORT("ND Pyramid basis functions are not yet supported "
+                  "for order > 1.");
+       return NULL;
+    }
+   */
+   return ND_Elements[GeomType];
 }
 
 const StatelessDofTransformation *
diff --git a/fem/fe_coll.hpp b/fem/fe_coll.hpp
index e7f58d0d5..1f022f7d4 100644
--- a/fem/fe_coll.hpp
+++ b/fem/fe_coll.hpp
@@ -278,7 +278,8 @@ protected:
 
 public:
    explicit H1_FECollection(const int p, const int dim = 3,
-                            const int btype = BasisType::GaussLobatto);
+                            const int btype = BasisType::GaussLobatto,
+                            const int pyrtype = 1);
 
    const FiniteElement *
    FiniteElementForGeometry(Geometry::Type GeomType) const override;
@@ -354,7 +355,8 @@ private:
 public:
    L2_FECollection(const int p, const int dim,
                    const int btype = BasisType::GaussLegendre,
-                   const int map_type = FiniteElement::VALUE);
+                   const int map_type = FiniteElement::VALUE,
+                   const int pyrtype = 1);
 
    const FiniteElement *
    FiniteElementForGeometry(Geometry::Type GeomType) const override;
diff --git a/fem/fespace.cpp b/fem/fespace.cpp
index 9e1c7a527..da8f3a3a4 100644
--- a/fem/fespace.cpp
+++ b/fem/fespace.cpp
@@ -1885,6 +1885,14 @@ void FiniteElementSpace::RefinementOperator::ConstructDoFTransArray()
          old_DoFTransArray[Geometry::PRISM] =
             new ND_WedgeDofTransformation(nd_pri->GetOrder());
       }
+
+      const FiniteElement *nd_pyr =
+         fec_ref->FiniteElementForGeometry(Geometry::PYRAMID);
+      if (nd_pyr)
+      {
+         old_DoFTransArray[Geometry::PYRAMID] =
+            new ND_PyramidDofTransformation(nd_pyr->GetOrder());
+      }
    }
 }
 
@@ -2565,6 +2573,14 @@ void FiniteElementSpace::ConstructDoFTransArray()
          DoFTransArray[Geometry::PRISM] =
             new ND_WedgeDofTransformation(nd_pri->GetOrder());
       }
+
+      const FiniteElement *nd_pyr =
+         fec->FiniteElementForGeometry(Geometry::PYRAMID);
+      if (nd_pyr)
+      {
+         DoFTransArray[Geometry::PYRAMID] =
+            new ND_PyramidDofTransformation(nd_pyr->GetOrder());
+      }
    }
 }
 
diff --git a/fem/intrules.cpp b/fem/intrules.cpp
index 975cb227d..4cdd5e362 100644
--- a/fem/intrules.cpp
+++ b/fem/intrules.cpp
@@ -1791,10 +1791,10 @@ IntegrationRule *IntegrationRules::TetrahedronIntegrationRule(int Order)
 IntegrationRule *IntegrationRules::PyramidIntegrationRule(int Order)
 {
    // This is a simple integration rule adapted from an integration
-   // rule for a cube which seems to be adequate for now. When we
-   // implement high order finite elements for pyramids we should
-   // revisit this and see if we can improve upon it.
-   const IntegrationRule &irc = Get(Geometry::CUBE, Order);
+   // rule for a cube which seems to be adequate for now. We should continue
+   // to search for a more appropriate integration rule designed specifically
+   // for pyramid elements.
+   const IntegrationRule &irc = Get(Geometry::CUBE, Order + 2);
    int npts = irc.GetNPoints();
    AllocIntRule(PyramidIntRules, Order);
    PyramidIntRules[Order] = new IntegrationRule(npts);
@@ -1807,7 +1807,7 @@ IntegrationRule *IntegrationRules::PyramidIntegrationRule(int Order)
       ipp.x = ipc.x * (1.0 - ipc.z);
       ipp.y = ipc.y * (1.0 - ipc.z);
       ipp.z = ipc.z;
-      ipp.weight = ipc.weight / 3.0;
+      ipp.weight = ipc.weight * pow(1.0 - ipc.z, 2);
    }
    return PyramidIntRules[Order];
 }
diff --git a/makefile b/makefile
index 55a1d9969..545c60947 100644
--- a/makefile
+++ b/makefile
@@ -377,6 +377,7 @@ MFEM_EXT_LIBS  ?= $(ALL_LIBS) $(LDFLAGS) $(LDFLAGS_INTERNAL)
 MFEM_LIBS      ?= $(if $(shared),$(BUILD_RPATH)) -L@MFEM_LIB_DIR@ -lmfem\
    @MFEM_EXT_LIBS@
 MFEM_LIB_FILE  ?= @MFEM_LIB_DIR@/libmfem.$(if $(shared),$(SO_VER),a)
+MFEM_LIBE_FILE ?= @MFEM_LIB_DIR@/libmfem-extras.$(if $(shared),$(SO_VER),a)
 MFEM_BUILD_TAG ?= $(shell uname -snm)
 MFEM_PREFIX    ?= $(PREFIX)
 MFEM_INC_DIR   ?= $(if $(CONFIG_FILE_DEF),@MFEM_BUILD_DIR@,@MFEM_DIR@)
@@ -410,6 +411,7 @@ ifneq (,$(filter install,$(MAKECMDGOALS)))
    MFEM_LIBS     = $(if $(shared),$(INSTALL_RPATH)) -L@MFEM_LIB_DIR@ -lmfem\
       @MFEM_EXT_LIBS@
    MFEM_LIB_FILE = @MFEM_LIB_DIR@/libmfem.$(if $(shared),$(SO_VER),a)
+   MFEM_LIBE_FILE = @MFEM_LIB_DIR@/libmfem-extras.$(if $(shared),$(SO_VER),a)
    ifeq ($(MFEM_USE_OCCA),YES)
       ifneq ($(MFEM_INSTALL_DIR),$(abspath $(PREFIX)))
          $(error OCCA is enabled: PREFIX must be set during configuration!)
@@ -443,9 +445,14 @@ RELSRC_FILES = $(patsubst $(SRC)%,%,$(SOURCE_FILES))
 OBJECT_FILES = $(patsubst $(SRC)%,$(BLD)%,$(SOURCE_FILES:.cpp=.o))
 OKL_DIRS = fem
 
-.PHONY: lib all clean distclean install config status info deps serial parallel	\
-	debug pdebug cuda hip pcuda cudebug pcudebug hpc style check test unittest \
-	deprecation-warnings
+EXTRA_DIRS = miniapps/common
+EXTRA_SOURCE_FILES = $(foreach dir,$(EXTRA_DIRS),$(wildcard $(SRC)$(dir)/*.cpp))
+EXTRA_RELSRC_FILES = $(patsubst $(SRC)%,%,$(EXTRA_SOURCE_FILES))
+EXTRA_OBJECT_FILES = $(patsubst $(SRC)%,$(BLD)%,$(EXTRA_SOURCE_FILES:.cpp=.o))
+
+.PHONY: lib all clean distclean install config status info deps serial parallel\
+	debug pdebug cuda hip pcuda cudebug pcudebug hpc style check test\
+	unittest deprecation-warnings
 
 .SUFFIXES:
 .SUFFIXES: .cpp .o
@@ -456,6 +463,8 @@ OKL_DIRS = fem
 
 # Default rule.
 lib: $(if $(static),$(BLD)libmfem.a) $(if $(shared),$(BLD)libmfem.$(SO_EXT))
+lib-extras: $(if $(static),$(BLD)libmfem-extras.a) \
+        $(if $(shared),$(BLD)libmfem-extras.$(SO_EXT))
 
 # Flags used for compiling all source files.
 MFEM_BUILD_FLAGS = $(MFEM_PICFLAG) $(MFEM_CPPFLAGS) $(MFEM_CXXFLAGS)\
@@ -465,6 +474,9 @@ MFEM_BUILD_FLAGS = $(MFEM_PICFLAG) $(MFEM_CPPFLAGS) $(MFEM_CXXFLAGS)\
 $(OBJECT_FILES): $(BLD)%.o: $(SRC)%.cpp $(CONFIG_MK)
 	$(MFEM_CXX) $(MFEM_BUILD_FLAGS) -c $(<) -o $(@)
 
+$(EXTRA_OBJECT_FILES): $(BLD)%.o: $(SRC)%.cpp $(CONFIG_MK)
+	$(MFEM_CXX) $(MFEM_FLAGS) -c $(<) -o $(@)
+
 all: examples miniapps $(TEST_DIRS)
 
 .PHONY: miniapps $(EM_DIRS) $(TEST_DIRS)
@@ -488,6 +500,13 @@ $(BLD)libmfem.$(SO_EXT): $(BLD)libmfem.$(SO_VER)
 	cd $(@D) && ln -sf $(<F) $(@F)
 	@$(MAKE) deprecation-warnings
 
+$(BLD)libmfem-extras.a: $(EXTRA_OBJECT_FILES)
+	$(AR) $(ARFLAGS) $(@) $(EXTRA_OBJECT_FILES)
+	$(RANLIB) $(@)
+
+$(BLD)libmfem-extras.$(SO_EXT): $(BLD)libmfem-extras.$(SO_VER)
+	cd $(@D) && ln -sf $(<F) $(@F)
+
 # If some of the external libraries are build without -fPIC, linking shared MFEM
 # library may fail. In such cases, one may set EXT_LIBS on the command line.
 EXT_LIBS = $(MFEM_EXT_LIBS)
@@ -495,6 +514,10 @@ $(BLD)libmfem.$(SO_VER): $(OBJECT_FILES)
 	$(MFEM_CXX) $(MFEM_LINK_FLAGS) $(BUILD_SOFLAGS) $(OBJECT_FILES) \
 	   $(EXT_LIBS) -o $(@)
 
+$(BLD)libmfem-extras.$(SO_VER): $(EXTRA_OBJECT_FILES)
+	$(MFEM_CXX) $(MFEM_BUILD_FLAGS) $(BUILD_SOFLAGS) $(EXTRA_OBJECT_FILES) \
+	   $(EXT_LIBS) -o $(@)
+
 # Shortcut targets options
 serial debug cuda hip cudebug hipdebug:           M_MPI=NO
 parallel pdebug pcuda pcudebug phip phipdebug:    M_MPI=YES
diff --git a/mesh/mesh.cpp b/mesh/mesh.cpp
index 364c051d4..6f3cd9db1 100644
--- a/mesh/mesh.cpp
+++ b/mesh/mesh.cpp
@@ -3650,9 +3650,9 @@ void Mesh::Make3D(int nx, int ny, int nz, Element::Type type,
          ind[0] = VTX(x  , y  , z  );
          ind[1] = VTX(x+1, y  , z  );
          ind[2] = VTX(x+1, y+1, z  );
-         ind[3] = VTX(x  , y+1, z  );
-         ind[4] = VTX(x  , y  , z+1);
-         ind[5] = VTX(x+1, y  , z+1);
+         ind[3] = VTX(x, y+1, z  );
+         ind[4] = VTX(x, y, z+1);
+         ind[5] = VTX(x+1, y, z+1);
          ind[6] = VTX(x+1, y+1, z+1);
          ind[7] = VTX(x  , y+1, z+1);
          // *INDENT-ON*
@@ -3672,9 +3672,9 @@ void Mesh::Make3D(int nx, int ny, int nz, Element::Type type,
                ind[0] = VTX(x  , y  , z  );
                ind[1] = VTX(x+1, y  , z  );
                ind[2] = VTX(x+1, y+1, z  );
-               ind[3] = VTX(x  , y+1, z  );
-               ind[4] = VTX(x  , y  , z+1);
-               ind[5] = VTX(x+1, y  , z+1);
+               ind[3] = VTX(x, y+1, z  );
+               ind[4] = VTX(x, y, z+1);
+               ind[5] = VTX(x+1, y, z+1);
                ind[6] = VTX(x+1, y+1, z+1);
                ind[7] = VTX(  x, y+1, z+1);
                // *INDENT-ON*
@@ -3837,6 +3837,7 @@ void Mesh::Make3D(int nx, int ny, int nz, Element::Type type,
    }
 
 #undef VTX
+#undef VTXP
 
 #if 0
    ofstream test_stream("debug.mesh");
@@ -9970,6 +9971,10 @@ void Mesh::UniformRefinement3D_base(Array<int> *f2qf_ptr, DSTable *v_to_v_p,
             tet->Init(oedge+e[3], oedge+e[7], oedge+e[4],
                       oface+qf0, attr);
 #endif
+            // Tetrahedral elements may be new to this mesh so ensure that
+            // the relevant flags are switched on
+            mesh_geoms |= (1 << Geometry::TETRAHEDRON);
+            meshgen |= 1;
          }
          break;
 
diff --git a/mesh/pyramid.hpp b/mesh/pyramid.hpp
index 5188a3da2..79e191a15 100644
--- a/mesh/pyramid.hpp
+++ b/mesh/pyramid.hpp
@@ -75,7 +75,7 @@ public:
    virtual ~Pyramid() = default;
 };
 
-extern class LinearPyramidFiniteElement PyramidFE;
+extern MFEM_EXPORT class LinearPyramidFiniteElement PyramidFE;
 
 }
 
diff --git a/miniapps/common/mesh_extras.cpp b/miniapps/common/mesh_extras.cpp
index 18f8b1a82..a3f0dba63 100644
--- a/miniapps/common/mesh_extras.cpp
+++ b/miniapps/common/mesh_extras.cpp
@@ -129,6 +129,25 @@ ElementMeshStream::ElementMeshStream(Element::Type e)
                << "1 0 1" << endl
                << "0 1 1" << endl;
          break;
+      case Element::PYRAMID:
+         *this << "dimension" << endl << 3 << endl
+               << "elements" << endl << 1 << endl
+               << "1 7 0 1 2 3 4" << endl
+               << "boundary" << endl << 5 << endl
+               << "1 3 3 2 1 0" << endl
+               << "1 2 0 1 4" << endl
+               << "1 2 1 2 4" << endl
+               << "1 2 3 4 2" << endl
+               << "1 2 0 4 3" << endl
+               << "vertices" << endl
+               << "5" << endl
+               << "3" << endl
+               << "0 0 0" << endl
+               << "1 0 0" << endl
+               << "1 1 0" << endl
+               << "0 1 0" << endl
+               << "0 0 1" << endl;
+         break;
       default:
          mfem_error("Invalid element type!");
          break;
diff --git a/miniapps/tools/display-basis.cpp b/miniapps/tools/display-basis.cpp
index f2c8cdb7f..1e00d735f 100644
--- a/miniapps/tools/display-basis.cpp
+++ b/miniapps/tools/display-basis.cpp
@@ -138,7 +138,7 @@ int main(int argc, char *argv[])
    OptionsParser args(argc, argv);
    args.AddOption(&eInt, "-e", "--elem-type",
                   "Element Type: (1-Segment, 2-Triangle, 3-Quadrilateral, "
-                  "4-Tetrahedron, 5-Hexahedron, 6-Wedge)");
+                  "4-Tetrahedron, 5-Hexahedron, 6-Wedge, 7-Pyramid)");
    args.AddOption(&bInt, "-b", "--basis-type",
                   "Basis Function Type (0-H1, 1-Nedelec, 2-Raviart-Thomas, "
                   "3-L2, 4-Fixed Order Cont.,\n\t5-Gaussian Discontinuous (2D),"
@@ -275,11 +275,12 @@ int main(int argc, char *argv[])
             cout <<
                  "4) Tetrahedron\n"
                  "5) Hexahedron\n"
-                 "6) Wedge\n";
+                 "6) Wedge\n"
+                 "7) Pyramid\n";
          }
          cout << "enter new element type --> " << flush;
          cin >> eInt;
-         if ( eInt <= 0 || eInt > 6 )
+         if ( eInt <= 0 || eInt > 7 )
          {
             cout << "invalid element type \"" << eInt << "\"" << endl << flush;
          }
@@ -532,6 +533,8 @@ string elemTypeStr(const Element::Type & eType)
          return "HEXAHEDRON";
       case Element::WEDGE:
          return "WEDGE";
+      case Element::PYRAMID:
+         return "PYRAMID";
       default:
          return "INVALID";
    };
@@ -553,7 +556,7 @@ bool
 elemIs3D(const Element::Type & eType)
 {
    return eType == Element::TETRAHEDRON || eType == Element::HEXAHEDRON ||
-          eType == Element::WEDGE;
+          eType == Element::WEDGE || eType == Element::PYRAMID;
 }
 
 string
diff --git a/tests/unit/CMakeLists.txt b/tests/unit/CMakeLists.txt
index 5e0a05724..176f8d916 100644
--- a/tests/unit/CMakeLists.txt
+++ b/tests/unit/CMakeLists.txt
@@ -84,6 +84,9 @@ set(UNIT_TESTS_SRCS
   fem/test_face_permutation.cpp
   fem/test_face_restriction.cpp
   fem/test_fe.cpp
+  fem/test_fe_compatibility.cpp
+  fem/test_fe_fixed.cpp
+  fem/test_fe_symmetry.cpp
   fem/test_get_value.cpp
   fem/test_getderivative.cpp
   fem/test_getgradient.cpp
diff --git a/tests/unit/fem/test_3d_bilininteg.cpp b/tests/unit/fem/test_3d_bilininteg.cpp
index eb8265367..0c68217c6 100644
--- a/tests/unit/fem/test_3d_bilininteg.cpp
+++ b/tests/unit/fem/test_3d_bilininteg.cpp
@@ -17,6 +17,9 @@ using namespace mfem;
 namespace bilininteg_3d
 {
 
+static int first_3D_et = (int)Element::TETRAHEDRON;
+static int  last_3D_et = (int)Element::PYRAMID;
+
 double zero3(const Vector & x) { return 0.0; }
 void Zero3(const Vector & x, Vector & v) { v.SetSize(3); v = 0.0; }
 
@@ -531,8 +534,7 @@ TEST_CASE("3D Bilinear Mass Integrators",
    FunctionCoefficient q3_coef(q3);
    FunctionCoefficient qf3_coef(qf3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -807,8 +809,7 @@ TEST_CASE("3D Bilinear Vector Mass Integrators",
    VectorFunctionCoefficient DF3_coef(dim, DF3);
    VectorFunctionCoefficient MF3_coef(dim, MF3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -1891,153 +1892,152 @@ TEST_CASE("3D Bilinear Gradient Integrator",
    VectorFunctionCoefficient Ddf3_coef(dim, DGrad_f3);
    VectorFunctionCoefficient Mdf3_coef(dim, MGrad_f3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
-   {
-      Mesh mesh =
-         Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
+   auto type = GENERATE(range(first_3D_et, last_3D_et + 1));
+   CAPTURE(type);
 
-      SECTION("Operators on H1 for element type " + std::to_string(type))
-      {
-         H1_FECollection    fec_h1(order, dim);
-         FiniteElementSpace fespace_h1(&mesh, &fec_h1);
+   Mesh mesh =
+      Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
 
-         GridFunction f_h1(&fespace_h1); f_h1.ProjectCoefficient(f3_coef);
+   SECTION("Operators on H1 for element type " + std::to_string(type))
+   {
+      H1_FECollection    fec_h1(order, dim);
+      FiniteElementSpace fespace_h1(&mesh, &fec_h1);
 
-         SECTION("Mapping H1 to ND")
-         {
-            ND_FECollection    fec_nd(order, dim);
-            FiniteElementSpace fespace_nd(&mesh, &fec_nd);
+      GridFunction f_h1(&fespace_h1); f_h1.ProjectCoefficient(f3_coef);
 
-            BilinearForm m_nd(&fespace_nd);
-            m_nd.AddDomainIntegrator(new VectorFEMassIntegrator());
-            m_nd.Assemble();
-            m_nd.Finalize();
+      SECTION("Mapping H1 to ND")
+      {
+         ND_FECollection    fec_nd(order, dim);
+         FiniteElementSpace fespace_nd(&mesh, &fec_nd);
 
-            GridFunction g_nd(&fespace_nd);
+         BilinearForm m_nd(&fespace_nd);
+         m_nd.AddDomainIntegrator(new VectorFEMassIntegrator());
+         m_nd.Assemble();
+         m_nd.Finalize();
 
-            Vector tmp_nd(fespace_nd.GetNDofs());
+         GridFunction g_nd(&fespace_nd);
 
-            SECTION("Without Coefficient")
-            {
-               MixedBilinearForm blf(&fespace_h1, &fespace_nd);
-               blf.AddDomainIntegrator(new MixedVectorGradientIntegrator());
-               blf.Assemble();
-               blf.Finalize();
+         Vector tmp_nd(fespace_nd.GetNDofs());
 
-               blf.Mult(f_h1, tmp_nd); g_nd = 0.0;
-               CG(m_nd, tmp_nd, g_nd, 0, 200, cg_rtol * cg_rtol, 0.0);
+         SECTION("Without Coefficient")
+         {
+            MixedBilinearForm blf(&fespace_h1, &fespace_nd);
+            blf.AddDomainIntegrator(new MixedVectorGradientIntegrator());
+            blf.Assemble();
+            blf.Finalize();
 
-               REQUIRE( g_nd.ComputeL2Error(df3_coef) < tol );
-            }
-            SECTION("With Scalar Coefficient")
-            {
-               MixedBilinearForm blf(&fespace_h1, &fespace_nd);
-               blf.AddDomainIntegrator(
-                  new MixedVectorGradientIntegrator(q3_coef));
-               blf.Assemble();
-               blf.Finalize();
+            blf.Mult(f_h1, tmp_nd); g_nd = 0.0;
+            CG(m_nd, tmp_nd, g_nd, 0, 200, cg_rtol * cg_rtol, 0.0);
 
-               blf.Mult(f_h1, tmp_nd); g_nd = 0.0;
-               CG(m_nd, tmp_nd, g_nd, 0, 200, cg_rtol * cg_rtol, 0.0);
+            REQUIRE( g_nd.ComputeL2Error(df3_coef) < tol );
+         }
+         SECTION("With Scalar Coefficient")
+         {
+            MixedBilinearForm blf(&fespace_h1, &fespace_nd);
+            blf.AddDomainIntegrator(
+               new MixedVectorGradientIntegrator(q3_coef));
+            blf.Assemble();
+            blf.Finalize();
 
-               REQUIRE( g_nd.ComputeL2Error(qdf3_coef) < tol );
-            }
-            SECTION("With Diagonal Matrix Coefficient")
-            {
-               MixedBilinearForm blf(&fespace_h1, &fespace_nd);
-               blf.AddDomainIntegrator(
-                  new MixedVectorGradientIntegrator(D3_coef));
-               blf.Assemble();
-               blf.Finalize();
+            blf.Mult(f_h1, tmp_nd); g_nd = 0.0;
+            CG(m_nd, tmp_nd, g_nd, 0, 200, cg_rtol * cg_rtol, 0.0);
 
-               blf.Mult(f_h1, tmp_nd); g_nd = 0.0;
-               CG(m_nd, tmp_nd, g_nd, 0, 200, cg_rtol * cg_rtol, 0.0);
+            REQUIRE( g_nd.ComputeL2Error(qdf3_coef) < tol );
+         }
+         SECTION("With Diagonal Matrix Coefficient")
+         {
+            MixedBilinearForm blf(&fespace_h1, &fespace_nd);
+            blf.AddDomainIntegrator(
+               new MixedVectorGradientIntegrator(D3_coef));
+            blf.Assemble();
+            blf.Finalize();
 
-               REQUIRE( g_nd.ComputeL2Error(Ddf3_coef) < tol );
-            }
-            SECTION("With Matrix Coefficient")
-            {
-               MixedBilinearForm blf(&fespace_h1, &fespace_nd);
-               blf.AddDomainIntegrator(
-                  new MixedVectorGradientIntegrator(M3_coef));
-               blf.Assemble();
-               blf.Finalize();
+            blf.Mult(f_h1, tmp_nd); g_nd = 0.0;
+            CG(m_nd, tmp_nd, g_nd, 0, 200, cg_rtol * cg_rtol, 0.0);
 
-               blf.Mult(f_h1, tmp_nd); g_nd = 0.0;
-               CG(m_nd, tmp_nd, g_nd, 0, 200, cg_rtol * cg_rtol, 0.0);
-
-               REQUIRE( g_nd.ComputeL2Error(Mdf3_coef) < tol );
-            }
+            REQUIRE( g_nd.ComputeL2Error(Ddf3_coef) < tol );
          }
-         SECTION("Mapping H1 to RT")
+         SECTION("With Matrix Coefficient")
          {
-            // Tests requiring an RT test space with same order of
-            // convergence as the RT trial space
+            MixedBilinearForm blf(&fespace_h1, &fespace_nd);
+            blf.AddDomainIntegrator(
+               new MixedVectorGradientIntegrator(M3_coef));
+            blf.Assemble();
+            blf.Finalize();
 
-            RT_FECollection    fec_rt(order - 1, dim);
-            FiniteElementSpace fespace_rt(&mesh, &fec_rt);
+            blf.Mult(f_h1, tmp_nd); g_nd = 0.0;
+            CG(m_nd, tmp_nd, g_nd, 0, 200, cg_rtol * cg_rtol, 0.0);
 
-            BilinearForm m_rt(&fespace_rt);
-            m_rt.AddDomainIntegrator(new VectorFEMassIntegrator());
-            m_rt.Assemble();
-            m_rt.Finalize();
+            REQUIRE( g_nd.ComputeL2Error(Mdf3_coef) < tol );
+         }
+      }
+      SECTION("Mapping H1 to RT")
+      {
+         // Tests requiring an RT test space with same order of
+         // convergence as the RT trial space
 
-            GridFunction g_rt(&fespace_rt);
+         RT_FECollection    fec_rt(order - 1, dim);
+         FiniteElementSpace fespace_rt(&mesh, &fec_rt);
 
-            Vector tmp_rt(fespace_rt.GetNDofs());
+         BilinearForm m_rt(&fespace_rt);
+         m_rt.AddDomainIntegrator(new VectorFEMassIntegrator());
+         m_rt.Assemble();
+         m_rt.Finalize();
 
-            SECTION("Without Coefficient")
-            {
-               MixedBilinearForm blf(&fespace_h1, &fespace_rt);
-               blf.AddDomainIntegrator(new MixedVectorGradientIntegrator());
-               blf.Assemble();
-               blf.Finalize();
+         GridFunction g_rt(&fespace_rt);
 
-               blf.Mult(f_h1, tmp_rt); g_rt = 0.0;
-               CG(m_rt, tmp_rt, g_rt, 0, 200, cg_rtol * cg_rtol, 0.0);
+         Vector tmp_rt(fespace_rt.GetNDofs());
 
-               REQUIRE( g_rt.ComputeL2Error(df3_coef) < tol );
-            }
-            SECTION("With Scalar Coefficient")
-            {
-               MixedBilinearForm blf(&fespace_h1, &fespace_rt);
-               blf.AddDomainIntegrator(
-                  new MixedVectorGradientIntegrator(q3_coef));
-               blf.Assemble();
-               blf.Finalize();
+         SECTION("Without Coefficient")
+         {
+            MixedBilinearForm blf(&fespace_h1, &fespace_rt);
+            blf.AddDomainIntegrator(new MixedVectorGradientIntegrator());
+            blf.Assemble();
+            blf.Finalize();
 
-               blf.Mult(f_h1, tmp_rt); g_rt = 0.0;
-               CG(m_rt, tmp_rt, g_rt, 0, 200, cg_rtol * cg_rtol, 0.0);
+            blf.Mult(f_h1, tmp_rt); g_rt = 0.0;
+            CG(m_rt, tmp_rt, g_rt, 0, 200, cg_rtol * cg_rtol, 0.0);
 
-               REQUIRE( g_rt.ComputeL2Error(qdf3_coef) < tol );
-            }
-            SECTION("With Diagonal Matrix Coefficient")
-            {
-               MixedBilinearForm blf(&fespace_h1, &fespace_rt);
-               blf.AddDomainIntegrator(
-                  new MixedVectorGradientIntegrator(D3_coef));
-               blf.Assemble();
-               blf.Finalize();
+            REQUIRE( g_rt.ComputeL2Error(df3_coef) < tol );
+         }
+         SECTION("With Scalar Coefficient")
+         {
+            MixedBilinearForm blf(&fespace_h1, &fespace_rt);
+            blf.AddDomainIntegrator(
+               new MixedVectorGradientIntegrator(q3_coef));
+            blf.Assemble();
+            blf.Finalize();
 
-               blf.Mult(f_h1, tmp_rt); g_rt = 0.0;
-               CG(m_rt, tmp_rt, g_rt, 0, 200, cg_rtol * cg_rtol, 0.0);
+            blf.Mult(f_h1, tmp_rt); g_rt = 0.0;
+            CG(m_rt, tmp_rt, g_rt, 0, 200, cg_rtol * cg_rtol, 0.0);
 
-               REQUIRE( g_rt.ComputeL2Error(Ddf3_coef) < tol );
-            }
-            SECTION("With Matrix Coefficient")
-            {
-               MixedBilinearForm blf(&fespace_h1, &fespace_rt);
-               blf.AddDomainIntegrator(
-                  new MixedVectorGradientIntegrator(M3_coef));
-               blf.Assemble();
-               blf.Finalize();
+            REQUIRE( g_rt.ComputeL2Error(qdf3_coef) < tol );
+         }
+         SECTION("With Diagonal Matrix Coefficient")
+         {
+            MixedBilinearForm blf(&fespace_h1, &fespace_rt);
+            blf.AddDomainIntegrator(
+               new MixedVectorGradientIntegrator(D3_coef));
+            blf.Assemble();
+            blf.Finalize();
 
-               blf.Mult(f_h1, tmp_rt); g_rt = 0.0;
-               CG(m_rt, tmp_rt, g_rt, 0, 200, cg_rtol * cg_rtol, 0.0);
+            blf.Mult(f_h1, tmp_rt); g_rt = 0.0;
+            CG(m_rt, tmp_rt, g_rt, 0, 200, cg_rtol * cg_rtol, 0.0);
 
-               REQUIRE( g_rt.ComputeL2Error(Mdf3_coef) < tol );
-            }
+            REQUIRE( g_rt.ComputeL2Error(Ddf3_coef) < tol );
+         }
+         SECTION("With Matrix Coefficient")
+         {
+            MixedBilinearForm blf(&fespace_h1, &fespace_rt);
+            blf.AddDomainIntegrator(
+               new MixedVectorGradientIntegrator(M3_coef));
+            blf.Assemble();
+            blf.Finalize();
+
+            blf.Mult(f_h1, tmp_rt); g_rt = 0.0;
+            CG(m_rt, tmp_rt, g_rt, 0, 200, cg_rtol * cg_rtol, 0.0);
+
+            REQUIRE( g_rt.ComputeL2Error(Mdf3_coef) < tol );
          }
       }
    }
@@ -2054,8 +2054,7 @@ TEST_CASE("3D Bilinear Curl Integrator",
    double cg_rtol = 1e-14;
    double tol = 1e-9;
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -2276,8 +2275,7 @@ TEST_CASE("3D Bilinear Cross Product Gradient Integrator",
    double cg_rtol = 1e-14;
    double tol = 1e-9;
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -2363,8 +2361,7 @@ TEST_CASE("3D Bilinear Cross Product Curl Integrator",
    double cg_rtol = 1e-14;
    double tol = 1e-9;
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -2447,8 +2444,7 @@ TEST_CASE("3D Bilinear Divergence Integrator",
    double cg_rtol = 1e-14;
    double tol = 1e-9;
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -2566,8 +2562,7 @@ TEST_CASE("3D Bilinear Vector Divergence Integrator",
    double cg_rtol = 1e-14;
    double tol = 1e-9;
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -2654,8 +2649,7 @@ TEST_CASE("3D Bilinear Vector Product Integrators",
    VectorFunctionCoefficient  V3_coef(dim, V3);
    VectorFunctionCoefficient Vf3_coef(dim, Vf3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -2880,8 +2874,7 @@ TEST_CASE("3D Bilinear Vector Cross Product Integrators",
    VectorFunctionCoefficient   V3_coef(dim, V3);
    VectorFunctionCoefficient VxF3_coef(dim, VcrossF3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -3097,8 +3090,7 @@ TEST_CASE("3D Bilinear Vector Dot Product Integrators",
    VectorFunctionCoefficient  V3_coef(dim, V3);
    FunctionCoefficient       VF3_coef(VdotF3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -3262,8 +3254,7 @@ TEST_CASE("3D Bilinear Directional Derivative Integrator",
    VectorFunctionCoefficient   V3_coef(dim, V3);
    FunctionCoefficient       Vdf3_coef(VdotGrad_f3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -3357,8 +3348,7 @@ TEST_CASE("3D Bilinear Weak Gradient Integrators",
    VectorFunctionCoefficient  df3_coef(dim, Grad_f3);
    VectorFunctionCoefficient dqf3_coef(dim, Grad_qf3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -3565,8 +3555,7 @@ TEST_CASE("3D Bilinear Scalar Weak Divergence Integrators",
    VectorFunctionCoefficient  Vf3_coef(dim, Vf3);
    FunctionCoefficient       dVf3_coef(Div_Vf3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -3719,8 +3708,7 @@ TEST_CASE("3D Bilinear Weak Divergence Integrators",
    FunctionCoefficient      dDF3_coef(Div_DF3);
    FunctionCoefficient      dMF3_coef(Div_MF3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -4055,8 +4043,7 @@ TEST_CASE("3D Bilinear Weak Curl Integrators",
    VectorFunctionCoefficient dDF3_coef(dim, Curl_DF3);
    VectorFunctionCoefficient dMF3_coef(dim, Curl_MF3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -4378,8 +4365,7 @@ TEST_CASE("3D Bilinear Weak Div Cross Integrators",
    VectorFunctionCoefficient  VF3_coef(dim, VcrossF3);
    FunctionCoefficient       dVF3_coef(Div_VcrossF3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -4514,8 +4500,7 @@ TEST_CASE("3D Bilinear Weak Curl Cross Integrators",
    VectorFunctionCoefficient  VxF3_coef(dim, VcrossF3);
    VectorFunctionCoefficient dVxF3_coef(dim, Curl_VcrossF3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -4647,8 +4632,7 @@ TEST_CASE("3D Bilinear Weak Grad Dot Product Integrators",
    FunctionCoefficient       VdotF3_coef(VdotF3);
    VectorFunctionCoefficient   dVF3_coef(dim, GradVdotF3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -4785,8 +4769,7 @@ TEST_CASE("3D Bilinear Grad Div Integrators",
    VectorFunctionCoefficient dVdf3_coef(dim, GradVdotGrad_f3);
    FunctionCoefficient       dVdF3_coef(DivVDivF3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -4912,8 +4895,7 @@ TEST_CASE("3D Bilinear Grad Grad Integrators",
    FunctionCoefficient      dqdf3_coef(Div_qGrad_f3);
    FunctionCoefficient      dMdf3_coef(Div_MGrad_f3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -5049,8 +5031,7 @@ TEST_CASE("3D Bilinear Mixed Grad Grad Integrators",
    FunctionCoefficient      dDdf3_coef(Div_DGrad_f3);
    FunctionCoefficient      dMdf3_coef(Div_MGrad_f3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -5208,8 +5189,7 @@ TEST_CASE("3D Bilinear Mixed Cross Grad Grad Integrators",
    VectorFunctionCoefficient Vxdf3_coef(dim, VcrossGrad_f3);
    FunctionCoefficient      dVxdf3_coef(Div_VcrossGrad_f3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -5281,8 +5261,7 @@ TEST_CASE("3D Bilinear Mixed Cross Curl Grad Integrators",
    VectorFunctionCoefficient VxdF3_coef(dim, VcrossCurlF3);
    FunctionCoefficient      dVxdF3_coef(DivVcrossCurlF3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -5365,8 +5344,7 @@ TEST_CASE("3D Bilinear Curl Curl Integrators",
    VectorFunctionCoefficient  qdF3_coef(dim, qCurlF3);
    VectorFunctionCoefficient dqdF3_coef(dim, Curl_qCurlF3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -5511,8 +5489,7 @@ TEST_CASE("3D Bilinear Mixed Curl Curl Integrators",
    VectorFunctionCoefficient dDdF3_coef(dim, Curl_DCurlF3);
    VectorFunctionCoefficient dMdF3_coef(dim, Curl_MCurlF3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -5668,8 +5645,7 @@ TEST_CASE("3D Bilinear Mixed Cross Curl Curl Integrators",
    VectorFunctionCoefficient  VdF3_coef(dim, VcrossCurlF3);
    VectorFunctionCoefficient dVdF3_coef(dim, Curl_VcrossCurlF3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -5740,8 +5716,7 @@ TEST_CASE("3D Bilinear Mixed Cross Grad Curl Integrators",
    VectorFunctionCoefficient  Vdf3_coef(dim, VcrossGrad_f3);
    VectorFunctionCoefficient dVdf3_coef(dim, Curl_VcrossGrad_f3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -5826,8 +5801,7 @@ TEST_CASE("3D Bilinear Div Div Integrators",
    FunctionCoefficient         qdF3_coef(qDivF3);
    VectorFunctionCoefficient  dqdF3_coef(dim, Grad_qDivF3);
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh =
          Mesh::MakeCartesian3D(n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
diff --git a/tests/unit/fem/test_calccurlshape.cpp b/tests/unit/fem/test_calccurlshape.cpp
index a19ca0671..c34b9c5b1 100644
--- a/tests/unit/fem/test_calccurlshape.cpp
+++ b/tests/unit/fem/test_calccurlshape.cpp
@@ -92,6 +92,16 @@ void TestCalcCurlShape(FiniteElement* fe, ElementTransformation * T, int res)
       for (int j=0; j < ipArr.Size(); ++j)
       {
          IntegrationPoint& ip = ipArr[j];
+
+         // Pyramid basis functions are poorly behaved outside the
+         // reference pyramid
+         if (fe->GetGeomType() == Geometry::PYRAMID &&
+             (ip.z < 0.0 || ip.z >= 1.0 ||
+              ip.y < 0.0 || ip.y > 1.0 - ip.z ||
+              ip.x < 0.0 || ip.x > 1.0 - ip.z)) { continue; }
+
+         CAPTURE(ip.x, ip.y, ip.z);
+
          fe->CalcCurlShape(ip, weights);
 
          weights.MultTranspose(dofs, v);
@@ -110,6 +120,7 @@ TEST_CASE("CalcCurlShape ND",
           "[ND_QuadrilateralElement]"
           "[ND_TetrahedronElement]"
           "[ND_WedgeElement]"
+          "[ND_FuentesPyramidElement]"
           "[ND_HexahedronElement]")
 {
    const int maxOrder = 5;
@@ -154,6 +165,15 @@ TEST_CASE("CalcCurlShape ND",
       TestCalcCurlShape(&fe, &T, resolution);
    }
 
+   SECTION("ND_FuentesPyramidElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::PYRAMID, T);
+
+      ND_FuentesPyramidElement fe(order);
+      TestCalcCurlShape(&fe, &T, resolution);
+   }
+
    SECTION("ND_HexahedronElement")
    {
       IsoparametricTransformation T;
@@ -163,3 +183,222 @@ TEST_CASE("CalcCurlShape ND",
       TestCalcCurlShape(&fe, &T, resolution);
    }
 }
+
+/**
+ * Tests fe->CalcCurlShape() over a set of IntegrationPoints
+ * chosen based on the order. Compares the computed derivatives against
+ * approximate derivatives computed using the secant method.
+ */
+void TestFDCalcCurlShape(FiniteElement* fe, ElementTransformation * T,
+                         int order)
+{
+   int  dof = fe->GetDof();
+   int  dim = fe->GetDim();
+   int cdim = fe->GetCurlDim();
+
+   DenseMatrix pshape(dof, dim);
+   DenseMatrix mshape(dof, dim);
+   Vector pcomp;
+   Vector mcomp;
+   Vector fdcomp(dof);
+   Vector fdshapecol;
+   DenseMatrix dshape(dof, cdim);
+   DenseMatrix fdshape(dof, cdim);
+
+   // Optimal step size for central difference
+   real_t h = std::cbrt(std::numeric_limits<real_t>::epsilon());
+   real_t inv2h = 0.5 / h;
+
+   // Error in the finite difference approximation of the derivative of a
+   // Legendre polynomial: P_n'''(1) h^2 / 6. Because we use shifted and scaled
+   // Legendre polynomials we need to increase these estimates by 2^3. We also
+   // make use of the fact that the third derivatives of Legendre polynomials
+   // are bounded by +/- (n+1)(n+2)(n+3)(n+4)(n+5)(n+6)/48.
+   real_t err_est = (order + 1) * (order + 2) * (order + 3) *
+                    (order + 4) * (order + 5) * (order + 6) * h * h / 36.0;
+
+   bool pyr = fe->GetGeomType() == Geometry::PYRAMID;
+
+   const IntegrationRule *ir = &IntRules.Get(fe->GetGeomType(), 2*order+dim-1);
+
+   IntegrationPoint ptp;
+   IntegrationPoint ptm;
+
+   int npoints = ir->GetNPoints();
+   for (int i=0; i < npoints; ++i)
+   {
+      // Get the current integration point from the integration rule
+      IntegrationPoint pt = ir->IntPoint(i);
+      fe->CalcCurlShape(pt, dshape);
+
+      CAPTURE(pt.x, pt.y, pt.z);
+
+      fdshape = 0.0;
+      for (int d=0; d<dim; d++)
+      {
+         const int d1 = (d + 1) % 3;
+         const int d2 = (d + 2) % 3;
+
+         // Compute shifted integration points
+         switch (d)
+         {
+            case 0:
+               ptm.x = pt.x - h; ptm.y = pt.y; ptm.z = pt.z;
+               ptp.x = pt.x + h; ptp.y = pt.y; ptp.z = pt.z;
+               break;
+            case 1:
+               ptm.x = pt.x; ptm.y = pt.y - h; ptm.z = pt.z;
+               ptp.x = pt.x; ptp.y = pt.y + h; ptp.z = pt.z;
+               break;
+            case 2:
+               ptm.x = pt.x; ptm.y = pt.y; ptm.z = pt.z - h;
+               ptp.x = pt.x; ptp.y = pt.y; ptp.z = pt.z + h;
+               break;
+            default:
+               ptm = pt;
+               ptp = pt;
+         }
+
+         // Compute shape functions at the shifted points
+         fe->CalcVShape(ptm, mshape);
+         fe->CalcVShape(ptp, pshape);
+
+         if (dim == 2 && d1 < 2)
+         {
+            // Extract the component to be differentiated
+            mshape.GetColumnReference(d1, mcomp);
+            pshape.GetColumnReference(d1, pcomp);
+
+            // Compute approximate derivatives using the secant method
+            add(inv2h, pcomp, -inv2h, mcomp, fdcomp);
+
+            fdshape.GetColumnReference(0, fdshapecol);
+            fdshapecol += fdcomp;
+         }
+         if (dim == 2 && d2 < 2)
+         {
+            // Extract the component to be differentiated
+            mshape.GetColumnReference(d2, mcomp);
+            pshape.GetColumnReference(d2, pcomp);
+
+            // Compute approximate derivatives using the secant method
+            add(inv2h, pcomp, -inv2h, mcomp, fdcomp);
+
+            fdshape.GetColumnReference(0, fdshapecol);
+            fdshapecol -= fdcomp;
+         }
+         if (dim == 3)
+         {
+            // Extract the component to be differentiated
+            mshape.GetColumnReference(d1, mcomp);
+            pshape.GetColumnReference(d1, pcomp);
+
+            // Compute approximate derivatives using the secant method
+            add(inv2h, pcomp, -inv2h, mcomp, fdcomp);
+
+            fdshape.GetColumnReference(d2, fdshapecol);
+            fdshapecol += fdcomp;
+
+            // Extract the component to be differentiated
+            mshape.GetColumnReference(d2, mcomp);
+            pshape.GetColumnReference(d2, pcomp);
+
+            // Compute approximate derivatives using the secant method
+            add(inv2h, pcomp, -inv2h, mcomp, fdcomp);
+
+            fdshape.GetColumnReference(d1, fdshapecol);
+            fdshapecol -= fdcomp;
+         }
+      }
+
+      // Compute the difference between the computed derivative and its
+      // finite difference approximation
+      fdshape -= dshape;
+
+      // Due to the scaling of the Legendre polynomials, as the integration
+      // points approach the apex of a pyramid the derivatives in the x and y
+      // directions become infinite. Therefore, we need to scale the finite
+      // difference error estimate by the following z-dependent factor. The
+      // truncation error involves the third derivative of the Legendre
+      // polynomial which adds three factors of 1/(1-z). Some of the basis
+      // functions are constructed using first derivatives of Legendre
+      // polynomials which adds one additional factor of 1/(1-z).
+      real_t pyr_fac = pyr ? std::pow(1.0/(1.0-pt.z), 4) : 1.0;
+
+      // Determine the maximum difference between the two derivative
+      // calculations
+      real_t max_err = fdshape.MaxMaxNorm();
+
+      // The factor of two is added to account for the sum of derivatives in
+      // each direction needed to form the curl. The factor of dim is added to
+      // account for the product rule used in computing derivatives of our
+      // basis functions which are products of Legendre polynomials in the
+      // different coordinates.
+      REQUIRE( max_err < 2 * dim * pyr_fac * err_est );
+   }
+}
+
+TEST_CASE("CalcCurlShape vs FD ND",
+          "[ND_TriangleElement]"
+          "[ND_QuadrilateralElement]"
+          "[ND_TetrahedronElement]"
+          "[ND_WedgeElement]"
+          "[ND_FuentesPyramidElement]"
+          "[ND_HexahedronElement]")
+{
+   const int maxOrder = 5;
+   auto order = GENERATE_COPY(range(1, maxOrder + 1));
+
+   CAPTURE(order);
+
+   SECTION("ND_TriangleElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::TRIANGLE, T);
+
+      ND_TriangleElement fe(order);
+      TestFDCalcCurlShape(&fe, &T, order);
+   }
+   SECTION("ND_QuadrilateralElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::QUADRILATERAL, T);
+
+      ND_QuadrilateralElement fe(order);
+      TestFDCalcCurlShape(&fe, &T, order);
+   }
+   SECTION("ND_TetrahedronElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::TETRAHEDRON, T);
+
+      ND_TetrahedronElement fe(order);
+      TestFDCalcCurlShape(&fe, &T, order);
+   }
+   SECTION("ND_WedgeElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::WEDGE, T);
+
+      ND_WedgeElement fe(order);
+      TestFDCalcCurlShape(&fe, &T, order);
+   }
+
+   SECTION("ND_FuentesPyramidElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::PYRAMID, T);
+
+      ND_FuentesPyramidElement fe(order);
+      TestFDCalcCurlShape(&fe, &T, order);
+   }
+
+   SECTION("ND_HexahedronElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::HEXAHEDRON, T);
+
+      ND_HexahedronElement fe(order);
+      TestFDCalcCurlShape(&fe, &T, order);
+   }
+}
diff --git a/tests/unit/fem/test_calcdivshape.cpp b/tests/unit/fem/test_calcdivshape.cpp
index 84b5cfd50..259d85b2e 100644
--- a/tests/unit/fem/test_calcdivshape.cpp
+++ b/tests/unit/fem/test_calcdivshape.cpp
@@ -88,6 +88,14 @@ void TestCalcDivShape(FiniteElement* fe, ElementTransformation * T, int res)
       for (int j=0; j < ipArr.Size(); ++j)
       {
          IntegrationPoint& ip = ipArr[j];
+
+         // Pyramid basis functions are poorly behaved outside the
+         // reference pyramid
+         if (fe->GetGeomType() == Geometry::PYRAMID &&
+             (ip.z >= 1.0 || ip.y > 1.0 - ip.z || ip.x > 1.0 - ip.z)) { continue; }
+
+         CAPTURE(ip.x, ip.y, ip.z);
+
          fe->CalcDivShape(ip, weights);
 
          REQUIRE( weights * dofs == Approx(1.) );
@@ -100,6 +108,7 @@ TEST_CASE("CalcDivShape RT",
           "[RT_QuadrilateralElement]"
           "[RT_TetrahedronElement]"
           "[RT_WedgeElement]"
+          "[RT_FuentesPyramidElement]"
           "[RT_HexahedronElement]")
 {
    const int maxOrder = 5;
@@ -144,6 +153,15 @@ TEST_CASE("CalcDivShape RT",
       TestCalcDivShape(&fe, &T, resolution);
    }
 
+   SECTION("RT_FuentesPyramidElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::PYRAMID, T);
+
+      RT_FuentesPyramidElement fe(order - 1);
+      TestCalcDivShape(&fe, &T, resolution);
+   }
+
    SECTION("RT_HexahedronElement")
    {
       IsoparametricTransformation T;
@@ -153,3 +171,180 @@ TEST_CASE("CalcDivShape RT",
       TestCalcDivShape(&fe, &T, resolution);
    }
 }
+
+/**
+ * Tests fe->CalcDivShape() over a set of IntegrationPoints
+ * chosen based on the order. Compares the computed derivatives against
+ * approximate derivatives computed using the secant method.
+ */
+void TestFDCalcDivShape(FiniteElement* fe, ElementTransformation * T, int order)
+{
+   int  dof = fe->GetDof();
+   int  dim = fe->GetDim();
+
+   DenseMatrix pshape(dof, dim);
+   DenseMatrix mshape(dof, dim);
+   Vector pcomp;
+   Vector mcomp;
+   Vector dshape(dof);
+   Vector fdcomp(dof), fdshape(dof);
+
+   // Optimal step size for central difference
+   real_t h = std::cbrt(std::numeric_limits<real_t>::epsilon());
+   real_t inv2h = 0.5 / h;
+
+   // Error in the finite difference approximation of the derivative of a
+   // Legendre polynomial: P_n'''(1) h^2 / 6. Because we use shifted and scaled
+   // Legendre polynomials we need to increase these estimates by 2^3. We also
+   // make use of the fact that the third derivatives of Legendre polynomials
+   // are bounded by +/- (n+1)(n+2)(n+3)(n+4)(n+5)(n+6)/48.
+   real_t err_est = (order + 1) * (order + 2) * (order + 3) *
+                    (order + 4) * (order + 5) * (order + 6) * h * h / 36.0;
+
+   bool pyr = fe->GetGeomType() == Geometry::PYRAMID;
+
+   const IntegrationRule *ir = &IntRules.Get(fe->GetGeomType(), 2*order+dim-1);
+
+   IntegrationPoint ptp;
+   IntegrationPoint ptm;
+
+   int npoints = ir->GetNPoints();
+   for (int i=0; i < npoints; ++i)
+   {
+      // Get the current integration point from the integration rule
+      IntegrationPoint pt = ir->IntPoint(i);
+      fe->CalcDivShape(pt, dshape);
+
+      CAPTURE(pt.x, pt.y, pt.z);
+
+      fdshape = 0.0;
+      for (int d=0; d<dim; d++)
+      {
+         // Compute shifted integration points
+         switch (d)
+         {
+            case 0:
+               ptm.x = pt.x - h; ptm.y = pt.y; ptm.z = pt.z;
+               ptp.x = pt.x + h; ptp.y = pt.y; ptp.z = pt.z;
+               break;
+            case 1:
+               ptm.x = pt.x; ptm.y = pt.y - h; ptm.z = pt.z;
+               ptp.x = pt.x; ptp.y = pt.y + h; ptp.z = pt.z;
+               break;
+            case 2:
+               ptm.x = pt.x; ptm.y = pt.y; ptm.z = pt.z - h;
+               ptp.x = pt.x; ptp.y = pt.y; ptp.z = pt.z + h;
+               break;
+            default:
+               ptm = pt;
+               ptp = pt;
+         }
+
+         // Compute shape functions at the shifted points
+         fe->CalcVShape(ptm, mshape);
+         fe->CalcVShape(ptp, pshape);
+
+         // Extract the component to be differentiated
+         mshape.GetColumnReference(d, mcomp);
+         pshape.GetColumnReference(d, pcomp);
+
+         // Compute approximate derivatives using the secant method
+         add(inv2h, pcomp, -inv2h, mcomp, fdcomp);
+
+         fdshape += fdcomp;
+      }
+
+      // Compute the difference between the computed derivative and its
+      // finite difference approximation
+      fdshape -= dshape;
+
+      // Due to the scaling of the Legendre polynomials, as the integration
+      // points approach the apex of a pyramid the derivatives in the x and y
+      // directions become infinite. Therefore, we need to scale the finite
+      // difference error estimate by the following z-dependent factor. The
+      // truncation error involves the third derivative of the Legendre
+      // polynomial which adds three factors of 1/(1-z). Some of the basis
+      // functions are constructed using first derivatives of Legendre
+      // polynomials which adds one additional factor of 1/(1-z).
+      real_t pyr_fac = pyr ? std::pow(1.0/(1.0-pt.z), 4) : 1.0;
+
+      // Determine the maximum difference between the two derivative
+      // calculations
+      real_t max_err = fdshape.Normlinf();
+
+      // The first factor of dim is added to account for the product
+      // rule used in computing derivatives of our basis functions which are
+      // products of Legendre polynomials in the different coordinates. The
+      // second factor of dim is added to account for the sum of derivatives
+      // in each direction needed to form the divergence.
+      REQUIRE( max_err < dim * dim * pyr_fac * err_est );
+   }
+}
+
+TEST_CASE("CalcDivShape vs FD RT",
+          "[RT_TriangleElement]"
+          "[RT_QuadrilateralElement]"
+          "[RT_TetrahedronElement]"
+          "[RT_WedgeElement]"
+          "[RT_FuentesPyramidElement]"
+          "[RT_HexahedronElement]")
+{
+   const int maxOrder = 5;
+   auto order = GENERATE_COPY(range(1, maxOrder + 1));
+
+   CAPTURE(order);
+
+   SECTION("RT_TriangleElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::TRIANGLE, T);
+
+      RT_TriangleElement fe(order - 1);
+      TestFDCalcDivShape(&fe, &T, order);
+   }
+
+   SECTION("RT_QuadrilateralElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::QUADRILATERAL, T);
+
+      RT_QuadrilateralElement fe(order - 1);
+      TestFDCalcDivShape(&fe, &T, order);
+   }
+
+   SECTION("RT_TetrahedronElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::TETRAHEDRON, T);
+
+      RT_TetrahedronElement fe(order - 1);
+      TestFDCalcDivShape(&fe, &T, order);
+   }
+
+   SECTION("RT_WedgeElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::WEDGE, T);
+
+      RT_WedgeElement fe(order - 1);
+      TestFDCalcDivShape(&fe, &T, order);
+   }
+
+   SECTION("RT_FuentesPyramidElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::PYRAMID, T);
+
+      RT_FuentesPyramidElement fe(order - 1);
+      TestFDCalcDivShape(&fe, &T, order);
+   }
+
+   SECTION("RT_HexahedronElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::HEXAHEDRON, T);
+
+      RT_HexahedronElement fe(order - 1);
+      TestFDCalcDivShape(&fe, &T, order);
+   }
+}
diff --git a/tests/unit/fem/test_calcdshape.cpp b/tests/unit/fem/test_calcdshape.cpp
index 150822a00..943c6e39d 100644
--- a/tests/unit/fem/test_calcdshape.cpp
+++ b/tests/unit/fem/test_calcdshape.cpp
@@ -93,6 +93,14 @@ void TestCalcDShape(FiniteElement* fe, ElementTransformation * T, int res)
       for (int j=0; j < ipArr.Size(); ++j)
       {
          IntegrationPoint& ip = ipArr[j];
+
+         // Pyramid basis functions are poorly behaved outside the
+         // reference pyramid
+         if (fe->GetGeomType() == Geometry::PYRAMID &&
+             (ip.z >= 1.0 || ip.y > 1.0 - ip.z || ip.x > 1.0 - ip.z)) { continue; }
+
+         CAPTURE(ip.x, ip.y, ip.z);
+
          fe->CalcDShape(ip, weights);
 
          weights.MultTranspose(dofs, v);
@@ -115,6 +123,8 @@ TEST_CASE("CalcDShape H1",
           "[H1_QuadrilateralElement]"
           "[H1_TetrahedronElement]"
           "[H1_WedgeElement]"
+          "[H1_FuentesPyramidElement]"
+          "[H1_BergotPyramidElement]"
           "[H1_HexahedronElement]")
 {
    const int maxOrder = 5;
@@ -168,6 +178,24 @@ TEST_CASE("CalcDShape H1",
       TestCalcDShape(&fe, &T, resolution);
    }
 
+   SECTION("H1_FuentesPyramidElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::PYRAMID, T);
+
+      H1_FuentesPyramidElement fe(order);
+      TestCalcDShape(&fe, &T, resolution);
+   }
+
+   SECTION("H1_BergotPyramidElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::PYRAMID, T);
+
+      H1_BergotPyramidElement fe(order);
+      TestCalcDShape(&fe, &T, resolution);
+   }
+
    SECTION("H1_HexahedronElement")
    {
       IsoparametricTransformation T;
@@ -177,3 +205,274 @@ TEST_CASE("CalcDShape H1",
       TestCalcDShape(&fe, &T, resolution);
    }
 }
+
+/**
+ * Tests fe->CalcDShape() over a set of IntegrationPoints
+ * chosen based on the order. Compares the computed derivatives against
+ * approximate derivatives computed using the secant method.
+ */
+void TestFDCalcDShape(FiniteElement* fe, ElementTransformation * T, int order)
+{
+   int  dof = fe->GetDof();
+   int  dim = fe->GetDim();
+
+   Vector pshape(dof);
+   Vector mshape(dof);
+   Vector fd;
+   DenseMatrix dshape( dof, dim );
+   DenseMatrix fdshape( dof, dim );
+
+   // Optimal step size for central difference
+   real_t h = std::cbrt(std::numeric_limits<real_t>::epsilon());
+   real_t inv2h = 0.5 / h;
+
+   // Error in the finite difference approximation of the derivative of a
+   // Legendre polynomial: P_n'''(1) h^2 / 6. Because we use shifted and scaled
+   // Legendre polynomials we need to increase these estimates by 2^3. We also
+   // make use of the fact that the third derivatives of Legendre polynomials
+   // are bounded by +/- (n+1)(n+2)(n+3)(n+4)(n+5)(n+6)/48.
+   real_t err_est = (order + 1) * (order + 2) * (order + 3) *
+                    (order + 4) * (order + 5) * (order + 6) * h * h / 36.0;
+
+   bool pyr = fe->GetGeomType() == Geometry::PYRAMID;
+
+   const IntegrationRule *ir = &IntRules.Get(fe->GetGeomType(), 2*order+dim-1);
+
+   IntegrationPoint ptp;
+   IntegrationPoint ptm;
+
+   int npoints = ir->GetNPoints();
+   for (int i=0; i < npoints; ++i)
+   {
+      // Get the current integration point from the integration rule
+      IntegrationPoint pt = ir->IntPoint(i);
+      fe->CalcDShape(pt, dshape);
+      for (int d=0; d<dim; d++)
+      {
+         // Compute shifted integration points
+         switch (d)
+         {
+            case 0:
+               ptm.x = pt.x - h; ptm.y = pt.y; ptm.z = pt.z;
+               ptp.x = pt.x + h; ptp.y = pt.y; ptp.z = pt.z;
+               break;
+            case 1:
+               ptm.x = pt.x; ptm.y = pt.y - h; ptm.z = pt.z;
+               ptp.x = pt.x; ptp.y = pt.y + h; ptp.z = pt.z;
+               break;
+            case 2:
+               ptm.x = pt.x; ptm.y = pt.y; ptm.z = pt.z - h;
+               ptp.x = pt.x; ptp.y = pt.y; ptp.z = pt.z + h;
+               break;
+            default:
+               ptm = pt;
+               ptp = pt;
+         }
+
+         // Compute shape functions at the shifted points
+         fe->CalcShape(ptm, mshape);
+         fe->CalcShape(ptp, pshape);
+
+         // Compute approximate derivatives using the secant method
+         fdshape.GetColumnReference(d, fd);
+         add(inv2h, pshape, -inv2h, mshape, fd);
+      }
+
+      // Compute the difference between the computed derivative and its
+      // finite difference approximation
+      fdshape -= dshape;
+
+      // Due to the scaling of the Legendre polynomials, as the integration
+      // points approach the apex of a pyramid the derivatives in the x and y
+      // directions become infinite. Therefore, we need to scale the finite
+      // difference error estimate by the following z-dependent factor.
+      real_t pyr_fac = pyr ? std::pow(1.0/(1.0-pt.z), 3) : 1.0;
+
+      // Determine the maximum difference between the two derivative
+      // calculations
+      real_t max_err = fdshape.MaxMaxNorm();
+
+      // The additional factor of dim is added to account for the product
+      // rule used in computing derivatives of our basis functions which are
+      // products of Legendre polynomials in the different coordinates.
+      REQUIRE( max_err < dim * pyr_fac * err_est );
+   }
+}
+
+TEST_CASE("CalcDShape vs FD H1",
+          "[H1_SegmentElement]"
+          "[H1_TriangleElement]"
+          "[H1_QuadrilateralElement]"
+          "[H1_TetrahedronElement]"
+          "[H1_WedgeElement]"
+          "[H1_FuentesPyramidElement]"
+          "[H1_BergotPyramidElement]"
+          "[H1_HexahedronElement]")
+{
+   const int maxOrder = 5;
+   auto order = GENERATE_COPY(range(1, maxOrder + 1));
+
+   CAPTURE(order);
+
+   SECTION("H1_SegmentElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::SEGMENT, T);
+
+      H1_SegmentElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+   SECTION("H1_TriangleElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::TRIANGLE, T);
+
+      H1_TriangleElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+   SECTION("H1_QuadrilateralElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::QUADRILATERAL, T);
+
+      H1_QuadrilateralElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+   SECTION("H1_TetrahedronElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::TETRAHEDRON, T);
+
+      H1_TetrahedronElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+   SECTION("H1_WedgeElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::WEDGE, T);
+
+      H1_WedgeElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+   SECTION("H1_FuentesPyramidElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::PYRAMID, T);
+
+      H1_FuentesPyramidElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+   SECTION("H1_BergotPyramidElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::PYRAMID, T);
+
+      H1_BergotPyramidElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+   SECTION("H1_HexahedronElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::HEXAHEDRON, T);
+
+      H1_HexahedronElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+}
+
+TEST_CASE("CalcDShape vs FD L2",
+          "[L2_SegmentElement]"
+          "[L2_TriangleElement]"
+          "[L2_QuadrilateralElement]"
+          "[L2_TetrahedronElement]"
+          "[L2_WedgeElement]"
+          "[L2_FuentesPyramidElement]"
+          "[L2_BergotPyramidElement]"
+          "[L2_HexahedronElement]")
+{
+   const int maxOrder = 5;
+   auto order = GENERATE_COPY(range(0, maxOrder));
+
+   CAPTURE(order);
+
+   SECTION("L2_SegmentElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::SEGMENT, T);
+
+      L2_SegmentElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+   SECTION("L2_TriangleElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::TRIANGLE, T);
+
+      L2_TriangleElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+   SECTION("L2_QuadrilateralElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::QUADRILATERAL, T);
+
+      L2_QuadrilateralElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+   SECTION("L2_TetrahedronElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::TETRAHEDRON, T);
+
+      L2_TetrahedronElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+   SECTION("L2_WedgeElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::WEDGE, T);
+
+      L2_WedgeElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+   SECTION("L2_FuentesPyramidElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::PYRAMID, T);
+
+      L2_FuentesPyramidElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+   SECTION("L2_BergotPyramidElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::PYRAMID, T);
+
+      L2_BergotPyramidElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+   SECTION("L2_HexahedronElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::HEXAHEDRON, T);
+
+      L2_HexahedronElement fe(order);
+      TestFDCalcDShape(&fe, &T, order);
+   }
+
+}
diff --git a/tests/unit/fem/test_calcshape.cpp b/tests/unit/fem/test_calcshape.cpp
index 6e7cd7b8c..02c0420d6 100644
--- a/tests/unit/fem/test_calcshape.cpp
+++ b/tests/unit/fem/test_calcshape.cpp
@@ -77,6 +77,8 @@ void GetRelatedIntegrationPoints(const IntegrationPoint& ip, int dim,
  */
 void TestCalcShape(FiniteElement* fe, int res, double tol=1e-12)
 {
+   CAPTURE(tol);
+
    int dim = fe->GetDim();
 
    Vector weights( fe->GetDof() );
@@ -101,6 +103,14 @@ void TestCalcShape(FiniteElement* fe, int res, double tol=1e-12)
       for (int j=0; j < ipArr.Size(); ++j)
       {
          IntegrationPoint& ip = ipArr[j];
+
+         // Pyramid basis functions are poorly behaved outside the
+         // reference pyramid
+         if (fe->GetGeomType() == Geometry::PYRAMID &&
+             (ip.z >= 1.0 || ip.y > 1.0 - ip.z || ip.x > 1.0 - ip.z)) { continue; }
+
+         CAPTURE(ip.x, ip.y, ip.z);
+
          fe->CalcShape(ip, weights);
          REQUIRE(weights.Sum() == MFEM_Approx(1., tol, tol));
       }
@@ -154,7 +164,10 @@ TEST_CASE("CalcShape H1",
           "[H1_QuadrilateralElement]"
           "[H1_TetrahedronElement]"
           "[H1_HexahedronElement]"
-          "[H1_WedgeElement]")
+          "[H1_WedgeElement]"
+          "[H1_FuentesPyramidElement]"
+          "[H1_BergotPyramidElement]"
+          "[H1_PyramidElement]")
 {
    const int maxOrder = 5;
    const int resolution = 10;
@@ -198,4 +211,16 @@ TEST_CASE("CalcShape H1",
       TestCalcShape(&fe, resolution, 2e-11*std::pow(10, order));
    }
 
+   SECTION("H1_FuentesPyramidElement")
+   {
+      H1_FuentesPyramidElement fe(order);
+      TestCalcShape(&fe, resolution, 2e-6*std::pow(10, order));
+   }
+
+   SECTION("H1_BergotPyramidElement")
+   {
+      H1_BergotPyramidElement fe(order);
+      TestCalcShape(&fe, resolution, 2e-11*std::pow(10, order));
+   }
+
 }
diff --git a/tests/unit/fem/test_calcvshape.cpp b/tests/unit/fem/test_calcvshape.cpp
index 631431678..90fb3d42b 100644
--- a/tests/unit/fem/test_calcvshape.cpp
+++ b/tests/unit/fem/test_calcvshape.cpp
@@ -138,6 +138,25 @@ void GetReferenceTransformation(const Element::Type ElemType,
          T.GetPointMat()(2, 5) = 1.0;
          T.SetFE(&WedgeFE);
          break;
+      case Element::PYRAMID :
+         T.GetPointMat().SetSize(3, 5);
+         T.GetPointMat()(0, 0) = 0.0;
+         T.GetPointMat()(1, 0) = 0.0;
+         T.GetPointMat()(2, 0) = 0.0;
+         T.GetPointMat()(0, 1) = 1.0;
+         T.GetPointMat()(1, 1) = 0.0;
+         T.GetPointMat()(2, 1) = 0.0;
+         T.GetPointMat()(0, 2) = 1.0;
+         T.GetPointMat()(1, 2) = 1.0;
+         T.GetPointMat()(2, 2) = 0.0;
+         T.GetPointMat()(0, 3) = 0.0;
+         T.GetPointMat()(1, 3) = 1.0;
+         T.GetPointMat()(2, 3) = 0.0;
+         T.GetPointMat()(0, 4) = 0.0;
+         T.GetPointMat()(1, 4) = 0.0;
+         T.GetPointMat()(2, 4) = 1.0;
+         T.SetFE(&PyramidFE);
+         break;
       default:
          MFEM_ABORT("Unknown element type \"" << ElemType << "\"");
          break;
@@ -193,6 +212,14 @@ void TestCalcVShape(FiniteElement* fe, ElementTransformation * T, int res)
       for (int j=0; j < ipArr.Size(); ++j)
       {
          IntegrationPoint& ip = ipArr[j];
+
+         // Pyramid basis functions are poorly behaved outside the
+         // reference pyramid
+         if (fe->GetGeomType() == Geometry::PYRAMID &&
+             (ip.z >= 1.0 || ip.y > 1.0 - ip.z || ip.x > 1.0 - ip.z)) { continue; }
+
+         CAPTURE(ip.x, ip.y, ip.z);
+
          fe->CalcVShape(ip, weights);
 
          weights.MultTranspose(dofsx, v);
@@ -217,6 +244,7 @@ TEST_CASE("CalcVShape ND",
           "[ND_QuadrilateralElement]"
           "[ND_TetrahedronElement]"
           "[ND_WedgeElement]"
+          "[ND_FuentesPyramidElement]"
           "[ND_HexahedronElement]")
 {
    const int maxOrder = 5;
@@ -270,6 +298,15 @@ TEST_CASE("CalcVShape ND",
       TestCalcVShape(&fe, &T, resolution);
    }
 
+   SECTION("ND_FuentesPyramidElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::PYRAMID, T);
+
+      ND_FuentesPyramidElement fe(order);
+      TestCalcVShape(&fe, &T, resolution);
+   }
+
    SECTION("ND_HexahedronElement")
    {
       IsoparametricTransformation T;
@@ -285,6 +322,7 @@ TEST_CASE("CalcVShape RT",
           "[RT_QuadrilateralElement]"
           "[RT_TetrahedronElement]"
           "[RT_WedgeElement]"
+          "[RT_FuentesPyramidElement]"
           "[RT_HexahedronElement]")
 {
    const int maxOrder = 5;
@@ -329,6 +367,15 @@ TEST_CASE("CalcVShape RT",
       TestCalcVShape(&fe, &T, resolution);
    }
 
+   SECTION("RT_FuentesElement")
+   {
+      IsoparametricTransformation T;
+      GetReferenceTransformation(Element::PYRAMID, T);
+
+      RT_FuentesPyramidElement fe(order);
+      TestCalcVShape(&fe, &T, resolution);
+   }
+
    SECTION("RT_HexahedronElement")
    {
       IsoparametricTransformation T;
diff --git a/tests/unit/fem/test_domain_int.cpp b/tests/unit/fem/test_domain_int.cpp
index 7dda05478..ca3967c9e 100644
--- a/tests/unit/fem/test_domain_int.cpp
+++ b/tests/unit/fem/test_domain_int.cpp
@@ -64,7 +64,8 @@ enum MeshType
    TETRAHEDRA = 13,
    WEDGE4 = 14,
    MIXED3D6 = 15,
-   MIXED3D8 = 16
+   MIXED3D8 = 16,
+   PYRAMID = 17
 };
 
 Mesh * GetMesh(MeshType type);
@@ -78,7 +79,7 @@ TEST_CASE("Domain Integration (Scalar Field)",
    int order = 2;
 
    for (int mt = (int)MeshType::SEGMENT;
-        mt <= (int)MeshType::MIXED3D8; mt++)
+        mt <= (int)MeshType::PYRAMID; mt++)
    {
       Mesh *mesh = GetMesh((MeshType)mt);
       int  dim = mesh->Dimension();
@@ -654,6 +655,25 @@ Mesh * GetMesh(MeshType type)
          mesh->AddTet(1, 7, 2, 5);
          mesh->AddTet(8, 2, 7, 5);
          break;
+      case PYRAMID:
+         mesh = new Mesh(3, 9, 6);
+         mesh->AddVertex(0.0, 0.0, 0.0);
+         mesh->AddVertex(a_, 0.0, 0.0);
+         mesh->AddVertex(a_, b_, 0.0);
+         mesh->AddVertex(0.0, b_, 0.0);
+         mesh->AddVertex(0.5 * a_, 0.5 * b_, 0.5 * c_);
+         mesh->AddVertex(0.0, 0.0, c_);
+         mesh->AddVertex(a_, 0.0, c_);
+         mesh->AddVertex(a_, b_, c_);
+         mesh->AddVertex(0.0, b_, c_);
+
+         mesh->AddPyramid(0, 1, 2, 3, 4);
+         mesh->AddPyramid(0, 5, 6, 1, 4);
+         mesh->AddPyramid(1, 6, 7, 2, 4);
+         mesh->AddPyramid(2, 7, 8, 3, 4);
+         mesh->AddPyramid(3, 8, 5, 0, 4);
+         mesh->AddPyramid(8, 7, 6, 5, 4);
+         break;
    }
    mesh->FinalizeTopology();
 
diff --git a/tests/unit/fem/test_fe.cpp b/tests/unit/fem/test_fe.cpp
index 6b0bc91ac..acd5ce4be 100644
--- a/tests/unit/fem/test_fe.cpp
+++ b/tests/unit/fem/test_fe.cpp
@@ -206,6 +206,62 @@ TEST_CASE("H1 Wedge Finite Element",
    }
 }
 
+TEST_CASE("H1 Pyramid Finite Element",
+          "[H1_PyramidElement]"
+          "[NodalFiniteElement]"
+          "[ScalarFiniteElement]"
+          "[FiniteElement]")
+{
+   for (int p = 1; p<=4; p++)
+   {
+      H1_FuentesPyramidElement fe(p);
+
+      if (p == 1)
+      {
+         SECTION("Attributes")
+         {
+            REQUIRE( fe.GetDim()            == 3                           );
+            REQUIRE( fe.GetGeomType()       == Geometry::PYRAMID           );
+            REQUIRE( fe.Space()             == (int) FunctionSpace::Uk     );
+            REQUIRE( fe.GetRangeType()      == (int) FiniteElement::SCALAR );
+            REQUIRE( fe.GetMapType()        == (int) FiniteElement::VALUE  );
+            REQUIRE( fe.GetDerivType()      == (int) FiniteElement::GRAD   );
+            REQUIRE( fe.GetDerivRangeType() == (int) FiniteElement::VECTOR );
+            REQUIRE( fe.GetDerivMapType()   == (int) FiniteElement::H_CURL );
+         }
+      }
+      SECTION("Sizes for p = " + std::to_string(p))
+      {
+         REQUIRE( fe.GetDof()   == p*(p*p+3)+1 ); // Fuentes et al
+         REQUIRE( fe.GetOrder() == p                   );
+      }
+   }
+   for (int p = 1; p<=4; p++)
+   {
+      H1_BergotPyramidElement fe(p);
+
+      if (p == 1)
+      {
+         SECTION("Attributes")
+         {
+            REQUIRE( fe.GetDim()            == 3                           );
+            REQUIRE( fe.GetGeomType()       == Geometry::PYRAMID           );
+            REQUIRE( fe.Space()             == (int) FunctionSpace::Uk     );
+            REQUIRE( fe.GetRangeType()      == (int) FiniteElement::SCALAR );
+            REQUIRE( fe.GetMapType()        == (int) FiniteElement::VALUE  );
+            REQUIRE( fe.GetDerivType()      == (int) FiniteElement::GRAD   );
+            REQUIRE( fe.GetDerivRangeType() == (int) FiniteElement::VECTOR );
+            REQUIRE( fe.GetDerivMapType()   == (int) FiniteElement::H_CURL );
+         }
+      }
+      SECTION("Sizes for p = " + std::to_string(p))
+      {
+         REQUIRE( fe.GetDof()   == (p+1)*(p+2)*(2*p+3)/6 ); // JSC
+         REQUIRE( fe.GetOrder() == p                   );
+      }
+   }
+}
+
 TEST_CASE("Nedelec Segment Finite Element",
           "[ND_SegmentElement]"
           "[VectorFiniteElement]"
diff --git a/tests/unit/fem/test_fe_compatibility.cpp b/tests/unit/fem/test_fe_compatibility.cpp
new file mode 100644
index 000000000..bca402778
--- /dev/null
+++ b/tests/unit/fem/test_fe_compatibility.cpp
@@ -0,0 +1,1302 @@
+// Copyright (c) 2010-2025, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mfem.hpp"
+#include "unit_tests.hpp"
+
+using namespace mfem;
+
+Element * GetElement(Geometry::Type type)
+{
+   Element *el = NULL;
+   switch (type)
+   {
+      case Geometry::POINT:
+         el = new Point;
+         break;
+      case Geometry::SEGMENT:
+         el = new Segment;
+         break;
+      case Geometry::TRIANGLE:
+         el = new Triangle;
+         break;
+      case Geometry::SQUARE:
+         el = new Quadrilateral;
+         break;
+      case Geometry::TETRAHEDRON:
+         el = new Tetrahedron;
+         break;
+      case Geometry::CUBE:
+         el = new Hexahedron;
+         break;
+      case Geometry::PRISM:
+         el = new Wedge;
+         break;
+      case Geometry::PYRAMID:
+         el = new Pyramid;
+         break;
+      default:
+         break;
+   }
+   return el;
+}
+
+// Build a mesh containing a single element
+Mesh MakeElementMesh(Geometry::Type type, real_t * vertices)
+{
+   Element *elem = GetElement(type);
+
+   int nvert = elem->GetNVertices();
+
+   Array<int> el_inds(nvert), el_attr(1);
+   for (int i=0; i<nvert; i++) { el_inds[i] = i; }
+   el_attr[0] = 1;
+
+   int dim = 0, sdim = -1;
+   Geometry::Type bdr_type = Geometry::INVALID;
+   if (type == Geometry::SEGMENT)
+   {
+      dim = 1;
+      sdim = 1;
+      bdr_type = Geometry::POINT;
+   }
+   else if (type >= Geometry::TRIANGLE && type <= Geometry::SQUARE)
+   {
+      dim = 2;
+      sdim = 2;
+      bdr_type = Geometry::SEGMENT;
+   }
+   else if (type >= Geometry::TETRAHEDRON)
+   {
+      dim = 3;
+      sdim = 3;
+      bdr_type = Geometry::TRIANGLE;
+   }
+
+   Mesh mesh(vertices, nvert, &el_inds[0], type, &el_attr[0], 1, NULL,
+             bdr_type, NULL, 0, dim, sdim);
+
+   mesh.Finalize();
+
+   delete elem;
+
+   return mesh;
+}
+
+// Build a mesh containing two copies of the edges of a single element.
+// This creates a group of disconnected edges with both possible orientations
+// which are aligned with the edges of the parent element.
+Mesh MakeElementEdgeMesh(Geometry::Type type, real_t * vertices)
+{
+   Element *elem = GetElement(type);
+
+   int dim = 1, sdim = 3;
+
+   int nedge = elem->GetNEdges();
+
+   int neelem = 2 * nedge;
+   int nevert = 2 * neelem;
+
+   Mesh mesh(dim, nevert, neelem, nevert, sdim);
+
+   int v = 0;
+
+   for (int i=0; i<nedge; i++)
+   {
+      const int *everts = elem->GetEdgeVertices(i);
+
+      mesh.AddVertex(vertices[3*everts[0]+0],
+                     vertices[3*everts[0]+1],
+                     vertices[3*everts[0]+2]);
+      mesh.AddVertex(vertices[3*everts[1]+0],
+                     vertices[3*everts[1]+1],
+                     vertices[3*everts[1]+2]);
+      mesh.AddSegment(v, v + 1, 1);
+      mesh.AddBdrPoint(v, everts[0]+1);
+      mesh.AddBdrPoint(v + 1, everts[1]+1);
+      v += 2;
+
+      mesh.AddVertex(vertices[3*everts[1]+0],
+                     vertices[3*everts[1]+1],
+                     vertices[3*everts[1]+2]);
+      mesh.AddVertex(vertices[3*everts[0]+0],
+                     vertices[3*everts[0]+1],
+                     vertices[3*everts[0]+2]);
+      mesh.AddSegment(v, v + 1, 2);
+      mesh.AddBdrPoint(v, everts[1]+1);
+      mesh.AddBdrPoint(v + 1, everts[0]+1);
+      v += 2;
+   }
+   mesh.FinalizeMesh();
+
+   delete elem;
+
+   return mesh;
+}
+
+// Build a mesh containing multiple copies of the faces of a single element.
+// This creates a group of disconnected faces with all possible orientations
+// which are aligned with the faces of the parent element. Specifically, this
+// produces six copies of triangular faces and eight copies of quadrilateral
+// faces.
+Mesh MakeElementFaceMesh(Geometry::Type type, real_t * vertices)
+{
+   Element *elem = GetElement(type);
+
+   int dim = 2, sdim = 3;
+
+   int nface = elem->GetNFaces();
+
+   int nfelem = 0;
+   int nfvert = 0;
+
+   Array<int> nfv(nface);
+   for (int i=0; i<nface; i++)
+   {
+      nfv[i] = elem->GetNFaceVertices(i);
+
+      nfelem += 2 * nfv[i];
+      nfvert += 2 * nfv[i] * nfv[i];
+   }
+
+   Mesh mesh(dim, nfvert, nfelem, 0, sdim);
+
+   int v = 0;
+
+   for (int i=0; i<nface; i++)
+   {
+      const int *fverts = elem->GetFaceVertices(i);
+
+      for (int p=0; p < 2; p++)
+      {
+         for (int o=0; o<nfv[i]; o++)
+         {
+            for (int j=0; j<nfv[i]; j++)
+            {
+               mesh.AddVertex(vertices[3*fverts[j]+0],
+                              vertices[3*fverts[j]+1],
+                              vertices[3*fverts[j]+2]);
+            }
+            if (nfv[i] == 3)
+            {
+               if (p == 0)
+               {
+                  mesh.AddTriangle(v + o%3, v + (o + 1)%3, v + (o + 2)%3, 1);
+               }
+               else
+               {
+                  mesh.AddTriangle(v + (o + 2)%3, v + (o + 1)%3, v + o%3, 1);
+               }
+            }
+            else
+            {
+               if (p == 0)
+               {
+                  mesh.AddQuad(v + (o + 0)%4, v + (o + 1)%4,
+                               v + (o + 2)%4, v + (o + 3)%4, 1);
+               }
+               else
+               {
+                  mesh.AddQuad(v + (o + 3)%4, v + (o + 2)%4,
+                               v + (o + 1)%4, v + (o + 0)%4, 1);
+               }
+            }
+            v += nfv[i];
+         }
+      }
+   }
+   mesh.FinalizeMesh();
+
+   delete elem;
+
+   return mesh;
+}
+
+// For a given element geometry, order, and dof index this function returns
+// the geometry type of the entity associated with that particular H1 index.
+// Additionally finfo returns the numbers of triangular and quadrilateral faces
+// touching this dof index (ntri = finfo % 8, nquad = finfo / 8).
+Geometry::Type GetH1DofType(Geometry::Type geom, int p, int index, int &finfo)
+{
+   finfo = 0;
+   if (geom == Geometry::TETRAHEDRON)
+   {
+      if (index < 4)
+      {
+         finfo = 3;
+         return Geometry::POINT;
+      }
+      if (index < 4 + 6 * (p - 1))
+      {
+         finfo = 2;
+         return Geometry::SEGMENT;
+      }
+      if (index < 4 + 6 * (p - 1) + 2 * (p - 1) * (p - 2))
+      {
+         return Geometry::TRIANGLE;
+      }
+      return Geometry::TETRAHEDRON;
+   }
+   if (geom == Geometry::CUBE)
+   {
+      if (index < 8)
+      {
+         finfo = 8 * 3;
+         return Geometry::POINT;
+      }
+      if (index < 8 + 12 * (p - 1))
+      {
+         finfo = 8 * 2;
+         return Geometry::SEGMENT;
+      }
+      if (index < 8 + 12 * (p - 1) + 6 * (p - 1) * (p - 1))
+      {
+         return Geometry::SQUARE;
+      }
+      return Geometry::CUBE;
+   }
+   if (geom == Geometry::PRISM)
+   {
+      if (index < 6)
+      {
+         finfo = 1 + 8 * 2;
+         return Geometry::POINT;
+      }
+      if (index < 6 + 9 * (p - 1))
+      {
+         finfo = (index < 6 + 6 * (p - 1)) ? (1 + 8 * 1) : (8 * 2);
+         return Geometry::SEGMENT;
+      }
+      if (index < 6 + 9 * (p - 1) + (p - 1) * (p - 2))
+      {
+         return Geometry::TRIANGLE;
+      }
+      if (index < 6 + 9 * (p - 1) + (p - 1) * (p - 2) + 3 * (p - 1) * (p - 1))
+      {
+         return Geometry::SQUARE;
+      }
+      return Geometry::PRISM;
+   }
+   if (geom == Geometry::PYRAMID)
+   {
+      if (index < 5)
+      {
+         finfo = (index < 4) ? (2 + 8 * 1) : 4;
+         return Geometry::POINT;
+      }
+      if (index < 5 + 8 * (p - 1))
+      {
+         finfo = (index < 5 + 4 * (p - 1)) ? (1 + 8 * 1) : 2;
+         return Geometry::SEGMENT;
+      }
+      if (index < 5 + 8 * (p - 1) + (p - 1) * (p - 1))
+      {
+         return Geometry::SQUARE;
+      }
+      if (index < 5 + 8 * (p - 1) + (p - 1) * (p - 1) + 2 * (p - 1) * (p - 2))
+      {
+         return Geometry::TRIANGLE;
+      }
+      return Geometry::PYRAMID;
+   }
+   return Geometry::INVALID;
+}
+
+// For a given element geometry, order, and dof index this function returns
+// the geometry type of the entity associated with that particular Nedelec
+// index.
+// Additionally finfo returns the numbers of triangular and quadrilateral
+// faces touching this dof index (ntri = finfo % 8, nquad = finfo / 8).
+Geometry::Type GetNDDofType(Geometry::Type geom, int p, int index, int &finfo)
+{
+   finfo = 0;
+   if (geom == Geometry::TETRAHEDRON)
+   {
+      if (index < p * 6)
+      {
+         finfo = 2;
+         return Geometry::SEGMENT;
+      }
+      if (index < p * 6 + 4 * p * (p - 1))
+      {
+         return Geometry::TRIANGLE;
+      }
+      return Geometry::TETRAHEDRON;
+   }
+   if (geom == Geometry::CUBE)
+   {
+      if (index < p * 12)
+      {
+         finfo = 8 * 2;
+         return Geometry::SEGMENT;
+      }
+      if (index < p * 12 + 12 * p * (p - 1))
+      {
+         return Geometry::SQUARE;
+      }
+      return Geometry::CUBE;
+   }
+   if (geom == Geometry::PRISM)
+   {
+      if (index < p * 9)
+      {
+         finfo = (index < 6 * p) ? (1 + 8 * 1) : (8 * 2);
+         return Geometry::SEGMENT;
+      }
+      if (index < p * 9 + 2 * p * (p - 1))
+      {
+         return Geometry::TRIANGLE;
+      }
+      if (index < p * 9 + 2 * p * (p - 1) + 6 * p * (p - 1))
+      {
+         return Geometry::SQUARE;
+      }
+      return Geometry::PRISM;
+   }
+   if (geom == Geometry::PYRAMID)
+   {
+      if (index < p * 8)
+      {
+         finfo = (index < 4 * p) ? (1 + 8 * 1) : 2;
+         return Geometry::SEGMENT;
+      }
+      if (index < p * 8 + 2 * p * (p - 1))
+      {
+         return Geometry::SQUARE;
+      }
+      if (index < p * 8 + 2 * p * (p - 1) + 4 * p * (p - 1))
+      {
+         return Geometry::TRIANGLE;
+      }
+      return Geometry::PYRAMID;
+   }
+   return Geometry::INVALID;
+}
+
+// For a given element geometry, order, and dof index this function returns
+// the geometry type of the entity associated with that particular
+// Raviart-Thomas index.
+Geometry::Type GetRTDofType(Geometry::Type geom, int p, int index)
+{
+   if (geom == Geometry::TETRAHEDRON)
+   {
+      if (index < 2 * p * (p + 1))
+      {
+         return Geometry::TRIANGLE;
+      }
+      return Geometry::TETRAHEDRON;
+   }
+   if (geom == Geometry::CUBE)
+   {
+      if (index < 6 * p * p)
+      {
+         return Geometry::SQUARE;
+      }
+      return Geometry::CUBE;
+   }
+   if (geom == Geometry::PRISM)
+   {
+      if (index < p * (p + 1))
+      {
+         return Geometry::TRIANGLE;
+      }
+      if (index < p * (p + 1) + 3 * p * p)
+      {
+         return Geometry::SQUARE;
+      }
+      return Geometry::PRISM;
+   }
+   if (geom == Geometry::PYRAMID)
+   {
+      if (index < p * p)
+      {
+         return Geometry::SQUARE;
+      }
+      if (index < p * p + 2 * p * (p + 1))
+      {
+         return Geometry::TRIANGLE;
+      }
+      return Geometry::PYRAMID;
+   }
+   return Geometry::INVALID;
+}
+
+static real_t ref_tet_vert[] = {0.,0.,0., 1.,0.,0., 0.,1.,0., 0.,0.,1.};
+static real_t equ_tet_vert[] = {0.,0.,0., 1.,0.,0., 0.5,0.8660254037844386,0.,
+                                0.5,0.2886751345948129,0.816496580927726
+                               };
+
+static real_t ref_cub_vert[] = {0.,0.,0., 1.,0.,0., 1.,1.,0., 0.,1.,0.,
+                                0.,0.,1., 1.,0.,1., 1.,1.,1., 0.,1.,1.
+                               };
+static real_t *equ_cub_vert = ref_cub_vert;
+
+static real_t ref_pri_vert[] = {0.,0.,0., 1.,0.,0., 0.,1.,0.,
+                                0.,0.,1., 1.,0.,1., 0.,1.,1.
+                               };
+static real_t equ_pri_vert[] = {0.,0.,0., 1.,0.,0., 0.5,0.8660254037844386,0.,
+                                0.,0.,1., 1.,0.,1., 0.5,0.8660254037844386,1.
+                               };
+
+static real_t ref_pyr_vert[] = {0.,0.,0., 1.,0.,0., 1.,1.,0., 0.,1.,0., 0.,0.,1.};
+static real_t equ_pyr_vert[] = {0.,0.,0., 1.,0.,0., 1.,1.,0., 0.,1.,0.,
+                                0.5,0.5,0.7071067811865475
+                               };
+
+// Coordinate transformation for 3D elements with planar sides
+class VectorTransformation
+{
+protected:
+   Vector a, b, c, d;
+   Vector axb, bxc, cxa;
+   mutable Vector pt0;
+   real_t abc;
+   bool init;
+
+   VectorTransformation() : a(3), b(3), c(3), d(3), axb(3), bxc(3), cxa(3),
+      pt0(3), abc(-1.0), init(false) {}
+
+   void Init()
+   {
+      abc = (a[0] * b[1] * c[2] +
+             a[1] * b[2] * c[0] +
+             a[2] * b[0] * c[1] -
+             a[2] * b[1] * c[0] -
+             a[1] * b[0] * c[2] -
+             a[0] * b[2] * c[1]);
+
+      a.cross3D(b, axb);
+      b.cross3D(c, bxc);
+      c.cross3D(a, cxa);
+
+      init = true;
+   }
+
+   bool CheckPositiveVolume()
+   {
+      if (!init) { Init(); }
+      return abc > 0.0;
+   }
+
+public:
+   VectorTransformation(const Vector &a_, const Vector &b_,
+                        const Vector &c_, const Vector &d_)
+      : a(a_), b(b_), c(c_), d(d_),
+        axb(3), bxc(3), cxa(3),
+        pt0(3), abc(-1.0)
+   {
+      Init();
+
+      if (!CheckPositiveVolume())
+      {
+         mfem::err << "VectorTransformation given invalid vectors\n";
+      }
+   }
+
+   virtual ~VectorTransformation() {}
+
+   virtual void RefToPhys(const Vector &pt, Vector &V) const
+   {
+      V.SetSize(3);
+
+      V = d;
+      V.Add(pt[0], a);
+      V.Add(pt[1], d);
+      V.Add(pt[2], c);
+   }
+
+   virtual void PhysToRef(const Vector &pt, Vector &V) const
+   {
+      V.SetSize(3);
+
+      add(pt, -1.0, d, pt0);
+
+      V[0] = bxc * pt0;
+      V[1] = cxa * pt0;
+      V[2] = axb * pt0;
+      V /= abc;
+   }
+
+   virtual void EvalJ(const Vector &pt, DenseMatrix &J) const
+   {
+      J.SetSize(3);
+
+      J.SetCol(0, a);
+      J.SetCol(1, b);
+      J.SetCol(2, c);
+   }
+
+   virtual real_t DetJ(const Vector &pt) const { return abc; }
+};
+
+class TetrahedronTrans : public VectorTransformation
+{
+public:
+   TetrahedronTrans(real_t *verts)
+   {
+      a[0] = verts[ 3] - verts[0];
+      a[1] = verts[ 4] - verts[1];
+      a[2] = verts[ 5] - verts[2];
+
+      b[0] = verts[ 6] - verts[0];
+      b[1] = verts[ 7] - verts[1];
+      b[2] = verts[ 8] - verts[2];
+
+      c[0] = verts[ 9] - verts[0];
+      c[1] = verts[10] - verts[1];
+      c[2] = verts[11] - verts[2];
+
+      d[0] = verts[0];
+      d[1] = verts[1];
+      d[2] = verts[2];
+
+      if (!CheckPositiveVolume())
+      {
+         mfem::err << "TetrahedronTrans given invalid vertices\n";
+      }
+   }
+};
+
+// Limited to parallelepipeds
+class CubeTrans : public VectorTransformation
+{
+public:
+   CubeTrans(real_t * verts)
+   {
+      a[0] = verts[ 3] - verts[0];
+      a[1] = verts[ 4] - verts[1];
+      a[2] = verts[ 5] - verts[2];
+
+      b[0] = verts[ 9] - verts[0];
+      b[1] = verts[10] - verts[1];
+      b[2] = verts[11] - verts[2];
+
+      c[0] = verts[12] - verts[0];
+      c[1] = verts[13] - verts[1];
+      c[2] = verts[14] - verts[2];
+
+      d[0] = verts[0];
+      d[1] = verts[1];
+      d[2] = verts[2];
+
+      if (!CheckPositiveVolume())
+      {
+         mfem::err << "CubeTrans given invalid vertices\n";
+      }
+
+   }
+};
+
+// Limited to prisms with parallel triangular faces
+class PrismTrans : public VectorTransformation
+{
+public:
+   PrismTrans(real_t * verts)
+   {
+      a[0] = verts[ 3] - verts[0];
+      a[1] = verts[ 4] - verts[1];
+      a[2] = verts[ 5] - verts[2];
+
+      b[0] = verts[ 6] - verts[0];
+      b[1] = verts[ 7] - verts[1];
+      b[2] = verts[ 8] - verts[2];
+
+      c[0] = verts[ 9] - verts[0];
+      c[1] = verts[10] - verts[1];
+      c[2] = verts[11] - verts[2];
+
+      d[0] = verts[0];
+      d[1] = verts[1];
+      d[2] = verts[2];
+
+      if (!CheckPositiveVolume())
+      {
+         mfem::err << "PrismTrans given invalid vertices\n";
+      }
+   }
+};
+
+// Limited to pyramids with parallelogram bases
+class PyramidTrans : public VectorTransformation
+{
+public:
+   PyramidTrans(real_t * verts)
+   {
+      a[0] = verts[ 3] - verts[0];
+      a[1] = verts[ 4] - verts[1];
+      a[2] = verts[ 5] - verts[2];
+
+      b[0] = verts[ 9] - verts[0];
+      b[1] = verts[10] - verts[1];
+      b[2] = verts[11] - verts[2];
+
+      c[0] = verts[12] - verts[0];
+      c[1] = verts[13] - verts[1];
+      c[2] = verts[14] - verts[2];
+
+      d[0] = verts[0];
+      d[1] = verts[1];
+      d[2] = verts[2];
+
+      if (!CheckPositiveVolume())
+      {
+         mfem::err << "PyramidTrans given invalid vertices\n";
+      }
+   }
+};
+
+VectorTransformation *GetVectorTransformation(Geometry::Type geom,
+                                              real_t * verts)
+{
+   if (geom == Geometry::TETRAHEDRON)
+   {
+      return new TetrahedronTrans(verts);
+   }
+   else if (geom == Geometry::CUBE)
+   {
+      return new CubeTrans(verts);
+   }
+   else if (geom == Geometry::PRISM)
+   {
+      return new PrismTrans(verts);
+   }
+   else if (geom == Geometry::PYRAMID)
+   {
+      return new PyramidTrans(verts);
+   }
+   return NULL;
+}
+
+class H1BasisCoef : public Coefficient
+{
+private:
+   int p, ndof;
+
+   Geometry::Type geom;
+   FiniteElement * elem;
+   H1_TetrahedronElement    tet;
+   H1_HexahedronElement     cub;
+   H1_WedgeElement          pri;
+   H1_FuentesPyramidElement pyr;
+
+   VectorTransformation &vtrans;
+
+   Vector dofs;
+   mutable Vector shape;
+
+public:
+   H1BasisCoef(Geometry::Type g_, int p_, VectorTransformation &vtrans_)
+      : p(p_), ndof(-1), geom(g_),
+        tet(p), cub(p), pri(p), pyr(p), vtrans(vtrans_)
+   {
+      dofs = 0.0;
+
+      if (geom == Geometry::TETRAHEDRON)
+      {
+         elem = &tet;
+      }
+      else if (geom == Geometry::CUBE)
+      {
+         elem = &cub;
+      }
+      else if (geom == Geometry::PRISM)
+      {
+         elem = &pri;
+      }
+      else if (geom == Geometry::PYRAMID)
+      {
+         elem = &pyr;
+      }
+
+      ndof = elem->GetDof();
+      dofs.SetSize(ndof);
+      shape.SetSize(ndof);
+   }
+
+   void SetDoF(int dof) { dofs = 0.0; dofs(dof) = 1.0; }
+   int GetNDoF() const { return ndof; }
+
+   real_t Eval(ElementTransformation &T,
+               const IntegrationPoint &ip2d)
+   {
+      real_t pt3d_data[3];
+      real_t ip3d_data[3];
+      Vector pt3d(pt3d_data, 3);
+      Vector ip3d_vec(ip3d_data, 3);
+      T.Transform(ip2d, pt3d);
+
+      vtrans.PhysToRef(pt3d, ip3d_vec);
+
+      IntegrationPoint ip3d; ip3d.Set(ip3d_data, 3);
+      elem->CalcShape(ip3d, shape);
+
+      return dofs * shape;
+   }
+};
+
+class HCurlBasisCoef : public VectorCoefficient
+{
+private:
+   int p, ndof;
+
+   Geometry::Type geom;
+   FiniteElement * elem;
+   ND_TetrahedronElement    tet;
+   ND_HexahedronElement     cub;
+   ND_WedgeElement          pri;
+   ND_FuentesPyramidElement pyr;
+
+   VectorTransformation &vtrans;
+
+   Vector dofs;
+   Vector nor;
+   Vector tng;
+   mutable DenseMatrix jac;
+   mutable DenseMatrix jacInv;
+   mutable DenseMatrix shape;
+   mutable DenseMatrix tshape;
+
+   bool restricted;
+
+public:
+   HCurlBasisCoef(Geometry::Type g_, int p_, VectorTransformation &vtrans_,
+                  bool restricted_ = false)
+      : VectorCoefficient(3),
+        p(p_), ndof(-1), geom(g_),
+        tet(p), cub(p), pri(p), pyr(p), vtrans(vtrans_),
+        nor(3), tng(3), jacInv(3),
+        restricted(restricted_)
+   {
+      dofs = 0.0;
+
+      if (geom == Geometry::TETRAHEDRON)
+      {
+         elem = &tet;
+      }
+      else if (geom == Geometry::CUBE)
+      {
+         elem = &cub;
+      }
+      else if (geom == Geometry::PRISM)
+      {
+         elem = &pri;
+      }
+      else if (geom == Geometry::PYRAMID)
+      {
+         elem = &pyr;
+      }
+
+      ndof = elem->GetDof();
+      dofs.SetSize(ndof);
+      shape.SetSize(ndof, 3);
+      tshape.SetSize(ndof, 3);
+   }
+
+   void SetDoF(int dof) { dofs = 0.0; dofs(dof) = 1.0; }
+   int GetNDoF() const { return ndof; }
+
+   void Eval(Vector &V, ElementTransformation &T,
+             const IntegrationPoint &ip2d)
+   {
+      V.SetSize(3);
+
+      real_t pt3d_data[3];
+      real_t ip3d_data[3];
+      Vector pt3d(pt3d_data, 3);
+      Vector ip3d_vec(ip3d_data, 3);
+      T.Transform(ip2d, pt3d);
+
+      vtrans.PhysToRef(pt3d, ip3d_vec);
+      vtrans.EvalJ(ip3d_vec, jac);
+      CalcInverse(jac, jacInv);
+
+      IntegrationPoint ip3d; ip3d.Set(ip3d_data, 3);
+
+      elem->CalcVShape(ip3d, shape);
+      Mult(shape, jacInv, tshape);
+
+      tshape.MultTranspose(dofs, V);
+
+      if (restricted)
+      {
+         if (T.Jacobian().Width() == 1)
+         {
+            tng[0] = T.Jacobian()(0,0);
+            tng[1] = T.Jacobian()(1,0);
+            tng[2] = T.Jacobian()(2,0);
+            tng /= tng.Norml2();
+            real_t tV = tng * V;
+            V.Set(tV, tng);
+         }
+         else if (T.Jacobian().Width() == 2)
+         {
+            CalcOrtho(T.Jacobian(), nor);
+            nor /= nor.Norml2();
+
+            real_t nV = nor * V;
+            V.Add(-nV, nor);
+         }
+      }
+   }
+};
+
+class HDivBasisCoef : public VectorCoefficient
+{
+private:
+   int p, ndof;
+
+   Geometry::Type geom;
+   FiniteElement * elem;
+   RT_TetrahedronElement    tet;
+   RT_HexahedronElement     cub;
+   RT_WedgeElement          pri;
+   RT_FuentesPyramidElement pyr;
+
+   VectorTransformation &vtrans;
+
+   Vector dofs;
+   mutable DenseMatrix jac;
+   mutable DenseMatrix shape;
+   mutable DenseMatrix tshape;
+
+public:
+   HDivBasisCoef(Geometry::Type g_, int p_, VectorTransformation &vtrans_)
+      : VectorCoefficient(3),
+        p(p_), ndof(-1), geom(g_),
+        tet(p), cub(p), pri(p), pyr(p), vtrans(vtrans_)
+   {
+      dofs = 0.0;
+
+      if (geom == Geometry::TETRAHEDRON)
+      {
+         elem = &tet;
+      }
+      else if (geom == Geometry::CUBE)
+      {
+         elem = &cub;
+      }
+      else if (geom == Geometry::PRISM)
+      {
+         elem = &pri;
+      }
+      else if (geom == Geometry::PYRAMID)
+      {
+         elem = &pyr;
+      }
+
+      ndof = elem->GetDof();
+      dofs.SetSize(ndof);
+      shape.SetSize(ndof, 3);
+      tshape.SetSize(ndof, 3);
+   }
+
+   void SetDoF(int dof) { dofs = 0.0; dofs(dof) = 1.0; }
+   int GetNDoF() const { return ndof; }
+
+   void Eval(Vector &V, ElementTransformation &T,
+             const IntegrationPoint &ip2d)
+   {
+      V.SetSize(3);
+
+      real_t pt3d_data[3];
+      real_t ip3d_data[3];
+      Vector pt3d(pt3d_data, 3);
+      Vector ip3d_vec(ip3d_data, 3);
+      T.Transform(ip2d, pt3d);
+
+      vtrans.PhysToRef(pt3d, ip3d_vec);
+      vtrans.EvalJ(ip3d_vec, jac);
+
+      IntegrationPoint ip3d; ip3d.Set(ip3d_data, 3);
+
+      elem->CalcVShape(ip3d, shape);
+      MultABt(shape, jac, tshape);
+      tshape *= 1/jac.Det();
+
+      tshape.MultTranspose(dofs, V);
+   }
+};
+
+class HDivTraceBasisCoef : public Coefficient
+{
+private:
+   int p, ndof;
+
+   Geometry::Type geom;
+   FiniteElement * elem;
+   RT_TetrahedronElement    tet;
+   RT_HexahedronElement     cub;
+   RT_WedgeElement          pri;
+   RT_FuentesPyramidElement pyr;
+
+   VectorTransformation &vtrans;
+
+   Vector dofs;
+   Vector V;
+   Vector nor;
+   mutable DenseMatrix jac;
+   mutable DenseMatrix shape;
+   mutable DenseMatrix tshape;
+
+public:
+   HDivTraceBasisCoef(Geometry::Type g_, int p_, VectorTransformation &vtrans_)
+      : p(p_), ndof(-1), geom(g_),
+        tet(p), cub(p), pri(p), pyr(p), vtrans(vtrans_), V(3), nor(3)
+   {
+      dofs = 0.0;
+
+      if (geom == Geometry::TETRAHEDRON)
+      {
+         elem = &tet;
+      }
+      else if (geom == Geometry::CUBE)
+      {
+         elem = &cub;
+      }
+      else if (geom == Geometry::PRISM)
+      {
+         elem = &pri;
+      }
+      else if (geom == Geometry::PYRAMID)
+      {
+         elem = &pyr;
+      }
+
+      ndof = elem->GetDof();
+      dofs.SetSize(ndof);
+      shape.SetSize(ndof, 3);
+      tshape.SetSize(ndof, 3);
+   }
+
+   void SetDoF(int dof) { dofs = 0.0; dofs(dof) = 1.0; }
+   int GetNDoF() const { return ndof; }
+
+   real_t Eval(ElementTransformation &T,
+               const IntegrationPoint &ip2d)
+   {
+      real_t pt3d_data[3];
+      real_t ip3d_data[3];
+      Vector pt3d(pt3d_data, 3);
+      Vector ip3d_vec(ip3d_data, 3);
+      T.Transform(ip2d, pt3d);
+
+      vtrans.PhysToRef(pt3d, ip3d_vec);
+      vtrans.EvalJ(ip3d_vec, jac);
+
+      IntegrationPoint ip3d; ip3d.Set(ip3d_data, 3);
+
+      elem->CalcVShape(ip3d, shape);
+      MultABt(shape, jac, tshape);
+      tshape *= 1/jac.Det();
+
+      tshape.MultTranspose(dofs, V);
+
+      CalcOrtho(T.Jacobian(), nor);
+      nor /= nor.Norml2();
+
+      return nor * V;
+   }
+};
+
+TEST_CASE("FE Compatibility",
+          "[H1_TetrahedronElement]"
+          "[H1_HexahedronElement]"
+          "[H1_WedgeElement]"
+          "[H1_PyramidElement]"
+          "[ND_TetrahedronElement]"
+          "[ND_HexahedronElement]"
+          "[ND_WedgeElement]"
+          "[ND_PyramidElement]"
+          "[RT_TetrahedronElement]"
+          "[RT_HexahedronElement]"
+          "[RT_WedgeElement]"
+          "[RT_PyramidElement]")
+{
+   auto geom = GENERATE(Geometry::TETRAHEDRON, Geometry::CUBE,
+                        Geometry::PRISM, Geometry::PYRAMID);
+   auto ref = GENERATE(false);
+   auto p = GENERATE(3);
+
+   CAPTURE(geom);
+   CAPTURE(ref);
+   CAPTURE(p);
+
+   real_t *geom_vert = NULL;
+   switch (geom)
+   {
+      case Geometry::TETRAHEDRON:
+         geom_vert = ref ? ref_tet_vert : equ_tet_vert;
+         break;
+      case Geometry::CUBE:
+         geom_vert = ref ? ref_cub_vert : equ_cub_vert;
+         break;
+      case Geometry::PRISM:
+         geom_vert = ref ? ref_pri_vert : equ_pri_vert;
+         break;
+      case Geometry::PYRAMID:
+         geom_vert = ref ? ref_pyr_vert : equ_pyr_vert;
+         break;
+      default:
+         break;
+   };
+   VectorTransformation *vtrans = GetVectorTransformation(geom, geom_vert);
+
+   Mesh elem_mesh = MakeElementMesh(geom, geom_vert);
+   Mesh edge_mesh = MakeElementEdgeMesh(geom, geom_vert);
+   Mesh face_mesh = MakeElementFaceMesh(geom, geom_vert);
+
+   real_t tol = 1e-10;
+
+   SECTION("H1 Trace")
+   {
+      H1_FECollection h1_fec_1d(p, 1);
+      H1_FECollection h1_fec_2d(p, 2);
+      H1_FECollection h1_fec_3d(p, 3);
+
+      FiniteElementSpace h1_fes_1d(&edge_mesh, &h1_fec_1d);
+      FiniteElementSpace h1_fes_2d(&face_mesh, &h1_fec_2d);
+      FiniteElementSpace h1_fes_3d(&elem_mesh, &h1_fec_3d);
+
+      GridFunction h1_gf_1d(&h1_fes_1d);
+      GridFunction h1_gf_2d(&h1_fes_2d);
+      GridFunction h1_gf_3d(&h1_fes_3d);
+
+      H1BasisCoef H1Coef(geom, p, *vtrans);
+
+      for (int i=0; i<H1Coef.GetNDoF(); i++)
+      {
+         CAPTURE(i);
+
+         H1Coef.SetDoF(i);
+
+         h1_gf_1d.ProjectCoefficient(H1Coef);
+         h1_gf_2d.ProjectCoefficient(H1Coef);
+         h1_gf_3d.ProjectCoefficient(H1Coef);
+
+         real_t nrmlinf_1d = h1_gf_1d.Normlinf();
+         real_t nrmlinf_2d = h1_gf_2d.Normlinf();
+         real_t nrmlinf_3d = h1_gf_3d.Normlinf();
+
+         real_t nrml1_1d   = h1_gf_1d.Norml1();
+         real_t nrml1_2d   = h1_gf_2d.Norml1();
+         real_t nrml1_3d   = h1_gf_3d.Norml1();
+
+         // Should produce exactly one non-zero in 3D
+         REQUIRE(fabs(nrml1_3d - nrmlinf_3d) < tol * nrmlinf_3d);
+
+         int finfo = 0;
+         Geometry::Type dofType = GetH1DofType(geom, p, i, finfo);
+
+         int ntri = finfo % 8;
+         int nsqr = finfo / 8;
+
+         if (dofType == Geometry::POINT)
+         {
+            real_t a_1d = (geom == Geometry::PYRAMID && i == 4) ? 8.0 : 6.0;
+            real_t a_2d = 6.0 * ntri + 8.0 * nsqr;
+
+            // In most case this should find exactly six non-zeros with equal
+            // values in 1D trace
+            // - Two dofs for every edge which meets at the vertex
+            //
+            // The apex of a pyramid is a special case where four edges meet
+            // producing exactly 8 non-zeros with equal values
+            REQUIRE(fabs(nrml1_1d - a_1d * nrmlinf_1d) < tol * nrmlinf_1d);
+
+            // The number of non-zeros in the 2D trace will depend on the
+            // types of faces meeting at each vertex.
+            REQUIRE(fabs(nrml1_2d - a_2d * nrmlinf_2d) < tol * nrmlinf_2d);
+         }
+         else if (dofType == Geometry::SEGMENT)
+         {
+            real_t a_2d = 6.0 * ntri + 8.0 * nsqr;
+
+            // Should find exactly two non-zeros with equal values in 1D trace
+            REQUIRE(fabs(nrml1_1d - 2.0 * nrmlinf_1d) < tol * nrmlinf_1d);
+
+            // The number of non-zeros in the 2D trace will depend on the
+            // types of faces meeting at each edge.
+            REQUIRE(fabs(nrml1_2d - a_2d * nrmlinf_2d) < tol * nrmlinf_2d);
+         }
+         else if (dofType == Geometry::TRIANGLE)
+         {
+            // Should find exactly zero non-zeros in 1D trace
+            REQUIRE(nrmlinf_1d < tol);
+
+            // Should find exactly six non-zeros with equal values in 2D trace
+            // - One non-zero in each of the six possible triangle
+            //   orientations
+            REQUIRE(fabs(nrml1_2d - 6 * nrmlinf_2d) < tol * nrmlinf_2d);
+         }
+         else if (dofType == Geometry::SQUARE)
+         {
+            // Should find exactly zero non-zeros in 1D trace
+            REQUIRE(nrmlinf_1d < tol);
+
+            // Should find exactly eight non-zeros with equal values in 2D trace
+            // - One non-zero in each of the eight possible quadrilateral
+            //   orientations
+            REQUIRE(fabs(nrml1_2d - 8 * nrmlinf_2d) < tol * nrmlinf_2d);
+         }
+         else
+         {
+            // Should find exactly zero non-zeros in 1D and 2D traces
+            REQUIRE(nrmlinf_1d < tol);
+            REQUIRE(nrmlinf_2d < tol);
+         }
+      }
+   }
+
+   SECTION("ND Trace")
+   {
+      ND_FECollection nd_fec_1d(p, 1);
+      ND_FECollection nd_fec_2d(p, 2);
+      ND_FECollection nd_fec_3d(p, 3);
+
+      FiniteElementSpace nd_fes_1d(&edge_mesh, &nd_fec_1d);
+      FiniteElementSpace nd_fes_2d(&face_mesh, &nd_fec_2d);
+      FiniteElementSpace nd_fes_3d(&elem_mesh, &nd_fec_3d);
+
+      GridFunction nd_gf_1d(&nd_fes_1d);
+      GridFunction nd_gf_2d(&nd_fes_2d);
+      GridFunction nd_gf_3d(&nd_fes_3d);
+
+      HCurlBasisCoef HCurlFullCoef(geom, p, *vtrans, false);
+      HCurlBasisCoef HCurlTraceCoef(geom, p, *vtrans, true);
+
+      for (int i=0; i<HCurlFullCoef.GetNDoF(); i++)
+      {
+         HCurlFullCoef.SetDoF(i);
+         HCurlTraceCoef.SetDoF(i);
+
+         nd_gf_1d.ProjectCoefficient(HCurlTraceCoef);
+         nd_gf_2d.ProjectCoefficient(HCurlTraceCoef);
+         nd_gf_3d.ProjectCoefficient(HCurlFullCoef);
+
+         real_t nrmlinf_1d = nd_gf_1d.Normlinf();
+         real_t nrmlinf_2d = nd_gf_2d.Normlinf();
+         real_t nrmlinf_3d = nd_gf_3d.Normlinf();
+
+         real_t nrml1_1d   = nd_gf_1d.Norml1();
+         real_t nrml1_2d   = nd_gf_2d.Norml1();
+         real_t nrml1_3d   = nd_gf_3d.Norml1();
+
+         // Should produce exactly one non-zero in 3D
+         REQUIRE(fabs(nrml1_3d - nrmlinf_3d) < tol * nrmlinf_3d);
+
+         int finfo = 0;
+         Geometry::Type dofType = GetNDDofType(geom, p, i, finfo);
+
+         int ntri = finfo % 8;
+         int nsqr = finfo / 8;
+
+         if (dofType == Geometry::SEGMENT)
+         {
+            real_t a_2d = 6.0 * ntri + 8.0 * nsqr;
+
+            // Should find exactly two non-zeros with equal values in 1D trace
+            REQUIRE(fabs(nrml1_1d - 2.0 * nrmlinf_1d) < tol * nrmlinf_1d);
+
+            // The number of non-zeros in the 2D trace will depend on the
+            // types of faces meeting at each edge.
+            REQUIRE(fabs(nrml1_2d - a_2d * nrmlinf_2d) < tol * nrmlinf_2d);
+         }
+         else if (dofType == Geometry::TRIANGLE)
+         {
+            // Should find exactly zero non-zeros in 1D trace
+            REQUIRE(nrmlinf_1d < tol);
+
+            // Should find exactly eight non-zeros with equal values in 2D trace
+            // - Four values come from orientations in which the x or y axis of
+            //   the reference triangle aligns with those of the 3D element.
+            // - The other four values correspond to the two alignments where
+            //   the 3D basis function aligns with the third edge of the
+            //   reference triangle.
+            REQUIRE(fabs(nrml1_2d - 8 * nrmlinf_2d) < tol * nrmlinf_2d);
+         }
+         else if (dofType == Geometry::SQUARE)
+         {
+            // Should find exactly zero non-zeros in 1D trace
+            REQUIRE(nrmlinf_1d < tol);
+
+            // Should find exactly eight non-zeros with equal values in 2D trace
+            // - One non-zero in each of the eight possible quadrilateral
+            //   orientations
+            REQUIRE(fabs(nrml1_2d - 8 * nrmlinf_2d) < tol * nrmlinf_2d);
+         }
+         else
+         {
+            // Should find exactly zero non-zeros in 1D and 2D traces
+            REQUIRE(nrmlinf_1d < tol);
+            REQUIRE(nrmlinf_2d < tol);
+         }
+      }
+   }
+
+   SECTION("RT Trace")
+   {
+      L2_FECollection rt_fec_2d(p - 1, 2,
+                                BasisType::GaussLegendre,
+                                FiniteElement::INTEGRAL);
+      RT_FECollection rt_fec_3d(p - 1, 3);
+
+      FiniteElementSpace rt_fes_2d(&face_mesh, &rt_fec_2d);
+      FiniteElementSpace rt_fes_3d(&elem_mesh, &rt_fec_3d);
+
+      GridFunction rt_gf_2d(&rt_fes_2d);
+      GridFunction rt_gf_3d(&rt_fes_3d);
+
+      HDivBasisCoef HDivFullCoef(geom, p - 1, *vtrans);
+      HDivTraceBasisCoef HDivTraceCoef(geom, p - 1, *vtrans);
+
+      for (int i=0; i<HDivFullCoef.GetNDoF(); i++)
+      {
+         CAPTURE(i);
+
+         HDivFullCoef.SetDoF(i);
+         HDivTraceCoef.SetDoF(i);
+         rt_gf_2d.ProjectCoefficient(HDivTraceCoef);
+         rt_gf_3d.ProjectCoefficient(HDivFullCoef);
+
+         real_t nrmlinf_2d = rt_gf_2d.Normlinf();
+         real_t nrmlinf_3d = rt_gf_3d.Normlinf();
+
+         real_t nrml1_2d   = rt_gf_2d.Norml1();
+         real_t nrml1_3d   = rt_gf_3d.Norml1();
+
+         // Should produce exactly one non-zero in 3D
+         REQUIRE(fabs(nrml1_3d - nrmlinf_3d) < tol * nrmlinf_3d);
+
+         Geometry::Type dofType = GetRTDofType(geom, p, i);
+
+         if (dofType == Geometry::TRIANGLE)
+         {
+            // Should find exactly six non-zeros with equal values in 2D trace
+            // - One non-zero in each of the six possible triangle orientations
+            REQUIRE(fabs(nrml1_2d - 6 * nrmlinf_2d) < tol * nrmlinf_2d);
+         }
+         else if (dofType == Geometry::SQUARE)
+         {
+            // Should find exactly eight non-zeros with equal values in 2D trace
+            // - One non-zero in each of the eight possible quadrilateral
+            //   orientations
+            REQUIRE(fabs(nrml1_2d - 8 * nrmlinf_2d) < tol * nrmlinf_2d);
+         }
+         else
+         {
+            // Should find exactly zero non-zeros in 2D trace
+            REQUIRE(nrmlinf_2d < tol);
+         }
+      }
+   }
+
+   delete vtrans;
+}
diff --git a/tests/unit/fem/test_fe_fixed.cpp b/tests/unit/fem/test_fe_fixed.cpp
new file mode 100644
index 000000000..439991c73
--- /dev/null
+++ b/tests/unit/fem/test_fe_fixed.cpp
@@ -0,0 +1,188 @@
+// Copyright (c) 2010-2025, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mfem.hpp"
+#include "unit_tests.hpp"
+
+using namespace mfem;
+
+void CompareFE(const FiniteElement &fe1, const FiniteElement &fe2)
+{
+   REQUIRE(fe1.GetDim()               == fe2.GetDim());
+   REQUIRE(fe1.GetRangeDim()          == fe2.GetRangeDim());
+   REQUIRE(fe1.GetCurlDim()           == fe2.GetCurlDim());
+   REQUIRE(fe1.GetGeomType()          == fe2.GetGeomType());
+   REQUIRE(fe1.GetDof()               == fe2.GetDof());
+   REQUIRE(fe1.GetOrder()             == fe2.GetOrder());
+   REQUIRE(fe1.GetRangeType()         == fe2.GetRangeType());
+   REQUIRE(fe1.GetDerivRangeType()    == fe2.GetDerivRangeType());
+   REQUIRE(fe1.GetMapType()           == fe2.GetMapType());
+   REQUIRE(fe1.GetDerivType()         == fe2.GetDerivType());
+   REQUIRE(fe1.GetDerivMapType()      == fe2.GetDerivMapType());
+
+   REQUIRE(fe1.HasAnisotropicOrders() == fe2.HasAnisotropicOrders());
+   REQUIRE(fe1.Space()                == fe2.Space());
+
+   // Get a uniform grid or integration points
+   const int res = 4;
+   RefinedGeometry* ref = GlobGeometryRefiner.Refine( fe1.GetGeomType(), res);
+   const IntegrationRule& intRule = ref->RefPts;
+   int npoints = intRule.GetNPoints();
+
+   if (fe1.GetRangeType() == FiniteElement::RangeType::SCALAR)
+   {
+      Vector s1(fe1.GetDof());
+      Vector s2(fe2.GetDof());
+
+      for (int i=0; i < npoints; i++)
+      {
+         // Get the current integration point from intRule
+         IntegrationPoint ip = intRule.IntPoint(i);
+
+         CAPTURE(ip.x, ip.y, ip.z);
+
+         fe1.CalcShape(ip, s1);
+         fe2.CalcShape(ip, s2);
+
+         s2 -= s1;
+
+         REQUIRE(s2.Norml2() == MFEM_Approx(0.));
+      }
+   }
+   if (fe1.GetRangeType() == FiniteElement::RangeType::VECTOR)
+   {
+      DenseMatrix s1(fe1.GetDof(), fe1.GetRangeDim());
+      DenseMatrix s2(fe2.GetDof(), fe2.GetRangeDim());
+
+      for (int i=0; i < npoints; i++)
+      {
+         // Get the current integration point from intRule
+         IntegrationPoint ip = intRule.IntPoint(i);
+
+         CAPTURE(ip.x, ip.y, ip.z);
+
+         fe1.CalcVShape(ip, s1);
+         fe2.CalcVShape(ip, s2);
+
+         s2 -= s1;
+
+         REQUIRE(s2.FNorm2() == MFEM_Approx(0.));
+      }
+   }
+   if (fe1.GetDerivType() == FiniteElement::DerivType::GRAD)
+   {
+      DenseMatrix s1(fe1.GetDof(), fe1.GetDim());
+      DenseMatrix s2(fe2.GetDof(), fe2.GetDim());
+
+      for (int i=0; i < npoints; i++)
+      {
+         // Get the current integration point from intRule
+         IntegrationPoint ip = intRule.IntPoint(i);
+
+         CAPTURE(ip.x, ip.y, ip.z);
+
+         fe1.CalcDShape(ip, s1);
+         fe2.CalcDShape(ip, s2);
+
+         s2 -= s1;
+
+         REQUIRE(s2.FNorm2() == MFEM_Approx(0.));
+      }
+   }
+   if (fe1.GetDerivType() == FiniteElement::DerivType::CURL)
+   {
+      DenseMatrix s1(fe1.GetDof(), fe1.GetCurlDim());
+      DenseMatrix s2(fe2.GetDof(), fe2.GetCurlDim());
+
+      for (int i=0; i < npoints; i++)
+      {
+         // Get the current integration point from intRule
+         IntegrationPoint ip = intRule.IntPoint(i);
+
+         CAPTURE(ip.x, ip.y, ip.z);
+
+         fe1.CalcCurlShape(ip, s1);
+         fe2.CalcCurlShape(ip, s2);
+
+         s2 -= s1;
+
+         REQUIRE(s2.FNorm2() == MFEM_Approx(0.));
+      }
+   }
+   if (fe1.GetDerivType() == FiniteElement::DerivType::DIV)
+   {
+      Vector s1(fe1.GetDof());
+      Vector s2(fe2.GetDof());
+
+      for (int i=0; i < npoints; i++)
+      {
+         // Get the current integration point from intRule
+         IntegrationPoint ip = intRule.IntPoint(i);
+
+         CAPTURE(ip.x, ip.y, ip.z);
+
+         fe1.CalcDivShape(ip, s1);
+         fe2.CalcDivShape(ip, s2);
+
+         s2 -= s1;
+
+         REQUIRE(s2.Norml2() == MFEM_Approx(0.));
+      }
+   }
+}
+
+TEST_CASE("Fixed Order Finite Elements",
+          "[LinearPyramidFiniteElement]"
+          "[Nedelec1PyrFiniteElement]"
+          // "[Nedelec2PyrFiniteElement]"
+          "[RT0PyrFiniteElement]"
+          "[P0PyrFiniteElement]")
+{
+   SECTION("H1 Order 1")
+   {
+      LinearPyramidFiniteElement fo;
+      H1_FuentesPyramidElement ao(1);
+
+      CompareFE(fo, ao);
+   }
+   SECTION("Nedelec Order 1")
+   {
+      Nedelec1PyrFiniteElement fo;
+      ND_FuentesPyramidElement ao(1);
+
+      CompareFE(fo, ao);
+   }
+   SECTION("Raviart-Thomas Order 0")
+   {
+      RT0PyrFiniteElement fo(false);
+      RT_FuentesPyramidElement ao(0);
+
+      CompareFE(fo, ao);
+   }
+   SECTION("L2 Order 0")
+   {
+      P0PyrFiniteElement fo;
+      L2_FuentesPyramidElement ao(0);
+
+      CompareFE(fo, ao);
+   }
+   /*
+   /// The following comparison fails because these two sets of basis functions
+   /// define the interior functions differently
+   SECTION("Nedelec Order 2")
+   {
+     Nedelec2PyrFiniteElement fo;
+     ND_FuentesPyramidElement ao(2);
+
+     CompareFE(fo, ao);
+   }
+   */
+}
diff --git a/tests/unit/fem/test_fe_symmetry.cpp b/tests/unit/fem/test_fe_symmetry.cpp
new file mode 100644
index 000000000..2a108529f
--- /dev/null
+++ b/tests/unit/fem/test_fe_symmetry.cpp
@@ -0,0 +1,446 @@
+// Copyright (c) 2010-2025, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mfem.hpp"
+#include "unit_tests.hpp"
+
+using namespace mfem;
+
+// Use the Hungarian algorithm to find the column permutation of A which
+// produces a matrix with the minimum trace.
+Array<int> findMinTracePermutation(const DenseMatrix &A)
+{
+   const int R = A.NumRows(), C = A.NumCols();
+   MFEM_VERIFY(R <= C, "Matrix must have at least as many columns as rows");
+
+   Array<int> perm(C + 1); perm = -1;
+   Vector potR(R); potR = 0.0;
+   Vector potC(C + 1); potC = 0.0;
+
+   const real_t inf = std::numeric_limits<real_t>::max();
+
+   for (int r_cur = 0; r_cur < R; ++r_cur)
+   {
+      int c_cur = C;
+      perm[c_cur] = r_cur;
+
+      Vector min_to(C + 1); min_to = inf;
+      Array<int> prv_col(C + 1); prv_col = -1;
+      Array<bool> col_in_path(C + 1); col_in_path = false;
+
+      while (perm[c_cur] != -1)
+      {
+         col_in_path[c_cur] = true;
+         const int r = perm[c_cur];
+         real_t delta = inf;
+         int c_next = 0;
+         for (int c = 0; c < C; ++c)
+         {
+            if (!col_in_path[c])
+            {
+               const real_t d = A(r,c) - potR[r] - potC[c];
+               if (d < min_to[c])
+               {
+                  min_to[c] = d;
+                  prv_col[c] = c_cur;
+               }
+               if (min_to[c] < delta)
+               {
+                  delta = min_to[c];
+                  c_next = c;
+               }
+            }
+         }
+         for (int c = 0; c <= C; ++c)
+         {
+            if (col_in_path[c])
+            {
+               potR[perm[c]] += delta;
+               potC[c] -= delta;
+            }
+            else
+            {
+               min_to[c] -= delta;
+            }
+         }
+         c_cur = c_next;
+      }
+      for (int c; c_cur != C; c_cur = c)
+      {
+         c = prv_col[c_cur];
+         perm[c_cur] = perm[c];
+      }
+   }
+
+   return perm;
+}
+
+/// We require that our pyramid basis functions possess four-fold rotational
+/// symmetry. This implies that:
+///    P s1 t1 = s0
+/// Where s0 and s1 are the shape functions evaluated at a random point and its
+/// image under rotation respectively. Also, t1 is the Piola transform
+/// for the finte element type and P is a signed permutation matrix. The signs
+/// of the permutation entries can be determined by the conventions used
+/// for the DoFs of the various basis functions. These signs are passed to this
+/// function in the ps argument. The remaining structure of the permutation is
+/// computed using findMinTracePermutation with the matrix ps * s1 * t1 * s0^T.
+///
+real_t computeVShapeDifference(const DenseMatrix &s0,
+                               const DenseMatrix &ts1,
+                               const Vector &ps)
+{
+   const int dof = s0.Height();
+   const int dim = s0.Width();
+
+   DenseMatrix pts1(ts1);
+   pts1.LeftScaling(ps);
+
+   DenseMatrix sts(dof);
+   MultABt(pts1, s0, sts); sts *= -1.0;
+   Array<int> perm = findMinTracePermutation(sts);
+
+   real_t nrm = 0.0;
+   for (int i=0; i<perm.Size() - 1; i++)
+   {
+      int i0 = i;
+      int i1 = perm[i];
+
+      for (int d=0; d<dim; d++)
+      {
+         nrm += pow(s0(i0, d) - pts1(i1, d), 2);
+      }
+   }
+
+   return nrm;
+}
+
+TEST_CASE("FE Symmetry",
+          "[H1_FuentesPyramidElemet]"
+          "[ND_FuentesPyramidElemet]"
+          "[RT_FuentesPyramidElemet]"
+          "[L2_FuentesPyramidElemet]")
+{
+   const int order = 3;
+   const int npts = 3;
+   const real_t tol = 1e-13;
+
+   CAPTURE(order);
+
+   IsoparametricTransformation T;
+   T.SetIdentityTransformation(Geometry::PYRAMID);
+   {
+      DenseMatrix &ptMat = T.GetPointMat();
+      ptMat.SetCol(0, Vector({-0.5, -0.5, 0.0}));
+      ptMat.SetCol(1, Vector({ 0.5, -0.5, 0.0}));
+      ptMat.SetCol(2, Vector({ 0.5,  0.5, 0.0}));
+      ptMat.SetCol(3, Vector({-0.5,  0.5, 0.0}));
+      ptMat.SetCol(4, Vector({ 0.0,  0.0, M_SQRT1_2}));
+      T.Reset();
+   }
+
+   for (int k=0; k<npts; k++)
+   {
+      double a = rand() / double(RAND_MAX);
+      double b = rand() / double(RAND_MAX);
+      double c = 0.9 * rand() / double(RAND_MAX);
+
+      // Select a random point inside a pyramid
+      IntegrationPoint ip0;
+      ip0.x = a * (1.0 - c); ip0.y = b * (1.0 - c); ip0.z = c;
+
+      SECTION("H1_FuentesFiniteElement")
+      {
+         H1_FuentesPyramidElement fe(order);
+
+         DenseMatrix s0(fe.GetDof(), 1);
+         DenseMatrix s1(fe.GetDof(), 1);
+
+         Vector v0(s0.GetData(), fe.GetDof());
+         Vector v1(s1.GetData(), fe.GetDof());
+
+         T.SetIntPoint(&ip0);
+         fe.CalcPhysShape(T, v0);
+
+         // 90 Degree Rotational Symmetry
+         {
+            IntegrationPoint ip1;
+            ip1.x = ip0.y;
+            ip1.y = 1.0 - ip0.x - ip0.z;
+            ip1.z = ip0.z;
+
+            T.SetIntPoint(&ip1);
+            fe.CalcPhysShape(T, v1);
+
+            Vector ps(fe.GetDof()); ps = 1.0;
+
+            REQUIRE(computeVShapeDifference(s0, s1, ps) < tol);
+         }
+
+         // 180 Degree Rotational Symmetry
+         {
+            IntegrationPoint ip1;
+            ip1.x = 1.0 - ip0.x - ip0.z;
+            ip1.y = 1.0 - ip0.y - ip0.z;
+            ip1.z = ip0.z;
+
+            T.SetIntPoint(&ip1);
+            fe.CalcPhysShape(T, v1);
+
+            Vector ps(fe.GetDof()); ps = 1.0;
+
+            REQUIRE(computeVShapeDifference(s0, s1, ps) < tol);
+         }
+
+         // 270 Degree Rotational Symmetry
+         {
+            IntegrationPoint ip1;
+            ip1.x = 1.0 - ip0.y - ip0.z;
+            ip1.y = ip0.x;
+            ip1.z = ip0.z;
+
+            T.SetIntPoint(&ip1);
+            fe.CalcPhysShape(T, v1);
+
+            Vector ps(fe.GetDof()); ps = 1.0;
+
+            REQUIRE(computeVShapeDifference(s0, s1, ps) < tol);
+         }
+      }
+
+      SECTION("ND_FuentesPyramidElement")
+      {
+         const int ne = order; // Num DoFs per edge
+         const int nt = order * (order - 1); // Num DoF per tri face
+         const int nq = 2 * nt; // Num DoF per quad face
+         const int ni = order * pow(order - 1, 2); // Num DoF per interior dir
+         const int oq = 8 * ne; // Offset to first quad DoF
+         const int ot = oq + nq; // Offset to first tri DoF
+         const int oi = ot + 4 * nt; // Offset to first interior DoF
+
+         ND_FuentesPyramidElement fe(order);
+
+         DenseMatrix s0(fe.GetDof(), 3);
+         DenseMatrix s1(fe.GetDof(), 3);
+
+         DenseMatrix t1(3);
+         DenseMatrix t1Inv(3);
+         DenseMatrix ts1(fe.GetDof(), 3);
+
+         T.SetIntPoint(&ip0);
+         fe.CalcPhysVShape(T, s0);
+
+         // 90 Degree Rotational Symmetry
+         {
+            IntegrationPoint ip1;
+            ip1.x = ip0.y;
+            ip1.y = 1.0 - ip0.x - ip0.z;
+            ip1.z = ip0.z;
+
+            t1Inv = 0.0; t1Inv(0,1) = 1.0; t1Inv(1,0) = -1.0; t1Inv(2,2) = 1.0;
+
+            T.SetIntPoint(&ip1);
+            fe.CalcPhysVShape(T, s1); Mult(s1, t1Inv, ts1);
+
+            Vector ps(fe.GetDof()); ps = 1.0;
+            for (int i = ne; i < 2 * ne; i++) { ps[i] = -1; }
+            for (int i = 3 * ne; i<4*ne; i++) { ps[i] = -1; }
+            for (int i = oq; i < oq + nt; i++) { ps[i] = -1; }
+            for (int i = oi + ni; i < oi + 2 * ni; i++) { ps[i] = -1; }
+
+            REQUIRE(computeVShapeDifference(s0, ts1, ps) < tol);
+         }
+
+         // 180 Degree Rotational Symmetry
+         {
+            IntegrationPoint ip1;
+            ip1.x = 1.0 - ip0.x - ip0.z;
+            ip1.y = 1.0 - ip0.y - ip0.z;
+            ip1.z = ip0.z;
+
+            t1Inv = 0.0; t1Inv(0,0) = -1.0; t1Inv(1,1) = -1.0; t1Inv(2,2) = 1.0;
+
+            T.SetIntPoint(&ip1);
+            fe.CalcPhysVShape(T, s1); Mult(s1, t1Inv, ts1);
+
+            Vector ps(fe.GetDof()); ps = 1.0;
+            for (int i = 0; i < 4 * ne; i++) { ps[i] = -1; }
+            for (int i = oq; i < oq + nq; i++) { ps[i] = -1; }
+            for (int i = oi; i < oi + 2 * ni; i++) { ps[i] = -1; }
+
+            REQUIRE(computeVShapeDifference(s0, ts1, ps) < tol);
+         }
+
+         // 270 Degree Rotational Symmetry
+         {
+            IntegrationPoint ip1;
+            ip1.x = 1.0 - ip0.y - ip0.z;
+            ip1.y = ip0.x;
+            ip1.z = ip0.z;
+
+            t1Inv = 0.0; t1Inv(0,1) = -1.0; t1Inv(1,0) = 1.0; t1Inv(2,2) = 1.0;
+
+            T.SetIntPoint(&ip1);
+            fe.CalcPhysVShape(T, s1); Mult(s1, t1Inv, ts1);
+
+            Vector ps(fe.GetDof()); ps = 1.0;
+            for (int i = 0; i < ne; i++) { ps[i] = -1; }
+            for (int i = 2 * ne; i < 3 * ne; i++) { ps[i] = -1; }
+            for (int i = oq + nt; i < ot; i++) { ps[i] = -1; }
+            for (int i = oi; i < oi + ni; i++) { ps[i] = -1; }
+
+            REQUIRE(computeVShapeDifference(s0, ts1, ps) < tol);
+         }
+      }
+
+      SECTION("RT_FuentesPyramidElement")
+      {
+         const int nq = order * order; // Num DoF per quad face
+         const int nt = (order * (order + 1)) / 2; // Num DoF per tri face
+         const int ni = order * order * (order - 1); // Num interior DoF per dir
+         const int ot = nq; // Offset to first tri DoF
+         const int oi = ot + 4 * nt; // Offset to first interior DoF
+
+         RT_FuentesPyramidElement fe(order - 1);
+
+         DenseMatrix s0(fe.GetDof(), 3);
+         DenseMatrix s1(fe.GetDof(), 3);
+
+         DenseMatrix t1(3);
+         DenseMatrix ts1(fe.GetDof(), 3);
+
+         T.SetIntPoint(&ip0);
+         fe.CalcPhysVShape(T, s0);
+
+         // 90 Degree Rotational Symmetry
+         {
+            IntegrationPoint ip1;
+            ip1.x = ip0.y;
+            ip1.y = 1.0 - ip0.x - ip0.z;
+            ip1.z = ip0.z;
+
+            t1 = 0.0; t1(0,1) = -1.0; t1(1,0) = 1.0; t1(2,2) = 1.0;
+
+            T.SetIntPoint(&ip1);
+            fe.CalcPhysVShape(T, s1); MultABt(s1, t1, ts1);
+
+            Vector ps(fe.GetDof()); ps = 1.0;
+            for (int i = oi + ni; i < oi + 2 * ni; i++)
+            {
+               ps[i] = -1.0;
+            }
+
+            REQUIRE(computeVShapeDifference(s0, ts1, ps) < tol);
+         }
+
+         // 180 Degree Rotational Symmetry
+         {
+            IntegrationPoint ip1;
+            ip1.x = 1.0 - ip0.x - ip0.z;
+            ip1.y = 1.0 - ip0.y - ip0.z;
+            ip1.z = ip0.z;
+
+            t1 = 0.0; t1(0,0) = -1.0; t1(1,1) = -1.0; t1(2,2) = 1.0;
+
+            T.SetIntPoint(&ip1);
+            fe.CalcPhysVShape(T, s1); MultABt(s1, t1, ts1);
+
+            Vector ps(fe.GetDof()); ps = 1.0;
+            for (int i = oi; i < oi + 2 * ni; i++)
+            {
+               ps[i] = -1.0;
+            }
+
+            REQUIRE(computeVShapeDifference(s0, ts1, ps) < tol);
+         }
+
+         // 270 Degree Rotational Symmetry
+         {
+            IntegrationPoint ip1;
+            ip1.x = 1.0 - ip0.y - ip0.z;
+            ip1.y = ip0.x;
+            ip1.z = ip0.z;
+
+            t1 = 0.0; t1(0,1) = 1.0; t1(1,0) = -1.0; t1(2,2) = 1.0;
+
+            T.SetIntPoint(&ip1);
+            fe.CalcPhysVShape(T, s1); MultABt(s1, t1, ts1);
+
+            Vector ps(fe.GetDof()); ps = 1.0;
+            for (int i = oi; i < oi + ni; i++)
+            {
+               ps[i] = -1.0;
+            }
+
+            REQUIRE(computeVShapeDifference(s0, ts1, ps) < tol);
+         }
+      }
+
+      SECTION("L2_FuentesFiniteElement")
+      {
+         L2_FuentesPyramidElement fe(order);
+
+         DenseMatrix s0(fe.GetDof(), 1);
+         DenseMatrix s1(fe.GetDof(), 1);
+
+         Vector v0(s0.GetData(), fe.GetDof());
+         Vector v1(s1.GetData(), fe.GetDof());
+
+         T.SetIntPoint(&ip0);
+         fe.CalcPhysShape(T, v0);
+
+         // 90 Degree Rotational Symmetry
+         {
+            IntegrationPoint ip1;
+            ip1.x = ip0.y;
+            ip1.y = 1.0 - ip0.x - ip0.z;
+            ip1.z = ip0.z;
+
+            T.SetIntPoint(&ip1);
+            fe.CalcPhysShape(T, v1);
+
+            Vector ps(fe.GetDof()); ps = 1.0;
+
+            REQUIRE(computeVShapeDifference(s0, s1, ps) < tol);
+         }
+
+         // 180 Degree Rotational Symmetry
+         {
+            IntegrationPoint ip1;
+            ip1.x = 1.0 - ip0.x - ip0.z;
+            ip1.y = 1.0 - ip0.y - ip0.z;
+            ip1.z = ip0.z;
+
+            T.SetIntPoint(&ip1);
+            fe.CalcPhysShape(T, v1);
+
+            Vector ps(fe.GetDof()); ps = 1.0;
+
+            REQUIRE(computeVShapeDifference(s0, s1, ps) < tol);
+         }
+
+         // 270 Degree Rotational Symmetry
+         {
+            IntegrationPoint ip1;
+            ip1.x = 1.0 - ip0.y - ip0.z;
+            ip1.y = ip0.x;
+            ip1.z = ip0.z;
+
+            T.SetIntPoint(&ip1);
+            fe.CalcPhysShape(T, v1);
+
+            Vector ps(fe.GetDof()); ps = 1.0;
+
+            REQUIRE(computeVShapeDifference(s0, s1, ps) < tol);
+         }
+      }
+   }
+}
diff --git a/tests/unit/fem/test_get_value.cpp b/tests/unit/fem/test_get_value.cpp
index cf19cffb9..76b5f15e1 100644
--- a/tests/unit/fem/test_get_value.cpp
+++ b/tests/unit/fem/test_get_value.cpp
@@ -17,6 +17,13 @@ using namespace mfem;
 namespace get_value
 {
 
+static int first_1D_et = (int)Element::SEGMENT;
+static int  last_1D_et = (int)Element::SEGMENT;
+static int first_2D_et = (int)Element::TRIANGLE;
+static int  last_2D_et = (int)Element::QUADRILATERAL;
+static int first_3D_et = (int)Element::TETRAHEDRON;
+static int  last_3D_et = (int)Element::PYRAMID;
+
 double func_1D_lin(const Vector &x)
 {
    return x[0];
@@ -133,8 +140,7 @@ TEST_CASE("1D GetValue",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::SEGMENT;
-        type <= (int)Element::SEGMENT; type++)
+   for (int type = first_1D_et; type <= last_1D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian1D(n, 2.0);
 
@@ -411,8 +417,7 @@ TEST_CASE("1D GetValue in Parallel",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::SEGMENT;
-        type <= (int)Element::SEGMENT; type++)
+   for (int type = first_1D_et; type <= last_1D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian1D(n, 2.0);
       ParMesh pmesh(MPI_COMM_WORLD, mesh);
@@ -571,8 +576,7 @@ TEST_CASE("2D GetValue",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::TRIANGLE;
-        type <= (int)Element::QUADRILATERAL; type++)
+   for (int type = first_2D_et; type <= last_2D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian2D(n, n, (Element::Type)type, 1, 2.0, 3.0);
 
@@ -884,8 +888,7 @@ TEST_CASE("2D GetValue in Parallel",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::TRIANGLE;
-        type <= (int)Element::QUADRILATERAL; type++)
+   for (int type = first_2D_et; type <= last_2D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian2D(n, n, (Element::Type)type, 1, 2.0, 3.0);
       ParMesh pmesh(MPI_COMM_WORLD, mesh);
@@ -1043,8 +1046,7 @@ TEST_CASE("3D GetValue",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian3D(
                      n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -1392,8 +1394,7 @@ TEST_CASE("3D GetValue in Parallel",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian3D(
                      n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -1559,8 +1560,7 @@ TEST_CASE("2D GetVectorValue",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::TRIANGLE;
-        type <= (int)Element::QUADRILATERAL; type++)
+   for (int type = first_2D_et; type <= last_2D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian2D(n, n, (Element::Type)type, 1, 2.0, 3.0);
 
@@ -2093,8 +2093,7 @@ TEST_CASE("2D GetVectorValue in Parallel",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::TRIANGLE;
-        type <= (int)Element::QUADRILATERAL; type++)
+   for (int type = first_2D_et; type <= last_2D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian2D(n, n, (Element::Type)type, 1, 2.0, 3.0);
       ParMesh pmesh(MPI_COMM_WORLD, mesh);
@@ -2390,8 +2389,7 @@ TEST_CASE("3D GetVectorValue",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian3D(
                      n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -3054,8 +3052,7 @@ TEST_CASE("3D GetVectorValue in Parallel",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian3D(
                      n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -3371,8 +3368,7 @@ TEST_CASE("1D GetGradient",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::SEGMENT;
-        type <= (int)Element::SEGMENT; type++)
+   for (int type = first_1D_et; type <= last_1D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian1D(n, 2.0);
 
@@ -3572,8 +3568,7 @@ TEST_CASE("2D GetGradient",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::TRIANGLE;
-        type <= (int)Element::QUADRILATERAL; type++)
+   for (int type = first_2D_et; type <= last_2D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian2D(n, n, (Element::Type)type, 1, 2.0, 3.0);
 
@@ -3780,8 +3775,7 @@ TEST_CASE("3D GetGradient",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian3D(
                      n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -3813,6 +3807,8 @@ TEST_CASE("3D GetGradient",
 
          SECTION("Domain Evaluation 3D")
          {
+            mfem::out << "Domain Evaluation 3D for element type "
+                      << std::to_string(type) << std::endl;
             for (int e = 0; e < mesh.GetNE(); e++)
             {
                ElementTransformation *T = mesh.GetElementTransformation(e);
@@ -3993,8 +3989,7 @@ TEST_CASE("2D GetCurl",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::TRIANGLE;
-        type <= (int)Element::QUADRILATERAL; type++)
+   for (int type = first_2D_et; type <= last_2D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian2D(n, n, (Element::Type)type, 1, 2.0, 3.0);
 
@@ -4239,8 +4234,7 @@ TEST_CASE("3D GetCurl",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian3D(
                      n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
@@ -4504,8 +4498,7 @@ TEST_CASE("2D GetDivergence",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::TRIANGLE;
-        type <= (int)Element::QUADRILATERAL; type++)
+   for (int type = first_2D_et; type <= last_2D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian2D(n, n, (Element::Type)type, 1, 2.0, 3.0);
 
@@ -4732,8 +4725,7 @@ TEST_CASE("3D GetDivergence",
 
    double tol = 1e-6;
 
-   for (int type = (int)Element::TETRAHEDRON;
-        type <= (int)Element::WEDGE; type++)
+   for (int type = first_3D_et; type <= last_3D_et; type++)
    {
       Mesh mesh = Mesh::MakeCartesian3D(
                      n, n, n, (Element::Type)type, 2.0, 3.0, 5.0);
diff --git a/tests/unit/fem/test_lin_interp.cpp b/tests/unit/fem/test_lin_interp.cpp
index fb953c6ba..4df816752 100644
--- a/tests/unit/fem/test_lin_interp.cpp
+++ b/tests/unit/fem/test_lin_interp.cpp
@@ -142,7 +142,7 @@ TEST_CASE("Identity Linear Interpolators",
    double tol = 1e-9;
 
    for (int type = (int)Element::SEGMENT;
-        type <= (int)Element::WEDGE; type++)
+        type <= (int)Element::PYRAMID; type++)
    {
       Mesh mesh;
 
@@ -521,7 +521,7 @@ TEST_CASE("Derivative Linear Interpolators",
    double tol = 1e-9;
 
    for (int type = (int)Element::SEGMENT;
-        type <= (int)Element::WEDGE; type++)
+        type <= (int)Element::PYRAMID; type++)
    {
       Mesh mesh;
 
@@ -737,12 +737,13 @@ TEST_CASE("Product Linear Interpolators",
           "[VectorCrossProductInterpolator]"
           "[VectorInnerProductInterpolator]")
 {
-   int order_h1 = 1, order_nd = 2, order_rt = 2, n = 3, dim = -1;
-   double tol = 1e-9;
+   const int order_h1 = 1, order_nd = 2, order_rt = 1, n = 3;
+   const real_t ratio = 4.0;
 
    for (int type = (int)Element::SEGMENT;
-        type <= (int)Element::WEDGE; type++)
+        type <= (int)Element::PYRAMID; type++)
    {
+      int dim = -1;
       Mesh mesh;
 
       if (type < (int)Element::TRIANGLE)
@@ -778,7 +779,9 @@ TEST_CASE("Product Linear Interpolators",
       FunctionCoefficient        FGCoef((dim==2) ? FdotG2 : FdotG3);
       VectorFunctionCoefficient  fGCoef(dim, (dim==2) ? fG2 : fG3);
       VectorFunctionCoefficient  FgCoef(dim, (dim==2) ? Fg2 : Fg3);
-      VectorFunctionCoefficient FxGCoef(dim, (dim==2) ? FcrossG2 : FcrossG3);
+
+      VectorFunctionCoefficient FxGCoef((dim==2) ? 1 : 3,
+                                        (dim==2) ? FcrossG2 : FcrossG3);
 
       SECTION("Operators on H1 for element type " + std::to_string(type))
       {
@@ -787,6 +790,7 @@ TEST_CASE("Product Linear Interpolators",
 
          GridFunction g0(&fespace_h1);
          g0.ProjectCoefficient(gCoef);
+         CAPTURE(g0.ComputeL2Error(gCoef));
 
          SECTION("Mapping H1 to H1")
          {
@@ -799,9 +803,14 @@ TEST_CASE("Product Linear Interpolators",
             Opf0.Assemble();
 
             GridFunction fg0(&fespace_h1p);
+            fg0.ProjectCoefficient(fgCoef);
+            const real_t fgErr = std::abs(fg0.ComputeL2Error(fgCoef));
+            CAPTURE(fgErr);
+
+            fg0 = 0.0;
             Opf0.Mult(g0,fg0);
 
-            REQUIRE( fg0.ComputeL2Error(fgCoef) < tol );
+            REQUIRE( std::abs(fg0.ComputeL2Error(fgCoef)) < ratio * fgErr );
          }
          if (dim > 1)
          {
@@ -819,9 +828,14 @@ TEST_CASE("Product Linear Interpolators",
                OpF1.Assemble();
 
                GridFunction Fg1(&fespace_ndp);
+               Fg1.ProjectCoefficient(FgCoef);
+               const real_t FgErr = std::abs(Fg1.ComputeL2Error(FgCoef));
+               CAPTURE(FgErr);
+
+               Fg1 = 0.0;
                OpF1.Mult(g0,Fg1);
 
-               REQUIRE( Fg1.ComputeL2Error(FgCoef) < tol );
+               REQUIRE( std::abs(Fg1.ComputeL2Error(FgCoef)) < ratio * FgErr );
             }
          }
       }
@@ -837,9 +851,6 @@ TEST_CASE("Product Linear Interpolators",
 
             SECTION("Mapping HCurl to HCurl")
             {
-               H1_FECollection    fec_h1(order_h1, dim);
-               FiniteElementSpace fespace_h1(&mesh, &fec_h1);
-
                ND_FECollection    fec_ndp(order_nd+order_h1, dim);
                FiniteElementSpace fespace_ndp(&mesh, &fec_ndp);
 
@@ -849,9 +860,14 @@ TEST_CASE("Product Linear Interpolators",
                Opf0.Assemble();
 
                GridFunction fG1(&fespace_ndp);
+               fG1.ProjectCoefficient(fGCoef);
+               const real_t fGErr = std::abs(fG1.ComputeL2Error(fGCoef));
+               CAPTURE(fGErr);
+
+               fG1 = 0.0;
                Opf0.Mult(G1,fG1);
 
-               REQUIRE( fG1.ComputeL2Error(fGCoef) < tol );
+               REQUIRE( std::abs(fG1.ComputeL2Error(fGCoef)) < ratio * fGErr );
             }
             if (dim == 2)
             {
@@ -866,9 +882,14 @@ TEST_CASE("Product Linear Interpolators",
                   OpF1.Assemble();
 
                   GridFunction FxG2(&fespace_l2p);
+                  FxG2.ProjectCoefficient(FxGCoef);
+                  const real_t FxGErr = std::abs(FxG2.ComputeL2Error(FxGCoef));
+                  CAPTURE(FxGErr);
+
+                  FxG2 = 0.0;
                   OpF1.Mult(G1,FxG2);
 
-                  REQUIRE( FxG2.ComputeL2Error(FxGCoef) < tol );
+                  REQUIRE( std::abs(FxG2.ComputeL2Error(FxGCoef)) < ratio * FxGErr );
                }
             }
             else
@@ -884,9 +905,14 @@ TEST_CASE("Product Linear Interpolators",
                   OpF1.Assemble();
 
                   GridFunction FxG2(&fespace_rtp);
+                  FxG2.ProjectCoefficient(FxGCoef);
+                  const real_t FxGErr = std::abs(FxG2.ComputeL2Error(FxGCoef));
+                  CAPTURE(FxGErr);
+
+                  FxG2 = 0.0;
                   OpF1.Mult(G1,FxG2);
 
-                  REQUIRE( FxG2.ComputeL2Error(FxGCoef) < tol );
+                  REQUIRE( std::abs(FxG2.ComputeL2Error(FxGCoef)) < ratio * FxGErr );
                }
             }
             SECTION("Mapping to L2")
@@ -903,9 +929,14 @@ TEST_CASE("Product Linear Interpolators",
                OpF2.Assemble();
 
                GridFunction FG3(&fespace_l2p);
+               FG3.ProjectCoefficient(FGCoef);
+               const real_t FGErr = std::abs(FG3.ComputeL2Error(FGCoef));
+               CAPTURE(FGErr);
+
+               FG3 = 0.0;
                OpF2.Mult(G1,FG3);
 
-               REQUIRE( FG3.ComputeL2Error(FGCoef) < tol );
+               REQUIRE( std::abs(FG3.ComputeL2Error(FGCoef)) < ratio * FGErr );
             }
          }
          SECTION("Operators on HDiv for element type " + std::to_string(type))
@@ -918,9 +949,6 @@ TEST_CASE("Product Linear Interpolators",
 
             SECTION("Mapping to L2")
             {
-               ND_FECollection    fec_nd(order_nd, dim);
-               FiniteElementSpace fespace_nd(&mesh, &fec_nd);
-
                L2_FECollection    fec_l2p(order_nd+order_rt, dim);
                FiniteElementSpace fespace_l2p(&mesh, &fec_l2p);
 
@@ -930,13 +958,115 @@ TEST_CASE("Product Linear Interpolators",
                OpF1.Assemble();
 
                GridFunction FG3(&fespace_l2p);
+               FG3.ProjectCoefficient(FGCoef);
+               const real_t FGErr = std::abs(FG3.ComputeL2Error(FGCoef));
+               CAPTURE(FGErr);
+
+               FG3 = 0.0;
                OpF1.Mult(G2,FG3);
 
-               REQUIRE( FG3.ComputeL2Error(FGCoef) < tol );
+               REQUIRE( std::abs(FG3.ComputeL2Error(FGCoef)) < ratio * FGErr );
             }
          }
       }
    }
 }
 
+TEST_CASE("Exact Sequence Properties: d(df)=0",
+          "[GradientInterpolator]"
+          "[CurlInterpolator]"
+          "[DivergenceInterpolator]")
+{
+   const int maxOrder = 3;
+   auto order = GENERATE_COPY(range(1, maxOrder + 1));
+   CAPTURE(order);
+
+   int n = 3, dim = -1;
+   real_t tol = 1e-10;
+
+   auto type = (Element::Type)GENERATE(range((int)Element::TRIANGLE,
+                                             (int)Element::PYRAMID + 1));
+   CAPTURE(type);
+
+   Mesh mesh;
+
+   if (type < (int)Element::TETRAHEDRON)
+   {
+      dim = 2;
+      mesh = Mesh::MakeCartesian2D(n, n, (Element::Type)type, 1, 2.0, 3.0);
+   }
+   else
+   {
+      dim = 3;
+      mesh = Mesh::MakeCartesian3D(n, n, n, (Element::Type)type,
+                                   2.0, 3.0, 5.0);
+   }
+
+   H1_FECollection    fec_h1(order, dim);
+   ND_FECollection    fec_nd(order, dim);
+   RT_FECollection    fec_rt(order - 1, dim);
+   L2_FECollection    fec_l2(order - 1, dim);
+
+   FiniteElementSpace fespace_h1(&mesh, &fec_h1);
+   FiniteElementSpace fespace_nd(&mesh, &fec_nd);
+   FiniteElementSpace fespace_rt(&mesh, &fec_rt);
+   FiniteElementSpace fespace_l2(&mesh, &fec_l2);
+
+   if (dim == 2)
+   {
+      DiscreteLinearOperator Grad(&fespace_h1, &fespace_nd);
+      Grad.AddDomainInterpolator(new GradientInterpolator());
+      Grad.Assemble();
+      Grad.Finalize();
+
+      DiscreteLinearOperator Curl(&fespace_nd, &fespace_l2);
+      Curl.AddDomainInterpolator(new CurlInterpolator());
+      Curl.Assemble();
+      Curl.Finalize();
+
+      SECTION("Curl of Gradient (2D)")
+      {
+         SparseMatrix * CurlGrad = Mult(Curl.SpMat(), Grad.SpMat());
+
+         REQUIRE(CurlGrad->MaxNorm() < tol);
+
+         delete CurlGrad;
+      }
+   }
+   else
+   {
+      DiscreteLinearOperator Grad(&fespace_h1, &fespace_nd);
+      Grad.AddDomainInterpolator(new GradientInterpolator());
+      Grad.Assemble();
+      Grad.Finalize();
+
+      DiscreteLinearOperator Curl(&fespace_nd, &fespace_rt);
+      Curl.AddDomainInterpolator(new CurlInterpolator());
+      Curl.Assemble();
+      Curl.Finalize();
+
+      DiscreteLinearOperator Div(&fespace_rt, &fespace_l2);
+      Div.AddDomainInterpolator(new DivergenceInterpolator());
+      Div.Assemble();
+      Div.Finalize();
+
+      SECTION("Curl of Gradient (3D)")
+      {
+         SparseMatrix * CurlGrad = Mult(Curl.SpMat(), Grad.SpMat());
+
+         REQUIRE(CurlGrad->MaxNorm() < tol);
+
+         delete CurlGrad;
+      }
+      SECTION("Divergence of Curl (3D)")
+      {
+         SparseMatrix * DivCurl = Mult(Div.SpMat(), Curl.SpMat());
+
+         REQUIRE(DivCurl->MaxNorm() < tol);
+
+         delete DivCurl;
+      }
+   }
+}
+
 } // namespace lin_interp
diff --git a/tests/unit/fem/test_poly1d.cpp b/tests/unit/fem/test_poly1d.cpp
new file mode 100644
index 000000000..932c79164
--- /dev/null
+++ b/tests/unit/fem/test_poly1d.cpp
@@ -0,0 +1,149 @@
+// Copyright (c) 2010-2025, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mfem.hpp"
+#include "catch.hpp"
+
+using namespace mfem;
+/*
+TEST_CASE("1D Jacobi Polynomials (alpha=0, beta=0)","[Poly_1D]")
+{
+   // For alpha = beta = 0 the Jacobi polynomials should equal the Legendre
+   // polynomials
+   int p = 6;
+   int order = 2 * p + 1;
+
+   const IntegrationRule &ir = IntRules.Get(Geometry::SEGMENT, order);
+
+   DenseMatrix J(p+1, ir.GetNPoints());
+   DenseMatrix L(p+1, ir.GetNPoints());
+
+   for (int i=0; i<ir.GetNPoints(); i++)
+   {
+      const IntegrationPoint &ip = ir.IntPoint(i);
+      poly1d.CalcJacobi(p, 0.0, 0.0, ip.x, J.GetColumn(i));
+      poly1d.CalcLegendre(p, ip.x, L.GetColumn(i));
+   }
+
+   J.Add(-1.0, L);
+
+   double max_norm = J.MaxMaxNorm();
+   REQUIRE(max_norm < 1e-11);
+}
+
+TEST_CASE("1D Jacobi Polynomials (alpha=beta=-0.5)","[Poly_1D]")
+{
+   // For alpha = beta = -1/2 the Jacobi polynomials should equal the Chebyshev
+   // polynomials
+   int p = 6;
+   int order = 2 * p + 1;
+
+   const IntegrationRule &ir = IntRules.Get(Geometry::SEGMENT, order);
+
+   DenseMatrix J(p+1, ir.GetNPoints());
+   DenseMatrix C(p+1, ir.GetNPoints());
+
+   for (int i=0; i<ir.GetNPoints(); i++)
+   {
+      const IntegrationPoint &ip = ir.IntPoint(i);
+      poly1d.CalcJacobi(p, -0.5, -0.5, ip.x, J.GetColumn(i));
+      poly1d.CalcBasis(p, ip.x, C.GetColumn(i));
+   }
+
+   // Jacobi polynomials are normalized so that P^(a,b)_n(1) = binom(n+a,n)
+   // whereas Chebyshev satisfy T_n(1) = 1.
+   Vector w(p+1);
+   w(0) = 1.0;
+   w(1) = 2.0;
+   w(2) = 8.0 / 3.0;
+   w(3) = 16.0 / 5.0;
+   w(4) = 128.0 / 35.0;
+   w(5) = 256.0 / 63.0;
+   w(6) = 1024.0 / 231.0;
+
+   // Rescale Jacobi polynomials to match Chebyshev convention
+   J.LeftScaling(w);
+
+   J.Add(-1.0, C);
+
+   // Measure error
+   double max_norm = J.MaxMaxNorm();
+   REQUIRE(max_norm < 1e-11);
+}
+
+TEST_CASE("1D Jacobi Polynomials (alpha=2, beta=0)","[Poly_1D]")
+{
+   // Check orthogonality of Jacobi polynomials up to order 6
+   int p = 6;
+   int order = 2 * p + 3;
+   double alpha = 2.0;
+
+   const IntegrationRule &ir = IntRules.Get(Geometry::SEGMENT, order);
+
+   DenseMatrix A(p+1, ir.GetNPoints());
+   Vector w(ir.GetNPoints());
+
+   // Compute polynomial values and weight function
+   for (int i=0; i<ir.GetNPoints(); i++)
+   {
+      const IntegrationPoint &ip = ir.IntPoint(i);
+      poly1d.CalcJacobi(p, alpha, 0.0, ip.x, A.GetColumn(i));
+      w(i) = pow(2.0 - 2.0 * ip.x, alpha) * ip.weight;
+   }
+
+   // Compute integrals
+   DenseMatrix ADAt(p+1);
+   MultADAt(A, w, ADAt);
+
+   // Remove expected diagonal entries
+   for (int i=0; i<=p; i++)
+   {
+      ADAt(i,i) -= 4.0 / (2.0 * i + 3.0);
+   }
+
+   // Measure error
+   double max_norm = ADAt.MaxMaxNorm();
+   REQUIRE(max_norm < 1e-11);
+}
+*/
+TEST_CASE("1D Legendre Polynomials","[Poly_1D]")
+{
+   // Check orthogonality of Legendre polynomials up to order 6
+   int p = 6;
+   int order = 2 * p + 1;
+
+   const IntegrationRule &ir = IntRules.Get(Geometry::SEGMENT, order);
+
+   DenseMatrix A(p+1, ir.GetNPoints());
+   Vector w(ir.GetNPoints());
+
+   // Compute polynomial values and weight function
+   for (int i=0; i<ir.GetNPoints(); i++)
+   {
+      const IntegrationPoint &ip = ir.IntPoint(i);
+      poly1d.CalcLegendre(p, ip.x, A.GetColumn(i));
+      w(i) = ip.weight;
+   }
+
+   // Compute integrals
+   DenseMatrix ADAt(p+1);
+   MultADAt(A, w, ADAt);
+
+   // Remove expected diagonal entries
+   for (int i=0; i<=p; i++)
+   {
+      ADAt(i,i) -= 1.0 / (2.0 * i + 1.0);
+   }
+
+   // Measure error
+   double max_norm = ADAt.MaxMaxNorm();
+   REQUIRE(max_norm < 1e-11);
+}
