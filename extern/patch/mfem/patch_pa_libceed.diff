diff --git a/CMakeLists.txt b/CMakeLists.txt
index 9e9aa895d..68e601eae 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -218,10 +218,7 @@ if (MFEM_USE_HIP)
 endif()
 
 # OpenMP
-if (MFEM_USE_OPENMP OR MFEM_USE_LEGACY_OPENMP)
-  if (NOT MFEM_THREAD_SAFE AND MFEM_USE_LEGACY_OPENMP)
-    message(FATAL_ERROR " *** MFEM_USE_LEGACY_OPENMP requires MFEM_THREAD_SAFE=ON.")
-  endif()
+if (MFEM_USE_OPENMP)
   find_package(OpenMP REQUIRED)
   set(OPENMP_LIBRARIES ${OpenMP_CXX_LIBRARIES})
   if(APPLE)
diff --git a/INSTALL b/INSTALL
index 1a325fdf6..138da219f 100644
--- a/INSTALL
+++ b/INSTALL
@@ -309,10 +309,6 @@ MFEM_THREAD_SAFE = YES/NO
    Use thread-safe implementation for some classes/methods. This comes at the
    cost of extra memory allocation and de-allocation.
 
-MFEM_USE_LEGACY_OPENMP = YES/NO
-   Enable (basic) experimental OpenMP support. Requires MFEM_THREAD_SAFE.
-   This option is deprecated.
-
 MFEM_USE_OPENMP = YES/NO
    Enable the OpenMP backend.
 
@@ -611,8 +607,8 @@ The specific libraries and their options are:
        http://math-atlas.sourceforge.net (ATLAS)
   Options: LAPACK_OPT (currently not used/needed), LAPACK_LIB.
 
-- OpenMP (optional), usually part of compiler, used when either MFEM_USE_OPENMP
-  or MFEM_USE_LEGACY_OPENMP is set to YES.
+- OpenMP (optional), usually part of compiler, used when MFEM_USE_OPENMP is set
+  to YES.
   Options: OPENMP_OPT, OPENMP_LIB.
 
 - High-resolution POSIX clocks: when using MFEM_TIMER_TYPE = 2, it may be
@@ -960,7 +956,6 @@ MFEM_USE_METIS - Set to ${MFEM_USE_MPI}, can be overwritten.
 MFEM_USE_LIBUNWIND
 MFEM_USE_LAPACK
 MFEM_THREAD_SAFE
-MFEM_USE_LEGACY_OPENMP
 MFEM_USE_OPENMP
 MFEM_USE_MEMALLOC
 MFEM_TIMER_TYPE - Set automatically, can be overwritten.
diff --git a/config/cmake/MFEMConfig.cmake.in b/config/cmake/MFEMConfig.cmake.in
index ed271311a..a9570e82f 100644
--- a/config/cmake/MFEMConfig.cmake.in
+++ b/config/cmake/MFEMConfig.cmake.in
@@ -25,7 +25,6 @@ set(MFEM_USE_LIBUNWIND @MFEM_USE_LIBUNWIND@)
 set(MFEM_USE_LAPACK @MFEM_USE_LAPACK@)
 set(MFEM_THREAD_SAFE @MFEM_THREAD_SAFE@)
 set(MFEM_USE_OPENMP @MFEM_USE_OPENMP@)
-set(MFEM_USE_LEGACY_OPENMP @MFEM_USE_LEGACY_OPENMP@)
 set(MFEM_USE_MEMALLOC @MFEM_USE_MEMALLOC@)
 set(MFEM_TIMER_TYPE @MFEM_TIMER_TYPE@)
 set(MFEM_USE_SUNDIALS @MFEM_USE_SUNDIALS@)
diff --git a/config/cmake/config.hpp.in b/config/cmake/config.hpp.in
index 7cb2a958d..ac715ee69 100644
--- a/config/cmake/config.hpp.in
+++ b/config/cmake/config.hpp.in
@@ -74,9 +74,6 @@
 // Enable the OpenMP backend.
 #cmakedefine MFEM_USE_OPENMP
 
-// [Deprecated] Enable experimental OpenMP support. Requires MFEM_THREAD_SAFE.
-#cmakedefine MFEM_USE_LEGACY_OPENMP
-
 // Internal MFEM option: enable group/batch allocation for some small objects.
 #cmakedefine MFEM_USE_MEMALLOC
 
diff --git a/config/cmake/modules/MfemCmakeUtilities.cmake b/config/cmake/modules/MfemCmakeUtilities.cmake
index 204b7d87f..9a629330b 100644
--- a/config/cmake/modules/MfemCmakeUtilities.cmake
+++ b/config/cmake/modules/MfemCmakeUtilities.cmake
@@ -843,16 +843,16 @@ function(mfem_export_mk_files)
   # Convert Boolean vars to YES/NO without writing the values to cache
   set(CONFIG_MK_BOOL_VARS MFEM_USE_MPI MFEM_USE_METIS MFEM_USE_METIS_5
       MFEM_DEBUG MFEM_USE_EXCEPTIONS MFEM_USE_ZLIB MFEM_USE_LIBUNWIND
-      MFEM_USE_LAPACK MFEM_THREAD_SAFE MFEM_USE_LEGACY_OPENMP MFEM_USE_OPENMP
-      MFEM_USE_MEMALLOC MFEM_USE_SUNDIALS MFEM_USE_SUITESPARSE
-      MFEM_USE_SUPERLU MFEM_USE_SUPERLU5 MFEM_USE_MUMPS MFEM_USE_STRUMPACK
-      MFEM_USE_GINKGO MFEM_USE_AMGX MFEM_USE_GNUTLS MFEM_USE_NETCDF
-      MFEM_USE_PETSC MFEM_USE_SLEPC MFEM_USE_MPFR MFEM_USE_SIDRE MFEM_USE_FMS
-      MFEM_USE_CONDUIT MFEM_USE_PUMI MFEM_USE_HIOP MFEM_USE_GSLIB MFEM_USE_CUDA
-      MFEM_USE_HIP MFEM_USE_RAJA MFEM_USE_OCCA MFEM_USE_CEED MFEM_USE_CALIPER
-      MFEM_USE_UMPIRE MFEM_USE_SIMD MFEM_USE_ADIOS2 MFEM_USE_MKL_CPARDISO
-      MFEM_USE_ADFORWARD MFEM_USE_CODIPACK MFEM_USE_BENCHMARK MFEM_USE_PARELAG
-      MFEM_USE_MOONOLITH MFEM_USE_ALGOIM MFEM_USE_ENZYME)
+      MFEM_USE_LAPACK MFEM_THREAD_SAFE MFEM_USE_OPENMP MFEM_USE_MEMALLOC
+      MFEM_USE_SUNDIALS MFEM_USE_SUITESPARSE MFEM_USE_SUPERLU MFEM_USE_SUPERLU5
+      MFEM_USE_MUMPS MFEM_USE_STRUMPACK MFEM_USE_GINKGO MFEM_USE_AMGX
+      MFEM_USE_GNUTLS MFEM_USE_NETCDF MFEM_USE_PETSC MFEM_USE_SLEPC
+      MFEM_USE_MPFR MFEM_USE_SIDRE MFEM_USE_FMS MFEM_USE_CONDUIT MFEM_USE_PUMI
+      MFEM_USE_HIOP MFEM_USE_GSLIB MFEM_USE_CUDA MFEM_USE_HIP MFEM_USE_RAJA
+      MFEM_USE_OCCA MFEM_USE_CEED MFEM_USE_CALIPER MFEM_USE_UMPIRE
+      MFEM_USE_SIMD MFEM_USE_ADIOS2 MFEM_USE_MKL_CPARDISO MFEM_USE_ADFORWARD
+      MFEM_USE_CODIPACK MFEM_USE_BENCHMARK MFEM_USE_PARELAG MFEM_USE_MOONOLITH
+      MFEM_USE_ALGOIM MFEM_USE_ENZYME)
   foreach(var ${CONFIG_MK_BOOL_VARS})
     if (${var})
       set(${var} YES)
diff --git a/config/config.hpp.in b/config/config.hpp.in
index 39d7737c7..e89cb4452 100644
--- a/config/config.hpp.in
+++ b/config/config.hpp.in
@@ -74,9 +74,6 @@
 // Enable the OpenMP backend.
 // #define MFEM_USE_OPENMP
 
-// [Deprecated] Enable experimental OpenMP support. Requires MFEM_THREAD_SAFE.
-// #define MFEM_USE_LEGACY_OPENMP
-
 // Internal MFEM option: enable group/batch allocation for some small objects.
 // #define MFEM_USE_MEMALLOC
 
diff --git a/config/config.mk.in b/config/config.mk.in
index 303750bf5..fd3bf4b77 100644
--- a/config/config.mk.in
+++ b/config/config.mk.in
@@ -24,7 +24,6 @@ MFEM_USE_ZLIB          = @MFEM_USE_ZLIB@
 MFEM_USE_LIBUNWIND     = @MFEM_USE_LIBUNWIND@
 MFEM_USE_LAPACK        = @MFEM_USE_LAPACK@
 MFEM_THREAD_SAFE       = @MFEM_THREAD_SAFE@
-MFEM_USE_LEGACY_OPENMP = @MFEM_USE_LEGACY_OPENMP@
 MFEM_USE_OPENMP        = @MFEM_USE_OPENMP@
 MFEM_USE_MEMALLOC      = @MFEM_USE_MEMALLOC@
 MFEM_TIMER_TYPE        = @MFEM_TIMER_TYPE@
diff --git a/config/defaults.cmake b/config/defaults.cmake
index 06531934d..6ebdf47f1 100644
--- a/config/defaults.cmake
+++ b/config/defaults.cmake
@@ -28,7 +28,6 @@ option(MFEM_USE_LIBUNWIND "Enable backtrace for errors." OFF)
 option(MFEM_USE_LAPACK "Enable LAPACK usage" OFF)
 option(MFEM_THREAD_SAFE "Enable thread safety" OFF)
 option(MFEM_USE_OPENMP "Enable the OpenMP backend" OFF)
-option(MFEM_USE_LEGACY_OPENMP "Enable legacy OpenMP usage" OFF)
 option(MFEM_USE_MEMALLOC "Enable the internal MEMALLOC option." ON)
 option(MFEM_USE_SUNDIALS "Enable SUNDIALS usage" OFF)
 option(MFEM_USE_SUITESPARSE "Enable SuiteSparse usage" OFF)
diff --git a/config/defaults.mk b/config/defaults.mk
index 237e9ed24..6150a393c 100644
--- a/config/defaults.mk
+++ b/config/defaults.mk
@@ -127,7 +127,6 @@ MFEM_USE_LIBUNWIND     = NO
 MFEM_USE_LAPACK        = NO
 MFEM_THREAD_SAFE       = NO
 MFEM_USE_OPENMP        = NO
-MFEM_USE_LEGACY_OPENMP = NO
 MFEM_USE_MEMALLOC      = YES
 MFEM_TIMER_TYPE        = $(if $(NOTMAC),2,4)
 MFEM_USE_SUNDIALS      = NO
diff --git a/fem/CMakeLists.txt b/fem/CMakeLists.txt
index aea1f901d..52708fdd7 100644
--- a/fem/CMakeLists.txt
+++ b/fem/CMakeLists.txt
@@ -17,19 +17,28 @@ set(SRCS
   integ/bilininteg_convection_mf.cpp
   integ/bilininteg_convection_pa.cpp
   integ/bilininteg_convection_ea.cpp
+  integ/bilininteg_curlcurl_mf.cpp
   integ/bilininteg_curlcurl_pa.cpp
+  integ/bilininteg_curlcurlmass_pa.cpp
   integ/bilininteg_dgtrace_pa.cpp
   integ/bilininteg_dgtrace_ea.cpp
   integ/bilininteg_diffusion_mf.cpp
   integ/bilininteg_diffusion_pa.cpp
   integ/bilininteg_diffusion_ea.cpp
+  integ/bilininteg_diffusionmass_pa.cpp
+  integ/bilininteg_divdiv_mf.cpp
   integ/bilininteg_divdiv_pa.cpp
+  integ/bilininteg_divdivmass_pa.cpp
   integ/bilininteg_gradient_pa.cpp
-  integ/bilininteg_interp_pa.cpp
+  integ/bilininteg_interp_id_pa.cpp
+  integ/bilininteg_interp_grad_pa.cpp
+  integ/bilininteg_interp_curl_pa.cpp
   integ/bilininteg_mass_mf.cpp
   integ/bilininteg_mass_pa.cpp
   integ/bilininteg_mass_ea.cpp
+  integ/bilininteg_mixedcurl_mf.cpp
   integ/bilininteg_mixedcurl_pa.cpp
+  integ/bilininteg_mixedvecgrad_mf.cpp
   integ/bilininteg_mixedvecgrad_pa.cpp
   integ/bilininteg_transpose_ea.cpp
   integ/bilininteg_vecdiffusion_mf.cpp
@@ -38,6 +47,7 @@ set(SRCS
   integ/bilininteg_vecmass_mf.cpp
   integ/bilininteg_vecmass_pa.cpp
   integ/bilininteg_vectorfediv_pa.cpp
+  integ/bilininteg_vectorfemass_mf.cpp
   integ/bilininteg_vectorfemass_pa.cpp
   integ/bilininteg_diffusion_kernels.cpp
   integ/bilininteg_hcurl_kernels.cpp
@@ -77,15 +87,23 @@ set(SRCS
   hybridization.cpp
   intrules.cpp
   ceed/interface/basis.cpp
-  ceed/interface/restriction.cpp
   ceed/interface/operator.cpp
+  ceed/interface/restriction.cpp
   ceed/interface/util.cpp
+  ceed/integrators/mass/mass.cpp
   ceed/integrators/convection/convection.cpp
   ceed/integrators/diffusion/diffusion.cpp
   ceed/integrators/nlconvection/nlconvection.cpp
-  ceed/integrators/mass/mass.cpp
+  ceed/integrators/vecfemass/vecfemass.cpp
+  ceed/integrators/divdiv/divdiv.cpp
+  ceed/integrators/curlcurl/curlcurl.cpp
+  ceed/integrators/diffusionmass/diffusionmass.cpp
+  ceed/integrators/divdivmass/divdivmass.cpp
+  ceed/integrators/curlcurlmass/curlcurlmass.cpp
+  ceed/integrators/mixedvecgrad/mixedvecgrad.cpp
+  ceed/integrators/mixedveccurl/mixedveccurl.cpp
+  ceed/integrators/interp/interp.cpp
   ceed/solvers/algebraic.cpp
-  ceed/solvers/full-assembly.cpp
   ceed/solvers/solvers-atpmg.cpp
   linearform.cpp
   linearform_ext.cpp
@@ -185,18 +203,39 @@ set(HDRS
   hybridization.hpp
   intrules.hpp
   ceed/interface/basis.hpp
+  ceed/interface/ceed.hpp
+  ceed/interface/coefficient.hpp
   ceed/interface/integrator.hpp
   ceed/interface/interface.hpp
+  ceed/interface/mixed_operator.hpp
   ceed/interface/operator.hpp
   ceed/interface/restriction.hpp
   ceed/interface/util.hpp
+  ceed/integrators/mass/mass.hpp
+  ceed/integrators/mass/mass_qf.h
   ceed/integrators/convection/convection.hpp
+  ceed/integrators/convection/convection_qf.h
   ceed/integrators/diffusion/diffusion.hpp
-  ceed/integrators/mass/mass.hpp
+  ceed/integrators/diffusion/diffusion_qf.h
   ceed/integrators/nlconvection/nlconvection.hpp
-  ceed/interface/coefficient.hpp
+  ceed/integrators/nlconvection/nlconvection_qf.h
+  ceed/integrators/vecfemass/vecfemass.hpp
+  ceed/integrators/vecfemass/vecfemass_qf.h
+  ceed/integrators/divdiv/divdiv.hpp
+  ceed/integrators/divdiv/divdiv_qf.h
+  ceed/integrators/curlcurl/curlcurl.hpp
+  ceed/integrators/curlcurl/curlcurl_qf.h
+  ceed/integrators/diffusionmass/diffusionmass.hpp
+  ceed/integrators/diffusionmass/diffusionmass_qf.h
+  ceed/integrators/divdivmass/divdivmass.hpp
+  ceed/integrators/divdivmass/divdivmass_qf.h
+  ceed/integrators/curlcurlmass/curlcurlmass.hpp
+  ceed/integrators/curlcurlmass/curlcurlmass_qf.h
+  ceed/integrators/mixedvecgrad/mixedvecgrad.hpp
+  ceed/integrators/mixedveccurl/mixedveccurl.hpp
+  ceed/integrators/interp/interp.hpp
+  ceed/integrators/util/util_qf.h
   ceed/solvers/algebraic.hpp
-  ceed/solvers/full-assembly.hpp
   ceed/solvers/solvers-atpmg.hpp
   linearform.hpp
   linearform_ext.hpp
diff --git a/fem/bilinearform.cpp b/fem/bilinearform.cpp
index 08862ac1c..93268bdda 100644
--- a/fem/bilinearform.cpp
+++ b/fem/bilinearform.cpp
@@ -18,51 +18,6 @@
 namespace mfem
 {
 
-void BilinearForm::AllocMat()
-{
-   if (static_cond) { return; }
-
-   if (precompute_sparsity == 0 || fes->GetVDim() > 1)
-   {
-      mat = new SparseMatrix(height);
-      return;
-   }
-
-   const Table &elem_dof = fes->GetElementToDofTable();
-   Table dof_dof;
-
-   if (interior_face_integs.Size() > 0)
-   {
-      // the sparsity pattern is defined from the map: face->element->dof
-      Table face_dof, dof_face;
-      {
-         Table *face_elem = fes->GetMesh()->GetFaceToElementTable();
-         mfem::Mult(*face_elem, elem_dof, face_dof);
-         delete face_elem;
-      }
-      Transpose(face_dof, dof_face, height);
-      mfem::Mult(dof_face, face_dof, dof_dof);
-   }
-   else
-   {
-      // the sparsity pattern is defined from the map: element->dof
-      Table dof_elem;
-      Transpose(elem_dof, dof_elem, height);
-      mfem::Mult(dof_elem, elem_dof, dof_dof);
-   }
-
-   dof_dof.SortRows();
-
-   int *I = dof_dof.GetI();
-   int *J = dof_dof.GetJ();
-   double *data = Memory<double>(I[height]);
-
-   mat = new SparseMatrix(I, J, data, height, height, true, true, true);
-   *mat = 0.0;
-
-   dof_dof.LoseData();
-}
-
 BilinearForm::BilinearForm(FiniteElementSpace *f)
    : Matrix(f->GetVSize())
 {
@@ -70,32 +25,24 @@ BilinearForm::BilinearForm(FiniteElementSpace *f)
    sequence = f->GetSequence();
    mat = mat_e = NULL;
    extern_bfs = 0;
-   element_matrices = NULL;
    static_cond = NULL;
    hybridization = NULL;
-   precompute_sparsity = 0;
    diag_policy = DIAG_KEEP;
-
    assembly = AssemblyLevel::LEGACY;
-   batch = 1;
    ext = NULL;
 }
 
-BilinearForm::BilinearForm(FiniteElementSpace *f, BilinearForm *bf, int ps)
+BilinearForm::BilinearForm(FiniteElementSpace *f, BilinearForm *bf)
    : Matrix(f->GetVSize())
 {
    fes = f;
    sequence = f->GetSequence();
-   mat_e = NULL;
+   mat = mat_e = NULL;
    extern_bfs = 1;
-   element_matrices = NULL;
    static_cond = NULL;
    hybridization = NULL;
-   precompute_sparsity = ps;
    diag_policy = DIAG_KEEP;
-
    assembly = AssemblyLevel::LEGACY;
-   batch = 1;
    ext = NULL;
 
    // Copy the pointers to the integrators
@@ -108,8 +55,6 @@ BilinearForm::BilinearForm(FiniteElementSpace *f, BilinearForm *bf, int ps)
 
    boundary_face_integs = bf->boundary_face_integs;
    boundary_face_integs_marker = bf->boundary_face_integs_marker;
-
-   AllocMat();
 }
 
 void BilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
@@ -181,32 +126,6 @@ void BilinearForm::EnableHybridization(FiniteElementSpace *constr_space,
    hybridization->Init(ess_tdof_list);
 }
 
-void BilinearForm::UseSparsity(int *I, int *J, bool isSorted)
-{
-   if (static_cond) { return; }
-
-   if (mat)
-   {
-      if (mat->Finalized() && mat->GetI() == I && mat->GetJ() == J)
-      {
-         return; // mat is already using the given sparsity
-      }
-      delete mat;
-   }
-   height = width = fes->GetVSize();
-   mat = new SparseMatrix(I, J, NULL, height, width, false, true, isSorted);
-}
-
-void BilinearForm::UseSparsity(SparseMatrix &A)
-{
-   MFEM_ASSERT(A.Height() == fes->GetVSize() && A.Width() == fes->GetVSize(),
-               "invalid matrix A dimensions: "
-               << A.Height() << " x " << A.Width());
-   MFEM_ASSERT(A.Finalized(), "matrix A must be Finalized");
-
-   UseSparsity(A.GetI(), A.GetJ(), A.ColumnsAreSorted());
-}
-
 double &BilinearForm::Elem(int i, int j)
 {
    return mat->Elem(i,j);
@@ -327,65 +246,97 @@ void BilinearForm::AddBdrFaceIntegrator(BilinearFormIntegrator *bfi,
    boundary_face_integs_marker.Append(&bdr_marker);
 }
 
-void BilinearForm::ComputeElementMatrix(int i, DenseMatrix &elmat)
+void BilinearForm::ComputeElementMatrix(int i, DenseMatrix &elmat,
+                                        Array<int> &vdofs)
 {
-   if (element_matrices)
-   {
-      elmat.SetSize(element_matrices->SizeI(), element_matrices->SizeJ());
-      elmat = element_matrices->GetData(i);
-      return;
-   }
-
+   DofTransformation *doftrans = fes->GetElementVDofs(i, vdofs);
+   elmat.SetSize(vdofs.Size());
+   elmat = 0.0;
    if (domain_integs.Size())
    {
-      const FiniteElement &fe = *fes->GetFE(i);
-      ElementTransformation *eltrans = fes->GetElementTransformation(i);
-      domain_integs[0]->AssembleElementMatrix(fe, *eltrans, elmat);
-      for (int k = 1; k < domain_integs.Size(); k++)
+      Mesh *mesh = fes->GetMesh();
+      ElementTransformation *eltrans = mesh->GetElementTransformation(i);
+      int elem_attr = mesh->GetAttribute(i);
+#ifdef MFEM_DEBUG
+      for (int k = 0; k < domain_integs.Size(); k++)
       {
-         domain_integs[k]->AssembleElementMatrix(fe, *eltrans, elemmat);
-         elmat += elemmat;
+         if (domain_integs_marker[k] != NULL)
+         {
+            MFEM_VERIFY(domain_integs_marker[k]->Size() ==
+                        (mesh->attributes.Size() ? mesh->attributes.Max() : 0),
+                        "invalid element marker for domain integrator #"
+                        << k << ", counting from zero");
+         }
+      }
+#endif
+      for (int k = 0; k < domain_integs.Size(); k++)
+      {
+         if (domain_integs_marker[k] == NULL ||
+             (*(domain_integs_marker[k]))[elem_attr-1] == 1)
+         {
+            domain_integs[k]->AssembleElementMatrix(*fes->GetFE(i),
+                                                    *eltrans, elemmat);
+            elmat += elemmat;
+         }
+      }
+      if (doftrans)
+      {
+         doftrans->TransformDual(elmat);
       }
-   }
-   else
-   {
-      fes->GetElementVDofs(i, vdofs);
-      elmat.SetSize(vdofs.Size());
-      elmat = 0.0;
    }
 }
 
-void BilinearForm::ComputeBdrElementMatrix(int i, DenseMatrix &elmat)
+void BilinearForm::ComputeBdrElementMatrix(int i, DenseMatrix &elmat,
+                                           Array<int> &vdofs)
 {
+   DofTransformation *doftrans = fes->GetBdrElementVDofs(i, vdofs);
+   elmat.SetSize(vdofs.Size());
+   elmat = 0.0;
    if (boundary_integs.Size())
    {
-      const FiniteElement &be = *fes->GetBE(i);
-      ElementTransformation *eltrans = fes->GetBdrElementTransformation(i);
-      boundary_integs[0]->AssembleElementMatrix(be, *eltrans, elmat);
-      for (int k = 1; k < boundary_integs.Size(); k++)
+      Mesh *mesh = fes->GetMesh();
+      ElementTransformation *eltrans = mesh->GetBdrElementTransformation(i);
+      int bdr_attr = mesh->GetBdrAttribute(i);
+#ifdef MFEM_DEBUG
+      for (int k = 0; k < boundary_integs.Size(); k++)
       {
-         boundary_integs[k]->AssembleElementMatrix(be, *eltrans, elemmat);
-         elmat += elemmat;
+         if (boundary_integs_marker[k] != NULL)
+         {
+            MFEM_VERIFY(boundary_integs_marker[k]->Size() ==
+                        (mesh->bdr_attributes.Size() ? mesh->bdr_attributes.Max() : 0),
+                        "invalid element marker for bdr integrator #"
+                        << k << ", counting from zero");
+         }
+      }
+#endif
+      for (int k = 0; k < boundary_integs.Size(); k++)
+      {
+         if (boundary_integs_marker[k] == NULL ||
+             (*(boundary_integs_marker[k]))[bdr_attr-1] == 1)
+         {
+            boundary_integs[k]->AssembleElementMatrix(*fes->GetBE(i),
+                                                      *eltrans, elemmat);
+            elmat += elemmat;
+         }
+      }
+      if (doftrans)
+      {
+         doftrans->TransformDual(elmat);
       }
-   }
-   else
-   {
-      fes->GetBdrElementVDofs(i, vdofs);
-      elmat.SetSize(vdofs.Size());
-      elmat = 0.0;
    }
 }
 
 void BilinearForm::AssembleElementMatrix(
    int i, const DenseMatrix &elmat, int skip_zeros)
 {
+   Array<int> vdofs;
+   fes->GetElementVDofs(i, vdofs);
    AssembleElementMatrix(i, elmat, vdofs, skip_zeros);
 }
 
 void BilinearForm::AssembleElementMatrix(
-   int i, const DenseMatrix &elmat, Array<int> &vdofs_, int skip_zeros)
+   int i, const DenseMatrix &elmat, const Array<int> &vdofs, int skip_zeros)
 {
-   fes->GetElementVDofs(i, vdofs_);
    if (static_cond)
    {
       static_cond->AssembleMatrix(i, elmat);
@@ -394,9 +345,9 @@ void BilinearForm::AssembleElementMatrix(
    {
       if (mat == NULL)
       {
-         AllocMat();
+         mat = new SparseMatrix(height);
       }
-      mat->AddSubMatrix(vdofs_, vdofs_, elmat, skip_zeros);
+      mat->AddSubMatrix(vdofs, vdofs, elmat, skip_zeros);
       if (hybridization)
       {
          hybridization->AssembleMatrix(i, elmat);
@@ -407,13 +358,14 @@ void BilinearForm::AssembleElementMatrix(
 void BilinearForm::AssembleBdrElementMatrix(
    int i, const DenseMatrix &elmat, int skip_zeros)
 {
+   Array<int> vdofs;
+   fes->GetBdrElementVDofs(i, vdofs);
    AssembleBdrElementMatrix(i, elmat, vdofs, skip_zeros);
 }
 
 void BilinearForm::AssembleBdrElementMatrix(
-   int i, const DenseMatrix &elmat, Array<int> &vdofs_, int skip_zeros)
+   int i, const DenseMatrix &elmat, const Array<int> &vdofs, int skip_zeros)
 {
-   fes->GetBdrElementVDofs(i, vdofs_);
    if (static_cond)
    {
       static_cond->AssembleBdrMatrix(i, elmat);
@@ -422,9 +374,9 @@ void BilinearForm::AssembleBdrElementMatrix(
    {
       if (mat == NULL)
       {
-         AllocMat();
+         mat = new SparseMatrix(height);
       }
-      mat->AddSubMatrix(vdofs_, vdofs_, elmat, skip_zeros);
+      mat->AddSubMatrix(vdofs, vdofs, elmat, skip_zeros);
       if (hybridization)
       {
          hybridization->AssembleBdrMatrix(i, elmat);
@@ -440,174 +392,39 @@ void BilinearForm::Assemble(int skip_zeros)
       return;
    }
 
-   ElementTransformation *eltrans;
-   DofTransformation *doftrans;
    Mesh *mesh = fes->GetMesh();
-   DenseMatrix elmat, *elmat_p;
+   DenseMatrix elmat;
+   Array<int> vdofs;
 
    if (mat == NULL)
    {
-      AllocMat();
-   }
-
-#ifdef MFEM_USE_LEGACY_OPENMP
-   int free_element_matrices = 0;
-   if (!element_matrices)
-   {
-      ComputeElementMatrices();
-      free_element_matrices = 1;
+      mat = new SparseMatrix(height);
    }
-#endif
 
    if (domain_integs.Size())
    {
-      for (int k = 0; k < domain_integs.Size(); k++)
+      for (int i = 0; i < mesh->GetNE(); i++)
       {
-         if (domain_integs_marker[k] != NULL)
-         {
-            MFEM_VERIFY(domain_integs_marker[k]->Size() ==
-                        (mesh->attributes.Size() ? mesh->attributes.Max() : 0),
-                        "invalid element marker for domain integrator #"
-                        << k << ", counting from zero");
-         }
-      }
-
-      for (int i = 0; i < fes->GetNE(); i++)
-      {
-         int elem_attr = fes->GetMesh()->GetAttribute(i);
-         doftrans = fes->GetElementVDofs(i, vdofs);
-         if (element_matrices)
-         {
-            elmat_p = &(*element_matrices)(i);
-         }
-         else
-         {
-            elmat.SetSize(0);
-            for (int k = 0; k < domain_integs.Size(); k++)
-            {
-               if ( domain_integs_marker[k] == NULL ||
-                    (*(domain_integs_marker[k]))[elem_attr-1] == 1)
-               {
-                  const FiniteElement &fe = *fes->GetFE(i);
-                  eltrans = fes->GetElementTransformation(i);
-                  domain_integs[k]->AssembleElementMatrix(fe, *eltrans, elemmat);
-                  if (elmat.Size() == 0)
-                  {
-                     elmat = elemmat;
-                  }
-                  else
-                  {
-                     elmat += elemmat;
-                  }
-               }
-            }
-            if (elmat.Size() == 0)
-            {
-               continue;
-            }
-            else
-            {
-               elmat_p = &elmat;
-            }
-            if (doftrans)
-            {
-               doftrans->TransformDual(elmat);
-            }
-            elmat_p = &elmat;
-         }
-         if (static_cond)
-         {
-            static_cond->AssembleMatrix(i, *elmat_p);
-         }
-         else
-         {
-            mat->AddSubMatrix(vdofs, vdofs, *elmat_p, skip_zeros);
-            if (hybridization)
-            {
-               hybridization->AssembleMatrix(i, *elmat_p);
-            }
-         }
+         ComputeElementMatrix(i, elmat, vdofs);
+         AssembleElementMatrix(i, elmat, vdofs, skip_zeros);
       }
    }
 
    if (boundary_integs.Size())
    {
-      // Which boundary attributes need to be processed?
-      Array<int> bdr_attr_marker(mesh->bdr_attributes.Size() ?
-                                 mesh->bdr_attributes.Max() : 0);
-      bdr_attr_marker = 0;
-      for (int k = 0; k < boundary_integs.Size(); k++)
+      for (int i = 0; i < mesh->GetNBE(); i++)
       {
-         if (boundary_integs_marker[k] == NULL)
-         {
-            bdr_attr_marker = 1;
-            break;
-         }
-         Array<int> &bdr_marker = *boundary_integs_marker[k];
-         MFEM_ASSERT(bdr_marker.Size() == bdr_attr_marker.Size(),
-                     "invalid boundary marker for boundary integrator #"
-                     << k << ", counting from zero");
-         for (int i = 0; i < bdr_attr_marker.Size(); i++)
-         {
-            bdr_attr_marker[i] |= bdr_marker[i];
-         }
-      }
-
-      for (int i = 0; i < fes->GetNBE(); i++)
-      {
-         const int bdr_attr = mesh->GetBdrAttribute(i);
-         if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
-
-         const FiniteElement &be = *fes->GetBE(i);
-         doftrans = fes->GetBdrElementVDofs(i, vdofs);
-         eltrans = fes->GetBdrElementTransformation(i);
-         int k = 0;
-         for (; k < boundary_integs.Size(); k++)
-         {
-            if (boundary_integs_marker[k] &&
-                (*boundary_integs_marker[k])[bdr_attr-1] == 0) { continue; }
-
-            boundary_integs[k]->AssembleElementMatrix(be, *eltrans, elmat);
-            k++;
-            break;
-         }
-         for (; k < boundary_integs.Size(); k++)
-         {
-            if (boundary_integs_marker[k] &&
-                (*boundary_integs_marker[k])[bdr_attr-1] == 0) { continue; }
-
-            boundary_integs[k]->AssembleElementMatrix(be, *eltrans, elemmat);
-            elmat += elemmat;
-         }
-         if (doftrans)
-         {
-            doftrans->TransformDual(elmat);
-         }
-         elmat_p = &elmat;
-         if (!static_cond)
-         {
-            mat->AddSubMatrix(vdofs, vdofs, *elmat_p, skip_zeros);
-            if (hybridization)
-            {
-               hybridization->AssembleBdrMatrix(i, *elmat_p);
-            }
-         }
-         else
-         {
-            static_cond->AssembleBdrMatrix(i, *elmat_p);
-         }
+         ComputeBdrElementMatrix(i, elmat, vdofs);
+         AssembleBdrElementMatrix(i, elmat, vdofs, skip_zeros);
       }
    }
 
    if (interior_face_integs.Size())
    {
-      FaceElementTransformations *tr;
       Array<int> vdofs2;
-
-      int nfaces = mesh->GetNumFaces();
-      for (int i = 0; i < nfaces; i++)
+      for (int i = 0; i < mesh->GetNumFaces(); i++)
       {
-         tr = mesh->GetInteriorFaceTransformations(i);
+         FaceElementTransformations *tr = mesh->GetInteriorFaceTransformations(i);
          if (tr != NULL)
          {
             fes->GetElementVDofs(tr->Elem1No, vdofs);
@@ -626,64 +443,31 @@ void BilinearForm::Assemble(int skip_zeros)
 
    if (boundary_face_integs.Size())
    {
-      FaceElementTransformations *tr;
-      const FiniteElement *fe1, *fe2;
-
-      // Which boundary attributes need to be processed?
-      Array<int> bdr_attr_marker(mesh->bdr_attributes.Size() ?
-                                 mesh->bdr_attributes.Max() : 0);
-      bdr_attr_marker = 0;
-      for (int k = 0; k < boundary_face_integs.Size(); k++)
-      {
-         if (boundary_face_integs_marker[k] == NULL)
-         {
-            bdr_attr_marker = 1;
-            break;
-         }
-         Array<int> &bdr_marker = *boundary_face_integs_marker[k];
-         MFEM_ASSERT(bdr_marker.Size() == bdr_attr_marker.Size(),
-                     "invalid boundary marker for boundary face integrator #"
-                     << k << ", counting from zero");
-         for (int i = 0; i < bdr_attr_marker.Size(); i++)
-         {
-            bdr_attr_marker[i] |= bdr_marker[i];
-         }
-      }
-
-      for (int i = 0; i < fes->GetNBE(); i++)
+      for (int i = 0; i < mesh->GetNBE(); i++)
       {
-         const int bdr_attr = mesh->GetBdrAttribute(i);
-         if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
-
-         tr = mesh->GetBdrFaceTransformations(i);
+         FaceElementTransformations *tr = mesh->GetBdrFaceTransformations(i);
          if (tr != NULL)
          {
-            fes->GetElementVDofs(tr->Elem1No, vdofs);
-            fe1 = fes->GetFE(tr->Elem1No);
+            int bdr_attr = mesh->GetBdrAttribute(i);
+            const FiniteElement *fe1 = fes->GetFE(tr->Elem1No);
             // The fe2 object is really a dummy and not used on the boundaries,
             // but we can't dereference a NULL pointer, and we don't want to
             // actually make a fake element.
-            fe2 = fe1;
+            const FiniteElement *fe2 = fe1;
+            fes->GetElementVDofs(tr->Elem1No, vdofs);
             for (int k = 0; k < boundary_face_integs.Size(); k++)
             {
-               if (boundary_face_integs_marker[k] &&
-                   (*boundary_face_integs_marker[k])[bdr_attr-1] == 0)
-               { continue; }
-
-               boundary_face_integs[k]->AssembleFaceMatrix(*fe1, *fe2, *tr,
-                                                           elemmat);
-               mat->AddSubMatrix(vdofs, vdofs, elemmat, skip_zeros);
+               if (boundary_face_integs_marker[k] == NULL ||
+                   (*boundary_face_integs_marker[k])[bdr_attr-1] == 1)
+               {
+                  boundary_face_integs[k]->AssembleFaceMatrix(*fe1, *fe2, *tr,
+                                                              elemmat);
+                  mat->AddSubMatrix(vdofs, vdofs, elemmat, skip_zeros);
+               }
             }
          }
       }
    }
-
-#ifdef MFEM_USE_LEGACY_OPENMP
-   if (free_element_matrices)
-   {
-      FreeElementMatrices();
-   }
-#endif
 }
 
 void BilinearForm::ConformingAssemble()
@@ -949,48 +733,6 @@ void BilinearForm::RecoverFEMSolution(const Vector &X,
    }
 }
 
-void BilinearForm::ComputeElementMatrices()
-{
-   if (element_matrices || domain_integs.Size() == 0 || fes->GetNE() == 0)
-   {
-      return;
-   }
-
-   int num_elements = fes->GetNE();
-   int num_dofs_per_el = fes->GetFE(0)->GetDof() * fes->GetVDim();
-
-   element_matrices = new DenseTensor(num_dofs_per_el, num_dofs_per_el,
-                                      num_elements);
-
-   DenseMatrix tmp;
-   IsoparametricTransformation eltrans;
-
-#ifdef MFEM_USE_LEGACY_OPENMP
-   #pragma omp parallel for private(tmp,eltrans)
-#endif
-   for (int i = 0; i < num_elements; i++)
-   {
-      DenseMatrix elmat(element_matrices->GetData(i),
-                        num_dofs_per_el, num_dofs_per_el);
-      const FiniteElement &fe = *fes->GetFE(i);
-#ifdef MFEM_DEBUG
-      if (num_dofs_per_el != fe.GetDof()*fes->GetVDim())
-         mfem_error("BilinearForm::ComputeElementMatrices:"
-                    " all elements must have same number of dofs");
-#endif
-      fes->GetElementTransformation(i, &eltrans);
-
-      domain_integs[0]->AssembleElementMatrix(fe, eltrans, elmat);
-      for (int k = 1; k < domain_integs.Size(); k++)
-      {
-         // note: some integrators may not be thread-safe
-         domain_integs[k]->AssembleElementMatrix(fe, eltrans, tmp);
-         elmat += tmp;
-      }
-      elmat.ClearExternalData();
-   }
-}
-
 void BilinearForm::EliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
                                         const Vector &sol, Vector &rhs,
                                         DiagonalPolicy dpolicy)
@@ -1043,15 +785,15 @@ void BilinearForm::EliminateEssentialBCDiag(const Array<int> &bdr_attr_is_ess,
    }
 }
 
-void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
+void BilinearForm::EliminateVDofs(const Array<int> &vdofs,
                                   const Vector &sol, Vector &rhs,
                                   DiagonalPolicy dpolicy)
 {
-   vdofs_.HostRead();
-   for (int i = 0; i < vdofs_.Size(); i++)
+   vdofs.HostRead();
+   for (int i = 0; i < vdofs.Size(); i++)
    {
-      int vdof = vdofs_[i];
-      if ( vdof >= 0 )
+      int vdof = vdofs[i];
+      if (vdof >= 0)
       {
          mat->EliminateRowCol(vdof, sol(vdof), rhs, dpolicy);
       }
@@ -1062,7 +804,7 @@ void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
    }
 }
 
-void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
+void BilinearForm::EliminateVDofs(const Array<int> &vdofs,
                                   DiagonalPolicy dpolicy)
 {
    if (mat_e == NULL)
@@ -1070,11 +812,11 @@ void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
       mat_e = new SparseMatrix(height);
    }
 
-   vdofs_.HostRead();
-   for (int i = 0; i < vdofs_.Size(); i++)
+   vdofs.HostRead();
+   for (int i = 0; i < vdofs.Size(); i++)
    {
-      int vdof = vdofs_[i];
-      if ( vdof >= 0 )
+      int vdof = vdofs[i];
+      if (vdof >= 0)
       {
          mat->EliminateRowCol(vdof, *mat_e, dpolicy);
       }
@@ -1094,10 +836,12 @@ void BilinearForm::EliminateEssentialBCFromDofs(
    MFEM_ASSERT(rhs.Size() == height, "incorrect rhs Vector size");
 
    for (int i = 0; i < ess_dofs.Size(); i++)
+   {
       if (ess_dofs[i] < 0)
       {
          mat->EliminateRowCol(i, sol(i), rhs, dpolicy);
       }
+   }
 }
 
 void BilinearForm::EliminateEssentialBCFromDofs(const Array<int> &ess_dofs,
@@ -1106,10 +850,12 @@ void BilinearForm::EliminateEssentialBCFromDofs(const Array<int> &ess_dofs,
    MFEM_ASSERT(ess_dofs.Size() == height, "incorrect dof Array size");
 
    for (int i = 0; i < ess_dofs.Size(); i++)
+   {
       if (ess_dofs[i] < 0)
       {
          mat->EliminateRowCol(i, dpolicy);
       }
+   }
 }
 
 void BilinearForm::EliminateEssentialBCFromDofsDiag(const Array<int> &ess_dofs,
@@ -1125,10 +871,10 @@ void BilinearForm::EliminateEssentialBCFromDofsDiag(const Array<int> &ess_dofs,
 }
 
 void BilinearForm::EliminateVDofsInRHS(
-   const Array<int> &vdofs_, const Vector &x, Vector &b)
+   const Array<int> &vdofs, const Vector &x, Vector &b)
 {
    mat_e->AddMult(x, b, -1.);
-   mat->PartMult(vdofs_, x, b);
+   mat->PartMult(vdofs, x, b);
 }
 
 void BilinearForm::Update(FiniteElementSpace *nfes)
@@ -1150,7 +896,6 @@ void BilinearForm::Update(FiniteElementSpace *nfes)
 
    delete mat_e;
    mat_e = NULL;
-   FreeElementMatrices();
    delete static_cond;
    static_cond = NULL;
 
@@ -1177,7 +922,6 @@ BilinearForm::~BilinearForm()
 {
    delete mat_e;
    delete mat;
-   delete element_matrices;
    delete static_cond;
    delete hybridization;
 
@@ -1195,7 +939,6 @@ BilinearForm::~BilinearForm()
    delete ext;
 }
 
-
 MixedBilinearForm::MixedBilinearForm(FiniteElementSpace *tr_fes,
                                      FiniteElementSpace *te_fes)
    : Matrix(te_fes->GetVSize(), tr_fes->GetVSize())
@@ -1220,6 +963,8 @@ MixedBilinearForm::MixedBilinearForm(FiniteElementSpace *tr_fes,
    mat_e = NULL;
    extern_bfs = 1;
    ext = NULL;
+   assembly = AssemblyLevel::LEGACY;
+   ext = NULL;
 
    // Copy the pointers to the integrators
    domain_integs = mbf->domain_integs;
@@ -1229,9 +974,6 @@ MixedBilinearForm::MixedBilinearForm(FiniteElementSpace *tr_fes,
 
    boundary_integs_marker = mbf->boundary_integs_marker;
    boundary_trace_face_integs_marker = mbf->boundary_trace_face_integs_marker;
-
-   assembly = AssemblyLevel::LEGACY;
-   ext = NULL;
 }
 
 void MixedBilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
@@ -1395,6 +1137,104 @@ void MixedBilinearForm::AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi,
    boundary_trace_face_integs_marker.Append(&bdr_marker);
 }
 
+void MixedBilinearForm::ComputeElementMatrix(int i, DenseMatrix &elmat,
+                                             Array<int> &trial_vdofs,
+                                             Array<int> &test_vdofs)
+{
+   DofTransformation *dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
+   DofTransformation *ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
+   elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
+   elmat = 0.0;
+   if (domain_integs.Size())
+   {
+      Mesh *mesh = test_fes->GetMesh();
+      ElementTransformation *eltrans = mesh->GetElementTransformation(i);
+      for (int k = 0; k < domain_integs.Size(); k++)
+      {
+         domain_integs[k]->AssembleElementMatrix2(*trial_fes->GetFE(i),
+                                                  *test_fes->GetFE(i),
+                                                  *eltrans, elemmat);
+         elmat += elemmat;
+      }
+      if (ran_dof_trans || dom_dof_trans)
+      {
+         TransformDual(ran_dof_trans, dom_dof_trans, elmat);
+      }
+   }
+}
+
+void MixedBilinearForm::ComputeBdrElementMatrix(int i, DenseMatrix &elmat,
+                                                Array<int> &trial_vdofs,
+                                                Array<int> &test_vdofs)
+{
+   DofTransformation *dom_dof_trans = trial_fes->GetBdrElementVDofs(i,
+                                                                    trial_vdofs);
+   DofTransformation *ran_dof_trans = test_fes->GetBdrElementVDofs(i, test_vdofs);
+   elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
+   elmat = 0.0;
+   if (boundary_integs.Size())
+   {
+      Mesh *mesh = test_fes->GetMesh();
+      ElementTransformation *eltrans = mesh->GetBdrElementTransformation(i);
+      int bdr_attr = mesh->GetBdrAttribute(i);
+      for (int k = 0; k < boundary_integs.Size(); k++)
+      {
+         if (boundary_integs_marker[k] == NULL ||
+             (*boundary_integs_marker[k])[bdr_attr-1] == 1)
+         {
+            boundary_integs[k]->AssembleElementMatrix2(*trial_fes->GetBE(i),
+                                                       *test_fes->GetBE(i),
+                                                       *eltrans, elemmat);
+            elmat += elemmat;
+         }
+      }
+      if (ran_dof_trans || dom_dof_trans)
+      {
+         TransformDual(ran_dof_trans, dom_dof_trans, elmat);
+      }
+   }
+}
+
+void MixedBilinearForm::AssembleElementMatrix(
+   int i, const DenseMatrix &elmat, int skip_zeros)
+{
+   Array<int> trial_vdofs, test_vdofs;
+   trial_fes->GetElementVDofs(i, trial_vdofs);
+   test_fes->GetElementVDofs(i, test_vdofs);
+   AssembleElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
+}
+
+void MixedBilinearForm::AssembleElementMatrix(
+   int i, const DenseMatrix &elmat, const Array<int> &trial_vdofs,
+   const Array<int> &test_vdofs, int skip_zeros)
+{
+   if (mat == NULL)
+   {
+      mat = new SparseMatrix(height, width);
+   }
+   mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
+}
+
+void MixedBilinearForm::AssembleBdrElementMatrix(
+   int i, const DenseMatrix &elmat, int skip_zeros)
+{
+   Array<int> trial_vdofs, test_vdofs;
+   trial_fes->GetBdrElementVDofs(i, trial_vdofs);
+   test_fes->GetBdrElementVDofs(i, test_vdofs);
+   AssembleBdrElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
+}
+
+void MixedBilinearForm::AssembleBdrElementMatrix(
+   int i, const DenseMatrix &elmat, const Array<int> &trial_vdofs,
+   const Array<int> &test_vdofs, int skip_zeros)
+{
+   if (mat == NULL)
+   {
+      mat = new SparseMatrix(height, width);
+   }
+   mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
+}
+
 void MixedBilinearForm::Assemble(int skip_zeros)
 {
    if (ext)
@@ -1403,11 +1243,9 @@ void MixedBilinearForm::Assemble(int skip_zeros)
       return;
    }
 
-   ElementTransformation *eltrans;
-   DofTransformation *dom_dof_trans;
-   DofTransformation *ran_dof_trans;
    Mesh *mesh = test_fes->GetMesh();
    DenseMatrix elmat;
+   Array<int> trial_vdofs, test_vdofs;
 
    if (mat == NULL)
    {
@@ -1416,171 +1254,85 @@ void MixedBilinearForm::Assemble(int skip_zeros)
 
    if (domain_integs.Size())
    {
-      for (int i = 0; i < test_fes->GetNE(); i++)
+      for (int i = 0; i < mesh->GetNE(); i++)
       {
-         dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
-         ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
-         eltrans = test_fes->GetElementTransformation(i);
-
-         elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
-         elmat = 0.0;
-         for (int k = 0; k < domain_integs.Size(); k++)
-         {
-            domain_integs[k]->AssembleElementMatrix2(*trial_fes->GetFE(i),
-                                                     *test_fes->GetFE(i),
-                                                     *eltrans, elemmat);
-            elmat += elemmat;
-         }
-         if (ran_dof_trans || dom_dof_trans)
-         {
-            TransformDual(ran_dof_trans, dom_dof_trans, elmat);
-         }
-         mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
+         ComputeElementMatrix(i, elmat, trial_vdofs, test_vdofs);
+         AssembleElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
       }
    }
 
    if (boundary_integs.Size())
    {
-      // Which boundary attributes need to be processed?
-      Array<int> bdr_attr_marker(mesh->bdr_attributes.Size() ?
-                                 mesh->bdr_attributes.Max() : 0);
-      bdr_attr_marker = 0;
-      for (int k = 0; k < boundary_integs.Size(); k++)
+      for (int i = 0; i < mesh->GetNBE(); i++)
       {
-         if (boundary_integs_marker[k] == NULL)
-         {
-            bdr_attr_marker = 1;
-            break;
-         }
-         Array<int> &bdr_marker = *boundary_integs_marker[k];
-         MFEM_ASSERT(bdr_marker.Size() == bdr_attr_marker.Size(),
-                     "invalid boundary marker for boundary integrator #"
-                     << k << ", counting from zero");
-         for (int i = 0; i < bdr_attr_marker.Size(); i++)
-         {
-            bdr_attr_marker[i] |= bdr_marker[i];
-         }
-      }
-
-      for (int i = 0; i < test_fes->GetNBE(); i++)
-      {
-         const int bdr_attr = mesh->GetBdrAttribute(i);
-         if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
-
-         dom_dof_trans = trial_fes->GetBdrElementVDofs(i, trial_vdofs);
-         ran_dof_trans = test_fes->GetBdrElementVDofs(i, test_vdofs);
-         eltrans = test_fes->GetBdrElementTransformation(i);
-
-         elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
-         elmat = 0.0;
-         for (int k = 0; k < boundary_integs.Size(); k++)
-         {
-            if (boundary_integs_marker[k] &&
-                (*boundary_integs_marker[k])[bdr_attr-1] == 0) { continue; }
-
-            boundary_integs[k]->AssembleElementMatrix2(*trial_fes->GetBE(i),
-                                                       *test_fes->GetBE(i),
-                                                       *eltrans, elemmat);
-            elmat += elemmat;
-         }
-         if (ran_dof_trans || dom_dof_trans)
-         {
-            TransformDual(ran_dof_trans, dom_dof_trans, elmat);
-         }
-         mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
+         ComputeBdrElementMatrix(i, elmat, trial_vdofs, test_vdofs);
+         AssembleBdrElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
       }
    }
 
    if (trace_face_integs.Size())
    {
-      FaceElementTransformations *ftr;
       Array<int> test_vdofs2;
-      const FiniteElement *trial_face_fe, *test_fe1, *test_fe2;
-
-      int nfaces = mesh->GetNumFaces();
-      for (int i = 0; i < nfaces; i++)
+      for (int i = 0; i < mesh->GetNumFaces(); i++)
       {
-         ftr = mesh->GetFaceElementTransformations(i);
-         trial_fes->GetFaceVDofs(i, trial_vdofs);
-         test_fes->GetElementVDofs(ftr->Elem1No, test_vdofs);
-         trial_face_fe = trial_fes->GetFaceElement(i);
-         test_fe1 = test_fes->GetFE(ftr->Elem1No);
-         if (ftr->Elem2No >= 0)
-         {
-            test_fes->GetElementVDofs(ftr->Elem2No, test_vdofs2);
-            test_vdofs.Append(test_vdofs2);
-            test_fe2 = test_fes->GetFE(ftr->Elem2No);
-         }
-         else
+         FaceElementTransformations *ftr = mesh->GetFaceElementTransformations(i);
+         if (ftr != NULL)
          {
-            // The test_fe2 object is really a dummy and not used on the
-            // boundaries, but we can't dereference a NULL pointer, and we don't
-            // want to actually make a fake element.
-            test_fe2 = test_fe1;
-         }
-         for (int k = 0; k < trace_face_integs.Size(); k++)
-         {
-            trace_face_integs[k]->AssembleFaceMatrix(*trial_face_fe, *test_fe1,
-                                                     *test_fe2, *ftr, elemmat);
-            mat->AddSubMatrix(test_vdofs, trial_vdofs, elemmat, skip_zeros);
+            trial_fes->GetFaceVDofs(i, trial_vdofs);
+            test_fes->GetElementVDofs(ftr->Elem1No, test_vdofs);
+            const FiniteElement *trial_face_fe = trial_fes->GetFaceElement(i);
+            const FiniteElement *test_fe1 = test_fes->GetFE(ftr->Elem1No);
+            const FiniteElement *test_fe2;
+            if (ftr->Elem2No >= 0)
+            {
+               test_fes->GetElementVDofs(ftr->Elem2No, test_vdofs2);
+               test_vdofs.Append(test_vdofs2);
+               test_fe2 = test_fes->GetFE(ftr->Elem2No);
+            }
+            else
+            {
+               // The test_fe2 object is really a dummy and not used on the
+               // boundaries, but we can't dereference a NULL pointer, and we don't
+               // want to actually make a fake element.
+               test_fe2 = test_fe1;
+            }
+            for (int k = 0; k < trace_face_integs.Size(); k++)
+            {
+               trace_face_integs[k]->AssembleFaceMatrix2(*trial_face_fe, *test_fe1,
+                                                         *test_fe2, *ftr, elemmat);
+               mat->AddSubMatrix(test_vdofs, trial_vdofs, elemmat, skip_zeros);
+            }
          }
       }
    }
 
    if (boundary_trace_face_integs.Size())
    {
-      FaceElementTransformations *ftr;
-      Array<int> te_vdofs2;
-      const FiniteElement *trial_face_fe, *test_fe1, *test_fe2;
-
-      // Which boundary attributes need to be processed?
-      Array<int> bdr_attr_marker(mesh->bdr_attributes.Size() ?
-                                 mesh->bdr_attributes.Max() : 0);
-      bdr_attr_marker = 0;
-      for (int k = 0; k < boundary_trace_face_integs.Size(); k++)
-      {
-         if (boundary_trace_face_integs_marker[k] == NULL)
-         {
-            bdr_attr_marker = 1;
-            break;
-         }
-         Array<int> &bdr_marker = *boundary_trace_face_integs_marker[k];
-         MFEM_ASSERT(bdr_marker.Size() == bdr_attr_marker.Size(),
-                     "invalid boundary marker for boundary trace face"
-                     "integrator #" << k << ", counting from zero");
-         for (int i = 0; i < bdr_attr_marker.Size(); i++)
-         {
-            bdr_attr_marker[i] |= bdr_marker[i];
-         }
-      }
-
-      for (int i = 0; i < trial_fes->GetNBE(); i++)
+      for (int i = 0; i < mesh->GetNBE(); i++)
       {
-         const int bdr_attr = mesh->GetBdrAttribute(i);
-         if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
-
-         ftr = mesh->GetBdrFaceTransformations(i);
-         if (ftr)
+         int bdr_attr = mesh->GetBdrAttribute(i);
+         FaceElementTransformations *ftr = mesh->GetBdrFaceTransformations(i);
+         if (ftr != NULL)
          {
             trial_fes->GetFaceVDofs(ftr->ElementNo, trial_vdofs);
             test_fes->GetElementVDofs(ftr->Elem1No, test_vdofs);
-            trial_face_fe = trial_fes->GetFaceElement(ftr->ElementNo);
-            test_fe1 = test_fes->GetFE(ftr->Elem1No);
+            const FiniteElement *trial_face_fe = trial_fes->GetFaceElement(ftr->ElementNo);
+            const FiniteElement *test_fe1 = test_fes->GetFE(ftr->Elem1No);
             // The test_fe2 object is really a dummy and not used on the
             // boundaries, but we can't dereference a NULL pointer, and we don't
             // want to actually make a fake element.
-            test_fe2 = test_fe1;
+            const FiniteElement *test_fe2 = test_fe1;
             for (int k = 0; k < boundary_trace_face_integs.Size(); k++)
             {
-               if (boundary_trace_face_integs_marker[k] &&
-                   (*boundary_trace_face_integs_marker[k])[bdr_attr-1] == 0)
-               { continue; }
-
-               boundary_trace_face_integs[k]->AssembleFaceMatrix(*trial_face_fe,
-                                                                 *test_fe1,
-                                                                 *test_fe2,
-                                                                 *ftr, elemmat);
-               mat->AddSubMatrix(test_vdofs, trial_vdofs, elemmat, skip_zeros);
+               if (boundary_trace_face_integs_marker[k] == NULL ||
+                   (*boundary_trace_face_integs_marker[k])[bdr_attr-1] == 1)
+               {
+                  boundary_trace_face_integs[k]->AssembleFaceMatrix2(*trial_face_fe,
+                                                                     *test_fe1,
+                                                                     *test_fe2,
+                                                                     *ftr, elemmat);
+                  mat->AddSubMatrix(test_vdofs, trial_vdofs, elemmat, skip_zeros);
+               }
             }
          }
       }
@@ -1666,143 +1418,6 @@ void MixedBilinearForm::AssembleDiagonal_ADAt(const Vector &D,
    }
 }
 
-void MixedBilinearForm::ComputeElementMatrix(int i, DenseMatrix &elmat)
-{
-   if (domain_integs.Size())
-   {
-      const FiniteElement &trial_fe = *trial_fes->GetFE(i);
-      const FiniteElement &test_fe = *test_fes->GetFE(i);
-      ElementTransformation *eltrans = test_fes->GetElementTransformation(i);
-      domain_integs[0]->AssembleElementMatrix2(trial_fe, test_fe, *eltrans,
-                                               elmat);
-      for (int k = 1; k < domain_integs.Size(); k++)
-      {
-         domain_integs[k]->AssembleElementMatrix2(trial_fe, test_fe, *eltrans,
-                                                  elemmat);
-         elmat += elemmat;
-      }
-   }
-   else
-   {
-      trial_fes->GetElementVDofs(i, trial_vdofs);
-      test_fes->GetElementVDofs(i, test_vdofs);
-      elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
-      elmat = 0.0;
-   }
-}
-
-void MixedBilinearForm::ComputeBdrElementMatrix(int i, DenseMatrix &elmat)
-{
-   if (boundary_integs.Size())
-   {
-      const FiniteElement &trial_be = *trial_fes->GetBE(i);
-      const FiniteElement &test_be = *test_fes->GetBE(i);
-      ElementTransformation *eltrans = test_fes->GetBdrElementTransformation(i);
-      boundary_integs[0]->AssembleElementMatrix2(trial_be, test_be, *eltrans,
-                                                 elmat);
-      for (int k = 1; k < boundary_integs.Size(); k++)
-      {
-         boundary_integs[k]->AssembleElementMatrix2(trial_be, test_be, *eltrans,
-                                                    elemmat);
-         elmat += elemmat;
-      }
-   }
-   else
-   {
-      trial_fes->GetBdrElementVDofs(i, trial_vdofs);
-      test_fes->GetBdrElementVDofs(i, test_vdofs);
-      elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
-      elmat = 0.0;
-   }
-}
-
-void MixedBilinearForm::AssembleElementMatrix(
-   int i, const DenseMatrix &elmat, int skip_zeros)
-{
-   AssembleElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
-}
-
-void MixedBilinearForm::AssembleElementMatrix(
-   int i, const DenseMatrix &elmat, Array<int> &trial_vdofs_,
-   Array<int> &test_vdofs_, int skip_zeros)
-{
-   trial_fes->GetElementVDofs(i, trial_vdofs_);
-   test_fes->GetElementVDofs(i, test_vdofs_);
-   if (mat == NULL)
-   {
-      mat = new SparseMatrix(height, width);
-   }
-   mat->AddSubMatrix(test_vdofs_, trial_vdofs_, elmat, skip_zeros);
-}
-
-void MixedBilinearForm::AssembleBdrElementMatrix(
-   int i, const DenseMatrix &elmat, int skip_zeros)
-{
-   AssembleBdrElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
-}
-
-void MixedBilinearForm::AssembleBdrElementMatrix(
-   int i, const DenseMatrix &elmat, Array<int> &trial_vdofs_,
-   Array<int> &test_vdofs_, int skip_zeros)
-{
-   trial_fes->GetBdrElementVDofs(i, trial_vdofs_);
-   test_fes->GetBdrElementVDofs(i, test_vdofs_);
-   if (mat == NULL)
-   {
-      mat = new SparseMatrix(height, width);
-   }
-   mat->AddSubMatrix(test_vdofs_, trial_vdofs_, elmat, skip_zeros);
-}
-
-void MixedBilinearForm::EliminateTrialDofs(
-   const Array<int> &bdr_attr_is_ess, const Vector &sol, Vector &rhs )
-{
-   int i, j, k;
-   Array<int> tr_vdofs, cols_marker(trial_fes->GetVSize());
-
-   cols_marker = 0;
-   for (i = 0; i < trial_fes->GetNBE(); i++)
-      if (bdr_attr_is_ess[trial_fes->GetBdrAttribute(i)-1])
-      {
-         trial_fes->GetBdrElementVDofs(i, tr_vdofs);
-         for (j = 0; j < tr_vdofs.Size(); j++)
-         {
-            if ((k = tr_vdofs[j]) < 0)
-            {
-               k = -1-k;
-            }
-            cols_marker[k] = 1;
-         }
-      }
-   mat->EliminateCols(cols_marker, &sol, &rhs);
-}
-
-void MixedBilinearForm::EliminateEssentialBCFromTrialDofs(
-   const Array<int> &marked_vdofs, const Vector &sol, Vector &rhs)
-{
-   mat->EliminateCols(marked_vdofs, &sol, &rhs);
-}
-
-void MixedBilinearForm::EliminateTestDofs(const Array<int> &bdr_attr_is_ess)
-{
-   int i, j, k;
-   Array<int> te_vdofs;
-
-   for (i = 0; i < test_fes->GetNBE(); i++)
-      if (bdr_attr_is_ess[test_fes->GetBdrAttribute(i)-1])
-      {
-         test_fes->GetBdrElementVDofs(i, te_vdofs);
-         for (j = 0; j < te_vdofs.Size(); j++)
-         {
-            if ((k = te_vdofs[j]) < 0)
-            {
-               k = -1-k;
-            }
-            mat->EliminateRow(k);
-         }
-      }
-}
-
 void MixedBilinearForm::FormRectangularLinearSystem(
    const Array<int> &trial_tdof_list,
    const Array<int> &test_tdof_list,
@@ -1867,6 +1482,59 @@ void MixedBilinearForm::FormRectangularSystemMatrix(
    A.Reset(mat, false);
 }
 
+void MixedBilinearForm::EliminateTrialDofs(
+   const Array<int> &bdr_attr_is_ess, const Vector &sol, Vector &rhs)
+{
+   int i, j, k;
+   Array<int> ess_dofs, cols_marker(trial_fes->GetVSize());
+   cols_marker = 0;
+
+   for (i = 0; i < trial_fes->GetNBE(); i++)
+   {
+      if (bdr_attr_is_ess[trial_fes->GetBdrAttribute(i)-1])
+      {
+         trial_fes->GetBdrElementVDofs(i, ess_dofs);
+         for (j = 0; j < ess_dofs.Size(); j++)
+         {
+            if ((k = ess_dofs[j]) < 0)
+            {
+               k = -1-k;
+            }
+            cols_marker[k] = 1;
+         }
+      }
+   }
+   mat->EliminateCols(cols_marker, &sol, &rhs);
+}
+
+void MixedBilinearForm::EliminateEssentialBCFromTrialDofs(
+   const Array<int> &marked_vdofs, const Vector &sol, Vector &rhs)
+{
+   mat->EliminateCols(marked_vdofs, &sol, &rhs);
+}
+
+void MixedBilinearForm::EliminateTestDofs(const Array<int> &bdr_attr_is_ess)
+{
+   int i, j, k;
+   Array<int> ess_dofs;
+
+   for (i = 0; i < test_fes->GetNBE(); i++)
+   {
+      if (bdr_attr_is_ess[test_fes->GetBdrAttribute(i)-1])
+      {
+         test_fes->GetBdrElementVDofs(i, ess_dofs);
+         for (j = 0; j < ess_dofs.Size(); j++)
+         {
+            if ((k = ess_dofs[j]) < 0)
+            {
+               k = -1-k;
+            }
+            mat->EliminateRow(k);
+         }
+      }
+   }
+}
+
 void MixedBilinearForm::Update()
 {
    delete mat;
@@ -1931,11 +1599,9 @@ void DiscreteLinearOperator::Assemble(int skip_zeros)
       return;
    }
 
-   ElementTransformation *eltrans;
-   DofTransformation *dom_dof_trans;
-   DofTransformation *ran_dof_trans;
    Mesh *mesh = test_fes->GetMesh();
    DenseMatrix elmat;
+   Array<int> trial_vdofs, test_vdofs;
 
    if (mat == NULL)
    {
@@ -1944,11 +1610,11 @@ void DiscreteLinearOperator::Assemble(int skip_zeros)
 
    if (domain_integs.Size())
    {
-      for (int i = 0; i < test_fes->GetNE(); i++)
+      for (int i = 0; i < mesh->GetNE(); i++)
       {
-         dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
-         ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
-         eltrans = test_fes->GetElementTransformation(i);
+         DofTransformation *dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
+         DofTransformation *ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
+         ElementTransformation *eltrans = test_fes->GetElementTransformation(i);
 
          elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
          elmat = 0.0;
@@ -1969,12 +1635,11 @@ void DiscreteLinearOperator::Assemble(int skip_zeros)
 
    if (trace_face_integs.Size())
    {
-      const int nfaces = mesh->GetNumFaces();
-      for (int i = 0; i < nfaces; i++)
+      for (int i = 0; i < mesh->GetNumFaces(); i++)
       {
          trial_fes->GetFaceVDofs(i, trial_vdofs);
          test_fes->GetFaceVDofs(i, test_vdofs);
-         eltrans = mesh->GetFaceTransformation(i);
+         ElementTransformation *eltrans = mesh->GetFaceTransformation(i);
 
          elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
          elmat = 0.0;
diff --git a/fem/bilinearform.hpp b/fem/bilinearform.hpp
index 9dc88ed97..55b8793ab 100644
--- a/fem/bilinearform.hpp
+++ b/fem/bilinearform.hpp
@@ -36,8 +36,6 @@ enum class AssemblyLevel
    /// is fully evaluated on the fly.
    /// This assembly level is ALWAYS performed on the host.
    LEGACY = 0,
-   /// @deprecated Use LEGACY instead.
-   LEGACYFULL = 0,
    /// Fully assembled form, i.e. a global sparse matrix in MFEM format. This
    /// assembly is compatible with device execution.
    FULL,
@@ -66,7 +64,7 @@ protected:
    SparseMatrix *mat;
 
    /** @brief Sparse Matrix \f$ M_e \f$ used to store the eliminations
-        from the b.c.  Owned.
+        from the b.c. Owned.
        \f$ M + M_e = M_{original} \f$ */
    SparseMatrix *mat_e;
 
@@ -75,11 +73,11 @@ protected:
 
    /// The assembly level of the form (full, partial, etc.)
    AssemblyLevel assembly;
-   /// Element batch size used in the form action (1, 8, num_elems, etc.)
-   int batch;
+
    /** @brief Extension for supporting Full Assembly (FA), Element Assembly (EA),
        Partial Assembly (PA), or Matrix Free assembly (MF). */
    BilinearFormExtension *ext;
+
    /** Indicates if the sparse matrix is sorted after assembly when using
        Full Assembly (FA). */
    bool sort_sparse_matrix = false;
@@ -113,11 +111,6 @@ protected:
    Array<BilinearFormIntegrator*> boundary_face_integs;
    Array<Array<int>*> boundary_face_integs_marker; ///< Entries are not owned.
 
-   DenseMatrix elemmat;
-   Array<int>  vdofs;
-
-   DenseTensor *element_matrices; ///< Owned.
-
    StaticCondensation *static_cond; ///< Owned.
    Hybridization *hybridization; ///< Owned.
 
@@ -126,30 +119,28 @@ protected:
        the constrained DoFs. */
    DiagonalPolicy diag_policy;
 
-   int precompute_sparsity;
-
-   // Allocate appropriate SparseMatrix and assign it to mat
-   void AllocMat();
+   DenseMatrix elemmat;
 
    // may be used in the construction of derived classes
    BilinearForm() : Matrix(0)
    {
-      fes = NULL; sequence = -1;
-      mat = mat_e = NULL; extern_bfs = 0; element_matrices = NULL;
-      static_cond = NULL; hybridization = NULL;
-      precompute_sparsity = 0;
+      fes = NULL;
+      sequence = -1;
+      mat = mat_e = NULL;
+      extern_bfs = 0;
+      static_cond = NULL;
+      hybridization = NULL;
       diag_policy = DIAG_KEEP;
       assembly = AssemblyLevel::LEGACY;
-      batch = 1;
       ext = NULL;
    }
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   BilinearForm(const BilinearForm &);
+   /// Copy construction is not supported.
+   BilinearForm(const BilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   BilinearForm &operator=(const BilinearForm &);
+   /// Copy assignment is not supported.
+   BilinearForm &operator=(const BilinearForm &) = delete;
 
 public:
    /// Creates bilinear form associated with FE space @a *f.
@@ -162,11 +153,8 @@ public:
        The pointer @a f is not owned by the newly constructed object.
 
        The integrators in @a bf are copied as pointers and they are not owned by
-       the newly constructed BilinearForm.
-
-       The optional parameter @a ps is used to initialize the internal flag
-       #precompute_sparsity, see UsePrecomputedSparsity() for details. */
-   BilinearForm(FiniteElementSpace *f, BilinearForm *bf, int ps = 0);
+       the newly constructed BilinearForm. */
+   BilinearForm(FiniteElementSpace *f, BilinearForm *bf);
 
    /// Get the size of the BilinearForm as a square matrix.
    int Size() const { return height; }
@@ -237,31 +225,6 @@ public:
    FiniteElementSpace *SCFESpace() const
    { return static_cond ? static_cond->GetTraceFESpace() : NULL; }
 
-   /** @brief For scalar FE spaces, precompute the sparsity pattern of the matrix
-       (assuming dense element matrices) based on the types of integrators
-       present in the bilinear form. */
-   void UsePrecomputedSparsity(int ps = 1) { precompute_sparsity = ps; }
-
-   /** @brief Use the given CSR sparsity pattern to allocate the internal
-       SparseMatrix.
-
-       - The @a I and @a J arrays must define a square graph with size equal to
-         GetVSize() of the associated FiniteElementSpace.
-       - This method should be called after enabling static condensation or
-         hybridization, if used.
-       - In the case of static condensation, @a I and @a J are not used.
-       - The ownership of the arrays @a I and @a J remains with the caller. */
-   void UseSparsity(int *I, int *J, bool isSorted);
-
-   /// Use the sparsity of @a A to allocate the internal SparseMatrix.
-   void UseSparsity(SparseMatrix &A);
-
-   /// Pre-allocate the internal SparseMatrix before assembly.
-   /**  If the flag 'precompute sparsity'
-       is set, the matrix is allocated in CSR format (i.e.
-       finalized) and the entries are initialized with zeros. */
-   void AllocateMatrix() { if (mat == NULL) { AllocMat(); } }
-
    /// Returns a reference to: \f$ M_{ij} \f$
    const double &operator()(int i, int j) { return (*mat)(i,j); }
 
@@ -286,7 +249,7 @@ public:
                                  const double a = 1.0) const;
 
    /** @brief Matrix vector multiplication with the original uneliminated
-       matrix.  The original matrix is \f$ M + M_e \f$ so we have:
+       matrix. The original matrix is \f$ M + M_e \f$ so we have:
        \f$ y = M x + M_e x \f$ */
    void FullMult(const Vector &x, Vector &y) const
    { mat->Mult(x, y); mat_e->AddMult(x, y); }
@@ -374,9 +337,28 @@ public:
    bool HasSpMatElim() const { return mat_e != nullptr; }
 
    /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
-        to it.  Used for transferring ownership. */
+        to it. Used for transferring ownership. */
    SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
 
+   /** Returns a const reference to the extension for assembly levels other
+    than AssemblyLevel::LEGACY. */
+   const BilinearFormExtension &Ext() const
+   {
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
+   }
+
+   /** Returns a reference to the extension for assembly levels other than
+       AssemblyLevel::LEGACY. */
+   BilinearFormExtension &Ext()
+   {
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
+   }
+
+   /// Returns true if the extension is not null, false otherwise.
+   bool HasExt() const { return ext != nullptr; }
+
    /// Adds new Domain Integrator. Assumes ownership of @a bfi.
    void AddDomainIntegrator(BilinearFormIntegrator *bfi);
    /// Adds new Domain Integrator restricted to certain elements specified by
@@ -430,7 +412,49 @@ public:
    Array<Array<int>*> *GetBFBFI_Marker()
    { return &boundary_face_integs_marker; }
 
-   /// Assembles the form i.e. sums over all domain/bdr integrators.
+   /// Compute the element matrix of the given element
+   void ComputeElementMatrix(int i, DenseMatrix &elmat, Array<int> &vdofs);
+
+   /// Compute the boundary element matrix of the given boundary element
+   void ComputeBdrElementMatrix(int i, DenseMatrix &elmat, Array<int> &vdofs);
+
+   /// Assemble the given element matrix
+   /** The element matrix @a elmat is assembled for the element @a i, i.e.
+       added to the system matrix. The flag @a skip_zeros skips the zero
+       elements of the matrix, unless they are breaking the symmetry of
+       the system matrix.
+   */
+   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
+                              int skip_zeros = 1);
+
+   /// Assemble the given element matrix
+   /** The element matrix @a elmat is assembled for the element @a i, i.e.
+       added to the system matrix. The vdofs of the element are returned
+       in @a vdofs. The flag @a skip_zeros skips the zero elements of the
+       matrix, unless they are breaking the symmetry of the system matrix.
+   */
+   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
+                              const Array<int> &vdofs, int skip_zeros = 1);
+
+   /// Assemble the given boundary element matrix
+   /** The boundary element matrix @a elmat is assembled for the boundary
+       element @a i, i.e. added to the system matrix. The flag @a skip_zeros
+       skips the zero elements of the matrix, unless they are breaking the
+       symmetry of the system matrix.
+   */
+   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
+                                 int skip_zeros = 1);
+
+   /// Assemble the given boundary element matrix
+   /** The boundary element matrix @a elmat is assembled for the boundary
+       element @a i, i.e. added to the system matrix. The vdofs of the element
+       are returned in @a vdofs. The flag @a skip_zeros skips the zero elements
+       of the matrix, unless they are breaking the symmetry of the system matrix.
+   */
+   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
+                                 const Array<int> &vdofs, int skip_zeros = 1);
+
+   /// Assembles the form i.e. sums over all domain/boundary integrators.
    void Assemble(int skip_zeros = 1);
 
    /** For a partially conforming FE space, complete the assembly process by
@@ -542,59 +566,6 @@ public:
    */
    virtual void RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x);
 
-   /// Compute and store internally all element matrices.
-   void ComputeElementMatrices();
-
-   /// Free the memory used by the element matrices.
-   void FreeElementMatrices()
-   { delete element_matrices; element_matrices = NULL; }
-
-   /// Compute the element matrix of the given element
-   /** The element matrix is computed by calling the domain integrators
-       or the one stored internally by a prior call of ComputeElementMatrices()
-       is returned when available.
-   */
-   void ComputeElementMatrix(int i, DenseMatrix &elmat);
-
-   /// Compute the boundary element matrix of the given boundary element
-   void ComputeBdrElementMatrix(int i, DenseMatrix &elmat);
-
-   /// Assemble the given element matrix
-   /** The element matrix @a elmat is assembled for the element @a i, i.e.
-       added to the system matrix. The flag @a skip_zeros skips the zero
-       elements of the matrix, unless they are breaking the symmetry of
-       the system matrix.
-   */
-   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
-                              int skip_zeros = 1);
-
-   /// Assemble the given element matrix
-   /** The element matrix @a elmat is assembled for the element @a i, i.e.
-       added to the system matrix. The vdofs of the element are returned
-       in @a vdofs. The flag @a skip_zeros skips the zero elements of the
-       matrix, unless they are breaking the symmetry of the system matrix.
-   */
-   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
-                              Array<int> &vdofs, int skip_zeros = 1);
-
-   /// Assemble the given boundary element matrix
-   /** The boundary element matrix @a elmat is assembled for the boundary
-       element @a i, i.e. added to the system matrix. The flag @a skip_zeros
-       skips the zero elements of the matrix, unless they are breaking the
-       symmetry of the system matrix.
-   */
-   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
-                                 int skip_zeros = 1);
-
-   /// Assemble the given boundary element matrix
-   /** The boundary element matrix @a elmat is assembled for the boundary
-       element @a i, i.e. added to the system matrix. The vdofs of the element
-       are returned in @a vdofs. The flag @a skip_zeros skips the zero elements
-       of the matrix, unless they are breaking the symmetry of the system matrix.
-   */
-   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
-                                 Array<int> &vdofs, int skip_zeros = 1);
-
    /// Eliminate essential boundary DOFs from the system.
    /** The array @a bdr_attr_is_ess marks boundary attributes that constitute
        the essential part of the boundary. By default, the diagonal at the
@@ -666,7 +637,7 @@ public:
        a(u,v) = V^t M U
 
    where `U` and `V` are the vectors representing the functions `u` and `v`,
-   respectively.  The first argument, `u`, of `a(,)` is in the trial space
+   respectively. The first argument, `u`, of `a(,)` is in the trial space
    and the second argument, `v`, is in the test space. Thus,
 
        # of rows of M = dimension of the test space and
@@ -677,11 +648,12 @@ public:
 class MixedBilinearForm : public Matrix
 {
 protected:
-   SparseMatrix *mat; ///< Owned.
-   SparseMatrix *mat_e; ///< Owned.
+   /** Sparse matrices associated with the form and the eliminations from
+       the b.c. Owned. */
+   SparseMatrix *mat, *mat_e;
 
-   FiniteElementSpace *trial_fes, ///< Not owned
-                      *test_fes;  ///< Not owned
+   /// FE space on which the form lives. Not owned.
+   FiniteElementSpace *trial_fes, *test_fes;
 
    /// The form assembly level (full, partial, etc.)
    AssemblyLevel assembly;
@@ -711,14 +683,13 @@ protected:
    Array<Array<int>*> boundary_trace_face_integs_marker;
 
    DenseMatrix elemmat;
-   Array<int>  trial_vdofs, test_vdofs;
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   MixedBilinearForm(const MixedBilinearForm &);
+   /// Copy construction is not supported.
+   MixedBilinearForm(const MixedBilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   MixedBilinearForm &operator=(const MixedBilinearForm &);
+   /// Copy assignment is not supported.
+   MixedBilinearForm &operator=(const MixedBilinearForm &) = delete;
 
 public:
    /** @brief Construct a MixedBilinearForm on the given trial, @a tr_fes, and
@@ -779,18 +750,45 @@ public:
    void GetBlocks(Array2D<SparseMatrix *> &blocks) const;
 
    /// Returns a const reference to the sparse matrix:  \f$ M \f$
-   const SparseMatrix &SpMat() const { return *mat; }
+   const SparseMatrix &SpMat() const
+   {
+      MFEM_VERIFY(mat, "mat is NULL and can't be dereferenced");
+      return *mat;
+   }
 
    /// Returns a reference to the sparse matrix:  \f$ M \f$
-   SparseMatrix &SpMat() { return *mat; }
+   SparseMatrix &SpMat()
+   {
+      MFEM_VERIFY(mat, "mat is NULL and can't be dereferenced");
+      return *mat;
+   }
 
    /// Returns true if the sparse matrix is not null, false otherwise.
    bool HasSpMat() const { return mat != nullptr; }
 
    /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
-        to it.  Used for transferring ownership. */
+        to it. Used for transferring ownership. */
    SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
 
+   /** Returns a const reference to the extension for assembly levels other
+    than AssemblyLevel::LEGACY. */
+   const MixedBilinearFormExtension &Ext() const
+   {
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
+   }
+
+   /** Returns a reference to the extension for assembly levels other than
+       AssemblyLevel::LEGACY. */
+   MixedBilinearFormExtension &Ext()
+   {
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
+   }
+
+   /// Returns true if the extension is not null, false otherwise.
+   bool HasExt() const { return ext != nullptr; }
+
    /// Adds a domain integrator. Assumes ownership of @a bfi.
    void AddDomainIntegrator(BilinearFormIntegrator *bfi);
 
@@ -837,40 +835,13 @@ public:
    Array<Array<int>*> *GetBTFBFI_Marker()
    { return &boundary_trace_face_integs_marker; }
 
-   void Assemble(int skip_zeros = 1);
-
-   /** For partially conforming trial and/or test FE spaces, complete the
-       assembly process by performing A := P2^t A P1 where A is the internal
-       sparse matrix; P1 and P2 are the conforming prolongation matrices of the
-       trial and test FE spaces, respectively. After this call the
-       MixedBilinearForm becomes an operator on the conforming FE spaces. */
-   void ConformingAssemble();
-
-   /** @brief Assemble the diagonal of ADA^T into diag, where A is this mixed
-       bilinear form and D is a diagonal. */
-   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
-
-   /// Get the input finite element space prolongation matrix
-   virtual const Operator *GetProlongation() const
-   { return trial_fes->GetProlongationMatrix(); }
-
-   /// Get the input finite element space restriction matrix
-   virtual const Operator *GetRestriction() const
-   { return trial_fes->GetRestrictionMatrix(); }
-
-   /// Get the test finite element space prolongation matrix
-   virtual const Operator *GetOutputProlongation() const
-   { return test_fes->GetProlongationMatrix(); }
-
-   /// Get the test finite element space restriction matrix
-   virtual const Operator *GetOutputRestriction() const
-   { return test_fes->GetRestrictionMatrix(); }
-
    /// Compute the element matrix of the given element
-   void ComputeElementMatrix(int i, DenseMatrix &elmat);
+   void ComputeElementMatrix(int i, DenseMatrix &elmat, Array<int> &trial_vdofs,
+                             Array<int> &test_vdofs);
 
    /// Compute the boundary element matrix of the given boundary element
-   void ComputeBdrElementMatrix(int i, DenseMatrix &elmat);
+   void ComputeBdrElementMatrix(int i, DenseMatrix &elmat, Array<int> &trial_vdofs,
+                                Array<int> &test_vdofs);
 
    /// Assemble the given element matrix
    /** The element matrix @a elmat is assembled for the element @a i, i.e.
@@ -889,7 +860,8 @@ public:
        of the system matrix.
    */
    void AssembleElementMatrix(int i, const DenseMatrix &elmat,
-                              Array<int> &trial_vdofs, Array<int> &test_vdofs,
+                              const Array<int> &trial_vdofs,
+                              const Array<int> &test_vdofs,
                               int skip_zeros = 1);
 
    /// Assemble the given boundary element matrix
@@ -909,16 +881,39 @@ public:
        symmetry of the system matrix.
    */
    void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
-                                 Array<int> &trial_vdofs, Array<int> &test_vdofs,
+                                 const Array<int> &trial_vdofs,
+                                 const Array<int> &test_vdofs,
                                  int skip_zeros = 1);
 
-   void EliminateTrialDofs(const Array<int> &bdr_attr_is_ess,
-                           const Vector &sol, Vector &rhs);
+   /// Assembles the form i.e. sums over all domain/boundary integrators.
+   void Assemble(int skip_zeros = 1);
 
-   void EliminateEssentialBCFromTrialDofs(const Array<int> &marked_vdofs,
-                                          const Vector &sol, Vector &rhs);
+   /** For partially conforming trial and/or test FE spaces, complete the
+       assembly process by performing A := P2^t A P1 where A is the internal
+       sparse matrix; P1 and P2 are the conforming prolongation matrices of the
+       trial and test FE spaces, respectively. After this call the
+       MixedBilinearForm becomes an operator on the conforming FE spaces. */
+   void ConformingAssemble();
 
-   virtual void EliminateTestDofs(const Array<int> &bdr_attr_is_ess);
+   /** @brief Assemble the diagonal of ADA^T into diag, where A is this mixed
+       bilinear form and D is a diagonal. */
+   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
+
+   /// Get the input finite element space prolongation matrix
+   virtual const Operator *GetProlongation() const
+   { return trial_fes->GetProlongationMatrix(); }
+
+   /// Get the input finite element space restriction matrix
+   virtual const Operator *GetRestriction() const
+   { return trial_fes->GetRestrictionMatrix(); }
+
+   /// Get the test finite element space prolongation matrix
+   virtual const Operator *GetOutputProlongation() const
+   { return test_fes->GetProlongationMatrix(); }
+
+   /// Get the test finite element space restriction matrix
+   virtual const Operator *GetOutputRestriction() const
+   { return test_fes->GetRestrictionMatrix(); }
 
    /** @brief Form the linear system A X = B, corresponding to this mixed bilinear
        form and the linear form @a b(.).
@@ -980,6 +975,14 @@ public:
       A.MakeRef(*A_ptr);
    }
 
+   void EliminateTrialDofs(const Array<int> &bdr_attr_is_ess,
+                           const Vector &sol, Vector &rhs);
+
+   void EliminateEssentialBCFromTrialDofs(const Array<int> &marked_vdofs,
+                                          const Vector &sol, Vector &rhs);
+
+   virtual void EliminateTestDofs(const Array<int> &bdr_attr_is_ess);
+
    void Update();
 
    /// Return the trial FE space associated with the BilinearForm.
@@ -1029,11 +1032,11 @@ public:
 class DiscreteLinearOperator : public MixedBilinearForm
 {
 private:
-   /// Copy construction is not supported; body is undefined.
-   DiscreteLinearOperator(const DiscreteLinearOperator &);
+   /// Copy construction is not supported.
+   DiscreteLinearOperator(const DiscreteLinearOperator &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   DiscreteLinearOperator &operator=(const DiscreteLinearOperator &);
+   /// Copy assignment is not supported.
+   DiscreteLinearOperator &operator=(const DiscreteLinearOperator &) = delete;
 
 public:
    /** @brief Construct a DiscreteLinearOperator on the given
@@ -1058,7 +1061,7 @@ public:
    /// Access all interpolators added with AddTraceFaceInterpolator().
    Array<BilinearFormIntegrator*> *GetTFI() { return GetTFBFI(); }
 
-   /// Set the desired assembly level. The default is AssemblyLevel::FULL.
+   /// Set the desired assembly level. The default is AssemblyLevel::LEGACY.
    /** This method must be called before assembly. */
    void SetAssemblyLevel(AssemblyLevel assembly_level);
 
diff --git a/fem/bilinearform_ext.cpp b/fem/bilinearform_ext.cpp
index e0174871d..c916866fc 100644
--- a/fem/bilinearform_ext.cpp
+++ b/fem/bilinearform_ext.cpp
@@ -2188,6 +2188,33 @@ void PADiscreteLinearOperatorExtension::Assemble()
    test_multiplicity.Reciprocal();
 }
 
+void PADiscreteLinearOperatorExtension::Mult(const Vector &x, Vector &y) const
+{
+   Array<BilinearFormIntegrator *> &interpolators = *a->GetDBFI();
+   if (elem_restrict_trial)
+   {
+      elem_restrict_trial->Mult(x, local_trial);
+   }
+   if (elem_restrict_test)
+   {
+      local_test = 0.0;
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultPA(elem_restrict_trial ? local_trial : x, local_test);
+      }
+      elem_restrict_test->MultTranspose(local_test, y);
+   }
+   else
+   {
+      y = 0.0;
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultPA(elem_restrict_trial ? local_trial : x, y);
+      }
+   }
+   y *= test_multiplicity;
+}
+
 void PADiscreteLinearOperatorExtension::AddMult(const Vector &x, Vector &y,
                                                 const double c) const
 {
@@ -2209,6 +2236,7 @@ void PADiscreteLinearOperatorExtension::AddMult(const Vector &x, Vector &y,
    }
    else
    {
+      temp_test = 0.0;
       for (BilinearFormIntegrator *interp : interpolators)
       {
          interp->AddMultPA(elem_restrict_trial ? local_trial : x, temp_test);
@@ -2222,6 +2250,9 @@ void PADiscreteLinearOperatorExtension::AddMultTranspose(const Vector &x,
                                                          Vector &y,
                                                          const double c) const
 {
+   MFEM_VERIFY(c == 1.0,
+               "General coefficient case for PADiscreteLinearOperatorExtension::"
+               "AddMultTranspose is not yet supported!");
    Array<BilinearFormIntegrator *> &interpolators = *a->GetDBFI();
    temp_test = x;
    temp_test *= test_multiplicity;
@@ -2237,26 +2268,14 @@ void PADiscreteLinearOperatorExtension::AddMultTranspose(const Vector &x,
          interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test,
                                     local_trial);
       }
-      if (c != 1.0)
-      {
-         local_trial *= c;
-      }
       elem_restrict_trial->AddMultTranspose(local_trial, y);
    }
    else
    {
       y.UseDevice(true); // typically this is a large vector, so store on device
-      if (c != 1.0)
-      {
-         MFEM_ABORT("General coefficient case for PADiscreteLinearOperatorExtension::"
-                    "AddMultTranspose is not yet supported!");
-      }
-      else
+      for (BilinearFormIntegrator *interp : interpolators)
       {
-         for (BilinearFormIntegrator *interp : interpolators)
-         {
-            interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test, y);
-         }
+         interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test, y);
       }
    }
 }
diff --git a/fem/bilinearform_ext.hpp b/fem/bilinearform_ext.hpp
index db26eb801..aa9271d8f 100644
--- a/fem/bilinearform_ext.hpp
+++ b/fem/bilinearform_ext.hpp
@@ -227,6 +227,7 @@ public:
    PADiscreteLinearOperatorExtension(DiscreteLinearOperator *linop);
 
    void Assemble();
+   void Mult(const Vector &x, Vector &y) const;
    void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
    void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
 };
diff --git a/fem/bilininteg.cpp b/fem/bilininteg.cpp
index e6fc2a6ee..71959402b 100644
--- a/fem/bilininteg.cpp
+++ b/fem/bilininteg.cpp
@@ -141,7 +141,7 @@ void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace&,
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &,
+void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace&,
                                                      Vector&,
                                                      Vector&)
 {
@@ -156,47 +156,50 @@ void BilinearFormIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace&,
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleElementMatrix(
-   const FiniteElement &el, ElementTransformation &Trans,
-   DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleElementMatrix(const FiniteElement&,
+                                                   ElementTransformation&,
+                                                   DenseMatrix&)
 {
    MFEM_ABORT("BilinearFormIntegrator::AssembleElementMatrix(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleElementMatrix2(
-   const FiniteElement &el1, const FiniteElement &el2,
-   ElementTransformation &Trans, DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleElementMatrix2(const FiniteElement&,
+                                                    const FiniteElement&,
+                                                    ElementTransformation&,
+                                                    DenseMatrix&)
 {
    MFEM_ABORT("BilinearFormIntegrator::AssembleElementMatrix2(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleFaceMatrix(
-   const FiniteElement &el1, const FiniteElement &el2,
-   FaceElementTransformations &Trans, DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleFaceMatrix(const FiniteElement&,
+                                                const FiniteElement&,
+                                                FaceElementTransformations&Trans,
+                                                DenseMatrix&)
 {
    MFEM_ABORT("BilinearFormIntegrator::AssembleFaceMatrix(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleFaceMatrix(
-   const FiniteElement &trial_face_fe, const FiniteElement &test_fe1,
-   const FiniteElement &test_fe2, FaceElementTransformations &Trans,
-   DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleFaceMatrix2(const FiniteElement&,
+                                                 const FiniteElement&,
+                                                 const FiniteElement&,
+                                                 FaceElementTransformations&,
+                                                 DenseMatrix&)
 {
-   MFEM_ABORT("AssembleFaceMatrix (mixed form) is not implemented for this"
-              " Integrator class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleFaceMatrix2(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleTraceFaceMatrix (int elem,
-                                                      const FiniteElement &trial_face_fe,
-                                                      const FiniteElement &test_fe1,
-                                                      FaceElementTransformations &Trans,
-                                                      DenseMatrix &elmat)
+void BilinearFormIntegrator::AssembleTraceFaceMatrix(int,
+                                                     const FiniteElement&,
+                                                     const FiniteElement&,
+                                                     FaceElementTransformations&,
+                                                     DenseMatrix&)
 {
-   MFEM_ABORT("AssembleTraceFaceMatrix (DPG form) is not implemented for this"
-              " Integrator class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleTraceFaceMatrix(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleElementVector(
@@ -221,17 +224,10 @@ void BilinearFormIntegrator::AssembleFaceVector(
    elmat.Mult(elfun, elvect);
 }
 
-void TransposeIntegrator::SetIntRule(const IntegrationRule *ir)
-{
-   IntRule = ir;
-   bfi->SetIntRule(ir);
-}
-
 void TransposeIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
    bfi->AssembleElementMatrix(el, Trans, bfi_elmat);
-   // elmat = bfi_elmat^t
    elmat.Transpose(bfi_elmat);
 }
 
@@ -240,7 +236,6 @@ void TransposeIntegrator::AssembleElementMatrix2(
    ElementTransformation &Trans, DenseMatrix &elmat)
 {
    bfi->AssembleElementMatrix2(test_fe, trial_fe, Trans, bfi_elmat);
-   // elmat = bfi_elmat^t
    elmat.Transpose(bfi_elmat);
 }
 
@@ -249,16 +244,9 @@ void TransposeIntegrator::AssembleFaceMatrix(
    FaceElementTransformations &Trans, DenseMatrix &elmat)
 {
    bfi->AssembleFaceMatrix(el1, el2, Trans, bfi_elmat);
-   // elmat = bfi_elmat^t
    elmat.Transpose(bfi_elmat);
 }
 
-void LumpedIntegrator::SetIntRule(const IntegrationRule *ir)
-{
-   IntRule = ir;
-   bfi->SetIntRule(ir);
-}
-
 void LumpedIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
@@ -266,38 +254,41 @@ void LumpedIntegrator::AssembleElementMatrix(
    elmat.Lump();
 }
 
-void InverseIntegrator::SetIntRule(const IntegrationRule *ir)
-{
-   IntRule = ir;
-   integrator->SetIntRule(ir);
-}
-
 void InverseIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   integrator->AssembleElementMatrix(el, Trans, elmat);
+   bfi->AssembleElementMatrix(el, Trans, elmat);
    elmat.Invert();
 }
 
+bool SumIntegrator::SupportsCeed() const
+{
+   for (int i = 0; i < bfis.Size(); i++)
+   {
+      if (!bfis[i]->SupportsCeed()) { return false; }
+   }
+   return true;
+}
+
 void SumIntegrator::SetIntRule(const IntegrationRule *ir)
 {
    IntRule = ir;
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->SetIntRule(ir);
+      bfis[i]->SetIntRule(ir);
    }
 }
 
 void SumIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   MFEM_ASSERT(integrators.Size() > 0, "empty SumIntegrator.");
+   MFEM_ASSERT(bfis.Size() > 0, "empty SumIntegrator.");
 
-   integrators[0]->AssembleElementMatrix(el, Trans, elmat);
-   for (int i = 1; i < integrators.Size(); i++)
+   bfis[0]->AssembleElementMatrix(el, Trans, elmat);
+   for (int i = 1; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleElementMatrix(el, Trans, elem_mat);
-      elmat += elem_mat;
+      bfis[i]->AssembleElementMatrix(el, Trans, bfi_elmat);
+      elmat += bfi_elmat;
    }
 }
 
@@ -305,13 +296,13 @@ void SumIntegrator::AssembleElementMatrix2(
    const FiniteElement &el1, const FiniteElement &el2,
    ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   MFEM_ASSERT(integrators.Size() > 0, "empty SumIntegrator.");
+   MFEM_ASSERT(bfis.Size() > 0, "empty SumIntegrator.");
 
-   integrators[0]->AssembleElementMatrix2(el1, el2, Trans, elmat);
-   for (int i = 1; i < integrators.Size(); i++)
+   bfis[0]->AssembleElementMatrix2(el1, el2, Trans, elmat);
+   for (int i = 1; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleElementMatrix2(el1, el2, Trans, elem_mat);
-      elmat += elem_mat;
+      bfis[i]->AssembleElementMatrix2(el1, el2, Trans, bfi_elmat);
+      elmat += bfi_elmat;
    }
 }
 
@@ -319,134 +310,134 @@ void SumIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
 {
-   MFEM_ASSERT(integrators.Size() > 0, "empty SumIntegrator.");
+   MFEM_ASSERT(bfis.Size() > 0, "empty SumIntegrator.");
 
-   integrators[0]->AssembleFaceMatrix(el1, el2, Trans, elmat);
-   for (int i = 1; i < integrators.Size(); i++)
+   bfis[0]->AssembleFaceMatrix(el1, el2, Trans, elmat);
+   for (int i = 1; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleFaceMatrix(el1, el2, Trans, elem_mat);
-      elmat += elem_mat;
+      bfis[i]->AssembleFaceMatrix(el1, el2, Trans, bfi_elmat);
+      elmat += bfi_elmat;
    }
 }
 
-void SumIntegrator::AssembleFaceMatrix(
-   const FiniteElement &tr_fe,
-   const FiniteElement &te_fe1, const FiniteElement &te_fe2,
-   FaceElementTransformations &Trans, DenseMatrix &elmat)
+void SumIntegrator::AssembleFaceMatrix2(
+   const FiniteElement &tr_fe, const FiniteElement &te_fe1,
+   const FiniteElement &te_fe2, FaceElementTransformations &Trans,
+   DenseMatrix &elmat)
 {
-   MFEM_ASSERT(integrators.Size() > 0, "empty SumIntegrator.");
+   MFEM_ASSERT(bfis.Size() > 0, "empty SumIntegrator.");
 
-   integrators[0]->AssembleFaceMatrix(tr_fe, te_fe1, te_fe2, Trans, elmat);
-   for (int i = 1; i < integrators.Size(); i++)
+   bfis[0]->AssembleFaceMatrix2(tr_fe, te_fe1, te_fe2, Trans, elmat);
+   for (int i = 1; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleFaceMatrix(tr_fe, te_fe1, te_fe2, Trans, elem_mat);
-      elmat += elem_mat;
+      bfis[i]->AssembleFaceMatrix2(tr_fe, te_fe1, te_fe2, Trans, bfi_elmat);
+      elmat += bfi_elmat;
    }
 }
 
 void SumIntegrator::AssemblePA(const FiniteElementSpace& fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssemblePA(fes);
+      bfis[i]->AssemblePA(fes);
    }
 }
 
 void SumIntegrator::AssemblePA(const FiniteElementSpace& trial_fes,
                                const FiniteElementSpace& test_fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssemblePA(trial_fes, test_fes);
+      bfis[i]->AssemblePA(trial_fes, test_fes);
    }
 }
 
 void SumIntegrator::AssembleDiagonalPA(Vector &diag)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleDiagonalPA(diag);
+      bfis[i]->AssembleDiagonalPA(diag);
    }
 }
 
 void SumIntegrator::AssemblePAInteriorFaces(const FiniteElementSpace &fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssemblePAInteriorFaces(fes);
+      bfis[i]->AssemblePAInteriorFaces(fes);
    }
 }
 
 void SumIntegrator::AssemblePABoundaryFaces(const FiniteElementSpace &fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssemblePABoundaryFaces(fes);
+      bfis[i]->AssemblePABoundaryFaces(fes);
    }
 }
 
 void SumIntegrator::AddMultPA(const Vector& x, Vector& y) const
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AddMultPA(x, y);
+      bfis[i]->AddMultPA(x, y);
    }
 }
 
 void SumIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AddMultTransposePA(x, y);
+      bfis[i]->AddMultTransposePA(x, y);
    }
 }
 
 void SumIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleMF(fes);
+      bfis[i]->AssembleMF(fes);
    }
 }
 
 void SumIntegrator::AssembleMF(const FiniteElementSpace& trial_fes,
                                const FiniteElementSpace& test_fes)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleMF(trial_fes, test_fes);
+      bfis[i]->AssembleMF(trial_fes, test_fes);
    }
 }
 
 void SumIntegrator::AssembleDiagonalMF(Vector &diag)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleDiagonalMF(diag);
+      bfis[i]->AssembleDiagonalMF(diag);
    }
 }
 
 void SumIntegrator::AddMultMF(const Vector& x, Vector& y) const
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AddMultTransposeMF(x, y);
+      bfis[i]->AddMultTransposeMF(x, y);
    }
 }
 
 void SumIntegrator::AddMultTransposeMF(const Vector &x, Vector &y) const
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AddMultMF(x, y);
+      bfis[i]->AddMultMF(x, y);
    }
 }
 
 void SumIntegrator::AssembleEA(const FiniteElementSpace &fes, Vector &emat)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleEA(fes, emat);
+      bfis[i]->AssembleEA(fes, emat);
    }
 }
 
@@ -454,32 +445,41 @@ void SumIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                             Vector &ea_data_int,
                                             Vector &ea_data_ext)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleEAInteriorFaces(fes, ea_data_int, ea_data_ext);
+      bfis[i]->AssembleEAInteriorFaces(fes, ea_data_int, ea_data_ext);
    }
 }
 
 void SumIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace &fes,
                                             Vector &ea_data_bdr)
 {
-   for (int i = 0; i < integrators.Size(); i++)
+   for (int i = 0; i < bfis.Size(); i++)
    {
-      integrators[i]->AssembleEABoundaryFaces(fes, ea_data_bdr);
+      bfis[i]->AssembleEABoundaryFaces(fes, ea_data_bdr);
    }
 }
 
 SumIntegrator::~SumIntegrator()
 {
-   if (own_integrators)
+   if (own_bfis)
    {
-      for (int i = 0; i < integrators.Size(); i++)
+      for (int i = 0; i < bfis.Size(); i++)
       {
-         delete integrators[i];
+         delete bfis[i];
       }
    }
 }
 
+const IntegrationRule &MixedScalarIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void MixedScalarIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -507,12 +507,8 @@ void MixedScalarIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int ir_order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
-      ir = &IntRules.Get(trial_fe.GetGeomType(), ir_order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -539,6 +535,15 @@ void MixedScalarIntegrator::AssembleElementMatrix2(
 #endif
 }
 
+const IntegrationRule &MixedVectorIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void MixedVectorIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -598,12 +603,8 @@ void MixedVectorIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int ir_order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
-      ir = &IntRules.Get(trial_fe.GetGeomType(), ir_order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -713,6 +714,15 @@ void MixedVectorIntegrator::AssembleElementMatrix2(
 #endif
 }
 
+const IntegrationRule &MixedScalarVectorIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void MixedScalarVectorIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -754,12 +764,8 @@ void MixedScalarVectorIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int ir_order = this->GetIntegrationOrder(trial_fe, test_fe, Trans);
-      ir = &IntRules.Get(trial_fe.GetGeomType(), ir_order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -787,6 +793,15 @@ void MixedScalarVectorIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &GradientIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void GradientIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans,  DenseMatrix &elmat)
@@ -843,18 +858,30 @@ void GradientIntegrator::AssembleElementMatrix2(
    }
 }
 
-const IntegrationRule &GradientIntegrator::GetRule(
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
+const IntegrationRule &DiffusionIntegrator::GetRuleStatic(
+   const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans)
 {
-   int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
+   int order;
+   if (trial_fe.Space() == FunctionSpace::Pk)
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() - 2;
+   }
+   else
+   {
+      // order = 2 * el.GetOrder() - 2;  // <-- this seems to work fine too
+      order = trial_fe.GetOrder() + test_fe.GetOrder() + trial_fe.GetDim() - 1;
+   }
+   if (trial_fe.Space() == FunctionSpace::rQk)
+   {
+      return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
+   }
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-void DiffusionIntegrator::AssembleElementMatrix(
-   const FiniteElement &el, ElementTransformation &Trans,
-   DenseMatrix &elmat)
+void DiffusionIntegrator::AssembleElementMatrix(const FiniteElement &el,
+                                                ElementTransformation &Trans,
+                                                DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    dim = el.GetDim();
@@ -889,7 +916,7 @@ void DiffusionIntegrator::AssembleElementMatrix(
 #endif
    elmat.SetSize(nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -970,7 +997,8 @@ void DiffusionIntegrator::AssembleElementMatrix2(
 #endif
    elmat.SetSize(te_nd, tr_nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1048,7 +1076,7 @@ void DiffusionIntegrator::AssembleElementVector(
 
    elvect.SetSize(nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    elvect = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1094,13 +1122,9 @@ void DiffusionIntegrator::AssembleElementVector(
 }
 
 void DiffusionIntegrator::ComputeElementFlux(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   Vector &u,
-   const FiniteElement &fluxelem,
-   Vector &flux,
-   bool with_coef,
-   const IntegrationRule *ir)
+   const FiniteElement &el, ElementTransformation &Trans,
+   Vector &u, const FiniteElement &fluxelem, Vector &flux,
+   bool with_coef, const IntegrationRule *ir)
 {
    int nd, spaceDim, fnd;
 
@@ -1196,11 +1220,9 @@ void DiffusionIntegrator::ComputeElementFlux(
    }
 }
 
-double DiffusionIntegrator::ComputeFluxEnergy(
-   const FiniteElement &fluxelem,
-   ElementTransformation &Trans,
-   Vector &flux,
-   Vector* d_energy)
+double DiffusionIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
+                                              ElementTransformation &Trans,
+                                              Vector &flux, Vector* d_energy)
 {
    int nd = fluxelem.GetDof();
    dim = fluxelem.GetDim();
@@ -1218,7 +1240,7 @@ double DiffusionIntegrator::ComputeFluxEnergy(
    if (d_energy) { vec.SetSize(spaceDim); }
    if (MQ) { M.SetSize(spaceDim); }
 
-   int order = 2 * fluxelem.GetOrder(); // <--
+   int order = 2 * fluxelem.GetOrder();
    const IntegrationRule *ir = &IntRules.Get(fluxelem.GetGeomType(), order);
 
    double energy = 0.0;
@@ -1274,20 +1296,13 @@ double DiffusionIntegrator::ComputeFluxEnergy(
    return energy;
 }
 
-const IntegrationRule &DiffusionIntegrator::GetRule(
+const IntegrationRule &MassIntegrator::GetRuleStatic(
    const FiniteElement &trial_fe,
-   const FiniteElement &test_fe)
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans,
+   int Q_order)
 {
-   int order;
-   if (trial_fe.Space() == FunctionSpace::Pk)
-   {
-      order = trial_fe.GetOrder() + test_fe.GetOrder() - 2;
-   }
-   else
-   {
-      // order = 2*el.GetOrder() - 2;  // <-- this seems to work fine too
-      order = trial_fe.GetOrder() + test_fe.GetOrder() + trial_fe.GetDim() - 1;
-   }
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() + Q_order;
    if (trial_fe.Space() == FunctionSpace::rQk)
    {
       return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
@@ -1295,22 +1310,20 @@ const IntegrationRule &DiffusionIntegrator::GetRule(
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-void MassIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+void MassIntegrator::AssembleElementMatrix(const FiniteElement &el,
+                                           ElementTransformation &Trans,
+                                           DenseMatrix &elmat)
 {
    int nd = el.GetDof();
-   // int dim = el.GetDim();
    double w;
 
 #ifdef MFEM_THREAD_SAFE
    Vector shape;
 #endif
-   shape.SetSize(nd);
    elmat.SetSize(nd);
+   shape.SetSize(nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, Trans);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1345,8 +1358,8 @@ void MassIntegrator::AssembleElementMatrix2(
    shape.SetSize(tr_nd);
    te_shape.SetSize(te_nd);
 
-   const IntegrationRule *ir = IntRule ? IntRule :
-                               &GetRule(trial_fe, test_fe, Trans);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1367,18 +1380,13 @@ void MassIntegrator::AssembleElementMatrix2(
    }
 }
 
-const IntegrationRule &MassIntegrator::GetRule(const FiniteElement &trial_fe,
-                                               const FiniteElement &test_fe,
-                                               ElementTransformation &Trans)
+const IntegrationRule &BoundaryMassIntegrator::GetRule(
+   const FiniteElement &el1,
+   const FiniteElement &el2,
+   FaceElementTransformations &Trans) const
 {
-   // int order = trial_fe.GetOrder() + test_fe.GetOrder();
-   const int order = trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW();
-
-   if (trial_fe.Space() == FunctionSpace::rQk)
-   {
-      return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
-   }
-   return IntRules.Get(trial_fe.GetGeomType(), order);
+   int order = el1.GetOrder() + el2.GetOrder();
+   return IntRules.Get(Trans.GetGeometryType(), order);
 }
 
 void BoundaryMassIntegrator::AssembleFaceMatrix(
@@ -1397,13 +1405,7 @@ void BoundaryMassIntegrator::AssembleFaceMatrix(
    elmat.SetSize(nd1);
    shape.SetSize(nd1);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * el1.GetOrder();
-
-      ir = &IntRules.Get(Trans.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -1427,6 +1429,15 @@ void BoundaryMassIntegrator::AssembleFaceMatrix(
    }
 }
 
+const IntegrationRule &ConvectionIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = Trans.OrderGrad(&trial_fe) + Trans.Order() + test_fe.GetOrder();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void ConvectionIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
@@ -1446,12 +1457,7 @@ void ConvectionIntegrator::AssembleElementMatrix(
 
    Vector vec1;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = Trans.OrderGrad(&el) + Trans.Order() + el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    Q->Eval(Q_ir, Trans, *ir);
 
@@ -1474,18 +1480,8 @@ void ConvectionIntegrator::AssembleElementMatrix(
    }
 }
 
-const IntegrationRule &ConvectionIntegrator::GetRule(
-   const FiniteElement &fe,
-   ElementTransformation &Trans)
-{
-   int order = Trans.OrderGrad(&fe) + Trans.Order() + fe.GetOrder();
-   return IntRules.Get(fe.GetGeomType(), order);
-}
-
 void GroupConvectionIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+   const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    int dim = el.GetDim();
@@ -1496,12 +1492,7 @@ void GroupConvectionIntegrator::AssembleElementMatrix(
    shape.SetSize(nd);
    grad.SetSize(nd,dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = Trans.OrderGrad(&el) + el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    Q->Eval(Q_nodal, Trans, el.GetNodes()); // sets the size of Q_nodal
 
@@ -1536,10 +1527,9 @@ void GroupConvectionIntegrator::AssembleElementMatrix(
    }
 }
 
-void VectorMassIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+void VectorMassIntegrator::AssembleElementMatrix(const FiniteElement &el,
+                                                 ElementTransformation &Trans,
+                                                 DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    int spaceDim = Trans.GetSpaceDim();
@@ -1561,20 +1551,7 @@ void VectorMassIntegrator::AssembleElementMatrix(
       mcoeff.SetSize(vdim);
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * el.GetOrder() + Trans.OrderW() + Q_order;
-
-      if (el.Space() == FunctionSpace::rQk)
-      {
-         ir = &RefinedIntRules.Get(el.GetGeomType(), order);
-      }
-      else
-      {
-         ir = &IntRules.Get(el.GetGeomType(), order);
-      }
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int s = 0; s < ir->GetNPoints(); s++)
@@ -1644,21 +1621,8 @@ void VectorMassIntegrator::AssembleElementMatrix2(
       mcoeff.SetSize(vdim);
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = (trial_fe.GetOrder() + test_fe.GetOrder() +
-                   Trans.OrderW() + Q_order);
-
-      if (trial_fe.Space() == FunctionSpace::rQk)
-      {
-         ir = &RefinedIntRules.Get(trial_fe.GetGeomType(), order);
-      }
-      else
-      {
-         ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-      }
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int s = 0; s < ir->GetNPoints(); s++)
@@ -1704,6 +1668,179 @@ void VectorMassIntegrator::AssembleElementMatrix2(
    }
 }
 
+void VectorDiffusionIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
+{
+   const int dof = el.GetDof();
+   dim = el.GetDim();
+   sdim = Trans.GetSpaceDim();
+
+   // If vdim is not set, set it to the space dimension;
+   vdim = (vdim <= 0) ? sdim : vdim;
+   const bool square = (dim == sdim);
+
+   if (VQ)
+   {
+      vcoeff.SetSize(vdim);
+   }
+   else if (MQ)
+   {
+      mcoeff.SetSize(vdim);
+   }
+
+   dshape.SetSize(dof, dim);
+   dshapedxt.SetSize(dof, sdim);
+
+   elmat.SetSize(vdim * dof);
+   pelmat.SetSize(dof);
+
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
+
+   elmat = 0.0;
+
+   for (int i = 0; i < ir->GetNPoints(); i++)
+   {
+
+      const IntegrationPoint &ip = ir->IntPoint(i);
+      el.CalcDShape(ip, dshape);
+
+      Trans.SetIntPoint(&ip);
+      double w = Trans.Weight();
+      w = ip.weight / (square ? w : w*w*w);
+      // AdjugateJacobian = / adj(J),         if J is square
+      //                    \ adj(J^t.J).J^t, otherwise
+      Mult(dshape, Trans.AdjugateJacobian(), dshapedxt);
+
+      if (VQ)
+      {
+         VQ->Eval(vcoeff, Trans, ip);
+         for (int k = 0; k < vdim; ++k)
+         {
+            Mult_a_AAt(w*vcoeff(k), dshapedxt, pelmat);
+            elmat.AddMatrix(pelmat, dof*k, dof*k);
+         }
+      }
+      else if (MQ)
+      {
+         MQ->Eval(mcoeff, Trans, ip);
+         for (int ii = 0; ii < vdim; ++ii)
+         {
+            for (int jj = 0; jj < vdim; ++jj)
+            {
+               Mult_a_AAt(w*mcoeff(ii,jj), dshapedxt, pelmat);
+               elmat.AddMatrix(pelmat, dof*ii, dof*jj);
+            }
+         }
+      }
+      else
+      {
+         if (Q) { w *= Q->Eval(Trans, ip); }
+         Mult_a_AAt(w, dshapedxt, pelmat);
+         for (int k = 0; k < vdim; ++k)
+         {
+            elmat.AddMatrix(pelmat, dof*k, dof*k);
+         }
+      }
+   }
+}
+
+void VectorDiffusionIntegrator::AssembleElementVector(
+   const FiniteElement &el, ElementTransformation &Tr,
+   const Vector &elfun, Vector &elvect)
+{
+   const int dof = el.GetDof();
+   dim = el.GetDim();
+   sdim = Tr.GetSpaceDim();
+
+   // If vdim is not set, set it to the space dimension;
+   vdim = (vdim <= 0) ? sdim : vdim;
+   const bool square = (dim == sdim);
+
+   if (VQ)
+   {
+      vcoeff.SetSize(vdim);
+   }
+   else if (MQ)
+   {
+      mcoeff.SetSize(vdim);
+   }
+
+   dshape.SetSize(dof, dim);
+   dshapedxt.SetSize(dof, dim);
+   // pelmat.SetSize(dim);
+
+   elvect.SetSize(dim*dof);
+
+   // NOTE: DenseMatrix is in column-major order. This is consistent with
+   // vectors ordered byNODES. In the resulting DenseMatrix, each column
+   // corresponds to a particular vdim.
+   DenseMatrix mat_in(elfun.GetData(), dof, dim);
+   DenseMatrix mat_out(elvect.GetData(), dof, dim);
+
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
+
+   elvect = 0.0;
+   for (int i = 0; i < ir->GetNPoints(); i++)
+   {
+      const IntegrationPoint &ip = ir->IntPoint(i);
+      el.CalcDShape(ip, dshape);
+
+      Tr.SetIntPoint(&ip);
+      double w = Tr.Weight();
+      w = ip.weight / (square ? w : w*w*w);
+      Mult(dshape, Tr.AdjugateJacobian(), dshapedxt);
+      MultAAt(dshapedxt, pelmat);
+
+      if (VQ)
+      {
+         VQ->Eval(vcoeff, Tr, ip);
+         for (int k = 0; k < vdim; ++k)
+         {
+            pelmat *= w*vcoeff(k);
+            const Vector vec_in(mat_in.GetColumn(k), dof);
+            Vector vec_out(mat_out.GetColumn(k), dof);
+            pelmat.AddMult(vec_in, vec_out);
+         }
+      }
+      else if (MQ)
+      {
+         MQ->Eval(mcoeff, Tr, ip);
+         for (int ii = 0; ii < vdim; ++ii)
+         {
+            Vector vec_out(mat_out.GetColumn(ii), dof);
+            for (int jj = 0; jj < vdim; ++jj)
+            {
+               pelmat *= w*mcoeff(ii,jj);
+               const Vector vec_in(mat_in.GetColumn(jj), dof);
+               pelmat.Mult(vec_in, vec_out);
+            }
+         }
+      }
+      else
+      {
+         if (Q) { w *= Q->Eval(Tr, ip); }
+         pelmat *= w;
+         for (int k = 0; k < vdim; ++k)
+         {
+            const Vector vec_in(mat_in.GetColumn(k), dof);
+            Vector vec_out(mat_out.GetColumn(k), dof);
+            pelmat.AddMult(vec_in, vec_out);
+         }
+      }
+   }
+}
+
+const IntegrationRule &VectorFEDivergenceIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorFEDivergenceIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -1719,12 +1856,8 @@ void VectorFEDivergenceIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = trial_fe.GetOrder() + test_fe.GetOrder() - 1; // <--
-      ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -1744,6 +1877,46 @@ void VectorFEDivergenceIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &VectorFEWeakDivergenceIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   // The integrand on the reference element is:
+   //    -( Q/det(J) ) u_hat^T adj(J) adj(J)^T grad_hat(v_hat).
+   //
+   // For Trans in (P_k)^d, v_hat in P_l, u_hat in ND_m, and dim=sdim=d>=1
+   // - J_{ij} is in P_{k-1}, so adj(J)_{ij} is in P_{(d-1)*(k-1)}
+   // - so adj(J)^T grad_hat(v_hat) is in (P_{(d-1)*(k-1)+(l-1)})^d
+   // - u_hat is in (P_m)^d
+   // - adj(J)^T u_hat is in (P_{(d-1)*(k-1)+m})^d
+   // - and u_hat^T adj(J) adj(J)^T grad_hat(v_hat) is in P_n with
+   //   n = 2*(d-1)*(k-1)+(l-1)+m
+   //
+   // For Trans in (Q_k)^d, v_hat in Q_l, u_hat in ND_m, and dim=sdim=d>1
+   // - J_{i*}, J's i-th row, is in ( Q_{k-1,k,k}, Q_{k,k-1,k}, Q_{k,k,k-1} )
+   // - adj(J)_{*j} is in ( Q_{s,s-1,s-1}, Q_{s-1,s,s-1}, Q_{s-1,s-1,s} )
+   //   with s = (d-1)*k
+   // - adj(J)^T grad_hat(v_hat) is in Q_{(d-1)*k+(l-1)}
+   // - u_hat is in ( Q_{m-1,m,m}, Q_{m,m-1,m}, Q_{m,m,m-1} )
+   // - adj(J)^T u_hat is in Q_{(d-1)*k+(m-1)}
+   // - and u_hat^T adj(J) adj(J)^T grad_hat(v_hat) is in Q_n with
+   //   n = 2*(d-1)*k+(l-1)+(m-1)
+   //
+   // In the next formula we use the expressions for n with k=1, which means
+   // that the term Q/det(J) is disregarded:
+   int order;
+   if (trial_fe.Space() == FunctionSpace::Pk)
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
+   }
+   else
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() + 2 * (trial_fe.GetDim() - 2);
+   }
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorFEWeakDivergenceIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -1770,37 +1943,8 @@ void VectorFEWeakDivergenceIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // The integrand on the reference element is:
-      //    -( Q/det(J) ) u_hat^T adj(J) adj(J)^T grad_hat(v_hat).
-      //
-      // For Trans in (P_k)^d, v_hat in P_l, u_hat in ND_m, and dim=sdim=d>=1
-      // - J_{ij} is in P_{k-1}, so adj(J)_{ij} is in P_{(d-1)*(k-1)}
-      // - so adj(J)^T grad_hat(v_hat) is in (P_{(d-1)*(k-1)+(l-1)})^d
-      // - u_hat is in (P_m)^d
-      // - adj(J)^T u_hat is in (P_{(d-1)*(k-1)+m})^d
-      // - and u_hat^T adj(J) adj(J)^T grad_hat(v_hat) is in P_n with
-      //   n = 2*(d-1)*(k-1)+(l-1)+m
-      //
-      // For Trans in (Q_k)^d, v_hat in Q_l, u_hat in ND_m, and dim=sdim=d>1
-      // - J_{i*}, J's i-th row, is in ( Q_{k-1,k,k}, Q_{k,k-1,k}, Q_{k,k,k-1} )
-      // - adj(J)_{*j} is in ( Q_{s,s-1,s-1}, Q_{s-1,s,s-1}, Q_{s-1,s-1,s} )
-      //   with s = (d-1)*k
-      // - adj(J)^T grad_hat(v_hat) is in Q_{(d-1)*k+(l-1)}
-      // - u_hat is in ( Q_{m-1,m,m}, Q_{m,m-1,m}, Q_{m,m,m-1} )
-      // - adj(J)^T u_hat is in Q_{(d-1)*k+(m-1)}
-      // - and u_hat^T adj(J) adj(J)^T grad_hat(v_hat) is in Q_n with
-      //   n = 2*(d-1)*k+(l-1)+(m-1)
-      //
-      // In the next formula we use the expressions for n with k=1, which means
-      // that the term Q/det(J) is disregarded:
-      int ir_order = (trial_fe.Space() == FunctionSpace::Pk) ?
-                     (trial_fe.GetOrder() + test_fe.GetOrder() - 1) :
-                     (trial_fe.GetOrder() + test_fe.GetOrder() + 2*(dim-2));
-      ir = &IntRules.Get(trial_fe.GetGeomType(), ir_order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -1826,6 +1970,15 @@ void VectorFEWeakDivergenceIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &VectorFECurlIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorFECurlIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -1863,12 +2016,8 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
 
    elmat.SetSize(test_nd, trial_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = trial_fe.GetOrder() + test_fe.GetOrder() - 1; // <--
-      ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -1923,6 +2072,27 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &DerivativeIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order;
+   if (trial_fe.Space() == FunctionSpace::Pk)
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
+   }
+   else
+   {
+      order = trial_fe.GetOrder() + test_fe.GetOrder() + trial_fe.GetDim();
+   }
+   if (trial_fe.Space() == FunctionSpace::rQk)
+   {
+      return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
+   }
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void DerivativeIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe,
    const FiniteElement &test_fe,
@@ -1944,28 +2114,8 @@ void DerivativeIntegrator::AssembleElementMatrix2(
    invdfdx.SetSize(dim, spaceDim);
    shape.SetSize(test_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      if (trial_fe.Space() == FunctionSpace::Pk)
-      {
-         order = trial_fe.GetOrder() + test_fe.GetOrder() - 1;
-      }
-      else
-      {
-         order = trial_fe.GetOrder() + test_fe.GetOrder() + dim;
-      }
-
-      if (trial_fe.Space() == FunctionSpace::rQk)
-      {
-         ir = &RefinedIntRules.Get(trial_fe.GetGeomType(), order);
-      }
-      else
-      {
-         ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-      }
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (i = 0; i < ir->GetNPoints(); i++)
@@ -1991,10 +2141,26 @@ void DerivativeIntegrator::AssembleElementMatrix2(
    }
 }
 
-void CurlCurlIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+const IntegrationRule &CurlCurlIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order;
+   if (trial_fe.Space() == FunctionSpace::Pk)
+   {
+      order = test_fe.GetOrder() + trial_fe.GetOrder() - 2;
+   }
+   else
+   {
+      order = test_fe.GetOrder() + trial_fe.GetOrder() + trial_fe.GetDim() - 1;
+   }
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
+void CurlCurlIntegrator::AssembleElementMatrix(const FiniteElement &el,
+                                               ElementTransformation &Trans,
+                                               DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    dim = el.GetDim();
@@ -2009,25 +2175,10 @@ void CurlCurlIntegrator::AssembleElementMatrix(
    curlshape_dFt.SetSize(nd,dimc);
 #endif
    elmat.SetSize(nd);
-
    if (MQ) { M.SetSize(dimc); }
    if (DQ) { D.SetSize(dimc); }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      if (el.Space() == FunctionSpace::Pk)
-      {
-         order = 2*el.GetOrder() - 2;
-      }
-      else
-      {
-         order = 2*el.GetOrder();
-      }
-
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2090,20 +2241,8 @@ void CurlCurlIntegrator::AssembleElementMatrix2(const FiniteElement &trial_fe,
    if (MQ) { M.SetSize(dimc); }
    if (DQ) { D.SetSize(dimc); }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      if (trial_fe.Space() == FunctionSpace::Pk)
-      {
-         order = test_fe.GetOrder() + trial_fe.GetOrder() - 2;
-      }
-      else
-      {
-         order = test_fe.GetOrder() + trial_fe.GetOrder() + trial_fe.GetDim() - 1;
-      }
-      ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2174,7 +2313,7 @@ double CurlCurlIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
    pointflux.SetSize(dim);
    if (d_energy) { vec.SetSize(dim); }
 
-   int order = 2 * fluxelem.GetOrder(); // <--
+   int order = 2 * fluxelem.GetOrder();
    const IntegrationRule &ir = IntRules.Get(fluxelem.GetGeomType(), order);
 
    double energy = 0.0;
@@ -2265,10 +2404,18 @@ double CurlCurlIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
    return energy;
 }
 
+const IntegrationRule &VectorCurlCurlIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   // Use the same integration rule as diffusion
+   int order = Trans.OrderGrad(&trial_fe) + Trans.OrderGrad(&test_fe);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorCurlCurlIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
+   const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
    int dim = el.GetDim();
    int dof = el.GetDof();
@@ -2284,13 +2431,7 @@ void VectorCurlCurlIntegrator::AssembleElementMatrix(
    Jadj.SetSize(dim);
 #endif
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // use the same integration rule as diffusion
-      int order = 2 * Trans.OrderGrad(&el);
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat.SetSize(dof*dim);
    elmat = 0.0;
@@ -2332,13 +2473,7 @@ double VectorCurlCurlIntegrator::GetElementEnergy(
 #endif
    DenseMatrix elfun_mat(elfun.GetData(), dof, dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // use the same integration rule as diffusion
-      int order = 2 * Tr.OrderGrad(&el);
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    double energy = 0.;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2380,6 +2515,15 @@ double VectorCurlCurlIntegrator::GetElementEnergy(
    return 0.5 * energy;
 }
 
+const IntegrationRule &MixedCurlIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderJ();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void MixedCurlIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
@@ -2415,13 +2559,9 @@ void MixedCurlIntegrator::AssembleElementMatrix2(
 
    double c;
    Vector d_col;
-   const IntegrationRule *ir = IntRule;
 
-   if (ir == NULL)
-   {
-      int order = trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderJ();
-      ir = &IntRules.Get(trial_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -2458,6 +2598,15 @@ void MixedCurlIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &VectorFEMassIntegrator::GetRuleStatic(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans)
+{
+   int order = Trans.OrderW() + test_fe.GetOrder() + trial_fe.GetOrder();
+   return IntRules.Get(test_fe.GetGeomType(), order);
+}
+
 void VectorFEMassIntegrator::AssembleElementMatrix(
    const FiniteElement &el,
    ElementTransformation &Trans,
@@ -2483,13 +2632,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix(
    elmat.SetSize(dof);
    elmat = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // int order = 2 * el.GetOrder();
-      int order = Trans.OrderW() + 2 * el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -2517,7 +2660,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix(
       {
          if (Q)
          {
-            w *= Q->Eval (Trans, ip);
+            w *= Q->Eval(Trans, ip);
          }
          AddMult_a_AAt(w, trial_vshape, elmat);
       }
@@ -2551,15 +2694,11 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
 #endif
 
       elmat.SetSize(vdim*test_dof, trial_dof);
+      elmat = 0.0;
 
-      const IntegrationRule *ir = IntRule;
-      if (ir == NULL)
-      {
-         int order = (Trans.OrderW() + test_fe.GetOrder() + trial_fe.GetOrder());
-         ir = &IntRules.Get(test_fe.GetGeomType(), order);
-      }
+      const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                               Trans);
 
-      elmat = 0.0;
       for (int i = 0; i < ir->GetNPoints(); i++)
       {
          const IntegrationPoint &ip = ir->IntPoint(i);
@@ -2652,12 +2791,8 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
 
       elmat.SetSize(test_dof, trial_dof);
 
-      const IntegrationRule *ir = IntRule;
-      if (ir == NULL)
-      {
-         int order = (Trans.OrderW() + test_fe.GetOrder() + trial_fe.GetOrder());
-         ir = &IntRules.Get(test_fe.GetGeomType(), order);
-      }
+      const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                               Trans);
 
       elmat = 0.0;
       for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2687,7 +2822,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
          {
             if (Q)
             {
-               w *= Q->Eval (Trans, ip);
+               w *= Q->Eval(Trans, ip);
             }
             AddMult_a_ABt(w,test_vshape,trial_vshape,elmat);
          }
@@ -2700,6 +2835,15 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
    }
 }
 
+const IntegrationRule &VectorDivergenceIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
+
 void VectorDivergenceIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe,
    const FiniteElement &test_fe,
@@ -2741,7 +2885,7 @@ void VectorDivergenceIntegrator::AssembleElementMatrix2(
       c = ip.weight;
       if (Q)
       {
-         c *= Q->Eval (Trans, ip);
+         c *= Q->Eval(Trans, ip);
       }
 
       // elmat += c * shape * divshape ^ t
@@ -2750,12 +2894,13 @@ void VectorDivergenceIntegrator::AssembleElementMatrix2(
    }
 }
 
-const IntegrationRule &VectorDivergenceIntegrator::GetRule(
+const IntegrationRule &DivDivIntegrator::GetRule(
    const FiniteElement &trial_fe,
    const FiniteElement &test_fe,
-   ElementTransformation &Trans)
+   ElementTransformation &Trans) const
 {
-   int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
+   int order = 2 * max(trial_fe.GetOrder(),
+                       test_fe.GetOrder()) - 2; // <--- OK for RTk
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
@@ -2774,12 +2919,7 @@ void DivDivIntegrator::AssembleElementMatrix(
 #endif
    elmat.SetSize(dof);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * el.GetOrder() - 2; // <--- OK for RTk
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2793,7 +2933,7 @@ void DivDivIntegrator::AssembleElementMatrix(
 
       if (Q)
       {
-         c *= Q->Eval (Trans, ip);
+         c *= Q->Eval(Trans, ip);
       }
 
       // elmat += c * divshape * divshape ^ t
@@ -2820,13 +2960,8 @@ void DivDivIntegrator::AssembleElementMatrix2(
 #endif
    elmat.SetSize(te_nd,tr_nd);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * max(test_fe.GetOrder(),
-                          trial_fe.GetOrder()) - 2; // <--- OK for RTk
-      ir = &IntRules.Get(test_fe.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
+                                                            Trans);
 
    elmat = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -2841,7 +2976,7 @@ void DivDivIntegrator::AssembleElementMatrix2(
 
       if (Q)
       {
-         c *= Q->Eval (Trans, ip);
+         c *= Q->Eval(Trans, ip);
       }
 
       te_divshape *= c;
@@ -2849,176 +2984,13 @@ void DivDivIntegrator::AssembleElementMatrix2(
    }
 }
 
-void VectorDiffusionIntegrator::AssembleElementMatrix(
-   const FiniteElement &el,
-   ElementTransformation &Trans,
-   DenseMatrix &elmat)
-{
-   const int dof = el.GetDof();
-   dim = el.GetDim();
-   sdim = Trans.GetSpaceDim();
-
-   // If vdim is not set, set it to the space dimension;
-   vdim = (vdim <= 0) ? sdim : vdim;
-   const bool square = (dim == sdim);
-
-   if (VQ)
-   {
-      vcoeff.SetSize(vdim);
-   }
-   else if (MQ)
-   {
-      mcoeff.SetSize(vdim);
-   }
-
-   dshape.SetSize(dof, dim);
-   dshapedxt.SetSize(dof, sdim);
-
-   elmat.SetSize(vdim * dof);
-   pelmat.SetSize(dof);
-
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      ir = &DiffusionIntegrator::GetRule(el,el);
-   }
-
-   elmat = 0.0;
-
-   for (int i = 0; i < ir->GetNPoints(); i++)
-   {
-
-      const IntegrationPoint &ip = ir->IntPoint(i);
-      el.CalcDShape(ip, dshape);
-
-      Trans.SetIntPoint(&ip);
-      double w = Trans.Weight();
-      w = ip.weight / (square ? w : w*w*w);
-      // AdjugateJacobian = / adj(J),         if J is square
-      //                    \ adj(J^t.J).J^t, otherwise
-      Mult(dshape, Trans.AdjugateJacobian(), dshapedxt);
-
-      if (VQ)
-      {
-         VQ->Eval(vcoeff, Trans, ip);
-         for (int k = 0; k < vdim; ++k)
-         {
-            Mult_a_AAt(w*vcoeff(k), dshapedxt, pelmat);
-            elmat.AddMatrix(pelmat, dof*k, dof*k);
-         }
-      }
-      else if (MQ)
-      {
-         MQ->Eval(mcoeff, Trans, ip);
-         for (int ii = 0; ii < vdim; ++ii)
-         {
-            for (int jj = 0; jj < vdim; ++jj)
-            {
-               Mult_a_AAt(w*mcoeff(ii,jj), dshapedxt, pelmat);
-               elmat.AddMatrix(pelmat, dof*ii, dof*jj);
-            }
-         }
-      }
-      else
-      {
-         if (Q) { w *= Q->Eval(Trans, ip); }
-         Mult_a_AAt(w, dshapedxt, pelmat);
-         for (int k = 0; k < vdim; ++k)
-         {
-            elmat.AddMatrix(pelmat, dof*k, dof*k);
-         }
-      }
-   }
-}
-
-void VectorDiffusionIntegrator::AssembleElementVector(
-   const FiniteElement &el, ElementTransformation &Tr,
-   const Vector &elfun, Vector &elvect)
+const IntegrationRule &ElasticityIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
 {
-   const int dof = el.GetDof();
-   dim = el.GetDim();
-   sdim = Tr.GetSpaceDim();
-
-   // If vdim is not set, set it to the space dimension;
-   vdim = (vdim <= 0) ? sdim : vdim;
-   const bool square = (dim == sdim);
-
-   if (VQ)
-   {
-      vcoeff.SetSize(vdim);
-   }
-   else if (MQ)
-   {
-      mcoeff.SetSize(vdim);
-   }
-
-   dshape.SetSize(dof, dim);
-   dshapedxt.SetSize(dof, dim);
-   // pelmat.SetSize(dim);
-
-   elvect.SetSize(dim*dof);
-
-   // NOTE: DenseMatrix is in column-major order. This is consistent with
-   // vectors ordered byNODES. In the resulting DenseMatrix, each column
-   // corresponds to a particular vdim.
-   DenseMatrix mat_in(elfun.GetData(), dof, dim);
-   DenseMatrix mat_out(elvect.GetData(), dof, dim);
-
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      ir = &DiffusionIntegrator::GetRule(el,el);
-   }
-
-   elvect = 0.0;
-   for (int i = 0; i < ir->GetNPoints(); i++)
-   {
-      const IntegrationPoint &ip = ir->IntPoint(i);
-      el.CalcDShape(ip, dshape);
-
-      Tr.SetIntPoint(&ip);
-      double w = Tr.Weight();
-      w = ip.weight / (square ? w : w*w*w);
-      Mult(dshape, Tr.AdjugateJacobian(), dshapedxt);
-      MultAAt(dshapedxt, pelmat);
-
-      if (VQ)
-      {
-         VQ->Eval(vcoeff, Tr, ip);
-         for (int k = 0; k < vdim; ++k)
-         {
-            pelmat *= w*vcoeff(k);
-            const Vector vec_in(mat_in.GetColumn(k), dof);
-            Vector vec_out(mat_out.GetColumn(k), dof);
-            pelmat.AddMult(vec_in, vec_out);
-         }
-      }
-      else if (MQ)
-      {
-         MQ->Eval(mcoeff, Tr, ip);
-         for (int ii = 0; ii < vdim; ++ii)
-         {
-            Vector vec_out(mat_out.GetColumn(ii), dof);
-            for (int jj = 0; jj < vdim; ++jj)
-            {
-               pelmat *= w*mcoeff(ii,jj);
-               const Vector vec_in(mat_in.GetColumn(jj), dof);
-               pelmat.Mult(vec_in, vec_out);
-            }
-         }
-      }
-      else
-      {
-         if (Q) { w *= Q->Eval(Tr, ip); }
-         pelmat *= w;
-         for (int k = 0; k < vdim; ++k)
-         {
-            const Vector vec_in(mat_in.GetColumn(k), dof);
-            Vector vec_out(mat_out.GetColumn(k), dof);
-            pelmat.AddMult(vec_in, vec_out);
-         }
-      }
-   }
+   int order = Trans.OrderGrad(&trial_fe) + Trans.OrderGrad(&test_fe);
+   return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
 void ElasticityIntegrator::AssembleElementMatrix(
@@ -3042,12 +3014,7 @@ void ElasticityIntegrator::AssembleElementMatrix(
 
    elmat.SetSize(dof * dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * Trans.OrderGrad(&el); // correct order?
-      ir = &IntRules.Get(el.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
 
    elmat = 0.0;
 
@@ -3210,12 +3177,7 @@ double ElasticityIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
    // Use the same integration rule as in AssembleElementMatrix, replacing 'el'
    // with 'fluxelem' when 'IntRule' is not set.
    // Should we be using a different (more accurate) rule here?
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order = 2 * Trans.OrderGrad(&fluxelem);
-      ir = &IntRules.Get(fluxelem.GetGeomType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fluxelem, Trans);
 
    double energy = 0.0;
 
@@ -3275,6 +3237,28 @@ double ElasticityIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
    return energy;
 }
 
+const IntegrationRule &DGTraceIntegrator::GetRule(
+   const FiniteElement &el1, const FiniteElement &el2,
+   FaceElementTransformations &Trans) const
+{
+   // Assuming order(u) == order(mesh)
+   int order;
+   if (Trans.Elem2No >= 0)
+   {
+      order = (min(Trans.Elem1->OrderW(), Trans.Elem2->OrderW()) +
+               2 * max(el1.GetOrder(), el2.GetOrder()));
+   }
+   else
+   {
+      order = Trans.Elem1->OrderW() + 2 * el1.GetOrder();
+   }
+   if (el1.Space() == FunctionSpace::Pk)
+   {
+      order++;
+   }
+   return IntRules.Get(Trans.GetGeometryType(), order);
+}
+
 void DGTraceIntegrator::AssembleFaceMatrix(const FiniteElement &el1,
                                            const FiniteElement &el2,
                                            FaceElementTransformations &Trans,
@@ -3302,24 +3286,7 @@ void DGTraceIntegrator::AssembleFaceMatrix(const FiniteElement &el1,
    elmat.SetSize(ndof1 + ndof2);
    elmat = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      // Assuming order(u)==order(mesh)
-      if (Trans.Elem2No >= 0)
-         order = (min(Trans.Elem1->OrderW(), Trans.Elem2->OrderW()) +
-                  2*max(el1.GetOrder(), el2.GetOrder()));
-      else
-      {
-         order = Trans.Elem1->OrderW() + 2*el1.GetOrder();
-      }
-      if (el1.Space() == FunctionSpace::Pk)
-      {
-         order++;
-      }
-      ir = &IntRules.Get(Trans.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, el2, Trans);
 
    for (int p = 0; p < ir->GetNPoints(); p++)
    {
@@ -3408,11 +3375,21 @@ void DGTraceIntegrator::AssembleFaceMatrix(const FiniteElement &el1,
    }
 }
 
-const IntegrationRule &DGTraceIntegrator::GetRule(
-   Geometry::Type geom, int order, FaceElementTransformations &T)
+const IntegrationRule &DGDiffusionIntegrator::GetRuleStatic(
+   const FiniteElement &el1, const FiniteElement &el2,
+   FaceElementTransformations &Trans)
 {
-   int int_order = T.Elem1->OrderW() + 2*order;
-   return IntRules.Get(geom, int_order);
+   // A simple choice for the integration order; is this OK?
+   int order;
+   if (Trans.Elem2No >= 0)
+   {
+      order = 2 * max(el1.GetOrder(), el2.GetOrder());
+   }
+   else
+   {
+      order = 2 * el1.GetOrder();
+   }
+   return IntRules.Get(Trans.GetGeometryType(), order);
 }
 
 void DGDiffusionIntegrator::AssembleFaceMatrix(
@@ -3459,21 +3436,7 @@ void DGDiffusionIntegrator::AssembleFaceMatrix(
       jmat = 0.;
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // a simple choice for the integration order; is this OK?
-      int order;
-      if (ndof2)
-      {
-         order = 2*max(el1.GetOrder(), el2.GetOrder());
-      }
-      else
-      {
-         order = 2*el1.GetOrder();
-      }
-      ir = &IntRules.Get(Trans.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, el2, Trans);
 
    // assemble: < {(Q \nabla u).n},[v] >      --> elmat
    //           kappa < {h^{-1} Q} [u],[v] >  --> jmat
@@ -3749,13 +3712,7 @@ void DGElasticityIntegrator::AssembleFaceMatrix(
       dshape2_dnM.SetSize(ndofs2);
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // a simple choice for the integration order; is this OK?
-      const int order = 2 * max(el1.GetOrder(), ndofs2 ? el2.GetOrder() : 0);
-      ir = &IntRules.Get(Trans.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, el2, Trans);
 
    for (int pind = 0; pind < ir->GetNPoints(); ++pind)
    {
@@ -3872,7 +3829,7 @@ void DGElasticityIntegrator::AssembleFaceMatrix(
    }
 }
 
-void TraceJumpIntegrator::AssembleFaceMatrix(
+void TraceJumpIntegrator::AssembleFaceMatrix2(
    const FiniteElement &trial_face_fe, const FiniteElement &test_fe1,
    const FiniteElement &test_fe2, FaceElementTransformations &Trans,
    DenseMatrix &elmat)
@@ -3964,7 +3921,7 @@ void TraceJumpIntegrator::AssembleFaceMatrix(
    }
 }
 
-void NormalTraceJumpIntegrator::AssembleFaceMatrix(
+void NormalTraceJumpIntegrator::AssembleFaceMatrix2(
    const FiniteElement &trial_face_fe, const FiniteElement &test_fe1,
    const FiniteElement &test_fe2, FaceElementTransformations &Trans,
    DenseMatrix &elmat)
@@ -4312,11 +4269,11 @@ struct ShapeCoefficient : public VectorCoefficient
 
 }
 
-void
-ScalarProductInterpolator::AssembleElementMatrix2(const FiniteElement &dom_fe,
-                                                  const FiniteElement &ran_fe,
-                                                  ElementTransformation &Trans,
-                                                  DenseMatrix &elmat)
+void ScalarProductInterpolator::AssembleElementMatrix2(
+   const FiniteElement &dom_fe,
+   const FiniteElement &ran_fe,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    internal::ShapeCoefficient dom_shape_coeff(*Q, dom_fe);
 
@@ -4327,8 +4284,7 @@ ScalarProductInterpolator::AssembleElementMatrix2(const FiniteElement &dom_fe,
    ran_fe.Project(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-void
-ScalarVectorProductInterpolator::AssembleElementMatrix2(
+void ScalarVectorProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
@@ -4361,8 +4317,7 @@ ScalarVectorProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-void
-VectorScalarProductInterpolator::AssembleElementMatrix2(
+void VectorScalarProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
@@ -4398,8 +4353,7 @@ VectorScalarProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-void
-ScalarCrossProductInterpolator::AssembleElementMatrix2(
+void ScalarCrossProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
@@ -4440,8 +4394,7 @@ ScalarCrossProductInterpolator::AssembleElementMatrix2(
    ran_fe.Project(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-void
-VectorCrossProductInterpolator::AssembleElementMatrix2(
+void VectorCrossProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
diff --git a/fem/bilininteg.hpp b/fem/bilininteg.hpp
index 209898714..dd6c7625c 100644
--- a/fem/bilininteg.hpp
+++ b/fem/bilininteg.hpp
@@ -41,10 +41,6 @@ public:
    // TODO: add support for other assembly levels (in addition to PA) and their
    // actions.
 
-   // TODO: for mixed meshes the quadrature rules to be used by methods like
-   // AssemblePA() can be given as a QuadratureSpace, e.g. using a new method:
-   // SetQuadratureSpace().
-
    // TODO: the methods for the various assembly levels make sense even in the
    // base class NonlinearFormIntegrator, except that not all assembly levels
    // make sense for the action of the nonlinear operator (but they all make
@@ -159,11 +155,11 @@ public:
 
    /** Abstract method used for assembling TraceFaceIntegrators in a
        MixedBilinearForm. */
-   virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
-                                   const FiniteElement &test_fe1,
-                                   const FiniteElement &test_fe2,
-                                   FaceElementTransformations &Trans,
-                                   DenseMatrix &elmat);
+   virtual void AssembleFaceMatrix2(const FiniteElement &trial_face_fe,
+                                    const FiniteElement &test_fe1,
+                                    const FiniteElement &test_fe2,
+                                    FaceElementTransformations &Trans,
+                                    DenseMatrix &elmat);
 
    /** Abstract method used for assembling TraceFaceIntegrators for
        DPG weak formulations. */
@@ -173,7 +169,6 @@ public:
                                         FaceElementTransformations &Trans,
                                         DenseMatrix &elmat);
 
-
    /// @brief Perform the local action of the BilinearFormIntegrator.
    /// Note that the default implementation in the base class is general but not
    /// efficient.
@@ -282,7 +277,12 @@ public:
    TransposeIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
    { bfi = bfi_; own_bfi = own_bfi_; }
 
-   virtual void SetIntRule(const IntegrationRule *ir);
+   virtual bool SupportsCeed() const { return bfi->SupportsCeed(); }
+
+   virtual void SetIntRule(const IntegrationRule *ir)
+   {
+      IntRule = ir; bfi->SetIntRule(ir);
+   }
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
@@ -293,7 +293,6 @@ public:
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -362,7 +361,12 @@ public:
    LumpedIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
    { bfi = bfi_; own_bfi = own_bfi_; }
 
-   virtual void SetIntRule(const IntegrationRule *ir);
+   virtual bool SupportsCeed() const { return bfi->SupportsCeed(); }
+
+   virtual void SetIntRule(const IntegrationRule *ir)
+   {
+      IntRule = ir; bfi->SetIntRule(ir);
+   }
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
@@ -375,57 +379,64 @@ public:
 class InverseIntegrator : public BilinearFormIntegrator
 {
 private:
-   bool own_integrator;
-   BilinearFormIntegrator *integrator;
+   bool own_bfi;
+   BilinearFormIntegrator *bfi;
 
 public:
-   InverseIntegrator(BilinearFormIntegrator *integ, bool own_integ = 1)
-   { integrator = integ; own_integrator = own_integ; }
+   InverseIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
+   { bfi = bfi_; own_bfi = own_bfi_; }
 
-   virtual void SetIntRule(const IntegrationRule *ir);
+   virtual bool SupportsCeed() const { return bfi->SupportsCeed(); }
+
+   virtual void SetIntRule(const IntegrationRule *ir)
+   {
+      IntRule = ir; bfi->SetIntRule(ir);
+   }
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
 
-   virtual ~InverseIntegrator() { if (own_integrator) { delete integrator; } }
+   virtual ~InverseIntegrator() { if (own_bfi) { delete bfi; } }
 };
 
 /// Integrator defining a sum of multiple Integrators.
 class SumIntegrator : public BilinearFormIntegrator
 {
 private:
-   bool own_integrators;
-   mutable DenseMatrix elem_mat;
-   Array<BilinearFormIntegrator*> integrators;
+   bool own_bfis;
+   Array<BilinearFormIntegrator*> bfis;
+   DenseMatrix bfi_elmat;
 
 public:
-   SumIntegrator(bool own_integs = true) { own_integrators = own_integs; }
+   SumIntegrator(bool own_bfis_ = true) { own_bfis = own_bfis_; }
 
-   virtual void SetIntRule(const IntegrationRule *ir);
+   void AddIntegrator(BilinearFormIntegrator *bfi)
+   { bfis.Append(bfi); }
+
+   virtual bool SupportsCeed() const;
 
-   void AddIntegrator(BilinearFormIntegrator *integ)
-   { integrators.Append(integ); }
+   virtual void SetIntRule(const IntegrationRule *ir);
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
-                                   const FiniteElement &test_fe1,
-                                   const FiniteElement &test_fe2,
-                                   FaceElementTransformations &Trans,
-                                   DenseMatrix &elmat);
+   virtual void AssembleFaceMatrix2(const FiniteElement &trial_face_fe,
+                                    const FiniteElement &test_fe1,
+                                    const FiniteElement &test_fe2,
+                                    FaceElementTransformations &Trans,
+                                    DenseMatrix &elmat);
 
    virtual void AssemblePA(const FiniteElementSpace &fes);
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
@@ -469,6 +480,11 @@ public:
 class MixedScalarIntegrator: public BilinearFormIntegrator
 {
 public:
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -486,39 +502,40 @@ protected:
    /// result if given the same FiniteElement. The default is false.
    bool same_calc_shape;
 
+   Coefficient *Q;
+
    MixedScalarIntegrator() : same_calc_shape(false), Q(NULL) {}
    MixedScalarIntegrator(Coefficient &q) : same_calc_shape(false), Q(&q) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement &trial_fe, const FiniteElement &test_fe) const
+   virtual bool VerifyFiniteElementTypes(
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarIntegrator:  "
              "Trial and test spaces must both be scalar fields.";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     Vector &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              Vector &shape)
    { test_fe.CalcPhysShape(Trans, shape); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      Vector &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               Vector &shape)
    { trial_fe.CalcPhysShape(Trans, shape); }
 
-   Coefficient *Q;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector test_shape, trial_shape;
@@ -530,6 +547,11 @@ private:
 class MixedVectorIntegrator: public BilinearFormIntegrator
 {
 public:
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -547,6 +569,12 @@ protected:
    /// result if given the same FiniteElement. The default is false.
    bool same_calc_shape;
 
+   int space_dim;
+   Coefficient *Q;
+   VectorCoefficient *VQ;
+   DiagonalMatrixCoefficient *DQ;
+   MatrixCoefficient *MQ;
+
    MixedVectorIntegrator()
       : same_calc_shape(false), Q(NULL), VQ(NULL), DQ(NULL), MQ(NULL) {}
    MixedVectorIntegrator(Coefficient &q)
@@ -557,47 +585,41 @@ protected:
    MixedVectorIntegrator(MatrixCoefficient &mq)
       : same_calc_shape(false), Q(NULL), VQ(NULL), DQ(NULL), MQ(&mq) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorIntegrator:  "
              "Trial and test spaces must both be vector fields";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return std::max(space_dim, test_fe.GetVDim()); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcVShape(Trans, shape); }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return std::max(space_dim, trial_fe.GetVDim()); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcVShape(Trans, shape); }
 
-   int space_dim;
-   Coefficient *Q;
-   VectorCoefficient *VQ;
-   DiagonalMatrixCoefficient *DQ;
-   MatrixCoefficient *MQ;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector V, D;
@@ -611,6 +633,11 @@ private:
 class MixedScalarVectorIntegrator: public BilinearFormIntegrator
 {
 public:
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -627,24 +654,28 @@ public:
    { AssembleElementMatrix2(fe, fe, Trans, elmat); }
 
 protected:
+   VectorCoefficient *VQ;
+   int space_dim;
+   bool transpose;
+   bool cross_2d;  // In 2D use a cross product rather than a dot product
+
    MixedScalarVectorIntegrator(VectorCoefficient &vq, bool transpose_ = false,
                                bool cross_2d_ = false)
       : VQ(&vq), transpose(transpose_), cross_2d(cross_2d_) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return ((transpose &&
                trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR ) ||
+               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR) ||
               (!transpose &&
                trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR )
-             );
+               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR));
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       if (transpose)
       {
@@ -660,35 +691,28 @@ protected:
       }
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-   inline virtual int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return std::max(space_dim, vector_fe.GetVDim()); }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape_)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape_)
    { vector_fe.CalcVShape(Trans, shape_); }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape_)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape_)
    { scalar_fe.CalcPhysShape(Trans, shape_); }
 
-   VectorCoefficient *VQ;
-   int space_dim;
-   bool transpose;
-   bool cross_2d;  // In 2D use a cross product rather than a dot product
-
 private:
 #ifndef MFEM_THREAD_SAFE
-   Vector V;
+   Vector V, shape, vshape_tmp;
    DenseMatrix vshape;
-   Vector      shape;
-   Vector      vshape_tmp;
 #endif
 };
 
@@ -723,25 +747,25 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 1 && test_fe.GetDim() == 1 &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD  &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarDerivativeIntegrator:  "
              "Trial and test spaces must both be scalar fields in 1D "
              "and the trial space must implement CalcDShape.";
    }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      Vector &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       trial_fe.CalcPhysDShape(Trans, dshape);
@@ -758,16 +782,16 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 1 && test_fe.GetDim() == 1 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakDerivativeIntegrator:  "
              "Trial and test spaces must both be scalar fields in 1D "
@@ -775,9 +799,9 @@ protected:
              "map type \"VALUE\".";
    }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     Vector &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       test_fe.CalcPhysDShape(Trans, dshape);
@@ -796,29 +820,29 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
-      return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV  &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+      return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarDivergenceIntegrator:  "
              "Trial must be H(Div) and the test space must be a "
              "scalar field";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      Vector &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               Vector &shape)
    { trial_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -832,15 +856,15 @@ public:
       : MixedScalarVectorIntegrator(vq) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
-      return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV  &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+      return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorDivergenceIntegrator:  "
              "Trial must be H(Div) and the test space must be a "
@@ -849,14 +873,14 @@ protected:
 
    // Subtract one due to the divergence and add one for the coefficient
    // which is assumed to be at least linear.
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1 + 1; }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -871,24 +895,24 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::DIV );
+              test_fe.GetDerivType()  == mfem::FiniteElement::DIV);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakGradientIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be H(Div)";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
    virtual void CalcTestShape(const FiniteElement &test_fe,
@@ -911,7 +935,7 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -920,21 +944,21 @@ protected:
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCurlIntegrator:  "
              "Trial must be H(Curl) and the test space must be a "
              "scalar field";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      Vector &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       trial_fe.CalcPhysCurlShape(Trans, dshape);
@@ -968,25 +992,25 @@ public:
       : MixedScalarIntegrator(q) {}
 
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCurlIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be H(Curl)";
    }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     Vector &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       test_fe.CalcPhysCurlShape(Trans, dshape);
@@ -1026,15 +1050,15 @@ public:
    MixedDotProductIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDotProductIntegrator:  "
              "Trial space must be a vector field "
@@ -1051,16 +1075,16 @@ public:
    MixedWeakGradDotIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::DIV );
+              test_fe.GetDerivType()  == mfem::FiniteElement::DIV);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakGradDotIntegrator:  "
              "Trial space must be a vector field "
@@ -1069,14 +1093,14 @@ public:
 
    // Subtract one due to the gradient and add one for the coefficient
    // which is assumed to be at least linear.
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1 + 1; }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1088,29 +1112,29 @@ public:
    MixedWeakDivCrossIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakDivCrossIntegrator:  "
              "Trial space must be a vector field in 3D "
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1128,26 +1152,26 @@ public:
    MixedGradGradIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) { same_calc_shape = true; }
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedGradGradIntegrator:  "
              "Trial and test spaces must both be scalar fields "
              "with a gradient operator.";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
-                                          const FiniteElement &test_fe,
-                                          ElementTransformation &Trans)
+   virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                   const FiniteElement &test_fe,
+                                   ElementTransformation &Trans) const
    {
       // Same as DiffusionIntegrator
       return test_fe.Space() == FunctionSpace::Pk ?
@@ -1155,20 +1179,20 @@ public:
              trial_fe.GetOrder() + test_fe.GetOrder() + test_fe.GetDim() - 1;
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1180,37 +1204,37 @@ public:
    MixedCrossGradGradIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) { same_calc_shape = true; }
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradGradIntegrator:  "
              "Trial and test spaces must both be scalar fields "
              "with a gradient operator.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1228,7 +1252,7 @@ public:
    MixedCurlCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) { same_calc_shape = true; }
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -1236,30 +1260,30 @@ public:
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCurlCurlIntegrator"
              "Trial and test spaces must both be vector fields in 3D "
              "with a curl.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1271,7 +1295,7 @@ public:
    MixedCrossCurlCurlIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) { same_calc_shape = true; }
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -1280,30 +1304,30 @@ public:
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlCurlIntegrator:  "
              "Trial and test spaces must both be vector fields in 3D "
              "with a curl.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1315,7 +1339,7 @@ public:
    MixedCrossCurlGradIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -1323,30 +1347,30 @@ public:
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlGradIntegrator"
              "Trial space must be a vector field in 3D with a curl"
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1358,7 +1382,7 @@ public:
    MixedCrossGradCurlIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
@@ -1366,30 +1390,30 @@ public:
               trial_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType()  == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType() == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType() == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradCurlIntegrator"
              "Trial space must be a scalar field in 3D with a gradient"
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1402,29 +1426,29 @@ public:
    MixedWeakCurlCrossIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakCurlCrossIntegrator:  "
              "Trial space must be a vector field in 3D "
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1437,26 +1461,26 @@ public:
    MixedScalarWeakCurlCrossIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCurlCrossIntegrator:  "
              "Trial space must be a vector field in 2D "
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       scalar_fe.CalcPhysCurlShape(Trans, dshape);
@@ -1472,34 +1496,34 @@ public:
    MixedCrossGradIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (test_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradIntegrator:  "
              "Trial space must be a scalar field with a gradient operator"
              " and the test space must be a vector field both in 3D.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    { test_fe.CalcVShape(Trans, shape); }
 };
 
@@ -1512,29 +1536,29 @@ public:
    MixedCrossCurlIntegrator(VectorCoefficient &vq)
       : MixedVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::CURL   &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlIntegrator:  "
              "Trial space must be a vector field in 3D with a curl "
              "and the test space must be a vector field";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1547,26 +1571,26 @@ public:
    MixedScalarCrossCurlIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, false, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::CURL   &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlIntegrator:  "
              "Trial space must be a vector field in 2D with a curl "
              "and the test space must be a vector field";
    }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       scalar_fe.CalcPhysCurlShape(Trans, dshape); shape *= -1.0;
@@ -1581,29 +1605,29 @@ public:
    MixedScalarCrossGradIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCrossGradIntegrator:  "
              "Trial space must be a scalar field in 2D with a gradient "
              "and the test space must be a scalar field";
    }
 
-   inline int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1615,16 +1639,16 @@ public:
    MixedScalarCrossProductIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCrossProductIntegrator:  "
              "Trial space must be a vector field in 2D "
@@ -1640,25 +1664,25 @@ public:
    MixedScalarWeakCrossProductIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, false, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCrossProductIntegrator:  "
              "Trial space must be a scalar field in 2D "
              "and the test space must be a vector field";
    }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1670,28 +1694,28 @@ public:
    MixedDirectionalDerivativeIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDirectionalDerivativeIntegrator:  "
              "Trial space must be a scalar field with a gradient "
              "and the test space must be a scalar field";
    }
 
-   inline virtual int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1703,34 +1727,34 @@ public:
    MixedGradDivIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, true) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
+              trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::DIV   );
+              test_fe.GetDerivType()  == mfem::FiniteElement::DIV);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedGradDivIntegrator:  "
              "Trial space must be a scalar field with a gradient"
              "and the test space must be a vector field with a divergence";
    }
 
-   inline virtual int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -1742,35 +1766,34 @@ public:
    MixedDivGradIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::DIV    &&
+              trial_fe.GetDerivType() == mfem::FiniteElement::DIV &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD
-             );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDivGradIntegrator:  "
              "Trial space must be a vector field with a divergence"
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 
-   inline virtual void CalcShape(const FiniteElement &scalar_fe,
-                                 ElementTransformation &Trans,
-                                 Vector &shape)
+   virtual void CalcShape(const FiniteElement &scalar_fe,
+                          ElementTransformation &Trans,
+                          Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -1782,28 +1805,28 @@ public:
    MixedScalarWeakDivergenceIntegrator(VectorCoefficient &vq)
       : MixedScalarVectorIntegrator(vq, false) {}
 
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD   );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakDivergenceIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline int GetVDim(const FiniteElement &vector_fe)
+   virtual int GetVDim(const FiniteElement &vector_fe) const
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement &vector_fe,
-                                  ElementTransformation &Trans,
-                                  DenseMatrix &shape)
+   virtual void CalcVShape(const FiniteElement &vector_fe,
+                           ElementTransformation &Trans,
+                           DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1824,40 +1847,57 @@ public:
    MixedVectorGradientIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorGradientIntegrator:  "
              "Trial spaces must be H1 and the test space must be a "
              "vector field in 2D or 3D";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    {
       trial_fe.CalcPhysDShape(Trans, shape);
    }
 
+private:
    DenseMatrix Jinv;
 
    // PA extension
@@ -1882,6 +1922,8 @@ public:
    MixedVectorCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
@@ -1890,29 +1932,35 @@ public:
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
-              trial_fe.GetDerivType() == mfem::FiniteElement::CURL  &&
-              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
+              trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
+              test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorCurlIntegrator:  "
              "Trial space must be H(Curl) and the test space must be a "
              "vector field in 3D";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
+   virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &shape)
+   virtual void CalcTrialShape(const FiniteElement &trial_fe,
+                               ElementTransformation &Trans,
+                               DenseMatrix &shape)
    {
       trial_fe.CalcPhysCurlShape(Trans, shape);
    }
@@ -1942,6 +1990,8 @@ public:
    MixedVectorWeakCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
@@ -1950,29 +2000,35 @@ public:
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
+              test_fe.GetDerivType()  == mfem::FiniteElement::CURL);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorWeakCurlIntegrator:  "
              "Trial space must be vector field in 3D and the "
              "test space must be H(Curl)";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    {
       test_fe.CalcPhysCurlShape(Trans, shape);
    }
@@ -2000,28 +2056,50 @@ public:
    MixedVectorWeakDivergenceIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
 protected:
-   inline virtual bool VerifyFiniteElementTypes(
+   virtual bool VerifyFiniteElementTypes(
       const FiniteElement &trial_fe,
       const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
-              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
+              test_fe.GetDerivType()  == mfem::FiniteElement::GRAD);
    }
 
-   inline virtual const char *FiniteElementTypeFailureMessage() const
+   virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorWeakDivergenceIntegrator:  "
              "Trial space must be vector field and the "
              "test space must be H1";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement &test_fe)
+   virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement &test_fe,
-                                     ElementTransformation &Trans,
-                                     DenseMatrix &shape)
+   virtual void CalcTestShape(const FiniteElement &test_fe,
+                              ElementTransformation &Trans,
+                              DenseMatrix &shape)
    {
       test_fe.CalcPhysDShape(Trans, shape);
       shape *= -1.0;
@@ -2063,6 +2141,11 @@ public:
       Q{&q}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
    {}
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2075,10 +2158,6 @@ public:
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
-
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe,
-                                         ElementTransformation &Trans);
 };
 
 /** Class for integrating the bilinear form a(u,v) := (Q grad u, grad v) where Q
@@ -2128,6 +2207,18 @@ public:
       : BilinearFormIntegrator(ir),
         Q(NULL), VQ(NULL), MQ(&q), maps(NULL), geom(NULL) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   static const IntegrationRule &GetRuleStatic(const FiniteElement &trial_fe,
+                                               const FiniteElement &test_fe,
+                                               ElementTransformation &Trans);
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return GetRuleStatic(trial_fe, test_fe, Trans); }
+
    /** Given a particular Finite Element computes the element stiffness matrix
        elmat. */
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -2159,6 +2250,9 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
@@ -2168,6 +2262,9 @@ public:
    using BilinearFormIntegrator::AssembleMF;
    virtual void AssembleMF(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
@@ -2175,11 +2272,6 @@ public:
    using BilinearFormIntegrator::AssembleEA;
    virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe);
-
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
-
    Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2210,6 +2302,19 @@ public:
    MassIntegrator(Coefficient &q, const IntegrationRule *ir = NULL)
       : BilinearFormIntegrator(ir), Q(&q), maps(NULL), geom(NULL) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   static const IntegrationRule &GetRuleStatic(const FiniteElement &trial_fe,
+                                               const FiniteElement &test_fe,
+                                               ElementTransformation &Trans,
+                                               int Q_order = 0);
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return GetRuleStatic(trial_fe, test_fe, Trans); }
+
    /** Given a particular Finite Element computes the element mass matrix
        elmat. */
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -2236,6 +2341,9 @@ public:
    using BilinearFormIntegrator::AssembleMF;
    virtual void AssembleMF(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
@@ -2243,12 +2351,6 @@ public:
    using BilinearFormIntegrator::AssembleEA;
    virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe,
-                                         ElementTransformation &Trans);
-
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
-
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2258,7 +2360,10 @@ class BoundaryMassIntegrator : public MassIntegrator
 public:
    BoundaryMassIntegrator(Coefficient &q) : MassIntegrator(q) {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const;
 
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
@@ -2289,6 +2394,13 @@ public:
    ConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
       : Q(&q) { alpha = a; }
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix(const FiniteElement &fes,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
@@ -2296,6 +2408,9 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
@@ -2305,17 +2420,15 @@ public:
    using BilinearFormIntegrator::AssembleMF;
    virtual void AssembleMF(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 
    using BilinearFormIntegrator::AssembleEA;
    virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
-
-   static const IntegrationRule &GetRule(const FiniteElement &fe,
-                                         ElementTransformation &Trans);
-
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
 };
 
 // Alias for @ConvectionIntegrator.
@@ -2349,33 +2462,154 @@ public:
                                       DenseMatrix &);
 };
 
-/** Class for integrating the bilinear form a(u,v) := (Q u, v),
-    where u=(u1,...,un) and v=(v1,...,vn); ui and vi are defined
-    by scalar FE through standard transformation. */
-class VectorMassIntegrator: public BilinearFormIntegrator
-{
-private:
-   int vdim;
-   Vector shape, te_shape, vec;
-   DenseMatrix partelmat;
-   DenseMatrix mcoeff;
-   int Q_order;
+/** Integrator for
 
+      (Q grad u, grad v) = sum_i (Q grad u_i, grad v_i) e_i e_i^T
+
+    for vector FE spaces, where e_i is the unit vector in the i-th direction.
+    The resulting local element matrix is square, of size <tt> vdim*dof </tt>,
+    where \c vdim is the vector dimension space and \c dof is the local degrees
+    of freedom. The integrator is not aware of the true vector dimension and
+    must use \c VectorCoefficient, \c MatrixCoefficient, or a caller-specified
+    value to determine the vector space. For a scalar coefficient, the caller
+    may manually specify the vector dimension or the vector dimension is assumed
+    to be the spatial dimension (i.e. 2-dimension or 3-dimension).
+*/
+class VectorDiffusionIntegrator : public BilinearFormIntegrator
+{
 protected:
-   Coefficient *Q;
-   VectorCoefficient *VQ;
-   MatrixCoefficient *MQ;
+   Coefficient *Q = NULL;
+   VectorCoefficient *VQ = NULL;
+   MatrixCoefficient *MQ = NULL;
 
    // PA extension
-   Vector pa_data;
    const DofToQuad *maps;         ///< Not owned
    const GeometricFactors *geom;  ///< Not owned
-   int dim, ne, nq, dofs1D, quad1D;
+   int dim, sdim, ne, dofs1D, quad1D;
+   Vector pa_data;
+
+private:
+   DenseMatrix dshape, dshapedxt, pelmat;
+   int vdim = -1;
+   DenseMatrix mcoeff;
+   Vector vcoeff;
 
 public:
-   /// Construct an integrator with coefficient 1.0
-   VectorMassIntegrator()
-      : vdim(-1), Q_order(0), Q(NULL), VQ(NULL), MQ(NULL) {}
+   VectorDiffusionIntegrator() {}
+
+   /** \brief Integrator with unit coefficient for caller-specified vector
+       dimension.
+
+       If the vector dimension does not match the true dimension of the space,
+       the resulting element matrix will be mathematically invalid. */
+   VectorDiffusionIntegrator(int vector_dimension)
+      : vdim(vector_dimension) {}
+
+   VectorDiffusionIntegrator(Coefficient &q)
+      : Q(&q) {}
+
+   VectorDiffusionIntegrator(Coefficient &q, const IntegrationRule *ir)
+      : BilinearFormIntegrator(ir), Q(&q) {}
+
+   /** \brief Integrator with scalar coefficient for caller-specified vector
+       dimension.
+
+       The element matrix is block-diagonal with \c vdim copies of the element
+       matrix integrated with the \c Coefficient.
+
+       If the vector dimension does not match the true dimension of the space,
+       the resulting element matrix will be mathematically invalid. */
+   VectorDiffusionIntegrator(Coefficient &q, int vector_dimension)
+      : Q(&q), vdim(vector_dimension) {}
+
+   /** \brief Integrator with \c VectorCoefficient. The vector dimension of the
+       \c FiniteElementSpace is assumed to be the same as the dimension of the
+       \c Vector.
+
+       The element matrix is block-diagonal and each block is integrated with
+       coefficient q_i.
+
+       If the vector dimension does not match the true dimension of the space,
+       the resulting element matrix will be mathematically invalid. */
+   VectorDiffusionIntegrator(VectorCoefficient &vq)
+      : VQ(&vq), vdim(vq.GetVDim()) {}
+
+   /** \brief Integrator with \c MatrixCoefficient. The vector dimension of the
+       \c FiniteElementSpace is assumed to be the same as the dimension of the
+       \c Matrix.
+
+       The element matrix is populated in each block. Each block is integrated
+       with coefficient q_ij.
+
+       If the vector dimension does not match the true dimension of the space,
+       the resulting element matrix will be mathematically invalid. */
+   VectorDiffusionIntegrator(MatrixCoefficient& mq)
+      : MQ(&mq), vdim(mq.GetVDim()) {}
+
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return DiffusionIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
+
+   virtual void AssembleElementMatrix(const FiniteElement &el,
+                                      ElementTransformation &Trans,
+                                      DenseMatrix &elmat);
+
+   virtual void AssembleElementVector(const FiniteElement &el,
+                                      ElementTransformation &Tr,
+                                      const Vector &elfun, Vector &elvect);
+
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+};
+
+/** Class for integrating the bilinear form a(u,v) := (Q u, v),
+    where u=(u1,...,un) and v=(v1,...,vn); ui and vi are defined
+    by scalar FE through standard transformation. */
+class VectorMassIntegrator: public BilinearFormIntegrator
+{
+private:
+   int vdim;
+   Vector shape, te_shape, vec;
+   DenseMatrix partelmat;
+   DenseMatrix mcoeff;
+   int Q_order;
+
+protected:
+   Coefficient *Q;
+   VectorCoefficient *VQ;
+   MatrixCoefficient *MQ;
+
+   // PA extension
+   Vector pa_data;
+   const DofToQuad *maps;         ///< Not owned
+   const GeometricFactors *geom;  ///< Not owned
+   int dim, ne, nq, dofs1D, quad1D;
+
+public:
+   /// Construct an integrator with coefficient 1.0
+   VectorMassIntegrator()
+      : vdim(-1), Q_order(0), Q(NULL), VQ(NULL), MQ(NULL) {}
    /** Construct an integrator with scalar coefficient q.  If possible, save
        memory by using a scalar integrator since the resulting matrix is block
        diagonal with the same diagonal block repeated. */
@@ -2394,6 +2628,14 @@ public:
    int GetVDim() const { return vdim; }
    void SetVDim(int vdim_) { vdim = vdim_; }
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return MassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans, Q_order); }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
@@ -2406,6 +2648,9 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
@@ -2413,11 +2658,12 @@ public:
    using BilinearFormIntegrator::AssembleMF;
    virtual void AssembleMF(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
-
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
 };
 
 /** Class for integrating (div u, p) where u is a vector field given by
@@ -2430,14 +2676,14 @@ public:
     ElementTransformation Trans. */
 class VectorFEDivergenceIntegrator : public BilinearFormIntegrator
 {
-protected:
-   Coefficient *Q;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector divshape, shape;
 #endif
 
+protected:
+   Coefficient *Q;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *mapsO;         ///< Not owned. DOF-to-quad map, open.
@@ -2449,9 +2695,10 @@ public:
    VectorFEDivergenceIntegrator() { Q = NULL; }
    VectorFEDivergenceIntegrator(Coefficient &q) { Q = &q; }
 
-   virtual void AssembleElementMatrix(const FiniteElement &el,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &elmat) {}
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2473,9 +2720,6 @@ public:
     This is equivalent to a weak divergence of the Nedelec basis functions. */
 class VectorFEWeakDivergenceIntegrator: public BilinearFormIntegrator
 {
-protected:
-   Coefficient *Q;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    DenseMatrix dshape;
@@ -2484,13 +2728,17 @@ private:
    DenseMatrix invdfdx;
 #endif
 
+protected:
+   Coefficient *Q;
+
 public:
    VectorFEWeakDivergenceIntegrator() { Q = NULL; }
    VectorFEWeakDivergenceIntegrator(Coefficient &q) { Q = &q; }
 
-   virtual void AssembleElementMatrix(const FiniteElement &el,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &elmat) {}
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2502,9 +2750,6 @@ public:
     test spaces are switched, assembles the form (u, curl v). */
 class VectorFECurlIntegrator: public BilinearFormIntegrator
 {
-protected:
-   Coefficient *Q;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    DenseMatrix curlshapeTrial;
@@ -2512,13 +2757,17 @@ private:
    DenseMatrix curlshapeTrial_dFT;
 #endif
 
+protected:
+   Coefficient *Q;
+
 public:
    VectorFECurlIntegrator() { Q = NULL; }
    VectorFECurlIntegrator(Coefficient &q) { Q = &q; }
 
-   virtual void AssembleElementMatrix(const FiniteElement &el,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &elmat) {}
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2540,6 +2789,11 @@ private:
 public:
    DerivativeIntegrator(Coefficient &q, int i) : Q(&q), xi(i) {}
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat)
@@ -2587,6 +2841,13 @@ public:
    CurlCurlIntegrator(MatrixCoefficient &mq, const IntegrationRule *ir = NULL) :
       BilinearFormIntegrator(ir), Q(NULL), DQ(NULL), MQ(&mq) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    /* Given a particular Finite Element, compute the
       element curl-curl matrix elmat */
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -2611,10 +2872,23 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2632,13 +2906,18 @@ protected:
 
 public:
    VectorCurlCurlIntegrator() { Q = NULL; }
-
    VectorCurlCurlIntegrator(Coefficient &q) : Q(&q) {}
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    /// Assemble an element matrix
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    /// Compute element energy: (1/2) (curl u, curl u)_E
    virtual double GetElementEnergy(const FiniteElement &el,
                                    ElementTransformation &Tr,
@@ -2663,11 +2942,17 @@ private:
    DenseMatrix dshape;
    DenseMatrix curlshape;
    DenseMatrix elmat_comp;
+
 public:
    MixedCurlIntegrator() : Q{NULL} {}
    MixedCurlIntegrator(Coefficient *q_) :  Q{q_} {}
    MixedCurlIntegrator(Coefficient &q) :  Q{&q} {}
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2681,9 +2966,6 @@ public:
 class VectorFEMassIntegrator: public BilinearFormIntegrator
 {
 private:
-   void Init(Coefficient *q, DiagonalMatrixCoefficient *dq, MatrixCoefficient *mq)
-   { Q = q; DQ = dq; MQ = mq; }
-
 #ifndef MFEM_THREAD_SAFE
    Vector shape;
    Vector D;
@@ -2693,6 +2975,9 @@ private:
    DenseMatrix trial_vshape;
 #endif
 
+   void Init(Coefficient *q, DiagonalMatrixCoefficient *dq, MatrixCoefficient *mq)
+   { Q = q; DQ = dq; MQ = mq; }
+
 protected:
    Coefficient *Q;
    DiagonalMatrixCoefficient *DQ;
@@ -2717,6 +3002,18 @@ public:
    VectorFEMassIntegrator(MatrixCoefficient *mq_) { Init(NULL, NULL, mq_); }
    VectorFEMassIntegrator(MatrixCoefficient &mq) { Init(NULL, NULL, &mq); }
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   static const IntegrationRule &GetRuleStatic(const FiniteElement &trial_fe,
+                                               const FiniteElement &test_fe,
+                                               ElementTransformation &Trans);
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return GetRuleStatic(trial_fe, test_fe, Trans); }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
@@ -2730,12 +3027,25 @@ public:
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2762,14 +3072,16 @@ private:
 
 public:
    VectorDivergenceIntegrator() :
-      Q(NULL), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   {  }
+      Q(NULL), trial_maps(NULL), test_maps(NULL), geom(NULL) {}
    VectorDivergenceIntegrator(Coefficient *q_) :
-      Q(q_), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   {}
+      Q(q_), trial_maps(NULL), test_maps(NULL), geom(NULL) {}
    VectorDivergenceIntegrator(Coefficient &q) :
-      Q(&q), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   {}
+      Q(&q), trial_maps(NULL), test_maps(NULL), geom(NULL) {}
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2783,10 +3095,6 @@ public:
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
-
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe,
-                                         ElementTransformation &Trans);
 };
 
 /// (Q div u, div v) for RT elements
@@ -2812,6 +3120,13 @@ public:
    DivDivIntegrator(Coefficient &q, const IntegrationRule *ir = NULL) :
       BilinearFormIntegrator(ir), Q(&q) {}
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
@@ -2824,120 +3139,231 @@ public:
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   const Coefficient *GetCoefficient() const { return Q; }
-};
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
 
-/** Integrator for
+   using BilinearFormIntegrator::AssembleMFBoundary;
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
 
-      (Q grad u, grad v) = sum_i (Q grad u_i, grad v_i) e_i e_i^T
+   virtual void AssembleDiagonalMF(Vector &diag);
 
-    for vector FE spaces, where e_i is the unit vector in the i-th direction.
-    The resulting local element matrix is square, of size <tt> vdim*dof </tt>,
-    where \c vdim is the vector dimension space and \c dof is the local degrees
-    of freedom. The integrator is not aware of the true vector dimension and
-    must use \c VectorCoefficient, \c MatrixCoefficient, or a caller-specified
-    value to determine the vector space. For a scalar coefficient, the caller
-    may manually specify the vector dimension or the vector dimension is assumed
-    to be the spatial dimension (i.e. 2-dimension or 3-dimension).
-*/
-class VectorDiffusionIntegrator : public BilinearFormIntegrator
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
+
+   const Coefficient *GetCoefficient() const { return Q; }
+};
+
+/** Class for integrating the bilinear form a(u,v) := (Qd grad u, grad v) +
+    (Qm u, v) */
+class DiffusionMassIntegrator: public BilinearFormIntegrator
 {
 protected:
-   Coefficient *Q = NULL;
-   VectorCoefficient *VQ = NULL;
-   MatrixCoefficient *MQ = NULL;
+   Coefficient *Qd, *Qm;
+   VectorCoefficient *VQd;
+   MatrixCoefficient *MQd;
 
-   // PA extension
-   const DofToQuad *maps;         ///< Not owned
-   const GeometricFactors *geom;  ///< Not owned
-   int dim, sdim, ne, dofs1D, quad1D;
-   Vector pa_data;
+public:
+   /// Construct a diffusion + mass integrator with coefficients Qd = Qm = 1.
+   DiffusionMassIntegrator(const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(NULL), VQd(NULL), MQd(NULL) {}
 
-private:
-   DenseMatrix dshape, dshapedxt, pelmat;
-   int vdim = -1;
-   DenseMatrix mcoeff;
-   Vector vcoeff;
+   /** Construct a diffusion + mass integrator with a scalar diffusion
+       coefficient qd and mass coefficient qm. */
+   DiffusionMassIntegrator(Coefficient &qd, Coefficient &qm,
+                           const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(&qd), Qm(&qm), VQd(NULL), MQd(NULL) {}
 
-public:
-   VectorDiffusionIntegrator() {}
+   /** Construct a diffusion + mass integrator with a vector diffusion
+       coefficient qd and mass coefficient qm. */
+   DiffusionMassIntegrator(VectorCoefficient &qd, Coefficient &qm,
+                           const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(&qm), VQd(&qd), MQd(NULL) {}
 
-   /** \brief Integrator with unit coefficient for caller-specified vector
-       dimension.
+   /** Construct a diffusion + mass integrator with a matrix diffusion
+       coefficient qd and mass coefficient qm. */
+   DiffusionMassIntegrator(MatrixCoefficient &qd, Coefficient &qm,
+                           const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(&qm), VQd(NULL), MQd(&qd) {}
 
-       If the vector dimension does not match the true dimension of the space,
-       the resulting element matrix will be mathematically invalid. */
-   VectorDiffusionIntegrator(int vector_dimension)
-      : vdim(vector_dimension) {}
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
 
-   VectorDiffusionIntegrator(Coefficient &q)
-      : Q(&q) {}
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return MassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
 
-   VectorDiffusionIntegrator(Coefficient &q, const IntegrationRule *ir)
-      : BilinearFormIntegrator(ir), Q(&q) {}
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   /** \brief Integrator with scalar coefficient for caller-specified vector
-       dimension.
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
 
-       The element matrix is block-diagonal with \c vdim copies of the element
-       matrix integrated with the \c Coefficient.
+   virtual void AssembleDiagonalPA(Vector &diag);
 
-       If the vector dimension does not match the true dimension of the space,
-       the resulting element matrix will be mathematically invalid. */
-   VectorDiffusionIntegrator(Coefficient &q, int vector_dimension)
-      : Q(&q), vdim(vector_dimension) {}
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+};
 
-   /** \brief Integrator with \c VectorCoefficient. The vector dimension of the
-       \c FiniteElementSpace is assumed to be the same as the dimension of the
-       \c Vector.
+/** Class for integrating the bilinear form a(u,v) := (Qd curl u, curl v) +
+    (Qm u, v) for ND elements */
+class CurlCurlMassIntegrator: public BilinearFormIntegrator
+{
+protected:
+   Coefficient *Qd, *Qm;
+   VectorCoefficient *VQd, *VQm;
+   MatrixCoefficient *MQd, *MQm;
 
-       The element matrix is block-diagonal and each block is integrated with
-       coefficient q_i.
+public:
+   /// Construct a curl-curl + mass integrator with coefficients Qd = Qm = 1.
+   CurlCurlMassIntegrator(const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(NULL), VQd(NULL), VQm(NULL), MQd(NULL), MQm(NULL) {}
 
-       If the vector dimension does not match the true dimension of the space,
-       the resulting element matrix will be mathematically invalid. */
-   VectorDiffusionIntegrator(VectorCoefficient &vq)
-      : VQ(&vq), vdim(vq.GetVDim()) {}
+   /** Construct a curl-curl + mass integrator with a scalar curl-curl
+       coefficient qd and scalar mass coefficient qm. */
+   CurlCurlMassIntegrator(Coefficient &qd, Coefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(&qd), Qm(&qm), VQd(NULL), VQm(NULL), MQd(NULL), MQm(NULL) {}
 
-   /** \brief Integrator with \c MatrixCoefficient. The vector dimension of the
-       \c FiniteElementSpace is assumed to be the same as the dimension of the
-       \c Matrix.
+   /** Construct a curl-curl + mass integrator with a scalar curl-curl
+       coefficient qd and vector mass coefficient qm. */
+   CurlCurlMassIntegrator(Coefficient &qd, VectorCoefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(&qd), Qm(NULL), VQd(NULL), VQm(&qm), MQd(NULL), MQm(NULL) {}
 
-       The element matrix is populated in each block. Each block is integrated
-       with coefficient q_ij.
+   /** Construct a curl-curl + mass integrator with a scalar curl-curl
+       coefficient qd and matrix mass coefficient qm. */
+   CurlCurlMassIntegrator(Coefficient &qd, MatrixCoefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(&qd), Qm(NULL), VQd(NULL), VQm(NULL), MQd(NULL), MQm(&qm) {}
 
-       If the vector dimension does not match the true dimension of the space,
-       the resulting element matrix will be mathematically invalid. */
-   VectorDiffusionIntegrator(MatrixCoefficient& mq)
-      : MQ(&mq), vdim(mq.GetVDim()) {}
+   /** Construct a curl-curl + mass integrator with a vector curl-curl
+       coefficient qd and scalar mass coefficient qm. */
+   CurlCurlMassIntegrator(VectorCoefficient &qd, Coefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(&qm), VQd(&qd), VQm(NULL), MQd(NULL), MQm(NULL) {}
 
-   virtual void AssembleElementMatrix(const FiniteElement &el,
-                                      ElementTransformation &Trans,
-                                      DenseMatrix &elmat);
+   /** Construct a curl-curl + mass integrator with a vector curl-curl
+       coefficient qd and vector mass coefficient qm. */
+   CurlCurlMassIntegrator(VectorCoefficient &qd, VectorCoefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(NULL), VQd(&qd), VQm(&qm), MQd(NULL), MQm(NULL) {}
 
-   virtual void AssembleElementVector(const FiniteElement &el,
-                                      ElementTransformation &Tr,
-                                      const Vector &elfun, Vector &elvect);
+   /** Construct a curl-curl + mass integrator with a vector curl-curl
+       coefficient qd and matrix mass coefficient qm. */
+   CurlCurlMassIntegrator(VectorCoefficient &qd, MatrixCoefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(NULL), VQd(&qd), VQm(NULL), MQd(NULL), MQm(&qm) {}
+
+   /** Construct a curl-curl + mass integrator with a matrix curl-curl
+       coefficient qd and scalar mass coefficient qm. */
+   CurlCurlMassIntegrator(MatrixCoefficient &qd, Coefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(&qm), VQd(NULL), VQm(NULL), MQd(&qd), MQm(NULL) {}
+
+   /** Construct a curl-curl + mass integrator with a matrix curl-curl
+       coefficient qd and vector mass coefficient qm. */
+   CurlCurlMassIntegrator(MatrixCoefficient &qd, VectorCoefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(NULL), VQd(NULL), VQm(&qm), MQd(&qd), MQm(NULL) {}
+
+   /** Construct a curl-curl + mass integrator with a matrix curl-curl
+       coefficient qd and matrix mass coefficient qm. */
+   CurlCurlMassIntegrator(MatrixCoefficient &qd, MatrixCoefficient &qm,
+                          const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(NULL), VQd(NULL), VQm(NULL), MQd(&qd), MQm(&qm) {}
+
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return VectorFEMassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
 
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+};
 
-   using BilinearFormIntegrator::AssembleMF;
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+/** Class for integrating the bilinear form a(u,v) := (Qd div u, div v) +
+    (Qm u, v) for RT elements */
+class DivDivMassIntegrator: public BilinearFormIntegrator
+{
+protected:
+   Coefficient *Qd, *Qm;
+   VectorCoefficient *VQm;
+   MatrixCoefficient *MQm;
 
-   virtual void AssembleDiagonalMF(Vector &diag);
+public:
+   /// Construct a div-div + mass integrator with coefficients Qd = Qm = 1.
+   DivDivMassIntegrator(const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(NULL), Qm(NULL), VQm(NULL), MQm(NULL) {}
 
-   virtual void AddMultMF(const Vector &x, Vector &y) const;
+   /** Construct a div-div + mass integrator with a div-div coefficient qd and
+       scalar mass coefficient qm. */
+   DivDivMassIntegrator(Coefficient &qd, Coefficient &qm,
+                        const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(&qd), Qm(&qm), VQm(NULL), MQm(NULL) {}
+
+   /** Construct a div-div + mass integrator with a div-div coefficient qd and
+       vector mass coefficient qm. */
+   DivDivMassIntegrator(Coefficient &qd, VectorCoefficient &qm,
+                        const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(&qd), Qm(NULL), VQm(&qm), MQm(NULL) {}
+
+   /** Construct a div-div + mass integrator with a div-div coefficient qd and
+       matrix mass coefficient qm. */
+   DivDivMassIntegrator(Coefficient &qd, MatrixCoefficient &qm,
+                        const IntegrationRule *ir = nullptr)
+      : BilinearFormIntegrator(ir),
+        Qd(&qd), Qm(NULL), VQm(NULL), MQm(&qm) {}
+
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   { return VectorFEMassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
 
-   bool SupportsCeed() const { return DeviceCanUseCeed(); }
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 };
 
 /** Integrator for the linear elasticity form:
@@ -2966,6 +3392,11 @@ public:
    ElasticityIntegrator(Coefficient &m, double q_l, double q_m)
    { lambda = NULL; mu = &m; q_lambda = q_l; q_mu = q_m; }
 
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const;
+
    virtual void AssembleElementMatrix(const FiniteElement &,
                                       ElementTransformation &,
                                       DenseMatrix &);
@@ -3054,7 +3485,11 @@ public:
                      double a, double b)
    { rho = &rho_; u = &u_; alpha = a; beta = b; }
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const;
+
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -3075,9 +3510,6 @@ public:
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace& fes,
                                         Vector &ea_data_bdr);
 
-   static const IntegrationRule &GetRule(Geometry::Type geom, int order,
-                                         FaceElementTransformations &T);
-
 private:
    void SetupPA(const FiniteElementSpace &fes, FaceType type);
 };
@@ -3137,7 +3569,16 @@ public:
    DGDiffusionIntegrator(MatrixCoefficient &q, const double s, const double k)
       : Q(NULL), MQ(&q), sigma(s), kappa(k) {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   static const IntegrationRule &GetRuleStatic(const FiniteElement &el1,
+                                               const FiniteElement &el2,
+                                               FaceElementTransformations &Trans);
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const
+   { return GetRuleStatic(el1, el2, Trans); }
+
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -3197,7 +3638,12 @@ public:
    MFEM_DEPRECATED DGDiffusionBR2Integrator(class FiniteElementSpace *fes,
                                             double e = 1.0);
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const
+   { return DGDiffusionIntegrator::GetRuleStatic(el1, el2, Trans); }
+
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -3274,7 +3720,12 @@ public:
                           double alpha_, double kappa_)
       : lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const
+   { return DGDiffusionIntegrator::GetRuleStatic(el1, el2, Trans); }
+
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -3325,12 +3776,11 @@ private:
 public:
    TraceJumpIntegrator() {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
-   virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
-                                   const FiniteElement &test_fe1,
-                                   const FiniteElement &test_fe2,
-                                   FaceElementTransformations &Trans,
-                                   DenseMatrix &elmat);
+   virtual void AssembleFaceMatrix2(const FiniteElement &trial_face_fe,
+                                    const FiniteElement &test_fe1,
+                                    const FiniteElement &test_fe2,
+                                    FaceElementTransformations &Trans,
+                                    DenseMatrix &elmat);
 };
 
 /** Integrator for the form: < v, [w.n] > over all faces (the interface) where
@@ -3345,12 +3795,11 @@ private:
 public:
    NormalTraceJumpIntegrator() {}
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
-   virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
-                                   const FiniteElement &test_fe1,
-                                   const FiniteElement &test_fe2,
-                                   FaceElementTransformations &Trans,
-                                   DenseMatrix &elmat);
+   virtual void AssembleFaceMatrix2(const FiniteElement &trial_face_fe,
+                                    const FiniteElement &test_fe1,
+                                    const FiniteElement &test_fe2,
+                                    FaceElementTransformations &Trans,
+                                    DenseMatrix &elmat);
 };
 
 /** Integrator for the DPG form: < v, w > over a face (the interface) where
@@ -3361,13 +3810,15 @@ class TraceIntegrator : public BilinearFormIntegrator
 {
 private:
    Vector face_shape, shape;
+
 public:
-   TraceIntegrator() { }
-   void AssembleTraceFaceMatrix(int elem,
-                                const FiniteElement &trial_face_fe,
-                                const FiniteElement &test_fe,
-                                FaceElementTransformations &Trans,
-                                DenseMatrix &elmat);
+   TraceIntegrator() {}
+
+   virtual void AssembleTraceFaceMatrix(int elem,
+                                        const FiniteElement &trial_face_fe,
+                                        const FiniteElement &test_fe,
+                                        FaceElementTransformations &Trans,
+                                        DenseMatrix &elmat);
 };
 
 /** Integrator for the form: < v, w.n > over a face (the interface) where
@@ -3380,15 +3831,15 @@ private:
    DenseMatrix shape;
 
 public:
-   NormalTraceIntegrator() { }
-   virtual void AssembleTraceFaceMatrix(int ielem,
+   NormalTraceIntegrator() {}
+
+   virtual void AssembleTraceFaceMatrix(int elem,
                                         const FiniteElement &trial_face_fe,
                                         const FiniteElement &test_fe,
                                         FaceElementTransformations &Trans,
                                         DenseMatrix &elmat);
 };
 
-
 /** Integrator for the form: < v, w  n > over a face (the interface)
  *  In 3D the trial variable v is defined on the interface (H^-1/2(curl), trace of H(curl))
  *  In 2D it's defined on the interface (H^1/2, trace of H1)
@@ -3426,17 +3877,30 @@ private:
    }
 
 public:
-   TangentTraceIntegrator() { }
-   void AssembleTraceFaceMatrix(int elem,
-                                const FiniteElement &trial_face_fe,
-                                const FiniteElement &test_fe,
-                                FaceElementTransformations &Trans,
-                                DenseMatrix &elmat);
+   TangentTraceIntegrator() {}
+
+   virtual void AssembleTraceFaceMatrix(int elem,
+                                        const FiniteElement &trial_face_fe,
+                                        const FiniteElement &test_fe,
+                                        FaceElementTransformations &Trans,
+                                        DenseMatrix &elmat);
 };
 
 /** Abstract class to serve as a base for local interpolators to be used in the
     DiscreteLinearOperator class. */
-class DiscreteInterpolator : public BilinearFormIntegrator {};
+class DiscreteInterpolator : public BilinearFormIntegrator
+{
+public:
+   // This avoids an error when GetRule is called with an interpolator even if
+   // it is never used.
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
+                                          ElementTransformation &Trans) const
+   {
+      return IntRules.Get(0, 0);
+   }
+};
 
 /** Class for constructing the gradient as a DiscreteLinearOperator from an
     H1-conforming space to an H(curl)-conforming space. The range space can be
@@ -3447,17 +3911,14 @@ public:
    GradientInterpolator() : dofquad_fe(NULL) {}
    virtual ~GradientInterpolator() { delete dofquad_fe; }
 
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    virtual void AssembleElementMatrix2(const FiniteElement &h1_fe,
                                        const FiniteElement &nd_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat)
    { nd_fe.ProjectGrad(h1_fe, Trans, elmat); }
 
-   /** @brief Setup method for PA data.
-
-       @param[in] trial_fes   H1 Lagrange space
-       @param[in] test_fes    H(curl) Nedelec space
-    */
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
@@ -3469,7 +3930,6 @@ public:
 private:
    /// 1D finite element that generates and owns the 1D DofToQuad maps below
    FiniteElement *dofquad_fe;
-
    bool B_id; // is the B basis operator (maps_C_C) the identity?
    const DofToQuad *maps_C_C; // one-d map with Lobatto rows, Lobatto columns
    const DofToQuad *maps_O_C; // one-d map with Legendre rows, Lobatto columns
@@ -3482,7 +3942,9 @@ private:
 class IdentityInterpolator : public DiscreteInterpolator
 {
 public:
-   IdentityInterpolator(): dofquad_fe(NULL) { }
+   IdentityInterpolator(): dofquad_fe(NULL) {}
+
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
@@ -3503,11 +3965,9 @@ public:
 private:
    /// 1D finite element that generates and owns the 1D DofToQuad maps below
    FiniteElement *dofquad_fe;
-
    const DofToQuad *maps_C_C; // one-d map with Lobatto rows, Lobatto columns
    const DofToQuad *maps_O_C; // one-d map with Legendre rows, Lobatto columns
    int dim, ne, o_dofs1D, c_dofs1D;
-
    Vector pa_data;
 };
 
@@ -3517,11 +3977,21 @@ private:
 class CurlInterpolator : public DiscreteInterpolator
 {
 public:
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat)
    { ran_fe.ProjectCurl(dom_fe, Trans, elmat); }
+
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 };
 
 /** Class for constructing the (local) discrete divergence matrix which can
@@ -3577,8 +4047,7 @@ protected:
 class ScalarVectorProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarVectorProductInterpolator(Coefficient &sc)
-      : Q(&sc) {}
+   ScalarVectorProductInterpolator(Coefficient &sc) : Q(&sc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
@@ -3595,8 +4064,7 @@ protected:
 class VectorScalarProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorScalarProductInterpolator(VectorCoefficient &vc)
-      : VQ(&vc) {}
+   VectorScalarProductInterpolator(VectorCoefficient &vc) : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
@@ -3630,8 +4098,7 @@ protected:
 class VectorCrossProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorCrossProductInterpolator(VectorCoefficient &vc)
-      : VQ(&vc) {}
+   VectorCrossProductInterpolator(VectorCoefficient &vc) : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &nd_fe,
                                        const FiniteElement &rt_fe,
diff --git a/fem/ceed/integrators/convection/convection.cpp b/fem/ceed/integrators/convection/convection.cpp
index c5560f354..cf6875d57 100644
--- a/fem/ceed/integrators/convection/convection.cpp
+++ b/fem/ceed/integrators/convection/convection.cpp
@@ -25,81 +25,96 @@ namespace ceed
 #ifdef MFEM_USE_CEED
 struct ConvectionOperatorInfo : public OperatorInfo
 {
-   ConvectionContext ctx;
-   ConvectionOperatorInfo(int dim, double alpha)
+   ConvectionContext ctx = {0};
+   bool ctx_coeff = false;
+   ConvectionOperatorInfo(const mfem::FiniteElementSpace &fes,
+                          mfem::VectorCoefficient *VQ, double alpha,
+                          bool use_bdr = false, bool use_mf = false)
    {
+      MFEM_VERIFY(VQ && VQ->GetVDim() == fes.GetMesh()->SpaceDimension(),
+                  "Incorrect coefficient dimensions in ceed::ConvectionOperatorInfo!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      ctx.alpha = alpha;
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_conv";
+         apply_qf = &f_apply_conv;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(VQ))
+      {
+         ctx_coeff = true;
+         const int vdim = VQ->GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_CONV_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_const";
+            build_qf = &f_build_conv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_const";
+            apply_qf = &f_apply_conv_mf_const;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_quad";
+            build_qf = &f_build_conv_quad;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_quad";
+            apply_qf = &f_apply_conv_mf_quad;
+         }
+      }
       header = "/integrators/convection/convection_qf.h";
-      build_func_const = ":f_build_conv_const";
-      build_qf_const = &f_build_conv_const;
-      build_func_quad = ":f_build_conv_quad";
-      build_qf_quad = &f_build_conv_quad;
-      apply_func = ":f_apply_conv";
-      apply_qf = &f_apply_conv;
-      apply_func_mf_const = ":f_apply_conv_mf_const";
-      apply_qf_mf_const = &f_apply_conv_mf_const;
-      apply_func_mf_quad = ":f_apply_conv_mf_quad";
-      apply_qf_mf_quad = &f_apply_conv_mf_quad;
       trial_op = EvalMode::Grad;
       test_op = EvalMode::Interp;
-      qdatasize = dim * (dim + 1) / 2;
-      ctx.alpha = alpha;
+      qdatasize = ctx.dim;
    }
 };
 #endif
 
 PAConvectionIntegrator::PAConvectionIntegrator(
+   const mfem::ConvectionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::VectorCoefficient *Q,
-   const double alpha)
-   : PAIntegrator()
-{
-#ifdef MFEM_USE_CEED
-   ConvectionOperatorInfo info(fes.GetMesh()->Dimension(), alpha);
-   Assemble(info, fes, irm, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedPAConvectionIntegrator::MixedPAConvectionIntegrator(
-   const ConvectionIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::VectorCoefficient *Q,
-   const double alpha)
+   mfem::VectorCoefficient *VQ,
+   const double alpha,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   ConvectionOperatorInfo info(fes.GetMesh()->Dimension(), alpha);
-   Assemble(integ, info, fes, Q);
+   ConvectionOperatorInfo info(fes, VQ, alpha, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? VQ : nullptr, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
 MFConvectionIntegrator::MFConvectionIntegrator(
+   const mfem::ConvectionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::VectorCoefficient *Q,
-   const double alpha)
-   : MFIntegrator()
-{
-#ifdef MFEM_USE_CEED
-   ConvectionOperatorInfo info(fes.GetMesh()->Dimension(), alpha);
-   Assemble(info, fes, irm, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedMFConvectionIntegrator::MixedMFConvectionIntegrator(
-   const ConvectionIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::VectorCoefficient *Q,
-   const double alpha)
+   mfem::VectorCoefficient *VQ,
+   const double alpha,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   ConvectionOperatorInfo info(fes.GetMesh()->Dimension(), alpha);
-   Assemble(integ, info, fes, Q);
+   ConvectionOperatorInfo info(fes, VQ, alpha, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? VQ : nullptr, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
diff --git a/fem/ceed/integrators/convection/convection.hpp b/fem/ceed/integrators/convection/convection.hpp
index 1cd968770..713b98c2c 100644
--- a/fem/ceed/integrators/convection/convection.hpp
+++ b/fem/ceed/integrators/convection/convection.hpp
@@ -13,7 +13,7 @@
 #define MFEM_LIBCEED_CONV_HPP
 
 #include "../../interface/integrator.hpp"
-#include "../../interface/mixed_integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
 #include "../../../fespace.hpp"
 
 namespace mfem
@@ -23,41 +23,25 @@ namespace ceed
 {
 
 /// Represent a ConvectionIntegrator with AssemblyLevel::Partial using libCEED.
-class PAConvectionIntegrator : public PAIntegrator
+class PAConvectionIntegrator : public MixedOperator<Integrator>
 {
 public:
-   PAConvectionIntegrator(const mfem::FiniteElementSpace &fes,
-                          const mfem::IntegrationRule &ir,
-                          mfem::VectorCoefficient *Q,
-                          const double alpha);
-};
-
-class MixedPAConvectionIntegrator : public MixedIntegrator<PAIntegrator>
-{
-public:
-   MixedPAConvectionIntegrator(const ConvectionIntegrator &integ,
-                               const mfem::FiniteElementSpace &fes,
-                               mfem::VectorCoefficient *Q,
-                               const double alpha);
+   PAConvectionIntegrator(const mfem::ConvectionIntegrator &integ,
+                          const mfem::FiniteElementSpace &fes,
+                          mfem::VectorCoefficient *VQ,
+                          const double alpha,
+                          const bool use_bdr = false);
 };
 
 /// Represent a ConvectionIntegrator with AssemblyLevel::None using libCEED.
-class MFConvectionIntegrator : public MFIntegrator
-{
-public:
-   MFConvectionIntegrator(const mfem::FiniteElementSpace &fes,
-                          const mfem::IntegrationRule &ir,
-                          mfem::VectorCoefficient *Q,
-                          const double alpha);
-};
-
-class MixedMFConvectionIntegrator : public MixedIntegrator<MFIntegrator>
+class MFConvectionIntegrator : public MixedOperator<Integrator>
 {
 public:
-   MixedMFConvectionIntegrator(const ConvectionIntegrator &integ,
-                               const mfem::FiniteElementSpace &fes,
-                               mfem::VectorCoefficient *Q,
-                               const double alpha);
+   MFConvectionIntegrator(const mfem::ConvectionIntegrator &integ,
+                          const mfem::FiniteElementSpace &fes,
+                          mfem::VectorCoefficient *VQ,
+                          const double alpha,
+                          const bool use_bdr = false);
 };
 
 }
diff --git a/fem/ceed/integrators/convection/convection_qf.h b/fem/ceed/integrators/convection/convection_qf.h
index 68e96895e..0dd11387c 100644
--- a/fem/ceed/integrators/convection/convection_qf.h
+++ b/fem/ceed/integrators/convection/convection_qf.h
@@ -9,207 +9,151 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-/// A structure used to pass additional data to f_build_conv and f_apply_conv
-struct ConvectionContext {
-   CeedInt dim, space_dim, vdim;
-   CeedScalar coeff[3];
+#ifndef MFEM_LIBCEED_CONV_QF_H
+#define MFEM_LIBCEED_CONV_QF_H
+
+#include "../util/util_qf.h"
+
+#define LIBCEED_CONV_COEFF_COMP_MAX 3
+
+struct ConvectionContext
+{
+   CeedInt dim, space_dim;
    CeedScalar alpha;
+   CeedScalar coeff[LIBCEED_CONV_COEFF_COMP_MAX];
 };
 
-/// libCEED Q-function for building quadrature data for a convection operator
+/// libCEED QFunction for building quadrature data for a convection operator
 /// with a constant coefficient
 CEED_QFUNCTION(f_build_conv_const)(void *ctx, CeedInt Q,
                                    const CeedScalar *const *in,
                                    CeedScalar *const *out)
 {
-   ConvectionContext *bc = (ConvectionContext*)ctx;
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
+   ConvectionContext *bc = (ConvectionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[1] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute and store qw * adj(J).
-   const CeedScalar coeff0 = bc->coeff[0];
-   const CeedScalar coeff1 = bc->coeff[1];
-   const CeedScalar coeff2 = bc->coeff[2];
+   // At every quadrature point, compute and store qw *  * c^T adj(J)^T
    const CeedScalar alpha  = bc->alpha;
+   const CeedScalar *coeff = bc->coeff;
    const CeedScalar *J = in[0], *qw = in[1];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            qd[i] = alpha * coeff0 * qw[i] * J[i];
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * alpha * coeff0 * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultCtAdjJt21(J + i, Q, coeff, 1, qw[i] * alpha, Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultCtAdjJt22(J + i, Q, coeff, 1, qw[i] * alpha, Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            qd[i + Q * 0] =  wx * J22 - wy * J12;
-            qd[i + Q * 1] = -wx * J21 + wy * J11;
+            MultCtAdjJt32(J + i, Q, coeff, 1, qw[i] * alpha, Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar wz = w * coeff2;
-            qd[i + Q * 0] = wx * A11 + wy * A12 + wz * A13;
-            qd[i + Q * 1] = wx * A21 + wy * A22 + wz * A23;
-            qd[i + Q * 2] = wx * A31 + wy * A32 + wz * A33;
+            MultCtAdjJt33(J + i, Q, coeff, 1, qw[i] * alpha, Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for building quadrature data for a convection operator
-/// coefficient evaluated at quadrature points.
+/// libCEED QFunction for building quadrature data for a convection operator
+/// with a coefficient evaluated at quadrature points
 CEED_QFUNCTION(f_build_conv_quad)(void *ctx, CeedInt Q,
                                   const CeedScalar *const *in,
                                   CeedScalar *const *out)
 {
    ConvectionContext *bc = (ConvectionContext *)ctx;
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute and store qw * adj(J).
-   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   // At every quadrature point, compute and store qw *  * c^T adj(J)^T
    const CeedScalar alpha  = bc->alpha;
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar coeff = c[i];
-            qd[i] = alpha * coeff * qw[i] * J[i];
+            qd[i] = qw[i] * alpha * c[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultCtAdjJt21(J + i, Q, c + i, Q, qw[i] * alpha, Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            qd[i + Q * 0] =  wx * J22 - wy * J12;
-            qd[i + Q * 1] = -wx * J21 + wy * J11;
+            MultCtAdjJt22(J + i, Q, c + i, Q, qw[i] * alpha, Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultCtAdjJt32(J + i, Q, c + i, Q, qw[i] * alpha, Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar wz = w * c[i + Q * 2];
-            qd[i + Q * 0] = wx * A11 + wy * A12 + wz * A13;
-            qd[i + Q * 1] = wx * A21 + wy * A22 + wz * A23;
-            qd[i + Q * 2] = wx * A31 + wy * A32 + wz * A33;
+            MultCtAdjJt33(J + i, Q, c + i, Q, qw[i] * alpha, Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a conv operator
+/// libCEED QFunction for applying a convection operator
 CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
                              const CeedScalar *const *in,
                              CeedScalar *const *out)
 {
    ConvectionContext *bc = (ConvectionContext *)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
+   // in[0] has shape [dim, ncomp=1, Q]
+   // out[0] has shape [ncomp=1, Q]
    const CeedScalar *ug = in[0], *qd = in[1];
    CeedScalar *vg = out[0];
-   switch (10*bc->dim + bc->vdim)
+   switch (bc->dim)
    {
-      case 11:
-         for (CeedInt i = 0; i < Q; i++)
+      case 1:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            vg[i] = ug[i] * qd[i];
+            vg[i] = qd[i] * ug[i];
          }
          break;
-      case 21:
-         for (CeedInt i = 0; i < Q; i++)
+      case 2:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             vg[i] = qd[i + Q * 0] * ug0 + qd[i + Q * 1] * ug1;
          }
          break;
-      case 22:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            const CeedScalar qd0 = qd[i + Q * 0];
-            const CeedScalar qd1 = qd[i + Q * 1];
-            for (CeedInt c = 0; c < 2; c++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (c+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+2*1)];
-               vg[i + Q * c] = qd0 * ug0 + qd1 * ug1;
-            }
-         }
-         break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
+      case 3:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
@@ -217,313 +161,147 @@ CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
             vg[i] = qd[i + Q * 0] * ug0 + qd[i + Q * 1] * ug1 + qd[i + Q * 2] * ug2;
          }
          break;
-      case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            const CeedScalar qd0 = qd[i + Q * 0];
-            const CeedScalar qd1 = qd[i + Q * 1];
-            const CeedScalar qd2 = qd[i + Q * 2];
-            for (CeedInt c = 0; c < 3; c++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (c+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (c+3*2)];
-               vg[i + Q * c] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
-            }
-         }
-         break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a conv operator
+/// libCEED QFunction for applying a convection operator with a constant
+/// coefficient
 CEED_QFUNCTION(f_apply_conv_mf_const)(void *ctx, CeedInt Q,
                                       const CeedScalar *const *in,
                                       CeedScalar *const *out)
 {
-   ConvectionContext *bc = (ConvectionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   ConvectionContext *bc = (ConvectionContext *)ctx;
+   // in[0] has shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
+   // out[0] has shape [ncomp=1, Q]
    //
-   // At every quadrature point, compute qw * adj(J).
-   const CeedScalar coeff0 = bc->coeff[0];
-   const CeedScalar coeff1 = bc->coeff[1];
-   const CeedScalar coeff2 = bc->coeff[2];
+   // At every quadrature point, compute qw *  * c^T adj(J)^T
    const CeedScalar alpha  = bc->alpha;
+   const CeedScalar *coeff = bc->coeff;
    const CeedScalar *ug = in[0], *J = in[1], *qw = in[2];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = alpha * coeff0 * qw[i] * J[i];
-            vg[i] = ug[i] * qd;
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * alpha * coeff0 * J[i];
+            vg[i] = qd * ug[i];
          }
          break;
       case 21:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar qd0 =  wx * J22 - wy * J12;
-            const CeedScalar qd1 = -wx * J21 + wy * J11;
-            const CeedScalar ug0 = ug[i + Q * 0];
-            const CeedScalar ug1 = ug[i + Q * 1];
-            vg[i] = qd0 * ug0 + qd1 * ug1;
+            CeedScalar qd;
+            MultCtAdjJt21(J + i, Q, coeff, 1, qw[i] * alpha, 1, &qd);
+            vg[i] = qd * ug[i];
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar qd0 =  wx * J22 - wy * J12;
-            const CeedScalar qd1 = -wx * J21 + wy * J11;
-            for (CeedInt c = 0; c < 2; c++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (c+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+2*1)];
-               vg[i + Q * c] = qd0 * ug0 + qd1 * ug1;
-            }
+            CeedScalar qd[2];
+            MultCtAdjJt22(J + i, Q, coeff, 1, qw[i] * alpha, 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i] = qd[0] * ug0 + qd[1] * ug1;
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar wz = w * coeff2;
-            const CeedScalar qd0 = wx * A11 + wy * A12 + wz * A13;
-            const CeedScalar qd1 = wx * A21 + wy * A22 + wz * A23;
-            const CeedScalar qd2 = wx * A31 + wy * A32 + wz * A33;
+            CeedScalar qd[2];
+            MultCtAdjJt32(J + i, Q, coeff, 1, qw[i] * alpha, 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
-            const CeedScalar ug2 = ug[i + Q * 2];
-            vg[i] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
+            vg[i] = qd[0] * ug0 + qd[1] * ug1;
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * coeff0;
-            const CeedScalar wy = w * coeff1;
-            const CeedScalar wz = w * coeff2;
-            const CeedScalar qd0 = wx * A11 + wy * A12 + wz * A13;
-            const CeedScalar qd1 = wx * A21 + wy * A22 + wz * A23;
-            const CeedScalar qd2 = wx * A31 + wy * A32 + wz * A33;
-            for (CeedInt c = 0; c < 3; c++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (c+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (c+3*2)];
-               vg[i + Q * c] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
-            }
+            CeedScalar qd[3];
+            MultCtAdjJt33(J + i, Q, coeff, 1, qw[i] * alpha, 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
          }
          break;
    }
    return 0;
 }
 
+/// libCEED QFunction for applying a convection operator with a coefficient
+/// evaluated at quadrature points
 CEED_QFUNCTION(f_apply_conv_mf_quad)(void *ctx, CeedInt Q,
                                      const CeedScalar *const *in,
                                      CeedScalar *const *out)
 {
-   ConvectionContext *bc = (ConvectionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
-   // in[2] is quadrature weights, size (Q)
+   ConvectionContext *bc = (ConvectionContext *)ctx;
+   // in[0] has shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   // out[0] has shape [ncomp=1, Q]
    //
-   // At every quadrature point, compute qw * adj(J).
-   const CeedScalar *c = in[0], *ug = in[1], *J = in[2], *qw = in[3];
+   // At every quadrature point, compute qw *  * c^T adj(J)^T
    const CeedScalar alpha  = bc->alpha;
+   const CeedScalar *ug = in[0], *c = in[1], *J = in[2], *qw = in[3];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = alpha * c[i] * qw[i] * J[i];
-            vg[i] = ug[i] * qd;
+            const CeedScalar qd = qw[i] * alpha * c[i] * J[i];
+            vg[i] = qd * ug[i];
          }
          break;
       case 21:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar qd0 =  wx * J22 - wy * J12;
-            const CeedScalar qd1 = -wx * J21 + wy * J11;
-            const CeedScalar ug0 = ug[i + Q * 0];
-            const CeedScalar ug1 = ug[i + Q * 1];
-            vg[i] = qd0 * ug0 + qd1 * ug1;
+            CeedScalar qd;
+            MultCtAdjJt21(J + i, Q, c + i, Q, qw[i] * alpha, 1, &qd);
+            vg[i] = qd * ug[i];
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar qd0 =  wx * J22 - wy * J12;
-            const CeedScalar qd1 = -wx * J21 + wy * J11;
-            for (CeedInt d = 0; d < 2; d++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (d+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (d+2*1)];
-               vg[i + Q * d] = qd0 * ug0 + qd1 * ug1;
-            }
+            CeedScalar qd[2];
+            MultCtAdjJt22(J + i, Q, c + i, Q, qw[i] * alpha, 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i] = qd[0] * ug0 + qd[1] * ug1;
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar wz = w * c[i + Q * 2];
-            const CeedScalar qd0 = wx * A11 + wy * A12 + wz * A13;
-            const CeedScalar qd1 = wx * A21 + wy * A22 + wz * A23;
-            const CeedScalar qd2 = wx * A31 + wy * A32 + wz * A33;
+            CeedScalar qd[2];
+            MultCtAdjJt32(J + i, Q, c + i, Q, qw[i] * alpha, 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
-            const CeedScalar ug2 = ug[i + Q * 2];
-            vg[i] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
+            vg[i] = qd[0] * ug0 + qd[1] * ug1;
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = alpha * qw[i];
-            const CeedScalar wx = w * c[i + Q * 0];
-            const CeedScalar wy = w * c[i + Q * 1];
-            const CeedScalar wz = w * c[i + Q * 2];
-            const CeedScalar qd0 = wx * A11 + wy * A12 + wz * A13;
-            const CeedScalar qd1 = wx * A21 + wy * A22 + wz * A23;
-            const CeedScalar qd2 = wx * A31 + wy * A32 + wz * A33;
-            for (CeedInt d = 0; d < 3; d++)
-            {
-               const CeedScalar ug0 = ug[i + Q * (d+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (d+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (d+3*2)];
-               vg[i + Q * d] = qd0 * ug0 + qd1 * ug1 + qd2 * ug2;
-            }
+            CeedScalar qd[3];
+            MultCtAdjJt33(J + i, Q, c + i, Q, qw[i] * alpha, 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
          }
          break;
    }
    return 0;
 }
+
+#endif // MFEM_LIBCEED_CONV_QF_H
diff --git a/fem/ceed/integrators/curlcurl/curlcurl.cpp b/fem/ceed/integrators/curlcurl/curlcurl.cpp
new file mode 100644
index 000000000..0cc66b380
--- /dev/null
+++ b/fem/ceed/integrators/curlcurl/curlcurl.cpp
@@ -0,0 +1,249 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "curlcurl.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "curlcurl_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct CurlCurlOperatorInfo : public OperatorInfo
+{
+   CurlCurlContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType>
+   CurlCurlOperatorInfo(const mfem::FiniteElementSpace &fes, CoeffType *Q,
+                        bool use_bdr = false, bool use_mf = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      MFEM_VERIFY(ctx.dim == 2 || ctx.dim == 3,
+                  "CurlCurlIntegrator requires dim == 2 or dim == 3!");
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      ctx.curl_dim = (ctx.dim < 3) ? 1 : ctx.dim;
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_curlcurl";
+         apply_qf = &f_apply_curlcurl;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_scalar";
+            build_qf = &f_build_curlcurl_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_scalar";
+            apply_qf = &f_apply_curlcurl_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, use_mf);
+      }
+      header = "/integrators/curlcurl/curlcurl_qf.h";
+      trial_op = EvalMode::Curl;
+      test_op = EvalMode::Curl;
+      qdatasize = (ctx.curl_dim * (ctx.curl_dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_scalar";
+            build_qf = &f_build_curlcurl_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_scalar";
+            apply_qf = &f_apply_curlcurl_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_scalar";
+            build_qf = &f_build_curlcurl_quad_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_scalar";
+            apply_qf = &f_apply_curlcurl_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         ctx_coeff = true;
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_CURLCURL_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_vector";
+            build_qf = &f_build_curlcurl_const_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_vector";
+            apply_qf = &f_apply_curlcurl_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_vector";
+            build_qf = &f_build_curlcurl_quad_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_vector";
+            apply_qf = &f_apply_curlcurl_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         ctx_coeff = true;
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_CURLCURL_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_matrix";
+            build_qf = &f_build_curlcurl_const_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_matrix";
+            apply_qf = &f_apply_curlcurl_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_matrix";
+            build_qf = &f_build_curlcurl_quad_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_matrix";
+            apply_qf = &f_apply_curlcurl_mf_quad_matrix;
+         }
+      }
+   }
+};
+#endif
+
+template <typename CoeffType>
+PACurlCurlIntegrator::PACurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   CurlCurlOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFCurlCurlIntegrator::MFCurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   CurlCurlOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PACurlCurlIntegrator::PACurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template PACurlCurlIntegrator::PACurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template PACurlCurlIntegrator::PACurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template MFCurlCurlIntegrator::MFCurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template MFCurlCurlIntegrator::MFCurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template MFCurlCurlIntegrator::MFCurlCurlIntegrator(
+   const mfem::CurlCurlIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/curlcurl/curlcurl.hpp b/fem/ceed/integrators/curlcurl/curlcurl.hpp
new file mode 100644
index 000000000..71d62c915
--- /dev/null
+++ b/fem/ceed/integrators/curlcurl/curlcurl.hpp
@@ -0,0 +1,51 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_CURLCURL_HPP
+#define MFEM_LIBCEED_CURLCURL_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/// Represent a CurlCurlIntegrator with AssemblyLevel::Partial using libCEED.
+class PACurlCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PACurlCurlIntegrator(const mfem::CurlCurlIntegrator &integ,
+                        const mfem::FiniteElementSpace &fes,
+                        CoeffType *Q,
+                        const bool use_bdr = false);
+};
+
+/// Represent a CurlCurlIntegrator with AssemblyLevel::None using libCEED.
+class MFCurlCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFCurlCurlIntegrator(const mfem::CurlCurlIntegrator &integ,
+                        const mfem::FiniteElementSpace &fes,
+                        CoeffType *Q,
+                        const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_CURLCURL_HPP
diff --git a/fem/ceed/integrators/curlcurl/curlcurl_qf.h b/fem/ceed/integrators/curlcurl/curlcurl_qf.h
new file mode 100644
index 000000000..6fbace54b
--- /dev/null
+++ b/fem/ceed/integrators/curlcurl/curlcurl_qf.h
@@ -0,0 +1,479 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_CURLCURL_QF_H
+#define MFEM_LIBCEED_CURLCURL_QF_H
+
+#include "../util/util_qf.h"
+
+#define LIBCEED_CURLCURL_COEFF_COMP_MAX 6
+
+struct CurlCurlContext
+{
+   CeedInt dim, space_dim, curl_dim;
+   CeedScalar coeff[LIBCEED_CURLCURL_COEFF_COMP_MAX];
+};
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a scalar constant coefficient
+CEED_QFUNCTION(f_build_curlcurl_const_scalar)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 / DetJ22(J + i, Q);
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 / DetJ32(J + i, Q);
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a vector constant coefficient
+CEED_QFUNCTION(f_build_curlcurl_const_vector)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a matrix constant coefficient
+CEED_QFUNCTION(f_build_curlcurl_const_matrix)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_quad_scalar)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ22(J + i, Q);
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ32(J + i, Q);
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_quad_vector)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl operator
+/// with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_quad_matrix)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J and store the
+   // symmetric part of the result. In 2D, compute and store qw * c / det(J)
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator
+CEED_QFUNCTION(f_apply_curlcurl)(void *ctx, CeedInt Q,
+                                 const CeedScalar *const *in,
+                                 CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   const CeedScalar *uc = in[0], *qd = in[1];
+   CeedScalar *vc = out[0];
+   switch (10 * bc->dim + bc->curl_dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            vc[i] = qd[i] * uc[i];
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[i + Q * 0] * uc0 + qd[i + Q * 1] * uc1 + qd[i + Q * 2] * uc2;
+            vc[i + Q * 1] = qd[i + Q * 1] * uc0 + qd[i + Q * 3] * uc1 + qd[i + Q * 4] * uc2;
+            vc[i + Q * 2] = qd[i + Q * 2] * uc0 + qd[i + Q * 4] * uc1 + qd[i + Q * 5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a scalar constant
+/// coefficient
+CEED_QFUNCTION(f_apply_curlcurl_mf_const_scalar)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *uc = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 / DetJ22(J + i, Q);
+            vc[i] = qd * uc[i];
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 / DetJ32(J + i, Q);
+            vc[i] = qd * uc[i];
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a vector constant
+/// coefficient
+CEED_QFUNCTION(f_apply_curlcurl_mf_const_vector)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *uc = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a matrix constant
+/// coefficient
+CEED_QFUNCTION(f_apply_curlcurl_mf_const_matrix)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *uc = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a scalar
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_curlcurl_mf_quad_scalar)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *uc = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ22(J + i, Q);
+            vc[i] = qd * uc[i];
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ32(J + i, Q);
+            vc[i] = qd * uc[i];
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a vector
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_curlcurl_mf_quad_vector)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *uc = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl operator with a matrix
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_curlcurl_mf_quad_matrix)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   CurlCurlContext *bc = (CurlCurlContext *)ctx;
+   // in[0], out[0] have shape [curl_dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J
+   const CeedScalar *uc = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vc = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] = qd[0] * uc0 + qd[1] * uc1 + qd[2] * uc2;
+            vc[i + Q * 1] = qd[1] * uc0 + qd[3] * uc1 + qd[4] * uc2;
+            vc[i + Q * 2] = qd[2] * uc0 + qd[4] * uc1 + qd[5] * uc2;
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_CURLCURL_QF_H
diff --git a/fem/ceed/integrators/curlcurlmass/curlcurlmass.cpp b/fem/ceed/integrators/curlcurlmass/curlcurlmass.cpp
new file mode 100644
index 000000000..ad0327dda
--- /dev/null
+++ b/fem/ceed/integrators/curlcurlmass/curlcurlmass.cpp
@@ -0,0 +1,155 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "curlcurlmass.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "curlcurlmass_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct CurlCurlMassOperatorInfo : public OperatorInfo
+{
+   CurlCurlMassContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType1, typename CoeffType2>
+   CurlCurlMassOperatorInfo(const mfem::FiniteElementSpace &fes,
+                            CoeffType1 *Qd, CoeffType2 *Qm,
+                            bool use_bdr = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      MFEM_VERIFY(ctx.dim == 2 || ctx.dim == 3,
+                  "CurlCurlMassIntegrator requires dim == 2 or dim == 3!");
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      ctx.curl_dim = (ctx.dim < 3) ? 1 : ctx.dim;
+      apply_func = ":f_apply_curlcurl_mass";
+      apply_qf = &f_apply_curlcurl_mass;
+      // This integrator always has the coefficient stored as QFunction input.
+      MFEM_VERIFY(Qd && Qm, "libCEED CurlCurlMassIntegrator requires both a "
+                  "curl-curl and a mass integrator coefficient!");
+      InitCoefficients(*Qd, *Qm);
+      header = "/integrators/curlcurlmass/curlcurlmass_qf.h";
+      trial_op = EvalMode::InterpAndCurl;
+      test_op = EvalMode::InterpAndCurl;
+      qdatasize = (ctx.curl_dim * (ctx.curl_dim + 1)) / 2 +
+                  (ctx.dim * (ctx.dim + 1)) / 2;
+   }
+   void InitCoefficients(mfem::Coefficient &Qd, mfem::Coefficient &Qm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_scalar_scalar";
+      build_qf = &f_build_curlcurl_mass_quad_scalar_scalar;
+   }
+   void InitCoefficients(mfem::Coefficient &Qd, mfem::VectorCoefficient &VQm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_scalar_vector";
+      build_qf = &f_build_curlcurl_mass_quad_scalar_vector;
+   }
+   void InitCoefficients(mfem::Coefficient &Qd, mfem::MatrixCoefficient &MQm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_scalar_matrix";
+      build_qf = &f_build_curlcurl_mass_quad_scalar_matrix;
+   }
+   void InitCoefficients(mfem::VectorCoefficient &Qd, mfem::Coefficient &Qm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_vector_scalar";
+      build_qf = &f_build_curlcurl_mass_quad_vector_scalar;
+   }
+   void InitCoefficients(mfem::VectorCoefficient &Qd, mfem::VectorCoefficient &VQm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_vector_vector";
+      build_qf = &f_build_curlcurl_mass_quad_vector_vector;
+   }
+   void InitCoefficients(mfem::VectorCoefficient &Qd, mfem::MatrixCoefficient &MQm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_vector_matrix";
+      build_qf = &f_build_curlcurl_mass_quad_vector_matrix;
+   }
+   void InitCoefficients(mfem::MatrixCoefficient &Qd, mfem::Coefficient &Qm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_matrix_scalar";
+      build_qf = &f_build_curlcurl_mass_quad_matrix_scalar;
+   }
+   void InitCoefficients(mfem::MatrixCoefficient &Qd, mfem::VectorCoefficient &VQm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_matrix_vector";
+      build_qf = &f_build_curlcurl_mass_quad_matrix_vector;
+   }
+   void InitCoefficients(mfem::MatrixCoefficient &Qd, mfem::MatrixCoefficient &MQm)
+   {
+      build_func = ":f_build_curlcurl_mass_quad_matrix_matrix";
+      build_qf = &f_build_curlcurl_mass_quad_matrix_matrix;
+   }
+};
+#endif
+
+template <typename CoeffType1, typename CoeffType2>
+PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType1 *Qd,
+   CoeffType2 *Qm,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   CurlCurlMassOperatorInfo info(fes, Qd, Qm, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Qd : nullptr,
+            !info.ctx_coeff ? Qm : nullptr, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, mfem::Coefficient *, const bool);
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, mfem::VectorCoefficient *, const bool);
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, mfem::MatrixCoefficient *, const bool);
+
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, mfem::Coefficient *, const bool);
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, mfem::VectorCoefficient *, const bool);
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, mfem::MatrixCoefficient *, const bool);
+
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, mfem::Coefficient *, const bool);
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, mfem::VectorCoefficient *, const bool);
+template PACurlCurlMassIntegrator::PACurlCurlMassIntegrator(
+   const mfem::CurlCurlMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/curlcurlmass/curlcurlmass.hpp b/fem/ceed/integrators/curlcurlmass/curlcurlmass.hpp
new file mode 100644
index 000000000..e68d9c28b
--- /dev/null
+++ b/fem/ceed/integrators/curlcurlmass/curlcurlmass.hpp
@@ -0,0 +1,41 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_CURLCURL_MASS_HPP
+#define MFEM_LIBCEED_CURLCURL_MASS_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/// Represent a CurlCurlMassIntegrator with AssemblyLevel::Partial using libCEED.
+class PACurlCurlMassIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType1, typename CoeffType2>
+   PACurlCurlMassIntegrator(const mfem::CurlCurlMassIntegrator &integ,
+                            const mfem::FiniteElementSpace &fes,
+                            CoeffType1 *Qd,
+                            CoeffType2 *Qm,
+                            const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_CURLCURL_MASS_HPP
diff --git a/fem/ceed/integrators/curlcurlmass/curlcurlmass_qf.h b/fem/ceed/integrators/curlcurlmass/curlcurlmass_qf.h
new file mode 100644
index 000000000..a7cc2488d
--- /dev/null
+++ b/fem/ceed/integrators/curlcurlmass/curlcurlmass_qf.h
@@ -0,0 +1,432 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_CURLCURL_MASS_QF_H
+#define MFEM_LIBCEED_CURLCURL_MASS_QF_H
+
+#include "../util/util_qf.h"
+
+struct CurlCurlMassContext
+{
+   CeedInt dim, space_dim, curl_dim;
+};
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with scalar coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_scalar_scalar)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=1, Q]
+   // in[1] is mass coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ22(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ32(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 1, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with scalar and vector coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_scalar_vector)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=1, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ22(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, cm + i, Q, 2, qw[i], Q, qdm + i);
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ32(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 1, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with scalar and matrix coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_scalar_matrix)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=1, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ22(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ32(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, cm + i, Q, 6, qw[i], Q, qdm + i);
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 1, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 6, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with vector and scalar coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_vector_scalar)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is mass coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 3, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with vector coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_vector_vector)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 3, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with vector and matrix coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_vector_matrix)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 3, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 6, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with matrix and scalar coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_matrix_scalar)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is mass coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 6, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with matrix and vector coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_matrix_vector)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 6, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a curl-curl + mass
+/// operator with matrix coefficients evaluated at quadrature points
+CEED_QFUNCTION(f_build_curlcurl_mass_quad_matrix_matrix)(void *ctx, CeedInt Q,
+                                                         const CeedScalar *const *in,
+                                                         CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0] is curl-curl coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) J^T C J (3D) or
+   // qw * c / det(J) (2D) and qw/det(J) adj(J) C adj(J)^T and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0],
+               *qdm = out[0] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->curl_dim)
+   {
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cd + i, Q, 6, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cm + i, Q, 6, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a curl-curl + mass operator
+CEED_QFUNCTION(f_apply_curlcurl_mass)(void *ctx, CeedInt Q,
+                                      const CeedScalar *const *in,
+                                      CeedScalar *const *out)
+{
+   CurlCurlMassContext *bc = (CurlCurlMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1], out[1] have shape [curl_dim, ncomp=1, Q]
+   const CeedScalar *u = in[0], *uc = in[1], *qdd = in[2],
+                     *qdm = in[2] + bc->curl_dim * (bc->curl_dim + 1) / 2 * Q;
+   CeedScalar *v = out[0], *vc = out[1];
+   switch (10 * bc->dim + bc->curl_dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            vc[i] = qdd[i] * uc[i];
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qdm[i + Q * 0] * u0 + qdm[i + Q * 1] * u1;
+            v[i + Q * 1] = qdm[i + Q * 1] * u0 + qdm[i + Q * 2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar uc0 = uc[i + Q * 0];
+            const CeedScalar uc1 = uc[i + Q * 1];
+            const CeedScalar uc2 = uc[i + Q * 2];
+            vc[i + Q * 0] =
+               qdd[i + Q * 0] * uc0 + qdd[i + Q * 1] * uc1 + qdd[i + Q * 2] * uc2;
+            vc[i + Q * 1] =
+               qdd[i + Q * 1] * uc0 + qdd[i + Q * 3] * uc1 + qdd[i + Q * 4] * uc2;
+            vc[i + Q * 2] =
+               qdd[i + Q * 2] * uc0 + qdd[i + Q * 4] * uc1 + qdd[i + Q * 5] * uc2;
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qdm[i + Q * 0] * u0 + qdm[i + Q * 1] * u1 + qdm[i + Q * 2] * u2;
+            v[i + Q * 1] = qdm[i + Q * 1] * u0 + qdm[i + Q * 3] * u1 + qdm[i + Q * 4] * u2;
+            v[i + Q * 2] = qdm[i + Q * 2] * u0 + qdm[i + Q * 4] * u1 + qdm[i + Q * 5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_CURLCURL_MASS_QF_H
diff --git a/fem/ceed/integrators/diffusion/diffusion.cpp b/fem/ceed/integrators/diffusion/diffusion.cpp
index 4cd68669f..0650eabbb 100644
--- a/fem/ceed/integrators/diffusion/diffusion.cpp
+++ b/fem/ceed/integrators/diffusion/diffusion.cpp
@@ -25,106 +25,258 @@ namespace ceed
 #ifdef MFEM_USE_CEED
 struct DiffusionOperatorInfo : public OperatorInfo
 {
-   DiffusionContext ctx;
-   DiffusionOperatorInfo(int dim)
+   DiffusionContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType>
+   DiffusionOperatorInfo(const mfem::FiniteElementSpace &fes, CoeffType *Q,
+                         bool use_bdr = false, bool use_mf = false)
    {
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      ctx.vdim = fes.GetVDim();
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_diff";
+         apply_qf = &f_apply_diff;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_scalar";
+            build_qf = &f_build_diff_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_scalar";
+            apply_qf = &f_apply_diff_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, use_mf);
+      }
       header = "/integrators/diffusion/diffusion_qf.h";
-      build_func_const = ":f_build_diff_const";
-      build_qf_const = &f_build_diff_const;
-      build_func_quad = ":f_build_diff_quad";
-      build_qf_quad = &f_build_diff_quad;
-      apply_func = ":f_apply_diff";
-      apply_qf = &f_apply_diff;
-      apply_func_mf_const = ":f_apply_diff_mf_const";
-      apply_qf_mf_const = &f_apply_diff_mf_const;
-      apply_func_mf_quad = ":f_apply_diff_mf_quad";
-      apply_qf_mf_quad = &f_apply_diff_mf_quad;
       trial_op = EvalMode::Grad;
       test_op = EvalMode::Grad;
-      qdatasize = dim*(dim+1)/2;
+      qdatasize = (ctx.dim * (ctx.dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_scalar";
+            build_qf = &f_build_diff_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_scalar";
+            apply_qf = &f_apply_diff_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_scalar";
+            build_qf = &f_build_diff_quad_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_scalar";
+            apply_qf = &f_apply_diff_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         ctx_coeff = true;
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_DIFF_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_vector";
+            build_qf = &f_build_diff_const_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_vector";
+            apply_qf = &f_apply_diff_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_vector";
+            build_qf = &f_build_diff_quad_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_vector";
+            apply_qf = &f_apply_diff_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         ctx_coeff = true;
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_DIFF_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_matrix";
+            build_qf = &f_build_diff_const_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_matrix";
+            apply_qf = &f_apply_diff_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_matrix";
+            build_qf = &f_build_diff_quad_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_matrix";
+            apply_qf = &f_apply_diff_mf_quad_matrix;
+         }
+      }
    }
 };
 #endif
 
+template <typename CoeffType>
 PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::DiffusionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::Coefficient *Q)
-   : PAIntegrator()
+   CoeffType *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(info, fes, irm, Q);
+   DiffusionOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPADiffusionIntegrator::MixedPADiffusionIntegrator(
-   const DiffusionIntegrator &integ,
+template <typename CoeffType>
+PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::VectorDiffusionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
+   CoeffType *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
+   DiffusionOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPADiffusionIntegrator::MixedPADiffusionIntegrator(
-   const VectorDiffusionIntegrator &integ,
+template <typename CoeffType>
+MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::DiffusionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
+   CoeffType *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
+   DiffusionOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
+template <typename CoeffType>
 MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::VectorDiffusionIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::Coefficient *Q)
-   : MFIntegrator()
+   CoeffType *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(info, fes, irm, Q);
+   DiffusionOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedMFDiffusionIntegrator::MixedMFDiffusionIntegrator(
-   const DiffusionIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
+// @cond DOXYGEN_SKIP
 
-MixedMFDiffusionIntegrator::MixedMFDiffusionIntegrator(
-   const VectorDiffusionIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   DiffusionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
+template PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template PADiffusionIntegrator::PADiffusionIntegrator(
+   const mfem::VectorDiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+
+template MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::DiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template MFDiffusionIntegrator::MFDiffusionIntegrator(
+   const mfem::VectorDiffusionIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+
+// @endcond
 
 } // namespace ceed
 
diff --git a/fem/ceed/integrators/diffusion/diffusion.hpp b/fem/ceed/integrators/diffusion/diffusion.hpp
index dd28c9d16..b92710bad 100644
--- a/fem/ceed/integrators/diffusion/diffusion.hpp
+++ b/fem/ceed/integrators/diffusion/diffusion.hpp
@@ -13,7 +13,7 @@
 #define MFEM_LIBCEED_DIFF_HPP
 
 #include "../../interface/integrator.hpp"
-#include "../../interface/mixed_integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
 #include "../../../fespace.hpp"
 
 namespace mfem
@@ -23,45 +23,37 @@ namespace ceed
 {
 
 /// Represent a DiffusionIntegrator with AssemblyLevel::Partial using libCEED.
-class PADiffusionIntegrator : public PAIntegrator
+class PADiffusionIntegrator : public MixedOperator<Integrator>
 {
 public:
-   PADiffusionIntegrator(const mfem::FiniteElementSpace &fes,
-                         const mfem::IntegrationRule &ir,
-                         mfem::Coefficient *Q);
-};
-
-class MixedPADiffusionIntegrator : public MixedIntegrator<PAIntegrator>
-{
-public:
-   MixedPADiffusionIntegrator(const DiffusionIntegrator &integ,
-                              const mfem::FiniteElementSpace &fes,
-                              mfem::Coefficient *Q);
-
-   MixedPADiffusionIntegrator(const VectorDiffusionIntegrator &integ,
-                              const mfem::FiniteElementSpace &fes,
-                              mfem::Coefficient *Q);
+   template <typename CoeffType>
+   PADiffusionIntegrator(const mfem::DiffusionIntegrator &integ,
+                         const mfem::FiniteElementSpace &fes,
+                         CoeffType *Q,
+                         const bool use_bdr = false);
+
+   template <typename CoeffType>
+   PADiffusionIntegrator(const mfem::VectorDiffusionIntegrator &integ,
+                         const mfem::FiniteElementSpace &fes,
+                         CoeffType *Q,
+                         const bool use_bdr = false);
 };
 
 /// Represent a DiffusionIntegrator with AssemblyLevel::None using libCEED.
-class MFDiffusionIntegrator : public MFIntegrator
+class MFDiffusionIntegrator : public MixedOperator<Integrator>
 {
 public:
-   MFDiffusionIntegrator(const mfem::FiniteElementSpace &fes,
-                         const mfem::IntegrationRule &ir,
-                         mfem::Coefficient *Q);
-};
-
-class MixedMFDiffusionIntegrator : public MixedIntegrator<MFIntegrator>
-{
-public:
-   MixedMFDiffusionIntegrator(const DiffusionIntegrator &integ,
-                              const mfem::FiniteElementSpace &fes,
-                              mfem::Coefficient *Q);
-
-   MixedMFDiffusionIntegrator(const VectorDiffusionIntegrator &integ,
-                              const mfem::FiniteElementSpace &fes,
-                              mfem::Coefficient *Q);
+   template <typename CoeffType>
+   MFDiffusionIntegrator(const mfem::DiffusionIntegrator &integ,
+                         const mfem::FiniteElementSpace &fes,
+                         CoeffType *Q,
+                         const bool use_bdr = false);
+
+   template <typename CoeffType>
+   MFDiffusionIntegrator(const mfem::VectorDiffusionIntegrator &integ,
+                         const mfem::FiniteElementSpace &fes,
+                         CoeffType *Q,
+                         const bool use_bdr = false);
 };
 
 }
diff --git a/fem/ceed/integrators/diffusion/diffusion_qf.h b/fem/ceed/integrators/diffusion/diffusion_qf.h
index aa4850e37..9ab50a3ed 100644
--- a/fem/ceed/integrators/diffusion/diffusion_qf.h
+++ b/fem/ceed/integrators/diffusion/diffusion_qf.h
@@ -9,180 +9,331 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
+#ifndef MFEM_LIBCEED_DIFF_QF_H
+#define MFEM_LIBCEED_DIFF_QF_H
 
-/// A structure used to pass additional data to f_build_diff and f_apply_diff
-struct DiffusionContext { CeedInt dim, space_dim, vdim; CeedScalar coeff; };
+#include "../util/util_qf.h"
 
-/// libCEED Q-function for building quadrature data for a diffusion operator
-/// with a constant coefficient
-CEED_QFUNCTION(f_build_diff_const)(void *ctx, CeedInt Q,
-                                   const CeedScalar *const *in,
-                                   CeedScalar *const *out)
+#define LIBCEED_DIFF_COEFF_COMP_MAX 6
+
+struct DiffusionContext
+{
+   CeedInt dim, space_dim, vdim;
+   CeedScalar coeff[LIBCEED_DIFF_COEFF_COMP_MAX];
+};
+
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a scalar constant coefficient
+CEED_QFUNCTION(f_build_diff_const_scalar)(void *ctx, CeedInt Q,
+                                          const CeedScalar *const *in,
+                                          CeedScalar *const *out)
 {
-   DiffusionContext *bc = (DiffusionContext*)ctx;
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[1] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute qw/det(J).adj(J).adj(J)^T and store
-   // the symmetric part of the result.
-   const CeedScalar coeff = bc->coeff;
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *coeff = bc->coeff;
    const CeedScalar *J = in[0], *qw = in[1];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a vector constant coefficient
+CEED_QFUNCTION(f_build_diff_const_vector)(void *ctx, CeedInt Q,
+                                          const CeedScalar *const *in,
+                                          CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a matrix constant coefficient
+CEED_QFUNCTION(f_build_diff_const_matrix)(void *ctx, CeedInt Q,
+                                          const CeedScalar *const *in,
+                                          CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            qd[i] = coeff * qw[i] / J[i];
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
-            qd[i + Q * 0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[i + Q * 1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[i + Q * 2] =   coeff * w * (J11 * J11 + J21 * J21);
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
-            qd[i + Q * 0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[i + Q * 1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[i + Q * 2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[i + Q * 3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[i + Q * 4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[i + Q * 5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for building quadrature data for a diffusion operator
-/// coefficient evaluated at quadrature points.
-CEED_QFUNCTION(f_build_diff_quad)(void *ctx, CeedInt Q,
-                                  const CeedScalar *const *in,
-                                  CeedScalar *const *out)
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_quad_scalar)(void *ctx, CeedInt Q,
+                                         const CeedScalar *const *in,
+                                         CeedScalar *const *out)
 {
    DiffusionContext *bc = (DiffusionContext *)ctx;
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   // in[0] is coefficients with shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute qw/det(J).adj(J).adj(J)^T and store
-   // the symmetric part of the result.
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
    const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            qd[i] = c[i] * qw[i] / J[i];
+            qd[i] = qw[i] * c[i] / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar coeff = c[i];
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
-            qd[i + Q * 0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[i + Q * 1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[i + Q * 2] =   coeff * w * (J11 * J11 + J21 * J21);
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar coeff = c[i];
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
-            qd[i + Q * 0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[i + Q * 1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[i + Q * 2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[i + Q * 3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[i + Q * 4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[i + Q * 5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a diff operator
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_quad_vector)(void *ctx, CeedInt Q,
+                                         const CeedScalar *const *in,
+                                         CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a diffusion operator
+/// with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_quad_matrix)(void *ctx, CeedInt Q,
+                                         const CeedScalar *const *in,
+                                         CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and store
+   // the symmetric part of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a diffusion operator
 CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
                              const CeedScalar *const *in,
                              CeedScalar *const *out)
 {
    DiffusionContext *bc = (DiffusionContext *)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
    const CeedScalar *ug = in[0], *qd = in[1];
    CeedScalar *vg = out[0];
-   switch (10*bc->dim + bc->vdim)
+   switch (10 * bc->dim + bc->vdim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            vg[i] = ug[i] * qd[i];
+            vg[i] = qd[i] * ug[i];
+         }
+         break;
+      case 12:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd0 = qd[i];
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd0 * ug[i + Q * d];
+            }
          }
          break;
       case 21:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
@@ -191,23 +342,23 @@ CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar qd00 = qd[i + Q * 0];
             const CeedScalar qd01 = qd[i + Q * 1];
             const CeedScalar qd10 = qd01;
             const CeedScalar qd11 = qd[i + Q * 2];
-            for (CeedInt c = 0; c < 2; c++)
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (c+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+2*1)];
-               vg[i + Q * (c+2*0)] = qd00 * ug0 + qd01 * ug1;
-               vg[i + Q * (c+2*1)] = qd10 * ug0 + qd11 * ug1;
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd00 * ug0 + qd01 * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd10 * ug0 + qd11 * ug1;
             }
          }
          break;
       case 31:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
@@ -217,8 +368,24 @@ CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
             vg[i + Q * 2] = qd[i + Q * 2] * ug0 + qd[i + Q * 4] * ug1 + qd[i + Q * 5] * ug2;
          }
          break;
+      case 23:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd00 = qd[i + Q * 0];
+            const CeedScalar qd01 = qd[i + Q * 1];
+            const CeedScalar qd10 = qd01;
+            const CeedScalar qd11 = qd[i + Q * 2];
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd00 * ug0 + qd01 * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd10 * ug0 + qd11 * ug1;
+            }
+         }
+         break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar qd00 = qd[i + Q * 0];
             const CeedScalar qd01 = qd[i + Q * 1];
@@ -229,14 +396,14 @@ CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
             const CeedScalar qd20 = qd02;
             const CeedScalar qd21 = qd12;
             const CeedScalar qd22 = qd[i + Q * 5];
-            for (CeedInt c = 0; c < 3; c++)
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (c+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (c+3*2)];
-               vg[i + Q * (c+3*0)] = qd00 * ug0 + qd01 * ug1 + qd02 * ug2;
-               vg[i + Q * (c+3*1)] = qd10 * ug0 + qd11 * ug1 + qd12 * ug2;
-               vg[i + Q * (c+3*2)] = qd20 * ug0 + qd21 * ug1 + qd22 * ug2;
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd00 * ug0 + qd01 * ug1 + qd02 * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd10 * ug0 + qd11 * ug1 + qd12 * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd20 * ug0 + qd21 * ug1 + qd22 * ug2;
             }
          }
          break;
@@ -244,104 +411,105 @@ CEED_QFUNCTION(f_apply_diff)(void *ctx, CeedInt Q,
    return 0;
 }
 
-/// libCEED Q-function for applying a diff operator
-CEED_QFUNCTION(f_apply_diff_mf_const)(void *ctx, CeedInt Q,
-                                      const CeedScalar *const *in,
-                                      CeedScalar *const *out)
+/// libCEED QFunction for applying a diffusion operator with a scalar constant
+/// coefficient
+CEED_QFUNCTION(f_apply_diff_mf_const_scalar)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
 {
-   DiffusionContext *bc = (DiffusionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute qw/det(J).adj(J).adj(J)^T
-   const CeedScalar coeff = bc->coeff;
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *coeff = bc->coeff;
    const CeedScalar *ug = in[0], *J = in[1], *qw = in[2];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
    {
-      case 11:
-         for (CeedInt i = 0; i < Q; i++)
+      case 111:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = coeff * qw[i] / J[i];
-            vg[i] = ug[i] * qd;
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 / J[i];
+            vg[i] = qd * ug[i];
          }
          break;
-      case 21:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[3];
-            qd[0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[2] =   coeff * w * (J11 * J11 + J21 * J21);
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
             vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
          }
          break;
-      case 22:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[3];
-            qd[0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[2] =   coeff * w * (J11 * J11 + J21 * J21);
-            for (CeedInt c = 0; c < 2; c++)
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (c+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+2*1)];
-               vg[i + Q * (c+2*0)] = qd[0] * ug0 + qd[1] * ug1;
-               vg[i + Q * (c+2*1)] = qd[1] * ug0 + qd[2] * ug1;
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
             }
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[6];
-            qd[0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             const CeedScalar ug2 = ug[i + Q * 2];
@@ -350,46 +518,19 @@ CEED_QFUNCTION(f_apply_diff_mf_const)(void *ctx, CeedInt Q,
             vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
          }
          break;
-      case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[6];
-            qd[0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
-            for (CeedInt c = 0; c < 3; c++)
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (c+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (c+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (c+3*2)];
-               vg[i + Q * (c+3*0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
-               vg[i + Q * (c+3*1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
-               vg[i + Q * (c+3*2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
             }
          }
          break;
@@ -397,105 +538,97 @@ CEED_QFUNCTION(f_apply_diff_mf_const)(void *ctx, CeedInt Q,
    return 0;
 }
 
-CEED_QFUNCTION(f_apply_diff_mf_quad)(void *ctx, CeedInt Q,
-                                     const CeedScalar *const *in,
-                                     CeedScalar *const *out)
+/// libCEED QFunction for applying a diffusion operator with a vector constant
+/// coefficient
+CEED_QFUNCTION(f_apply_diff_mf_const_vector)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
 {
-   DiffusionContext *bc = (DiffusionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute qw/det(J).adj(J).adj(J)^T
-   const CeedScalar *c = in[0], *ug = in[1], *J = in[2], *qw = in[3];
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *ug = in[0], *J = in[1], *qw = in[2];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
    {
-      case 11:
-         for (CeedInt i = 0; i < Q; i++)
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = c[i] * qw[i] / J[i];
-            vg[i] = ug[i] * qd;
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
          }
          break;
-      case 21:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[3];
-            const CeedScalar coeff = c[i];
-            qd[0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[2] =   coeff * w * (J11 * J11 + J21 * J21);
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
             vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
          }
          break;
-      case 22:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 2   qd: 0 1   adj(J):  J22 -J12
-            //    1 3       1 2           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] / (J11 * J22 - J21 * J12);
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[3];
-            const CeedScalar coeff = c[i];
-            qd[0] =   coeff * w * (J12 * J12 + J22 * J22);
-            qd[1] = - coeff * w * (J11 * J12 + J21 * J22);
-            qd[2] =   coeff * w * (J11 * J11 + J21 * J21);
-            for (CeedInt d = 0; d < 2; d++)
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (d+2*0)];
-               const CeedScalar ug1 = ug[i + Q * (d+2*1)];
-               vg[i + Q * (d+2*0)] = qd[0] * ug0 + qd[1] * ug1;
-               vg[i + Q * (d+2*1)] = qd[1] * ug0 + qd[2] * ug1;
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
             }
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[6];
-            const CeedScalar coeff = c[i];
-            qd[0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
             const CeedScalar ug0 = ug[i + Q * 0];
             const CeedScalar ug1 = ug[i + Q * 1];
             const CeedScalar ug2 = ug[i + Q * 2];
@@ -504,50 +637,507 @@ CEED_QFUNCTION(f_apply_diff_mf_quad)(void *ctx, CeedInt Q,
             vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
          }
          break;
-      case 33:
-         for (CeedInt i = 0; i < Q; i++)
-         {
-            // J: 0 3 6   qd: 0 1 2
-            //    1 4 7       1 3 4
-            //    2 5 8       2 4 5
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] / (J11 * A11 + J21 * A12 + J31 * A13);
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
             CeedScalar qd[6];
-            const CeedScalar coeff = c[i];
-            qd[0] = coeff * w * (A11 * A11 + A12 * A12 + A13 * A13);
-            qd[1] = coeff * w * (A11 * A21 + A12 * A22 + A13 * A23);
-            qd[2] = coeff * w * (A11 * A31 + A12 * A32 + A13 * A33);
-            qd[3] = coeff * w * (A21 * A21 + A22 * A22 + A23 * A23);
-            qd[4] = coeff * w * (A21 * A31 + A22 * A32 + A23 * A33);
-            qd[5] = coeff * w * (A31 * A31 + A32 * A32 + A33 * A33);
-            for (CeedInt d = 0; d < 3; d++)
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               const CeedScalar ug0 = ug[i + Q * (d+3*0)];
-               const CeedScalar ug1 = ug[i + Q * (d+3*1)];
-               const CeedScalar ug2 = ug[i + Q * (d+3*2)];
-               vg[i + Q * (d+3*0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
-               vg[i + Q * (d+3*1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
-               vg[i + Q * (d+3*2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
             }
          }
          break;
    }
    return 0;
 }
+
+/// libCEED QFunction for applying a diffusion operator with a matrix constant
+/// coefficient
+CEED_QFUNCTION(f_apply_diff_mf_const_matrix)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *ug = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vg = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
+   {
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+            vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+            }
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a diffusion operator with a scalar
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_diff_mf_quad_scalar)(void *ctx, CeedInt Q,
+                                            const CeedScalar *const *in,
+                                            CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *ug = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vg = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
+   {
+      case 111:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / J[i];
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+            vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+            }
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a diffusion operator with a vector
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_diff_mf_quad_vector)(void *ctx, CeedInt Q,
+                                            const CeedScalar *const *in,
+                                            CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *ug = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vg = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
+   {
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+            vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+            }
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a diffusion operator with a matrix
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_diff_mf_quad_matrix)(void *ctx, CeedInt Q,
+                                            const CeedScalar *const *in,
+                                            CeedScalar *const *out)
+{
+   DiffusionContext *bc = (DiffusionContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=vdim, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T
+   const CeedScalar *ug = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vg = out[0];
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
+   {
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], 1, &qd);
+            vg[i] = qd * ug[i];
+         }
+         break;
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], 1, &qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               vg[i + Q * d] = qd * ug[i + Q * d];
+            }
+         }
+         break;
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 2 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 2 * 1)];
+               vg[i + Q * (d + 2 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 2 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[2] * ug1;
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[2] * ug1;
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i + Q * 0] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+            vg[i + Q * 1] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+            vg[i + Q * 2] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               const CeedScalar ug0 = ug[i + Q * (d + 3 * 0)];
+               const CeedScalar ug1 = ug[i + Q * (d + 3 * 1)];
+               const CeedScalar ug2 = ug[i + Q * (d + 3 * 2)];
+               vg[i + Q * (d + 3 * 0)] = qd[0] * ug0 + qd[1] * ug1 + qd[2] * ug2;
+               vg[i + Q * (d + 3 * 1)] = qd[1] * ug0 + qd[3] * ug1 + qd[4] * ug2;
+               vg[i + Q * (d + 3 * 2)] = qd[2] * ug0 + qd[4] * ug1 + qd[5] * ug2;
+            }
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_DIFF_QF_H
diff --git a/fem/ceed/integrators/diffusionmass/diffusionmass.cpp b/fem/ceed/integrators/diffusionmass/diffusionmass.cpp
new file mode 100644
index 000000000..36201dc1c
--- /dev/null
+++ b/fem/ceed/integrators/diffusionmass/diffusionmass.cpp
@@ -0,0 +1,100 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "diffusionmass.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "diffusionmass_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct DiffusionMassOperatorInfo : public OperatorInfo
+{
+   DiffusionMassContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType>
+   DiffusionMassOperatorInfo(const mfem::FiniteElementSpace &fes, CoeffType *Qd,
+                             mfem::Coefficient *Qm, bool use_bdr = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED DiffusionMassIntegrator for does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      apply_func = ":f_apply_diff_mass";
+      apply_qf = &f_apply_diff_mass;
+      // This integrator always has the coefficient stored as QFunction input.
+      MFEM_VERIFY(Qd && Qm, "libCEED DiffusionMassIntegrator requires both a "
+                  "diffusion and a mass integrator coefficient!");
+      InitCoefficients(*Qd, *Qm);
+      header = "/integrators/diffusionmass/diffusionmass_qf.h";
+      trial_op = EvalMode::InterpAndGrad;
+      test_op = EvalMode::InterpAndGrad;
+      qdatasize = (ctx.dim * (ctx.dim + 1)) / 2 + 1;
+   }
+   void InitCoefficients(mfem::Coefficient &Qd, mfem::Coefficient &Qm)
+   {
+      build_func = ":f_build_diff_mass_quad_scalar";
+      build_qf = &f_build_diff_mass_quad_scalar;
+   }
+   void InitCoefficients(mfem::VectorCoefficient &VQd, mfem::Coefficient &Qm)
+   {
+      build_func = ":f_build_diff_mass_quad_vector";
+      build_qf = &f_build_diff_mass_quad_vector;
+   }
+   void InitCoefficients(mfem::MatrixCoefficient &MQd, mfem::Coefficient &Qm)
+   {
+      build_func = ":f_build_diff_mass_quad_matrix";
+      build_qf = &f_build_diff_mass_quad_matrix;
+   }
+};
+#endif
+
+template <typename CoeffType>
+PADiffusionMassIntegrator::PADiffusionMassIntegrator(
+   const mfem::DiffusionMassIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType *Qd,
+   mfem::Coefficient *Qm,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   DiffusionMassOperatorInfo info(fes, Qd, Qm, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Qd : nullptr,
+            !info.ctx_coeff ? Qm : nullptr, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PADiffusionMassIntegrator::PADiffusionMassIntegrator(
+   const mfem::DiffusionMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, mfem::Coefficient *, const bool);
+template PADiffusionMassIntegrator::PADiffusionMassIntegrator(
+   const mfem::DiffusionMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, mfem::Coefficient *, const bool);
+template PADiffusionMassIntegrator::PADiffusionMassIntegrator(
+   const mfem::DiffusionMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, mfem::Coefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/diffusionmass/diffusionmass.hpp b/fem/ceed/integrators/diffusionmass/diffusionmass.hpp
new file mode 100644
index 000000000..f81a9266c
--- /dev/null
+++ b/fem/ceed/integrators/diffusionmass/diffusionmass.hpp
@@ -0,0 +1,42 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_DIFF_MASS_HPP
+#define MFEM_LIBCEED_DIFF_MASS_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/** Represent a DiffusionMassIntegrator with AssemblyLevel::Partial using
+    libCEED. */
+class PADiffusionMassIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PADiffusionMassIntegrator(const mfem::DiffusionMassIntegrator &integ,
+                             const mfem::FiniteElementSpace &fes,
+                             CoeffType *Qd,
+                             mfem::Coefficient *Qm,
+                             const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_DIFF_MASS_HPP
diff --git a/fem/ceed/integrators/diffusionmass/diffusionmass_qf.h b/fem/ceed/integrators/diffusionmass/diffusionmass_qf.h
new file mode 100644
index 000000000..a04a36e2c
--- /dev/null
+++ b/fem/ceed/integrators/diffusionmass/diffusionmass_qf.h
@@ -0,0 +1,268 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_DIFF_MASS_QF_H
+#define MFEM_LIBCEED_DIFF_MASS_QF_H
+
+#include "../util/util_qf.h"
+
+struct DiffusionMassContext
+{
+   CeedInt dim, space_dim;
+};
+
+/// libCEED QFunction for building quadrature data for a diffusion + mass
+/// operator with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_mass_quad_scalar)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   DiffusionMassContext *bc = (DiffusionMassContext *)ctx;
+   // in[0] is diffusion coefficients with shape [ncomp=1, Q]
+   // in[1] is mass coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and
+   // qw * c * det(J) and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0], *qdm = out[0] + bc->dim * (bc->dim + 1) / 2 * Q;
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / J[i];
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, cd + i, Q, 1, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ21(J + i, Q);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, cd + i, Q, 1, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, cd + i, Q, 1, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ32(J + i, Q);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cd + i, Q, 1, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ33(J + i, Q);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a diffusion + mass
+/// operator with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_mass_quad_vector)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   DiffusionMassContext *bc = (DiffusionMassContext *)ctx;
+   // in[0] is diffusion coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is mass coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and
+   // qw * c * det(J) and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0], *qdm = out[0] + bc->dim * (bc->dim + 1) / 2 * Q;
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, cd + i, Q, 2, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ21(J + i, Q);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, cd + i, Q, 2, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, cd + i, Q, 3, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ32(J + i, Q);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cd + i, Q, 3, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ33(J + i, Q);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a diffusion + mass
+/// operator with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_diff_mass_quad_matrix)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   DiffusionMassContext *bc = (DiffusionMassContext *)ctx;
+   // in[0] is diffusion coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is mass coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T and
+   // qw * c * det(J) and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0], *qdm = out[0] + bc->dim * (bc->dim + 1) / 2 * Q;
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, cd + i, Q, 3, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ21(J + i, Q);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, cd + i, Q, 3, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, cd + i, Q, 6, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ32(J + i, Q);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, cd + i, Q, 6, qw[i], Q, qdd + i);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * DetJ33(J + i, Q);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a diffusion + mass operator
+CEED_QFUNCTION(f_apply_diff_mass)(void *ctx, CeedInt Q,
+                                  const CeedScalar *const *in,
+                                  CeedScalar *const *out)
+{
+   DiffusionMassContext *bc = (DiffusionMassContext *)ctx;
+   // in[0], out[0] have shape [ncomp=1, Q]
+   // in[1], out[1] have shape [dim, ncomp=1, Q]
+   const CeedScalar *u = in[0], *ug = in[1], *qdd = in[2],
+                     *qdm = in[2] + bc->dim * (bc->dim + 1) / 2 * Q;
+   CeedScalar *v = out[0], *vg = out[1];
+   switch (bc->dim)
+   {
+      case 1:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            vg[i] = qdd[i] * ug[i];
+         }
+         break;
+      case 2:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            vg[i + Q * 0] = qdd[i + Q * 0] * ug0 + qdd[i + Q * 1] * ug1;
+            vg[i + Q * 1] = qdd[i + Q * 1] * ug0 + qdd[i + Q * 2] * ug1;
+         }
+         break;
+      case 3:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar ug0 = ug[i + Q * 0];
+            const CeedScalar ug1 = ug[i + Q * 1];
+            const CeedScalar ug2 = ug[i + Q * 2];
+            vg[i + Q * 0] =
+               qdd[i + Q * 0] * ug0 + qdd[i + Q * 1] * ug1 + qdd[i + Q * 2] * ug2;
+            vg[i + Q * 1] =
+               qdd[i + Q * 1] * ug0 + qdd[i + Q * 3] * ug1 + qdd[i + Q * 4] * ug2;
+            vg[i + Q * 2] =
+               qdd[i + Q * 2] * ug0 + qdd[i + Q * 4] * ug1 + qdd[i + Q * 5] * ug2;
+         }
+         break;
+   }
+   CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+   {
+      v[i] = qdm[i] * u[i];
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_DIFF_MASS_QF_H
diff --git a/fem/ceed/integrators/divdiv/divdiv.cpp b/fem/ceed/integrators/divdiv/divdiv.cpp
new file mode 100644
index 000000000..49ed27ca5
--- /dev/null
+++ b/fem/ceed/integrators/divdiv/divdiv.cpp
@@ -0,0 +1,127 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "divdiv.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "divdiv_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct DivDivOperatorInfo : public OperatorInfo
+{
+   DivDivContext ctx = {0};
+   bool ctx_coeff = false;
+   DivDivOperatorInfo(const mfem::FiniteElementSpace &fes, mfem::Coefficient *Q,
+                      bool use_bdr = false, bool use_mf = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_divdiv";
+         apply_qf = &f_apply_divdiv;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_divdiv_const";
+            build_qf = &f_build_divdiv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_divdiv_mf_const";
+            apply_qf = &f_apply_divdiv_mf_const;
+         }
+      }
+      else if (mfem::ConstantCoefficient *const_coeff =
+                  dynamic_cast<mfem::ConstantCoefficient *>(Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_divdiv_const";
+            build_qf = &f_build_divdiv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_divdiv_mf_const";
+            apply_qf = &f_apply_divdiv_mf_const;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_divdiv_quad";
+            build_qf = &f_build_divdiv_quad;
+         }
+         else
+         {
+            apply_func = ":f_apply_divdiv_mf_quad";
+            apply_qf = &f_apply_divdiv_mf_quad;
+         }
+      }
+      header = "/integrators/divdiv/divdiv_qf.h";
+      trial_op = EvalMode::Div;
+      test_op = EvalMode::Div;
+      qdatasize = 1;
+   }
+};
+#endif
+
+PADivDivIntegrator::PADivDivIntegrator(const mfem::DivDivIntegrator &integ,
+                                       const mfem::FiniteElementSpace &fes,
+                                       mfem::Coefficient *Q,
+                                       const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   DivDivOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+MFDivDivIntegrator::MFDivDivIntegrator(const mfem::DivDivIntegrator &integ,
+                                       const mfem::FiniteElementSpace &fes,
+                                       mfem::Coefficient *Q,
+                                       const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   DivDivOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/divdiv/divdiv.hpp b/fem/ceed/integrators/divdiv/divdiv.hpp
new file mode 100644
index 000000000..1e5bf163e
--- /dev/null
+++ b/fem/ceed/integrators/divdiv/divdiv.hpp
@@ -0,0 +1,49 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_DIVDIV_HPP
+#define MFEM_LIBCEED_DIVDIV_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/// Represent a DivDivIntegrator with AssemblyLevel::Partial using libCEED.
+class PADivDivIntegrator : public MixedOperator<Integrator>
+{
+public:
+   PADivDivIntegrator(const mfem::DivDivIntegrator &integ,
+                      const mfem::FiniteElementSpace &fes,
+                      mfem::Coefficient *Q,
+                      const bool use_bdr = false);
+};
+
+/// Represent a DivDivIntegrator with AssemblyLevel::None using libCEED.
+class MFDivDivIntegrator : public MixedOperator<Integrator>
+{
+public:
+   MFDivDivIntegrator(const mfem::DivDivIntegrator &integ,
+                      const mfem::FiniteElementSpace &fes,
+                      mfem::Coefficient *Q,
+                      const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_DIVDIV_HPP
diff --git a/fem/ceed/integrators/divdiv/divdiv_qf.h b/fem/ceed/integrators/divdiv/divdiv_qf.h
new file mode 100644
index 000000000..853aa0011
--- /dev/null
+++ b/fem/ceed/integrators/divdiv/divdiv_qf.h
@@ -0,0 +1,250 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_DIVDIV_QF_H
+#define MFEM_LIBCEED_DIVDIV_QF_H
+
+#include "../util/util_qf.h"
+
+struct DivDivContext
+{
+   CeedInt dim, space_dim;
+   CeedScalar coeff;
+};
+
+/// libCEED QFunction for building quadrature data for a div-div operator
+/// with a constant coefficient
+CEED_QFUNCTION(f_build_divdiv_const)(void *ctx, CeedInt Q,
+                                     const CeedScalar *const *in,
+                                     CeedScalar *const *out)
+{
+   DivDivContext *bc = (DivDivContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute and store qw * c / det(J)
+   const CeedScalar coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / DetJ21(J + i, Q);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / DetJ32(J + i, Q);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff / DetJ33(J + i, Q);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a div-div operator
+/// with a coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_divdiv_quad)(void *ctx, CeedInt Q,
+                                    const CeedScalar *const *in,
+                                    CeedScalar *const *out)
+{
+   DivDivContext *bc = (DivDivContext *)ctx;
+   // in[0] is coefficients, size (Q)
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute and store qw * c / det(J)
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ21(J + i, Q);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ32(J + i, Q);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / DetJ33(J + i, Q);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a div-div operator
+CEED_QFUNCTION(f_apply_divdiv)(void *ctx, CeedInt Q,
+                               const CeedScalar *const *in,
+                               CeedScalar *const *out)
+{
+   // in[0], out[0] have shape [ncomp=1, Q]
+   const CeedScalar *ud = in[0], *qd = in[1];
+   CeedScalar *vd = out[0];
+   CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+   {
+      vd[i] = qd[i] * ud[i];
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a div-div operator with a constant
+/// coefficient
+CEED_QFUNCTION(f_apply_divdiv_mf_const)(void *ctx, CeedInt Q,
+                                        const CeedScalar *const *in,
+                                        CeedScalar *const *out)
+{
+   DivDivContext *bc = (DivDivContext *)ctx;
+   // in[0], out[0] have shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c / det(J)
+   const CeedScalar coeff = bc->coeff;
+   const CeedScalar *ud = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *vd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / J[i];
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / DetJ21(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / DetJ22(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / DetJ32(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff / DetJ33(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a div-div operator with a coefficient
+/// evaluated at quadrature points
+CEED_QFUNCTION(f_apply_divdiv_mf_quad)(void *ctx, CeedInt Q,
+                                       const CeedScalar *const *in,
+                                       CeedScalar *const *out)
+{
+   DivDivContext *bc = (DivDivContext *)ctx;
+   // in[0], out[0] have shape [ncomp=1, Q]
+   // in[0] is coefficients, size (Q)
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c / det(J)
+   const CeedScalar *ud = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *vd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / J[i];
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ21(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ22(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ32(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / DetJ33(J + i, Q);
+            vd[i] = qd * ud[i];
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_DIVDIV_QF_H
diff --git a/fem/ceed/integrators/divdivmass/divdivmass.cpp b/fem/ceed/integrators/divdivmass/divdivmass.cpp
new file mode 100644
index 000000000..b6595752c
--- /dev/null
+++ b/fem/ceed/integrators/divdivmass/divdivmass.cpp
@@ -0,0 +1,101 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "divdivmass.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "divdivmass_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct DivDivMassOperatorInfo : public OperatorInfo
+{
+   DivDivMassContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType>
+   DivDivMassOperatorInfo(const mfem::FiniteElementSpace &fes,
+                          mfem::Coefficient *Qd, CoeffType *Qm,
+                          bool use_bdr = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      apply_func = ":f_apply_divdiv_mass";
+      apply_qf = &f_apply_divdiv_mass;
+      // This integrator always has the coefficient stored as QFunction input.
+      MFEM_VERIFY(Qd && Qm, "libCEED DivDivMassIntegrator requires both a "
+                  "div-div and a mass integrator coefficient!");
+      InitCoefficients(*Qd, *Qm);
+      header = "/integrators/divdivmass/divdivmass_qf.h";
+      trial_op = EvalMode::InterpAndDiv;
+      test_op = EvalMode::InterpAndDiv;
+      qdatasize = 1 + (ctx.dim * (ctx.dim + 1)) / 2;
+   }
+   void InitCoefficients(mfem::Coefficient &Qd, mfem::Coefficient &Qm)
+   {
+      build_func = ":f_build_divdiv_mass_quad_scalar";
+      build_qf = &f_build_divdiv_mass_quad_scalar;
+   }
+   void InitCoefficients(mfem::Coefficient &Qd, mfem::VectorCoefficient &VQm)
+   {
+      build_func = ":f_build_divdiv_mass_quad_vector";
+      build_qf = &f_build_divdiv_mass_quad_vector;
+   }
+   void InitCoefficients(mfem::Coefficient &Qd, mfem::MatrixCoefficient &MQm)
+   {
+      build_func = ":f_build_divdiv_mass_quad_matrix";
+      build_qf = &f_build_divdiv_mass_quad_matrix;
+   }
+};
+#endif
+
+template <typename CoeffType>
+PADivDivMassIntegrator::PADivDivMassIntegrator(
+   const mfem::DivDivMassIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   mfem::Coefficient *Qd,
+   CoeffType *Qm,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   DivDivMassOperatorInfo info(fes, Qd, Qm, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Qd : nullptr,
+            !info.ctx_coeff ? Qm : nullptr, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PADivDivMassIntegrator::PADivDivMassIntegrator(
+   const mfem::DivDivMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, mfem::Coefficient *, const bool);
+template PADivDivMassIntegrator::PADivDivMassIntegrator(
+   const mfem::DivDivMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, mfem::VectorCoefficient *, const bool);
+template PADivDivMassIntegrator::PADivDivMassIntegrator(
+   const mfem::DivDivMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/divdivmass/divdivmass.hpp b/fem/ceed/integrators/divdivmass/divdivmass.hpp
new file mode 100644
index 000000000..03f3d0c9b
--- /dev/null
+++ b/fem/ceed/integrators/divdivmass/divdivmass.hpp
@@ -0,0 +1,41 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_DIVDIV_MASS_HPP
+#define MFEM_LIBCEED_DIVDIV_MASS_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/// Represent a DivDivMassIntegrator with AssemblyLevel::Partial using libCEED.
+class PADivDivMassIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PADivDivMassIntegrator(const mfem::DivDivMassIntegrator &integ,
+                          const mfem::FiniteElementSpace &fes,
+                          mfem::Coefficient *Qd,
+                          CoeffType *Qm,
+                          const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_DIVDIV_MASS_HPP
diff --git a/fem/ceed/integrators/divdivmass/divdivmass_qf.h b/fem/ceed/integrators/divdivmass/divdivmass_qf.h
new file mode 100644
index 000000000..788bfc0b4
--- /dev/null
+++ b/fem/ceed/integrators/divdivmass/divdivmass_qf.h
@@ -0,0 +1,264 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_DIVDIV_MASS_QF_H
+#define MFEM_LIBCEED_DIVDIV_MASS_QF_H
+
+#include "../util/util_qf.h"
+
+struct DivDivMassContext
+{
+   CeedInt dim, space_dim;
+};
+
+/// libCEED QFunction for building quadrature data for a div-div + mass
+/// operator with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_divdiv_mass_quad_scalar)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   DivDivMassContext *bc = (DivDivMassContext *)ctx;
+   // in[0] is div-div coefficients with shape [ncomp=1, Q]
+   // in[1] is mass coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c / det(J) and
+   // qw/det(J) J^T C J and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0], *qdm = out[0] + Q;
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / J[i];
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdm[i] = qw[i] * cm[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ21(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ22(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ32(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ33(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cm + i, Q, 1, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a div-div + mass
+/// operator with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_divdiv_mass_quad_vector)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   DivDivMassContext *bc = (DivDivMassContext *)ctx;
+   // in[0] is div-div coefficients with shape [ncomp=1, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c / det(J) and
+   // qw/det(J) J^T C J and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0], *qdm = out[0] + Q;
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ21(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, cm + i, Q, 2, qw[i], Q, qdm + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ22(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, cm + i, Q, 2, qw[i], Q, qdm + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ32(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ33(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for a div-div + mass
+/// operator with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_divdiv_mass_quad_matrix)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   DivDivMassContext *bc = (DivDivMassContext *)ctx;
+   // in[0] is div-div coefficients with shape [ncomp=1, Q]
+   // in[1] is mass coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c / det(J) and
+   // qw/det(J) J^T C J and store the result
+   const CeedScalar *cd = in[0], *cm = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *qdd = out[0], *qdm = out[0] + Q;
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ21(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ22(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, cm + i, Q, 3, qw[i], Q, qdm + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ32(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, cm + i, Q, 6, qw[i], Q, qdm + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qdd[i] = qw[i] * cd[i] / DetJ33(J + i, Q);
+         }
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, cm + i, Q, 6, qw[i], Q, qdm + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a div-div + mass operator
+CEED_QFUNCTION(f_apply_divdiv_mass)(void *ctx, CeedInt Q,
+                                    const CeedScalar *const *in,
+                                    CeedScalar *const *out)
+{
+   DivDivMassContext *bc = (DivDivMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1], out[1] have shape [ncomp=1, Q]
+   const CeedScalar *u = in[0], *ud = in[1], *qdd = in[2], *qdm = in[2] + Q;
+   CeedScalar *v = out[0], *vd = out[1];
+   CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+   {
+      vd[i] = qdd[i] * ud[i];
+   }
+   switch (bc->dim)
+   {
+      case 1:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            v[i] = qdm[i] * u[i];
+         }
+         break;
+      case 2:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qdm[i + Q * 0] * u0 + qdm[i + Q * 1] * u1;
+            v[i + Q * 1] = qdm[i + Q * 1] * u0 + qdm[i + Q * 2] * u1;
+         }
+         break;
+      case 3:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qdm[i + Q * 0] * u0 + qdm[i + Q * 1] * u1 + qdm[i + Q * 2] * u2;
+            v[i + Q * 1] = qdm[i + Q * 1] * u0 + qdm[i + Q * 3] * u1 + qdm[i + Q * 4] * u2;
+            v[i + Q * 2] = qdm[i + Q * 2] * u0 + qdm[i + Q * 4] * u1 + qdm[i + Q * 5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_DIVDIV_MASS_QF_H
diff --git a/fem/ceed/integrators/interp/interp.cpp b/fem/ceed/integrators/interp/interp.cpp
new file mode 100644
index 000000000..6aab4f47f
--- /dev/null
+++ b/fem/ceed/integrators/interp/interp.cpp
@@ -0,0 +1,58 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "interp.hpp"
+
+#include "../../../../config/config.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct DiscreteInterpolatorOperatorInfo : public OperatorInfo
+{
+   DiscreteInterpolatorOperatorInfo()
+   {
+      // Discrete interpolators use a built-in QFunction
+      header = "";
+      header = "";
+      build_func = "";
+      build_qf = nullptr;
+      apply_func = "";
+      apply_qf = nullptr;
+      apply_func_mf = "";
+      apply_qf_mf = nullptr;
+      trial_op = EvalMode::Interp;
+      test_op = EvalMode::None;
+      qdatasize = 0;
+   }
+};
+#endif
+
+PADiscreteInterpolator::PADiscreteInterpolator(
+   const mfem::DiscreteInterpolator &interp,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes)
+{
+#ifdef MFEM_USE_CEED
+   DiscreteInterpolatorOperatorInfo info;
+   Assemble(interp, info, trial_fes, test_fes, (mfem::Coefficient *)nullptr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/solvers/full-assembly.hpp b/fem/ceed/integrators/interp/interp.hpp
similarity index 50%
rename from fem/ceed/solvers/full-assembly.hpp
rename to fem/ceed/integrators/interp/interp.hpp
index ed338f725..a923df572 100644
--- a/fem/ceed/solvers/full-assembly.hpp
+++ b/fem/ceed/integrators/interp/interp.hpp
@@ -9,12 +9,12 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#ifndef MFEM_CEED_ASSEMBLE_HPP
-#define MFEM_CEED_ASSEMBLE_HPP
+#ifndef MFEM_LIBCEED_INTERP_HPP
+#define MFEM_LIBCEED_INTERP_HPP
 
-#include "../interface/ceed.hpp"
-
-#ifdef MFEM_USE_CEED
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
 
 namespace mfem
 {
@@ -22,18 +22,19 @@ namespace mfem
 namespace ceed
 {
 
-/** @brief Assembles a CeedOperator as an mfem::SparseMatrix
-
-    In parallel, this assembles independently on each processor, that is, it
-    assembles at the L-vector level. The assembly procedure is always performed
-    on the host, but this works also for operators stored on device by copying
-    memory. */
-int CeedOperatorFullAssemble(CeedOperator op, SparseMatrix **mat);
-
-} // namespace ceed
+/** Represent DiscreteInterpolator classes with AssemblyLevel::Partial
+    using libCEED. */
+class PADiscreteInterpolator : public MixedOperator<Interpolator>
+{
+public:
+   PADiscreteInterpolator(
+      const mfem::DiscreteInterpolator &interp,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes);
+};
 
-} // namespace mfem
+}
 
-#endif
+}
 
-#endif
+#endif // MFEM_LIBCEED_INTERP_HPP
diff --git a/fem/ceed/integrators/mass/mass.cpp b/fem/ceed/integrators/mass/mass.cpp
index dfcc9a8ce..593d5faed 100644
--- a/fem/ceed/integrators/mass/mass.cpp
+++ b/fem/ceed/integrators/mass/mass.cpp
@@ -25,20 +25,69 @@ namespace ceed
 #ifdef MFEM_USE_CEED
 struct MassOperatorInfo : public OperatorInfo
 {
-   MassContext ctx;
-   MassOperatorInfo()
+   MassContext ctx = {0};
+   bool ctx_coeff = false;
+   MassOperatorInfo(const mfem::FiniteElementSpace &fes, mfem::Coefficient *Q,
+                    bool use_bdr = false, bool use_mf = false)
    {
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      ctx.vdim = fes.GetVDim();
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_mass";
+         apply_qf = &f_apply_mass;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_mass_const";
+            build_qf = &f_build_mass_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_mass_mf_const";
+            apply_qf = &f_apply_mass_mf_const;
+         }
+      }
+      else if (mfem::ConstantCoefficient *const_coeff =
+                  dynamic_cast<mfem::ConstantCoefficient *>(Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_mass_const";
+            build_qf = &f_build_mass_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_mass_mf_const";
+            apply_qf = &f_apply_mass_mf_const;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_mass_quad";
+            build_qf = &f_build_mass_quad;
+         }
+         else
+         {
+            apply_func = ":f_apply_mass_mf_quad";
+            apply_qf = &f_apply_mass_mf_quad;
+         }
+      }
       header = "/integrators/mass/mass_qf.h";
-      build_func_const = ":f_build_mass_const";
-      build_qf_const = &f_build_mass_const;
-      build_func_quad = ":f_build_mass_quad";
-      build_qf_quad = &f_build_mass_quad;
-      apply_func = ":f_apply_mass";
-      apply_qf = &f_apply_mass;
-      apply_func_mf_const = ":f_apply_mass_mf_const";
-      apply_qf_mf_const = &f_apply_mass_mf_const;
-      apply_func_mf_quad = ":f_apply_mass_mf_quad";
-      apply_qf_mf_quad = &f_apply_mass_mf_quad;
       trial_op = EvalMode::Interp;
       test_op = EvalMode::Interp;
       qdatasize = 1;
@@ -46,75 +95,53 @@ struct MassOperatorInfo : public OperatorInfo
 };
 #endif
 
-PAMassIntegrator::PAMassIntegrator(const mfem::FiniteElementSpace &fes,
-                                   const mfem::IntegrationRule &irm,
-                                   mfem::Coefficient *Q)
-   : PAIntegrator()
+PAMassIntegrator::PAMassIntegrator(const mfem::MassIntegrator &integ,
+                                   const mfem::FiniteElementSpace &fes,
+                                   mfem::Coefficient *Q,
+                                   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(info, fes, irm, Q);
+   MassOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPAMassIntegrator::MixedPAMassIntegrator(const MassIntegrator &integ,
-                                             const mfem::FiniteElementSpace &fes,
-                                             mfem::Coefficient *Q)
+PAMassIntegrator::PAMassIntegrator(const mfem::VectorMassIntegrator &integ,
+                                   const mfem::FiniteElementSpace &fes,
+                                   mfem::Coefficient *Q,
+                                   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(integ, info, fes, Q);
+   MassOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPAMassIntegrator::MixedPAMassIntegrator(const VectorMassIntegrator &integ,
-                                             const mfem::FiniteElementSpace &fes,
-                                             mfem::Coefficient *Q)
+MFMassIntegrator::MFMassIntegrator(const mfem::MassIntegrator &integ,
+                                   const mfem::FiniteElementSpace &fes,
+                                   mfem::Coefficient *Q,
+                                   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(integ, info, fes, Q);
+   MassOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MFMassIntegrator::MFMassIntegrator(const mfem::FiniteElementSpace &fes,
-                                   const mfem::IntegrationRule &irm,
-                                   mfem::Coefficient *Q)
-   : MFIntegrator()
+MFMassIntegrator::MFMassIntegrator(const mfem::VectorMassIntegrator &integ,
+                                   const mfem::FiniteElementSpace &fes,
+                                   mfem::Coefficient *Q,
+                                   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(info, fes, irm, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedMFMassIntegrator::MixedMFMassIntegrator(const MassIntegrator &integ,
-                                             const mfem::FiniteElementSpace &fes,
-                                             mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(integ, info, fes, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedMFMassIntegrator::MixedMFMassIntegrator(const VectorMassIntegrator &integ,
-                                             const mfem::FiniteElementSpace &fes,
-                                             mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   MassOperatorInfo info;
-   Assemble(integ, info, fes, Q);
+   MassOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
diff --git a/fem/ceed/integrators/mass/mass.hpp b/fem/ceed/integrators/mass/mass.hpp
index 696f8c3dc..4125fc6ed 100644
--- a/fem/ceed/integrators/mass/mass.hpp
+++ b/fem/ceed/integrators/mass/mass.hpp
@@ -13,7 +13,7 @@
 #define MFEM_LIBCEED_MASS_HPP
 
 #include "../../interface/integrator.hpp"
-#include "../../interface/mixed_integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
 #include "../../../fespace.hpp"
 
 namespace mfem
@@ -23,45 +23,33 @@ namespace ceed
 {
 
 /// Represent a MassIntegrator with AssemblyLevel::Partial using libCEED.
-class PAMassIntegrator : public PAIntegrator
+class PAMassIntegrator : public MixedOperator<Integrator>
 {
 public:
-   PAMassIntegrator(const mfem::FiniteElementSpace &fes,
-                    const mfem::IntegrationRule &ir,
-                    mfem::Coefficient *Q);
-};
-
-class MixedPAMassIntegrator : public MixedIntegrator<PAIntegrator>
-{
-public:
-   MixedPAMassIntegrator(const MassIntegrator &integ,
-                         const mfem::FiniteElementSpace &fes,
-                         mfem::Coefficient *Q);
-
-   MixedPAMassIntegrator(const VectorMassIntegrator &integ,
-                         const mfem::FiniteElementSpace &fes,
-                         mfem::Coefficient *Q);
+   PAMassIntegrator(const mfem::MassIntegrator &integ,
+                    const mfem::FiniteElementSpace &fes,
+                    mfem::Coefficient *Q,
+                    const bool use_bdr = false);
+
+   PAMassIntegrator(const mfem::VectorMassIntegrator &integ,
+                    const mfem::FiniteElementSpace &fes,
+                    mfem::Coefficient *Q,
+                    const bool use_bdr = false);
 };
 
 /// Represent a MassIntegrator with AssemblyLevel::None using libCEED.
-class MFMassIntegrator : public MFIntegrator
+class MFMassIntegrator : public MixedOperator<Integrator>
 {
 public:
-   MFMassIntegrator(const mfem::FiniteElementSpace &fes,
-                    const mfem::IntegrationRule &ir,
-                    mfem::Coefficient *Q);
-};
-
-class MixedMFMassIntegrator : public MixedIntegrator<MFIntegrator>
-{
-public:
-   MixedMFMassIntegrator(const MassIntegrator &integ,
-                         const mfem::FiniteElementSpace &fes,
-                         mfem::Coefficient *Q);
-
-   MixedMFMassIntegrator(const VectorMassIntegrator &integ,
-                         const mfem::FiniteElementSpace &fes,
-                         mfem::Coefficient *Q);
+   MFMassIntegrator(const mfem::MassIntegrator &integ,
+                    const mfem::FiniteElementSpace &fes,
+                    mfem::Coefficient *Q,
+                    const bool use_bdr = false);
+
+   MFMassIntegrator(const mfem::VectorMassIntegrator &integ,
+                    const mfem::FiniteElementSpace &fes,
+                    mfem::Coefficient *Q,
+                    const bool use_bdr = false);
 };
 
 }
diff --git a/fem/ceed/integrators/mass/mass_qf.h b/fem/ceed/integrators/mass/mass_qf.h
index 85002ae04..3cdd3b5e3 100644
--- a/fem/ceed/integrators/mass/mass_qf.h
+++ b/fem/ceed/integrators/mass/mass_qf.h
@@ -9,128 +9,151 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
+#ifndef MFEM_LIBCEED_MASS_QF_H
+#define MFEM_LIBCEED_MASS_QF_H
 
-/// A structure used to pass additional data to f_build_diff and f_apply_diff
-struct MassContext { CeedInt dim, space_dim, vdim; CeedScalar coeff; };
+#include "../util/util_qf.h"
 
-/// libCEED Q-function for building quadrature data for a mass operator with a
-/// constant coefficient
+struct MassContext
+{
+   CeedInt dim, space_dim, vdim;
+   CeedScalar coeff;
+};
+
+/// libCEED QFunction for building quadrature data for a mass operator
+/// with a constant coefficient
 CEED_QFUNCTION(f_build_mass_const)(void *ctx, CeedInt Q,
                                    const CeedScalar *const *in,
                                    CeedScalar *const *out)
 {
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute and store qw * c * det(J)
    MassContext *bc = (MassContext *)ctx;
    const CeedScalar coeff = bc->coeff;
    const CeedScalar *J = in[0], *qw = in[1];
-   CeedScalar *rho = out[0];
-   switch (bc->dim + 10*bc->space_dim)
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            rho[i] = coeff * J[i] * qw[i];
+            qd[i] = qw[i] * coeff * DetJ21(J + i, Q);
          }
          break;
       case 22:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            rho[i] = coeff * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
+            qd[i] = qw[i] * coeff * DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff * DetJ32(J + i, Q);
          }
          break;
       case 33:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            rho[i] = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                      J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                      J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * coeff * qw[i];
+            qd[i] = qw[i] * coeff * DetJ33(J + i, Q);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for building quadrature data for a mass operator with a
-/// coefficient evaluated at quadrature points.
+/// libCEED QFunction for building quadrature data for a mass operator
+/// with a coefficient evaluated at quadrature points
 CEED_QFUNCTION(f_build_mass_quad)(void *ctx, CeedInt Q,
                                   const CeedScalar *const *in,
                                   CeedScalar *const *out)
 {
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
-   // in[1] is quadrature weights, size (Q)
+   // in[0] is coefficients, size (Q)
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute and store qw * c * det(J)
    MassContext *bc = (MassContext *)ctx;
    const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
-   CeedScalar *rho = out[0];
-   switch (bc->dim + 10*bc->space_dim)
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            rho[i] = c[i] * J[i] * qw[i];
+            qd[i] = qw[i] * c[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] * DetJ21(J + i, Q);
          }
          break;
       case 22:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] * DetJ22(J + i, Q);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            rho[i] = c[i] * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
+            qd[i] = qw[i] * c[i] * DetJ32(J + i, Q);
          }
          break;
       case 33:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            rho[i] = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                      J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                      J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * c[i] * qw[i];
+            qd[i] = qw[i] * c[i] * DetJ33(J + i, Q);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a mass operator
+/// libCEED QFunction for applying a mass operator
 CEED_QFUNCTION(f_apply_mass)(void *ctx, CeedInt Q,
                              const CeedScalar *const *in,
                              CeedScalar *const *out)
 {
    MassContext *bc = (MassContext *)ctx;
-   const CeedScalar *u = in[0], *w = in[1];
+   // in[0], out[0] have shape [ncomp=vdim, Q]
+   const CeedScalar *u = in[0], *qd = in[1];
    CeedScalar *v = out[0];
    switch (bc->vdim)
    {
       case 1:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            v[i] = w[i] * u[i];
+            v[i] = qd[i] * u[i];
          }
          break;
       case 2:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar W = w[i];
-            for (CeedInt c = 0; c < 2; c++)
+            const CeedScalar qdi = qd[i];
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               v[i+c*Q] = W * u[i+c*Q];
+               v[i + d * Q] = qdi * u[i + d * Q];
             }
          }
          break;
       case 3:
-         for (CeedInt i=0; i<Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar W = w[i];
-            for (CeedInt c = 0; c < 3; c++)
+            const CeedScalar qdi = qd[i];
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               v[i+c*Q] = W * u[i+c*Q];
+               v[i + d * Q] = qdi * u[i + d * Q];
             }
          }
          break;
@@ -138,63 +161,95 @@ CEED_QFUNCTION(f_apply_mass)(void *ctx, CeedInt Q,
    return 0;
 }
 
-/// libCEED Q-function for applying a diff operator
+/// libCEED QFunction for applying a mass operator with a constant
+/// coefficient
 CEED_QFUNCTION(f_apply_mass_mf_const)(void *ctx, CeedInt Q,
-                                      const CeedScalar *const *in, CeedScalar *const *out)
+                                      const CeedScalar *const *in,
+                                      CeedScalar *const *out)
 {
-   MassContext *bc = (MassContext*)ctx;
+   MassContext *bc = (MassContext *)ctx;
+   // in[0], out[0] have shape [ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c * det(J)
    const CeedScalar coeff = bc->coeff;
    const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
    CeedScalar *v = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
    {
-      case 11:
-         for (CeedInt i = 0; i < Q; i++)
+      case 111:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar rho = coeff * qw[i] / J[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * coeff * J[i];
+            v[i] = qd * u[i];
          }
          break;
-      case 21:
-         for (CeedInt i = 0; i < Q; i++)
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar rho = coeff * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * coeff * DetJ21(J + i, Q);
+            v[i] = qd * u[i];
          }
          break;
-      case 22:
-         for (CeedInt i=0; i<Q; i++)
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            const CeedScalar rho = coeff * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
-            for (CeedInt c = 0; c < 2; c++)
+            const CeedScalar qd = qw[i] * coeff * DetJ21(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               v[i+c*Q] = rho * u[i+c*Q];
+               v[i + d * Q] = qd * u[i + d * Q];
             }
          }
          break;
-      case 31:
-         for (CeedInt i = 0; i < Q; i++)
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar rho = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                                    J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                                    J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * coeff * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * coeff * DetJ22(J + i, Q);
+            v[i] = qd * u[i];
          }
          break;
-      case 33:
-         for (CeedInt i=0; i<Q; i++)
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * DetJ22(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               v[i + d * Q] = qd * u[i + d * Q];
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * DetJ32(J + i, Q);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            const CeedScalar rho = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                                    J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                                    J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * coeff * qw[i];
-            for (CeedInt c = 0; c < 3; c++)
+            const CeedScalar qd = qw[i] * coeff * DetJ32(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               v[i+c*Q] = rho * u[i+c*Q];
+               v[i + d * Q] = qd * u[i + d * Q];
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * DetJ33(J + i, Q);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * DetJ33(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               v[i + d * Q] = qd * u[i + d * Q];
             }
          }
          break;
@@ -202,69 +257,99 @@ CEED_QFUNCTION(f_apply_mass_mf_const)(void *ctx, CeedInt Q,
    return 0;
 }
 
+/// libCEED QFunction for applying a mass operator with a coefficient
+/// evaluated at quadrature points
 CEED_QFUNCTION(f_apply_mass_mf_quad)(void *ctx, CeedInt Q,
-                                     const CeedScalar *const *in, CeedScalar *const *out)
+                                     const CeedScalar *const *in,
+                                     CeedScalar *const *out)
 {
-   MassContext *bc = (MassContext*)ctx;
-   const CeedScalar *c = in[0], *u = in[1], *J = in[2], *qw = in[3];
+   MassContext *bc = (MassContext *)ctx;
+   // in[0], out[0] have shape [ncomp=vdim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw * c * det(J)
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
    CeedScalar *v = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (100 * bc->space_dim + 10 * bc->dim + bc->vdim)
    {
-      case 11:
-         for (CeedInt i=0; i<Q; i++)
+      case 111:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar rho = c[i] * J[i] * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * c[i] * J[i];
+            v[i] = qd * u[i];
          }
          break;
-      case 21:
-         for (CeedInt i=0; i<Q; i++)
+      case 211:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            const CeedScalar rho = c[i] * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * c[i] * DetJ21(J + i, Q);
+            v[i] = qd * u[i];
          }
          break;
-      case 22:
-         for (CeedInt i=0; i<Q; i++)
+      case 212:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 2
-            // 1 3
-            const CeedScalar rho = c[i] * (J[i+Q*0]*J[i+Q*3] - J[i+Q*1]*J[i+Q*2]) * qw[i];
-            for (CeedInt d = 0; d < 2; d++)
+            const CeedScalar qd = qw[i] * c[i] * DetJ21(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
             {
-               v[i+d*Q] = rho * u[i+d*Q];
+               v[i + d * Q] = qd * u[i + d * Q];
             }
          }
          break;
-      case 31:
-         for (CeedInt i=0; i<Q; i++)
+      case 221:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            const CeedScalar rho = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                                    J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                                    J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * c[i] * qw[i];
-            v[i] = rho * u[i];
+            const CeedScalar qd = qw[i] * c[i] * DetJ22(J + i, Q);
+            v[i] = qd * u[i];
          }
          break;
-      case 33:
-         for (CeedInt i=0; i<Q; i++)
+      case 222:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * DetJ22(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 2; d++)
+            {
+               v[i + d * Q] = qd * u[i + d * Q];
+            }
+         }
+         break;
+      case 321:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * DetJ32(J + i, Q);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 323:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // 0 3 6
-            // 1 4 7
-            // 2 5 8
-            const CeedScalar rho = (J[i+Q*0]*(J[i+Q*4]*J[i+Q*8] - J[i+Q*5]*J[i+Q*7]) -
-                                    J[i+Q*1]*(J[i+Q*3]*J[i+Q*8] - J[i+Q*5]*J[i+Q*6]) +
-                                    J[i+Q*2]*(J[i+Q*3]*J[i+Q*7] - J[i+Q*4]*J[i+Q*6])) * c[i] * qw[i];
-            for (CeedInt d = 0; d < 3; d++)
+            const CeedScalar qd = qw[i] * c[i] * DetJ32(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
             {
-               v[i+d*Q] = rho * u[i+d*Q];
+               v[i + d * Q] = qd * u[i + d * Q];
+            }
+         }
+         break;
+      case 331:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * DetJ33(J + i, Q);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 333:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * DetJ33(J + i, Q);
+            CeedPragmaSIMD for (CeedInt d = 0; d < 3; d++)
+            {
+               v[i + d * Q] = qd * u[i + d * Q];
             }
          }
          break;
    }
    return 0;
 }
+
+#endif // MFEM_LIBCEED_MASS_QF_H
diff --git a/fem/ceed/integrators/mixedveccurl/mixedveccurl.cpp b/fem/ceed/integrators/mixedveccurl/mixedveccurl.cpp
new file mode 100644
index 000000000..835e40736
--- /dev/null
+++ b/fem/ceed/integrators/mixedveccurl/mixedveccurl.cpp
@@ -0,0 +1,347 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mixedveccurl.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "../curlcurl/curlcurl_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct MixedVectorCurlOperatorInfoBase : public OperatorInfo
+{
+   CurlCurlContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType>
+   MixedVectorCurlOperatorInfoBase(const mfem::FiniteElementSpace &trial_fes,
+                                   const mfem::FiniteElementSpace &test_fes,
+                                   CoeffType *Q, bool use_bdr = false,
+                                   bool use_mf = false)
+   {
+      // Reuse H(div) quadrature functions for CurlCurlIntegrator
+      MFEM_VERIFY(trial_fes.GetVDim() == 1 && test_fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = trial_fes.GetMesh()->Dimension() - use_bdr;
+      MFEM_VERIFY(ctx.dim == 3,
+                  "MixedVectorCurlIntegrator and MixedVectorWeakCurlIntegrator "
+                  "require dim == 3!");
+      ctx.space_dim = trial_fes.GetMesh()->SpaceDimension();
+      ctx.curl_dim = (ctx.dim < 3) ? 1 : ctx.dim;
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_curlcurl";
+         apply_qf = &f_apply_curlcurl;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_scalar";
+            build_qf = &f_build_curlcurl_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_scalar";
+            apply_qf = &f_apply_curlcurl_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, use_mf);
+      }
+      header = "/integrators/curlcurl/curlcurl_qf.h";
+      qdatasize = (ctx.curl_dim * (ctx.curl_dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_scalar";
+            build_qf = &f_build_curlcurl_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_scalar";
+            apply_qf = &f_apply_curlcurl_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_scalar";
+            build_qf = &f_build_curlcurl_quad_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_scalar";
+            apply_qf = &f_apply_curlcurl_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         ctx_coeff = true;
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_CURLCURL_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_vector";
+            build_qf = &f_build_curlcurl_const_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_vector";
+            apply_qf = &f_apply_curlcurl_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_vector";
+            build_qf = &f_build_curlcurl_quad_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_vector";
+            apply_qf = &f_apply_curlcurl_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         ctx_coeff = true;
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_CURLCURL_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_const_matrix";
+            build_qf = &f_build_curlcurl_const_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_const_matrix";
+            apply_qf = &f_apply_curlcurl_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_curlcurl_quad_matrix";
+            build_qf = &f_build_curlcurl_quad_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_curlcurl_mf_quad_matrix";
+            apply_qf = &f_apply_curlcurl_mf_quad_matrix;
+         }
+      }
+   }
+};
+
+struct MixedVectorCurlOperatorInfo : public MixedVectorCurlOperatorInfoBase
+{
+   template <typename CoeffType>
+   MixedVectorCurlOperatorInfo(const mfem::FiniteElementSpace &trial_fes,
+                               const mfem::FiniteElementSpace &test_fes,
+                               CoeffType *Q, bool use_bdr = false,
+                               bool use_mf = false)
+      : MixedVectorCurlOperatorInfoBase(trial_fes, test_fes, Q, use_bdr, use_mf)
+   {
+      MFEM_VERIFY(
+         trial_fes.FEColl()->GetDerivMapType(ctx.dim) == mfem::FiniteElement::H_DIV &&
+         test_fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_DIV,
+         "libCEED interface for MixedVectorCurlIntegrator requires "
+         "H(curl) domain and H(div) range FE spaces!");
+      trial_op = EvalMode::Curl;
+      test_op = EvalMode::Interp;
+   }
+};
+
+struct MixedVectorWeakCurlOperatorInfo : public MixedVectorCurlOperatorInfoBase
+{
+   template <typename CoeffType>
+   MixedVectorWeakCurlOperatorInfo(const mfem::FiniteElementSpace &trial_fes,
+                                   const mfem::FiniteElementSpace &test_fes,
+                                   CoeffType *Q, bool use_bdr = false,
+                                   bool use_mf = false)
+      : MixedVectorCurlOperatorInfoBase(trial_fes, test_fes, Q, use_bdr, use_mf)
+   {
+      MFEM_VERIFY(
+         trial_fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_DIV &&
+         test_fes.FEColl()->GetDerivMapType(ctx.dim) == mfem::FiniteElement::H_DIV,
+         "libCEED interface for MixedVectorWeakCurlIntegrator requires "
+         "H(div) domain and H(curl) range FE spaces!");
+      trial_op = EvalMode::Interp;
+      test_op = EvalMode::Curl;
+   }
+};
+#endif
+
+template <typename CoeffType>
+PAMixedVectorCurlIntegrator::PAMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorCurlOperatorInfo info(trial_fes, test_fes, Q, use_bdr);
+   Assemble(integ, info, trial_fes, test_fes, !info.ctx_coeff ? Q : nullptr,
+            use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFMixedVectorCurlIntegrator::MFMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorCurlOperatorInfo info(trial_fes, test_fes, Q, use_bdr, true);
+   Assemble(integ, info, trial_fes, test_fes, !info.ctx_coeff ? Q : nullptr,
+            use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+PAMixedVectorWeakCurlIntegrator::PAMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorWeakCurlOperatorInfo info(trial_fes, test_fes, Q, use_bdr);
+   Assemble(integ, info, trial_fes, test_fes, !info.ctx_coeff ? Q : nullptr,
+            use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFMixedVectorWeakCurlIntegrator::MFMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorWeakCurlOperatorInfo info(trial_fes, test_fes, Q, use_bdr, true);
+   Assemble(integ, info, trial_fes, test_fes, !info.ctx_coeff ? Q : nullptr,
+            use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PAMixedVectorCurlIntegrator::PAMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template PAMixedVectorCurlIntegrator::PAMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template PAMixedVectorCurlIntegrator::PAMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template MFMixedVectorCurlIntegrator::MFMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template MFMixedVectorCurlIntegrator::MFMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template MFMixedVectorCurlIntegrator::MFMixedVectorCurlIntegrator(
+   const mfem::MixedVectorCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template PAMixedVectorWeakCurlIntegrator::PAMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template PAMixedVectorWeakCurlIntegrator::PAMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template PAMixedVectorWeakCurlIntegrator::PAMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template MFMixedVectorWeakCurlIntegrator::MFMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template MFMixedVectorWeakCurlIntegrator::MFMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template MFMixedVectorWeakCurlIntegrator::MFMixedVectorWeakCurlIntegrator(
+   const mfem::MixedVectorWeakCurlIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/mixedveccurl/mixedveccurl.hpp b/fem/ceed/integrators/mixedveccurl/mixedveccurl.hpp
new file mode 100644
index 000000000..3bae19e0c
--- /dev/null
+++ b/fem/ceed/integrators/mixedveccurl/mixedveccurl.hpp
@@ -0,0 +1,85 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_MIXEDVECCURL_HPP
+#define MFEM_LIBCEED_MIXEDVECCURL_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/** Represent a MixedVectorCurlIntegrator with AssemblyLevel::Partial
+    using libCEED. */
+class PAMixedVectorCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAMixedVectorCurlIntegrator(
+      const mfem::MixedVectorCurlIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorCurlIntegrator with AssemblyLevel::None
+    using libCEED. */
+class MFMixedVectorCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFMixedVectorCurlIntegrator(
+      const mfem::MixedVectorCurlIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorWeakCurlIntegrator with AssemblyLevel::Partial
+    using libCEED. */
+class PAMixedVectorWeakCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAMixedVectorWeakCurlIntegrator(
+      const mfem::MixedVectorWeakCurlIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorWeakCurlIntegrator with AssemblyLevel::None
+    using libCEED. */
+class MFMixedVectorWeakCurlIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFMixedVectorWeakCurlIntegrator(
+      const mfem::MixedVectorWeakCurlIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_MIXEDVECCURL_HPP
diff --git a/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.cpp b/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.cpp
new file mode 100644
index 000000000..7d00d542f
--- /dev/null
+++ b/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.cpp
@@ -0,0 +1,409 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "mixedvecgrad.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "../diffusion/diffusion_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct MixedVectorGradientOperatorInfoBase : public OperatorInfo
+{
+   DiffusionContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType>
+   MixedVectorGradientOperatorInfoBase(const mfem::FiniteElementSpace &trial_fes,
+                                       const mfem::FiniteElementSpace &test_fes,
+                                       CoeffType *Q, bool use_bdr = false,
+                                       bool use_mf = false)
+   {
+      // Reuse H(curl) quadrature functions for DiffusionIntegrator
+      MFEM_VERIFY(trial_fes.GetVDim() == 1 && test_fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = trial_fes.GetMesh()->Dimension() - use_bdr;
+      MFEM_VERIFY(ctx.dim == 2 || ctx.dim == 3,
+                  "MixedVectorGradientIntegrator and MixedVectorWeakDivergenceIntegrator "
+                  "require dim == 2 or dim == 3!");
+      ctx.space_dim = trial_fes.GetMesh()->SpaceDimension();
+      ctx.vdim = 1;
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_diff";
+         apply_qf = &f_apply_diff;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_scalar";
+            build_qf = &f_build_diff_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_scalar";
+            apply_qf = &f_apply_diff_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, use_mf);
+      }
+      header = "/integrators/diffusion/diffusion_qf.h";
+      qdatasize = (ctx.dim * (ctx.dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_scalar";
+            build_qf = &f_build_diff_const_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_scalar";
+            apply_qf = &f_apply_diff_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_scalar";
+            build_qf = &f_build_diff_quad_scalar;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_scalar";
+            apply_qf = &f_apply_diff_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         ctx_coeff = true;
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_DIFF_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_vector";
+            build_qf = &f_build_diff_const_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_vector";
+            apply_qf = &f_apply_diff_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_vector";
+            build_qf = &f_build_diff_quad_vector;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_vector";
+            apply_qf = &f_apply_diff_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         ctx_coeff = true;
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_DIFF_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_const_matrix";
+            build_qf = &f_build_diff_const_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_const_matrix";
+            apply_qf = &f_apply_diff_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_diff_quad_matrix";
+            build_qf = &f_build_diff_quad_matrix;
+         }
+         else
+         {
+            apply_func = ":f_apply_diff_mf_quad_matrix";
+            apply_qf = &f_apply_diff_mf_quad_matrix;
+         }
+      }
+   }
+};
+
+struct MixedVectorGradientOperatorInfo :
+   public MixedVectorGradientOperatorInfoBase
+{
+   template <typename CoeffType>
+   MixedVectorGradientOperatorInfo(const mfem::FiniteElementSpace &trial_fes,
+                                   const mfem::FiniteElementSpace &test_fes,
+                                   CoeffType *Q, bool use_bdr = false,
+                                   bool use_mf = false)
+      : MixedVectorGradientOperatorInfoBase(trial_fes, test_fes, Q, use_bdr, use_mf)
+   {
+      MFEM_VERIFY(
+         (trial_fes.FEColl()->GetDerivMapType(ctx.dim) == mfem::FiniteElement::H_CURL &&
+          test_fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_CURL),
+         "libCEED interface for MixedVectorGradientIntegrator requires "
+         "H^1 domain and H(curl) range FE spaces!");
+      trial_op = EvalMode::Grad;
+      test_op = EvalMode::Interp;
+   }
+};
+
+struct MixedVectorWeakDivergenceOperatorInfo :
+   public MixedVectorGradientOperatorInfoBase
+{
+   template <typename CoeffType>
+   MixedVectorWeakDivergenceOperatorInfo(const mfem::FiniteElementSpace &trial_fes,
+                                         const mfem::FiniteElementSpace &test_fes,
+                                         CoeffType *Q, bool use_bdr = false,
+                                         bool use_mf = false)
+      : MixedVectorGradientOperatorInfoBase(trial_fes, test_fes, Q, use_bdr, use_mf)
+   {
+      MFEM_VERIFY(
+         (trial_fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_CURL &&
+          test_fes.FEColl()->GetDerivMapType(ctx.dim) == mfem::FiniteElement::H_CURL),
+         "libCEED interface for MixedVectorWeakDivergenceIntegrator requires "
+         "H(curl) domain and H^1 range FE spaces!");
+      trial_op = EvalMode::Interp;
+      test_op = EvalMode::Grad;
+      if (ctx_coeff)
+      {
+         for (int i = 0; i < LIBCEED_DIFF_COEFF_COMP_MAX; i++)
+         {
+            ctx.coeff[i] *= -1.0;
+         }
+      }
+   }
+};
+#endif
+
+template <typename CoeffType>
+PAMixedVectorGradientIntegrator::PAMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorGradientOperatorInfo info(trial_fes, test_fes, Q, use_bdr);
+   Assemble(integ, info, trial_fes, test_fes, !info.ctx_coeff ? Q : nullptr,
+            use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFMixedVectorGradientIntegrator::MFMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorGradientOperatorInfo info(trial_fes, test_fes, Q, use_bdr, true);
+   Assemble(integ, info, trial_fes, test_fes, !info.ctx_coeff ? Q : nullptr,
+            use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+namespace
+{
+
+#ifdef MFEM_USE_CEED
+mfem::Coefficient *NegativeCoeff(mfem::Coefficient &Q)
+{
+   return new mfem::ProductCoefficient(-1.0, Q);
+}
+
+mfem::VectorCoefficient *NegativeCoeff(mfem::VectorCoefficient &Q)
+{
+   return new mfem::ScalarVectorProductCoefficient(-1.0, Q);
+}
+
+mfem::MatrixCoefficient *NegativeCoeff(mfem::MatrixCoefficient &Q)
+{
+   return new mfem::ScalarMatrixProductCoefficient(-1.0, Q);
+}
+#endif
+
+} // namespace
+
+template <typename CoeffType>
+PAMixedVectorWeakDivergenceIntegrator::PAMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorWeakDivergenceOperatorInfo info(trial_fes, test_fes, Q, use_bdr);
+   if (!info.ctx_coeff)
+   {
+      // Does not inherit ownership of old Q
+      MFEM_VERIFY(Q, "Unexpected missing coefficient in libCEED "
+                  "MixedVectorGradientIntegrator!");
+      auto *nQ = NegativeCoeff(*Q);
+      Assemble(integ, info, trial_fes, test_fes, nQ, use_bdr);
+      delete nQ;
+   }
+   else
+   {
+      Assemble(integ, info, trial_fes, test_fes, (mfem::Coefficient *)nullptr,
+               use_bdr);
+   }
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFMixedVectorWeakDivergenceIntegrator::MFMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &integ,
+   const mfem::FiniteElementSpace &trial_fes,
+   const mfem::FiniteElementSpace &test_fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   MixedVectorWeakDivergenceOperatorInfo info(trial_fes, test_fes, Q, use_bdr,
+                                              true);
+   if (!info.ctx_coeff)
+   {
+      // Does not inherit ownership of old Q
+      MFEM_VERIFY(Q, "Unexpected missing coefficient in libCEED "
+                  "MixedVectorGradientIntegrator!");
+      auto *nQ = NegativeCoeff(*Q);
+      Assemble(integ, info, trial_fes, test_fes, nQ, use_bdr, true);
+      delete nQ;
+   }
+   else
+   {
+      Assemble(integ, info, trial_fes, test_fes, (mfem::Coefficient *)nullptr,
+               use_bdr, true);
+   }
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PAMixedVectorGradientIntegrator::PAMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template PAMixedVectorGradientIntegrator::PAMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template PAMixedVectorGradientIntegrator::PAMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template PAMixedVectorWeakDivergenceIntegrator::PAMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template PAMixedVectorWeakDivergenceIntegrator::PAMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template PAMixedVectorWeakDivergenceIntegrator::PAMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template MFMixedVectorGradientIntegrator::MFMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::Coefficient *, const bool);
+template MFMixedVectorGradientIntegrator::MFMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::VectorCoefficient *, const bool);
+template MFMixedVectorGradientIntegrator::MFMixedVectorGradientIntegrator(
+   const mfem::MixedVectorGradientIntegrator &, const mfem::FiniteElementSpace &,
+   const mfem::FiniteElementSpace &, mfem::MatrixCoefficient *, const bool);
+
+template MFMixedVectorWeakDivergenceIntegrator::MFMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template MFMixedVectorWeakDivergenceIntegrator::MFMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template MFMixedVectorWeakDivergenceIntegrator::MFMixedVectorWeakDivergenceIntegrator(
+   const mfem::MixedVectorWeakDivergenceIntegrator &,
+   const mfem::FiniteElementSpace &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.hpp b/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.hpp
new file mode 100644
index 000000000..c4220ea0f
--- /dev/null
+++ b/fem/ceed/integrators/mixedvecgrad/mixedvecgrad.hpp
@@ -0,0 +1,85 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_MIXEDVECGRAD_HPP
+#define MFEM_LIBCEED_MIXEDVECGRAD_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/** Represent a MixedVectorGradientIntegrator with AssemblyLevel::Partial
+    using libCEED. */
+class PAMixedVectorGradientIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAMixedVectorGradientIntegrator(
+      const mfem::MixedVectorGradientIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorGradientIntegrator with AssemblyLevel::None
+    using libCEED. */
+class MFMixedVectorGradientIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFMixedVectorGradientIntegrator(
+      const mfem::MixedVectorGradientIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorWeakDivergenceIntegrator with AssemblyLevel::Partial
+    using libCEED. */
+class PAMixedVectorWeakDivergenceIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAMixedVectorWeakDivergenceIntegrator(
+      const mfem::MixedVectorWeakDivergenceIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+/** Represent a MixedVectorWeakDivergenceIntegrator with AssemblyLevel::None
+    using libCEED. */
+class MFMixedVectorWeakDivergenceIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFMixedVectorWeakDivergenceIntegrator(
+      const mfem::MixedVectorWeakDivergenceIntegrator &integ,
+      const mfem::FiniteElementSpace &trial_fes,
+      const mfem::FiniteElementSpace &test_fes,
+      CoeffType *Q,
+      const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_MIXEDVECGRAD_HPP
diff --git a/fem/ceed/integrators/nlconvection/nlconvection.cpp b/fem/ceed/integrators/nlconvection/nlconvection.cpp
index ba4a274dc..e46c4a495 100644
--- a/fem/ceed/integrators/nlconvection/nlconvection.cpp
+++ b/fem/ceed/integrators/nlconvection/nlconvection.cpp
@@ -25,76 +25,101 @@ namespace ceed
 #ifdef MFEM_USE_CEED
 struct NLConvectionOperatorInfo : public OperatorInfo
 {
-   NLConvectionContext ctx;
-   NLConvectionOperatorInfo(int dim)
+   NLConvectionContext ctx = {0};
+   bool ctx_coeff = false;
+   NLConvectionOperatorInfo(const mfem::FiniteElementSpace &fes,
+                            mfem::Coefficient *Q, bool use_bdr = false,
+                            bool use_mf = false)
    {
+      MFEM_VERIFY(fes.GetVDim() == fes.GetMesh()->SpaceDimension(),
+                  "Missing coefficient in ceed::NLConvectionOperatorInfo!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_conv";
+         apply_qf = &f_apply_conv;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff = 1.0;
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_const";
+            build_qf = &f_build_conv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_const";
+            apply_qf = &f_apply_conv_mf_const;
+         }
+      }
+      else if (mfem::ConstantCoefficient *const_coeff =
+                  dynamic_cast<mfem::ConstantCoefficient *>(Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_const";
+            build_qf = &f_build_conv_const;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_const";
+            apply_qf = &f_apply_conv_mf_const;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = ":f_build_conv_quad";
+            build_qf = &f_build_conv_quad;
+         }
+         else
+         {
+            apply_func = ":f_apply_conv_mf_quad";
+            apply_qf = &f_apply_conv_mf_quad;
+         }
+      }
       header = "/integrators/nlconvection/nlconvection_qf.h";
-      build_func_const = ":f_build_conv_const";
-      build_qf_const = &f_build_conv_const;
-      build_func_quad = ":f_build_conv_quad";
-      build_qf_quad = &f_build_conv_quad;
-      apply_func = ":f_apply_conv";
-      apply_qf = &f_apply_conv;
-      apply_func_mf_const = ":f_apply_conv_mf_const";
-      apply_qf_mf_const = &f_apply_conv_mf_const;
-      apply_func_mf_quad = ":f_apply_conv_mf_quad";
-      apply_qf_mf_quad = &f_apply_conv_mf_quad;
       trial_op = EvalMode::InterpAndGrad;
       test_op = EvalMode::Interp;
-      qdatasize = dim * dim;
+      qdatasize = ctx.dim * ctx.space_dim;
    }
 };
 #endif
 
-PAVectorConvectionNLFIntegrator::PAVectorConvectionNLFIntegrator(
+PAVectorConvectionNLIntegrator::PAVectorConvectionNLIntegrator(
+   const mfem::VectorConvectionNLFIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::Coefficient *Q)
-   : PAIntegrator()
+   mfem::Coefficient *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   NLConvectionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(info, fes, irm, Q);
+   NLConvectionOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
 }
 
-MixedPAVectorConvectionNLIntegrator::MixedPAVectorConvectionNLIntegrator(
-   const VectorConvectionNLFIntegrator &integ,
+MFVectorConvectionNLIntegrator::MFVectorConvectionNLIntegrator(
+   const mfem::VectorConvectionNLFIntegrator &integ,
    const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
+   mfem::Coefficient *Q,
+   const bool use_bdr)
 {
 #ifdef MFEM_USE_CEED
-   NLConvectionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MFVectorConvectionNLFIntegrator::MFVectorConvectionNLFIntegrator(
-   const mfem::FiniteElementSpace &fes,
-   const mfem::IntegrationRule &irm,
-   mfem::Coefficient *Q)
-   : MFIntegrator()
-{
-#ifdef MFEM_USE_CEED
-   NLConvectionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(info, fes, irm, Q);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
-}
-
-MixedMFVectorConvectionNLIntegrator::MixedMFVectorConvectionNLIntegrator(
-   const VectorConvectionNLFIntegrator &integ,
-   const mfem::FiniteElementSpace &fes,
-   mfem::Coefficient *Q)
-{
-#ifdef MFEM_USE_CEED
-   NLConvectionOperatorInfo info(fes.GetMesh()->Dimension());
-   Assemble(integ, info, fes, Q);
+   NLConvectionOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
diff --git a/fem/ceed/integrators/nlconvection/nlconvection.hpp b/fem/ceed/integrators/nlconvection/nlconvection.hpp
index 3efe88728..cf245322a 100644
--- a/fem/ceed/integrators/nlconvection/nlconvection.hpp
+++ b/fem/ceed/integrators/nlconvection/nlconvection.hpp
@@ -13,7 +13,7 @@
 #define MFEM_LIBCEED_NLCONV_HPP
 
 #include "../../interface/integrator.hpp"
-#include "../../interface/mixed_integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
 #include "../../../fespace.hpp"
 
 namespace mfem
@@ -24,40 +24,26 @@ namespace ceed
 
 /** Represent a VectorConvectionNLFIntegrator with AssemblyLevel::Partial
     using libCEED. */
-class PAVectorConvectionNLFIntegrator : public PAIntegrator
+class PAVectorConvectionNLIntegrator : public MixedOperator<Integrator>
 {
 public:
-   PAVectorConvectionNLFIntegrator(const mfem::FiniteElementSpace &fes,
-                                   const mfem::IntegrationRule &irm,
-                                   mfem::Coefficient *coeff);
-};
-
-class MixedPAVectorConvectionNLIntegrator : public MixedIntegrator<PAIntegrator>
-{
-public:
-   MixedPAVectorConvectionNLIntegrator(
-      const VectorConvectionNLFIntegrator &integ,
+   PAVectorConvectionNLIntegrator(
+      const mfem::VectorConvectionNLFIntegrator &integ,
       const mfem::FiniteElementSpace &fes,
-      mfem::Coefficient *Q);
+      mfem::Coefficient *Q,
+      const bool use_bdr = false);
 };
 
 /** Represent a VectorConvectionNLFIntegrator with AssemblyLevel::None
     using libCEED. */
-class MFVectorConvectionNLFIntegrator : public MFIntegrator
-{
-public:
-   MFVectorConvectionNLFIntegrator(const mfem::FiniteElementSpace &fes,
-                                   const mfem::IntegrationRule &irm,
-                                   mfem::Coefficient *coeff);
-};
-
-class MixedMFVectorConvectionNLIntegrator : public MixedIntegrator<MFIntegrator>
+class MFVectorConvectionNLIntegrator : public MixedOperator<Integrator>
 {
 public:
-   MixedMFVectorConvectionNLIntegrator(
-      const VectorConvectionNLFIntegrator &integ,
+   MFVectorConvectionNLIntegrator(
+      const mfem::VectorConvectionNLFIntegrator &integ,
       const mfem::FiniteElementSpace &fes,
-      mfem::Coefficient *Q);
+      mfem::Coefficient *Q,
+      const bool use_bdr = false);
 };
 
 }
diff --git a/fem/ceed/integrators/nlconvection/nlconvection_qf.h b/fem/ceed/integrators/nlconvection/nlconvection_qf.h
index ef0d41327..ee1782784 100644
--- a/fem/ceed/integrators/nlconvection/nlconvection_qf.h
+++ b/fem/ceed/integrators/nlconvection/nlconvection_qf.h
@@ -9,186 +9,155 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-/// A structure used to pass additional data to f_build_conv and f_apply_conv
-struct NLConvectionContext { CeedInt dim, space_dim, vdim; CeedScalar coeff; };
+#ifndef MFEM_LIBCEED_NLCONV_QF_H
+#define MFEM_LIBCEED_NLCONV_QF_H
 
-/// libCEED Q-function for building quadrature data for a convection operator
-/// with a constant coefficient
+#include "../util/util_qf.h"
+
+struct NLConvectionContext
+{
+   CeedInt dim, space_dim;
+   CeedScalar coeff;
+};
+
+/// libCEED QFunction for building quadrature data for a convection
+/// operator with a constant coefficient
 CEED_QFUNCTION(f_build_conv_const)(void *ctx, CeedInt Q,
                                    const CeedScalar *const *in,
                                    CeedScalar *const *out)
 {
-   NLConvectionContext *bc = (NLConvectionContext*)ctx;
-   // in[0] is Jacobians with shape [dim, nc=dim, Q]
+   NLConvectionContext *bc = (NLConvectionContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[1] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute and store qw * adj(J).
+   // At every quadrature point, compute and store qw * c * adj(J)^T
    const CeedScalar coeff = bc->coeff;
    const CeedScalar *J = in[0], *qw = in[1];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * coeff * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            qd[i] = coeff * qw[i] * J[i];
+            MultAdjJt21(J + i, Q, qw[i] * coeff, Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 2   adj(J):  J22 -J12
-            //    1 3       1 3           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] * coeff;
-            qd[i + Q * 0] =  w * J22;
-            qd[i + Q * 1] = -w * J21;
-            qd[i + Q * 2] = -w * J12;
-            qd[i + Q * 3] =  w * J11;
+            MultAdjJt22(J + i, Q, qw[i] * coeff, Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJt32(J + i, Q, qw[i] * coeff, Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 3 6
-            //    1 4 7       1 4 7
-            //    2 5 8       2 5 8
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] * coeff;
-            qd[i + Q * 0] = w * A11;
-            qd[i + Q * 1] = w * A21;
-            qd[i + Q * 2] = w * A31;
-            qd[i + Q * 3] = w * A12;
-            qd[i + Q * 4] = w * A22;
-            qd[i + Q * 5] = w * A32;
-            qd[i + Q * 6] = w * A13;
-            qd[i + Q * 7] = w * A23;
-            qd[i + Q * 8] = w * A33;
+            MultAdjJt33(J + i, Q, qw[i] * coeff, Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for building quadrature data for a convection operator
-/// coefficient evaluated at quadrature points.
+/// libCEED QFunction for building quadrature data for a convection
+/// operator with a coefficient evaluated at quadrature points
 CEED_QFUNCTION(f_build_conv_quad)(void *ctx, CeedInt Q,
                                   const CeedScalar *const *in,
                                   CeedScalar *const *out)
 {
    NLConvectionContext *bc = (NLConvectionContext *)ctx;
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
+   // in[0] is coefficients, size (Q)
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
    // in[2] is quadrature weights, size (Q)
    //
-   // At every quadrature point, compute and store qw * adj(J).
+   // At every quadrature point, compute and store qw * c * adj(J)^T
    const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
    CeedScalar *qd = out[0];
-   switch (bc->dim + 10 * bc->space_dim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar coeff = c[i];
-            qd[i] = coeff * qw[i] * J[i];
+            MultAdjJt21(J + i, Q, qw[i] * c[i], Q, qd + i);
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 2   adj(J):  J22 -J12
-            //    1 3       1 3           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar coeff = c[i];
-            const CeedScalar w = qw[i] * coeff;
-            qd[i + Q * 0] =  w * J22;
-            qd[i + Q * 1] = -w * J21;
-            qd[i + Q * 2] = -w * J12;
-            qd[i + Q * 3] =  w * J11;
+            MultAdjJt22(J + i, Q, qw[i] * c[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJt32(J + i, Q, qw[i] * c[i], Q, qd + i);
          }
          break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 3 6
-            //    1 4 7       1 4 7
-            //    2 5 8       2 5 8
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar coeff = c[i];
-            const CeedScalar w = qw[i] * coeff;
-            qd[i + Q * 0] = w * A11;
-            qd[i + Q * 1] = w * A21;
-            qd[i + Q * 2] = w * A31;
-            qd[i + Q * 3] = w * A12;
-            qd[i + Q * 4] = w * A22;
-            qd[i + Q * 5] = w * A32;
-            qd[i + Q * 6] = w * A13;
-            qd[i + Q * 7] = w * A23;
-            qd[i + Q * 8] = w * A33;
+            MultAdjJt33(J + i, Q, qw[i] * c[i], Q, qd + i);
          }
          break;
    }
    return 0;
 }
 
-/// libCEED Q-function for applying a conv operator
+/// libCEED QFunction for applying a convection operator
 CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
                              const CeedScalar *const *in,
                              CeedScalar *const *out)
 {
    NLConvectionContext *bc = (NLConvectionContext *)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
+   // in[0] has shape [ncomp=space_dim, Q]
+   // in[1] has shape [dim, ncomp=space_dim, Q]
+   // out[0] has shape [ncomp=space_dim, Q]
    const CeedScalar *u = in[0], *ug = in[1], *qd = in[2];
    CeedScalar *vg = out[0];
-   switch (10*bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            vg[i] = qd[i] * u[i] * ug[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            vg[i] = u[i] * ug[i] * qd[i];
+            const CeedScalar qd00 = qd[i + Q * 0];
+            const CeedScalar qd10 = qd[i + Q * 1];
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar Dxu0 = qd00 * ug00;
+            const CeedScalar Dyu0 = qd10 * ug00;
+            const CeedScalar Dxu1 = qd00 * ug10;
+            const CeedScalar Dyu1 = qd10 * ug10;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar qd00 = qd[i + Q * 0];
             const CeedScalar qd10 = qd[i + Q * 1];
@@ -200,16 +169,47 @@ CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
             const CeedScalar ug10 = ug[i + Q * 1];
             const CeedScalar ug01 = ug[i + Q * 2];
             const CeedScalar ug11 = ug[i + Q * 3];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11;
+            const CeedScalar Dxu0 = qd00 * ug00 + qd01 * ug01;
+            const CeedScalar Dyu0 = qd10 * ug00 + qd11 * ug01;
+            const CeedScalar Dxu1 = qd00 * ug10 + qd01 * ug11;
+            const CeedScalar Dyu1 = qd10 * ug10 + qd11 * ug11;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd00 = qd[i + Q * 0];
+            const CeedScalar qd10 = qd[i + Q * 1];
+            const CeedScalar qd20 = qd[i + Q * 2];
+            const CeedScalar qd01 = qd[i + Q * 3];
+            const CeedScalar qd11 = qd[i + Q * 4];
+            const CeedScalar qd21 = qd[i + Q * 5];
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar u2   = u[i + Q * 2];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar ug20 = ug[i + Q * 2];
+            const CeedScalar ug01 = ug[i + Q * 3];
+            const CeedScalar ug11 = ug[i + Q * 4];
+            const CeedScalar ug21 = ug[i + Q * 5];
+            const CeedScalar Dxu0 = qd00 * ug00 + qd01 * ug01;
+            const CeedScalar Dyu0 = qd10 * ug00 + qd11 * ug01;
+            const CeedScalar Dzu0 = qd20 * ug00 + qd21 * ug01;
+            const CeedScalar Dxu1 = qd00 * ug10 + qd01 * ug11;
+            const CeedScalar Dyu1 = qd10 * ug10 + qd11 * ug11;
+            const CeedScalar Dzu1 = qd20 * ug10 + qd21 * ug11;
+            const CeedScalar Dxu2 = qd00 * ug20 + qd01 * ug21;
+            const CeedScalar Dyu2 = qd10 * ug20 + qd11 * ug21;
+            const CeedScalar Dzu2 = qd20 * ug20 + qd21 * ug21;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
+            vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
+         }
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
             const CeedScalar qd00 = qd[i + Q * 0];
             const CeedScalar qd10 = qd[i + Q * 1];
@@ -232,15 +232,15 @@ CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
             const CeedScalar ug02 = ug[i + Q * 6];
             const CeedScalar ug12 = ug[i + Q * 7];
             const CeedScalar ug22 = ug[i + Q * 8];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10 + ug02 * qd20;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11 + ug02 * qd21;
-            const CeedScalar Dzu0 = ug00 * qd02 + ug01 * qd12 + ug02 * qd22;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10 + ug12 * qd20;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11 + ug12 * qd21;
-            const CeedScalar Dzu1 = ug10 * qd02 + ug11 * qd12 + ug12 * qd22;
-            const CeedScalar Dxu2 = ug20 * qd00 + ug21 * qd10 + ug22 * qd20;
-            const CeedScalar Dyu2 = ug20 * qd01 + ug21 * qd11 + ug22 * qd21;
-            const CeedScalar Dzu2 = ug20 * qd02 + ug21 * qd12 + ug22 * qd22;
+            const CeedScalar Dxu0 = qd00 * ug00 + qd01 * ug01 + qd02 * ug02;
+            const CeedScalar Dyu0 = qd10 * ug00 + qd11 * ug01 + qd12 * ug02;
+            const CeedScalar Dzu0 = qd20 * ug00 + qd21 * ug01 + qd22 * ug02;
+            const CeedScalar Dxu1 = qd00 * ug10 + qd01 * ug11 + qd02 * ug12;
+            const CeedScalar Dyu1 = qd10 * ug10 + qd11 * ug11 + qd12 * ug12;
+            const CeedScalar Dzu1 = qd20 * ug10 + qd21 * ug11 + qd22 * ug12;
+            const CeedScalar Dxu2 = qd00 * ug20 + qd01 * ug21 + qd02 * ug22;
+            const CeedScalar Dyu2 = qd10 * ug20 + qd11 * ug21 + qd12 * ug22;
+            const CeedScalar Dzu2 = qd20 * ug20 + qd21 * ug21 + qd22 * ug22;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
             vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
@@ -250,91 +250,101 @@ CEED_QFUNCTION(f_apply_conv)(void *ctx, CeedInt Q,
    return 0;
 }
 
-/// libCEED Q-function for applying a conv operator
+/// libCEED QFunction for applying a convection operator with a constant
+/// coefficient
 CEED_QFUNCTION(f_apply_conv_mf_const)(void *ctx, CeedInt Q,
                                       const CeedScalar *const *in,
                                       CeedScalar *const *out)
 {
-   NLConvectionContext *bc = (NLConvectionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
-   // in[2] is quadrature weights, size (Q)
+   NLConvectionContext *bc = (NLConvectionContext *)ctx;
+   // in[0] has shape [ncomp=space_dim, Q]
+   // in[1] has shape [dim, ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   // out[0] has shape [ncomp=space_dim, Q]
    //
-   // At every quadrature point, compute qw * adj(J).
+   // At every quadrature point, compute qw * c * adj(J)^T
    const CeedScalar coeff = bc->coeff;
    const CeedScalar *u = in[0], *ug = in[1], *J = in[2], *qw = in[3];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * coeff * J[i];
+            vg[i] = u[i] * qd * ug[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = coeff * qw[i] * J[i];
-            vg[i] = u[i] * ug[i] * qd;
+            CeedScalar qd[2];
+            MultAdjJt21(J + i, Q, qw[i] * coeff, 1, qd);
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar Dxu0 = qd[0] * ug00;
+            const CeedScalar Dyu0 = qd[1] * ug00;
+            const CeedScalar Dxu1 = qd[0] * ug10;
+            const CeedScalar Dyu1 = qd[1] * ug10;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 2   adj(J):  J22 -J12
-            //    1 3       1 3           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] * coeff;
-            const CeedScalar qd00 =  w * J22;
-            const CeedScalar qd10 = -w * J21;
-            const CeedScalar qd01 = -w * J12;
-            const CeedScalar qd11 =  w * J11;
+            CeedScalar qd[4];
+            MultAdjJt22(J + i, Q, qw[i] * coeff, 1, qd);
             const CeedScalar u0   = u[i + Q * 0];
             const CeedScalar u1   = u[i + Q * 1];
             const CeedScalar ug00 = ug[i + Q * 0];
             const CeedScalar ug10 = ug[i + Q * 1];
             const CeedScalar ug01 = ug[i + Q * 2];
             const CeedScalar ug11 = ug[i + Q * 3];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11;
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[2] * ug01;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[3] * ug01;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[2] * ug11;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[3] * ug11;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJt32(J + i, Q, qw[i] * coeff, 1, qd);
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar u2   = u[i + Q * 2];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar ug20 = ug[i + Q * 2];
+            const CeedScalar ug01 = ug[i + Q * 3];
+            const CeedScalar ug11 = ug[i + Q * 4];
+            const CeedScalar ug21 = ug[i + Q * 5];
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[3] * ug01;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[4] * ug01;
+            const CeedScalar Dzu0 = qd[2] * ug00 + qd[5] * ug01;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[3] * ug11;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[4] * ug11;
+            const CeedScalar Dzu1 = qd[2] * ug10 + qd[5] * ug11;
+            const CeedScalar Dxu2 = qd[0] * ug20 + qd[3] * ug21;
+            const CeedScalar Dyu2 = qd[1] * ug20 + qd[4] * ug21;
+            const CeedScalar Dzu2 = qd[2] * ug20 + qd[5] * ug21;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
+            vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
+         }
+         break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 3 6
-            //    1 4 7       1 4 7
-            //    2 5 8       2 5 8
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] * coeff;
-            const CeedScalar qd00 = w * A11;
-            const CeedScalar qd10 = w * A21;
-            const CeedScalar qd20 = w * A31;
-            const CeedScalar qd01 = w * A12;
-            const CeedScalar qd11 = w * A22;
-            const CeedScalar qd21 = w * A32;
-            const CeedScalar qd02 = w * A13;
-            const CeedScalar qd12 = w * A23;
-            const CeedScalar qd22 = w * A33;
+            CeedScalar qd[9];
+            MultAdjJt33(J + i, Q, qw[i] * coeff, 1, qd);
             const CeedScalar u0   = u[i + Q * 0];
             const CeedScalar u1   = u[i + Q * 1];
             const CeedScalar u2   = u[i + Q * 2];
@@ -347,15 +357,15 @@ CEED_QFUNCTION(f_apply_conv_mf_const)(void *ctx, CeedInt Q,
             const CeedScalar ug02 = ug[i + Q * 6];
             const CeedScalar ug12 = ug[i + Q * 7];
             const CeedScalar ug22 = ug[i + Q * 8];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10 + ug02 * qd20;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11 + ug02 * qd21;
-            const CeedScalar Dzu0 = ug00 * qd02 + ug01 * qd12 + ug02 * qd22;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10 + ug12 * qd20;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11 + ug12 * qd21;
-            const CeedScalar Dzu1 = ug10 * qd02 + ug11 * qd12 + ug12 * qd22;
-            const CeedScalar Dxu2 = ug20 * qd00 + ug21 * qd10 + ug22 * qd20;
-            const CeedScalar Dyu2 = ug20 * qd01 + ug21 * qd11 + ug22 * qd21;
-            const CeedScalar Dzu2 = ug20 * qd02 + ug21 * qd12 + ug22 * qd22;
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[3] * ug01 + qd[6] * ug02;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[4] * ug01 + qd[7] * ug02;
+            const CeedScalar Dzu0 = qd[2] * ug00 + qd[5] * ug01 + qd[8] * ug02;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[3] * ug11 + qd[6] * ug12;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[4] * ug11 + qd[7] * ug12;
+            const CeedScalar Dzu1 = qd[2] * ug10 + qd[5] * ug11 + qd[8] * ug12;
+            const CeedScalar Dxu2 = qd[0] * ug20 + qd[3] * ug21 + qd[6] * ug22;
+            const CeedScalar Dyu2 = qd[1] * ug20 + qd[4] * ug21 + qd[7] * ug22;
+            const CeedScalar Dzu2 = qd[2] * ug20 + qd[5] * ug21 + qd[8] * ug22;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
             vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
@@ -365,89 +375,101 @@ CEED_QFUNCTION(f_apply_conv_mf_const)(void *ctx, CeedInt Q,
    return 0;
 }
 
+/// libCEED QFunction for applying a convection operator with a coefficient
+/// evaluated at quadrature points
 CEED_QFUNCTION(f_apply_conv_mf_quad)(void *ctx, CeedInt Q,
                                      const CeedScalar *const *in,
                                      CeedScalar *const *out)
 {
-   NLConvectionContext *bc = (NLConvectionContext*)ctx;
-   // in[0], out[0] have shape [dim, nc=1, Q]
-   // in[1] is Jacobians with shape [dim, nc=dim, Q]
-   // in[2] is quadrature weights, size (Q)
+   NLConvectionContext *bc = (NLConvectionContext *)ctx;
+   // in[0] has shape [ncomp=space_dim, Q]
+   // in[1] has shape [dim, ncomp=space_dim, Q]
+   // in[2] is coefficients, size (Q)
+   // in[3] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[4] is quadrature weights, size (Q)
+   // out[0] has shape [ncomp=space_dim, Q]
    //
-   // At every quadrature point, compute qw * adj(J).
-   const CeedScalar *c = in[0], *u = in[1], *ug = in[2], *J = in[3], *qw = in[4];
+   // At every quadrature point, compute qw * c * adj(J)^T
+   const CeedScalar *u = in[0], *ug = in[1], *c = in[2], *J = in[3], *qw = in[4];
    CeedScalar *vg = out[0];
-   switch (10 * bc->dim + bc->vdim)
+   switch (10 * bc->space_dim + bc->dim)
    {
       case 11:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            const CeedScalar qd = c[i] * qw[i] * J[i];
-            vg[i] = u[i] * ug[i] * qd;
+            const CeedScalar qd = qw[i] * c[i] * J[i];
+            vg[i] = u[i] * qd * ug[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[2];
+            MultAdjJt21(J + i, Q, qw[i] * c[i], 1, qd);
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar Dxu0 = qd[0] * ug00;
+            const CeedScalar Dyu0 = qd[1] * ug00;
+            const CeedScalar Dxu1 = qd[0] * ug10;
+            const CeedScalar Dyu1 = qd[1] * ug10;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
       case 22:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 2   qd: 0 2   adj(J):  J22 -J12
-            //    1 3       1 3           -J21  J11
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J12 = J[i + Q * 2];
-            const CeedScalar J22 = J[i + Q * 3];
-            const CeedScalar w = qw[i] * c[i];
-            const CeedScalar qd00 =  w * J22;
-            const CeedScalar qd10 = -w * J21;
-            const CeedScalar qd01 = -w * J12;
-            const CeedScalar qd11 =  w * J11;
+            CeedScalar qd[4];
+            MultAdjJt22(J + i, Q, qw[i] * c[i], 1, qd);
             const CeedScalar u0   = u[i + Q * 0];
             const CeedScalar u1   = u[i + Q * 1];
             const CeedScalar ug00 = ug[i + Q * 0];
             const CeedScalar ug10 = ug[i + Q * 1];
             const CeedScalar ug01 = ug[i + Q * 2];
             const CeedScalar ug11 = ug[i + Q * 3];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11;
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[2] * ug01;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[3] * ug01;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[2] * ug11;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[3] * ug11;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1;
          }
          break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJt32(J + i, Q, qw[i] * c[i], 1, qd);
+            const CeedScalar u0   = u[i + Q * 0];
+            const CeedScalar u1   = u[i + Q * 1];
+            const CeedScalar u2   = u[i + Q * 2];
+            const CeedScalar ug00 = ug[i + Q * 0];
+            const CeedScalar ug10 = ug[i + Q * 1];
+            const CeedScalar ug20 = ug[i + Q * 2];
+            const CeedScalar ug01 = ug[i + Q * 3];
+            const CeedScalar ug11 = ug[i + Q * 4];
+            const CeedScalar ug21 = ug[i + Q * 5];
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[3] * ug01;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[4] * ug01;
+            const CeedScalar Dzu0 = qd[2] * ug00 + qd[5] * ug01;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[3] * ug11;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[4] * ug11;
+            const CeedScalar Dzu1 = qd[2] * ug10 + qd[5] * ug11;
+            const CeedScalar Dxu2 = qd[0] * ug20 + qd[3] * ug21;
+            const CeedScalar Dyu2 = qd[1] * ug20 + qd[4] * ug21;
+            const CeedScalar Dzu2 = qd[2] * ug20 + qd[5] * ug21;
+            vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
+            vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
+            vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
+         }
+         break;
       case 33:
-         for (CeedInt i = 0; i < Q; i++)
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
          {
-            // J: 0 3 6   qd: 0 3 6
-            //    1 4 7       1 4 7
-            //    2 5 8       2 5 8
-            const CeedScalar J11 = J[i + Q * 0];
-            const CeedScalar J21 = J[i + Q * 1];
-            const CeedScalar J31 = J[i + Q * 2];
-            const CeedScalar J12 = J[i + Q * 3];
-            const CeedScalar J22 = J[i + Q * 4];
-            const CeedScalar J32 = J[i + Q * 5];
-            const CeedScalar J13 = J[i + Q * 6];
-            const CeedScalar J23 = J[i + Q * 7];
-            const CeedScalar J33 = J[i + Q * 8];
-            const CeedScalar A11 = J22 * J33 - J23 * J32;
-            const CeedScalar A12 = J13 * J32 - J12 * J33;
-            const CeedScalar A13 = J12 * J23 - J13 * J22;
-            const CeedScalar A21 = J23 * J31 - J21 * J33;
-            const CeedScalar A22 = J11 * J33 - J13 * J31;
-            const CeedScalar A23 = J13 * J21 - J11 * J23;
-            const CeedScalar A31 = J21 * J32 - J22 * J31;
-            const CeedScalar A32 = J12 * J31 - J11 * J32;
-            const CeedScalar A33 = J11 * J22 - J12 * J21;
-            const CeedScalar w = qw[i] * c[i];
-            const CeedScalar qd00 = w * A11;
-            const CeedScalar qd10 = w * A21;
-            const CeedScalar qd20 = w * A31;
-            const CeedScalar qd01 = w * A12;
-            const CeedScalar qd11 = w * A22;
-            const CeedScalar qd21 = w * A32;
-            const CeedScalar qd02 = w * A13;
-            const CeedScalar qd12 = w * A23;
-            const CeedScalar qd22 = w * A33;
+            CeedScalar qd[9];
+            MultAdjJt33(J + i, Q, qw[i] * c[i], 1, qd);
             const CeedScalar u0   = u[i + Q * 0];
             const CeedScalar u1   = u[i + Q * 1];
             const CeedScalar u2   = u[i + Q * 2];
@@ -460,15 +482,15 @@ CEED_QFUNCTION(f_apply_conv_mf_quad)(void *ctx, CeedInt Q,
             const CeedScalar ug02 = ug[i + Q * 6];
             const CeedScalar ug12 = ug[i + Q * 7];
             const CeedScalar ug22 = ug[i + Q * 8];
-            const CeedScalar Dxu0 = ug00 * qd00 + ug01 * qd10 + ug02 * qd20;
-            const CeedScalar Dyu0 = ug00 * qd01 + ug01 * qd11 + ug02 * qd21;
-            const CeedScalar Dzu0 = ug00 * qd02 + ug01 * qd12 + ug02 * qd22;
-            const CeedScalar Dxu1 = ug10 * qd00 + ug11 * qd10 + ug12 * qd20;
-            const CeedScalar Dyu1 = ug10 * qd01 + ug11 * qd11 + ug12 * qd21;
-            const CeedScalar Dzu1 = ug10 * qd02 + ug11 * qd12 + ug12 * qd22;
-            const CeedScalar Dxu2 = ug20 * qd00 + ug21 * qd10 + ug22 * qd20;
-            const CeedScalar Dyu2 = ug20 * qd01 + ug21 * qd11 + ug22 * qd21;
-            const CeedScalar Dzu2 = ug20 * qd02 + ug21 * qd12 + ug22 * qd22;
+            const CeedScalar Dxu0 = qd[0] * ug00 + qd[3] * ug01 + qd[6] * ug02;
+            const CeedScalar Dyu0 = qd[1] * ug00 + qd[4] * ug01 + qd[7] * ug02;
+            const CeedScalar Dzu0 = qd[2] * ug00 + qd[5] * ug01 + qd[8] * ug02;
+            const CeedScalar Dxu1 = qd[0] * ug10 + qd[3] * ug11 + qd[6] * ug12;
+            const CeedScalar Dyu1 = qd[1] * ug10 + qd[4] * ug11 + qd[7] * ug12;
+            const CeedScalar Dzu1 = qd[2] * ug10 + qd[5] * ug11 + qd[8] * ug12;
+            const CeedScalar Dxu2 = qd[0] * ug20 + qd[3] * ug21 + qd[6] * ug22;
+            const CeedScalar Dyu2 = qd[1] * ug20 + qd[4] * ug21 + qd[7] * ug22;
+            const CeedScalar Dzu2 = qd[2] * ug20 + qd[5] * ug21 + qd[8] * ug22;
             vg[i + Q * 0] = u0 * Dxu0 + u1 * Dyu0 + u2 * Dzu0;
             vg[i + Q * 1] = u0 * Dxu1 + u1 * Dyu1 + u2 * Dzu1;
             vg[i + Q * 2] = u0 * Dxu2 + u1 * Dyu2 + u2 * Dzu2;
@@ -477,3 +499,5 @@ CEED_QFUNCTION(f_apply_conv_mf_quad)(void *ctx, CeedInt Q,
    }
    return 0;
 }
+
+#endif // MFEM_LIBCEED_NLCONV_QF_H
diff --git a/fem/ceed/integrators/util/util_qf.h b/fem/ceed/integrators/util/util_qf.h
new file mode 100644
index 000000000..fa7ca763b
--- /dev/null
+++ b/fem/ceed/integrators/util/util_qf.h
@@ -0,0 +1,855 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_UTIL_QF_H
+#define MFEM_LIBCEED_UTIL_QF_H
+
+#include <math.h>
+
+CEED_QFUNCTION_HELPER CeedScalar DetJ22(const CeedScalar *J,
+                                        const CeedInt J_stride)
+{
+   // J: 0 2
+   //    1 3
+   return J[J_stride * 0] * J[J_stride * 3] -
+          J[J_stride * 1] * J[J_stride * 2];
+}
+
+CEED_QFUNCTION_HELPER CeedScalar DetJ21(const CeedScalar *J,
+                                        const CeedInt J_stride)
+{
+   // J: 0
+   //    1
+   return sqrt(J[J_stride * 0] * J[J_stride * 0] +
+               J[J_stride * 1] * J[J_stride * 1]);
+}
+
+CEED_QFUNCTION_HELPER CeedScalar DetJ33(const CeedScalar *J,
+                                        const CeedInt J_stride)
+{
+   // J: 0 3 6
+   //    1 4 7
+   //    2 5 8
+   return J[J_stride * 0] * (J[J_stride * 4] * J[J_stride * 8] -
+                             J[J_stride * 5] * J[J_stride * 7]) -
+          J[J_stride * 1] * (J[J_stride * 3] * J[J_stride * 8] -
+                             J[J_stride * 5] * J[J_stride * 6]) +
+          J[J_stride * 2] * (J[J_stride * 3] * J[J_stride * 7] -
+                             J[J_stride * 4] * J[J_stride * 6]);
+}
+
+CEED_QFUNCTION_HELPER CeedScalar DetJ32(const CeedScalar *J,
+                                        const CeedInt J_stride)
+{
+   // J: 0 3
+   //    1 4
+   //    2 5
+   const CeedScalar E = J[J_stride * 0] * J[J_stride * 0] +
+                        J[J_stride * 1] * J[J_stride * 1] +
+                        J[J_stride * 2] * J[J_stride * 2];
+   const CeedScalar G = J[J_stride * 3] * J[J_stride * 3] +
+                        J[J_stride * 4] * J[J_stride * 4] +
+                        J[J_stride * 5] * J[J_stride * 5];
+   const CeedScalar F = J[J_stride * 0] * J[J_stride * 3] +
+                        J[J_stride * 1] * J[J_stride * 4] +
+                        J[J_stride * 2] * J[J_stride * 5];
+   return sqrt(E * G - F * F);
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJCAdjJt22(const CeedScalar *J,
+                                            const CeedInt J_stride,
+                                            const CeedScalar *c,
+                                            const CeedInt c_stride,
+                                            const CeedInt c_comp,
+                                            const CeedScalar qw,
+                                            const CeedInt qd_stride,
+                                            CeedScalar *qd)
+{
+   // compute qw/det(J) adj(J) C adj(J)^T and store the symmetric part of the result
+   // J: 0 2   adj(J):  J22 -J12   qd: 0 1
+   //    1 3           -J21  J11       1 2
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J12 = J[J_stride * 2];
+   const CeedScalar J22 = J[J_stride * 3];
+   const CeedScalar w = qw / (J11 * J22 - J21 * J12);
+   if (c_comp == 3)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0 1
+      //    1 2
+      const CeedScalar R11 =  c[c_stride * 0] * J22 - c[c_stride * 1] * J12;
+      const CeedScalar R21 =  c[c_stride * 1] * J22 - c[c_stride * 2] * J12;
+      const CeedScalar R12 = -c[c_stride * 0] * J21 + c[c_stride * 1] * J11;
+      const CeedScalar R22 = -c[c_stride * 1] * J21 + c[c_stride * 2] * J11;
+      qd[qd_stride * 0] = w * (J22 * R11 - J12 * R21);
+      qd[qd_stride * 1] = w * (J11 * R21 - J21 * R11);
+      qd[qd_stride * 2] = w * (J11 * R22 - J21 * R12);
+   }
+   else if (c_comp == 2)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      qd[qd_stride * 0] =  w * (c[c_stride * 1] * J12 * J12 +
+                                c[c_stride * 0] * J22 * J22);
+      qd[qd_stride * 1] = -w * (c[c_stride * 1] * J11 * J12 +
+                                c[c_stride * 0] * J21 * J22);
+      qd[qd_stride * 2] =  w * (c[c_stride * 1] * J11 * J11 +
+                                c[c_stride * 0] * J21 * J21);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] =  w * c[c_stride * 0] * (J12 * J12 + J22 * J22);
+      qd[qd_stride * 1] = -w * c[c_stride * 0] * (J11 * J12 + J21 * J22);
+      qd[qd_stride * 2] =  w * c[c_stride * 0] * (J11 * J11 + J21 * J21);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJCAdjJt21(const CeedScalar *J,
+                                            const CeedInt J_stride,
+                                            const CeedScalar *c,
+                                            const CeedInt c_stride,
+                                            const CeedInt c_comp,
+                                            const CeedScalar qw,
+                                            const CeedInt qd_stride,
+                                            CeedScalar *qd)
+{
+   // compute qw/det(J) adj(J) C adj(J)^T and store the symmetric part of the result
+   // J: 0   adj(J): 1/sqrt(J^T J) J^T   qd: 0
+   //    1
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar d = J11 * J11 + J21 * J21;
+   const CeedScalar w = qw / sqrt(d);
+   if (c_comp == 3)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0 1
+      //    1 2
+      const CeedScalar R11 = c[c_stride * 0] * J11 + c[c_stride * 1] * J21;
+      const CeedScalar R21 = c[c_stride * 1] * J11 + c[c_stride * 2] * J21;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21) / d;
+   }
+   else if (c_comp == 2)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21) / d;
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] = w * c[c_stride * 0];
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJCAdjJt33(const CeedScalar *J,
+                                            const CeedInt J_stride,
+                                            const CeedScalar *c,
+                                            const CeedInt c_stride,
+                                            const CeedInt c_comp,
+                                            const CeedScalar qw,
+                                            const CeedInt qd_stride,
+                                            CeedScalar *qd)
+{
+   // compute qw/det(J) adj(J) C adj(J)^T and store the symmetric part of the result
+   // J: 0 3 6   qd: 0 1 2
+   //    1 4 7       1 3 4
+   //    2 5 8       2 4 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar J13 = J[J_stride * 6];
+   const CeedScalar J23 = J[J_stride * 7];
+   const CeedScalar J33 = J[J_stride * 8];
+   const CeedScalar A11 = J22 * J33 - J23 * J32;
+   const CeedScalar A12 = J13 * J32 - J12 * J33;
+   const CeedScalar A13 = J12 * J23 - J13 * J22;
+   const CeedScalar A21 = J23 * J31 - J21 * J33;
+   const CeedScalar A22 = J11 * J33 - J13 * J31;
+   const CeedScalar A23 = J13 * J21 - J11 * J23;
+   const CeedScalar A31 = J21 * J32 - J22 * J31;
+   const CeedScalar A32 = J12 * J31 - J11 * J32;
+   const CeedScalar A33 = J11 * J22 - J12 * J21;
+   const CeedScalar w = qw / (J11 * A11 + J21 * A12 + J31 * A13);
+   if (c_comp == 6)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0 1 2
+      //    1 3 4
+      //    2 4 5
+      const CeedScalar R11 = c[c_stride * 0] * A11 +
+                             c[c_stride * 1] * A12 +
+                             c[c_stride * 2] * A13;
+      const CeedScalar R12 = c[c_stride * 0] * A21 +
+                             c[c_stride * 1] * A22 +
+                             c[c_stride * 2] * A23;
+      const CeedScalar R13 = c[c_stride * 0] * A31 +
+                             c[c_stride * 1] * A32 +
+                             c[c_stride * 2] * A33;
+      const CeedScalar R21 = c[c_stride * 1] * A11 +
+                             c[c_stride * 3] * A12 +
+                             c[c_stride * 4] * A13;
+      const CeedScalar R22 = c[c_stride * 1] * A21 +
+                             c[c_stride * 3] * A22 +
+                             c[c_stride * 4] * A23;
+      const CeedScalar R23 = c[c_stride * 1] * A31 +
+                             c[c_stride * 3] * A32 +
+                             c[c_stride * 4] * A33;
+      const CeedScalar R31 = c[c_stride * 2] * A11 +
+                             c[c_stride * 4] * A12 +
+                             c[c_stride * 5] * A13;
+      const CeedScalar R32 = c[c_stride * 2] * A21 +
+                             c[c_stride * 4] * A22 +
+                             c[c_stride * 5] * A23;
+      const CeedScalar R33 = c[c_stride * 2] * A31 +
+                             c[c_stride * 4] * A32 +
+                             c[c_stride * 5] * A33;
+      qd[qd_stride * 0] = w * (A11 * R11 + A12 * R21 + A13 * R31);
+      qd[qd_stride * 1] = w * (A11 * R12 + A12 * R22 + A13 * R32);
+      qd[qd_stride * 2] = w * (A11 * R13 + A12 * R23 + A13 * R33);
+      qd[qd_stride * 3] = w * (A21 * R12 + A22 * R22 + A23 * R32);
+      qd[qd_stride * 4] = w * (A21 * R13 + A22 * R23 + A23 * R33);
+      qd[qd_stride * 5] = w * (A31 * R13 + A32 * R23 + A33 * R33);
+   }
+   else if (c_comp == 3)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      //        2
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * A11 * A11 +
+                               c[c_stride * 1] * A12 * A12 +
+                               c[c_stride * 2] * A13 * A13);
+      qd[qd_stride * 1] = w * (c[c_stride * 0] * A11 * A21 +
+                               c[c_stride * 1] * A12 * A22 +
+                               c[c_stride * 2] * A13 * A23);
+      qd[qd_stride * 2] = w * (c[c_stride * 0] * A11 * A31 +
+                               c[c_stride * 1] * A12 * A32 +
+                               c[c_stride * 2] * A13 * A33);
+      qd[qd_stride * 3] = w * (c[c_stride * 0] * A21 * A21 +
+                               c[c_stride * 1] * A22 * A22 +
+                               c[c_stride * 2] * A23 * A23);
+      qd[qd_stride * 4] = w * (c[c_stride * 0] * A21 * A31 +
+                               c[c_stride * 1] * A22 * A32 +
+                               c[c_stride * 2] * A23 * A33);
+      qd[qd_stride * 5] = w * (c[c_stride * 0] * A31 * A31 +
+                               c[c_stride * 1] * A32 * A32 +
+                               c[c_stride * 2] * A33 * A33);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] =
+         w * c[c_stride * 0] * (A11 * A11 + A12 * A12 + A13 * A13);
+      qd[qd_stride * 1] =
+         w * c[c_stride * 0] * (A11 * A21 + A12 * A22 + A13 * A23);
+      qd[qd_stride * 2] =
+         w * c[c_stride * 0] * (A11 * A31 + A12 * A32 + A13 * A33);
+      qd[qd_stride * 3] =
+         w * c[c_stride * 0] * (A21 * A21 + A22 * A22 + A23 * A23);
+      qd[qd_stride * 4] =
+         w * c[c_stride * 0] * (A21 * A31 + A22 * A32 + A23 * A33);
+      qd[qd_stride * 5] =
+         w * c[c_stride * 0] * (A31 * A31 + A32 * A32 + A33 * A33);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJCAdjJt32(const CeedScalar *J,
+                                            const CeedInt J_stride,
+                                            const CeedScalar *c,
+                                            const CeedInt c_stride,
+                                            const CeedInt c_comp,
+                                            const CeedScalar qw,
+                                            const CeedInt qd_stride,
+                                            CeedScalar *qd)
+{
+   // compute qw/det(J) adj(J) C adj(J)^T and store the symmetric part of the result
+   // J: 0 3   qd: 0 1
+   //    1 4       1 2
+   //    2 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar E = J11 * J11 + J21 * J21 + J31 * J31;
+   const CeedScalar G = J12 * J12 + J22 * J22 + J32 * J32;
+   const CeedScalar F = J11 * J12 + J21 * J22 + J31 * J32;
+   const CeedScalar d = E * G - F * F;
+   const CeedScalar w = qw / sqrt(d);
+   if (c_comp == 6)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0 1 2
+      //    1 3 4
+      //    2 4 5
+      const CeedScalar R11 = G * (c[c_stride * 0] * J11 +
+                                  c[c_stride * 1] * J21 +
+                                  c[c_stride * 2] * J31) -
+                             F * (c[c_stride * 0] * J12 +
+                                  c[c_stride * 1] * J22 +
+                                  c[c_stride * 2] * J32);
+      const CeedScalar R21 = G * (c[c_stride * 1] * J11 +
+                                  c[c_stride * 3] * J21 +
+                                  c[c_stride * 4] * J31) -
+                             F * (c[c_stride * 1] * J12 +
+                                  c[c_stride * 3] * J22 +
+                                  c[c_stride * 4] * J32);
+      const CeedScalar R31 = G * (c[c_stride * 2] * J11 +
+                                  c[c_stride * 4] * J21 +
+                                  c[c_stride * 5] * J31) -
+                             F * (c[c_stride * 2] * J12 +
+                                  c[c_stride * 4] * J22 +
+                                  c[c_stride * 5] * J32);
+      const CeedScalar R12 = E * (c[c_stride * 0] * J12 +
+                                  c[c_stride * 1] * J22 +
+                                  c[c_stride * 2] * J32) -
+                             F * (c[c_stride * 0] * J11 +
+                                  c[c_stride * 1] * J21 +
+                                  c[c_stride * 2] * J31);
+      const CeedScalar R22 = E * (c[c_stride * 1] * J12 +
+                                  c[c_stride * 3] * J22 +
+                                  c[c_stride * 4] * J32) -
+                             F * (c[c_stride * 1] * J11 +
+                                  c[c_stride * 3] * J21 +
+                                  c[c_stride * 4] * J31);
+      const CeedScalar R32 = E * (c[c_stride * 2] * J12 +
+                                  c[c_stride * 4] * J22 +
+                                  c[c_stride * 5] * J32) -
+                             F * (c[c_stride * 2] * J11 +
+                                  c[c_stride * 4] * J21 +
+                                  c[c_stride * 5] * J31);
+      qd[qd_stride * 0] = w * (G * (J11 * R11 + J21 * R21 + J31 * R31) -
+                               F * (J12 * R11 + J22 * R21 + J32 * R31)) / d;
+      qd[qd_stride * 1] = w * (G * (J11 * R12 + J21 * R22 + J31 * R32) -
+                               F * (J12 * R12 + J22 * R22 + J32 * R32)) / d;
+      qd[qd_stride * 2] = w * (E * (J12 * R12 + J22 * R22 + J32 * R32) -
+                               F * (J11 * R12 + J21 * R22 + J31 * R32)) / d;
+   }
+   else if (c_comp == 3)  // Vector coefficient
+   {
+      // First compute entries of R = C adj(J)^T
+      // c: 0
+      //      1
+      //        2
+      const CeedScalar R11 = c[c_stride * 0] * (G * J11 - F * J12);
+      const CeedScalar R21 = c[c_stride * 1] * (G * J21 - F * J22);
+      const CeedScalar R31 = c[c_stride * 2] * (G * J31 - F * J32);
+      const CeedScalar R12 = c[c_stride * 0] * (E * J12 - F * J11);
+      const CeedScalar R22 = c[c_stride * 1] * (E * J22 - F * J21);
+      const CeedScalar R32 = c[c_stride * 2] * (E * J32 - F * J31);
+      qd[qd_stride * 0] = w * (G * (J11 * R11 + J21 * R21 + J31 * R31) -
+                               F * (J12 * R11 + J22 * R21 + J32 * R31)) / d;
+      qd[qd_stride * 1] = w * (G * (J11 * R12 + J21 * R22 + J31 * R32) -
+                               F * (J12 * R12 + J22 * R22 + J32 * R32)) / d;
+      qd[qd_stride * 2] = w * (E * (J12 * R12 + J22 * R22 + J32 * R32) -
+                               F * (J11 * R12 + J21 * R22 + J31 * R32)) / d;
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] =  w * c[c_stride * 0] * G;
+      qd[qd_stride * 1] = -w * c[c_stride * 0] * F;
+      qd[qd_stride * 2] =  w * c[c_stride * 0] * E;
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultJtCJ22(const CeedScalar *J,
+                                      const CeedInt J_stride,
+                                      const CeedScalar *c,
+                                      const CeedInt c_stride,
+                                      const CeedInt c_comp,
+                                      const CeedScalar qw,
+                                      const CeedInt qd_stride,
+                                      CeedScalar *qd)
+{
+   // compute qw/det(J) J^T C J and store the symmetric part of the result
+   // J: 0 2   qd: 0 1
+   //    1 3       1 2
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J12 = J[J_stride * 2];
+   const CeedScalar J22 = J[J_stride * 3];
+   const CeedScalar w = qw / (J11 * J22 - J21 * J12);
+   if (c_comp == 3)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C J
+      // c: 0 1
+      //    1 2
+      const CeedScalar R11 = c[c_stride * 0] * J11 + c[c_stride * 1] * J21;
+      const CeedScalar R21 = c[c_stride * 1] * J11 + c[c_stride * 2] * J21;
+      const CeedScalar R12 = c[c_stride * 0] * J12 + c[c_stride * 1] * J22;
+      const CeedScalar R22 = c[c_stride * 1] * J12 + c[c_stride * 2] * J22;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21);
+      qd[qd_stride * 1] = w * (J11 * R12 + J21 * R22);
+      qd[qd_stride * 2] = w * (J12 * R12 + J22 * R22);
+   }
+   else if (c_comp == 2)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21);
+      qd[qd_stride * 1] = w * (c[c_stride * 0] * J11 * J12 +
+                               c[c_stride * 1] * J21 * J22);
+      qd[qd_stride * 2] = w * (c[c_stride * 0] * J12 * J12 +
+                               c[c_stride * 1] * J22 * J22);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] = w * c[c_stride * 0] * (J11 * J11 + J21 * J21);
+      qd[qd_stride * 1] = w * c[c_stride * 0] * (J11 * J12 + J21 * J22);
+      qd[qd_stride * 2] = w * c[c_stride * 0] * (J12 * J12 + J22 * J22);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultJtCJ21(const CeedScalar *J,
+                                      const CeedInt J_stride,
+                                      const CeedScalar *c,
+                                      const CeedInt c_stride,
+                                      const CeedInt c_comp,
+                                      const CeedScalar qw,
+                                      const CeedInt qd_stride,
+                                      CeedScalar *qd)
+{
+   // compute qw/det(J) J^T C J and store the symmetric part of the result
+   // J: 0   qd: 0
+   //    1
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   if (c_comp == 3)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C J
+      // c: 0 1
+      //    1 2
+      const CeedScalar w = qw / sqrt(J11 * J11 + J21 * J21);
+      const CeedScalar R11 = c[c_stride * 0] * J11 + c[c_stride * 1] * J21;
+      const CeedScalar R21 = c[c_stride * 1] * J11 + c[c_stride * 2] * J21;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21);
+   }
+   else if (c_comp == 2)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      const CeedScalar w = qw / sqrt(J11 * J11 + J21 * J21);
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] = qw * c[c_stride * 0] * sqrt(J11 * J11 + J21 * J21);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultJtCJ33(const CeedScalar *J,
+                                      const CeedInt J_stride,
+                                      const CeedScalar *c,
+                                      const CeedInt c_stride,
+                                      const CeedInt c_comp,
+                                      const CeedScalar qw,
+                                      const CeedInt qd_stride,
+                                      CeedScalar *qd)
+{
+   // compute qw/det(J) J^T C J and store the symmetric part of the result
+   // J: 0 3 6   qd: 0 1 2
+   //    1 4 7       1 3 4
+   //    2 5 8       2 4 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar J13 = J[J_stride * 6];
+   const CeedScalar J23 = J[J_stride * 7];
+   const CeedScalar J33 = J[J_stride * 8];
+   const CeedScalar w = qw / (J11 * (J22 * J33 - J23 * J32) +
+                              J21 * (J13 * J32 - J12 * J33) +
+                              J31 * (J12 * J23 - J13 * J22));
+   if (c_comp == 6)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C J
+      // c: 0 1 2
+      //    1 3 4
+      //    2 4 5
+      const CeedScalar R11 = c[c_stride * 0] * J11 +
+                             c[c_stride * 1] * J21 +
+                             c[c_stride * 2] * J31;
+      const CeedScalar R12 = c[c_stride * 0] * J12 +
+                             c[c_stride * 1] * J22 +
+                             c[c_stride * 2] * J32;
+      const CeedScalar R13 = c[c_stride * 0] * J13 +
+                             c[c_stride * 1] * J23 +
+                             c[c_stride * 2] * J33;
+      const CeedScalar R21 = c[c_stride * 1] * J11 +
+                             c[c_stride * 3] * J21 +
+                             c[c_stride * 4] * J31;
+      const CeedScalar R22 = c[c_stride * 1] * J12 +
+                             c[c_stride * 3] * J22 +
+                             c[c_stride * 4] * J32;
+      const CeedScalar R23 = c[c_stride * 1] * J13 +
+                             c[c_stride * 3] * J23 +
+                             c[c_stride * 4] * J33;
+      const CeedScalar R31 = c[c_stride * 2] * J11 +
+                             c[c_stride * 4] * J21 +
+                             c[c_stride * 5] * J31;
+      const CeedScalar R32 = c[c_stride * 2] * J12 +
+                             c[c_stride * 4] * J22 +
+                             c[c_stride * 5] * J32;
+      const CeedScalar R33 = c[c_stride * 2] * J13 +
+                             c[c_stride * 4] * J23 +
+                             c[c_stride * 5] * J33;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21 + J31 * R31);
+      qd[qd_stride * 1] = w * (J11 * R12 + J21 * R22 + J31 * R32);
+      qd[qd_stride * 2] = w * (J11 * R13 + J21 * R23 + J31 * R33);
+      qd[qd_stride * 3] = w * (J12 * R12 + J22 * R22 + J32 * R32);
+      qd[qd_stride * 4] = w * (J12 * R13 + J22 * R23 + J32 * R33);
+      qd[qd_stride * 5] = w * (J13 * R13 + J23 * R23 + J33 * R33);
+   }
+   else if (c_comp == 3)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      //        2
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21 +
+                               c[c_stride * 2] * J31 * J31);
+      qd[qd_stride * 1] = w * (c[c_stride * 0] * J11 * J12 +
+                               c[c_stride * 1] * J21 * J22 +
+                               c[c_stride * 2] * J31 * J32);
+      qd[qd_stride * 2] = w * (c[c_stride * 0] * J11 * J13 +
+                               c[c_stride * 1] * J21 * J23 +
+                               c[c_stride * 2] * J31 * J33);
+      qd[qd_stride * 3] = w * (c[c_stride * 0] * J12 * J12 +
+                               c[c_stride * 1] * J22 * J22 +
+                               c[c_stride * 2] * J32 * J32);
+      qd[qd_stride * 4] = w * (c[c_stride * 0] * J12 * J13 +
+                               c[c_stride * 1] * J22 * J23 +
+                               c[c_stride * 2] * J32 * J33);
+      qd[qd_stride * 5] = w * (c[c_stride * 0] * J13 * J13 +
+                               c[c_stride * 1] * J23 * J23 +
+                               c[c_stride * 2] * J33 * J33);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] =
+         w * c[c_stride * 0] * (J11 * J11 + J21 * J21 + J31 * J31);
+      qd[qd_stride * 1] =
+         w * c[c_stride * 0] * (J11 * J12 + J21 * J22 + J31 * J32);
+      qd[qd_stride * 2] =
+         w * c[c_stride * 0] * (J11 * J13 + J21 * J23 + J31 * J33);
+      qd[qd_stride * 3] =
+         w * c[c_stride * 0] * (J12 * J12 + J22 * J22 + J32 * J32);
+      qd[qd_stride * 4] =
+         w * c[c_stride * 0] * (J12 * J13 + J22 * J23 + J32 * J33);
+      qd[qd_stride * 5] =
+         w * c[c_stride * 0] * (J13 * J13 + J23 * J23 + J33 * J33);
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultJtCJ32(const CeedScalar *J,
+                                      const CeedInt J_stride,
+                                      const CeedScalar *c,
+                                      const CeedInt c_stride,
+                                      const CeedInt c_comp,
+                                      const CeedScalar qw,
+                                      const CeedInt qd_stride,
+                                      CeedScalar *qd)
+{
+   // compute qw/det(J) J^T C J and store the symmetric part of the result
+   // J: 0 3   qd: 0 1
+   //    1 4       1 2
+   //    2 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar E = J11 * J11 + J21 * J21 + J31 * J31;
+   const CeedScalar G = J12 * J12 + J22 * J22 + J32 * J32;
+   const CeedScalar F = J11 * J12 + J21 * J22 + J31 * J32;
+   const CeedScalar w = qw / sqrt(E * G - F * F);
+   if (c_comp == 6)  // Matrix coefficient (symmetric)
+   {
+      // First compute entries of R = C J
+      // c: 0 1 2
+      //    1 3 4
+      //    2 4 5
+      const CeedScalar R11 = c[c_stride * 0] * J11 +
+                             c[c_stride * 1] * J21 +
+                             c[c_stride * 2] * J31;
+      const CeedScalar R21 = c[c_stride * 1] * J11 +
+                             c[c_stride * 3] * J21 +
+                             c[c_stride * 4] * J31;
+      const CeedScalar R31 = c[c_stride * 2] * J11 +
+                             c[c_stride * 4] * J21 +
+                             c[c_stride * 5] * J31;
+      const CeedScalar R12 = c[c_stride * 0] * J12 +
+                             c[c_stride * 1] * J22 +
+                             c[c_stride * 2] * J32;
+      const CeedScalar R22 = c[c_stride * 1] * J12 +
+                             c[c_stride * 3] * J22 +
+                             c[c_stride * 4] * J32;
+      const CeedScalar R32 = c[c_stride * 2] * J12 +
+                             c[c_stride * 4] * J22 +
+                             c[c_stride * 5] * J32;
+      qd[qd_stride * 0] = w * (J11 * R11 + J21 * R21 + J31 * R31);
+      qd[qd_stride * 1] = w * (J11 * R12 + J21 * R22 + J31 * R32);
+      qd[qd_stride * 2] = w * (J12 * R12 + J22 * R22 + J32 * R32);
+   }
+   else if (c_comp == 3)  // Vector coefficient
+   {
+      // c: 0
+      //      1
+      //        2
+      qd[qd_stride * 0] = w * (c[c_stride * 0] * J11 * J11 +
+                               c[c_stride * 1] * J21 * J21 +
+                               c[c_stride * 2] * J31 * J31);
+      qd[qd_stride * 1] = w * (c[c_stride * 0] * J11 * J12 +
+                               c[c_stride * 1] * J21 * J22 +
+                               c[c_stride * 2] * J31 * J32);
+      qd[qd_stride * 2] = w * (c[c_stride * 0] * J12 * J12 +
+                               c[c_stride * 1] * J22 * J22 +
+                               c[c_stride * 2] * J32 * J32);
+   }
+   else  // Scalar coefficient
+   {
+      qd[qd_stride * 0] = w * c[c_stride * 0] * E;
+      qd[qd_stride * 1] = w * c[c_stride * 0] * F;
+      qd[qd_stride * 2] = w * c[c_stride * 0] * G;
+   }
+}
+
+CEED_QFUNCTION_HELPER void MultCtAdjJt22(const CeedScalar *J,
+                                         const CeedInt J_stride,
+                                         const CeedScalar *c,
+                                         const CeedInt c_stride,
+                                         const CeedScalar qw,
+                                         const CeedInt qd_stride,
+                                         CeedScalar *qd)
+{
+   // compute qw c^T adj(J)^T and store the result vector
+   // J: 0 2   adj(J):  J22 -J12
+   //    1 3           -J21  J11
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J12 = J[J_stride * 2];
+   const CeedScalar J22 = J[J_stride * 3];
+   const CeedScalar w1 = qw * c[c_stride * 0];
+   const CeedScalar w2 = qw * c[c_stride * 1];
+   qd[qd_stride * 0] =  w1 * J22 - w2 * J12;
+   qd[qd_stride * 1] = -w1 * J21 + w2 * J11;
+}
+
+CEED_QFUNCTION_HELPER void MultCtAdjJt21(const CeedScalar *J,
+                                         const CeedInt J_stride,
+                                         const CeedScalar *c,
+                                         const CeedInt c_stride,
+                                         const CeedScalar qw,
+                                         const CeedInt qd_stride,
+                                         CeedScalar *qd)
+{
+   // compute qw c^T adj(J)^T and store the result vector
+   // J: 0   adj(J): 1/sqrt(J^T J) J^T
+   //    1
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar w = qw / sqrt(J11 * J11 + J21 * J21);
+   const CeedScalar w1 = w * c[c_stride * 0];
+   const CeedScalar w2 = w * c[c_stride * 1];
+   qd[qd_stride * 0] =  w1 * J11 + w2 * J21;
+}
+
+CEED_QFUNCTION_HELPER void MultCtAdjJt33(const CeedScalar *J,
+                                         const CeedInt J_stride,
+                                         const CeedScalar *c,
+                                         const CeedInt c_stride,
+                                         const CeedScalar qw,
+                                         const CeedInt qd_stride,
+                                         CeedScalar *qd)
+{
+   // compute qw c^T adj(J)^T and store the result vector
+   // J: 0 3 6
+   //    1 4 7
+   //    2 5 8
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar J13 = J[J_stride * 6];
+   const CeedScalar J23 = J[J_stride * 7];
+   const CeedScalar J33 = J[J_stride * 8];
+   const CeedScalar A11 = J22 * J33 - J23 * J32;
+   const CeedScalar A12 = J13 * J32 - J12 * J33;
+   const CeedScalar A13 = J12 * J23 - J13 * J22;
+   const CeedScalar A21 = J23 * J31 - J21 * J33;
+   const CeedScalar A22 = J11 * J33 - J13 * J31;
+   const CeedScalar A23 = J13 * J21 - J11 * J23;
+   const CeedScalar A31 = J21 * J32 - J22 * J31;
+   const CeedScalar A32 = J12 * J31 - J11 * J32;
+   const CeedScalar A33 = J11 * J22 - J12 * J21;
+   const CeedScalar w1 = qw * c[c_stride * 0];
+   const CeedScalar w2 = qw * c[c_stride * 1];
+   const CeedScalar w3 = qw * c[c_stride * 2];
+   qd[qd_stride * 0] = w1 * A11 + w2 * A12 + w3 * A13;
+   qd[qd_stride * 1] = w1 * A21 + w2 * A22 + w3 * A23;
+   qd[qd_stride * 2] = w1 * A31 + w2 * A32 + w3 * A33;
+}
+
+CEED_QFUNCTION_HELPER void MultCtAdjJt32(const CeedScalar *J,
+                                         const CeedInt J_stride,
+                                         const CeedScalar *c,
+                                         const CeedInt c_stride,
+                                         const CeedScalar qw,
+                                         const CeedInt qd_stride,
+                                         CeedScalar *qd)
+{
+   // compute qw c^T adj(J)^T and store the result vector
+   // J: 0 3
+   //    1 4
+   //    2 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar E = J11 * J11 + J21 * J21 + J31 * J31;
+   const CeedScalar G = J12 * J12 + J22 * J22 + J32 * J32;
+   const CeedScalar F = J11 * J12 + J21 * J22 + J31 * J32;
+   const CeedScalar A11 = G * J11 - F * J12;
+   const CeedScalar A21 = E * J12 - F * J11;
+   const CeedScalar A12 = G * J21 - F * J22;
+   const CeedScalar A22 = E * J22 - F * J21;
+   const CeedScalar A13 = G * J31 - F * J32;
+   const CeedScalar A23 = E * J32 - F * J31;
+   const CeedScalar w = qw / sqrt(E * G - F * F);
+   const CeedScalar w1 = w * c[c_stride * 0];
+   const CeedScalar w2 = w * c[c_stride * 1];
+   const CeedScalar w3 = w * c[c_stride * 2];
+   qd[qd_stride * 0] = w1 * A11 + w2 * A12 + w3 * A13;
+   qd[qd_stride * 1] = w1 * A21 + w2 * A22 + w3 * A23;
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJt22(const CeedScalar *J,
+                                       const CeedInt J_stride,
+                                       const CeedScalar qw,
+                                       const CeedInt qd_stride,
+                                       CeedScalar *qd)
+{
+   // compute qw adj(J)^T and store the result matrix
+   // J: 0 2   adj(J):  J22 -J12   qd: 0 2
+   //    1 3           -J21  J11       1 3
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J12 = J[J_stride * 2];
+   const CeedScalar J22 = J[J_stride * 3];
+   qd[qd_stride * 0] =  qw * J22;
+   qd[qd_stride * 1] = -qw * J12;
+   qd[qd_stride * 2] = -qw * J21;
+   qd[qd_stride * 3] =  qw * J11;
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJt21(const CeedScalar *J,
+                                       const CeedInt J_stride,
+                                       const CeedScalar qw,
+                                       const CeedInt qd_stride,
+                                       CeedScalar *qd)
+{
+   // compute qw adj(J)^T and store the result matrix
+   // J: 0   adj(J):  1/sqrt(J^T J) J^T   qd: 0
+   //    1                                    1
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar w = qw / sqrt(J11 * J11 + J21 * J21);
+   qd[qd_stride * 0] = w * J11;
+   qd[qd_stride * 1] = w * J21;
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJt33(const CeedScalar *J,
+                                       const CeedInt J_stride,
+                                       const CeedScalar qw,
+                                       const CeedInt qd_stride,
+                                       CeedScalar *qd)
+{
+   // compute qw adj(J)^T and store the result matrix
+   // J: 0 3 6   qd: 0 3 6
+   //    1 4 7       1 4 7
+   //    2 5 8       2 5 8
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar J13 = J[J_stride * 6];
+   const CeedScalar J23 = J[J_stride * 7];
+   const CeedScalar J33 = J[J_stride * 8];
+   const CeedScalar A11 = J22 * J33 - J23 * J32;
+   const CeedScalar A12 = J13 * J32 - J12 * J33;
+   const CeedScalar A13 = J12 * J23 - J13 * J22;
+   const CeedScalar A21 = J23 * J31 - J21 * J33;
+   const CeedScalar A22 = J11 * J33 - J13 * J31;
+   const CeedScalar A23 = J13 * J21 - J11 * J23;
+   const CeedScalar A31 = J21 * J32 - J22 * J31;
+   const CeedScalar A32 = J12 * J31 - J11 * J32;
+   const CeedScalar A33 = J11 * J22 - J12 * J21;
+   qd[qd_stride * 0] = qw * A11;
+   qd[qd_stride * 1] = qw * A12;
+   qd[qd_stride * 2] = qw * A13;
+   qd[qd_stride * 3] = qw * A21;
+   qd[qd_stride * 4] = qw * A22;
+   qd[qd_stride * 5] = qw * A23;
+   qd[qd_stride * 6] = qw * A31;
+   qd[qd_stride * 7] = qw * A32;
+   qd[qd_stride * 8] = qw * A33;
+}
+
+CEED_QFUNCTION_HELPER void MultAdjJt32(const CeedScalar *J,
+                                       const CeedInt J_stride,
+                                       const CeedScalar qw,
+                                       const CeedInt qd_stride,
+                                       CeedScalar *qd)
+{
+   // compute qw adj(J)^T and store the result matrix
+   // J: 0 3   qd: 0 3
+   //    1 4       1 4
+   //    2 5       2 5
+   const CeedScalar J11 = J[J_stride * 0];
+   const CeedScalar J21 = J[J_stride * 1];
+   const CeedScalar J31 = J[J_stride * 2];
+   const CeedScalar J12 = J[J_stride * 3];
+   const CeedScalar J22 = J[J_stride * 4];
+   const CeedScalar J32 = J[J_stride * 5];
+   const CeedScalar E = J11 * J11 + J21 * J21 + J31 * J31;
+   const CeedScalar G = J12 * J12 + J22 * J22 + J32 * J32;
+   const CeedScalar F = J11 * J12 + J21 * J22 + J31 * J32;
+   const CeedScalar A11 = G * J11 - F * J12;
+   const CeedScalar A21 = E * J12 - F * J11;
+   const CeedScalar A12 = G * J21 - F * J22;
+   const CeedScalar A22 = E * J22 - F * J21;
+   const CeedScalar A13 = G * J31 - F * J32;
+   const CeedScalar A23 = E * J32 - F * J31;
+   const CeedScalar w = qw / sqrt(E * G - F * F);
+   qd[qd_stride * 0] = w * A11;
+   qd[qd_stride * 1] = w * A12;
+   qd[qd_stride * 2] = w * A13;
+   qd[qd_stride * 3] = w * A21;
+   qd[qd_stride * 4] = w * A22;
+   qd[qd_stride * 5] = w * A23;
+}
+
+#endif // MFEM_LIBCEED_UTIL_QF_H
diff --git a/fem/ceed/integrators/vecfemass/vecfemass.cpp b/fem/ceed/integrators/vecfemass/vecfemass.cpp
new file mode 100644
index 000000000..ea57d7e19
--- /dev/null
+++ b/fem/ceed/integrators/vecfemass/vecfemass.cpp
@@ -0,0 +1,279 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "vecfemass.hpp"
+
+#include "../../../../config/config.hpp"
+#ifdef MFEM_USE_CEED
+#include "vecfemass_qf.h"
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+#ifdef MFEM_USE_CEED
+struct VectorFEMassOperatorInfo : public OperatorInfo
+{
+   VectorFEMassContext ctx = {0};
+   bool ctx_coeff = false;
+   template <typename CoeffType>
+   VectorFEMassOperatorInfo(const mfem::FiniteElementSpace &fes, CoeffType *Q,
+                            bool use_bdr = false, bool use_mf = false)
+   {
+      MFEM_VERIFY(fes.GetVDim() == 1,
+                  "libCEED interface for vector FE does not support vdim > 1!");
+      ctx.dim = fes.GetMesh()->Dimension() - use_bdr;
+      ctx.space_dim = fes.GetMesh()->SpaceDimension();
+      bool is_hdiv = (fes.FEColl()->GetMapType(ctx.dim) ==
+                      mfem::FiniteElement::H_DIV);
+      MFEM_VERIFY(is_hdiv ||
+                  fes.FEColl()->GetMapType(ctx.dim) == mfem::FiniteElement::H_CURL,
+                  "VectorFEMassIntegrator requires H(div) or H(curl) FE space!");
+      if (!use_mf)
+      {
+         apply_func = ":f_apply_vecfemass";
+         apply_qf = &f_apply_vecfemass;
+      }
+      else
+      {
+         build_func = "";
+         build_qf = nullptr;
+      }
+      if (Q == nullptr)
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = 1.0;
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_const_scalar" :
+                         ":f_build_hcurlmass_const_scalar";
+            build_qf = is_hdiv ? &f_build_hdivmass_const_scalar :
+                       &f_build_hcurlmass_const_scalar;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_const_scalar" :
+                         ":f_apply_hcurlmass_mf_const_scalar";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_const_scalar :
+                       &f_apply_hcurlmass_mf_const_scalar;
+         }
+      }
+      else
+      {
+         InitCoefficient(*Q, is_hdiv, use_mf);
+      }
+      header = "/integrators/vecfemass/vecfemass_qf.h";
+      trial_op = EvalMode::Interp;
+      test_op = EvalMode::Interp;
+      qdatasize = (ctx.dim * (ctx.dim + 1)) / 2;
+   }
+   void InitCoefficient(mfem::Coefficient &Q, bool is_hdiv, bool use_mf)
+   {
+      if (mfem::ConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::ConstantCoefficient *>(&Q))
+      {
+         ctx_coeff = true;
+         ctx.coeff[0] = const_coeff->constant;
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_const_scalar" :
+                         ":f_build_hcurlmass_const_scalar";
+            build_qf = is_hdiv ? &f_build_hdivmass_const_scalar :
+                       &f_build_hcurlmass_const_scalar;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_const_scalar" :
+                         ":f_apply_hcurlmass_mf_const_scalar";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_const_scalar :
+                       &f_apply_hcurlmass_mf_const_scalar;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_quad_scalar" :
+                         ":f_build_hcurlmass_quad_scalar";
+            build_qf = is_hdiv ? &f_build_hdivmass_quad_scalar :
+                       &f_build_hcurlmass_quad_scalar;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_quad_scalar" :
+                         ":f_apply_hcurlmass_mf_quad_scalar";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_quad_scalar :
+                       &f_apply_hcurlmass_mf_quad_scalar;
+         }
+      }
+   }
+   void InitCoefficient(mfem::VectorCoefficient &VQ, bool is_hdiv, bool use_mf)
+   {
+      if (mfem::VectorConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::VectorConstantCoefficient *>(&VQ))
+      {
+         ctx_coeff = true;
+         const int vdim = VQ.GetVDim();
+         MFEM_VERIFY(vdim <= LIBCEED_VECFEMASS_COEFF_COMP_MAX,
+                     "VectorCoefficient dimension exceeds context storage!");
+         const mfem::Vector &val = const_coeff->GetVec();
+         for (int i = 0; i < vdim; i++)
+         {
+            ctx.coeff[i] = val[i];
+         }
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_const_vector" :
+                         ":f_build_hcurlmass_const_vector";
+            build_qf = is_hdiv ? &f_build_hdivmass_const_vector :
+                       &f_build_hcurlmass_const_vector;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_const_vector" :
+                         ":f_apply_hcurlmass_mf_const_vector";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_const_vector :
+                       &f_apply_hcurlmass_mf_const_vector;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_quad_vector" :
+                         ":f_build_hcurlmass_quad_vector";
+            build_qf = is_hdiv ? &f_build_hdivmass_quad_vector :
+                       &f_build_hcurlmass_quad_vector;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_quad_vector" :
+                         ":f_apply_hcurlmass_mf_quad_vector";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_quad_vector :
+                       &f_apply_hcurlmass_mf_quad_vector;
+         }
+      }
+   }
+   void InitCoefficient(mfem::MatrixCoefficient &MQ, bool is_hdiv, bool use_mf)
+   {
+      // Assumes matrix coefficient is symmetric
+      if (mfem::MatrixConstantCoefficient *const_coeff =
+             dynamic_cast<mfem::MatrixConstantCoefficient *>(&MQ))
+      {
+         ctx_coeff = true;
+         const int vdim = MQ.GetVDim();
+         MFEM_VERIFY((vdim * (vdim + 1)) / 2 <= LIBCEED_VECFEMASS_COEFF_COMP_MAX,
+                     "MatrixCoefficient dimensions exceed context storage!");
+         const mfem::DenseMatrix &val = const_coeff->GetMatrix();
+         for (int j = 0; j < vdim; j++)
+         {
+            for (int i = j; i < vdim; i++)
+            {
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               ctx.coeff[idx] = val(i, j);
+            }
+         }
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_const_matrix" :
+                         ":f_build_hcurlmass_const_matrix";
+            build_qf = is_hdiv ? &f_build_hdivmass_const_matrix :
+                       &f_build_hcurlmass_const_matrix;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_const_matrix" :
+                         ":f_apply_hcurlmass_mf_const_matrix";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_const_matrix :
+                       &f_apply_hcurlmass_mf_const_matrix;
+         }
+      }
+      else
+      {
+         if (!use_mf)
+         {
+            build_func = is_hdiv ? ":f_build_hdivmass_quad_matrix" :
+                         ":f_build_hcurlmass_quad_matrix";
+            build_qf = is_hdiv ? &f_build_hdivmass_quad_matrix :
+                       &f_build_hcurlmass_quad_matrix;
+         }
+         else
+         {
+            apply_func = is_hdiv ? ":f_apply_hdivmass_mf_quad_matrix" :
+                         ":f_apply_hcurlmass_mf_quad_matrix";
+            apply_qf = is_hdiv ? &f_apply_hdivmass_mf_quad_matrix :
+                       &f_apply_hcurlmass_mf_quad_matrix;
+         }
+      }
+   }
+};
+#endif
+
+template <typename CoeffType>
+PAVectorFEMassIntegrator::PAVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   VectorFEMassOperatorInfo info(fes, Q, use_bdr);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+template <typename CoeffType>
+MFVectorFEMassIntegrator::MFVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &integ,
+   const mfem::FiniteElementSpace &fes,
+   CoeffType *Q,
+   const bool use_bdr)
+{
+#ifdef MFEM_USE_CEED
+   VectorFEMassOperatorInfo info(fes, Q, use_bdr, true);
+   Assemble(integ, info, fes, !info.ctx_coeff ? Q : nullptr, use_bdr, true);
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+// @cond DOXYGEN_SKIP
+
+template PAVectorFEMassIntegrator::PAVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template PAVectorFEMassIntegrator::PAVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template PAVectorFEMassIntegrator::PAVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+template MFVectorFEMassIntegrator::MFVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::Coefficient *, const bool);
+template MFVectorFEMassIntegrator::MFVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::VectorCoefficient *, const bool);
+template MFVectorFEMassIntegrator::MFVectorFEMassIntegrator(
+   const mfem::VectorFEMassIntegrator &, const mfem::FiniteElementSpace &,
+   mfem::MatrixCoefficient *, const bool);
+
+// @endcond
+
+} // namespace ceed
+
+} // namespace mfem
diff --git a/fem/ceed/integrators/vecfemass/vecfemass.hpp b/fem/ceed/integrators/vecfemass/vecfemass.hpp
new file mode 100644
index 000000000..aa0ca2ea3
--- /dev/null
+++ b/fem/ceed/integrators/vecfemass/vecfemass.hpp
@@ -0,0 +1,51 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_VECFEMASS_HPP
+#define MFEM_LIBCEED_VECFEMASS_HPP
+
+#include "../../interface/integrator.hpp"
+#include "../../interface/mixed_operator.hpp"
+#include "../../../fespace.hpp"
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/// Represent a VectorFEMassIntegrator with AssemblyLevel::Partial using libCEED.
+class PAVectorFEMassIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   PAVectorFEMassIntegrator(const mfem::VectorFEMassIntegrator &integ,
+                            const mfem::FiniteElementSpace &fes,
+                            CoeffType *Q,
+                            const bool use_bdr = false);
+};
+
+/// Represent a VectorFEMassIntegrator with AssemblyLevel::None using libCEED.
+class MFVectorFEMassIntegrator : public MixedOperator<Integrator>
+{
+public:
+   template <typename CoeffType>
+   MFVectorFEMassIntegrator(const mfem::VectorFEMassIntegrator &integ,
+                            const mfem::FiniteElementSpace &fes,
+                            CoeffType *Q,
+                            const bool use_bdr = false);
+};
+
+}
+
+}
+
+#endif // MFEM_LIBCEED_VECFEMASS_HPP
diff --git a/fem/ceed/integrators/vecfemass/vecfemass_qf.h b/fem/ceed/integrators/vecfemass/vecfemass_qf.h
new file mode 100644
index 000000000..571316ba8
--- /dev/null
+++ b/fem/ceed/integrators/vecfemass/vecfemass_qf.h
@@ -0,0 +1,1454 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_VECFEMASS_QF_H
+#define MFEM_LIBCEED_VECFEMASS_QF_H
+
+#include "../util/util_qf.h"
+
+#define LIBCEED_VECFEMASS_COEFF_COMP_MAX 6
+
+struct VectorFEMassContext
+{
+   CeedInt dim, space_dim;
+   CeedScalar coeff[LIBCEED_VECFEMASS_COEFF_COMP_MAX];
+};
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a scalar constant coefficient
+CEED_QFUNCTION(f_build_hdivmass_const_scalar)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a vector constant coefficient
+CEED_QFUNCTION(f_build_hdivmass_const_vector)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a matrix constant coefficient
+CEED_QFUNCTION(f_build_hdivmass_const_matrix)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a scalar constant coefficient
+CEED_QFUNCTION(f_build_hcurlmass_const_scalar)(void *ctx, CeedInt Q,
+                                               const CeedScalar *const *in,
+                                               CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            qd[i] = qw[i] * coeff0 / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a vector constant coefficient
+CEED_QFUNCTION(f_build_hcurlmass_const_vector)(void *ctx, CeedInt Q,
+                                               const CeedScalar *const *in,
+                                               CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a matrix constant coefficient
+CEED_QFUNCTION(f_build_hcurlmass_const_matrix)(void *ctx, CeedInt Q,
+                                               const CeedScalar *const *in,
+                                               CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[1] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *J = in[0], *qw = in[1];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hdivmass_quad_scalar)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] * J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hdivmass_quad_vector)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(div) mass operator
+/// with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hdivmass_quad_matrix)(void *ctx, CeedInt Q,
+                                             const CeedScalar *const *in,
+                                             CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ21(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ22(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ32(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultJtCJ33(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a scalar coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hcurlmass_quad_scalar)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            qd[i] = qw[i] * c[i] / J[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a vector coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hcurlmass_quad_vector)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for building quadrature data for an H(curl) mass operator
+/// with a matrix coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_build_hcurlmass_quad_matrix)(void *ctx, CeedInt Q,
+                                              const CeedScalar *const *in,
+                                              CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div)) and store the symmetric part
+   // of the result
+   const CeedScalar *c = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *qd = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], Q, qd + i);
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], Q, qd + i);
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying a vector FE mass operator
+CEED_QFUNCTION(f_apply_vecfemass)(void *ctx, CeedInt Q,
+                                  const CeedScalar *const *in,
+                                  CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   const CeedScalar *u = in[0], *qd = in[1];
+   CeedScalar *v = out[0];
+   switch (bc->dim)
+   {
+      case 1:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            v[i] = qd[i] * u[i];
+         }
+         break;
+      case 2:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[i + Q * 0] * u0 + qd[i + Q * 1] * u1;
+            v[i + Q * 1] = qd[i + Q * 1] * u0 + qd[i + Q * 2] * u1;
+         }
+         break;
+      case 3:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[i + Q * 0] * u0 + qd[i + Q * 1] * u1 + qd[i + Q * 2] * u2;
+            v[i + Q * 1] = qd[i + Q * 1] * u0 + qd[i + Q * 3] * u1 + qd[i + Q * 4] * u2;
+            v[i + Q * 2] = qd[i + Q * 2] * u0 + qd[i + Q * 4] * u1 + qd[i + Q * 5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) mass operator with a scalar
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hdivmass_mf_const_scalar)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 * J[i];
+            v[i] = qd * u[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, coeff, 1, 1, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) mass operator with a vector
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hdivmass_mf_const_vector)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, coeff, 1, 2, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, coeff, 1, 2, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) mass operator with a matrix
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hdivmass_mf_const_matrix)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, coeff, 1, 3, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) mass operator with a scalar
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hcurlmass_mf_const_scalar)(void *ctx, CeedInt Q,
+                                                  const CeedScalar *const *in,
+                                                  CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar coeff0 = coeff[0];
+            const CeedScalar qd = qw[i] * coeff0 / J[i];
+            v[i] = qd * u[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 1, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) mass operator with a vector
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hcurlmass_mf_const_vector)(void *ctx, CeedInt Q,
+                                                  const CeedScalar *const *in,
+                                                  CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 2, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 2, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) mass operator with a matrix
+/// constant coefficient
+CEED_QFUNCTION(f_apply_hcurlmass_mf_const_matrix)(void *ctx, CeedInt Q,
+                                                  const CeedScalar *const *in,
+                                                  CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[2] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *coeff = bc->coeff;
+   const CeedScalar *u = in[0], *J = in[1], *qw = in[2];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, coeff, 1, 3, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, coeff, 1, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, coeff, 1, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) operator with a scalar
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hdivmass_mf_quad_scalar)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] * J[i];
+            v[i] = qd * u[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, c + i, Q, 1, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) operator with a vector
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hdivmass_mf_quad_vector)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, c + i, Q, 2, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, c + i, Q, 2, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(div) operator with a matrix
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hdivmass_mf_quad_matrix)(void *ctx, CeedInt Q,
+                                                const CeedScalar *const *in,
+                                                CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultJtCJ21(J + i, Q, c + i, Q, 3, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ22(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultJtCJ32(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultJtCJ33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) operator with a scalar
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hcurlmass_mf_quad_scalar)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=1, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 11:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            const CeedScalar qd = qw[i] * c[i] / J[i];
+            v[i] = qd * u[i];
+         }
+         break;
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 1, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 1, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) operator with a vector
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hcurlmass_mf_quad_vector)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 2, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 2, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+/// libCEED QFunction for applying an H(curl) operator with a matrix
+/// coefficient evaluated at quadrature points
+CEED_QFUNCTION(f_apply_hcurlmass_mf_quad_matrix)(void *ctx, CeedInt Q,
+                                                 const CeedScalar *const *in,
+                                                 CeedScalar *const *out)
+{
+   VectorFEMassContext *bc = (VectorFEMassContext *)ctx;
+   // in[0], out[0] have shape [dim, ncomp=1, Q]
+   // in[1] is coefficients with shape [ncomp=space_dim*(space_dim+1)/2, Q]
+   // in[2] is Jacobians with shape [dim, ncomp=space_dim, Q]
+   // in[3] is quadrature weights, size (Q)
+   //
+   // At every quadrature point, compute qw/det(J) adj(J) C adj(J)^T (for
+   // H(curl)) or qw/det(J) J^T C J (for H(div))
+   const CeedScalar *u = in[0], *c = in[1], *J = in[2], *qw = in[3];
+   CeedScalar *v = out[0];
+   switch (10 * bc->space_dim + bc->dim)
+   {
+      case 21:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd;
+            MultAdjJCAdjJt21(J + i, Q, c + i, Q, 3, qw[i], 1, &qd);
+            v[i] = qd * u[i];
+         }
+         break;
+      case 22:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt22(J + i, Q, c + i, Q, 3, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 32:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[3];
+            MultAdjJCAdjJt32(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1;
+            v[i + Q * 1] = qd[1] * u0 + qd[2] * u1;
+         }
+         break;
+      case 33:
+         CeedPragmaSIMD for (CeedInt i = 0; i < Q; i++)
+         {
+            CeedScalar qd[6];
+            MultAdjJCAdjJt33(J + i, Q, c + i, Q, 6, qw[i], 1, qd);
+            const CeedScalar u0 = u[i + Q * 0];
+            const CeedScalar u1 = u[i + Q * 1];
+            const CeedScalar u2 = u[i + Q * 2];
+            v[i + Q * 0] = qd[0] * u0 + qd[1] * u1 + qd[2] * u2;
+            v[i + Q * 1] = qd[1] * u0 + qd[3] * u1 + qd[4] * u2;
+            v[i + Q * 2] = qd[2] * u0 + qd[4] * u1 + qd[5] * u2;
+         }
+         break;
+   }
+   return 0;
+}
+
+#endif // MFEM_LIBCEED_VECFEMASS_QF_H
diff --git a/fem/ceed/interface/basis.cpp b/fem/ceed/interface/basis.cpp
index 37858cb78..ee6225f40 100644
--- a/fem/ceed/interface/basis.cpp
+++ b/fem/ceed/interface/basis.cpp
@@ -9,7 +9,8 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../../gridfunc.hpp"
+#include "basis.hpp"
+
 #include "util.hpp"
 
 namespace mfem
@@ -44,78 +45,174 @@ static CeedElemTopology GetCeedTopology(Geometry::Type geom)
    }
 }
 
-static void InitNonTensorBasis(const mfem::FiniteElementSpace &fes,
-                               const mfem::FiniteElement &fe,
-                               const mfem::IntegrationRule &ir,
-                               Ceed ceed, CeedBasis *basis)
-{
-   const mfem::DofToQuad &maps = fe.GetDofToQuad(ir, mfem::DofToQuad::FULL);
-   mfem::Mesh *mesh = fes.GetMesh();
-   const int dim = mesh->Dimension();
-   const int ndofs = maps.ndof;
-   const int nqpts = maps.nqpt;
-   mfem::DenseMatrix qX(dim,nqpts);
-   mfem::Vector qW(nqpts);
-   for (int i = 0; i < nqpts; i++)
-   {
-      const mfem::IntegrationPoint &ip = ir.IntPoint(i);
-      qX(0,i) = ip.x;
-      if (dim>1) { qX(1,i) = ip.y; }
-      if (dim>2) { qX(2,i) = ip.z; }
-      qW(i) = ip.weight;
-   }
-   CeedBasisCreateH1(ceed, GetCeedTopology(fe.GetGeomType()),
-                     fes.GetVDim(), ndofs, nqpts,
-                     maps.Bt.GetData(), maps.Gt.GetData(),
-                     qX.GetData(), qW.GetData(), basis);
-}
-
 static void InitTensorBasis(const mfem::FiniteElementSpace &fes,
                             const mfem::FiniteElement &fe,
                             const mfem::IntegrationRule &ir,
-                            Ceed ceed, CeedBasis *basis)
+                            Ceed ceed,
+                            CeedBasis *basis)
 {
    const mfem::DofToQuad &maps = fe.GetDofToQuad(ir, mfem::DofToQuad::TENSOR);
-   mfem::Mesh *mesh = fes.GetMesh();
-   const int ndofs = maps.ndof;
-   const int nqpts = maps.nqpt;
-   mfem::Vector qX(nqpts), qW(nqpts);
-   // The x-coordinates of the first `nqpts` points of the integration rule are
+   const int dim = fe.GetDim();
+   const int ncomp = fes.GetVDim();
+   const int P = maps.ndof;
+   const int Q = maps.nqpt;
+   mfem::Vector qX(Q), qW(Q);
+   // The x-coordinates of the first `Q` points of the integration rule are
    // the points of the corresponding 1D rule. We also scale the weights
    // accordingly.
    double w_sum = 0.0;
-   for (int i = 0; i < nqpts; i++)
+   for (int i = 0; i < Q; i++)
    {
       const mfem::IntegrationPoint &ip = ir.IntPoint(i);
       qX(i) = ip.x;
       qW(i) = ip.weight;
       w_sum += ip.weight;
    }
-   qW *= 1.0/w_sum;
-   CeedBasisCreateTensorH1(ceed, mesh->Dimension(), fes.GetVDim(), ndofs,
-                           nqpts, maps.Bt.GetData(),
-                           maps.Gt.GetData(), qX.GetData(),
-                           qW.GetData(), basis);
+   qW *= 1.0 / w_sum;
+   CeedBasisCreateTensorH1(ceed, dim, ncomp, P, Q,
+                           maps.Bt.GetData(), maps.Gt.GetData(),
+                           qX.GetData(), qW.GetData(), basis);
 }
 
-static void InitBasisImpl(const FiniteElementSpace &fes,
-                          const FiniteElement &fe,
-                          const IntegrationRule &ir,
-                          Ceed ceed, CeedBasis *basis)
+static void InitNonTensorBasis(const mfem::FiniteElementSpace &fes,
+                               const mfem::FiniteElement &fe,
+                               const mfem::IntegrationRule &ir,
+                               Ceed ceed,
+                               CeedBasis *basis)
 {
-   // Check for FES -> basis, restriction in hash tables
+   const mfem::DofToQuad &maps = fe.GetDofToQuad(ir, mfem::DofToQuad::FULL);
+   const int dim = fe.GetDim();
+   const int ncomp = fes.GetVDim();
+   const int P = maps.ndof;
+   const int Q = maps.nqpt;
+   mfem::DenseMatrix qX(dim, Q);
+   mfem::Vector qW(Q);
+   for (int i = 0; i < Q; i++)
+   {
+      const mfem::IntegrationPoint &ip = ir.IntPoint(i);
+      qX(0, i) = ip.x;
+      if (dim > 1) { qX(1, i) = ip.y; }
+      if (dim > 2) { qX(2, i) = ip.z; }
+      qW(i) = ip.weight;
+   }
+   if (fe.GetMapType() == mfem::FiniteElement::H_DIV)
+   {
+      CeedBasisCreateHdiv(ceed, GetCeedTopology(fe.GetGeomType()), ncomp, P, Q,
+                          maps.Bt.GetData(), maps.Gt.GetData(),
+                          qX.GetData(), qW.GetData(), basis);
+   }
+   else if (fe.GetMapType() == mfem::FiniteElement::H_CURL)
+   {
+      CeedBasisCreateHcurl(ceed, GetCeedTopology(fe.GetGeomType()), ncomp, P, Q,
+                           maps.Bt.GetData(), maps.Gt.GetData(),
+                           qX.GetData(), qW.GetData(), basis);
+   }
+   else
+   {
+      CeedBasisCreateH1(ceed, GetCeedTopology(fe.GetGeomType()), ncomp, P, Q,
+                        maps.Bt.GetData(), maps.Gt.GetData(),
+                        qX.GetData(), qW.GetData(), basis);
+   }
+}
+
+#if 0
+static void InitCeedInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes,
+                                      const FiniteElement &trial_fe,
+                                      const FiniteElement &test_fe,
+                                      Ceed ceed,
+                                      CeedBasis *basis)
+{
+   // Basis projection operator using libCEED
+   CeedBasis trial_basis, test_basis;
+   const int P = std::max(trial_fe.GetDof(), test_fe.GetDof()), ir_order_max = 100;
+   int ir_order = std::max(trial_fe.GetOrder(), test_fe.GetOrder());
+   for (; ir_order < ir_order_max; ir_order++)
+   {
+      if (IntRules.Get(trial_fe.GetGeomType(), ir_order).GetNPoints() >= P) { break; }
+   }
+   const IntegrationRule &ir = IntRules.Get(trial_fe.GetGeomType(), ir_order);
+   InitBasis(trial_fes, trial_fe, ir, ceed, &trial_basis);
+   InitBasis(test_fes, test_fe, ir, ceed, &test_basis);
+   CeedBasisCreateProjection(trial_basis, test_basis, basis);
+}
+#endif
+
+static void InitMfemInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes,
+                                      const FiniteElement &trial_fe,
+                                      const FiniteElement &test_fe,
+                                      Ceed ceed,
+                                      CeedBasis *basis)
+{
+   MFEM_VERIFY(trial_fes.GetVDim() == test_fes.GetVDim(),
+               "libCEED discrete linear operator requires same vdim for trial "
+               "and test FE spaces.");
+   const int dim = trial_fe.GetDim();
+   const int ncomp = trial_fes.GetVDim();
+   const int trial_P = trial_fe.GetDof();
+   const int test_P = test_fe.GetDof();
+   mfem::DenseMatrix qX(dim, test_P), Gt(trial_P, test_P * dim), Bt;
+   mfem::Vector qW(test_P);
+   mfem::IsoparametricTransformation dummy;
+   dummy.SetIdentityTransformation(trial_fe.GetGeomType());
+   if (trial_fe.GetMapType() == test_fe.GetMapType())
+   {
+      // Prolongation
+      test_fe.GetTransferMatrix(trial_fe, dummy, Bt);
+   }
+   else if (trial_fe.GetMapType() == mfem::FiniteElement::VALUE &&
+            test_fe.GetMapType() == mfem::FiniteElement::H_CURL)
+   {
+      // Discrete gradient interpolator
+      test_fe.ProjectGrad(trial_fe, dummy, Bt);
+   }
+   else if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL &&
+            test_fe.GetMapType() == mfem::FiniteElement::H_DIV)
+   {
+      // Discrete curl interpolator
+      test_fe.ProjectCurl(trial_fe, dummy, Bt);
+   }
+   else if (trial_fe.GetMapType() == mfem::FiniteElement::H_DIV &&
+            test_fe.GetMapType() == mfem::FiniteElement::INTEGRAL)
+   {
+      // Discrete divergence interpolator
+      test_fe.ProjectDiv(trial_fe, dummy, Bt);
+   }
+   else
+   {
+      MFEM_ABORT("Unsupported trial/test FE spaces for libCEED discrete "
+                 "linear operator");
+   }
+   Bt.Transpose();
+   Gt = 0.0;
+   qX = 0.0;
+   qW = 0.0;
+   CeedBasisCreateH1(ceed, GetCeedTopology(trial_fe.GetGeomType()), ncomp,
+                     trial_P, test_P, Bt.GetData(), Gt.GetData(),
+                     qX.GetData(), qW.GetData(), basis);
+}
+
+void InitBasis(const FiniteElementSpace &fes,
+               const FiniteElement &fe,
+               const IntegrationRule &ir,
+               Ceed ceed,
+               CeedBasis *basis)
+{
+   // Check for fes -> basis in hash table
    const int P = fe.GetDof();
    const int Q = ir.GetNPoints();
    const int ncomp = fes.GetVDim();
-   BasisKey basis_key(&fes, &ir, ncomp, P, Q);
-   auto basis_itr = mfem::internal::ceed_basis_map.find(basis_key);
-   const bool tensor = dynamic_cast<const mfem::TensorBasisElement *>
-                       (&fe) != nullptr;
+   BasisKey basis_key(&fes, nullptr, &ir, {P, Q, ncomp});
 
    // Init or retrieve key values
-   if (basis_itr == mfem::internal::ceed_basis_map.end())
+   auto basis_itr = internal::ceed_basis_map.find(basis_key);
+   if (basis_itr == internal::ceed_basis_map.end())
    {
-      if ( tensor )
+      const bool tensor =
+         dynamic_cast<const mfem::TensorBasisElement *>(&fe) != nullptr;
+      const bool vector = fe.GetRangeType() == mfem::FiniteElement::VECTOR;
+      if (tensor && !vector)
       {
          InitTensorBasis(fes, fe, ir, ceed, basis);
       }
@@ -123,7 +220,7 @@ static void InitBasisImpl(const FiniteElementSpace &fes,
       {
          InitNonTensorBasis(fes, fe, ir, ceed, basis);
       }
-      mfem::internal::ceed_basis_map[basis_key] = *basis;
+      internal::ceed_basis_map[basis_key] = *basis;
    }
    else
    {
@@ -131,22 +228,41 @@ static void InitBasisImpl(const FiniteElementSpace &fes,
    }
 }
 
-void InitBasis(const FiniteElementSpace &fes,
-               const IntegrationRule &ir,
-               Ceed ceed, CeedBasis *basis)
+void InitInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes,
+                           const FiniteElement &trial_fe,
+                           const FiniteElement &test_fe,
+                           Ceed ceed,
+                           CeedBasis *basis)
 {
-   const mfem::FiniteElement &fe = *fes.GetFE(0);
-   InitBasisImpl(fes, fe, ir, ceed, basis);
-}
+   // Check for fes -> basis in hash table
+   const int P1 = trial_fe.GetDof();
+   const int P2 = test_fe.GetDof();
+   const int ncomp = trial_fes.GetVDim();  // Assumed same as test_fes
+   BasisKey basis_key(&trial_fes, &test_fes, nullptr, {P1, P2, ncomp});
 
-void InitBasisWithIndices(const FiniteElementSpace &fes,
-                          const IntegrationRule &ir,
-                          int nelem,
-                          const int* indices,
-                          Ceed ceed, CeedBasis *basis)
-{
-   const mfem::FiniteElement &fe = *fes.GetFE(indices[0]);
-   InitBasisImpl(fes, fe, ir, ceed, basis);
+   // Init or retrieve key values
+   auto basis_itr = internal::ceed_basis_map.find(basis_key);
+   if (basis_itr == internal::ceed_basis_map.end())
+   {
+#if 0
+      if (trial_fe.GetMapType() == test_fe.GetMapType())
+      {
+         InitCeedInterpolatorBasis(trial_fes, test_fes, trial_fe, test_fe,
+                                   ceed, basis);
+      }
+      else
+#endif
+      {
+         InitMfemInterpolatorBasis(trial_fes, test_fes, trial_fe, test_fe,
+                                   ceed, basis);
+      }
+      internal::ceed_basis_map[basis_key] = *basis;
+   }
+   else
+   {
+      *basis = basis_itr->second;
+   }
 }
 
 #endif
diff --git a/fem/ceed/interface/basis.hpp b/fem/ceed/interface/basis.hpp
index 3781f4cf7..f0591e662 100644
--- a/fem/ceed/interface/basis.hpp
+++ b/fem/ceed/interface/basis.hpp
@@ -12,6 +12,7 @@
 #ifndef MFEM_LIBCEED_BASIS
 #define MFEM_LIBCEED_BASIS
 
+#include "../../fespace.hpp"
 #include "ceed.hpp"
 
 namespace mfem
@@ -22,31 +23,111 @@ namespace ceed
 
 #ifdef MFEM_USE_CEED
 
-/** @brief Initialize a CeedBasis for non-mixed meshes.
+/** @brief Initialize a CeedBasis based on an mfem::FiniteElementSpace @a fes,
+    an mfem::FiniteElement @a fe, and an mfem::IntegrationRule @a ir.
 
-   @param[in] fes Input finite element space.
-   @param[in] ir Input integration rule.
-   @param[in] ceed Input Ceed object.
-   @param[out] basis The address of the initialized CeedBasis object.
-*/
+    @param[in] fes The finite element space.
+    @param[in] fe The finite element.
+    @param[in] ir The integration rule.
+    @param[in] ceed The Ceed object.
+    @param[out] basis The `CeedBasis` to initialize. */
 void InitBasis(const FiniteElementSpace &fes,
+               const FiniteElement &fe,
                const IntegrationRule &ir,
-               Ceed ceed, CeedBasis *basis);
+               Ceed ceed,
+               CeedBasis *basis);
 
-/** @brief Initialize a CeedBasis for mixed meshes.
+/** @brief Initialize a CeedBasis based on an mfem::FiniteElementSpace @a fes,
+    an mfem::IntegrationRule @a ir, and an optional list of element indices
+    @a indices.
 
     @param[in] fes The finite element space.
-    @param[in] ir is the integration rule for the operator.
-    @param[in] nelem The number of elements.
+    @param[in] ir The integration rule.
+    @param[in] use_bdr Create the basis for boundary elements.
+    @param[in] indices The indices of the elements of same type in the
+                       `FiniteElementSpace`. If `indices == nullptr`, assumes
+                       that the `FiniteElementSpace` is not mixed.
+    @param[in] ceed The Ceed object.
+    @param[out] basis The `CeedBasis` to initialize. */
+inline void InitBasis(const FiniteElementSpace &fes,
+                      const IntegrationRule &ir,
+                      bool use_bdr,
+                      const int *indices,
+                      Ceed ceed,
+                      CeedBasis *basis)
+{
+   const int first_index = indices ? indices[0] : 0;
+   const mfem::FiniteElement &fe =
+      use_bdr ? *fes.GetBE(first_index) : *fes.GetFE(first_index);
+   InitBasis(fes, fe, ir, ceed, basis);
+}
+
+inline void InitBasis(const FiniteElementSpace &fes,
+                      const IntegrationRule &ir,
+                      bool use_bdr,
+                      Ceed ceed,
+                      CeedBasis *basis)
+{
+   InitBasis(fes, ir, use_bdr, nullptr, ceed, basis);
+}
+
+/** @brief Initialize a CeedBasis based on an interpolation from
+    mfem::FiniteElementSpace @a trial_fes to @a test_fes. The type of
+    interpolation will be chosen based on the map type of the provided
+    mfem::FiniteElement objects.
+
+    @param[in] trial_fes The trial finite element space.
+    @param[in] test_fes The test finite element space.
+    @param[in] trial_fe The trial finite element.
+    @param[in] test_fe The test finite element.
+    @param[in] ceed The Ceed object.
+    @param[out] basis The `CeedBasis` to initialize. */
+void InitInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes,
+                           const FiniteElement &trial_fe,
+                           const FiniteElement &test_fe,
+                           Ceed ceed,
+                           CeedBasis *basis);
+
+/** @brief Initialize a CeedBasis based on an interpolation from
+    mfem::FiniteElementSpace @a trial_fes to @a test_fes, with an optional list
+    of element indices @a indices. The type of interpolation will be chosen
+    based on the map type of the provided spaces.
+
+    @param[in] trial_fes The trial finite element space.
+    @param[in] test_fes The test finite element space.
     @param[in] indices The indices of the elements of same type in the
-                       `FiniteElementSpace`.
+                       `FiniteElementSpace`. If `indices == nullptr`, assumes
+                       that the `FiniteElementSpace` is not mixed.
     @param[in] ceed The Ceed object.
     @param[out] basis The `CeedBasis` to initialize. */
-void InitBasisWithIndices(const FiniteElementSpace &fes,
-                          const IntegrationRule &ir,
-                          int nelem,
-                          const int* indices,
-                          Ceed ceed, CeedBasis *basis);
+inline void InitInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                                  const FiniteElementSpace &test_fes,
+                                  const int *indices,
+                                  Ceed ceed,
+                                  CeedBasis *basis)
+{
+   const mfem::FiniteElement *trial_fe, *test_fe;
+   if (indices)
+   {
+      trial_fe = trial_fes.GetFE(indices[0]);
+      test_fe = test_fes.GetFE(indices[0]);
+   }
+   else
+   {
+      trial_fe = trial_fes.GetFE(0);
+      test_fe = test_fes.GetFE(0);
+   }
+   InitInterpolatorBasis(trial_fes, test_fes, *trial_fe, *test_fe, ceed, basis);
+}
+
+inline void InitInterpolatorBasis(const FiniteElementSpace &trial_fes,
+                                  const FiniteElementSpace &test_fes,
+                                  Ceed ceed,
+                                  CeedBasis *basis)
+{
+   InitInterpolatorBasis(trial_fes, test_fes, nullptr, ceed, basis);
+}
 
 #endif
 
diff --git a/fem/ceed/interface/ceed.hpp b/fem/ceed/interface/ceed.hpp
index 1e06d9ab5..c519c6664 100644
--- a/fem/ceed/interface/ceed.hpp
+++ b/fem/ceed/interface/ceed.hpp
@@ -12,6 +12,7 @@
 #ifndef MFEM_LIBCEED_CEED
 #define MFEM_LIBCEED_CEED
 
+#include "../../../config/config.hpp"
 #ifdef MFEM_USE_CEED
 #include <ceed.h>
 #if !CEED_VERSION_GE(0,10,0)
@@ -24,7 +25,11 @@ namespace mfem
 namespace internal
 {
 
+// Definition in general/device.cpp.
 extern Ceed ceed;
+#ifdef MFEM_USE_OPENMP
+#pragma omp threadprivate(ceed)
+#endif
 
 } // namespace internal
 
diff --git a/fem/ceed/interface/coefficient.hpp b/fem/ceed/interface/coefficient.hpp
index abb70e8b8..1862730be 100644
--- a/fem/ceed/interface/coefficient.hpp
+++ b/fem/ceed/interface/coefficient.hpp
@@ -15,7 +15,6 @@
 #ifdef MFEM_USE_CEED
 
 #include "../../../general/forall.hpp"
-#include "../../../config/config.hpp"
 #include "../../../linalg/vector.hpp"
 #include "../../../linalg/dtensor.hpp"
 #include "../../../mesh/mesh.hpp"
@@ -27,54 +26,41 @@
 namespace mfem
 {
 
-class Mesh;
-class IntegrationRule;
-class Coefficient;
-class VectorCoefficient;
-class GridFunction;
-
 namespace ceed
 {
 
 struct Coefficient
 {
    const int ncomp;
-   Coefficient(int ncomp_) : ncomp(ncomp_) { }
-   virtual bool IsConstant() const { return true; }
-   virtual ~Coefficient() { }
-};
-
-struct VariableCoefficient : Coefficient
-{
-   CeedVector coeffVector = nullptr;
    const CeedEvalMode emode;
-   VariableCoefficient(int ncomp_, CeedEvalMode emode_)
-      : Coefficient(ncomp_), emode(emode_) { }
-   virtual bool IsConstant() const override { return false; }
-   ~VariableCoefficient()
+   CeedVector coeff_vector;
+   Coefficient(int ncomp, CeedEvalMode emode)
+      : ncomp(ncomp), emode(emode), coeff_vector(nullptr) {}
+   virtual ~Coefficient()
    {
-      CeedVectorDestroy(&coeffVector);
+      CeedVectorDestroy(&coeff_vector);
    }
 };
 
-struct GridCoefficient : VariableCoefficient
+struct GridCoefficient : Coefficient
 {
    const mfem::GridFunction &gf;
    CeedBasis basis;
    CeedElemRestriction restr;
-   GridCoefficient(const mfem::GridFunction &gf_)
-      : VariableCoefficient(gf_.VectorDim(), CEED_EVAL_INTERP),
-        gf(gf_)
+   GridCoefficient(const mfem::GridFunction &gf, Ceed ceed)
+      : Coefficient(gf.VectorDim(), CEED_EVAL_INTERP), gf(gf),
+        basis(nullptr), restr(nullptr)
    {
-      InitVector(gf, coeffVector);
+      InitVector(gf, ceed, coeff_vector);
    }
 };
 
-struct QuadCoefficient : VariableCoefficient
+struct QuadCoefficient : Coefficient
 {
-   mfem::Vector coeff;
+   mfem::Vector vector;
    CeedElemRestriction restr;
-   QuadCoefficient(int ncomp_) : VariableCoefficient(ncomp_, CEED_EVAL_NONE) { }
+   QuadCoefficient(int ncomp)
+      : Coefficient(ncomp, CEED_EVAL_NONE), restr(nullptr) {}
 };
 
 /** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
@@ -84,73 +70,70 @@ struct QuadCoefficient : VariableCoefficient
     @param[in] Q is the coefficient from the `Integrator`.
     @param[in] mesh is the mesh.
     @param[in] ir is the integration rule.
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] ceed The Ceed object.
     @param[out] coeff_ptr is the structure to store the coefficient for the
-                          `CeedOperator`.
-    @param[out] ctx is the Context associated to the QFunction. */
-template <typename Context>
-void InitCoefficient(mfem::Coefficient *Q, mfem::Mesh &mesh,
-                     const mfem::IntegrationRule &ir,
-                     Coefficient*& coeff_ptr, Context &ctx)
+                          `CeedOperator`. */
+inline void InitCoefficient(mfem::Coefficient &Q,
+                            mfem::Mesh &mesh,
+                            const mfem::IntegrationRule &ir,
+                            bool use_bdr,
+                            Ceed ceed,
+                            Coefficient *&coeff_ptr)
 {
-   if ( Q == nullptr )
-   {
-      Coefficient *ceedCoeff = new Coefficient(1);
-      ctx.coeff = 1.0;
-      coeff_ptr = ceedCoeff;
-   }
-   else if (ConstantCoefficient *const_coeff =
-               dynamic_cast<ConstantCoefficient*>(Q))
+   if (mfem::GridFunctionCoefficient *gf_coeff =
+          dynamic_cast<mfem::GridFunctionCoefficient *>(&Q))
    {
-      Coefficient *ceedCoeff = new Coefficient(1);
-      ctx.coeff = const_coeff->constant;
-      coeff_ptr = ceedCoeff;
+      auto *ceed_coeff = new GridCoefficient(*gf_coeff->GetGridFunction(), ceed);
+      coeff_ptr = ceed_coeff;
    }
-   else if (GridFunctionCoefficient* gf_coeff =
-               dynamic_cast<GridFunctionCoefficient*>(Q))
+   else if (mfem::QuadratureFunctionCoefficient *qf_coeff =
+               dynamic_cast<mfem::QuadratureFunctionCoefficient *>(&Q))
    {
-      GridCoefficient *ceedCoeff =
-         new GridCoefficient(*gf_coeff->GetGridFunction());
-      coeff_ptr = ceedCoeff;
-   }
-   else if (QuadratureFunctionCoefficient *cQ =
-               dynamic_cast<QuadratureFunctionCoefficient*>(Q))
-   {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(1);
-      const int ne = mesh.GetNE();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      const mfem::QuadratureFunction &qFun = cQ->GetQuadFunction();
-      MFEM_VERIFY(qFun.Size() == nq * ne,
-                  "Incompatible QuadratureFunction dimension \n");
-
-      MFEM_VERIFY(&ir == &qFun.GetSpace()->GetIntRule(0),
+      auto *ceed_coeff = new QuadCoefficient(1);
+      const mfem::QuadratureFunction &qfunc = qf_coeff->GetQuadFunction();
+      MFEM_VERIFY(qfunc.Size() == nq * ne,
+                  "Incompatible QuadratureFunction dimension.");
+      MFEM_VERIFY(&ir == &qfunc.GetSpace()->GetIntRule(0),
                   "IntegrationRule used within integrator and in"
-                  " QuadratureFunction appear to be different");
-      qFun.Read();
-      ceedCoeff->coeff.MakeRef(const_cast<mfem::QuadratureFunction &>(qFun),0);
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+                  " QuadratureFunction appear to be different.");
+      qfunc.Read();
+      ceed_coeff->vector.MakeRef(const_cast<mfem::QuadratureFunction &>(qfunc), 0);
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
    else
    {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(1);
-      const int ne = mesh.GetNE();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      ceedCoeff->coeff.SetSize(nq * ne);
-      auto C = Reshape(ceedCoeff->coeff.HostWrite(), nq, ne);
+      auto *ceed_coeff = new QuadCoefficient(1);
+      ceed_coeff->vector.SetSize(nq * ne);
+      auto C = Reshape(ceed_coeff->vector.HostWrite(), nq, ne);
+      mfem::IsoparametricTransformation T;
       for (int e = 0; e < ne; ++e)
       {
-         mfem::ElementTransformation &T = *mesh.GetElementTransformation(e);
+         if (use_bdr)
+         {
+            mesh.GetBdrElementTransformation(e, &T);
+         }
+         else
+         {
+            mesh.GetElementTransformation(e, &T);
+         }
          for (int q = 0; q < nq; ++q)
          {
-            C(q,e) = Q->Eval(T, ir.IntPoint(q));
+            const IntegrationPoint &ip = ir.IntPoint(q);
+            T.SetIntPoint(&ip);
+            C(q, e) = Q.Eval(T, ip);
          }
       }
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
 }
 
-
 /** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
     mfem::VectorCoefficient @a VQ, an mfem::Mesh @a mesh, and an
     mfem::IntegrationRule @a ir.
@@ -158,76 +141,130 @@ void InitCoefficient(mfem::Coefficient *Q, mfem::Mesh &mesh,
     @param[in] VQ is the vector coefficient from the `Integrator`.
     @param[in] mesh is the mesh.
     @param[in] ir is the integration rule.
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] ceed The Ceed object.
     @param[out] coeff_ptr is the structure to store the coefficient for the
-                          `CeedOperator`.
-    @param[out] ctx is the Context associated to the QFunction. */
-template <typename Context>
-void InitCoefficient(mfem::VectorCoefficient *VQ, mfem::Mesh &mesh,
-                     const mfem::IntegrationRule &ir,
-                     Coefficient *&coeff_ptr, Context &ctx)
+                          `CeedOperator`. */
+inline void InitCoefficient(mfem::VectorCoefficient &VQ,
+                            mfem::Mesh &mesh,
+                            const mfem::IntegrationRule &ir,
+                            bool use_bdr,
+                            Ceed ceed,
+                            Coefficient *&coeff_ptr)
 {
-   if (VectorConstantCoefficient *const_coeff =
-          dynamic_cast<VectorConstantCoefficient*>(VQ))
+   if (mfem::VectorGridFunctionCoefficient *vgf_coeff =
+          dynamic_cast<mfem::VectorGridFunctionCoefficient *>(&VQ))
    {
-      const int vdim = const_coeff->GetVDim();
-      const mfem::Vector &val = const_coeff->GetVec();
-      Coefficient *ceedCoeff = new Coefficient(vdim);
-      for (int i = 0; i < vdim; i++)
-      {
-         ctx.coeff[i] = val[i];
-      }
-      coeff_ptr = ceedCoeff;
+      auto *ceed_coeff = new GridCoefficient(*vgf_coeff->GetGridFunction(), ceed);
+      coeff_ptr = ceed_coeff;
    }
-   else if (VectorGridFunctionCoefficient* vgf_coeff =
-               dynamic_cast<VectorGridFunctionCoefficient*>(VQ))
+   else if (mfem::VectorQuadratureFunctionCoefficient *vqf_coeff =
+               dynamic_cast<mfem::VectorQuadratureFunctionCoefficient *>(&VQ))
    {
-      GridCoefficient *ceedCoeff =
-         new GridCoefficient(*vgf_coeff->GetGridFunction());
-      coeff_ptr = ceedCoeff;
-   }
-   else if (VectorQuadratureFunctionCoefficient *cQ =
-               dynamic_cast<VectorQuadratureFunctionCoefficient*>(VQ))
-   {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(cQ->GetVDim());
-      const int dim = mesh.Dimension();
-      const int ne = mesh.GetNE();
+      const int vdim = vqf_coeff->GetVDim();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      const mfem::QuadratureFunction &qFun = cQ->GetQuadFunction();
-      MFEM_VERIFY(qFun.Size() == dim * nq * ne,
-                  "Incompatible QuadratureFunction dimension \n");
-
-      MFEM_VERIFY(&ir == &qFun.GetSpace()->GetIntRule(0),
+      auto *ceed_coeff = new QuadCoefficient(vdim);
+      const mfem::QuadratureFunction &qfunc = vqf_coeff->GetQuadFunction();
+      MFEM_VERIFY(qfunc.Size() == vdim * nq * ne,
+                  "Incompatible QuadratureFunction dimension.");
+      MFEM_VERIFY(&ir == &qfunc.GetSpace()->GetIntRule(0),
                   "IntegrationRule used within integrator and in"
-                  " QuadratureFunction appear to be different");
-      qFun.Read();
-      ceedCoeff->coeff.MakeRef(const_cast<mfem::QuadratureFunction &>(qFun),0);
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+                  " QuadratureFunction appear to be different.");
+      qfunc.Read();
+      ceed_coeff->vector.MakeRef(const_cast<mfem::QuadratureFunction &>(qfunc), 0);
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
    else
    {
-      const int dim = mesh.Dimension();
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(dim);
-      const int ne = mesh.GetNE();
+      const int vdim = VQ.GetVDim();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      ceedCoeff->coeff.SetSize(dim * nq * ne);
-      auto C = Reshape(ceedCoeff->coeff.HostWrite(), dim, nq, ne);
-      mfem::DenseMatrix Q_ir;
+      auto *ceed_coeff = new QuadCoefficient(vdim);
+      ceed_coeff->vector.SetSize(vdim * nq * ne);
+      auto C = Reshape(ceed_coeff->vector.HostWrite(), vdim, nq, ne);
+      mfem::IsoparametricTransformation T;
+      mfem::DenseMatrix Q_ip;
       for (int e = 0; e < ne; ++e)
       {
-         mfem::ElementTransformation &T = *mesh.GetElementTransformation(e);
-         VQ->Eval(Q_ir, T, ir);
+         if (use_bdr)
+         {
+            mesh.GetBdrElementTransformation(e, &T);
+         }
+         else
+         {
+            mesh.GetElementTransformation(e, &T);
+         }
+         VQ.Eval(Q_ip, T, ir);
          for (int q = 0; q < nq; ++q)
          {
-            for (int i = 0; i < dim; ++i)
+            for (int i = 0; i < vdim; ++i)
+            {
+               C(i, q, e) = Q_ip(i, q);
+            }
+         }
+      }
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
+   }
+}
+
+/** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
+    mfem::MatrixCoefficient @a MQ, an mfem::Mesh @a mesh, and an
+    mfem::IntegrationRule @a ir.
+
+    @param[in] MQ is the matrix coefficient from the `Integrator`.
+    @param[in] mesh is the mesh.
+    @param[in] ir is the integration rule.
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] ceed The Ceed object.
+    @param[out] coeff_ptr is the structure to store the coefficient for the
+                          `CeedOperator`. */
+inline void InitCoefficient(mfem::MatrixCoefficient &MQ,
+                            mfem::Mesh &mesh,
+                            const mfem::IntegrationRule &ir,
+                            bool use_bdr,
+                            Ceed ceed,
+                            Coefficient *&coeff_ptr)
+{
+   // Assumes matrix coefficient is symmetric
+   const int vdim = MQ.GetVDim();
+   const int ncomp = (vdim * (vdim + 1)) / 2;
+   const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
+   const int nq = ir.GetNPoints();
+   auto *ceed_coeff = new QuadCoefficient(ncomp);
+   ceed_coeff->vector.SetSize(ncomp * nq * ne);
+   auto C = Reshape(ceed_coeff->vector.HostWrite(), ncomp, nq, ne);
+   mfem::IsoparametricTransformation T;
+   mfem::DenseMatrix Q_ip;
+   for (int e = 0; e < ne; ++e)
+   {
+      if (use_bdr)
+      {
+         mesh.GetBdrElementTransformation(e, &T);
+      }
+      else
+      {
+         mesh.GetElementTransformation(e, &T);
+      }
+      for (int q = 0; q < nq; ++q)
+      {
+         const IntegrationPoint &ip = ir.IntPoint(q);
+         T.SetIntPoint(&ip);
+         MQ.Eval(Q_ip, T, ip);
+         for (int j = 0; j < vdim; ++j)
+         {
+            for (int i = j; i < vdim; ++i)
             {
-               C(i,q,e) = Q_ir(i,q);
+               const int idx = (j * vdim) - (((j - 1) * j) / 2) + i - j;
+               C(idx, q, e) = Q_ip(i, j);  // Column-major
             }
          }
       }
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
    }
+   InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+   coeff_ptr = ceed_coeff;
 }
 
 /** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
@@ -237,57 +274,45 @@ void InitCoefficient(mfem::VectorCoefficient *VQ, mfem::Mesh &mesh,
     @param[in] Q is the coefficient from the `Integrator`.
     @param[in] mesh is the mesh.
     @param[in] ir is the integration rule.
-    @param[in] nelem The number of elements.
-    @param[in] indices The indices of the elements of same type in the
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] nelem is the number of elements.
+    @param[in] indices are the indices of the elements of same type in the
                        `FiniteElementSpace`.
+    @param[in] ceed The Ceed object.
     @param[out] coeff_ptr is the structure to store the coefficient for the
-                          `CeedOperator`.
-    @param[out] ctx is the Context associated to the QFunction. */
-template <typename Context>
-void InitCoefficientWithIndices(mfem::Coefficient *Q, mfem::Mesh &mesh,
-                                const mfem::IntegrationRule &ir,
-                                int nelem,
-                                const int* indices,
-                                Coefficient*& coeff_ptr, Context &ctx)
+                          `CeedOperator`. */
+inline void InitCoefficientWithIndices(mfem::Coefficient &Q,
+                                       mfem::Mesh &mesh,
+                                       const mfem::IntegrationRule &ir,
+                                       bool use_bdr,
+                                       int nelem,
+                                       const int *indices,
+                                       Ceed ceed,
+                                       Coefficient *&coeff_ptr)
 {
-   if ( Q == nullptr )
-   {
-      Coefficient *ceedCoeff = new Coefficient(1);
-      ctx.coeff = 1.0;
-      coeff_ptr = ceedCoeff;
-   }
-   else if (ConstantCoefficient *const_coeff =
-               dynamic_cast<ConstantCoefficient*>(Q))
+   if (mfem::GridFunctionCoefficient *gf_coeff =
+          dynamic_cast<mfem::GridFunctionCoefficient *>(&Q))
    {
-      Coefficient *ceedCoeff = new Coefficient(1);
-      ctx.coeff = const_coeff->constant;
-      coeff_ptr = ceedCoeff;
+      auto *ceed_coeff = new GridCoefficient(*gf_coeff->GetGridFunction(), ceed);
+      coeff_ptr = ceed_coeff;
    }
-   else if (GridFunctionCoefficient* gf_coeff =
-               dynamic_cast<GridFunctionCoefficient*>(Q))
+   else if (mfem::QuadratureFunctionCoefficient *qf_coeff =
+               dynamic_cast<mfem::QuadratureFunctionCoefficient *>(&Q))
    {
-      GridCoefficient *ceedCoeff =
-         new GridCoefficient(*gf_coeff->GetGridFunction());
-      coeff_ptr = ceedCoeff;
-   }
-   else if (QuadratureFunctionCoefficient *cQ =
-               dynamic_cast<QuadratureFunctionCoefficient*>(Q))
-   {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(1);
-      const int ne = mesh.GetNE();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      const mfem::QuadratureFunction &qFun = cQ->GetQuadFunction();
-      MFEM_VERIFY(qFun.Size() == nq * ne,
-                  "Incompatible QuadratureFunction dimension \n");
-
-      MFEM_VERIFY(&ir == &qFun.GetSpace()->GetIntRule(0),
+      auto *ceed_coeff = new QuadCoefficient(1);
+      ceed_coeff->vector.SetSize(nq * nelem);
+      const mfem::QuadratureFunction &qfunc = qf_coeff->GetQuadFunction();
+      MFEM_VERIFY(qfunc.Size() == nq * ne,
+                  "Incompatible QuadratureFunction dimension.");
+      MFEM_VERIFY(&ir == &qfunc.GetSpace()->GetIntRule(0),
                   "IntegrationRule used within integrator and in"
-                  " QuadratureFunction appear to be different");
-      ceedCoeff->coeff.SetSize(nq * nelem);
+                  " QuadratureFunction appear to be different.");
       Memory<int> m_indices((int*)indices, nelem, false);
-      auto in = Reshape(qFun.Read(), nq, ne);
+      auto in = Reshape(qfunc.Read(), nq, ne);
       auto d_indices = Read(m_indices, nelem);
-      auto out = Reshape(ceedCoeff->coeff.Write(), nq, nelem);
+      auto out = Reshape(ceed_coeff->vector.Write(), nq, nelem);
       mfem::forall(nelem * nq, [=] MFEM_HOST_DEVICE (int i)
       {
          const int q = i%nq;
@@ -296,140 +321,214 @@ void InitCoefficientWithIndices(mfem::Coefficient *Q, mfem::Mesh &mesh,
          out(q, sub_e) = in(q, e);
       });
       m_indices.DeleteDevice();
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
    else
    {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(1);
       const int nq = ir.GetNPoints();
-      ceedCoeff->coeff.SetSize(nq * nelem);
-      auto C = Reshape(ceedCoeff->coeff.HostWrite(), nq, nelem);
+      auto *ceed_coeff = new QuadCoefficient(1);
+      ceed_coeff->vector.SetSize(nq * nelem);
+      auto C = Reshape(ceed_coeff->vector.HostWrite(), nq, nelem);
+      mfem::IsoparametricTransformation T;
       for (int i = 0; i < nelem; ++i)
       {
          const int e = indices[i];
-         mfem::ElementTransformation &T = *mesh.GetElementTransformation(e);
+         if (use_bdr)
+         {
+            mesh.GetBdrElementTransformation(e, &T);
+         }
+         else
+         {
+            mesh.GetElementTransformation(e, &T);
+         }
          for (int q = 0; q < nq; ++q)
          {
-            C(q, i) = Q->Eval(T, ir.IntPoint(q));
+            const IntegrationPoint &ip = ir.IntPoint(q);
+            T.SetIntPoint(&ip);
+            C(q, i) = Q.Eval(T, ip);
          }
       }
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
 }
 
-
 /** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
-    mfem::VectorCoefficient @a Q, an mfem::Mesh @a mesh, and an
+    mfem::VectorCoefficient @a VQ, an mfem::Mesh @a mesh, and an
     mfem::IntegrationRule @a ir for the elements given by the indices @a indices.
 
     @param[in] VQ is the vector coefficient from the `Integrator`.
     @param[in] mesh is the mesh.
     @param[in] ir is the integration rule.
-    @param[in] nelem The number of elements.
-    @param[in] indices The indices of the elements of same type in the
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] nelem is the number of elements.
+    @param[in] indices are the indices of the elements of same type in the
                        `FiniteElementSpace`.
+    @param[in] ceed The Ceed object.
     @param[out] coeff_ptr is the structure to store the coefficient for the
-                          `CeedOperator`.
-    @param[out] ctx is the Context associated to the QFunction. */
-template <typename Context>
-void InitCoefficientWithIndices(mfem::VectorCoefficient *VQ, mfem::Mesh &mesh,
-                                const mfem::IntegrationRule &ir,
-                                int nelem,
-                                const int* indices,
-                                Coefficient *&coeff_ptr, Context &ctx)
+                          `CeedOperator`. */
+inline void InitCoefficientWithIndices(mfem::VectorCoefficient &VQ,
+                                       mfem::Mesh &mesh,
+                                       const mfem::IntegrationRule &ir,
+                                       bool use_bdr,
+                                       int nelem,
+                                       const int *indices,
+                                       Ceed ceed,
+                                       Coefficient *&coeff_ptr)
 {
-   if (VectorConstantCoefficient *const_coeff =
-          dynamic_cast<VectorConstantCoefficient*>(VQ))
-   {
-      const int vdim = const_coeff->GetVDim();
-      const mfem::Vector &val = const_coeff->GetVec();
-      Coefficient *ceedCoeff = new Coefficient(vdim);
-      for (int i = 0; i < vdim; i++)
-      {
-         ctx.coeff[i] = val[i];
-      }
-      coeff_ptr = ceedCoeff;
-   }
-   else if (VectorGridFunctionCoefficient* vgf_coeff =
-               dynamic_cast<VectorGridFunctionCoefficient*>(VQ))
+   if (mfem::VectorGridFunctionCoefficient *vgf_coeff =
+          dynamic_cast<mfem::VectorGridFunctionCoefficient *>(&VQ))
    {
-      GridCoefficient *ceedCoeff =
-         new GridCoefficient(*vgf_coeff->GetGridFunction());
-      coeff_ptr = ceedCoeff;
+      auto *ceed_coeff = new GridCoefficient(*vgf_coeff->GetGridFunction(), ceed);
+      coeff_ptr = ceed_coeff;
    }
-   else if (VectorQuadratureFunctionCoefficient *cQ =
-               dynamic_cast<VectorQuadratureFunctionCoefficient*>(VQ))
+   else if (mfem::VectorQuadratureFunctionCoefficient *vqf_coeff =
+               dynamic_cast<mfem::VectorQuadratureFunctionCoefficient *>(&VQ))
    {
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(cQ->GetVDim());
-      const int dim = mesh.Dimension();
-      const int ne = mesh.GetNE();
+      const int vdim = vqf_coeff->GetVDim();
+      const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
       const int nq = ir.GetNPoints();
-      const mfem::QuadratureFunction &qFun = cQ->GetQuadFunction();
-      MFEM_VERIFY(qFun.Size() == dim * nq * ne,
-                  "Incompatible QuadratureFunction dimension \n");
-
-      MFEM_VERIFY(&ir == &qFun.GetSpace()->GetIntRule(0),
+      auto *ceed_coeff = new QuadCoefficient(vdim);
+      ceed_coeff->vector.SetSize(vdim * nq * nelem);
+      const mfem::QuadratureFunction &qfunc = vqf_coeff->GetQuadFunction();
+      MFEM_VERIFY(qfunc.Size() == vdim * nq * ne,
+                  "Incompatible QuadratureFunction dimension.");
+      MFEM_VERIFY(&ir == &qfunc.GetSpace()->GetIntRule(0),
                   "IntegrationRule used within integrator and in"
-                  " QuadratureFunction appear to be different");
-      ceedCoeff->coeff.SetSize(dim * nq * nelem);
+                  " QuadratureFunction appear to be different.");
       Memory<int> m_indices((int*)indices, nelem, false);
-      auto in = Reshape(qFun.Read(), dim, nq, ne);
+      auto in = Reshape(qfunc.Read(), vdim, nq, ne);
       auto d_indices = Read(m_indices, nelem);
-      auto out = Reshape(ceedCoeff->coeff.Write(), dim, nq, nelem);
+      auto out = Reshape(ceed_coeff->vector.Write(), vdim, nq, nelem);
       mfem::forall(nelem * nq, [=] MFEM_HOST_DEVICE (int i)
       {
          const int q = i%nq;
          const int sub_e = i/nq;
          const int e = d_indices[sub_e];
-         for (int d = 0; d < dim; d++)
+         for (int d = 0; d < vdim; d++)
          {
             out(d, q, sub_e) = in(d, q, e);
          }
       });
       m_indices.DeleteDevice();
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
    }
    else
    {
-      const int dim = mesh.Dimension();
-      QuadCoefficient *ceedCoeff = new QuadCoefficient(dim);
+      const int vdim = VQ.GetVDim();
       const int nq = ir.GetNPoints();
-      ceedCoeff->coeff.SetSize(dim * nq * nelem);
-      auto C = Reshape(ceedCoeff->coeff.HostWrite(), dim, nq, nelem);
-      mfem::DenseMatrix Q_ir;
+      auto *ceed_coeff = new QuadCoefficient(vdim);
+      ceed_coeff->vector.SetSize(vdim * nq * nelem);
+      auto C = Reshape(ceed_coeff->vector.HostWrite(), vdim, nq, nelem);
+      mfem::IsoparametricTransformation T;
+      mfem::DenseMatrix Q_ip;
       for (int i = 0; i < nelem; ++i)
       {
          const int e = indices[i];
-         mfem::ElementTransformation &T = *mesh.GetElementTransformation(e);
-         VQ->Eval(Q_ir, T, ir);
+         if (use_bdr)
+         {
+            mesh.GetBdrElementTransformation(e, &T);
+         }
+         else
+         {
+            mesh.GetElementTransformation(e, &T);
+         }
+         VQ.Eval(Q_ip, T, ir);
          for (int q = 0; q < nq; ++q)
          {
-            for (int d = 0; d < dim; ++d)
+            for (int d = 0; d < vdim; ++d)
+            {
+               C(d, q, i) = Q_ip(d, q);
+            }
+         }
+      }
+      InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+      coeff_ptr = ceed_coeff;
+   }
+}
+
+/** @brief Initializes an mfem::ceed::Coefficient @a coeff_ptr from an
+    mfem::MatrixCoefficient @a MQ, an mfem::Mesh @a mesh, and an
+    mfem::IntegrationRule @a ir for the elements given by the indices @a indices.
+
+    @param[in] MQ is the matrix coefficient from the `Integrator`.
+    @param[in] mesh is the mesh.
+    @param[in] ir is the integration rule.
+    @param[in] use_bdr is a flag to construct the coefficient on mesh boundaries.
+    @param[in] nelem is the number of elements.
+    @param[in] indices are the indices of the elements of same type in the
+                       `FiniteElementSpace`.
+    @param[in] ceed The Ceed object.
+    @param[out] coeff_ptr is the structure to store the coefficient for the
+                          `CeedOperator`. */
+inline void InitCoefficientWithIndices(mfem::MatrixCoefficient &MQ,
+                                       mfem::Mesh &mesh,
+                                       const mfem::IntegrationRule &ir,
+                                       bool use_bdr,
+                                       int nelem,
+                                       const int *indices,
+                                       Ceed ceed,
+                                       Coefficient *&coeff_ptr)
+{
+   // Assumes matrix coefficient is symmetric
+   const int vdim = MQ.GetVDim();
+   const int ncomp = (vdim * (vdim + 1)) / 2;
+   const int nq = ir.GetNPoints();
+   auto *ceed_coeff = new QuadCoefficient(ncomp);
+   ceed_coeff->vector.SetSize(ncomp * nq * nelem);
+   auto C = Reshape(ceed_coeff->vector.HostWrite(), ncomp, nq, nelem);
+   mfem::IsoparametricTransformation T;
+   mfem::DenseMatrix Q_ip;
+   for (int i = 0; i < nelem; ++i)
+   {
+      const int e = indices[i];
+      if (use_bdr)
+      {
+         mesh.GetBdrElementTransformation(e, &T);
+      }
+      else
+      {
+         mesh.GetElementTransformation(e, &T);
+      }
+      for (int q = 0; q < nq; ++q)
+      {
+         const IntegrationPoint &ip = ir.IntPoint(q);
+         T.SetIntPoint(&ip);
+         MQ.Eval(Q_ip, T, ip);
+         for (int dj = 0; dj < vdim; ++dj)
+         {
+            for (int di = dj; di < vdim; ++di)
             {
-               C(d, q, i) = Q_ir(d, q);
+               const int idx = (dj * vdim) - (((dj - 1) * dj) / 2) + di - dj;
+               C(idx, q, i) = Q_ip(di, dj);  // Column-major
             }
          }
       }
-      InitVector(ceedCoeff->coeff, ceedCoeff->coeffVector);
-      coeff_ptr = ceedCoeff;
    }
+   InitVector(ceed_coeff->vector, ceed, ceed_coeff->coeff_vector);
+   coeff_ptr = ceed_coeff;
 }
 
-template <typename Coeff, typename Context>
-void InitCoefficient(Coeff *Q, mfem::Mesh &mesh,
-                     const mfem::IntegrationRule &ir, int nelem,
-                     const int* indices, Coefficient *&coeff_ptr, Context &ctx)
+template <typename CoeffType>
+inline void InitCoefficient(CoeffType &Q,
+                            mfem::Mesh &mesh,
+                            const mfem::IntegrationRule &ir,
+                            bool use_bdr,
+                            int nelem,
+                            const int *indices,
+                            Ceed ceed,
+                            Coefficient *&coeff_ptr)
 {
    if (indices)
    {
-      InitCoefficientWithIndices(Q, mesh, ir, nelem, indices, coeff_ptr, ctx);
+      InitCoefficientWithIndices(Q, mesh, ir, use_bdr, nelem, indices,
+                                 ceed, coeff_ptr);
    }
    else
    {
-      InitCoefficient(Q, mesh, ir, coeff_ptr, ctx);
+      InitCoefficient(Q, mesh, ir, use_bdr, ceed, coeff_ptr);
    }
 }
 
diff --git a/fem/ceed/interface/integrator.hpp b/fem/ceed/interface/integrator.hpp
index eea79388d..713518b42 100644
--- a/fem/ceed/interface/integrator.hpp
+++ b/fem/ceed/interface/integrator.hpp
@@ -9,17 +9,18 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#ifndef MFEM_LIBCEED_INTEG
-#define MFEM_LIBCEED_INTEG
+#ifndef MFEM_LIBCEED_INTEGRATOR
+#define MFEM_LIBCEED_INTEGRATOR
 
-#include "../../../config/config.hpp"
 #include "../../fespace.hpp"
 #include "../../gridfunc.hpp"
-#include "operator.hpp"
+#include "basis.hpp"
 #include "coefficient.hpp"
+#include "operator.hpp"
 #include "restriction.hpp"
 #include "util.hpp"
 #include "ceed.hpp"
+#include <string>
 
 namespace mfem
 {
@@ -28,43 +29,29 @@ namespace ceed
 {
 
 /** The different evaluation modes available for PA and MF CeedIntegrator. */
-enum class EvalMode { None, Interp, Grad, InterpAndGrad };
+enum class EvalMode { None, Interp, Grad, Div, Curl,
+                      InterpAndGrad, InterpAndDiv, InterpAndCurl
+                    };
 
 #ifdef MFEM_USE_CEED
 /** This structure is a template interface for the Assemble methods of
     PAIntegrator and MFIntegrator. See ceed/mass.cpp for an example. */
 struct OperatorInfo
 {
-   /** The path to the qFunction header. */
+   /** The path to the QFunction header. */
    const char *header;
-   /** The name of the qFunction to build a partially assembled CeedOperator
-       with a constant Coefficient. */
-   const char *build_func_const;
-   /** The qFunction to build a partially assembled CeedOperator with a constant
-       Coefficient. */
-   CeedQFunctionUser build_qf_const;
-   /** The name of the qFunction to build a partially assembled CeedOperator
-       with a variable Coefficient. */
-   const char *build_func_quad;
-   /** The qFunction to build a partially assembled CeedOperator with a variable
-       Coefficient. */
-   CeedQFunctionUser build_qf_quad;
-   /** The name of the qFunction to apply a partially assembled CeedOperator. */
+   /** The name of the QFunction to build a partially assembled CeedOperator. */
+   const char *build_func;
+   /** The QFunction to build a partially assembled CeedOperator. */
+   CeedQFunctionUser build_qf;
+   /** The name of the QFunction to apply a partially assembled CeedOperator. */
    const char *apply_func;
-   /** The qFunction to apply a partially assembled CeedOperator. */
+   /** The QFunction to apply a partially assembled CeedOperator. */
    CeedQFunctionUser apply_qf;
-   /** The name of the qFunction to apply a matrix-free CeedOperator with a
-       constant Coefficient. */
-   const char *apply_func_mf_const;
-   /** The qFunction to apply a matrix-free CeedOperator with a constant
-       Coefficient. */
-   CeedQFunctionUser apply_qf_mf_const;
-   /** The name of the qFunction to apply a matrix-free CeedOperator with a
-       variable Coefficient. */
-   const char *apply_func_mf_quad;
-   /** The qFunction to apply a matrix-free CeedOperator with a variable
-       Coefficient. */
-   CeedQFunctionUser apply_qf_mf_quad;
+   /** The name of the QFunction to apply a matrix-free CeedOperator. */
+   const char *apply_func_mf;
+   /** The QFunction to apply a matrix-free CeedOperator. */
+   CeedQFunctionUser apply_qf_mf;
    /** The EvalMode on the trial basis functions. */
    EvalMode trial_op;
    /** The EvalMode on the test basis functions. */
@@ -74,284 +61,348 @@ struct OperatorInfo
 };
 #endif
 
-/** This class represent a partially assembled operator using libCEED. */
-class PAIntegrator : public ceed::Operator
+/** This class represents a matrix-free or partially assembled bilinear,
+    mixed bilinear, or nonlinear form operator using libCEED. */
+class Integrator
 {
 #ifdef MFEM_USE_CEED
 protected:
-   CeedBasis  trial_basis, test_basis, mesh_basis;
-   CeedElemRestriction trial_restr, test_restr, mesh_restr, restr_i;
-   CeedQFunction build_qfunc, apply_qfunc;
+   CeedOperator oper;
+   CeedBasis trial_basis, test_basis, mesh_basis;
+   CeedElemRestriction trial_restr, test_restr, mesh_restr, qdata_restr;
+   CeedQFunction apply_qfunc;
+   CeedQFunctionContext apply_ctx;
    CeedVector node_coords, qdata;
-   Coefficient *coeff;
-   CeedQFunctionContext build_ctx;
-   CeedOperator build_oper;
+   Coefficient *coeff1, *coeff2;
 
 public:
-   PAIntegrator()
-      : Operator(),
+   Integrator()
+      : oper(nullptr),
         trial_basis(nullptr), test_basis(nullptr), mesh_basis(nullptr),
         trial_restr(nullptr), test_restr(nullptr), mesh_restr(nullptr),
-        restr_i(nullptr),
-        build_qfunc(nullptr), apply_qfunc(nullptr), node_coords(nullptr),
-        qdata(nullptr), coeff(nullptr), build_ctx(nullptr), build_oper(nullptr)
-   { }
-
-   /** @brief This method assembles the `PAIntegrator` with the given
-       `CeedOperatorInfo` @a info, an `mfem::FiniteElementSpace` @a fes, an
-       `mfem::IntegrationRule` @a ir, and `mfem::Coefficient` or
-       `mfem::VectorCoefficient` @a Q.
-       The `CeedOperatorInfo` type is expected to inherit from `OperatorInfo`,
-       and contain a `Context` type relevant to the qFunctions.
-
-       @param[in] info is the structure describing the CeedOperator to assemble.
-       @param[in] fes is the finite element space.
-       @param[in] ir is the integration rule for the operator.
-       @param[in] Q is the coefficient from the `Integrator`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
-                 const mfem::FiniteElementSpace &fes,
-                 const mfem::IntegrationRule &ir,
-                 CoeffType *Q)
-   {
-      Assemble(info, fes, ir, fes.GetNE(), nullptr, Q);
-   }
+        qdata_restr(nullptr),
+        apply_qfunc(nullptr), apply_ctx(nullptr),
+        node_coords(nullptr), qdata(nullptr),
+        coeff1(nullptr), coeff2(nullptr) {}
 
-   /** @brief This method assembles the `PAIntegrator` with the given
-       `CeedOperatorInfo` @a info, an `mfem::FiniteElementSpace` @a fes, an
-       `mfem::IntegrationRule` @a ir, and `mfem::Coefficient` or
-       `mfem::VectorCoefficient` @a Q for the elements given by the indices
-       @a indices.
-       The `CeedOperatorInfo` type is expected to inherit from `OperatorInfo`,
-       and contain a `Context` type relevant to the qFunctions.
-
-       @param[in] info is the structure describing the CeedOperator to assemble.
-       @param[in] fes is the finite element space.
-       @param[in] ir is the integration rule for the operator.
-       @param[in] nelem The number of elements.
-       @param[in] indices The indices of the elements of same type in the
-                          `FiniteElementSpace`. If `indices == nullptr`, assumes
-                          that the `FiniteElementSpace` is not mixed.
-       @param[in] Q is the coefficient from the `Integrator`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
-                 const mfem::FiniteElementSpace &fes,
-                 const mfem::IntegrationRule &ir,
-                 int nelem,
-                 const int* indices,
-                 CoeffType *Q)
-   {
-      Assemble(info, fes, fes, ir, nelem, indices, Q);
-   }
-
-   /** This method assembles the PAIntegrator for mixed forms.
+   CeedOperator GetOperator() const { return oper; }
+   CeedOperator GetTransposeOperator() const { return nullptr; }
 
-       @param[in] info the `CeedOperatorInfo` describing the `CeedOperator`,
-                       the `CeedOperatorInfo` type is expected to inherit from
-                       `OperatorInfo` and contain a `Context` type relevant to
-                       the qFunctions.
-       @param[in] trial_fes the trial `FiniteElementSpace` for the form,
-       @param[in] test_fes the test `FiniteElementSpace` for the form,
-       @param[in] ir the `IntegrationRule` for the numerical integration,
-       @param[in] Q `Coefficient` or `VectorCoefficient`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
+   template <typename CeedOperatorInfo, typename CoeffType1, typename CoeffType2>
+   void Assemble(Ceed ceed,
+                 CeedOperatorInfo &info,
                  const mfem::FiniteElementSpace &trial_fes,
                  const mfem::FiniteElementSpace &test_fes,
                  const mfem::IntegrationRule &ir,
-                 CoeffType *Q)
+                 CoeffType1 *Q1,
+                 CoeffType2 *Q2,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
    {
-      Assemble(info, trial_fes, test_fes, ir, trial_fes.GetNE(), nullptr, Q);
+      Assemble(ceed, info, trial_fes, test_fes, ir,
+               use_bdr ? trial_fes.GetNBE() : trial_fes.GetNE(),
+               nullptr, Q1, Q2, use_bdr, use_mf);
    }
 
-   /** This method assembles the PAIntegrator for mixed forms on mixed meshes.
+   /** This method assembles the `Integrator` for mixed forms on mixed meshes.
 
-       @param[in] info the `CeedOperatorInfo` describing the `CeedOperator`,
+       @param[in] ceed The Ceed object.
+       @param[in] info The `CeedOperatorInfo` describing the `CeedOperator`,
                        the `CeedOperatorInfo` type is expected to inherit from
                        `OperatorInfo` and contain a `Context` type relevant to
-                       the qFunctions.
-       @param[in] trial_fes the trial `FiniteElementSpace` for the form,
-       @param[in] test_fes the test `FiniteElementSpace` for the form,
-       @param[in] ir the `IntegrationRule` for the numerical integration,
-       @param[in] nelem The number of elements,
+                       the QFunctions.
+       @param[in] trial_fes The trial `FiniteElementSpace` for the form.
+       @param[in] test_fes The test `FiniteElementSpace` for the form.
+       @param[in] ir The `IntegrationRule` for the numerical integration.
+       @param[in] nelem The number of elements.
        @param[in] indices The indices of the elements of same type in the
                           `FiniteElementSpace`. If `indices == nullptr`, assumes
-                          that the `FiniteElementSpace` is not mixed,
-       @param[in] Q `Coefficient` or `VectorCoefficient`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
+                          that the `FiniteElementSpace` is not mixed.
+       @param[in] Q1 `Coefficient`, `VectorCoefficient`, or
+                     `MatrixCoefficient`.
+       @param[in] Q2 A second `Coefficient`, `VectorCoefficient`, or
+                     `MatrixCoefficient` for certain integrators.
+       @param[in] use_bdr Controls whether to construct the operator for the
+                          domain or domain boundary.
+       @param[in] use_mf Controls whether to construct a matrix-free or
+                         partially assembled operator. */
+   template <typename CeedOperatorInfo, typename CoeffType1, typename CoeffType2>
+   void Assemble(Ceed ceed,
+                 CeedOperatorInfo &info,
                  const mfem::FiniteElementSpace &trial_fes,
                  const mfem::FiniteElementSpace &test_fes,
                  const mfem::IntegrationRule &ir,
                  int nelem,
-                 const int* indices,
-                 CoeffType *Q)
+                 const int *indices,
+                 CoeffType1 *Q1,
+                 CoeffType2 *Q2,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
    {
-      Ceed ceed(internal::ceed);
       mfem::Mesh &mesh = *trial_fes.GetMesh();
-      MFEM_VERIFY(!(!indices && mesh.GetNumGeometries(mesh.Dimension()) > 1),
-                  "Use ceed::MixedIntegrator on mixed meshes.");
-      InitCoefficient(Q, mesh, ir, nelem, indices, coeff, info.ctx);
-      bool const_coeff = coeff->IsConstant();
-      std::string build_func = const_coeff ? info.build_func_const
-                               : info.build_func_quad;
-      CeedQFunctionUser build_qf = const_coeff ? info.build_qf_const
-                                   : info.build_qf_quad;
-      PAOperator op {info.qdatasize, info.header,
-                     build_func, build_qf,
-                     info.apply_func, info.apply_qf,
-                     info.trial_op,
-                     info.test_op
-                    };
-      CeedInt dim = mesh.SpaceDimension();
+      CeedInt dim = mesh.Dimension() - use_bdr;
+      CeedInt space_dim = mesh.SpaceDimension();
+      CeedInt curl_dim = (dim < 3) ? 1 : dim;
       CeedInt trial_vdim = trial_fes.GetVDim();
       CeedInt test_vdim = test_fes.GetVDim();
-
-      mesh.EnsureNodes();
-      if ( &trial_fes == &test_fes )
+      bool trial_vectorfe =
+         (trial_fes.FEColl()->GetRangeType(dim) == mfem::FiniteElement::VECTOR);
+      bool test_vectorfe =
+         (test_fes.FEColl()->GetRangeType(dim) == mfem::FiniteElement::VECTOR);
+      MFEM_VERIFY(!(!indices && mesh.GetNumGeometries(dim) > 1),
+                  "Use ceed::MixedOperator<ceed::Integrator> on mixed meshes.");
+      if (Q1) { InitCoefficient(*Q1, mesh, ir, use_bdr, nelem, indices, ceed, coeff1); }
+      if (Q2) { InitCoefficient(*Q2, mesh, ir, use_bdr, nelem, indices, ceed, coeff2); }
+
+      if (&trial_fes == &test_fes)
       {
-         InitBasisAndRestriction(trial_fes, ir, nelem, indices,
-                                 ceed, &trial_basis, &trial_restr);
-         test_basis = trial_basis;
-         test_restr = trial_restr;
+         InitBasis(trial_fes, ir, use_bdr, indices, ceed,
+                   &trial_basis);
+         InitRestriction(trial_fes, use_bdr, nelem, indices, ceed,
+                         &trial_restr);
+         CeedBasisReferenceCopy(trial_basis, &test_basis);
+         CeedElemRestrictionReferenceCopy(trial_restr, &test_restr);
       }
       else
       {
-         InitBasisAndRestriction(trial_fes, ir, nelem, indices,
-                                 ceed, &trial_basis, &trial_restr);
-         InitBasisAndRestriction(test_fes, ir, nelem, indices,
-                                 ceed, &test_basis, &test_restr);
+         InitBasis(trial_fes, ir, use_bdr, indices, ceed,
+                   &trial_basis);
+         InitBasis(test_fes, ir, use_bdr, indices, ceed,
+                   &test_basis);
+         InitRestriction(trial_fes, use_bdr, nelem, indices, ceed,
+                         &trial_restr);
+         InitRestriction(test_fes, use_bdr, nelem, indices, ceed,
+                         &test_restr);
       }
 
-      const mfem::FiniteElementSpace *mesh_fes = mesh.GetNodalFESpace();
-      MFEM_VERIFY(mesh_fes, "the Mesh has no nodal FE space");
-      InitBasisAndRestriction(*mesh_fes, ir, nelem, indices,
-                              ceed, &mesh_basis, &mesh_restr);
-
       CeedInt trial_nqpts, test_nqpts;
       CeedBasisGetNumQuadraturePoints(trial_basis, &trial_nqpts);
       CeedBasisGetNumQuadraturePoints(test_basis, &test_nqpts);
       MFEM_VERIFY(trial_nqpts == test_nqpts,
                   "Trial and test basis must have the same number of quadrature"
                   " points.");
-      CeedInt nqpts = trial_nqpts;
-
-      const int qdatasize = op.qdatasize;
-      InitStridedRestriction(*mesh_fes, nelem, nqpts, qdatasize,
-                             CEED_STRIDES_BACKEND,
-                             &restr_i);
-
-      InitVector(*mesh.GetNodes(), node_coords);
-
-      CeedVectorCreate(ceed, nelem * nqpts * qdatasize, &qdata);
-
-      // Context data to be passed to the Q-function.
-      info.ctx.dim = mesh.Dimension();
-      info.ctx.space_dim = mesh.SpaceDimension();
-      info.ctx.vdim = trial_fes.GetVDim();
-
-      std::string qf_file = GetCeedPath() + op.header;
-      std::string qf = qf_file + op.build_func;
-      CeedQFunctionCreateInterior(ceed, 1, op.build_qf, qf.c_str(),
-                                  &build_qfunc);
-
-      // Create the Q-function that builds the operator (i.e. computes its
-      // quadrature data) and set its context data.
-      if (VariableCoefficient *var_coeff =
-             dynamic_cast<VariableCoefficient*>(coeff))
+      const CeedInt nqpts = trial_nqpts;
+#ifdef MFEM_USE_OPENMP
+      #pragma omp critical (MeshNodes)
+#endif
       {
-         CeedQFunctionAddInput(build_qfunc, "coeff", coeff->ncomp,
-                               var_coeff->emode);
+         mesh.EnsureNodes();
+         InitVector(*mesh.GetNodes(), ceed, node_coords);
       }
-      CeedQFunctionAddInput(build_qfunc, "dx", dim * dim, CEED_EVAL_GRAD);
-      CeedQFunctionAddInput(build_qfunc, "weights", 1, CEED_EVAL_WEIGHT);
-      CeedQFunctionAddOutput(build_qfunc, "qdata", qdatasize, CEED_EVAL_NONE);
+      const mfem::FiniteElementSpace *mesh_fes = mesh.GetNodalFESpace();
+      MFEM_VERIFY(mesh_fes, "The mesh has no nodal FE space.");
+      InitBasis(*mesh_fes, ir, use_bdr, indices, ceed, &mesh_basis);
+      InitRestriction(*mesh_fes, use_bdr, nelem, indices, ceed, &mesh_restr);
 
-      CeedQFunctionContextCreate(ceed, &build_ctx);
-      CeedQFunctionContextSetData(build_ctx, CEED_MEM_HOST,
+      CeedQFunctionContextCreate(ceed, &apply_ctx);
+      CeedQFunctionContextSetData(apply_ctx, CEED_MEM_HOST,
                                   CEED_COPY_VALUES,
                                   sizeof(info.ctx),
                                   &info.ctx);
-      CeedQFunctionSetContext(build_qfunc, build_ctx);
 
-      // Create the operator that builds the quadrature data for the operator.
-      CeedOperatorCreate(ceed, build_qfunc, NULL, NULL, &build_oper);
-      if (GridCoefficient *gridCoeff = dynamic_cast<GridCoefficient*>(coeff))
-      {
-         InitBasisAndRestriction(*gridCoeff->gf.FESpace(), ir,
-                                 nelem, indices, ceed,
-                                 &gridCoeff->basis,
-                                 &gridCoeff->restr);
-         CeedOperatorSetField(build_oper, "coeff", gridCoeff->restr,
-                              gridCoeff->basis, gridCoeff->coeffVector);
-      }
-      else if (QuadCoefficient *quadCoeff =
-                  dynamic_cast<QuadCoefficient*>(coeff))
+      if (!use_mf)
       {
-         const int ncomp = quadCoeff->ncomp;
-         CeedInt strides[3] = {ncomp, 1, ncomp*nqpts};
-         InitStridedRestriction(*mesh.GetNodalFESpace(),
-                                nelem, nqpts, ncomp, strides,
-                                &quadCoeff->restr);
-         CeedOperatorSetField(build_oper, "coeff", quadCoeff->restr,
-                              CEED_BASIS_COLLOCATED, quadCoeff->coeffVector);
+         const int qdatasize = info.qdatasize;
+         InitStridedRestriction(*mesh_fes, nelem, nqpts, qdatasize,
+                                CEED_STRIDES_BACKEND, ceed,
+                                &qdata_restr);
+         CeedVectorCreate(ceed, nelem * nqpts * qdatasize, &qdata);
+
+         // Create the QFunction that builds the operator (i.e. computes its
+         // quadrature data) and set its context data.
+         CeedQFunction build_qfunc;
+         std::string qf = GetCeedPath() + info.header + info.build_func;
+         CeedQFunctionCreateInterior(ceed, 1, info.build_qf, qf.c_str(),
+                                     &build_qfunc);
+         if (coeff1)
+         {
+            CeedQFunctionAddInput(build_qfunc, "coeff1", coeff1->ncomp, coeff1->emode);
+         }
+         if (coeff2)
+         {
+            CeedQFunctionAddInput(build_qfunc, "coeff2", coeff2->ncomp, coeff2->emode);
+         }
+         CeedQFunctionAddInput(build_qfunc, "dx", dim * space_dim, CEED_EVAL_GRAD);
+         CeedQFunctionAddInput(build_qfunc, "weights", 1, CEED_EVAL_WEIGHT);
+         CeedQFunctionAddOutput(build_qfunc, "qdata", qdatasize, CEED_EVAL_NONE);
+         CeedQFunctionSetContext(build_qfunc, apply_ctx);
+
+         // Create the operator that builds the quadrature data for the operator.
+         CeedOperator build_oper;
+         CeedOperatorCreate(ceed, build_qfunc, NULL, NULL, &build_oper);
+         if (coeff1)
+         {
+            if (GridCoefficient *grid_coeff = dynamic_cast<GridCoefficient *>(coeff1))
+            {
+               const mfem::FiniteElementSpace *coeff_fes = grid_coeff->gf.FESpace();
+               InitBasis(*coeff_fes, ir, use_bdr, indices, ceed,
+                         &grid_coeff->basis);
+               InitRestriction(*coeff_fes, use_bdr, nelem, indices, ceed,
+                               &grid_coeff->restr);
+               CeedOperatorSetField(build_oper, "coeff1", grid_coeff->restr,
+                                    grid_coeff->basis, grid_coeff->coeff_vector);
+            }
+            else if (QuadCoefficient *quad_coeff = dynamic_cast<QuadCoefficient *>(coeff1))
+            {
+               const int ncomp = quad_coeff->ncomp;
+               CeedInt strides[3] = {ncomp, 1, ncomp * nqpts};
+               InitStridedRestriction(*mesh_fes, nelem, nqpts, ncomp, strides, ceed,
+                                      &quad_coeff->restr);
+               CeedOperatorSetField(build_oper, "coeff1", quad_coeff->restr,
+                                    CEED_BASIS_COLLOCATED, quad_coeff->coeff_vector);
+            }
+            else
+            {
+               MFEM_ABORT("Unknown coefficient type in QFunction setup!");
+            }
+         }
+         if (coeff2)
+         {
+            if (GridCoefficient *grid_coeff = dynamic_cast<GridCoefficient *>(coeff2))
+            {
+               const mfem::FiniteElementSpace *coeff_fes = grid_coeff->gf.FESpace();
+               InitBasis(*coeff_fes, ir, use_bdr, indices, ceed,
+                         &grid_coeff->basis);
+               InitRestriction(*coeff_fes, use_bdr, nelem, indices, ceed,
+                               &grid_coeff->restr);
+               CeedOperatorSetField(build_oper, "coeff2", grid_coeff->restr,
+                                    grid_coeff->basis, grid_coeff->coeff_vector);
+            }
+            else if (QuadCoefficient *quad_coeff = dynamic_cast<QuadCoefficient *>(coeff2))
+            {
+               const int ncomp = quad_coeff->ncomp;
+               CeedInt strides[3] = {ncomp, 1, ncomp * nqpts};
+               InitStridedRestriction(*mesh_fes, nelem, nqpts, ncomp, strides, ceed,
+                                      &quad_coeff->restr);
+               CeedOperatorSetField(build_oper, "coeff2", quad_coeff->restr,
+                                    CEED_BASIS_COLLOCATED, quad_coeff->coeff_vector);
+            }
+            else
+            {
+               MFEM_ABORT("Unknown coefficient type in QFunction setup!");
+            }
+         }
+         CeedOperatorSetField(build_oper, "dx", mesh_restr,
+                              mesh_basis, CEED_VECTOR_ACTIVE);
+         CeedOperatorSetField(build_oper, "weights", CEED_ELEMRESTRICTION_NONE,
+                              mesh_basis, CEED_VECTOR_NONE);
+         CeedOperatorSetField(build_oper, "qdata", qdata_restr,
+                              CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE);
+         CeedOperatorCheckReady(build_oper);
+
+         // Compute the quadrature data for the operator.
+         CeedOperatorApply(build_oper, node_coords, qdata, CEED_REQUEST_IMMEDIATE);
+
+         CeedOperatorDestroy(&build_oper);
+         CeedQFunctionDestroy(&build_qfunc);
+
+         CeedVectorDestroy(&node_coords);
+         node_coords = nullptr;
+         delete coeff1;
+         delete coeff2;
+         coeff1 = coeff2 = nullptr;
       }
-      CeedOperatorSetField(build_oper, "dx", mesh_restr,
-                           mesh_basis, CEED_VECTOR_ACTIVE);
-      CeedOperatorSetField(build_oper, "weights", CEED_ELEMRESTRICTION_NONE,
-                           mesh_basis, CEED_VECTOR_NONE);
-      CeedOperatorSetField(build_oper, "qdata", restr_i,
-                           CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE);
-
-      // Compute the quadrature data for the operator.
-      CeedOperatorApply(build_oper, node_coords, qdata, CEED_REQUEST_IMMEDIATE);
-
-      // Create the Q-function that defines the action of the operator.
-      qf = qf_file + op.apply_func;
-      CeedQFunctionCreateInterior(ceed, 1, op.apply_qf, qf.c_str(),
+
+      // Create the QFunction that defines the action of the operator.
+      std::string qf = GetCeedPath() + info.header + info.apply_func;
+      CeedQFunctionCreateInterior(ceed, 1, info.apply_qf, qf.c_str(),
                                   &apply_qfunc);
-      // input
-      switch (op.trial_op)
+      switch (info.trial_op)
       {
          case EvalMode::None:
             CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim, CEED_EVAL_NONE);
             break;
          case EvalMode::Interp:
-            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim, CEED_EVAL_INTERP);
+            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim * (trial_vectorfe ? dim : 1),
+                                  CEED_EVAL_INTERP);
             break;
          case EvalMode::Grad:
-            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim*dim, CEED_EVAL_GRAD);
+            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim * dim, CEED_EVAL_GRAD);
+            break;
+         case EvalMode::Div:
+            CeedQFunctionAddInput(apply_qfunc, "du", trial_vdim, CEED_EVAL_DIV);
+            break;
+         case EvalMode::Curl:
+            CeedQFunctionAddInput(apply_qfunc, "cu", trial_vdim * curl_dim, CEED_EVAL_CURL);
             break;
          case EvalMode::InterpAndGrad:
+            MFEM_VERIFY(!trial_vectorfe,
+                        "EvalMode::InterpAndGrad is not intended for vector FE.");
             CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim, CEED_EVAL_INTERP);
-            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim*dim, CEED_EVAL_GRAD);
+            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim * dim, CEED_EVAL_GRAD);
             break;
+         case EvalMode::InterpAndDiv:
+            MFEM_VERIFY(trial_vectorfe,
+                        "EvalMode::InterpAndDiv is only intended for vector FE.");
+            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim * dim, CEED_EVAL_INTERP);
+            CeedQFunctionAddInput(apply_qfunc, "du", trial_vdim, CEED_EVAL_DIV);
+            break;
+         case EvalMode::InterpAndCurl:
+            MFEM_VERIFY(trial_vectorfe,
+                        "EvalMode::InterpAndCurl is only intended for vector FE.");
+            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim * dim, CEED_EVAL_INTERP);
+            CeedQFunctionAddInput(apply_qfunc, "cu", trial_vdim * curl_dim, CEED_EVAL_CURL);
+            break;
+      }
+      if (use_mf)
+      {
+         if (coeff1)
+         {
+            CeedQFunctionAddInput(apply_qfunc, "coeff1", coeff1->ncomp, coeff1->emode);
+         }
+         if (coeff2)
+         {
+            CeedQFunctionAddInput(apply_qfunc, "coeff2", coeff2->ncomp, coeff2->emode);
+         }
+         CeedQFunctionAddInput(apply_qfunc, "dx", dim * space_dim, CEED_EVAL_GRAD);
+         CeedQFunctionAddInput(apply_qfunc, "weights", 1, CEED_EVAL_WEIGHT);
+      }
+      else
+      {
+         CeedQFunctionAddInput(apply_qfunc, "qdata", info.qdatasize, CEED_EVAL_NONE);
       }
-      // qdata
-      CeedQFunctionAddInput(apply_qfunc, "qdata", qdatasize, CEED_EVAL_NONE);
-      // output
-      switch (op.test_op)
+      switch (info.test_op)
       {
          case EvalMode::None:
             CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim, CEED_EVAL_NONE);
             break;
          case EvalMode::Interp:
-            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim, CEED_EVAL_INTERP);
+            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim * (test_vectorfe ? dim : 1),
+                                   CEED_EVAL_INTERP);
             break;
          case EvalMode::Grad:
-            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim*dim, CEED_EVAL_GRAD);
+            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim * dim, CEED_EVAL_GRAD);
+            break;
+         case EvalMode::Div:
+            CeedQFunctionAddOutput(apply_qfunc, "dv", test_vdim, CEED_EVAL_DIV);
+            break;
+         case EvalMode::Curl:
+            CeedQFunctionAddOutput(apply_qfunc, "cv", test_vdim * curl_dim, CEED_EVAL_CURL);
             break;
          case EvalMode::InterpAndGrad:
+            MFEM_VERIFY(!test_vectorfe,
+                        "EvalMode::InterpAndGrad is not intended for vector FE.");
             CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim, CEED_EVAL_INTERP);
-            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim*dim, CEED_EVAL_GRAD);
+            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim * dim, CEED_EVAL_GRAD);
+            break;
+         case EvalMode::InterpAndDiv:
+            MFEM_VERIFY(test_vectorfe,
+                        "EvalMode::InterpAndDiv is only intended for vector FE.");
+            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim * dim, CEED_EVAL_INTERP);
+            CeedQFunctionAddOutput(apply_qfunc, "dv", test_vdim, CEED_EVAL_DIV);
+            break;
+         case EvalMode::InterpAndCurl:
+            MFEM_VERIFY(test_vectorfe,
+                        "EvalMode::InterpAndCurl is only intended for vector FE.");
+            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim * dim, CEED_EVAL_INTERP);
+            CeedQFunctionAddOutput(apply_qfunc, "cv", test_vdim * curl_dim, CEED_EVAL_CURL);
             break;
       }
-      CeedQFunctionSetContext(apply_qfunc, build_ctx);
+      CeedQFunctionSetContext(apply_qfunc, apply_ctx);
 
       // Create the operator.
       CeedOperatorCreate(ceed, apply_qfunc, NULL, NULL, &oper);
-      // input
-      switch (op.trial_op)
+      switch (info.trial_op)
       {
          case EvalMode::None:
             CeedOperatorSetField(oper, "u", trial_restr,
@@ -363,16 +414,88 @@ public:
          case EvalMode::Grad:
             CeedOperatorSetField(oper, "gu", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
             break;
+         case EvalMode::Div:
+            CeedOperatorSetField(oper, "du", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
+            break;
+         case EvalMode::Curl:
+            CeedOperatorSetField(oper, "cu", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
+            break;
          case EvalMode::InterpAndGrad:
             CeedOperatorSetField(oper, "u", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
             CeedOperatorSetField(oper, "gu", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
             break;
+         case EvalMode::InterpAndDiv:
+            CeedOperatorSetField(oper, "u", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
+            CeedOperatorSetField(oper, "du", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
+            break;
+         case EvalMode::InterpAndCurl:
+            CeedOperatorSetField(oper, "u", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
+            CeedOperatorSetField(oper, "cu", trial_restr, trial_basis, CEED_VECTOR_ACTIVE);
+            break;
+      }
+      if (use_mf)
+      {
+         if (coeff1)
+         {
+            if (GridCoefficient *grid_coeff = dynamic_cast<GridCoefficient *>(coeff1))
+            {
+               const mfem::FiniteElementSpace *coeff_fes = grid_coeff->gf.FESpace();
+               InitBasis(*coeff_fes, ir, use_bdr, indices, ceed,
+                         &grid_coeff->basis);
+               InitRestriction(*coeff_fes, use_bdr, nelem, indices, ceed,
+                               &grid_coeff->restr);
+               CeedOperatorSetField(oper, "coeff1", grid_coeff->restr,
+                                    grid_coeff->basis, grid_coeff->coeff_vector);
+            }
+            else if (QuadCoefficient *quad_coeff = dynamic_cast<QuadCoefficient *>(coeff1))
+            {
+               const int ncomp = quad_coeff->ncomp;
+               CeedInt strides[3] = {ncomp, 1, ncomp * nqpts};
+               InitStridedRestriction(*mesh_fes, nelem, nqpts, ncomp, strides, ceed,
+                                      &quad_coeff->restr);
+               CeedOperatorSetField(oper, "coeff1", quad_coeff->restr,
+                                    CEED_BASIS_COLLOCATED, quad_coeff->coeff_vector);
+            }
+            else
+            {
+               MFEM_ABORT("Unknown coefficient type in QFunction setup!");
+            }
+         }
+         if (coeff2)
+         {
+            if (GridCoefficient *grid_coeff = dynamic_cast<GridCoefficient *>(coeff2))
+            {
+               const mfem::FiniteElementSpace *coeff_fes = grid_coeff->gf.FESpace();
+               InitBasis(*coeff_fes, ir, use_bdr, indices, ceed,
+                         &grid_coeff->basis);
+               InitRestriction(*coeff_fes, use_bdr, nelem, indices, ceed,
+                               &grid_coeff->restr);
+               CeedOperatorSetField(oper, "coeff2", grid_coeff->restr,
+                                    grid_coeff->basis, grid_coeff->coeff_vector);
+            }
+            else if (QuadCoefficient *quad_coeff = dynamic_cast<QuadCoefficient *>(coeff2))
+            {
+               const int ncomp = quad_coeff->ncomp;
+               CeedInt strides[3] = {ncomp, 1, ncomp * nqpts};
+               InitStridedRestriction(*mesh_fes, nelem, nqpts, ncomp, strides, ceed,
+                                      &quad_coeff->restr);
+               CeedOperatorSetField(oper, "coeff2", quad_coeff->restr,
+                                    CEED_BASIS_COLLOCATED, quad_coeff->coeff_vector);
+            }
+            else
+            {
+               MFEM_ABORT("Unknown coefficient type in QFunction setup!");
+            }
+         }
+         CeedOperatorSetField(oper, "dx", mesh_restr, mesh_basis, node_coords);
+         CeedOperatorSetField(oper, "weights", CEED_ELEMRESTRICTION_NONE,
+                              mesh_basis, CEED_VECTOR_NONE);
       }
-      // qdata
-      CeedOperatorSetField(oper, "qdata", restr_i, CEED_BASIS_COLLOCATED,
-                           qdata);
-      // output
-      switch (op.test_op)
+      else
+      {
+         CeedOperatorSetField(oper, "qdata", qdata_restr, CEED_BASIS_COLLOCATED, qdata);
+      }
+      switch (info.test_op)
       {
          case EvalMode::None:
             CeedOperatorSetField(oper, "v", test_restr,
@@ -384,389 +507,162 @@ public:
          case EvalMode::Grad:
             CeedOperatorSetField(oper, "gv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
             break;
+         case EvalMode::Div:
+            CeedOperatorSetField(oper, "dv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
+            break;
+         case EvalMode::Curl:
+            CeedOperatorSetField(oper, "cv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
+            break;
          case EvalMode::InterpAndGrad:
             CeedOperatorSetField(oper, "v", test_restr, test_basis, CEED_VECTOR_ACTIVE);
             CeedOperatorSetField(oper, "gv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
             break;
+         case EvalMode::InterpAndDiv:
+            CeedOperatorSetField(oper, "v", test_restr, test_basis, CEED_VECTOR_ACTIVE);
+            CeedOperatorSetField(oper, "dv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
+            break;
+         case EvalMode::InterpAndCurl:
+            CeedOperatorSetField(oper, "v", test_restr, test_basis, CEED_VECTOR_ACTIVE);
+            CeedOperatorSetField(oper, "cv", test_restr, test_basis, CEED_VECTOR_ACTIVE);
+            break;
       }
-
-      CeedVectorCreate(ceed, trial_vdim*trial_fes.GetNDofs(), &u);
-      CeedVectorCreate(ceed, test_vdim*test_fes.GetNDofs(), &v);
+      CeedOperatorCheckReady(oper);
    }
 
-   virtual ~PAIntegrator()
+   ~Integrator()
    {
-      CeedQFunctionDestroy(&build_qfunc);
+      // All basis and restriction objects are destroyed by fes destructor
+      CeedOperatorDestroy(&oper);
       CeedQFunctionDestroy(&apply_qfunc);
-      CeedQFunctionContextDestroy(&build_ctx);
+      CeedQFunctionContextDestroy(&apply_ctx);
       CeedVectorDestroy(&node_coords);
       CeedVectorDestroy(&qdata);
-      delete coeff;
-      CeedOperatorDestroy(&build_oper);
+      delete coeff1;
+      delete coeff2;
    }
-
-private:
-   /** This structure contains the data to assemble a partially assembled
-       operator with libCEED. */
-   struct PAOperator
-   {
-      /** The number of quadrature data at each quadrature point. */
-      int qdatasize;
-      /** The path to the header containing the functions for libCEED. */
-      std::string header;
-      /** The name of the Qfunction to build the quadrature data. */
-      std::string build_func;
-      /** The Qfunction to build the quadrature data. */
-      CeedQFunctionUser build_qf;
-      /** The name of the Qfunction to apply the operator. */
-      std::string apply_func;
-      /** The Qfunction to apply the operator. */
-      CeedQFunctionUser apply_qf;
-      /** The evaluation mode to apply to the trial function (CEED_EVAL_INTERP,
-          CEED_EVAL_GRAD, etc.) */
-      EvalMode trial_op;
-      /** The evaluation mode to apply to the test function ( CEED_EVAL_INTERP,
-          CEED_EVAL_GRAD, etc.)*/
-      EvalMode test_op;
-   };
 #endif
 };
 
-/** This class represent a matrix-free operator using libCEED. */
-class MFIntegrator : public ceed::Operator
+/** This class represents a matrix-free or partially assembled discrete linear
+    operator using libCEED. */
+class Interpolator
 {
 #ifdef MFEM_USE_CEED
 protected:
-   CeedBasis trial_basis, test_basis, mesh_basis;
-   CeedElemRestriction trial_restr, test_restr, mesh_restr, restr_i;
-   CeedQFunction apply_qfunc;
-   CeedVector node_coords, qdata;
-   Coefficient *coeff;
-   CeedQFunctionContext build_ctx;
+   CeedOperator oper, oper_t;
+   CeedBasis basis_ctof;
+   CeedElemRestriction trial_restr, test_restr;
+   CeedQFunction apply_qfunc, apply_qfunc_t;
 
 public:
-   MFIntegrator()
-      : Operator(),
-        trial_basis(nullptr), test_basis(nullptr), mesh_basis(nullptr),
-        trial_restr(nullptr), test_restr(nullptr), mesh_restr(nullptr),
-        restr_i(nullptr),
-        apply_qfunc(nullptr), node_coords(nullptr),
-        qdata(nullptr), coeff(nullptr), build_ctx(nullptr) { }
-
-   /** @brief This method assembles the `MFIntegrator` with the given
-       `CeedOperatorInfo` @a info, an `mfem::FiniteElementSpace` @a fes, an
-       `mfem::IntegrationRule` @a ir, and `mfem::Coefficient` or
-       `mfem::VectorCoefficient` @a Q.
-       The `CeedOperatorInfo` type is expected to inherit from `OperatorInfo`,
-       and contain a `Context` type relevant to the qFunctions.
-
-       @param[in] info is the structure describing the CeedOperator to assemble.
-       @param[in] fes is the finite element space.
-       @param[in] ir is the integration rule for the operator.
-       @param[in] Q is the coefficient from the `Integrator`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
-                 const mfem::FiniteElementSpace &fes,
-                 const mfem::IntegrationRule &ir,
-                 CoeffType *Q)
-   {
-      Assemble(info, fes, ir, fes.GetNE(), nullptr, Q);
-   }
-
-   /** @brief This method assembles the `MFIntegrator` with the given
-       `CeedOperatorInfo` @a info, an `mfem::FiniteElementSpace` @a fes, an
-       `mfem::IntegrationRule` @a ir, and `mfem::Coefficient` or
-       `mfem::VectorCoefficient` @a Q for the elements given by the indices
-       @a indices.
-       The `CeedOperatorInfo` type is expected to inherit from `OperatorInfo`,
-       and contain a `Context` type relevant to the qFunctions.
-
-       @param[in] info is the structure describing the CeedOperator to assemble.
-       @param[in] fes is the finite element space.
-       @param[in] ir is the integration rule for the operator.
-       @param[in] nelem The number of elements.
-       @param[in] indices The indices of the elements of same type in the
-                          `FiniteElementSpace`. If `indices == nullptr`, assumes
-                          that the `FiniteElementSpace` is not mixed.
-       @param[in] Q is the coefficient from the `Integrator`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
-                 const mfem::FiniteElementSpace &fes,
-                 const mfem::IntegrationRule &ir,
-                 int nelem,
-                 const int* indices,
-                 CoeffType *Q)
-   {
-      Assemble(info, fes, fes, ir, nelem, indices, Q);
-   }
-
-   /** This method assembles the MFIntegrator for mixed forms.
-
-       @param[in] info the `CeedOperatorInfo` describing the `CeedOperator`,
-                       the `CeedOperatorInfo` type is expected to inherit from
-                       `OperatorInfo` and contain a `Context` type relevant to
-                       the qFunctions.
-       @param[in] trial_fes the trial `FiniteElementSpace` for the form,
-       @param[in] test_fes the test `FiniteElementSpace` for the form,
-       @param[in] ir the `IntegrationRule` for the numerical integration,
-       @param[in] Q `Coefficient` or `VectorCoefficient`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
+   Interpolator()
+      : oper(nullptr), oper_t(nullptr),
+        basis_ctof(nullptr),
+        trial_restr(nullptr), test_restr(nullptr),
+        apply_qfunc(nullptr), apply_qfunc_t(nullptr) {}
+
+   CeedOperator GetOperator() const { return oper; }
+   CeedOperator GetTransposeOperator() const { return oper_t; }
+
+   template <typename CeedOperatorInfo, typename CoeffType1, typename CoeffType2>
+   void Assemble(Ceed ceed,
+                 CeedOperatorInfo &info,
                  const mfem::FiniteElementSpace &trial_fes,
                  const mfem::FiniteElementSpace &test_fes,
                  const mfem::IntegrationRule &ir,
-                 CoeffType *Q)
+                 CoeffType1 *Q1,
+                 CoeffType2 *Q2,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
    {
-      Assemble(info, trial_fes, test_fes, ir, trial_fes.GetNE(), nullptr, Q);
+      Assemble(ceed, info, trial_fes, test_fes, ir,
+               use_bdr ? trial_fes.GetNBE() : trial_fes.GetNE(),
+               nullptr, Q1, Q2, use_bdr, use_mf);
    }
 
-   /** This method assembles the MFIntegrator for mixed forms.
+   /** This method assembles the `Interpolator` on mixed meshes. Its signature
+       matches that for `Integrator`.
 
-       @param[in] info the `CeedOperatorInfo` describing the `CeedOperator`,
+       @param[in] ceed The Ceed object.
+       @param[in] info The `CeedOperatorInfo` describing the `CeedOperator`,
                        the `CeedOperatorInfo` type is expected to inherit from
                        `OperatorInfo` and contain a `Context` type relevant to
-                       the qFunctions.
-       @param[in] trial_fes the trial `FiniteElementSpace` for the form,
-       @param[in] test_fes the test `FiniteElementSpace` for the form,
-       @param[in] ir the `IntegrationRule` for the numerical integration,
-       @param[in] nelem The number of elements,
+                       the QFunctions.
+       @param[in] trial_fes The trial `FiniteElementSpace` for the form.
+       @param[in] test_fes The test `FiniteElementSpace` for the form.
+       @param[in] ir Not supported by `Interpolator`.
+       @param[in] nelem The number of elements.
        @param[in] indices The indices of the elements of same type in the
                           `FiniteElementSpace`. If `indices == nullptr`, assumes
-                          that the `FiniteElementSpace` is not mixed,
-       @param[in] Q `Coefficient` or `VectorCoefficient`. */
-   template <typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(CeedOperatorInfo &info,
+                          that the `FiniteElementSpace` is not mixed.
+       @param[in] Q1 Not supported by `Interpolator`.
+       @param[in] Q2 Not supported by `Interpolator`.
+       @param[in] use_bdr Not supported by `Interpolator`.
+       @param[in] use_mf Controls whether to construct a matrix-free or
+                         partially assembled operator. */
+   template <typename CeedOperatorInfo, typename CoeffType1, typename CoeffType2>
+   void Assemble(Ceed ceed,
+                 CeedOperatorInfo &info,
                  const mfem::FiniteElementSpace &trial_fes,
                  const mfem::FiniteElementSpace &test_fes,
                  const mfem::IntegrationRule &ir,
                  int nelem,
-                 const int* indices,
-                 CoeffType *Q)
+                 const int *indices,
+                 CoeffType1 *Q1,
+                 CoeffType2 *Q2,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
    {
-      Ceed ceed(internal::ceed);
-      Mesh &mesh = *trial_fes.GetMesh();
-      MFEM_VERIFY(!(!indices && mesh.GetNumGeometries(mesh.Dimension()) > 1),
-                  "Use ceed::MixedIntegrator on mixed meshes.");
-      InitCoefficient(Q, mesh, ir, nelem, indices, coeff, info.ctx);
-      bool const_coeff = coeff->IsConstant();
-      std::string apply_func = const_coeff ? info.apply_func_mf_const
-                               : info.apply_func_mf_quad;
-      CeedQFunctionUser apply_qf = const_coeff ? info.apply_qf_mf_const
-                                   : info.apply_qf_mf_quad;
-      MFOperator op {info.header,
-                     apply_func, apply_qf,
-                     info.trial_op,
-                     info.test_op
-                    };
-
-      CeedInt dim = mesh.SpaceDimension();
       CeedInt trial_vdim = trial_fes.GetVDim();
       CeedInt test_vdim = test_fes.GetVDim();
-
-      mesh.EnsureNodes();
-      if ( &trial_fes == &test_fes )
-      {
-         InitBasisAndRestriction(trial_fes, ir, nelem, indices, ceed,
-                                 &trial_basis, &trial_restr);
-         test_basis = trial_basis;
-         test_restr = trial_restr;
-      }
-      else
-      {
-         InitBasisAndRestriction(trial_fes, ir, nelem, indices, ceed,
-                                 &trial_basis, &trial_restr);
-         InitBasisAndRestriction(test_fes, ir, nelem, indices, ceed,
-                                 &test_basis, &test_restr);
-      }
-
-      const mfem::FiniteElementSpace *mesh_fes = mesh.GetNodalFESpace();
-      MFEM_VERIFY(mesh_fes, "the Mesh has no nodal FE space");
-      InitBasisAndRestriction(*mesh_fes, ir, nelem, indices, ceed, &mesh_basis,
-                              &mesh_restr);
-
-      CeedInt trial_nqpts, test_nqpts;
-      CeedBasisGetNumQuadraturePoints(trial_basis, &trial_nqpts);
-      CeedBasisGetNumQuadraturePoints(trial_basis, &test_nqpts);
-      MFEM_VERIFY(trial_nqpts == test_nqpts,
-                  "Trial and test basis must have the same number of quadrature"
-                  " points.");
-      CeedInt nqpts = trial_nqpts;
-
-      InitVector(*mesh.GetNodes(), node_coords);
-
-      // Context data to be passed to the Q-function.
-      info.ctx.dim = mesh.Dimension();
-      info.ctx.space_dim = mesh.SpaceDimension();
-      info.ctx.vdim = trial_fes.GetVDim();
-
-      std::string qf_file = GetCeedPath() + op.header;
-      std::string qf = qf_file + op.apply_func;
-      CeedQFunctionCreateInterior(ceed, 1, op.apply_qf, qf.c_str(),
+      MFEM_VERIFY(!Q1 && !Q2, "ceed:Interpolator does not support coefficients.");
+      MFEM_VERIFY(!use_bdr,
+                  "ceed:Interpolator does not support boundary interpolators.");
+      MFEM_VERIFY(trial_vdim == 1 && test_vdim == 1,
+                  "ceed:Interpolator does not support spaces with vdim > 1.");
+
+      InitInterpolatorBasis(trial_fes, test_fes, indices, ceed, &basis_ctof);
+      InitRestriction(trial_fes, use_bdr, true, false, nelem, indices,
+                      ceed, &trial_restr);
+      InitRestriction(test_fes, use_bdr, true, true, nelem, indices,
+                      ceed, &test_restr);
+      MFEM_VERIFY(info.trial_op == EvalMode::Interp,
+                  "ceed:Interpolator only supports trial_op == Interp.");
+      MFEM_VERIFY(info.test_op == EvalMode::None,
+                  "ceed:Interpolator only supports test_op == None.");
+
+      // Create the QFunction that defines the action of the operator
+      // (only an identity as element dof multiplicity is handled outside of libCEED)
+      CeedQFunctionCreateIdentity(ceed, trial_vdim, CEED_EVAL_INTERP, CEED_EVAL_NONE,
                                   &apply_qfunc);
+      CeedQFunctionCreateIdentity(ceed, trial_vdim, CEED_EVAL_NONE, CEED_EVAL_INTERP,
+                                  &apply_qfunc_t);
 
-      // Create the Q-function that builds the operator (i.e. computes its
-      // quadrature data) and set its context data.
-      if (VariableCoefficient *var_coeff =
-             dynamic_cast<VariableCoefficient*>(coeff))
-      {
-         CeedQFunctionAddInput(apply_qfunc, "coeff", coeff->ncomp,
-                               var_coeff->emode);
-      }
-      // input
-      switch (op.trial_op)
-      {
-         case EvalMode::None:
-            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim,
-                                  CEED_EVAL_NONE);
-            break;
-         case EvalMode::Interp:
-            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim,
-                                  CEED_EVAL_INTERP);
-            break;
-         case EvalMode::Grad:
-            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim*dim,
-                                  CEED_EVAL_GRAD);
-            break;
-         case EvalMode::InterpAndGrad:
-            CeedQFunctionAddInput(apply_qfunc, "u", trial_vdim,
-                                  CEED_EVAL_INTERP);
-            CeedQFunctionAddInput(apply_qfunc, "gu", trial_vdim*dim,
-                                  CEED_EVAL_GRAD);
-            break;
-      }
-      CeedQFunctionAddInput(apply_qfunc, "dx", dim * dim, CEED_EVAL_GRAD);
-      CeedQFunctionAddInput(apply_qfunc, "weights", 1, CEED_EVAL_WEIGHT);
-      // output
-      switch (op.test_op)
-      {
-         case EvalMode::None:
-            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim,
-                                   CEED_EVAL_NONE);
-            break;
-         case EvalMode::Interp:
-            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim,
-                                   CEED_EVAL_INTERP);
-            break;
-         case EvalMode::Grad:
-            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim*dim,
-                                   CEED_EVAL_GRAD);
-            break;
-         case EvalMode::InterpAndGrad:
-            CeedQFunctionAddOutput(apply_qfunc, "v", test_vdim,
-                                   CEED_EVAL_INTERP);
-            CeedQFunctionAddOutput(apply_qfunc, "gv", test_vdim*dim,
-                                   CEED_EVAL_GRAD);
-            break;
-      }
-
-      CeedQFunctionContextCreate(ceed, &build_ctx);
-      CeedQFunctionContextSetData(build_ctx, CEED_MEM_HOST,
-                                  CEED_COPY_VALUES,
-                                  sizeof(info.ctx),
-                                  &info.ctx);
-      CeedQFunctionSetContext(apply_qfunc, build_ctx);
-
-      // Create the operator.
+      // Create the operator
       CeedOperatorCreate(ceed, apply_qfunc, NULL, NULL, &oper);
-      // coefficient
-      if (GridCoefficient *gridCoeff = dynamic_cast<GridCoefficient*>(coeff))
-      {
-         InitBasisAndRestriction(*gridCoeff->gf.FESpace(), ir, nelem, indices,
-                                 ceed, &gridCoeff->basis, &gridCoeff->restr);
-         CeedOperatorSetField(oper, "coeff", gridCoeff->restr,
-                              gridCoeff->basis, gridCoeff->coeffVector);
-      }
-      else if (QuadCoefficient *quadCoeff =
-                  dynamic_cast<QuadCoefficient*>(coeff))
-      {
-         const int ncomp = quadCoeff->ncomp;
-         CeedInt strides[3] = {ncomp, 1, ncomp*nqpts};
-         InitStridedRestriction(*mesh.GetNodalFESpace(),
-                                nelem, nqpts, ncomp, strides,
-                                &quadCoeff->restr);
-         CeedOperatorSetField(oper, "coeff", quadCoeff->restr,
-                              CEED_BASIS_COLLOCATED, quadCoeff->coeffVector);
-      }
-      // input
-      switch (op.trial_op)
-      {
-         case EvalMode::None:
-            CeedOperatorSetField(oper, "u", trial_restr,
-                                 CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::Interp:
-            CeedOperatorSetField(oper, "u", trial_restr, trial_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::Grad:
-            CeedOperatorSetField(oper, "gu", trial_restr, trial_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::InterpAndGrad:
-            CeedOperatorSetField(oper, "u", trial_restr, trial_basis,
-                                 CEED_VECTOR_ACTIVE);
-            CeedOperatorSetField(oper, "gu", trial_restr, trial_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-      }
-      CeedOperatorSetField(oper, "dx", mesh_restr,
-                           mesh_basis, node_coords);
-      CeedOperatorSetField(oper, "weights", CEED_ELEMRESTRICTION_NONE,
-                           mesh_basis, CEED_VECTOR_NONE);
-      // output
-      switch (op.test_op)
-      {
-         case EvalMode::None:
-            CeedOperatorSetField(oper, "v", test_restr,
-                                 CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::Interp:
-            CeedOperatorSetField(oper, "v", test_restr, test_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::Grad:
-            CeedOperatorSetField(oper, "gv", test_restr, test_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-         case EvalMode::InterpAndGrad:
-            CeedOperatorSetField(oper, "v", test_restr, test_basis,
-                                 CEED_VECTOR_ACTIVE);
-            CeedOperatorSetField(oper, "gv", test_restr, test_basis,
-                                 CEED_VECTOR_ACTIVE);
-            break;
-      }
-
-      CeedVectorCreate(ceed, trial_vdim*trial_fes.GetNDofs(), &u);
-      CeedVectorCreate(ceed, test_vdim*test_fes.GetNDofs(), &v);
+      CeedOperatorSetField(oper, "input", trial_restr, basis_ctof,
+                           CEED_VECTOR_ACTIVE);
+      CeedOperatorSetField(oper, "output", test_restr, CEED_BASIS_COLLOCATED,
+                           CEED_VECTOR_ACTIVE);
+      CeedOperatorCheckReady(oper);
+
+      // Create the transpose operator
+      CeedOperatorCreate(ceed, apply_qfunc_t, NULL, NULL, &oper_t);
+      CeedOperatorSetField(oper_t, "input", test_restr, CEED_BASIS_COLLOCATED,
+                           CEED_VECTOR_ACTIVE);
+      CeedOperatorSetField(oper_t, "output", trial_restr, basis_ctof,
+                           CEED_VECTOR_ACTIVE);
+      CeedOperatorCheckReady(oper_t);
    }
 
-   virtual ~MFIntegrator()
+   ~Interpolator()
    {
+      // All basis and restriction objects are destroyed by fes destructor
+      CeedOperatorDestroy(&oper);
+      CeedOperatorDestroy(&oper_t);
       CeedQFunctionDestroy(&apply_qfunc);
-      CeedQFunctionContextDestroy(&build_ctx);
-      CeedVectorDestroy(&node_coords);
-      CeedVectorDestroy(&qdata);
-      delete coeff;
+      CeedQFunctionDestroy(&apply_qfunc_t);
    }
-
-private:
-   /** This structure contains the data to assemble a matrix-free operator with
-       libCEED. */
-   struct MFOperator
-   {
-      /** The path to the header containing the functions for libCEED. */
-      std::string header;
-      /** The name of the Qfunction to apply the operator. */
-      std::string apply_func;
-      /** The Qfunction to apply the operator. */
-      CeedQFunctionUser apply_qf;
-      /** The evaluation mode to apply to the trial function (CEED_EVAL_INTERP,
-          CEED_EVAL_GRAD, etc.) */
-      EvalMode trial_op;
-      /** The evaluation mode to apply to the test function ( CEED_EVAL_INTERP,
-          CEED_EVAL_GRAD, etc.) */
-      EvalMode test_op;
-   };
 #endif
 };
 
@@ -774,4 +670,4 @@ private:
 
 } // namespace mfem
 
-#endif // MFEM_LIBCEED_INTEG
+#endif // MFEM_LIBCEED_INTEGRATOR
diff --git a/fem/ceed/interface/interface.hpp b/fem/ceed/interface/interface.hpp
index 0a69121ad..8b877188c 100644
--- a/fem/ceed/interface/interface.hpp
+++ b/fem/ceed/interface/interface.hpp
@@ -14,6 +14,8 @@
 
 // Object wrapping a CeedOperator in a mfem::Operator.
 #include "operator.hpp"
+// Operator supporting mixed finite element spaces.
+#include "mixed_operator.hpp"
 // Functions to initialize CeedBasis objects.
 #include "basis.hpp"
 // Functions to initialize CeedRestriction objects.
@@ -22,8 +24,6 @@
 #include "coefficient.hpp"
 // PA or MF Operator using libCEED.
 #include "integrator.hpp"
-// PA Operator supporting mixed finite element spaces.
-#include "mixed_integrator.hpp"
 // Utility functions
 #include "util.hpp"
 // Wrapper to include <ceed.h>
diff --git a/fem/ceed/interface/mixed_integrator.hpp b/fem/ceed/interface/mixed_integrator.hpp
deleted file mode 100644
index 8d344f4d9..000000000
--- a/fem/ceed/interface/mixed_integrator.hpp
+++ /dev/null
@@ -1,126 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-#ifndef MFEM_LIBCEED_MIXED_INTEGRATOR
-#define MFEM_LIBCEED_MIXED_INTEGRATOR
-
-#include "ceed.hpp"
-#include "integrator.hpp"
-#include <unordered_map>
-
-namespace mfem
-{
-
-namespace ceed
-{
-
-/** @brief This class wraps a `ceed::PAIntegrator` or `ceed::MFIntegrator` to
-    support mixed finite element spaces. */
-template <typename CeedInteg>
-class MixedIntegrator : public ceed::Operator
-{
-#ifdef MFEM_USE_CEED
-   using ElementKey = std::pair<int, int>; //< Element::Type, Order >
-   struct key_hash
-   {
-      std::size_t operator()(const ElementKey& k) const
-      {
-         return k.first + 2 * k.second;
-      }
-   };
-   using ElementsMap = std::unordered_map<const ElementKey, int*, key_hash>;
-   std::vector<CeedInteg*> sub_ops;
-
-public:
-   template <typename Integrator, typename CeedOperatorInfo, typename CoeffType>
-   void Assemble(const Integrator &integ,
-                 CeedOperatorInfo &info,
-                 const mfem::FiniteElementSpace &fes,
-                 CoeffType *Q)
-   {
-      ElementsMap count;
-      ElementsMap element_indices;
-      ElementsMap offsets;
-
-      // Count the number of elements of each type
-      for (int i = 0; i < fes.GetNE(); i++)
-      {
-         ElementKey key(fes.GetElementType(i), fes.GetElementOrder(i));
-         auto value = count.find(key);
-         if (value == count.end())
-         {
-            count[key] = new int(1);
-         }
-         else
-         {
-            (*value->second)++;
-         }
-      }
-
-      // Initialization of the arrays
-      for ( const auto& value : count )
-      {
-         element_indices[value.first] = new int[*value.second];
-         offsets[value.first] = new int(0);
-      }
-
-      // Populates the indices arrays for each element type
-      for (int i = 0; i < fes.GetNE(); i++)
-      {
-         ElementKey key(fes.GetElementType(i), fes.GetElementOrder(i));
-         int &offset = *(offsets[key]);
-         int* indices_array = element_indices[key];
-         indices_array[offset] = i;
-         offset++;
-      }
-
-      // Create composite CeedOperator
-      CeedCompositeOperatorCreate(internal::ceed, &oper);
-
-      // Create each sub-CeedOperator
-      sub_ops.reserve(element_indices.size());
-      for (const auto& value : element_indices)
-      {
-         const int* indices = value.second;
-         const int first_index = indices[0];
-         const mfem::FiniteElement &el = *fes.GetFE(first_index);
-         auto &T = *fes.GetMesh()->GetElementTransformation(first_index);
-         MFEM_ASSERT(!integ.GetIntegrationRule(),
-                     "Mixed mesh integrators should not have an"
-                     " IntegrationRule.");
-         const IntegrationRule &ir = GetRule(integ, el, el, T);
-         auto sub_op = new CeedInteg();
-         int nelem = *count[value.first];
-         sub_op->Assemble(info, fes, ir, nelem, indices, Q);
-         sub_ops.push_back(sub_op);
-         CeedCompositeOperatorAddSub(oper, sub_op->GetCeedOperator());
-      }
-
-      const int ndofs = fes.GetVDim() * fes.GetNDofs();
-      CeedVectorCreate(internal::ceed, ndofs, &u);
-      CeedVectorCreate(internal::ceed, ndofs, &v);
-   }
-
-   virtual ~MixedIntegrator()
-   {
-      for (auto sub_op : sub_ops)
-      {
-         delete sub_op;
-      }
-   }
-#endif
-};
-
-} // namespace ceed
-
-} // namespace mfem
-
-#endif // MFEM_LIBCEED_MIXED_INTEGRATOR
diff --git a/fem/ceed/interface/mixed_operator.hpp b/fem/ceed/interface/mixed_operator.hpp
new file mode 100644
index 000000000..51f3c3bf1
--- /dev/null
+++ b/fem/ceed/interface/mixed_operator.hpp
@@ -0,0 +1,295 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#ifndef MFEM_LIBCEED_MIXED_OPERATOR
+#define MFEM_LIBCEED_MIXED_OPERATOR
+
+#include "../../fespace.hpp"
+#include "operator.hpp"
+#include "util.hpp"
+#include "ceed.hpp"
+#include <array>
+#include <unordered_map>
+#include <vector>
+#ifdef MFEM_USE_OPENMP
+#include <omp.h>
+#endif
+
+namespace mfem
+{
+
+namespace ceed
+{
+
+/** @brief This class wraps one or more `OpType` objects to support finite
+    element spaces on mixed meshes. */
+template <typename OpType>
+class MixedOperator : public Operator
+{
+#ifdef MFEM_USE_CEED
+   using ElementKey =
+      std::array<int, 3>; // <mfem::Element::Type, TrialOrder, TestOrder>
+   struct ElementHash
+   {
+      std::size_t operator()(const ElementKey &k) const
+      {
+         return CeedHashCombine(
+                   CeedHashCombine(CeedHash(k[0]), CeedHash(k[1])),
+                   CeedHash(k[2]));
+      }
+   };
+#ifndef MFEM_USE_OPENMP
+   std::vector<OpType *> sub_ops;
+#else
+   std::vector<std::vector<OpType *>> sub_ops;
+#endif
+
+public:
+   template <typename IntegratorType, typename CeedOperatorInfo, typename CoeffType>
+   void Assemble(const IntegratorType &integ,
+                 CeedOperatorInfo &info,
+                 const mfem::FiniteElementSpace &fes,
+                 CoeffType *Q,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
+   {
+      Assemble(integ, info, fes, fes, Q, (mfem::Coefficient *)nullptr, use_bdr,
+               use_mf);
+   }
+
+   template <typename IntegratorType, typename CeedOperatorInfo,
+             typename CoeffType1, typename CoeffType2>
+   void Assemble(const IntegratorType &integ,
+                 CeedOperatorInfo &info,
+                 const mfem::FiniteElementSpace &fes,
+                 CoeffType1 *Q1,
+                 CoeffType2 *Q2,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
+   {
+      Assemble(integ, info, fes, fes, Q1, Q2, use_bdr, use_mf);
+   }
+
+   template <typename IntegratorType, typename CeedOperatorInfo, typename CoeffType>
+   void Assemble(const IntegratorType &integ,
+                 CeedOperatorInfo &info,
+                 const mfem::FiniteElementSpace &trial_fes,
+                 const mfem::FiniteElementSpace &test_fes,
+                 CoeffType *Q,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
+   {
+      Assemble(integ, info, trial_fes, test_fes, Q, (mfem::Coefficient *)nullptr,
+               use_bdr, use_mf);
+   }
+
+   template <typename IntegratorType, typename CeedOperatorInfo,
+             typename CoeffType1, typename CoeffType2>
+   void Assemble(const IntegratorType &integ,
+                 CeedOperatorInfo &info,
+                 const mfem::FiniteElementSpace &trial_fes,
+                 const mfem::FiniteElementSpace &test_fes,
+                 CoeffType1 *Q1,
+                 CoeffType2 *Q2,
+                 const bool use_bdr = false,
+                 const bool use_mf = false)
+   {
+      MFEM_VERIFY(trial_fes.GetMesh() == test_fes.GetMesh(),
+                  "Trial and test basis must correspond to the same Mesh.");
+      mfem::Mesh &mesh = *trial_fes.GetMesh();
+#ifndef MFEM_USE_OPENMP
+      const bool mixed =
+         mesh.GetNumGeometries(mesh.Dimension() - use_bdr) > 1 ||
+         trial_fes.IsVariableOrder() || test_fes.IsVariableOrder();
+      if (!mixed)
+      {
+         const mfem::FiniteElement &trial_fe = use_bdr ? *trial_fes.GetBE(0) :
+                                               *trial_fes.GetFE(0);
+         const mfem::FiniteElement &test_fe = use_bdr ? *test_fes.GetBE(0) :
+                                              *test_fes.GetFE(0);
+         auto &T = use_bdr ? *mesh.GetBdrElementTransformation(0) :
+                   *mesh.GetElementTransformation(0);
+         const mfem::IntegrationRule &ir =
+            integ.GetIntegrationRule() ? *integ.GetIntegrationRule() :
+            integ.GetRule(trial_fe, test_fe, T);
+         sub_ops.push_back(new OpType);
+         auto &sub_op = *sub_ops.back();
+         sub_op.Assemble(internal::ceed, info, trial_fes, test_fes, ir,
+                         Q1, Q2, use_bdr, use_mf);
+         CeedOperatorReferenceCopy(sub_op.GetOperator(), &oper);
+         if (sub_op.GetTransposeOperator())
+         {
+            CeedOperatorReferenceCopy(sub_op.GetTransposeOperator(), &oper_t);
+         }
+         CeedVectorCreate(internal::ceed,
+                          trial_fes.GetVDim() * trial_fes.GetNDofs(), &u);
+         CeedVectorCreate(internal::ceed,
+                          test_fes.GetVDim() * test_fes.GetNDofs(), &v);
+         return;
+      }
+#endif
+
+#ifdef MFEM_USE_OPENMP
+      #pragma omp parallel
+#endif
+      {
+         const int ne = use_bdr ? mesh.GetNBE() : mesh.GetNE();
+#ifdef MFEM_USE_OPENMP
+         const int nt = omp_get_num_threads();
+         #pragma omp master
+         {
+            thread_ops.resize(nt, nullptr);
+            thread_ops_t.resize(nt, nullptr);
+            thread_u.resize(nt, nullptr);
+            thread_v.resize(nt, nullptr);
+            sub_ops.resize(nt);
+         }
+         const int tid = omp_get_thread_num();
+         const int stride = (ne + nt - 1) / nt;
+         const int start = tid * stride;
+         const int stop = std::min(start + stride, ne);
+#else
+         const int start = 0;
+         const int stop = ne;
+#endif
+
+         // Count the number of elements of each type
+         std::unordered_map<ElementKey, int, ElementHash> counts, offsets;
+         std::unordered_map<ElementKey, std::vector<int>, ElementHash> element_indices;
+         for (int i = start; i < stop; i++)
+         {
+            const mfem::FiniteElement &trial_fe = use_bdr ? *trial_fes.GetBE(i) :
+                                                  *trial_fes.GetFE(i);
+            const mfem::FiniteElement &test_fe = use_bdr ? *test_fes.GetBE(i) :
+                                                 *test_fes.GetFE(i);
+            mfem::Element::Type type = use_bdr ? mesh.GetBdrElementType(i) :
+                                       mesh.GetElementType(i);
+            ElementKey key = {type, trial_fe.GetOrder(), test_fe.GetOrder()};
+            auto value = counts.find(key);
+            if (value == counts.end())
+            {
+               counts[key] = 1;
+            }
+            else
+            {
+               value->second++;
+            }
+         }
+
+         // Initialization of the arrays
+         for (const auto &value : counts)
+         {
+            offsets[value.first] = 0;
+            element_indices[value.first] = std::vector<int>(value.second);
+         }
+
+         // Populates the indices arrays for each element type
+         for (int i = start; i < stop; i++)
+         {
+            const mfem::FiniteElement &trial_fe = use_bdr ? *trial_fes.GetBE(i) :
+                                                  *trial_fes.GetFE(i);
+            const mfem::FiniteElement &test_fe = use_bdr ? *test_fes.GetBE(i) :
+                                                 *test_fes.GetFE(i);
+            mfem::Element::Type type = use_bdr ? mesh.GetBdrElementType(i) :
+                                       mesh.GetElementType(i);
+            ElementKey key = {type, trial_fe.GetOrder(), test_fe.GetOrder()};
+            int &offset = offsets[key];
+            std::vector<int> &indices = element_indices[key];
+            indices[offset++] = i;
+         }
+
+         // Create each sub-CeedOperator, some threads may be empty
+#ifdef MFEM_USE_OPENMP
+         #pragma omp barrier
+         CeedOperator &loc_oper = thread_ops[tid];
+         CeedOperator &loc_oper_t = thread_ops_t[tid];
+         CeedVector &loc_u = thread_u[tid];
+         CeedVector &loc_v = thread_v[tid];
+         std::vector<OpType *> &loc_sub_ops = sub_ops[tid];
+#else
+         CeedOperator &loc_oper = oper;
+         CeedOperator &loc_oper_t = oper_t;
+         CeedVector &loc_u = u;
+         CeedVector &loc_v = v;
+         std::vector<OpType *> &loc_sub_ops = sub_ops;
+#endif
+         if (element_indices.size() > 0)
+         {
+            loc_sub_ops.reserve(element_indices.size());
+            CeedCompositeOperatorCreate(internal::ceed, &loc_oper);
+            IsoparametricTransformation T;  // Thread-safe
+            for (const auto &value : element_indices)
+            {
+               const std::vector<int> &indices = value.second;
+               const int first_index = indices[0];
+               const mfem::FiniteElement &trial_fe =
+                  use_bdr ? *trial_fes.GetBE(first_index) : *trial_fes.GetFE(first_index);
+               const mfem::FiniteElement &test_fe =
+                  use_bdr ? *test_fes.GetBE(first_index) : *test_fes.GetFE(first_index);
+               if (use_bdr)
+               {
+                  mesh.GetBdrElementTransformation(first_index, &T);
+               }
+               else
+               {
+                  mesh.GetElementTransformation(first_index, &T);
+               }
+               MFEM_VERIFY(!integ.GetIntegrationRule(),
+                           "Mixed mesh integrators should not have an IntegrationRule.");
+               const IntegrationRule &ir = integ.GetRule(trial_fe, test_fe, T);
+               loc_sub_ops.push_back(new OpType);
+               auto &sub_op = *loc_sub_ops.back();
+               sub_op.Assemble(internal::ceed, info, trial_fes, test_fes, ir,
+                               static_cast<int>(indices.size()), indices.data(),
+                               Q1, Q2, use_bdr, use_mf);
+               CeedCompositeOperatorAddSub(loc_oper, sub_op.GetOperator());
+               if (sub_op.GetTransposeOperator())
+               {
+                  if (!loc_oper_t) { CeedCompositeOperatorCreate(internal::ceed, &loc_oper_t); }
+                  CeedCompositeOperatorAddSub(loc_oper_t, sub_op.GetTransposeOperator());
+               }
+            }
+            CeedOperatorCheckReady(loc_oper);
+            if (loc_oper_t) { CeedOperatorCheckReady(loc_oper_t); }
+            CeedVectorCreate(internal::ceed,
+                             trial_fes.GetVDim() * trial_fes.GetNDofs(), &loc_u);
+            CeedVectorCreate(internal::ceed,
+                             test_fes.GetVDim() * test_fes.GetNDofs(), &loc_v);
+         }
+      }
+   }
+
+   virtual ~MixedOperator()
+   {
+#ifndef MFEM_USE_OPENMP
+      for (auto *sub_op : sub_ops)
+      {
+         delete sub_op;
+      }
+#else
+      #pragma omp parallel
+      {
+         const int tid = omp_get_thread_num();
+         for (auto *sub_op : sub_ops[tid])
+         {
+            delete sub_op;
+         }
+      }
+#endif
+   }
+#endif
+};
+
+} // namespace ceed
+
+} // namespace mfem
+
+#endif // MFEM_LIBCEED_MIXED_OPERATOR
diff --git a/fem/ceed/interface/operator.cpp b/fem/ceed/interface/operator.cpp
index 8545ccaa8..05b5219b2 100644
--- a/fem/ceed/interface/operator.cpp
+++ b/fem/ceed/interface/operator.cpp
@@ -11,11 +11,12 @@
 
 #include "operator.hpp"
 
-#include "../../../config/config.hpp"
 #include "../../../linalg/vector.hpp"
 #include "../../fespace.hpp"
 #include "util.hpp"
-#include "ceed.hpp"
+#ifdef MFEM_USE_OPENMP
+#include <omp.h>
+#endif
 
 namespace mfem
 {
@@ -26,59 +27,100 @@ namespace ceed
 #ifdef MFEM_USE_CEED
 Operator::Operator(CeedOperator op)
 {
-   oper = op;
    CeedSize in_len, out_len;
-   int ierr = CeedOperatorGetActiveVectorLengths(oper, &in_len, &out_len);
+   int ierr = CeedOperatorGetActiveVectorLengths(op, &in_len, &out_len);
    PCeedChk(ierr);
-   height = out_len;
    width = in_len;
-   MFEM_VERIFY(height == out_len, "height overflow");
+   height = out_len;
    MFEM_VERIFY(width == in_len, "width overflow");
-   CeedVectorCreate(internal::ceed, height, &v);
+   MFEM_VERIFY(height == out_len, "height overflow");
+#ifndef MFEM_USE_OPENMP
+   oper = op;
+   oper_t = nullptr;
    CeedVectorCreate(internal::ceed, width, &u);
+   CeedVectorCreate(internal::ceed, height, &v);
+#else
+   thread_ops = {op};
+   thread_ops_t = {nullptr};
+   thread_u.resize(1);
+   thread_v.resize(1);
+   CeedVectorCreate(internal::ceed, width, &thread_u[0]);
+   CeedVectorCreate(internal::ceed, height, &thread_v[0]);
+#endif
 }
 #endif
 
-void Operator::Mult(const mfem::Vector &x, mfem::Vector &y) const
+Operator::~Operator()
 {
 #ifdef MFEM_USE_CEED
+#ifndef MFEM_USE_OPENMP
+   CeedOperatorDestroy(&oper);
+   CeedOperatorDestroy(&oper_t);
+   CeedVectorDestroy(&u);
+   CeedVectorDestroy(&v);
+#else
+   #pragma omp parallel
+   {
+      const int tid = omp_get_thread_num();
+      CeedOperatorDestroy(&thread_ops[tid]);
+      CeedOperatorDestroy(&thread_ops_t[tid]);
+      CeedVectorDestroy(&thread_u[tid]);
+      CeedVectorDestroy(&thread_v[tid]);
+   }
+#endif
+#endif
+}
+
+namespace
+{
+
+#ifdef MFEM_USE_CEED
+template <bool ADD>
+inline void CeedAddMult(CeedOperator oper, CeedVector u,
+                        CeedVector v, const mfem::Vector &x, mfem::Vector &y)
+{
+   if (!oper) { return; }  // No-op for an empty operator
    const CeedScalar *x_ptr;
    CeedScalar *y_ptr;
    CeedMemType mem;
-   CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   CeedGetPreferredMemType(internal::ceed, &mem);
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       x_ptr = x.Read();
-      y_ptr = y.Write();
+      y_ptr = (!ADD) ? y.Write() : y.ReadWrite();
    }
    else
    {
       x_ptr = x.HostRead();
-      y_ptr = y.HostWrite();
+      y_ptr = (!ADD) ? y.HostWrite() : y.HostReadWrite();
       mem = CEED_MEM_HOST;
    }
+
    CeedVectorSetArray(u, mem, CEED_USE_POINTER, const_cast<CeedScalar*>(x_ptr));
    CeedVectorSetArray(v, mem, CEED_USE_POINTER, y_ptr);
-
-   CeedOperatorApply(oper, u, v, CEED_REQUEST_IMMEDIATE);
-
+   if (!ADD)
+   {
+      CeedOperatorApply(oper, u, v, CEED_REQUEST_IMMEDIATE);
+   }
+   else
+   {
+      CeedOperatorApplyAdd(oper, u, v, CEED_REQUEST_IMMEDIATE);
+   }
    CeedVectorTakeArray(u, mem, const_cast<CeedScalar**>(&x_ptr));
    CeedVectorTakeArray(v, mem, &y_ptr);
-#else
-   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
-#endif
 }
 
-void Operator::AddMult(const mfem::Vector &x, mfem::Vector &y,
-                       const double a) const
+#ifdef MFEM_USE_OPENMP
+inline void CeedAddMult(const std::vector<CeedOperator> &ops,
+                        const std::vector<CeedVector> &u,
+                        const std::vector<CeedVector> &v,
+                        const mfem::Vector &x, mfem::Vector &y)
 {
-#ifdef MFEM_USE_CEED
-   MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    const CeedScalar *x_ptr;
    CeedScalar *y_ptr;
    CeedMemType mem;
-   CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   CeedGetPreferredMemType(internal::ceed, &mem);
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       x_ptr = x.Read();
       y_ptr = y.ReadWrite();
@@ -89,13 +131,80 @@ void Operator::AddMult(const mfem::Vector &x, mfem::Vector &y,
       y_ptr = y.HostReadWrite();
       mem = CEED_MEM_HOST;
    }
-   CeedVectorSetArray(u, mem, CEED_USE_POINTER, const_cast<CeedScalar*>(x_ptr));
-   CeedVectorSetArray(v, mem, CEED_USE_POINTER, y_ptr);
 
-   CeedOperatorApplyAdd(oper, u, v, CEED_REQUEST_IMMEDIATE);
+   #pragma omp parallel
+   {
+      const int tid = omp_get_thread_num();
+      if (ops[tid])  // No-op for an empty operator
+      {
+         CeedScalar *u_ptr = const_cast<CeedScalar *>(x_ptr);
+         CeedScalar *v_ptr = y_ptr;
+         CeedVectorSetArray(u[tid], mem, CEED_USE_POINTER, u_ptr);
+         CeedVectorSetArray(v[tid], mem, CEED_USE_POINTER, v_ptr);
+         CeedOperatorApplyAdd(ops[tid], u[tid], v[tid], CEED_REQUEST_IMMEDIATE);
+         CeedVectorTakeArray(u[tid], mem, &u_ptr);
+         CeedVectorTakeArray(v[tid], mem, &v_ptr);
+      }
+   }
+}
+#endif
+#endif
+
+} // namespace
 
-   CeedVectorTakeArray(u, mem, const_cast<CeedScalar**>(&x_ptr));
-   CeedVectorTakeArray(v, mem, &y_ptr);
+void Operator::Mult(const mfem::Vector &x, mfem::Vector &y) const
+{
+#ifdef MFEM_USE_CEED
+#ifndef MFEM_USE_OPENMP
+   CeedAddMult<false>(oper, u, v, x, y);
+#else
+   y = 0.0;
+   CeedAddMult(thread_ops, thread_u, thread_v, x, y);
+#endif
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+void Operator::AddMult(const mfem::Vector &x, mfem::Vector &y,
+                       const double a) const
+{
+#ifdef MFEM_USE_CEED
+   MFEM_ASSERT(a == 1.0, "General coefficient case is not yet supported");
+#ifndef MFEM_USE_OPENMP
+   CeedAddMult<true>(oper, u, v, x, y);
+#else
+   CeedAddMult(thread_ops, thread_u, thread_v, x, y);
+#endif
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+void Operator::MultTranspose(const mfem::Vector &x, mfem::Vector &y) const
+{
+#ifdef MFEM_USE_CEED
+#ifndef MFEM_USE_OPENMP
+   CeedAddMult<false>(oper_t, v, u, x, y);
+#else
+   y = 0.0;
+   CeedAddMult(thread_ops_t, thread_v, thread_u, x, y);
+#endif
+#else
+   MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
+#endif
+}
+
+void Operator::AddMultTranspose(const mfem::Vector &x, mfem::Vector &y,
+                                const double a) const
+{
+#ifdef MFEM_USE_CEED
+   MFEM_ASSERT(a == 1.0, "General coefficient case is not yet supported");
+#ifndef MFEM_USE_OPENMP
+   CeedAddMult<true>(oper_t, v, u, x, y);
+#else
+   CeedAddMult(thread_ops_t, thread_v, thread_u, x, y);
+#endif
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
@@ -106,8 +215,8 @@ void Operator::GetDiagonal(mfem::Vector &diag) const
 #ifdef MFEM_USE_CEED
    CeedScalar *d_ptr;
    CeedMemType mem;
-   CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   CeedGetPreferredMemType(internal::ceed, &mem);
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       d_ptr = diag.ReadWrite();
    }
@@ -116,11 +225,25 @@ void Operator::GetDiagonal(mfem::Vector &diag) const
       d_ptr = diag.HostReadWrite();
       mem = CEED_MEM_HOST;
    }
-   CeedVectorSetArray(v, mem, CEED_USE_POINTER, d_ptr);
 
+#ifndef MFEM_USE_OPENMP
+   CeedVectorSetArray(v, mem, CEED_USE_POINTER, d_ptr);
    CeedOperatorLinearAssembleAddDiagonal(oper, v, CEED_REQUEST_IMMEDIATE);
-
    CeedVectorTakeArray(v, mem, &d_ptr);
+#else
+   #pragma omp parallel
+   {
+      const int tid = omp_get_thread_num();
+      if (thread_ops[tid])  // No-op for an empty operator
+      {
+         CeedScalar *v_ptr = d_ptr;
+         CeedVectorSetArray(thread_v[tid], mem, CEED_USE_POINTER, v_ptr);
+         CeedOperatorLinearAssembleAddDiagonal(thread_ops[tid], thread_v[tid],
+                                               CEED_REQUEST_IMMEDIATE);
+         CeedVectorTakeArray(thread_v[tid], mem, &v_ptr);
+      }
+   }
+#endif
 #else
    MFEM_ABORT("MFEM must be built with MFEM_USE_CEED=YES to use libCEED.");
 #endif
diff --git a/fem/ceed/interface/operator.hpp b/fem/ceed/interface/operator.hpp
index cffea2fc7..4901236e9 100644
--- a/fem/ceed/interface/operator.hpp
+++ b/fem/ceed/interface/operator.hpp
@@ -14,6 +14,9 @@
 
 #include "../../../linalg/operator.hpp"
 #include "ceed.hpp"
+#ifdef MFEM_USE_OPENMP
+#include <vector>
+#endif
 
 namespace mfem
 {
@@ -26,34 +29,51 @@ class Operator : public mfem::Operator
 {
 protected:
 #ifdef MFEM_USE_CEED
-   CeedOperator oper;
+#ifndef MFEM_USE_OPENMP
+   CeedOperator oper, oper_t;
    CeedVector u, v;
+#else
+   std::vector<CeedOperator> thread_ops, thread_ops_t;
+   std::vector<CeedVector> thread_u, thread_v;
+#endif
 
-   Operator() : oper(nullptr), u(nullptr), v(nullptr) { }
+#ifndef MFEM_USE_OPENMP
+   Operator() : oper(nullptr), oper_t(nullptr), u(nullptr), v(nullptr) {}
+#else
+   Operator() {}
+#endif
 #endif
 
 public:
 #ifdef MFEM_USE_CEED
-   /// This class takes ownership of op and will delete it
+   /// This constructor takes ownership of the operator and will delete it
    Operator(CeedOperator op);
+
+   operator CeedOperator() const
+   {
+#ifndef MFEM_USE_OPENMP
+      return oper;
+#else
+      MFEM_VERIFY(thread_ops.size() == 1,
+                  "Threaded ceed:Operator should access CeedOperators by thread index");
+      return thread_ops[0];
+#endif
+   }
+#ifdef MFEM_USE_OPENMP
+   CeedOperator operator[](std::size_t i) const { return thread_ops[i]; }
+   std::size_t Size() const { return thread_ops.size(); }
+#endif
 #endif
+
    void Mult(const mfem::Vector &x, mfem::Vector &y) const override;
    void AddMult(const mfem::Vector &x, mfem::Vector &y,
                 const double a = 1.0) const override;
+   void MultTranspose(const mfem::Vector &x, mfem::Vector &y) const override;
+   void AddMultTranspose(const mfem::Vector &x, mfem::Vector &y,
+                         const double a = 1.0) const override;
    void GetDiagonal(mfem::Vector &diag) const;
-   using mfem::Operator::SetupRAP;
-   virtual ~Operator()
-   {
-#ifdef MFEM_USE_CEED
-      CeedOperatorDestroy(&oper);
-      CeedVectorDestroy(&u);
-      CeedVectorDestroy(&v);
-#endif
-   }
 
-#ifdef MFEM_USE_CEED
-   CeedOperator& GetCeedOperator() { return oper; }
-#endif
+   virtual ~Operator();
 };
 
 } // namespace ceed
diff --git a/fem/ceed/interface/restriction.cpp b/fem/ceed/interface/restriction.cpp
index e7e8539bd..8f17a7fbe 100644
--- a/fem/ceed/interface/restriction.cpp
+++ b/fem/ceed/interface/restriction.cpp
@@ -9,8 +9,10 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#include "../../../fem/gridfunc.hpp"
-#include "ceed.hpp"
+#include "restriction.hpp"
+
+#include "util.hpp"
+#include <cstdint>
 
 namespace mfem
 {
@@ -20,248 +22,381 @@ namespace ceed
 
 #ifdef MFEM_USE_CEED
 
-static void InitNativeRestr(const mfem::FiniteElementSpace &fes,
-                            Ceed ceed, CeedElemRestriction *restr)
+static void InitLexicoRestr(const mfem::FiniteElementSpace &fes,
+                            bool use_bdr,
+                            int nelem,
+                            Ceed ceed,
+                            CeedElemRestriction *restr)
 {
-   const mfem::FiniteElement *fe = fes.GetFE(0);
-   const int P = fe->GetDof();
-   CeedInt compstride = fes.GetOrdering()==Ordering::byVDIM ? 1 : fes.GetNDofs();
-   const mfem::Table &el_dof = fes.GetElementToDofTable();
+   const mfem::FiniteElement &fe = use_bdr ? *fes.GetBE(0) : *fes.GetFE(0);
+   const int P = fe.GetDof();
+   const mfem::TensorBasisElement *tfe =
+      dynamic_cast<const mfem::TensorBasisElement *>(&fe);
+   const mfem::Array<int> &dof_map = tfe->GetDofMap();
+   CeedInt compstride =
+      (fes.GetOrdering() == Ordering::byVDIM) ? 1 : fes.GetNDofs();
+   const int stride = (compstride == 1) ? fes.GetVDim() : 1;
+   const mfem::Table &el_dof = use_bdr ? fes.GetBdrElementToDofTable() :
+                               fes.GetElementToDofTable();
+   const int *el_map = el_dof.GetJ();
    mfem::Array<int> tp_el_dof(el_dof.Size_of_connections());
-   const mfem::TensorBasisElement * tfe =
-      dynamic_cast<const mfem::TensorBasisElement *>(fe);
-   const int stride = compstride == 1 ? fes.GetVDim() : 1;
-   const mfem::Array<int>& dof_map = tfe->GetDofMap();
+   mfem::Array<bool> tp_el_orients(el_dof.Size_of_connections());
+   bool use_el_orients = false;
 
-   for (int i = 0; i < fes.GetNE(); i++)
+   for (int i = 0; i < nelem; i++)
    {
-      const int el_offset = P * i;
+      // No need to handle DofTransformation for tensor-product elements
       for (int j = 0; j < P; j++)
       {
-         tp_el_dof[j+el_offset] = stride*el_dof.GetJ()[dof_map[j]+el_offset];
+         const int sdid = dof_map[j];  // signed
+         const int did = (sdid >= 0) ? sdid : -1 - sdid;
+         const int sgid = el_map[did + P * i];  // signed
+         const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+         tp_el_dof[j + P * i] = stride * gid;
+         tp_el_orients[j + P * i] =
+            (sgid >= 0 && sdid < 0) || (sgid < 0 && sdid >= 0);
+         use_el_orients = use_el_orients || tp_el_orients[j + P * i];
       }
    }
 
-   CeedElemRestrictionCreate(ceed, fes.GetNE(), P, fes.GetVDim(),
-                             compstride, (fes.GetVDim())*(fes.GetNDofs()),
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
+   if (use_el_orients)
+   {
+      CeedElemRestrictionCreateOriented(ceed, nelem, P, fes.GetVDim(),
+                                        compstride, fes.GetVDim() * fes.GetNDofs(),
+                                        CEED_MEM_HOST, CEED_COPY_VALUES,
+                                        tp_el_dof.GetData(), tp_el_orients.GetData(),
+                                        restr);
+   }
+   else
+   {
+      CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
+                                compstride, fes.GetVDim() * fes.GetNDofs(),
+                                CEED_MEM_HOST, CEED_COPY_VALUES,
+                                tp_el_dof.GetData(), restr);
+   }
 }
 
-static void InitLexicoRestr(const mfem::FiniteElementSpace &fes,
-                            Ceed ceed, CeedElemRestriction *restr)
+static void InitNativeRestr(const mfem::FiniteElementSpace &fes,
+                            bool use_bdr,
+                            int nelem,
+                            Ceed ceed,
+                            CeedElemRestriction *restr)
 {
-   const mfem::FiniteElement *fe = fes.GetFE(0);
-   const int P = fe->GetDof();
-   CeedInt compstride = fes.GetOrdering()==Ordering::byVDIM ? 1 : fes.GetNDofs();
-   const mfem::Table &el_dof = fes.GetElementToDofTable();
+   const mfem::FiniteElement &fe = use_bdr ? *fes.GetBE(0) : *fes.GetFE(0);
+   const int P = fe.GetDof();
+   CeedInt compstride =
+      (fes.GetOrdering() == Ordering::byVDIM) ? 1 : fes.GetNDofs();
+   const int stride = (compstride == 1) ? fes.GetVDim() : 1;
+   const mfem::Table &el_dof = use_bdr ? fes.GetBdrElementToDofTable() :
+                               fes.GetElementToDofTable();
+   const int *el_map = el_dof.GetJ();
    mfem::Array<int> tp_el_dof(el_dof.Size_of_connections());
-   const int stride = compstride == 1 ? fes.GetVDim() : 1;
+   mfem::Array<bool> tp_el_orients(el_dof.Size_of_connections());
+   bool use_el_orients = false;
 
-   for (int e = 0; e < fes.GetNE(); e++)
+   for (int i = 0; i < nelem; i++)
    {
-      for (int i = 0; i < P; i++)
+      // DofTransformation support uses InitNativeRestrWithIndices
+      for (int j = 0; j < P; j++)
       {
-         tp_el_dof[i + e*P] = stride*el_dof.GetJ()[i + e*P];
+         const int sgid = el_map[j + P * i];  // signed
+         const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+         tp_el_dof[j + P * i] = stride * gid;
+         tp_el_orients[j + P * i] = (sgid < 0);
+         use_el_orients = use_el_orients || tp_el_orients[j + P * i];
       }
    }
 
-   CeedElemRestrictionCreate(ceed, fes.GetNE(), P, fes.GetVDim(),
-                             compstride, (fes.GetVDim())*(fes.GetNDofs()),
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
-}
-
-static void InitRestrictionImpl(const mfem::FiniteElementSpace &fes,
-                                Ceed ceed, CeedElemRestriction *restr)
-{
-   const mfem::FiniteElement *fe = fes.GetFE(0);
-   const mfem::TensorBasisElement * tfe =
-      dynamic_cast<const mfem::TensorBasisElement *>(fe);
-   if ( tfe && tfe->GetDofMap().Size()>0 ) // Native ordering using dof_map
+   if (use_el_orients)
    {
-      InitNativeRestr(fes, ceed, restr);
+      CeedElemRestrictionCreateOriented(ceed, nelem, P, fes.GetVDim(),
+                                        compstride, fes.GetVDim() * fes.GetNDofs(),
+                                        CEED_MEM_HOST, CEED_COPY_VALUES,
+                                        tp_el_dof.GetData(), tp_el_orients.GetData(),
+                                        restr);
    }
-   else  // Lexicographic ordering
+   else
    {
-      InitLexicoRestr(fes, ceed, restr);
+      CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
+                                compstride, fes.GetVDim() * fes.GetNDofs(),
+                                CEED_MEM_HOST, CEED_COPY_VALUES,
+                                tp_el_dof.GetData(), restr);
    }
 }
 
-static void InitNativeRestrWithIndices(
-   const mfem::FiniteElementSpace &fes,
-   int nelem,
-   const int* indices,
-   Ceed ceed, CeedElemRestriction *restr)
+static void InitLexicoRestrWithIndices(const mfem::FiniteElementSpace &fes,
+                                       bool use_bdr,
+                                       int nelem,
+                                       const int *indices,
+                                       Ceed ceed,
+                                       CeedElemRestriction *restr)
 {
-   const mfem::FiniteElement *fe = fes.GetFE(indices[0]);
-   const int P = fe->GetDof();
-   CeedInt compstride = fes.GetOrdering()==Ordering::byVDIM ? 1 : fes.GetNDofs();
-   mfem::Array<int> tp_el_dof(nelem*P);
-   const mfem::TensorBasisElement * tfe =
-      dynamic_cast<const mfem::TensorBasisElement *>(fe);
-   Array<int> dofs;
-   const int stride = compstride == 1 ? fes.GetVDim() : 1;
-   const mfem::Array<int>& dof_map = tfe->GetDofMap();
+   const int first_index = indices ? indices[0] : 0;
+   const mfem::FiniteElement &fe = use_bdr ? *fes.GetBE(first_index) :
+                                   *fes.GetFE(first_index);
+   const int P = fe.GetDof();
+   const mfem::TensorBasisElement *tfe =
+      dynamic_cast<const mfem::TensorBasisElement *>(&fe);
+   const mfem::Array<int> &dof_map = tfe->GetDofMap();
+   CeedInt compstride =
+      (fes.GetOrdering() == Ordering::byVDIM) ? 1 : fes.GetNDofs();
+   const int stride = (compstride == 1) ? fes.GetVDim() : 1;
+   mfem::Array<int> tp_el_dof(nelem * P), dofs;
+   mfem::Array<bool> tp_el_orients(nelem * P);
+   bool use_el_orients = false;
+   mfem::DofTransformation dof_trans;
 
    for (int i = 0; i < nelem; i++)
    {
+      // No need to handle DofTransformation for tensor-product elements
       const int elem_index = indices[i];
-      fes.GetElementDofs(elem_index, dofs);
-      const int el_offset = P * i;
-      for (int j = 0; j < P; j++)
+      if (use_bdr)
       {
-         tp_el_dof[j + el_offset] = stride*dofs[dof_map[j]];
+         fes.GetBdrElementDofs(elem_index, dofs, dof_trans);
       }
-   }
-
-   CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
-                             compstride, (fes.GetVDim())*(fes.GetNDofs()),
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
-}
-
-static void InitLexicoRestrWithIndices(
-   const mfem::FiniteElementSpace &fes,
-   int nelem,
-   const int* indices,
-   Ceed ceed, CeedElemRestriction *restr)
-{
-   const mfem::FiniteElement *fe = fes.GetFE(indices[0]);
-   const int P = fe->GetDof();
-   CeedInt compstride = fes.GetOrdering()==Ordering::byVDIM ? 1 : fes.GetNDofs();
-   mfem::Array<int> tp_el_dof(nelem*P);
-   Array<int> dofs;
-   const int stride = compstride == 1 ? fes.GetVDim() : 1;
-
-   for (int i = 0; i < nelem; i++)
-   {
-      const int elem_index = indices[i];
-      fes.GetElementDofs(elem_index, dofs);
-      const int el_offset = P * i;
+      else
+      {
+         fes.GetElementDofs(elem_index, dofs, dof_trans);
+      }
+      MFEM_VERIFY(!dof_trans.GetDofTransformation(),
+                  "Unexpected DofTransformation for lexicographic element "
+                  "restriction.");
       for (int j = 0; j < P; j++)
       {
-         tp_el_dof[j + el_offset] = stride*dofs[j];
+         const int sdid = dof_map[j];  // signed
+         const int did = (sdid >= 0) ? sdid : -1 - sdid;
+         const int sgid = dofs[did];  // signed
+         const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+         tp_el_dof[j + P * i] = stride * gid;
+         tp_el_orients[j + P * i] =
+            (sgid >= 0 && sdid < 0) || (sgid < 0 && sdid >= 0);
+         use_el_orients = use_el_orients || tp_el_orients[j + P * i];
       }
    }
 
-   CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
-                             compstride, (fes.GetVDim())*(fes.GetNDofs()),
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
+   if (use_el_orients)
+   {
+      CeedElemRestrictionCreateOriented(ceed, nelem, P, fes.GetVDim(),
+                                        compstride, fes.GetVDim() * fes.GetNDofs(),
+                                        CEED_MEM_HOST, CEED_COPY_VALUES,
+                                        tp_el_dof.GetData(), tp_el_orients.GetData(),
+                                        restr);
+   }
+   else
+   {
+      CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
+                                compstride, fes.GetVDim() * fes.GetNDofs(),
+                                CEED_MEM_HOST, CEED_COPY_VALUES,
+                                tp_el_dof.GetData(), restr);
+   }
 }
 
-static void InitRestrictionWithIndicesImpl(
-   const mfem::FiniteElementSpace &fes,
-   int nelem,
-   const int* indices,
-   Ceed ceed, CeedElemRestriction *restr)
+static void InitNativeRestrWithIndices(const mfem::FiniteElementSpace &fes,
+                                       bool use_bdr,
+                                       bool has_dof_trans,
+                                       bool is_interp_range,
+                                       int nelem,
+                                       const int *indices,
+                                       Ceed ceed,
+                                       CeedElemRestriction *restr)
 {
-   const mfem::FiniteElement *fe = fes.GetFE(indices[0]);
-   const mfem::TensorBasisElement * tfe =
-      dynamic_cast<const mfem::TensorBasisElement *>(fe);
-   if ( tfe && tfe->GetDofMap().Size()>0 ) // Native ordering using dof_map
+   const int first_index = indices ? indices[0] : 0;
+   const mfem::FiniteElement &fe = use_bdr ? *fes.GetBE(first_index) :
+                                   *fes.GetFE(first_index);
+   const int P = fe.GetDof();
+   CeedInt compstride =
+      (fes.GetOrdering() == Ordering::byVDIM) ? 1 : fes.GetNDofs();
+   const int stride = (compstride == 1) ? fes.GetVDim() : 1;
+   mfem::Array<int> tp_el_dof(nelem * P), dofs;
+   mfem::Array<bool> tp_el_orients;
+   mfem::Array<int8_t> tp_el_curl_orients;
+   bool use_el_orients = false;
+   mfem::DofTransformation dof_trans;
+   mfem::Vector el_trans_j;
+   if (!has_dof_trans)
    {
-      InitNativeRestrWithIndices(fes, nelem, indices, ceed, restr);
+      tp_el_orients.SetSize(nelem * P);
    }
-   else  // Lexicographic ordering
+   else
    {
-      InitLexicoRestrWithIndices(fes, nelem, indices, ceed, restr);
+      tp_el_curl_orients.SetSize(nelem * P * 3, 0);
+      el_trans_j.SetSize(P);
    }
-}
 
-static void InitCoeffRestrictionWithIndicesImpl(
-   const mfem::FiniteElementSpace &fes,
-   int nelem,
-   const int* indices,
-   int nquads,
-   int ncomp,
-   Ceed ceed,
-   CeedElemRestriction *restr)
-{
-   mfem::Array<int> tp_el_dof(nelem*nquads);
-   const int stride_quad = ncomp;
-   const int stride_elem = ncomp*nquads;
-   // TODO generalize to support different #quads
    for (int i = 0; i < nelem; i++)
    {
-      const int elem_index = indices[i];
-      const int el_offset = elem_index * stride_elem;
-      for (int j = 0; j < nquads; j++)
+      const int elem_index = indices ? indices[i] : i;
+      if (use_bdr)
+      {
+         fes.GetBdrElementDofs(elem_index, dofs, dof_trans);
+      }
+      else
+      {
+         fes.GetElementDofs(elem_index, dofs, dof_trans);
+      }
+      if (!has_dof_trans)
       {
-         tp_el_dof[j + nquads * i] = j * stride_quad + el_offset;
+         for (int j = 0; j < P; j++)
+         {
+            const int sgid = dofs[j];  // signed
+            const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+            tp_el_dof[j + P * i] = stride * gid;
+            tp_el_orients[j + P * i] = (sgid < 0);
+            use_el_orients = use_el_orients || tp_el_orients[j + P * i];
+         }
+      }
+      else
+      {
+         for (int j = 0; j < P; j++)
+         {
+            const int sgid = dofs[j];  // signed
+            const int gid = (sgid >= 0) ? sgid : -1 - sgid;
+            tp_el_dof[j + P * i] = stride * gid;
+
+            // Fill column j of element tridiagonal matrix tp_el_curl_orients
+            el_trans_j = 0.0;
+            el_trans_j(j) = 1.0;
+            if (is_interp_range)
+            {
+               dof_trans.InvTransformDual(el_trans_j);
+            }
+            else
+            {
+               dof_trans.InvTransformPrimal(el_trans_j);
+            }
+            double sign_j = (sgid < 0) ? -1.0 : 1.0;
+            tp_el_curl_orients[3 * (j + 0 + P * i) + 1] =
+               static_cast<int8_t>(sign_j * el_trans_j(j + 0));
+            if (j > 0)
+            {
+               tp_el_curl_orients[3 * (j - 1 + P * i) + 2] =
+                  static_cast<int8_t>(sign_j * el_trans_j(j - 1));
+            }
+            if (j < P - 1)
+            {
+               tp_el_curl_orients[3 * (j + 1 + P * i) + 0] =
+                  static_cast<int8_t>(sign_j * el_trans_j(j + 1));
+            }
+#ifdef MFEM_DEBUG
+            int nnz = 0;
+            for (int k = 0; k < P; k++)
+            {
+               if (k < j - 1 && k > j + 1 && el_trans_j(k) != 0.0) { nnz++; }
+            }
+            MFEM_ASSERT(nnz == 0,
+                        "Element transformation matrix is not tridiagonal at column "
+                        << j << " (nnz = " << nnz << ")!");
+#endif
+         }
       }
    }
-   CeedElemRestrictionCreate(ceed, nelem, nquads, ncomp, 1,
-                             ncomp*fes.GetNE()*nquads,
-                             CEED_MEM_HOST, CEED_COPY_VALUES,
-                             tp_el_dof.GetData(), restr);
-}
 
-void InitStridedRestriction(const mfem::FiniteElementSpace &fes,
-                            CeedInt nelem, CeedInt nqpts, CeedInt qdatasize,
-                            const CeedInt *strides,
-                            CeedElemRestriction *restr)
-{
-   RestrKey restr_key(&fes, nelem, nqpts, qdatasize, restr_type::Strided);
-   auto restr_itr = mfem::internal::ceed_restr_map.find(restr_key);
-   if (restr_itr == mfem::internal::ceed_restr_map.end())
+   if (tp_el_curl_orients.Size())
    {
-      CeedElemRestrictionCreateStrided(mfem::internal::ceed, nelem, nqpts, qdatasize,
-                                       nelem*nqpts*qdatasize,
-                                       strides,
-                                       restr);
-      // Will be automatically destroyed when @a fes gets destroyed.
-      mfem::internal::ceed_restr_map[restr_key] = *restr;
+      CeedElemRestrictionCreateCurlOriented(ceed, nelem, P, fes.GetVDim(),
+                                            compstride, fes.GetVDim() * fes.GetNDofs(),
+                                            CEED_MEM_HOST, CEED_COPY_VALUES,
+                                            tp_el_dof.GetData(), tp_el_curl_orients.GetData(),
+                                            restr);
+   }
+   else if (use_el_orients)
+   {
+      CeedElemRestrictionCreateOriented(ceed, nelem, P, fes.GetVDim(),
+                                        compstride, fes.GetVDim() * fes.GetNDofs(),
+                                        CEED_MEM_HOST, CEED_COPY_VALUES,
+                                        tp_el_dof.GetData(), tp_el_orients.GetData(),
+                                        restr);
    }
    else
    {
-      *restr = restr_itr->second;
+      CeedElemRestrictionCreate(ceed, nelem, P, fes.GetVDim(),
+                                compstride, fes.GetVDim() * fes.GetNDofs(),
+                                CEED_MEM_HOST, CEED_COPY_VALUES,
+                                tp_el_dof.GetData(), restr);
    }
 }
 
 void InitRestriction(const FiniteElementSpace &fes,
+                     bool use_bdr,
+                     bool is_interp,
+                     bool is_range,
+                     int nelem,
+                     const int *indices,
                      Ceed ceed,
                      CeedElemRestriction *restr)
 {
-   // Check for FES -> basis, restriction in hash tables
-   const mfem::FiniteElement *fe = fes.GetFE(0);
-   const int P = fe->GetDof();
-   const int nelem = fes.GetNE();
+   // Check for fes -> restriction in hash table
+   // {-1, -1, -1} is unique from CEED_STRIDES_BACKEND for strided restrictions
+   // The restriction for an interpolator range space is slightly different as
+   // the output is a primal vector instead of a dual vector, and lexicographic
+   // ordering is never used (no use of tensor-product basis)
+   const int first_index = indices ? indices[0] : 0;
+   const mfem::FiniteElement &fe = use_bdr ? *fes.GetBE(first_index) :
+                                   *fes.GetFE(first_index);
+   const int P = fe.GetDof();
    const int ncomp = fes.GetVDim();
-   RestrKey restr_key(&fes, nelem, P, ncomp, restr_type::Standard);
-   auto restr_itr = mfem::internal::ceed_restr_map.find(restr_key);
-
-   // Init or retrieve key values
-   if (restr_itr == mfem::internal::ceed_restr_map.end())
+   const mfem::TensorBasisElement *tfe =
+      dynamic_cast<const mfem::TensorBasisElement *>(&fe);
+   const bool vector = fe.GetRangeType() == mfem::FiniteElement::VECTOR;
+   const bool lexico =
+      (tfe && tfe->GetDofMap().Size() > 0 && !vector && !is_interp);
+   mfem::Array<int> dofs;
+   mfem::DofTransformation dof_trans;
+   if (use_bdr)
    {
-      InitRestrictionImpl(fes, ceed, restr);
-      mfem::internal::ceed_restr_map[restr_key] = *restr;
+      fes.GetBdrElementDofs(first_index, dofs, dof_trans);
    }
    else
    {
-      *restr = restr_itr->second;
+      fes.GetElementDofs(first_index, dofs, dof_trans);
    }
-}
-
-void InitRestrictionWithIndices(const FiniteElementSpace &fes,
-                                int nelem,
-                                const int* indices,
-                                Ceed ceed,
-                                CeedElemRestriction *restr)
-{
-   // Check for FES -> basis, restriction in hash tables
-   const mfem::FiniteElement *fe = fes.GetFE(indices[0]);
-   const int P = fe->GetDof();
-   const int ncomp = fes.GetVDim();
-   RestrKey restr_key(&fes, nelem, P, ncomp, restr_type::Standard);
-   auto restr_itr = mfem::internal::ceed_restr_map.find(restr_key);
+   const bool has_dof_trans = dof_trans.GetDofTransformation() &&
+                              !dof_trans.IsEmpty();
+   const bool unique_range_restr = (is_interp && is_range && has_dof_trans);
+   RestrKey restr_key(&fes, {nelem, P, ncomp, unique_range_restr}, {-1, -1, -1});
 
    // Init or retrieve key values
-   if (restr_itr == mfem::internal::ceed_restr_map.end())
+   auto restr_itr = internal::ceed_restr_map.find(restr_key);
+   if (restr_itr == internal::ceed_restr_map.end())
    {
-      InitRestrictionWithIndicesImpl(fes, nelem, indices, ceed, restr);
-      mfem::internal::ceed_restr_map[restr_key] = *restr;
+      if (indices)
+      {
+         if (lexico)
+         {
+            // Lexicographic ordering using dof_map
+            InitLexicoRestrWithIndices(fes, use_bdr, nelem, indices,
+                                       ceed, restr);
+         }
+         else
+         {
+            // Native ordering
+            InitNativeRestrWithIndices(fes, use_bdr, has_dof_trans, is_interp && is_range,
+                                       nelem, indices, ceed, restr);
+         }
+      }
+      else
+      {
+         if (lexico)
+         {
+            // Lexicographic ordering using dof_map
+            MFEM_VERIFY(!has_dof_trans,
+                        "Unexpected DofTransformation for lexicographic element "
+                        "restriction.");
+            InitLexicoRestr(fes, use_bdr, nelem, ceed, restr);
+         }
+         else if (!has_dof_trans)
+         {
+            // Native ordering without dof_trans
+            InitNativeRestr(fes, use_bdr, nelem, ceed, restr);
+         }
+         else
+         {
+            // Native ordering with dof_trans
+            InitNativeRestrWithIndices(fes, use_bdr, has_dof_trans, is_interp && is_range,
+                                       nelem, nullptr, ceed, restr);
+         }
+      }
+      internal::ceed_restr_map[restr_key] = *restr;
    }
    else
    {
@@ -269,24 +404,26 @@ void InitRestrictionWithIndices(const FiniteElementSpace &fes,
    }
 }
 
-void InitCoeffRestrictionWithIndices(const FiniteElementSpace &fes,
-                                     int nelem,
-                                     const int* indices,
-                                     int nquads,
-                                     int ncomp,
-                                     Ceed ceed,
-                                     CeedElemRestriction *restr)
+void InitStridedRestriction(const mfem::FiniteElementSpace &fes,
+                            CeedInt nelem,
+                            CeedInt nqpts,
+                            CeedInt qdatasize,
+                            const CeedInt strides[3],
+                            Ceed ceed,
+                            CeedElemRestriction *restr)
 {
-   // Check for FES -> basis, restriction in hash tables
-   RestrKey restr_key(&fes, nelem, nquads, ncomp, restr_type::Coeff);
-   auto restr_itr = mfem::internal::ceed_restr_map.find(restr_key);
+   // Check for fes -> restriction in hash table
+   RestrKey restr_key(&fes, {nelem, nqpts, qdatasize, 0},
+   {strides[0], strides[1], strides[2]});
 
    // Init or retrieve key values
-   if (restr_itr == mfem::internal::ceed_restr_map.end())
+   auto restr_itr = internal::ceed_restr_map.find(restr_key);
+   if (restr_itr == internal::ceed_restr_map.end())
    {
-      InitCoeffRestrictionWithIndicesImpl(fes, nelem, indices, nquads, ncomp,
-                                          ceed, restr);
-      mfem::internal::ceed_restr_map[restr_key] = *restr;
+      CeedElemRestrictionCreateStrided(ceed, nelem, nqpts, qdatasize,
+                                       nelem * nqpts * qdatasize, strides,
+                                       restr);
+      internal::ceed_restr_map[restr_key] = *restr;
    }
    else
    {
diff --git a/fem/ceed/interface/restriction.hpp b/fem/ceed/interface/restriction.hpp
index 221716b39..9b88e8e48 100644
--- a/fem/ceed/interface/restriction.hpp
+++ b/fem/ceed/interface/restriction.hpp
@@ -12,6 +12,7 @@
 #ifndef MFEM_LIBCEED_RESTR
 #define MFEM_LIBCEED_RESTR
 
+#include "../../fespace.hpp"
 #include "ceed.hpp"
 
 namespace mfem
@@ -21,65 +22,70 @@ namespace ceed
 {
 
 #ifdef MFEM_USE_CEED
-/** @brief Initialize a CeedElemRestriction for non-mixed meshes.
 
-    @param[in] fes Input finite element space.
-    @param[in] ceed Input Ceed object.
-    @param[out] restr The address of the initialized CeedElemRestriction object.
-*/
-void InitRestriction(const FiniteElementSpace &fes,
-                     Ceed ceed,
-                     CeedElemRestriction *restr);
-
-/** @brief Initialize a CeedElemRestriction for mixed meshes.
+/** @brief Initialize a CeedElemRestriction based on an
+    mfem::FiniteElementSpace @a fes and an optional list of @a nelem elements
+    of indices @a indices.
 
     @param[in] fes The finite element space.
-    @param[in] ceed The Ceed object.
+    @param[in] use_bdr Create the restriction for boundary elements.
+    @param[in] is_interp Create the restriction for an interpolation operator
+                         (sometimes requires special treatment).
+    @param[in] is_range Create the restriction for the range space of an
+                        operator (sometimes requires special treatment).
     @param[in] nelem The number of elements.
     @param[in] indices The indices of the elements of same type in the
-                       `FiniteElementSpace`.
+                       `FiniteElementSpace`. If `indices == nullptr`, assumes
+                       that the `FiniteElementSpace` is not mixed.
+    @param[in] ceed The Ceed object.
     @param[out] restr The `CeedElemRestriction` to initialize. */
-void InitRestrictionWithIndices(const FiniteElementSpace &fes,
-                                int nelem,
-                                const int* indices,
-                                Ceed ceed,
-                                CeedElemRestriction *restr);
+void InitRestriction(const FiniteElementSpace &fes,
+                     bool use_bdr,
+                     bool is_interp,
+                     bool is_range,
+                     int nelem,
+                     const int *indices,
+                     Ceed ceed,
+                     CeedElemRestriction *restr);
+
+inline void InitRestriction(const FiniteElementSpace &fes,
+                            bool use_bdr,
+                            int nelem,
+                            const int *indices,
+                            Ceed ceed,
+                            CeedElemRestriction *restr)
+{
+   InitRestriction(fes, use_bdr, false, false, nelem, indices, ceed, restr);
+}
+
+inline void InitRestriction(const FiniteElementSpace &fes,
+                            Ceed ceed,
+                            CeedElemRestriction *restr)
+{
+   InitRestriction(fes, false, false, false, fes.GetNE(), nullptr, ceed, restr);
+}
 
-/** @brief Initialize a strided CeedElemRestriction
+/** @brief Initialize a strided CeedElemRestriction.
 
     @param[in] fes Input finite element space.
     @param[in] nelem is the number of elements.
     @param[in] nqpts is the total number of quadrature points.
     @param[in] qdatasize is the number of data per quadrature point.
     @param[in] strides Array for strides between [nodes, components, elements].
-    Data for node i, component j, element k can be found in the L-vector at
-    index i*strides[0] + j*strides[1] + k*strides[2]. CEED_STRIDES_BACKEND may
-    be used with vectors created by a Ceed backend.
+                       Data for node i, component j, element k can be found in
+                       the L-vector at index i*strides[0] + j*strides[1] +
+                       k*strides[2]. CEED_STRIDES_BACKEND may be used with
+                       vectors created by a Ceed backend.
+    @param[in] ceed The Ceed object.
     @param[out] restr The `CeedElemRestriction` to initialize. */
 void InitStridedRestriction(const mfem::FiniteElementSpace &fes,
-                            CeedInt nelem, CeedInt nqpts, CeedInt qdatasize,
-                            const CeedInt *strides,
+                            CeedInt nelem,
+                            CeedInt nqpts,
+                            CeedInt qdatasize,
+                            const CeedInt strides[3],
+                            Ceed ceed,
                             CeedElemRestriction *restr);
 
-/** @brief Initialize a CeedElemRestriction for a mfem::Coefficient on a mixed
-    mesh.
-
-    @param[in] fes The finite element space.
-    @param[in] nelem is the number of elements.
-    @param[in] indices The indices of the elements of same type in the
-                       `FiniteElementSpace`.
-    @param[in] nquads is the total number of quadrature points
-    @param[in] ncomp is the number of data per quadrature point
-    @param[in] ceed The Ceed object.
-    @param[out] restr The `CeedElemRestriction` to initialize. */
-void InitCoeffRestrictionWithIndices(const FiniteElementSpace &fes,
-                                     int nelem,
-                                     const int* indices,
-                                     int nquads,
-                                     int ncomp,
-                                     Ceed ceed,
-                                     CeedElemRestriction *restr);
-
 #endif
 
 } // namespace ceed
diff --git a/fem/ceed/interface/util.cpp b/fem/ceed/interface/util.cpp
index b65fd2197..970df6a3a 100644
--- a/fem/ceed/interface/util.cpp
+++ b/fem/ceed/interface/util.cpp
@@ -9,14 +9,11 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
+#include "util.hpp"
+
 #include "../../../general/device.hpp"
-#include "../../../fem/gridfunc.hpp"
 #include "../../../linalg/dtensor.hpp"
-
-#include "basis.hpp"
-#include "restriction.hpp"
-#include "ceed.hpp"
-
+#include "../../gridfunc.hpp"
 #include <sys/types.h>
 #include <sys/stat.h>
 #if !defined(_WIN32) || !defined(_MSC_VER)
@@ -41,30 +38,35 @@ namespace ceed
 void RemoveBasisAndRestriction(const mfem::FiniteElementSpace *fes)
 {
 #ifdef MFEM_USE_CEED
-   auto itb = mfem::internal::ceed_basis_map.begin();
-   while (itb != mfem::internal::ceed_basis_map.end())
-   {
-      if (std::get<0>(itb->first)==fes)
-      {
-         CeedBasisDestroy(&itb->second);
-         itb = mfem::internal::ceed_basis_map.erase(itb);
-      }
-      else
-      {
-         itb++;
-      }
-   }
-   auto itr = mfem::internal::ceed_restr_map.begin();
-   while (itr != mfem::internal::ceed_restr_map.end())
+#ifdef MFEM_USE_OPENMP
+   #pragma omp parallel
+#endif
    {
-      if (std::get<0>(itr->first)==fes)
+      auto itb = internal::ceed_basis_map.begin();
+      while (itb != internal::ceed_basis_map.end())
       {
-         CeedElemRestrictionDestroy(&itr->second);
-         itr = mfem::internal::ceed_restr_map.erase(itr);
+         if (std::get<0>(itb->first) == fes)
+         {
+            CeedBasisDestroy(&itb->second);
+            itb = internal::ceed_basis_map.erase(itb);
+         }
+         else
+         {
+            itb++;
+         }
       }
-      else
+      auto itr = internal::ceed_restr_map.begin();
+      while (itr != internal::ceed_restr_map.end())
       {
-         itr++;
+         if (std::get<0>(itr->first) == fes)
+         {
+            CeedElemRestrictionDestroy(&itr->second);
+            itr = internal::ceed_restr_map.erase(itr);
+         }
+         else
+         {
+            itr++;
+         }
       }
    }
 #endif
@@ -72,84 +74,47 @@ void RemoveBasisAndRestriction(const mfem::FiniteElementSpace *fes)
 
 #ifdef MFEM_USE_CEED
 
-void InitVector(const mfem::Vector &v, CeedVector &cv)
+void InitVector(const mfem::Vector &v, Ceed ceed, CeedVector &cv)
 {
-   CeedVectorCreate(mfem::internal::ceed, v.Size(), &cv);
+   CeedVectorCreate(ceed, v.Size(), &cv);
    CeedScalar *cv_ptr;
    CeedMemType mem;
-   CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   CeedGetPreferredMemType(ceed, &mem);
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
-      cv_ptr = const_cast<CeedScalar*>(v.Read());
+      cv_ptr = const_cast<CeedScalar *>(v.Read());
    }
    else
    {
-      cv_ptr = const_cast<CeedScalar*>(v.HostRead());
+      cv_ptr = const_cast<CeedScalar *>(v.HostRead());
       mem = CEED_MEM_HOST;
    }
    CeedVectorSetArray(cv, mem, CEED_USE_POINTER, cv_ptr);
 }
 
-void InitBasisAndRestriction(const FiniteElementSpace &fes,
-                             const IntegrationRule &irm,
-                             Ceed ceed, CeedBasis *basis,
-                             CeedElemRestriction *restr)
-{
-   InitBasis(fes, irm, ceed, basis);
-   InitRestriction(fes, ceed, restr);
-}
-
-void InitBasisAndRestrictionWithIndices(const FiniteElementSpace &fes,
-                                        const IntegrationRule &irm,
-                                        int nelem,
-                                        const int* indices,
-                                        Ceed ceed, CeedBasis *basis,
-                                        CeedElemRestriction *restr)
-{
-   InitBasisWithIndices(fes, irm, nelem, indices, ceed, basis);
-   InitRestrictionWithIndices(fes, nelem, indices, ceed, restr);
-}
-
-void InitBasisAndRestriction(const FiniteElementSpace &fes,
-                             const IntegrationRule &irm,
-                             int nelem,
-                             const int* indices,
-                             Ceed ceed, CeedBasis *basis,
-                             CeedElemRestriction *restr)
-{
-   if (indices)
-   {
-      InitBasisAndRestrictionWithIndices(fes,irm,nelem,indices,ceed,basis,restr);
-   }
-   else
-   {
-      InitBasisAndRestriction(fes,irm,ceed,basis,restr);
-   }
-}
-
 // Assumes a tensor-product operator with one active field
 int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field)
 {
    int ierr;
    Ceed ceed;
-   ierr = CeedOperatorGetCeed(oper, &ceed); CeedChk(ierr);
+   ierr = CeedOperatorGetCeed(oper, &ceed); PCeedChk(ierr);
 
    CeedQFunction qf;
    bool isComposite;
-   ierr = CeedOperatorIsComposite(oper, &isComposite); CeedChk(ierr);
+   ierr = CeedOperatorIsComposite(oper, &isComposite); PCeedChk(ierr);
    CeedOperator *subops;
    if (isComposite)
    {
 #if CEED_VERSION_GE(0, 10, 2)
-      ierr = CeedCompositeOperatorGetSubList(oper, &subops); CeedChk(ierr);
+      ierr = CeedCompositeOperatorGetSubList(oper, &subops); PCeedChk(ierr);
 #else
-      ierr = CeedOperatorGetSubList(oper, &subops); CeedChk(ierr);
+      ierr = CeedOperatorGetSubList(oper, &subops); PCeedChk(ierr);
 #endif
-      ierr = CeedOperatorGetQFunction(subops[0], &qf); CeedChk(ierr);
+      ierr = CeedOperatorGetQFunction(subops[0], &qf); PCeedChk(ierr);
    }
    else
    {
-      ierr = CeedOperatorGetQFunction(oper, &qf); CeedChk(ierr);
+      ierr = CeedOperatorGetQFunction(oper, &qf); PCeedChk(ierr);
    }
    CeedInt numinputfields, numoutputfields;
    ierr = CeedQFunctionGetNumArgs(qf, &numinputfields, &numoutputfields);
@@ -157,12 +122,12 @@ int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field)
    if (isComposite)
    {
       ierr = CeedOperatorGetFields(subops[0], &numinputfields, &inputfields,
-                                   &numoutputfields, NULL); CeedChk(ierr);
+                                   &numoutputfields, NULL); PCeedChk(ierr);
    }
    else
    {
       ierr = CeedOperatorGetFields(oper, &numinputfields, &inputfields,
-                                   &numoutputfields, NULL); CeedChk(ierr);
+                                   &numoutputfields, NULL); PCeedChk(ierr);
    }
 
    CeedVector if_vector;
@@ -170,7 +135,7 @@ int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field)
    int found_index = -1;
    for (int i = 0; i < numinputfields; ++i)
    {
-      ierr = CeedOperatorFieldGetVector(inputfields[i], &if_vector); CeedChk(ierr);
+      ierr = CeedOperatorFieldGetVector(inputfields[i], &if_vector); PCeedChk(ierr);
       if (if_vector == CEED_VECTOR_ACTIVE)
       {
          if (found)
@@ -190,66 +155,6 @@ int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field)
    return 0;
 }
 
-template <>
-const IntegrationRule & GetRule<MassIntegrator>(
-   const MassIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return MassIntegrator::GetRule(trial_fe, test_fe, trans);
-}
-
-template <>
-const IntegrationRule & GetRule<VectorMassIntegrator>(
-   const VectorMassIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return MassIntegrator::GetRule(trial_fe, test_fe, trans);
-}
-
-template <>
-const IntegrationRule & GetRule<ConvectionIntegrator>(
-   const ConvectionIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return ConvectionIntegrator::GetRule(trial_fe, trans);
-}
-
-template <>
-const IntegrationRule & GetRule<VectorConvectionNLFIntegrator>(
-   const VectorConvectionNLFIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return VectorConvectionNLFIntegrator::GetRule(trial_fe, trans);
-}
-
-template <>
-const IntegrationRule & GetRule<DiffusionIntegrator>(
-   const DiffusionIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return DiffusionIntegrator::GetRule(trial_fe, test_fe);
-}
-
-template <>
-const IntegrationRule & GetRule<VectorDiffusionIntegrator>(
-   const VectorDiffusionIntegrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &trans)
-{
-   return DiffusionIntegrator::GetRule(trial_fe, test_fe);
-}
-
 std::string ceed_path;
 
 const std::string &GetCeedPath()
diff --git a/fem/ceed/interface/util.hpp b/fem/ceed/interface/util.hpp
index 674186a87..cffe365b1 100644
--- a/fem/ceed/interface/util.hpp
+++ b/fem/ceed/interface/util.hpp
@@ -12,16 +12,16 @@
 #ifndef MFEM_LIBCEED_UTIL
 #define MFEM_LIBCEED_UTIL
 
-#include "../../../config/config.hpp"
-#include <functional>
-#include <string>
-#include <tuple>
-#include <unordered_map>
-
+#include "../../../general/error.hpp"
 #include "ceed.hpp"
 #ifdef MFEM_USE_CEED
-#include <ceed/backend.h>  // for CeedOperatorField
+#include <ceed/backend.h>
 #endif
+#include <array>
+#include <functional>
+#include <tuple>
+#include <unordered_map>
+#include <string>
 
 namespace mfem
 {
@@ -40,7 +40,7 @@ namespace ceed
 {
 
 /** @brief Remove from ceed_basis_map and ceed_restr_map the entries associated
-    with the given @a fes. */
+    with the given @a fes when @a fes gets destroyed. */
 void RemoveBasisAndRestriction(const mfem::FiniteElementSpace *fes);
 
 #ifdef MFEM_USE_CEED
@@ -48,61 +48,18 @@ void RemoveBasisAndRestriction(const mfem::FiniteElementSpace *fes);
 #define PCeedChk(err) do {                                                     \
      if ((err))                                                                \
      {                                                                         \
-        const char * errmsg;                                                   \
+        const char *errmsg;                                                    \
         CeedGetErrorMessage(internal::ceed, &errmsg);                          \
         MFEM_ABORT(errmsg);                                                    \
      }                                                                         \
   } while(0);
 
 /// Initialize a CeedVector from an mfem::Vector
-void InitVector(const mfem::Vector &v, CeedVector &cv);
-
-/** @brief Initialize a CeedBasis and a CeedElemRestriction based on an
-    mfem::FiniteElementSpace @a fes, and an mfem::IntegrationRule @a ir.
-
-    @param[in] fes The finite element space.
-    @param[in] ir The integration rule.
-    @param[in] ceed The Ceed object.
-    @param[out] basis The `CeedBasis` to initialize.
-    @param[out] restr The `CeedElemRestriction` to initialize.
-
-    @warning Only for non-mixed finite element spaces. */
-void InitBasisAndRestriction(const mfem::FiniteElementSpace &fes,
-                             const mfem::IntegrationRule &ir,
-                             Ceed ceed, CeedBasis *basis,
-                             CeedElemRestriction *restr);
-
-/** @brief Initialize a CeedBasis and a CeedElemRestriction based on an
-    mfem::FiniteElementSpace @a fes, and an mfem::IntegrationRule @a ir,
-    and a list of @a nelem elements of indices @a indices.
-
-    @param[in] fes The finite element space.
-    @param[in] ir The integration rule.
-    @param[in] nelem The number of elements.
-    @param[in] indices The indices of the elements of same type in the
-                       `FiniteElementSpace`. If `indices == nullptr`, assumes
-                       that the `FiniteElementSpace` is not mixed.
-    @param[in] ceed The Ceed object.
-    @param[out] basis The `CeedBasis` to initialize.
-    @param[out] restr The `CeedElemRestriction` to initialize. */
-void InitBasisAndRestriction(const FiniteElementSpace &fes,
-                             const IntegrationRule &ir,
-                             int nelem,
-                             const int* indices,
-                             Ceed ceed, CeedBasis *basis,
-                             CeedElemRestriction *restr);
+void InitVector(const mfem::Vector &v, Ceed ceed, CeedVector &cv);
 
 int CeedOperatorGetActiveField(CeedOperator oper, CeedOperatorField *field);
 
-
-template <typename Integrator>
-const IntegrationRule & GetRule(
-   const Integrator &integ,
-   const FiniteElement &trial_fe,
-   const FiniteElement &test_fe,
-   ElementTransformation &Trans);
-
-/// Return the path to the libCEED q-function headers.
+/// Return the path to the libCEED QFunction headers.
 const std::string &GetCeedPath();
 
 /// Wrapper for std::hash.
@@ -121,42 +78,47 @@ inline std::size_t CeedHashCombine(std::size_t seed, std::size_t hash)
 }
 
 // Hash table for CeedBasis
-using BasisKey = std::tuple<const mfem::FiniteElementSpace*,
-      const mfem::IntegrationRule*,
-      int, int, int>;
+using BasisKey =
+   std::tuple<const mfem::FiniteElementSpace *, const mfem::FiniteElementSpace *,
+   const mfem::IntegrationRule *, std::array<int, 3>>;
 struct BasisHash
 {
-   std::size_t operator()(const BasisKey& k) const
+   std::size_t operator()(const BasisKey &k) const
    {
       return CeedHashCombine(
                 CeedHashCombine(
-                   CeedHash(std::get<0>(k)),
-                   CeedHash(std::get<1>(k))),
+                   CeedHashCombine(
+                      CeedHash(std::get<0>(k)),
+                      CeedHash(std::get<1>(k))),
+                   CeedHash(std::get<2>(k))),
                 CeedHashCombine(
-                   CeedHashCombine(CeedHash(std::get<2>(k)),
-                                   CeedHash(std::get<3>(k))),
-                   CeedHash(std::get<4>(k))));
+                   CeedHashCombine(CeedHash(std::get<3>(k)[0]),
+                                   CeedHash(std::get<3>(k)[1])),
+                   CeedHash(std::get<3>(k)[2])));
    }
 };
 using BasisMap = std::unordered_map<const BasisKey, CeedBasis, BasisHash>;
 
-enum restr_type {Standard, Strided, Coeff};
-
 // Hash table for CeedElemRestriction
 using RestrKey =
-   std::tuple<const mfem::FiniteElementSpace*, int, int, int, int>;
+   std::tuple<const mfem::FiniteElementSpace *, std::array<int, 4>,
+   std::array<int, 3>>;
 struct RestrHash
 {
-   std::size_t operator()(const RestrKey& k) const
+   std::size_t operator()(const RestrKey &k) const
    {
       return CeedHashCombine(
+                CeedHash(std::get<0>(k)),
                 CeedHashCombine(
                    CeedHashCombine(
-                      CeedHash(std::get<0>(k)),
-                      CeedHash(std::get<1>(k))),
-                   CeedHashCombine(CeedHash(std::get<2>(k)),
-                                   CeedHash(std::get<3>(k)))),
-                CeedHash(std::get<4>(k)));
+                      CeedHashCombine(CeedHash(std::get<1>(k)[0]),
+                                      CeedHash(std::get<1>(k)[1])),
+                      CeedHashCombine(CeedHash(std::get<1>(k)[2]),
+                                      CeedHash(std::get<1>(k)[3]))),
+                   CeedHashCombine(
+                      CeedHashCombine(CeedHash(std::get<2>(k)[0]),
+                                      CeedHash(std::get<2>(k)[1])),
+                      CeedHash(std::get<2>(k)[2]))));
    }
 };
 using RestrMap =
@@ -171,9 +133,15 @@ namespace internal
 
 #ifdef MFEM_USE_CEED
 /** @warning These maps have a tendency to create bugs when adding new "types"
-    of CeedBasis and CeedElemRestriction. */
+    of CeedBasis and CeedElemRestriction. Definitions in general/device.cpp. */
 extern ceed::BasisMap ceed_basis_map;
+#ifdef MFEM_USE_OPENMP
+#pragma omp threadprivate(ceed_basis_map)
+#endif
 extern ceed::RestrMap ceed_restr_map;
+#ifdef MFEM_USE_OPENMP
+#pragma omp threadprivate(ceed_restr_map)
+#endif
 #endif
 
 } // namespace internal
diff --git a/fem/ceed/solvers/algebraic.cpp b/fem/ceed/solvers/algebraic.cpp
index 2cc325dbc..03e14de2d 100644
--- a/fem/ceed/solvers/algebraic.cpp
+++ b/fem/ceed/solvers/algebraic.cpp
@@ -11,14 +11,19 @@
 
 #include "algebraic.hpp"
 
+#include "../../../general/forall.hpp"
 #include "../../bilinearform.hpp"
 #include "../../fespace.hpp"
 #include "../../pfespace.hpp"
-#include "../../../general/forall.hpp"
-#include "solvers-atpmg.hpp"
-#include "full-assembly.hpp"
 #include "../interface/restriction.hpp"
-#include "../interface/ceed.hpp"
+#include "../interface/util.hpp"
+#include "solvers-atpmg.hpp"
+#ifdef MFEM_USE_CEED
+#include <ceed/backend.h>
+#endif
+#ifdef MFEM_USE_OPENMP
+#include <omp.h>
+#endif
 
 namespace mfem
 {
@@ -28,44 +33,50 @@ namespace ceed
 
 #ifdef MFEM_USE_CEED
 
+int CeedInternalFree(void *p)
+{
+   free(*(void **)p);
+   *(void **)p = NULL;
+   return 0;
+}
+
 /** Wraps a CeedOperator in an mfem::Operator, with essential boundary
     conditions and a prolongation operator for parallel application. */
 class ConstrainedOperator : public mfem::Operator
 {
 public:
    /// This object takes ownership of oper and will delete it
-   ConstrainedOperator(CeedOperator oper, const Array<int> &ess_tdofs_,
-                       const mfem::Operator *P_);
-   ConstrainedOperator(CeedOperator oper, const mfem::Operator *P_);
+   ConstrainedOperator(CeedOperator oper, const Array<int> &ess_tdofs,
+                       const mfem::Operator *P);
+   ConstrainedOperator(CeedOperator oper, const mfem::Operator *P);
    ~ConstrainedOperator();
-   void Mult(const Vector& x, Vector& y) const;
-   CeedOperator GetCeedOperator() const;
+
    const Array<int> &GetEssentialTrueDofs() const;
    const mfem::Operator *GetProlongation() const;
+   operator CeedOperator() const { return (CeedOperator)*unconstrained_op; }
+   void Mult(const Vector& x, Vector& y) const;
+
 private:
    Array<int> ess_tdofs;
    const mfem::Operator *P;
    ceed::Operator *unconstrained_op;
-   mfem::ConstrainedOperator *constrained_op;
+   mfem::Operator *constrained_op;
 };
 
-ConstrainedOperator::ConstrainedOperator(
-   CeedOperator oper,
-   const Array<int> &ess_tdofs_,
-   const mfem::Operator *P_)
-   : ess_tdofs(ess_tdofs_), P(P_)
+ConstrainedOperator::ConstrainedOperator(CeedOperator oper,
+                                         const Array<int> &ess_tdofs,
+                                         const mfem::Operator *P)
+   : ess_tdofs(ess_tdofs), P(P)
 {
    unconstrained_op = new ceed::Operator(oper);
-   mfem::Operator *rap = unconstrained_op->SetupRAP(P, P);
-   height = width = rap->Height();
-   bool own_rap = (rap != unconstrained_op);
-   constrained_op = new mfem::ConstrainedOperator(rap, ess_tdofs, own_rap);
+   unconstrained_op->FormSystemOperator(ess_tdofs, constrained_op);
+   height = width = constrained_op->Height();
 }
 
 ConstrainedOperator::ConstrainedOperator(CeedOperator oper,
-                                         const mfem::Operator *P_)
-   : ConstrainedOperator(oper, Array<int>(), P_)
-{ }
+                                         const mfem::Operator *P)
+   : ConstrainedOperator(oper, Array<int>(), P)
+{}
 
 ConstrainedOperator::~ConstrainedOperator()
 {
@@ -78,11 +89,6 @@ void ConstrainedOperator::Mult(const Vector& x, Vector& y) const
    constrained_op->Mult(x, y);
 }
 
-CeedOperator ConstrainedOperator::GetCeedOperator() const
-{
-   return unconstrained_op->GetCeedOperator();
-}
-
 const Array<int> &ConstrainedOperator::GetEssentialTrueDofs() const
 {
    return ess_tdofs;
@@ -93,29 +99,21 @@ const mfem::Operator *ConstrainedOperator::GetProlongation() const
    return P;
 }
 
-/// assumes a square operator (you could do rectangular, you'd have
-/// to find separate active input and output fields/restrictions)
-int CeedOperatorGetSize(CeedOperator oper, CeedInt * size)
-{
-   CeedSize in_len, out_len;
-   int ierr = CeedOperatorGetActiveVectorLengths(oper, &in_len, &out_len);
-   CeedChk(ierr);
-   *size = (CeedInt)in_len;
-   MFEM_VERIFY(in_len == out_len, "not a square CeedOperator");
-   MFEM_VERIFY(in_len == *size, "size overflow");
-   return 0;
-}
-
 Solver *BuildSmootherFromCeed(ConstrainedOperator &op, bool chebyshev)
 {
    int ierr;
-   CeedOperator ceed_op = op.GetCeedOperator();
+
    const Array<int> &ess_tdofs = op.GetEssentialTrueDofs();
    const mfem::Operator *P = op.GetProlongation();
+
    // Assemble the a local diagonal, in the sense of L-vector
    CeedVector diagceed;
-   CeedInt length;
-   ierr = CeedOperatorGetSize(ceed_op, &length); PCeedChk(ierr);
+   CeedSize l_in, l_out;
+   ierr = CeedOperatorGetActiveVectorLengths(op, &l_in, &l_out);
+   PCeedChk(ierr);
+   MFEM_VERIFY(l_in == l_out, "Not a square CeedOperator.");
+   MFEM_VERIFY((CeedInt)l_in == l_in, "Size overflow.");
+   CeedInt length = l_in;
    ierr = CeedVectorCreate(internal::ceed, length, &diagceed); PCeedChk(ierr);
    CeedMemType mem;
    ierr = CeedGetPreferredMemType(internal::ceed, &mem); PCeedChk(ierr);
@@ -128,7 +126,7 @@ Solver *BuildSmootherFromCeed(ConstrainedOperator &op, bool chebyshev)
                      local_diag.Write(true);
    ierr = CeedVectorSetArray(diagceed, mem, CEED_USE_POINTER, ptr);
    PCeedChk(ierr);
-   ierr = CeedOperatorLinearAssembleDiagonal(ceed_op, diagceed,
+   ierr = CeedOperatorLinearAssembleDiagonal(op, diagceed,
                                              CEED_REQUEST_IMMEDIATE);
    PCeedChk(ierr);
    ierr = CeedVectorTakeArray(diagceed, mem, NULL); PCeedChk(ierr);
@@ -172,8 +170,7 @@ public:
       int ierr;
       const Array<int> ess_tdofs = oper.GetEssentialTrueDofs();
 
-      ierr = CeedOperatorFullAssemble(oper.GetCeedOperator(), &mat_local);
-      PCeedChk(ierr);
+      ierr = CeedOperatorFullAssemble(oper, &mat_local); PCeedChk(ierr);
 
       {
          HypreParMatrix hypre_local(
@@ -185,7 +182,7 @@ public:
       amg = new HypreBoomerAMG(*op_assembled);
       amg->SetPrintLevel(0);
    }
-   void SetOperator(const mfem::Operator &op) override { }
+   void SetOperator(const mfem::Operator &op) override {}
    void Mult(const Vector &x, Vector &y) const override { amg->Mult(x, y); }
    ~AssembledAMG()
    {
@@ -224,37 +221,47 @@ void CoarsenEssentialDofs(const mfem::Operator &interp,
    }
 }
 
-void AddToCompositeOperator(BilinearFormIntegrator *integ, CeedOperator op)
+namespace
 {
-   if (integ->SupportsCeed())
-   {
-      CeedCompositeOperatorAddSub(op, integ->GetCeedOp().GetCeedOperator());
-   }
-   else
+
+inline void CompositeOperatorAddSub(BilinearFormIntegrator &integ,
+                                    CeedOperator op)
+{
+   MFEM_VERIFY(integ.SupportsCeed(), "This integrator does not support Ceed!");
+#ifndef MFEM_USE_OPENMP
+   CeedCompositeOperatorAddSub(op, integ.GetCeedOp());
+#else
+   #pragma omp parallel
    {
-      MFEM_ABORT("This integrator does not support Ceed!");
+      const int tid = omp_get_thread_num();
+      if (integ.GetCeedOp()[tid])
+      {
+         #pragma omp critical
+         CeedCompositeOperatorAddSub(op, integ.GetCeedOp()[tid]);
+      }
    }
+#endif
 }
 
+} // namespace
+
 CeedOperator CreateCeedCompositeOperatorFromBilinearForm(BilinearForm &form)
 {
    int ierr;
    CeedOperator op;
    ierr = CeedCompositeOperatorCreate(internal::ceed, &op); PCeedChk(ierr);
-
-   MFEM_VERIFY(form.GetBBFI()->Size() == 0,
-               "Not implemented for this integrator!");
-   MFEM_VERIFY(form.GetFBFI()->Size() == 0,
-               "Not implemented for this integrator!");
-   MFEM_VERIFY(form.GetBFBFI()->Size() == 0,
-               "Not implemented for this integrator!");
-
-   // Get the domain bilinear form integrators (DBFIs)
-   Array<BilinearFormIntegrator*> *bffis = form.GetDBFI();
-   for (int i = 0; i < bffis->Size(); ++i)
+   for (BilinearFormIntegrator *integ : *form.GetDBFI())
+   {
+      CompositeOperatorAddSub(*integ, op);
+   }
+   for (BilinearFormIntegrator *integ : *form.GetBBFI())
    {
-      AddToCompositeOperator((*bffis)[i], op);
+      CompositeOperatorAddSub(*integ, op);
    }
+   MFEM_VERIFY(form.GetFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in CreateCeedCompositeOperatorFromBilinearForm");
+   MFEM_VERIFY(form.GetBFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in CreateCeedCompositeOperatorFromBilinearForm");
    return op;
 }
 
@@ -262,13 +269,13 @@ CeedOperator CoarsenCeedCompositeOperator(
    CeedOperator op,
    CeedElemRestriction er,
    CeedBasis c2f,
-   int order_reduction
-)
+   int order_reduction)
 {
    int ierr;
    bool isComposite;
    ierr = CeedOperatorIsComposite(op, &isComposite); PCeedChk(ierr);
-   MFEM_ASSERT(isComposite, "");
+   MFEM_ASSERT(isComposite,
+               "CoarsenCeedCompositeOperator requires a composite operator.");
 
    CeedOperator op_coarse;
    ierr = CeedCompositeOperatorCreate(internal::ceed,
@@ -304,8 +311,8 @@ CeedOperator CoarsenCeedCompositeOperator(
 AlgebraicMultigrid::AlgebraicMultigrid(
    AlgebraicSpaceHierarchy &hierarchy,
    BilinearForm &form,
-   const Array<int> &ess_tdofs
-) : GeometricMultigrid(hierarchy)
+   const Array<int> &ess_tdofs)
+   : GeometricMultigrid(hierarchy)
 {
    int nlevels = fespaces.GetNumLevels();
    ceed_operators.SetSize(nlevels);
@@ -344,14 +351,14 @@ AlgebraicMultigrid::AlgebraicMultigrid(
          if (nlevels == 1)
          {
             // Only one level -- no coarsening, finest level
-            ParFiniteElementSpace *pfes
-               = dynamic_cast<ParFiniteElementSpace*>(&space);
+            ParFiniteElementSpace *pfes =
+               dynamic_cast<ParFiniteElementSpace*>(&space);
             if (pfes) { P_mat = pfes->Dof_TrueDof_Matrix(); }
          }
          else
          {
-            ParAlgebraicCoarseSpace *pspace
-               = dynamic_cast<ParAlgebraicCoarseSpace*>(&space);
+            ParAlgebraicCoarseSpace *pspace =
+               dynamic_cast<ParAlgebraicCoarseSpace*>(&space);
             if (pspace) { P_mat = pspace->GetProlongationHypreParMatrix(); }
          }
          if (P_mat) { smoother = new AssembledAMG(*op, P_mat); }
@@ -378,67 +385,68 @@ int AlgebraicInterpolation::Initialize(
 
    CeedSize height, width;
    ierr = CeedElemRestrictionGetLVectorSize(erestrictu_coarse, &width);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    ierr = CeedElemRestrictionGetLVectorSize(erestrictu_fine, &height);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    // interpolation qfunction
    const int bp3_ncompu = 1;
    CeedQFunction l_qf_restrict, l_qf_prolong;
    ierr = CeedQFunctionCreateIdentity(ceed, bp3_ncompu, CEED_EVAL_NONE,
-                                      CEED_EVAL_INTERP, &l_qf_restrict); CeedChk(ierr);
+                                      CEED_EVAL_INTERP, &l_qf_restrict); PCeedChk(ierr);
    ierr = CeedQFunctionCreateIdentity(ceed, bp3_ncompu, CEED_EVAL_INTERP,
-                                      CEED_EVAL_NONE, &l_qf_prolong); CeedChk(ierr);
+                                      CEED_EVAL_NONE, &l_qf_prolong); PCeedChk(ierr);
 
    qf_restrict = l_qf_restrict;
    qf_prolong = l_qf_prolong;
 
    CeedVector c_fine_multiplicity;
-   ierr = CeedVectorCreate(ceed, height, &c_fine_multiplicity); CeedChk(ierr);
-   ierr = CeedVectorSetValue(c_fine_multiplicity, 0.0); CeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, height, &c_fine_multiplicity); PCeedChk(ierr);
+   ierr = CeedVectorSetValue(c_fine_multiplicity, 0.0); PCeedChk(ierr);
 
    // Create the restriction operator
    // Restriction - Fine to coarse
    ierr = CeedOperatorCreate(ceed, qf_restrict, CEED_QFUNCTION_NONE,
-                             CEED_QFUNCTION_NONE, &op_restrict); CeedChk(ierr);
+                             CEED_QFUNCTION_NONE, &op_restrict); PCeedChk(ierr);
    ierr = CeedOperatorSetField(op_restrict, "input", erestrictu_fine,
-                               CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE); CeedChk(ierr);
+                               CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE); PCeedChk(ierr);
    ierr = CeedOperatorSetField(op_restrict, "output", erestrictu_coarse,
-                               basisctof, CEED_VECTOR_ACTIVE); CeedChk(ierr);
+                               basisctof, CEED_VECTOR_ACTIVE); PCeedChk(ierr);
 
    // Interpolation - Coarse to fine
    // Create the prolongation operator
    ierr =  CeedOperatorCreate(ceed, qf_prolong, CEED_QFUNCTION_NONE,
-                              CEED_QFUNCTION_NONE, &op_interp); CeedChk(ierr);
+                              CEED_QFUNCTION_NONE, &op_interp); PCeedChk(ierr);
    ierr =  CeedOperatorSetField(op_interp, "input", erestrictu_coarse,
-                                basisctof, CEED_VECTOR_ACTIVE); CeedChk(ierr);
+                                basisctof, CEED_VECTOR_ACTIVE); PCeedChk(ierr);
    ierr = CeedOperatorSetField(op_interp, "output", erestrictu_fine,
-                               CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE); CeedChk(ierr);
+                               CEED_BASIS_COLLOCATED, CEED_VECTOR_ACTIVE); PCeedChk(ierr);
 
    ierr = CeedElemRestrictionGetMultiplicity(erestrictu_fine,
-                                             c_fine_multiplicity); CeedChk(ierr);
-   ierr = CeedVectorCreate(ceed, height, &fine_multiplicity_r); CeedChk(ierr);
+                                             c_fine_multiplicity); PCeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, height, &fine_multiplicity_r); PCeedChk(ierr);
 
    CeedScalar* fine_r_data;
    const CeedScalar* fine_data;
    ierr = CeedVectorGetArrayWrite(fine_multiplicity_r, CEED_MEM_HOST,
-                                  &fine_r_data); CeedChk(ierr);
+                                  &fine_r_data); PCeedChk(ierr);
    ierr = CeedVectorGetArrayRead(c_fine_multiplicity, CEED_MEM_HOST,
-                                 &fine_data); CeedChk(ierr);
+                                 &fine_data); PCeedChk(ierr);
    for (CeedSize i = 0; i < height; ++i)
    {
       fine_r_data[i] = 1.0 / fine_data[i];
    }
 
-   ierr = CeedVectorRestoreArray(fine_multiplicity_r, &fine_r_data); CeedChk(ierr);
+   ierr = CeedVectorRestoreArray(fine_multiplicity_r, &fine_r_data);
+   PCeedChk(ierr);
    ierr = CeedVectorRestoreArrayRead(c_fine_multiplicity, &fine_data);
-   CeedChk(ierr);
-   ierr = CeedVectorDestroy(&c_fine_multiplicity); CeedChk(ierr);
+   PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&c_fine_multiplicity); PCeedChk(ierr);
 
-   ierr = CeedVectorCreate(ceed, height, &fine_work); CeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, height, &fine_work); PCeedChk(ierr);
 
-   ierr = CeedVectorCreate(ceed, height, &v_); CeedChk(ierr);
-   ierr = CeedVectorCreate(ceed, width, &u_); CeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, height, &v_); PCeedChk(ierr);
+   ierr = CeedVectorCreate(ceed, width, &u_); PCeedChk(ierr);
 
    return 0;
 }
@@ -447,12 +455,12 @@ int AlgebraicInterpolation::Finalize()
 {
    int ierr;
 
-   ierr = CeedQFunctionDestroy(&qf_restrict); CeedChk(ierr);
-   ierr = CeedQFunctionDestroy(&qf_prolong); CeedChk(ierr);
-   ierr = CeedOperatorDestroy(&op_interp); CeedChk(ierr);
-   ierr = CeedOperatorDestroy(&op_restrict); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&fine_multiplicity_r); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&fine_work); CeedChk(ierr);
+   ierr = CeedQFunctionDestroy(&qf_restrict); PCeedChk(ierr);
+   ierr = CeedQFunctionDestroy(&qf_prolong); PCeedChk(ierr);
+   ierr = CeedOperatorDestroy(&op_interp); PCeedChk(ierr);
+   ierr = CeedOperatorDestroy(&op_restrict); PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&fine_multiplicity_r); PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&fine_work); PCeedChk(ierr);
 
    return 0;
 }
@@ -470,8 +478,8 @@ AlgebraicInterpolation::AlgebraicInterpolation(
                                             &ho_nldofs); PCeedChk(ierr);
    height = (int)ho_nldofs;
    width = (int)lo_nldofs;
-   MFEM_VERIFY(ho_nldofs == height, "height overflow");
-   MFEM_VERIFY(lo_nldofs == width, "width overflow");
+   MFEM_VERIFY(ho_nldofs == height, "Height overflow.");
+   MFEM_VERIFY(lo_nldofs == width, "Width overflow.");
    owns_basis_ = false;
    ierr = Initialize(ceed, basisctof, erestrictu_coarse, erestrictu_fine);
    PCeedChk(ierr);
@@ -490,7 +498,6 @@ AlgebraicInterpolation::~AlgebraicInterpolation()
 }
 
 /// a = a (pointwise*) b
-/// @todo: using MPI_FORALL in this Ceed-like function is ugly
 int CeedVectorPointwiseMult(CeedVector a, const CeedVector b)
 {
    int ierr;
@@ -498,8 +505,8 @@ int CeedVectorPointwiseMult(CeedVector a, const CeedVector b)
    CeedVectorGetCeed(a, &ceed);
 
    CeedSize length, length2;
-   ierr = CeedVectorGetLength(a, &length); CeedChk(ierr);
-   ierr = CeedVectorGetLength(b, &length2); CeedChk(ierr);
+   ierr = CeedVectorGetLength(a, &length); PCeedChk(ierr);
+   ierr = CeedVectorGetLength(b, &length2); PCeedChk(ierr);
    if (length != length2)
    {
       return CeedError(ceed, 1, "Vector sizes don't match");
@@ -516,14 +523,16 @@ int CeedVectorPointwiseMult(CeedVector a, const CeedVector b)
    }
    CeedScalar *a_data;
    const CeedScalar *b_data;
-   ierr = CeedVectorGetArray(a, mem, &a_data); CeedChk(ierr);
-   ierr = CeedVectorGetArrayRead(b, mem, &b_data); CeedChk(ierr);
-   MFEM_VERIFY(int(length) == length, "length overflow");
+   ierr = CeedVectorGetArray(a, mem, &a_data); PCeedChk(ierr);
+   ierr = CeedVectorGetArrayRead(b, mem, &b_data); PCeedChk(ierr);
+   MFEM_VERIFY(int(length) == length, "Length overflow.");
    mfem::forall(length, [=] MFEM_HOST_DEVICE (int i)
-   {a_data[i] *= b_data[i];});
+   {
+      a_data[i] *= b_data[i];
+   });
 
-   ierr = CeedVectorRestoreArray(a, &a_data); CeedChk(ierr);
-   ierr = CeedVectorRestoreArrayRead(b, &b_data); CeedChk(ierr);
+   ierr = CeedVectorRestoreArray(a, &a_data); PCeedChk(ierr);
+   ierr = CeedVectorRestoreArrayRead(b, &b_data); PCeedChk(ierr);
 
    return 0;
 }
@@ -535,7 +544,7 @@ void AlgebraicInterpolation::Mult(const mfem::Vector& x, mfem::Vector& y) const
    CeedScalar *out_ptr;
    CeedMemType mem;
    ierr = CeedGetPreferredMemType(internal::ceed, &mem); PCeedChk(ierr);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       in_ptr = x.Read();
       out_ptr = y.ReadWrite();
@@ -568,7 +577,7 @@ void AlgebraicInterpolation::MultTranspose(const mfem::Vector& x,
    ierr = CeedGetPreferredMemType(internal::ceed, &mem); PCeedChk(ierr);
    const CeedScalar *in_ptr;
    CeedScalar *out_ptr;
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       in_ptr = x.Read();
       out_ptr = y.ReadWrite();
@@ -592,9 +601,11 @@ void AlgebraicInterpolation::MultTranspose(const mfem::Vector& x,
    ierr = CeedVectorGetArrayRead(fine_multiplicity_r, mem,
                                  &multiplicitydata); PCeedChk(ierr);
    ierr = CeedVectorGetArrayWrite(fine_work, mem, &workdata); PCeedChk(ierr);
-   MFEM_VERIFY((int)length == length, "length overflow");
+   MFEM_VERIFY((int)length == length, "Length overflow.");
    mfem::forall(length, [=] MFEM_HOST_DEVICE (int i)
-   {workdata[i] = in_ptr[i] * multiplicitydata[i];});
+   {
+      workdata[i] = in_ptr[i] * multiplicitydata[i];
+   });
    ierr = CeedVectorRestoreArrayRead(fine_multiplicity_r,
                                      &multiplicitydata);
    ierr = CeedVectorRestoreArray(fine_work, &workdata); PCeedChk(ierr);
@@ -637,8 +648,7 @@ AlgebraicSpaceHierarchy::AlgebraicSpaceHierarchy(FiniteElementSpace &fes)
 
    current_order = order;
 
-   Ceed ceed = internal::ceed;
-   InitRestriction(fes, ceed, &fine_er);
+   InitRestriction(fes, internal::ceed, &fine_er);
    CeedElemRestriction er = fine_er;
 
    int dim = fes.GetMesh()->Dimension();
@@ -673,7 +683,7 @@ AlgebraicSpaceHierarchy::AlgebraicSpaceHierarchy(FiniteElementSpace &fes)
       current_order = current_order/2;
       fespaces[ilevel] = space;
       ceed_interpolations[ilevel] = new AlgebraicInterpolation(
-         ceed,
+         internal::ceed,
          space->GetCeedCoarseToFine(),
          space->GetCeedElemRestriction(),
          er
@@ -701,11 +711,10 @@ AlgebraicCoarseSpace::AlgebraicCoarseSpace(
    CeedElemRestriction fine_er,
    int order,
    int dim,
-   int order_reduction_
-) : order_reduction(order_reduction_)
+   int order_reduction)
+   : order_reduction(order_reduction)
 {
    int ierr;
-   order_reduction = order_reduction_;
 
    ierr = CeedATPMGElemRestriction(order, order_reduction, fine_er,
                                    &ceed_elem_restriction, dof_map);
@@ -717,7 +726,7 @@ AlgebraicCoarseSpace::AlgebraicCoarseSpace(
    ierr = CeedElemRestrictionGetLVectorSize(ceed_elem_restriction, &ndofs_);
    PCeedChk(ierr);
    ndofs = ndofs_;
-   MFEM_VERIFY(ndofs == ndofs_, "ndofs overflow");
+   MFEM_VERIFY(ndofs == ndofs_, "Overflow in ndofs.");
 
    mesh = fine_fes.GetMesh();
 }
@@ -743,9 +752,8 @@ ParAlgebraicCoarseSpace::ParAlgebraicCoarseSpace(
 {
    CeedSize lsize;
    CeedElemRestrictionGetLVectorSize(ceed_elem_restriction, &lsize);
+   MFEM_VERIFY((int)lsize == lsize, "Size overflow.");
    const Table &group_ldof_fine = gc_fine->GroupLDofTable();
-
-   MFEM_VERIFY((int)lsize == lsize, "size overflow");
    ldof_group.SetSize(lsize);
    ldof_group = 0;
 
@@ -825,7 +833,8 @@ HypreParMatrix *ParAlgebraicCoarseSpace::GetProlongationHypreParMatrix()
    if (P_mat) { return P_mat; }
 
    ParMesh *pmesh = dynamic_cast<ParMesh*>(mesh);
-   MFEM_VERIFY(pmesh != NULL, "");
+   MFEM_VERIFY(pmesh != NULL,
+               "ParAlgebraicCoarseSpace requires a ParMesh mesh object.");
    Array<HYPRE_BigInt> dof_offsets, tdof_offsets, tdof_nb_offsets;
    Array<HYPRE_BigInt> *offsets[2] = {&dof_offsets, &tdof_offsets};
    int lsize = P->Height();
@@ -950,12 +959,12 @@ AlgebraicSolver::AlgebraicSolver(BilinearForm &form,
                                  const Array<int>& ess_tdofs)
 {
    MFEM_VERIFY(DeviceCanUseCeed(),
-               "AlgebraicSolver requires a Ceed device");
+               "AlgebraicSolver requires a Ceed device.");
    MFEM_VERIFY(form.GetAssemblyLevel() == AssemblyLevel::PARTIAL ||
                form.GetAssemblyLevel() == AssemblyLevel::NONE,
                "AlgebraicSolver requires partial assembly or fully matrix-free.");
    MFEM_VERIFY(UsesTensorBasis(*form.FESpace()),
-               "AlgebraicSolver requires tensor product basis functions.");
+               "AlgebraicSolver requires tensor-product basis functions.");
 #ifdef MFEM_USE_CEED
    fespaces = new AlgebraicSpaceHierarchy(*form.FESpace());
    multigrid = new AlgebraicMultigrid(*fespaces, form, ess_tdofs);
@@ -986,6 +995,124 @@ void AlgebraicSolver::SetOperator(const mfem::Operator& op)
 #endif
 }
 
+#ifdef MFEM_USE_CEED
+namespace
+{
+
+inline void OperatorFullAssemble(BilinearFormIntegrator &integ, bool set,
+                                 Array<SparseMatrix *> &mat_i)
+{
+   if (!integ.SupportsCeed()) { return; }
+#ifndef MFEM_USE_OPENMP
+   SparseMatrix *mat_integ;
+   int ierr = CeedOperatorFullAssemble(integ.GetCeedOp(), &mat_integ, set);
+   PCeedChk(ierr);
+   mat_i.Append(mat_integ);
+#else
+   #pragma omp parallel
+   {
+      SparseMatrix *mat_integ;
+      const int tid = omp_get_thread_num();
+      if (integ.GetCeedOp()[tid])
+      {
+         int ierr = CeedOperatorFullAssemble(integ.GetCeedOp()[tid], &mat_integ, set);
+         PCeedChk(ierr);
+         #pragma omp critical
+         mat_i.Append(mat_integ);
+      }
+   }
+#endif
+}
+
+} // namespace
+
+SparseMatrix *CeedOperatorFullAssemble(BilinearForm &form, bool set)
+{
+   Array<SparseMatrix *> mat_i;
+   for (BilinearFormIntegrator *integ : *form.GetDBFI())
+   {
+      OperatorFullAssemble(*integ, set, mat_i);
+   }
+   for (BilinearFormIntegrator *integ : *form.GetBBFI())
+   {
+      OperatorFullAssemble(*integ, set, mat_i);
+   }
+   MFEM_VERIFY(form.GetFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in CeedOperatorFullAssemble.");
+   MFEM_VERIFY(form.GetBFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in CeedOperatorFullAssemble.");
+
+   // This method frees all the no longer used memory from mat_i
+   return Add(mat_i);
+}
+
+SparseMatrix *CeedOperatorFullAssemble(MixedBilinearForm &form, bool set)
+{
+   Array<SparseMatrix *> mat_i;
+   for (BilinearFormIntegrator *integ : *form.GetDBFI())
+   {
+      OperatorFullAssemble(*integ, set, mat_i);
+   }
+   for (BilinearFormIntegrator *integ : *form.GetBBFI())
+   {
+      OperatorFullAssemble(*integ, set, mat_i);
+   }
+   MFEM_VERIFY(form.GetTFBFI()->Size() == 0, "AddTraceFaceIntegrator is not "
+               "currently supported in CeedOperatorFullAssemble.");
+   MFEM_VERIFY(form.GetBTFBFI()->Size() == 0, "AddBdrTraceFaceIntegrator is not "
+               "currently supported in CeedOperatorFullAssemble.");
+
+   // This method frees all the no longer used memory from mat_i
+   return Add(mat_i);
+}
+
+int CeedOperatorFullAssemble(CeedOperator op, SparseMatrix **mat, bool set)
+{
+   int ierr;
+   Ceed ceed;
+   ierr = CeedOperatorGetCeed(op, &ceed); PCeedChk(ierr);
+
+   CeedSize l_in, l_out;
+   ierr = CeedOperatorGetActiveVectorLengths(op, &l_in, &l_out); PCeedChk(ierr);
+   MFEM_VERIFY((int)l_in == l_in && (int)l_out == l_out, "Size overflow.");
+   *mat = new SparseMatrix(l_out, l_in);
+
+   CeedSize nnz;
+   CeedInt *rows, *cols;
+   ierr = CeedOperatorLinearAssembleSymbolic(op, &nnz, &rows, &cols);
+   PCeedChk(ierr);
+
+   CeedVector vals;
+   ierr = CeedVectorCreate(ceed, nnz, &vals); PCeedChk(ierr);
+   ierr = CeedOperatorLinearAssemble(op, vals); PCeedChk(ierr);
+
+   const CeedScalar *val_array;
+   ierr = CeedVectorGetArrayRead(vals, CEED_MEM_HOST, &val_array); PCeedChk(ierr);
+   for (CeedSize k = 0; k < nnz; ++k)
+   {
+      if (!set)
+      {
+         (*mat)->Add(rows[k], cols[k], val_array[k]);
+      }
+      else
+      {
+         (*mat)->Set(rows[k], cols[k], val_array[k]);
+      }
+   }
+   ierr = CeedVectorRestoreArrayRead(vals, &val_array); PCeedChk(ierr);
+
+   ierr = CeedVectorDestroy(&vals); PCeedChk(ierr);
+   ierr = CeedInternalFree(&rows); PCeedChk(ierr);
+   ierr = CeedInternalFree(&cols); PCeedChk(ierr);
+
+   // Enforce structurally symmetric for later elimination
+   const int skip_zeros = 0;
+   (*mat)->Finalize(skip_zeros);
+
+   return 0;
+}
+#endif
+
 } // namespace ceed
 
 } // namespace mfem
diff --git a/fem/ceed/solvers/algebraic.hpp b/fem/ceed/solvers/algebraic.hpp
index 49cdbca98..8c84a2034 100644
--- a/fem/ceed/solvers/algebraic.hpp
+++ b/fem/ceed/solvers/algebraic.hpp
@@ -12,9 +12,9 @@
 #ifndef MFEM_CEED_ALGEBRAIC_HPP
 #define MFEM_CEED_ALGEBRAIC_HPP
 
+#include "../../../linalg/sparsemat.hpp"
 #include "../../fespacehierarchy.hpp"
 #include "../../multigrid.hpp"
-#include "../interface/operator.hpp"
 #include "../interface/ceed.hpp"
 
 namespace mfem
@@ -32,13 +32,14 @@ class AlgebraicCoarseSpace : public FiniteElementSpace
 {
 public:
    AlgebraicCoarseSpace(FiniteElementSpace &fine_fes, CeedElemRestriction fine_er,
-                        int order, int dim, int order_reduction_);
+                        int order, int dim, int order_reduction);
+   ~AlgebraicCoarseSpace();
+
    int GetOrderReduction() const { return order_reduction; }
    CeedElemRestriction GetCeedElemRestriction() const { return ceed_elem_restriction; }
    CeedBasis GetCeedCoarseToFine() const { return coarse_to_fine; }
    virtual const mfem::Operator *GetProlongationMatrix() const override { return NULL; }
    virtual const SparseMatrix *GetRestrictionMatrix() const override { return NULL; }
-   ~AlgebraicCoarseSpace();
 
 protected:
    int *dof_map;
@@ -64,11 +65,12 @@ public:
       int order_reduction_,
       GroupCommunicator *gc_fine
    );
+   ~ParAlgebraicCoarseSpace();
+
    virtual const mfem::Operator *GetProlongationMatrix() const override { return P; }
    virtual const SparseMatrix *GetRestrictionMatrix() const override { return R_mat; }
    GroupCommunicator *GetGroupCommunicator() const { return gc; }
    HypreParMatrix *GetProlongationHypreParMatrix();
-   ~ParAlgebraicCoarseSpace();
 
 private:
    SparseMatrix *R_mat;
@@ -92,14 +94,11 @@ public:
       Ceed ceed, CeedBasis basisctof,
       CeedElemRestriction erestrictu_coarse,
       CeedElemRestriction erestrictu_fine);
-
    ~AlgebraicInterpolation();
 
    virtual void Mult(const mfem::Vector& x, mfem::Vector& y) const;
-
    virtual void MultTranspose(const mfem::Vector& x, mfem::Vector& y) const;
 
-   using mfem::Operator::SetupRAP;
 private:
    int Initialize(Ceed ceed, CeedBasis basisctof,
                   CeedElemRestriction erestrictu_coarse,
@@ -127,11 +126,6 @@ public:
        The given space is a real (geometric) space, but the coarse spaces are
        constructed semi-algebraically with no mesh information. */
    AlgebraicSpaceHierarchy(FiniteElementSpace &fespace);
-   AlgebraicCoarseSpace& GetAlgebraicCoarseSpace(int level)
-   {
-      MFEM_ASSERT(level < GetNumLevels() - 1, "");
-      return static_cast<AlgebraicCoarseSpace&>(*fespaces[level]);
-   }
    ~AlgebraicSpaceHierarchy()
    {
       for (int i=0; i<R_tr.Size(); ++i)
@@ -144,6 +138,12 @@ public:
       }
    }
 
+   AlgebraicCoarseSpace& GetAlgebraicCoarseSpace(int level)
+   {
+      MFEM_ASSERT(level < GetNumLevels() - 1, "");
+      return static_cast<AlgebraicCoarseSpace&>(*fespaces[level]);
+   }
+
 private:
    CeedElemRestriction fine_er;
    Array<AlgebraicInterpolation*> ceed_interpolations;
@@ -163,14 +163,13 @@ public:
        @param[in] form       partially assembled BilinearForm on finest level
        @param[in] ess_tdofs  List of essential true dofs on finest level
     */
-   AlgebraicMultigrid(
-      AlgebraicSpaceHierarchy &hierarchy,
-      BilinearForm &form,
-      const Array<int> &ess_tdofs
-   );
-   virtual void SetOperator(const mfem::Operator &op) override { }
+   AlgebraicMultigrid(AlgebraicSpaceHierarchy &hierarchy,
+                      BilinearForm &form,
+                      const Array<int> &ess_tdofs);
    ~AlgebraicMultigrid();
 
+   virtual void SetOperator(const mfem::Operator &op) override {}
+
 private:
    OperatorHandle fine_operator;
    Array<CeedOperator> ceed_operators;
@@ -186,12 +185,12 @@ class AlgebraicSolver : public Solver
 {
 private:
 #ifdef MFEM_USE_CEED
-   AlgebraicSpaceHierarchy * fespaces;
-   AlgebraicMultigrid * multigrid;
+   AlgebraicSpaceHierarchy *fespaces;
+   AlgebraicMultigrid *multigrid;
 #endif
 
 public:
-   /** @brief Constructs algebraic multigrid hierarchy and solver.
+   /** @brief Constructs algebraic multigrid hierarchy and solver
 
        This only works if the Ceed device backend is enabled.
 
@@ -200,10 +199,36 @@ public:
     */
    AlgebraicSolver(BilinearForm &form, const Array<int>& ess_tdofs);
    ~AlgebraicSolver();
+
    void Mult(const Vector& x, Vector& y) const;
    void SetOperator(const mfem::Operator& op);
 };
 
+#ifdef MFEM_USE_CEED
+/** @brief Assemble the CeedOperators from a BilinearForm as an
+    mfem::SparseMatrix
+
+    In parallel, this assembles independently on each processor, that is, it
+    assembles at the L-vector level. The assembly procedure is always performed
+    on the host, but this works also for operators stored on device by copying
+    memory. */
+SparseMatrix *CeedOperatorFullAssemble(BilinearForm &form, bool set = false);
+
+/** @brief Assemble the CeedOperators from a MixedBilinearForm as an
+    mfem::SparseMatrix */
+SparseMatrix *CeedOperatorFullAssemble(MixedBilinearForm &form,
+                                       bool set = false);
+
+/** @brief Assembles a CeedOperator as an mfem::SparseMatrix
+
+    In parallel, this assembles independently on each processor, that is, it
+    assembles at the L-vector level. The assembly procedure is always performed
+    on the host, but this works also for operators stored on device by copying
+    memory. */
+int CeedOperatorFullAssemble(CeedOperator op, SparseMatrix **mat,
+                             bool set = false);
+#endif
+
 } // namespace ceed
 
 } // namespace mfem
diff --git a/fem/ceed/solvers/full-assembly.cpp b/fem/ceed/solvers/full-assembly.cpp
deleted file mode 100644
index ccf9b145a..000000000
--- a/fem/ceed/solvers/full-assembly.cpp
+++ /dev/null
@@ -1,341 +0,0 @@
-// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
-// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
-// LICENSE and NOTICE for details. LLNL-CODE-806117.
-//
-// This file is part of the MFEM library. For more information and source code
-// availability visit https://mfem.org.
-//
-// MFEM is free software; you can redistribute it and/or modify it under the
-// terms of the BSD-3 license. We welcome feedback and contributions, see file
-// CONTRIBUTING.md for details.
-
-#include "full-assembly.hpp"
-
-#include "../../../linalg/sparsemat.hpp"
-#include "../interface/util.hpp"
-#include "../interface/ceed.hpp"
-
-#ifdef MFEM_USE_CEED
-
-namespace mfem
-{
-
-namespace ceed
-{
-
-int CeedHackReallocArray(size_t n, size_t unit, void *p)
-{
-   *(void **)p = realloc(*(void **)p, n*unit);
-   if (n && unit && !*(void **)p)
-      return CeedError(NULL, 1, "realloc failed to allocate %zd members of size "
-                       "%zd\n", n, unit);
-   return 0;
-}
-
-#define CeedHackRealloc(n, p) CeedHackReallocArray((n), sizeof(**(p)), p)
-
-int CeedHackFree(void *p)
-{
-   free(*(void **)p);
-   *(void **)p = NULL;
-   return 0;
-}
-
-int CeedSingleOperatorFullAssemble(CeedOperator op, SparseMatrix *out)
-{
-   int ierr;
-   Ceed ceed;
-   ierr = CeedOperatorGetCeed(op, &ceed); CeedChk(ierr);
-
-   // Assemble QFunction
-   CeedQFunction qf;
-   ierr = CeedOperatorGetQFunction(op, &qf); CeedChk(ierr);
-   CeedInt numinputfields, numoutputfields;
-   CeedChk(ierr);
-   CeedVector assembledqf;
-   CeedElemRestriction rstr_q;
-   ierr = CeedOperatorLinearAssembleQFunction(
-             op, &assembledqf, &rstr_q, CEED_REQUEST_IMMEDIATE); CeedChk(ierr);
-
-   CeedSize qflength;
-   ierr = CeedVectorGetLength(assembledqf, &qflength); CeedChk(ierr);
-
-   CeedOperatorField *input_fields;
-   CeedOperatorField *output_fields;
-   ierr = CeedOperatorGetFields(op, &numinputfields, &input_fields,
-                                &numoutputfields, &output_fields);
-   CeedChk(ierr);
-
-   // Determine active input basis
-   CeedQFunctionField *qffields;
-   ierr = CeedQFunctionGetFields(qf, &numinputfields, &qffields,
-                                 &numoutputfields, NULL);
-   CeedChk(ierr);
-   CeedInt numemodein = 0, ncomp, dim = 1;
-   CeedEvalMode *emodein = NULL;
-   CeedBasis basisin = NULL;
-   CeedElemRestriction rstrin = NULL;
-   for (CeedInt i=0; i<numinputfields; i++)
-   {
-      CeedVector vec;
-      ierr = CeedOperatorFieldGetVector(input_fields[i], &vec); CeedChk(ierr);
-      if (vec == CEED_VECTOR_ACTIVE)
-      {
-         ierr = CeedOperatorFieldGetBasis(input_fields[i], &basisin);
-         CeedChk(ierr);
-         ierr = CeedBasisGetNumComponents(basisin, &ncomp); CeedChk(ierr);
-         ierr = CeedBasisGetDimension(basisin, &dim); CeedChk(ierr);
-         ierr = CeedOperatorFieldGetElemRestriction(input_fields[i], &rstrin);
-         CeedChk(ierr);
-         CeedEvalMode emode;
-         ierr = CeedQFunctionFieldGetEvalMode(qffields[i], &emode);
-         CeedChk(ierr);
-         switch (emode)
-         {
-            case CEED_EVAL_NONE:
-            case CEED_EVAL_INTERP:
-               ierr = CeedHackRealloc(numemodein + 1, &emodein); CeedChk(ierr);
-               emodein[numemodein] = emode;
-               numemodein += 1;
-               break;
-            case CEED_EVAL_GRAD:
-               ierr = CeedHackRealloc(numemodein + dim, &emodein); CeedChk(ierr);
-               for (CeedInt d=0; d<dim; d++)
-               {
-                  emodein[numemodein+d] = emode;
-               }
-               numemodein += dim;
-               break;
-            case CEED_EVAL_WEIGHT:
-            case CEED_EVAL_DIV:
-            case CEED_EVAL_CURL:
-               break; // Caught by QF Assembly
-         }
-      }
-   }
-
-   // Determine active output basis
-   ierr = CeedQFunctionGetFields(qf, &numinputfields, NULL, &numoutputfields,
-                                 &qffields); CeedChk(ierr);
-   CeedInt numemodeout = 0;
-   CeedEvalMode *emodeout = NULL;
-   CeedBasis basisout = NULL;
-   CeedElemRestriction rstrout = NULL;
-   for (CeedInt i=0; i<numoutputfields; i++)
-   {
-      CeedVector vec;
-      ierr = CeedOperatorFieldGetVector(output_fields[i], &vec); CeedChk(ierr);
-      if (vec == CEED_VECTOR_ACTIVE)
-      {
-         ierr = CeedOperatorFieldGetBasis(output_fields[i], &basisout);
-         CeedChk(ierr);
-         ierr = CeedOperatorFieldGetElemRestriction(output_fields[i], &rstrout);
-         CeedChk(ierr);
-         CeedChk(ierr);
-         CeedEvalMode emode;
-         ierr = CeedQFunctionFieldGetEvalMode(qffields[i], &emode);
-         CeedChk(ierr);
-         switch (emode)
-         {
-            case CEED_EVAL_NONE:
-            case CEED_EVAL_INTERP:
-               ierr = CeedHackRealloc(numemodeout + 1, &emodeout); CeedChk(ierr);
-               emodeout[numemodeout] = emode;
-               numemodeout += 1;
-               break;
-            case CEED_EVAL_GRAD:
-               ierr = CeedHackRealloc(numemodeout + dim, &emodeout); CeedChk(ierr);
-               for (CeedInt d=0; d<dim; d++)
-               {
-                  emodeout[numemodeout+d] = emode;
-               }
-               numemodeout += dim;
-               break;
-            case CEED_EVAL_WEIGHT:
-            case CEED_EVAL_DIV:
-            case CEED_EVAL_CURL:
-               break; // Caught by QF Assembly
-         }
-      }
-   }
-
-   CeedInt nelem, elemsize, nqpts;
-   CeedSize nnodes;
-   ierr = CeedElemRestrictionGetNumElements(rstrin, &nelem); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetElementSize(rstrin, &elemsize); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetLVectorSize(rstrin, &nnodes); CeedChk(ierr);
-   ierr = CeedBasisGetNumQuadraturePoints(basisin, &nqpts); CeedChk(ierr);
-
-   // Determine elem_dof relation
-   CeedVector index_vec;
-   ierr = CeedVectorCreate(ceed, nnodes, &index_vec); CeedChk(ierr);
-   CeedScalar *array;
-   ierr = CeedVectorGetArrayWrite(index_vec, CEED_MEM_HOST, &array);
-   CeedChk(ierr);
-   for (CeedSize i = 0; i < nnodes; ++i)
-   {
-      array[i] = i;
-   }
-   ierr = CeedVectorRestoreArray(index_vec, &array); CeedChk(ierr);
-   CeedVector elem_dof;
-   ierr = CeedVectorCreate(ceed, nelem * elemsize, &elem_dof); CeedChk(ierr);
-   ierr = CeedVectorSetValue(elem_dof, 0.0); CeedChk(ierr);
-   CeedElemRestrictionApply(rstrin, CEED_NOTRANSPOSE, index_vec,
-                            elem_dof, CEED_REQUEST_IMMEDIATE); CeedChk(ierr);
-   const CeedScalar * elem_dof_a;
-   ierr = CeedVectorGetArrayRead(elem_dof, CEED_MEM_HOST, &elem_dof_a);
-   CeedChk(ierr);
-   ierr = CeedVectorDestroy(&index_vec); CeedChk(ierr);
-
-   // loop over elements and put in SparseMatrix
-   // SparseMatrix * out = new SparseMatrix(nnodes, nnodes);
-   MFEM_ASSERT(out->Height() == nnodes, "Sizes don't match!");
-   MFEM_ASSERT(out->Width() == nnodes, "Sizes don't match!");
-   const CeedScalar *interpin, *gradin;
-   ierr = CeedBasisGetInterp(basisin, &interpin); CeedChk(ierr);
-   ierr = CeedBasisGetGrad(basisin, &gradin); CeedChk(ierr);
-
-   const CeedScalar * assembledqfarray;
-   ierr = CeedVectorGetArrayRead(assembledqf, CEED_MEM_HOST, &assembledqfarray);
-   CeedChk(ierr);
-
-   CeedInt layout[3];
-   ierr = CeedElemRestrictionGetELayout(rstr_q, &layout); CeedChk(ierr);
-   ierr = CeedElemRestrictionDestroy(&rstr_q); CeedChk(ierr);
-
-   // enforce structurally symmetric for later elimination
-   const int skip_zeros = 0;
-   MFEM_ASSERT(numemodein == numemodeout,
-               "Ceed full assembly not implemented for this case.");
-   for (int e = 0; e < nelem; ++e)
-   {
-      // get Array<int> for use in SparseMatrix::AddSubMatrix()
-      Array<int> rows(elemsize);
-      for (int i = 0; i < elemsize; ++i)
-      {
-         rows[i] = elem_dof_a[e * elemsize + i];
-      }
-
-      // form element matrix itself
-      DenseMatrix Bmat(nqpts * numemodein, elemsize);
-      Bmat = 0.0;
-      // Store block-diagonal D matrix as collection of small dense blocks
-      DenseTensor Dmat(numemodeout, numemodein, nqpts);
-      Dmat = 0.0;
-      DenseMatrix elem_mat(elemsize, elemsize);
-      elem_mat = 0.0;
-      for (int q = 0; q < nqpts; ++q)
-      {
-         for (int n = 0; n < elemsize; ++n)
-         {
-            CeedInt din = -1;
-            for (int ein = 0; ein < numemodein; ++ein)
-            {
-               if (emodein[ein] == CEED_EVAL_INTERP)
-               {
-                  Bmat(numemodein * q + ein, n) += interpin[q * elemsize + n];
-               }
-               else if (emodein[ein] == CEED_EVAL_GRAD)
-               {
-                  din += 1;
-                  Bmat(numemodein * q + ein, n) += gradin[(din*nqpts+q) * elemsize + n];
-               }
-               else
-               {
-                  MFEM_ASSERT(false, "Not implemented!");
-               }
-            }
-         }
-         for (int ei = 0; ei < numemodein; ++ei)
-         {
-            for (int ej = 0; ej < numemodein; ++ej)
-            {
-               const int comp = ei * numemodein + ej;
-               const int index = q*layout[0] + comp*layout[1] + e*layout[2];
-               Dmat(ei, ej, q) += assembledqfarray[index];
-            }
-         }
-      }
-      DenseMatrix BTD(elemsize, nqpts*numemodein);
-      // Compute B^T*D
-      BTD = 0.0;
-      for (int j=0; j<elemsize; ++j)
-      {
-         for (int q=0; q<nqpts; ++q)
-         {
-            int qq = numemodein*q;
-            for (int ei = 0; ei < numemodein; ++ei)
-            {
-               for (int ej = 0; ej < numemodein; ++ej)
-               {
-                  BTD(j,qq+ei) += Bmat(qq+ej,j)*Dmat(ej,ei,q);
-               }
-            }
-         }
-      }
-
-      Mult(BTD, Bmat, elem_mat);
-
-      // put element matrix in sparsemat
-      out->AddSubMatrix(rows, rows, elem_mat, skip_zeros);
-   }
-
-   ierr = CeedVectorRestoreArrayRead(elem_dof, &elem_dof_a); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&elem_dof); CeedChk(ierr);
-   ierr = CeedVectorRestoreArrayRead(assembledqf, &assembledqfarray);
-   CeedChk(ierr);
-   ierr = CeedVectorDestroy(&assembledqf); CeedChk(ierr);
-   ierr = CeedHackFree(&emodein); CeedChk(ierr);
-   ierr = CeedHackFree(&emodeout); CeedChk(ierr);
-
-   return 0;
-}
-
-int CeedOperatorFullAssemble(CeedOperator op, SparseMatrix **mat)
-{
-   int ierr;
-
-   CeedSize in_len, out_len;
-   ierr = CeedOperatorGetActiveVectorLengths(op, &in_len, &out_len);
-   CeedChk(ierr);
-   const int nnodes = in_len;
-   MFEM_VERIFY(in_len == out_len, "not a square CeedOperator");
-   MFEM_VERIFY(in_len == nnodes, "size overflow");
-
-   SparseMatrix *out = new SparseMatrix(nnodes, nnodes);
-
-   bool isComposite;
-   ierr = CeedOperatorIsComposite(op, &isComposite); CeedChk(ierr);
-   if (isComposite)
-   {
-      CeedInt numsub;
-      CeedOperator *subops;
-#if CEED_VERSION_GE(0, 10, 2)
-      CeedCompositeOperatorGetNumSub(op, &numsub);
-      ierr = CeedCompositeOperatorGetSubList(op, &subops); CeedChk(ierr);
-#else
-      CeedOperatorGetNumSub(op, &numsub);
-      ierr = CeedOperatorGetSubList(op, &subops); CeedChk(ierr);
-#endif
-      for (int i = 0; i < numsub; ++i)
-      {
-         ierr = CeedSingleOperatorFullAssemble(subops[i], out); CeedChk(ierr);
-      }
-   }
-   else
-   {
-      ierr = CeedSingleOperatorFullAssemble(op, out); CeedChk(ierr);
-   }
-   // enforce structurally symmetric for later elimination
-   const int skip_zeros = 0;
-   out->Finalize(skip_zeros);
-   *mat = out;
-
-   return 0;
-}
-
-} // namespace ceed
-
-} // namespace mfem
-
-#endif
diff --git a/fem/ceed/solvers/solvers-atpmg.cpp b/fem/ceed/solvers/solvers-atpmg.cpp
index 8f4be00b2..603c92d44 100644
--- a/fem/ceed/solvers/solvers-atpmg.cpp
+++ b/fem/ceed/solvers/solvers-atpmg.cpp
@@ -11,15 +11,13 @@
 
 #include "solvers-atpmg.hpp"
 
-#include "../interface/ceed.hpp"
 #include "../interface/util.hpp"
-
 #ifdef MFEM_USE_CEED
 #include <ceed/backend.h>
-
+#endif
 #include <math.h>
-// todo: should probably use Ceed memory wrappers instead of calloc/free?
-#include <stdlib.h>
+
+#ifdef MFEM_USE_CEED
 
 namespace mfem
 {
@@ -86,17 +84,17 @@ int CeedATPMGElemRestriction(int order,
 {
    int ierr;
    Ceed ceed;
-   ierr = CeedElemRestrictionGetCeed(er_in, &ceed); CeedChk(ierr);
+   ierr = CeedElemRestrictionGetCeed(er_in, &ceed); PCeedChk(ierr);
 
    CeedInt numelem, numcomp, elemsize;
    CeedSize numnodes;
-   ierr = CeedElemRestrictionGetNumElements(er_in, &numelem); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetLVectorSize(er_in, &numnodes); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetElementSize(er_in, &elemsize); CeedChk(ierr);
-   ierr = CeedElemRestrictionGetNumComponents(er_in, &numcomp); CeedChk(ierr);
+   ierr = CeedElemRestrictionGetNumElements(er_in, &numelem); PCeedChk(ierr);
+   ierr = CeedElemRestrictionGetLVectorSize(er_in, &numnodes); PCeedChk(ierr);
+   ierr = CeedElemRestrictionGetElementSize(er_in, &elemsize); PCeedChk(ierr);
+   ierr = CeedElemRestrictionGetNumComponents(er_in, &numcomp); PCeedChk(ierr);
    if (numcomp != 1)
    {
-      // todo: multi-component will require more thought
+      // TODO: multi-component will require more thought
       return CeedError(ceed, 1, "Algebraic element restriction not "
                        "implemented for multiple components.");
    }
@@ -107,31 +105,31 @@ int CeedATPMGElemRestriction(int order,
 
    CeedVector in_lvec, in_evec;
    ierr = CeedElemRestrictionCreateVector(er_in, &in_lvec, &in_evec);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    // Create the elem_dof array from the given high-order ElemRestriction
    // by using it to map the L-vector indices to an E-vector
    CeedScalar * lvec_data;
    ierr = CeedVectorGetArrayWrite(in_lvec, CEED_MEM_HOST, &lvec_data);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    for (CeedSize i = 0; i < numnodes; ++i)
    {
       lvec_data[i] = (CeedScalar) i;
    }
-   ierr = CeedVectorRestoreArray(in_lvec, &lvec_data); CeedChk(ierr);
+   ierr = CeedVectorRestoreArray(in_lvec, &lvec_data); PCeedChk(ierr);
    CeedInt in_layout[3];
-   ierr = CeedElemRestrictionGetELayout(er_in, &in_layout); CeedChk(ierr);
+   ierr = CeedElemRestrictionGetELayout(er_in, &in_layout); PCeedChk(ierr);
    if (in_layout[0] == 0 && in_layout[1] == 0 && in_layout[2] == 0)
    {
       return CeedError(ceed, 1, "Cannot interpret e-vector ordering of given"
                        "CeedElemRestriction!");
    }
    ierr = CeedElemRestrictionApply(er_in, CEED_NOTRANSPOSE, in_lvec, in_evec,
-                                   CEED_REQUEST_IMMEDIATE); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&in_lvec); CeedChk(ierr);
+                                   CEED_REQUEST_IMMEDIATE); PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&in_lvec); PCeedChk(ierr);
    const CeedScalar * in_elem_dof;
    ierr = CeedVectorGetArrayRead(in_evec, CEED_MEM_HOST, &in_elem_dof);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    // Create a map (dof_map) that maps high-order ldof indices to
    // low-order ldof indices, with -1 indicating no correspondence
@@ -469,13 +467,13 @@ int CeedATPMGElemRestriction(int order,
                        "CeedATPMGElemRestriction does not yet support this dimension.");
    }
 
-   ierr = CeedVectorRestoreArrayRead(in_evec, &in_elem_dof); CeedChk(ierr);
-   ierr = CeedVectorDestroy(&in_evec); CeedChk(ierr);
+   ierr = CeedVectorRestoreArrayRead(in_evec, &in_elem_dof); PCeedChk(ierr);
+   ierr = CeedVectorDestroy(&in_evec); PCeedChk(ierr);
 
    ierr = CeedElemRestrictionCreate(ceed, numelem, coarse_elemsize, numcomp,
                                     0, running_out_ldof_count,
                                     CEED_MEM_HOST, CEED_COPY_VALUES, out_elem_dof,
-                                    er_out); CeedChk(ierr);
+                                    er_out); PCeedChk(ierr);
 
    delete [] out_elem_dof;
 
@@ -491,7 +489,7 @@ int CeedBasisATPMGCoarseToFine(Ceed ceed, int P1d, int dim, int order_reduction,
    // calling the following Ceed function)
    int ierr;
    ierr = CeedBasisCreateTensorH1Lagrange(ceed, dim, 1, P1d - order_reduction, P1d,
-                                          CEED_GAUSS_LOBATTO, basisc2f); CeedChk(ierr);
+                                          CEED_GAUSS_LOBATTO, basisc2f); PCeedChk(ierr);
    return 0;
 }
 
@@ -501,13 +499,13 @@ int CeedBasisATPMGCoarseToFine(CeedBasis basisin,
 {
    int ierr;
    Ceed ceed;
-   ierr = CeedBasisGetCeed(basisin, &ceed); CeedChk(ierr);
+   ierr = CeedBasisGetCeed(basisin, &ceed); PCeedChk(ierr);
 
    CeedInt dim, P1d;
-   ierr = CeedBasisGetDimension(basisin, &dim); CeedChk(ierr);
-   ierr = CeedBasisGetNumNodes1D(basisin, &P1d); CeedChk(ierr);
+   ierr = CeedBasisGetDimension(basisin, &dim); PCeedChk(ierr);
+   ierr = CeedBasisGetNumNodes1D(basisin, &P1d); PCeedChk(ierr);
    ierr = CeedBasisATPMGCoarseToFine(ceed, P1d, dim, order_reduction,
-                                     basisc2f); CeedChk(ierr);
+                                     basisc2f); PCeedChk(ierr);
    return 0;
 }
 
@@ -518,38 +516,38 @@ int CeedBasisATPMGCoarsen(CeedBasis basisin,
 {
    int ierr;
    Ceed ceed;
-   ierr = CeedBasisGetCeed(basisin, &ceed); CeedChk(ierr);
+   ierr = CeedBasisGetCeed(basisin, &ceed); PCeedChk(ierr);
 
    CeedInt dim, ncomp, P1d, Q1d;
-   ierr = CeedBasisGetDimension(basisin, &dim); CeedChk(ierr);
-   ierr = CeedBasisGetNumComponents(basisin, &ncomp); CeedChk(ierr);
-   ierr = CeedBasisGetNumNodes1D(basisin, &P1d); CeedChk(ierr);
-   ierr = CeedBasisGetNumQuadraturePoints1D(basisin, &Q1d); CeedChk(ierr);
+   ierr = CeedBasisGetDimension(basisin, &dim); PCeedChk(ierr);
+   ierr = CeedBasisGetNumComponents(basisin, &ncomp); PCeedChk(ierr);
+   ierr = CeedBasisGetNumNodes1D(basisin, &P1d); PCeedChk(ierr);
+   ierr = CeedBasisGetNumQuadraturePoints1D(basisin, &Q1d); PCeedChk(ierr);
 
    CeedInt coarse_P1d = P1d - order_reduction;
 
    const CeedScalar *interp1d;
-   ierr = CeedBasisGetInterp1D(basisin, &interp1d); CeedChk(ierr);
+   ierr = CeedBasisGetInterp1D(basisin, &interp1d); PCeedChk(ierr);
    const CeedScalar * grad1d;
-   ierr = CeedBasisGetGrad1D(basisin, &grad1d); CeedChk(ierr);
+   ierr = CeedBasisGetGrad1D(basisin, &grad1d); PCeedChk(ierr);
 
    CeedScalar * coarse_interp1d = new CeedScalar[coarse_P1d * Q1d];
    CeedScalar * coarse_grad1d = new CeedScalar[coarse_P1d * Q1d];
    CeedScalar * fine_nodal_points = new CeedScalar[P1d];
 
    // these things are in [-1, 1], not [0, 1], which matters
-   // (todo: how can we determine this or something related, algebraically?)
+   // (TODO: how can we determine this or something related, algebraically?)
    /* one way you might be able to tell is to just run this algorithm
       with coarse_P1d = 2 (i.e., linear) and look for symmetry in the coarse
       basis matrix? */
-   ierr = CeedLobattoQuadrature(P1d, fine_nodal_points, NULL); CeedChk(ierr);
+   ierr = CeedLobattoQuadrature(P1d, fine_nodal_points, NULL); PCeedChk(ierr);
    for (int i = 0; i < P1d; ++i)
    {
       fine_nodal_points[i] = 0.5 * fine_nodal_points[i] + 0.5; // cheating
    }
 
    const CeedScalar *interp_ctof;
-   ierr = CeedBasisGetInterp1D(basisc2f, &interp_ctof); CeedChk(ierr);
+   ierr = CeedBasisGetInterp1D(basisc2f, &interp_ctof); PCeedChk(ierr);
 
    for (int i = 0; i < Q1d; ++i)
    {
@@ -568,12 +566,12 @@ int CeedBasisATPMGCoarsen(CeedBasis basisin,
    }
 
    const CeedScalar * qref1d;
-   ierr = CeedBasisGetQRef(basisin, &qref1d); CeedChk(ierr);
+   ierr = CeedBasisGetQRef(basisin, &qref1d); PCeedChk(ierr);
    const CeedScalar * qweight1d;
-   ierr = CeedBasisGetQWeights(basisin, &qweight1d); CeedChk(ierr);
+   ierr = CeedBasisGetQWeights(basisin, &qweight1d); PCeedChk(ierr);
    ierr = CeedBasisCreateTensorH1(ceed, dim, ncomp,
                                   coarse_P1d, Q1d, coarse_interp1d, coarse_grad1d,
-                                  qref1d, qweight1d, basisout); CeedChk(ierr);
+                                  qref1d, qweight1d, basisout); PCeedChk(ierr);
 
    delete [] fine_nodal_points;
    delete [] coarse_interp1d;
@@ -593,19 +591,19 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
 
    int ierr;
    Ceed ceed;
-   ierr = CeedOperatorGetCeed(oper, &ceed); CeedChk(ierr);
+   ierr = CeedOperatorGetCeed(oper, &ceed); PCeedChk(ierr);
 
    CeedQFunction qf;
-   ierr = CeedOperatorGetQFunction(oper, &qf); CeedChk(ierr);
+   ierr = CeedOperatorGetQFunction(oper, &qf); PCeedChk(ierr);
    CeedInt numinputfields, numoutputfields;
    CeedQFunctionField *inputqfields, *outputqfields;
    ierr = CeedQFunctionGetFields(qf, &numinputfields, &inputqfields,
                                  &numoutputfields, &outputqfields);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    CeedOperatorField *inputfields, *outputfields;
    ierr = CeedOperatorGetFields(oper, &numinputfields, &inputfields,
                                 &numoutputfields, &outputfields);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    CeedElemRestriction * er_input = new CeedElemRestriction[numinputfields];
    CeedElemRestriction * er_output = new CeedElemRestriction[numoutputfields];
@@ -619,10 +617,11 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
    for (int i = 0; i < numinputfields; ++i)
    {
       ierr = CeedOperatorFieldGetElemRestriction(inputfields[i],
-                                                 &er_input[i]); CeedChk(ierr);
-      ierr = CeedOperatorFieldGetVector(inputfields[i], &if_vector[i]); CeedChk(ierr);
+                                                 &er_input[i]); PCeedChk(ierr);
+      ierr = CeedOperatorFieldGetVector(inputfields[i], &if_vector[i]);
+      PCeedChk(ierr);
       ierr = CeedOperatorFieldGetBasis(inputfields[i], &basis_input[i]);
-      CeedChk(ierr);
+      PCeedChk(ierr);
       if (if_vector[i] == CEED_VECTOR_ACTIVE)
       {
          if (active_input_basis < 0)
@@ -638,11 +637,11 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
    for (int i = 0; i < numoutputfields; ++i)
    {
       ierr = CeedOperatorFieldGetElemRestriction(outputfields[i],
-                                                 &er_output[i]); CeedChk(ierr);
+                                                 &er_output[i]); PCeedChk(ierr);
       ierr = CeedOperatorFieldGetVector(outputfields[i], &of_vector[i]);
-      CeedChk(ierr);
+      PCeedChk(ierr);
       ierr = CeedOperatorFieldGetBasis(outputfields[i], &basis_output[i]);
-      CeedChk(ierr);
+      PCeedChk(ierr);
       if (of_vector[i] == CEED_VECTOR_ACTIVE)
       {
          // should already be coarsened
@@ -659,36 +658,36 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
 
    CeedOperator coper;
    ierr = CeedOperatorCreate(ceed, qf, CEED_QFUNCTION_NONE, CEED_QFUNCTION_NONE,
-                             &coper); CeedChk(ierr);
+                             &coper); PCeedChk(ierr);
 
    for (int i = 0; i < numinputfields; ++i)
    {
       char * fieldname;
-      ierr = CeedQFunctionFieldGetName(inputqfields[i], &fieldname); CeedChk(ierr);
+      ierr = CeedQFunctionFieldGetName(inputqfields[i], &fieldname); PCeedChk(ierr);
       if (if_vector[i] == CEED_VECTOR_ACTIVE)
       {
          ierr = CeedOperatorSetField(coper, fieldname, coarse_er, cbasis,
-                                     if_vector[i]); CeedChk(ierr);
+                                     if_vector[i]); PCeedChk(ierr);
       }
       else
       {
          ierr = CeedOperatorSetField(coper, fieldname, er_input[i], basis_input[i],
-                                     if_vector[i]); CeedChk(ierr);
+                                     if_vector[i]); PCeedChk(ierr);
       }
    }
    for (int i = 0; i < numoutputfields; ++i)
    {
       char * fieldname;
-      ierr = CeedQFunctionFieldGetName(outputqfields[i], &fieldname); CeedChk(ierr);
+      ierr = CeedQFunctionFieldGetName(outputqfields[i], &fieldname); PCeedChk(ierr);
       if (of_vector[i] == CEED_VECTOR_ACTIVE)
       {
          ierr = CeedOperatorSetField(coper, fieldname, coarse_er, cbasis,
-                                     of_vector[i]); CeedChk(ierr);
+                                     of_vector[i]); PCeedChk(ierr);
       }
       else
       {
          ierr = CeedOperatorSetField(coper, fieldname, er_output[i], basis_output[i],
-                                     of_vector[i]); CeedChk(ierr);
+                                     of_vector[i]); PCeedChk(ierr);
       }
    }
    delete [] er_input;
@@ -711,21 +710,21 @@ int CeedATPMGOperator(CeedOperator oper, int order_reduction,
    int ierr;
 
    CeedQFunction qf;
-   ierr = CeedOperatorGetQFunction(oper, &qf); CeedChk(ierr);
+   ierr = CeedOperatorGetQFunction(oper, &qf); PCeedChk(ierr);
    CeedInt numinputfields, numoutputfields;
    CeedOperatorField *inputfields;
    ierr = CeedOperatorGetFields(oper, &numinputfields, &inputfields,
                                 &numoutputfields, NULL);
-   CeedChk(ierr);
+   PCeedChk(ierr);
 
    CeedBasis basis;
-   ierr = CeedOperatorGetActiveBasis(oper, &basis); CeedChk(ierr);
+   ierr = CeedOperatorGetActiveBasis(oper, &basis); PCeedChk(ierr);
    ierr = CeedBasisATPMGCoarseToFine(basis, basis_ctof_out, order_reduction);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    ierr = CeedBasisATPMGCoarsen(basis, *basis_ctof_out, coarse_basis_out,
-                                order_reduction); CeedChk(ierr);
+                                order_reduction); PCeedChk(ierr);
    ierr = CeedATPMGOperator(oper, order_reduction, coarse_er, *coarse_basis_out,
-                            *basis_ctof_out, out); CeedChk(ierr);
+                            *basis_ctof_out, out); PCeedChk(ierr);
    return 0;
 }
 
@@ -734,11 +733,11 @@ int CeedOperatorGetOrder(CeedOperator oper, CeedInt * order)
    int ierr;
 
    CeedOperatorField active_field;
-   ierr = CeedOperatorGetActiveField(oper, &active_field); CeedChk(ierr);
+   ierr = CeedOperatorGetActiveField(oper, &active_field); PCeedChk(ierr);
    CeedBasis basis;
-   ierr = CeedOperatorFieldGetBasis(active_field, &basis); CeedChk(ierr);
+   ierr = CeedOperatorFieldGetBasis(active_field, &basis); PCeedChk(ierr);
    int P1d;
-   ierr = CeedBasisGetNumNodes1D(basis, &P1d); CeedChk(ierr);
+   ierr = CeedBasisGetNumNodes1D(basis, &P1d); PCeedChk(ierr);
    *order = P1d - 1;
 
    return 0;
@@ -753,13 +752,13 @@ int CeedATPMGBundle(CeedOperator oper, int order_reduction,
 {
    int ierr;
    CeedInt order;
-   ierr = CeedOperatorGetOrder(oper, &order); CeedChk(ierr);
+   ierr = CeedOperatorGetOrder(oper, &order); PCeedChk(ierr);
    CeedElemRestriction ho_er;
-   ierr = CeedOperatorGetActiveElemRestriction(oper, &ho_er); CeedChk(ierr);
+   ierr = CeedOperatorGetActiveElemRestriction(oper, &ho_er); PCeedChk(ierr);
    ierr = CeedATPMGElemRestriction(order, order_reduction, ho_er, er_out, dof_map);
-   CeedChk(ierr);
+   PCeedChk(ierr);
    ierr = CeedATPMGOperator(oper, order_reduction, *er_out, coarse_basis_out,
-                            basis_ctof_out, coarse_oper); CeedChk(ierr);
+                            basis_ctof_out, coarse_oper); PCeedChk(ierr);
    return 0;
 }
 
diff --git a/fem/ceed/solvers/solvers-atpmg.hpp b/fem/ceed/solvers/solvers-atpmg.hpp
index 8d85b1840..62a1640fe 100644
--- a/fem/ceed/solvers/solvers-atpmg.hpp
+++ b/fem/ceed/solvers/solvers-atpmg.hpp
@@ -25,7 +25,7 @@ namespace ceed
 /** @brief Take given (high-order) CeedElemRestriction and make a new
     CeedElemRestriction, which corresponds to a lower-order problem.
 
-    Assumes a Gauss-Lobatto basis and tensor product elements, and assumes that
+    Assumes a Gauss-Lobatto basis and tensor-product elements, and assumes that
     the nodes in er_in are ordered in a tensor-product way.
 
     This is a setup routine that operates on the host.
diff --git a/fem/coefficient.cpp b/fem/coefficient.cpp
index 04b96a355..5b51454d6 100644
--- a/fem/coefficient.cpp
+++ b/fem/coefficient.cpp
@@ -187,8 +187,8 @@ double SphericalPolarCoefficient::Eval(ElementTransformation & T,
                 transip[2]);
 }
 
-double GridFunctionCoefficient::Eval (ElementTransformation &T,
-                                      const IntegrationPoint &ip)
+double GridFunctionCoefficient::Eval(ElementTransformation &T,
+                                     const IntegrationPoint &ip)
 {
    Mesh *gf_mesh = GridF->FESpace()->GetMesh();
    if (T.mesh->GetNE() == gf_mesh->GetNE())
@@ -673,12 +673,6 @@ void PWMatrixCoefficient::UpdateCoefficient(int attr, MatrixCoefficient & coef)
    MFEM_VERIFY(coef.GetWidth() == width,
                "PWMatrixCoefficient::UpdateCoefficient:  "
                "MatrixCoefficient has incompatible width.");
-   if (symmetric)
-   {
-      MFEM_VERIFY(coef.IsSymmetric(),
-                  "PWMatrixCoefficient::UpdateCoefficient:  "
-                  "MatrixCoefficient has incompatible symmetry.");
-   }
    pieces[attr] = &coef;
 }
 
@@ -730,68 +724,17 @@ void MatrixFunctionCoefficient::Eval(DenseMatrix &K, ElementTransformation &T,
 
    K.SetSize(height, width);
 
-   if (symmetric) // Use SymmFunction (deprecated version)
-   {
-      MFEM_VERIFY(height == width && SymmFunction,
-                  "MatrixFunctionCoefficient is not symmetric");
-
-      Vector Ksym((width * (width + 1)) / 2); // 1x1: 1, 2x2: 3, 3x3: 6
-
-      SymmFunction(transip, Ksym);
-
-      // Copy upper triangular values from Ksym to the full matrix K
-      int os = 0;
-      for (int i=0; i<height; ++i)
-      {
-         for (int j=i; j<width; ++j)
-         {
-            const double Kij = Ksym[j - i + os];
-            K(i,j) = Kij;
-            if (j != i) { K(j,i) = Kij; }
-         }
-
-         os += width - i;
-      }
-   }
-   else
+   if (Function)
    {
-      if (Function)
-      {
-         Function(transip, K);
-      }
-      else if (TDFunction)
-      {
-         TDFunction(transip, GetTime(), K);
-      }
-      else
-      {
-         K = mat;
-      }
+      Function(transip, K);
    }
-
-   if (Q)
+   else if (TDFunction)
    {
-      K *= Q->Eval(T, ip, GetTime());
+      TDFunction(transip, GetTime(), K);
    }
-}
-
-void MatrixFunctionCoefficient::EvalSymmetric(Vector &K,
-                                              ElementTransformation &T,
-                                              const IntegrationPoint &ip)
-{
-   MFEM_VERIFY(symmetric && height == width && SymmFunction,
-               "MatrixFunctionCoefficient is not symmetric");
-
-   double x[3];
-   Vector transip(x, 3);
-
-   T.Transform(ip, transip);
-
-   K.SetSize((width * (width + 1)) / 2); // 1x1: 1, 2x2: 3, 3x3: 6
-
-   if (SymmFunction)
+   else
    {
-      SymmFunction(transip, K);
+      K = mat;
    }
 
    if (Q)
@@ -832,7 +775,7 @@ void SymmetricMatrixCoefficient::Eval(DenseMatrix &K, ElementTransformation &T,
    Eval(mat, T, ip);
    for (int j = 0; j < width; ++j)
    {
-      for (int i = 0; i < height; ++ i)
+      for (int i = 0; i < height; ++i)
       {
          K(i, j) = mat(i, j);
       }
@@ -1832,3 +1775,4 @@ CoefficientVector::~CoefficientVector()
 }
 
 }
+
diff --git a/fem/coefficient.hpp b/fem/coefficient.hpp
index b98ac360b..ecc4ab7b1 100644
--- a/fem/coefficient.hpp
+++ b/fem/coefficient.hpp
@@ -106,7 +106,6 @@ private:
    Vector constants;
 
 public:
-
    /// Constructs a piecewise constant coefficient in NumOfSubD subdomains
    explicit PWConstCoefficient(int NumOfSubD = 0) : constants(NumOfSubD)
    { constants = 0.0; }
@@ -177,7 +176,6 @@ private:
                 const Array<Coefficient*> & coefs);
 
 public:
-
    /// Constructs a piecewise coefficient
    explicit PWCoefficient() {}
 
@@ -458,7 +456,6 @@ protected:
    double (*tdf)(double);
 
 public:
-
    /// Construct a unit delta function centered at (0.0,0.0,0.0)
    DeltaCoefficient()
    {
@@ -621,15 +618,16 @@ class VectorConstantCoefficient : public VectorCoefficient
 {
 private:
    Vector vec;
+
 public:
    /// Construct the coefficient with constant vector @a v.
    VectorConstantCoefficient(const Vector &v)
       : VectorCoefficient(v.Size()), vec(v) { }
-   using VectorCoefficient::Eval;
 
    ///  Evaluate the vector coefficient at @a ip.
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip) { V = vec; }
+   using VectorCoefficient::Eval;
 
    /// Return a reference to the constant vector in this class.
    const Vector& GetVec() const { return vec; }
@@ -679,7 +677,6 @@ private:
                 const Array<VectorCoefficient*> & coefs);
 
 public:
-
    /// Constructs a piecewise vector coefficient of dimension vd
    explicit PWVectorCoefficient(int vd): VectorCoefficient(vd) {}
 
@@ -763,10 +760,10 @@ public:
       : VectorCoefficient(dim), TDFunction(std::move(TDF)), Q(q)
    { }
 
-   using VectorCoefficient::Eval;
    /// Evaluate the vector coefficient at @a ip.
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    virtual ~VectorFunctionCoefficient() { }
 };
@@ -803,11 +800,11 @@ public:
    double Eval(int i, ElementTransformation &T, const IntegrationPoint &ip)
    { return Coeff[i] ? Coeff[i]->Eval(T, ip, GetTime()) : 0.0; }
 
-   using VectorCoefficient::Eval;
    /** @brief Evaluate the coefficient. Each element of vector V comes from the
        associated array of scalar coefficients. */
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    /// Destroys vector coefficient.
    virtual ~VectorArrayCoefficient();
@@ -862,7 +859,6 @@ protected:
    const GridFunction *GridFunc;
 
 public:
-
    /** @brief Construct the coefficient with a scalar grid function @a gf. The
        grid function is not owned by the coefficient. */
    GradientGridFunctionCoefficient(const GridFunction *gf);
@@ -903,10 +899,10 @@ public:
    /// Get the vector grid function.
    const GridFunction * GetGridFunction() const { return GridFunc; }
 
-   using VectorCoefficient::Eval;
    /// Evaluate the vector curl coefficient at @a ip.
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    virtual ~CurlGridFunctionCoefficient() { }
 };
@@ -995,12 +991,13 @@ public:
    virtual void EvalDelta(Vector &V, ElementTransformation &T,
                           const IntegrationPoint &ip);
 
-   using VectorCoefficient::Eval;
    /** @brief A VectorDeltaFunction cannot be evaluated. Calling this method
        will cause an MFEM error, terminating the application. */
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip)
    { mfem_error("VectorDeltaCoefficient::Eval"); }
+   using VectorCoefficient::Eval;
+
    virtual ~VectorDeltaCoefficient() { }
 };
 
@@ -1042,16 +1039,15 @@ class MatrixCoefficient
 protected:
    int height, width;
    double time;
-   bool symmetric;  // deprecated
 
 public:
    /// Construct a dim x dim matrix coefficient.
-   explicit MatrixCoefficient(int dim, bool symm=false)
-   { height = width = dim; time = 0.; symmetric = symm; }
+   explicit MatrixCoefficient(int dim)
+   { height = width = dim; time = 0.; }
 
    /// Construct a h x w matrix coefficient.
-   MatrixCoefficient(int h, int w, bool symm=false) :
-      height(h), width(w), time(0.), symmetric(symm) { }
+   MatrixCoefficient(int h, int w) :
+      height(h), width(w), time(0.) { }
 
    /// Set the time for time dependent coefficients
    virtual void SetTime(double t) { time = t; }
@@ -1068,9 +1064,6 @@ public:
    /// For backward compatibility get the width of the matrix.
    int GetVDim() const { return width; }
 
-   /** @deprecated Use SymmetricMatrixCoefficient instead */
-   bool IsSymmetric() const { return symmetric; }
-
    /** @brief Evaluate the matrix coefficient in the element described by @a T
        at the point @a ip, storing the result in @a K. */
    /** @note When this method is called, the caller must make sure that the
@@ -1087,17 +1080,6 @@ public:
    /// the width of the matrix.
    virtual void Project(QuadratureFunction &qf, bool transpose=false);
 
-   /// (DEPRECATED) Evaluate a symmetric matrix coefficient.
-   /** @brief Evaluate the upper triangular entries of the matrix coefficient
-       in the symmetric case, similarly to Eval. Matrix entry (i,j) is stored
-       in K[j - i + os_i] for 0 <= i <= j < width, os_0 = 0,
-       os_{i+1} = os_i + width - i. That is, K = {M(0,0), ..., M(0,w-1),
-       M(1,1), ..., M(1,w-1), ..., M(w-1,w-1) with w = width.
-       @deprecated Use Eval() instead. */
-   virtual void EvalSymmetric(Vector &K, ElementTransformation &T,
-                              const IntegrationPoint &ip)
-   { mfem_error("MatrixCoefficient::EvalSymmetric"); }
-
    virtual ~MatrixCoefficient() { }
 };
 
@@ -1107,14 +1089,17 @@ class MatrixConstantCoefficient : public MatrixCoefficient
 {
 private:
    DenseMatrix mat;
+
 public:
    ///Construct using matrix @a m for the constant.
    MatrixConstantCoefficient(const DenseMatrix &m)
       : MatrixCoefficient(m.Height(), m.Width()), mat(m) { }
-   using MatrixCoefficient::Eval;
+
    /// Evaluate the matrix coefficient at @a ip.
    virtual void Eval(DenseMatrix &M, ElementTransformation &T,
                      const IntegrationPoint &ip) { M = mat; }
+   using MatrixCoefficient::Eval;
+
    /// Return a reference to the constant matrix.
    const DenseMatrix& GetMatrix() { return mat; }
 };
@@ -1164,20 +1149,18 @@ private:
                 const Array<MatrixCoefficient*> & coefs);
 
 public:
-
    /// Constructs a piecewise matrix coefficient of dimension dim by dim
-   explicit PWMatrixCoefficient(int dim, bool symm = false)
-      : MatrixCoefficient(dim, symm) {}
+   explicit PWMatrixCoefficient(int dim)
+      : MatrixCoefficient(dim) {}
 
    /// Constructs a piecewise matrix coefficient of dimension h by w
-   explicit PWMatrixCoefficient(int h, int w, bool symm = false)
-      : MatrixCoefficient(h, w, symm) {}
+   explicit PWMatrixCoefficient(int h, int w)
+      : MatrixCoefficient(h, w) {}
 
    /// Construct the coefficient using arrays describing the pieces
    /** \param dim - size of the square matrix-valued result
        \param attr - an array of attribute numbers for each piece
        \param coefs - the corresponding array of MatrixCoefficient pointers
-       \param symm - true if the result will be symmetric, false otherwise
        Any missing attributes or NULL coefficient pointers will result in a
        zero matrix being returned.
 
@@ -1185,16 +1168,14 @@ public:
        transferred to this object.
    */
    PWMatrixCoefficient(int dim, const Array<int> & attr,
-                       const Array<MatrixCoefficient*> & coefs,
-                       bool symm=false)
-      : MatrixCoefficient(dim, symm) { InitMap(attr, coefs); }
+                       const Array<MatrixCoefficient*> & coefs)
+      : MatrixCoefficient(dim) { InitMap(attr, coefs); }
 
    /// Construct the coefficient using arrays describing the pieces
    /** \param h - height of the matrix-valued result
        \param w - width of the matrix-valued result
        \param attr - an array of attribute numbers for each piece
        \param coefs - the corresponding array of MatrixCoefficient pointers
-       \param symm - true if the result will be symmetric, false otherwise
        Any missing attributes or NULL coefficient pointers will result in a
        zero matrix being returned for that attribute.
 
@@ -1202,9 +1183,8 @@ public:
        transferred to this object.
    */
    PWMatrixCoefficient(int h, int w, const Array<int> & attr,
-                       const Array<MatrixCoefficient*> & coefs,
-                       bool symm=false)
-      : MatrixCoefficient(h, w, symm) { InitMap(attr, coefs); }
+                       const Array<MatrixCoefficient*> & coefs)
+      : MatrixCoefficient(h, w) { InitMap(attr, coefs); }
 
    /// Set the time for time dependent coefficients
    virtual void SetTime(double t);
@@ -1233,7 +1213,6 @@ class MatrixFunctionCoefficient : public MatrixCoefficient
 {
 private:
    std::function<void(const Vector &, DenseMatrix &)> Function;
-   std::function<void(const Vector &, Vector &)> SymmFunction;  // deprecated
    std::function<void(const Vector &, double, DenseMatrix &)> TDFunction;
 
    Coefficient *Q;
@@ -1257,28 +1236,6 @@ public:
       : MatrixCoefficient(m.Height(), m.Width()), Q(&q), mat(m)
    { }
 
-   /** @brief Define a time-independent symmetric square matrix coefficient from
-       a std function */
-   /** \param dim - the size of the matrix
-       \param SymmF - function used in EvalSymmetric
-       \param q - optional scalar Coefficient to scale the matrix coefficient
-       @deprecated Use another constructor without setting SymmFunction. */
-   MatrixFunctionCoefficient(int dim,
-                             std::function<void(const Vector &, Vector &)> SymmF,
-                             Coefficient *q = NULL)
-      : MatrixCoefficient(dim, true), SymmFunction(std::move(SymmF)), Q(q), mat(0)
-   { }
-
-   /// Define a time-dependent square matrix coefficient from a std function
-   /** \param dim - the size of the matrix
-       \param TDF - time-dependent function
-       \param q - optional scalar Coefficient to scale the matrix coefficient */
-   MatrixFunctionCoefficient(int dim,
-                             std::function<void(const Vector &, double, DenseMatrix &)> TDF,
-                             Coefficient *q = nullptr)
-      : MatrixCoefficient(dim), TDFunction(std::move(TDF)), Q(q)
-   { }
-
    /// Set the time for internally stored coefficients
    void SetTime(double t);
 
@@ -1286,11 +1243,6 @@ public:
    virtual void Eval(DenseMatrix &K, ElementTransformation &T,
                      const IntegrationPoint &ip);
 
-   /// (DEPRECATED) Evaluate the symmetric matrix coefficient at @a ip.
-   /** @deprecated Use Eval() instead. */
-   virtual void EvalSymmetric(Vector &K, ElementTransformation &T,
-                              const IntegrationPoint &ip);
-
    virtual ~MatrixFunctionCoefficient() { }
 };
 
@@ -1320,12 +1272,11 @@ public:
        can be overridden with the @a own parameter. */
    void Set(int i, int j, Coefficient * c, bool own=true);
 
-   using MatrixCoefficient::Eval;
-
    /// Evaluate coefficient located at (i,j) in the matrix using integration
    /// point @a ip.
    double Eval(int i, int j, ElementTransformation &T, const IntegrationPoint &ip)
    { return Coeff[i*width+j] ? Coeff[i*width+j] -> Eval(T, ip, GetTime()) : 0.0; }
+   using MatrixCoefficient::Eval;
 
    /// Evaluate the matrix coefficient @a ip.
    virtual void Eval(DenseMatrix &K, ElementTransformation &T,
@@ -1428,10 +1379,11 @@ class SymmetricMatrixCoefficient : public MatrixCoefficient
 protected:
    /// Internal matrix used when evaluating this coefficient as a DenseMatrix.
    DenseSymmetricMatrix mat;
+
 public:
    /// Construct a dim x dim matrix coefficient.
    explicit SymmetricMatrixCoefficient(int dimension)
-      : MatrixCoefficient(dimension, true) { }
+      : MatrixCoefficient(dimension) { }
 
    /// Get the size of the matrix.
    int GetSize() const { return height; }
@@ -1481,10 +1433,11 @@ public:
    ///Construct using matrix @a m for the constant.
    SymmetricMatrixConstantCoefficient(const DenseSymmetricMatrix &m)
       : SymmetricMatrixCoefficient(m.Height()), mat(m) { }
-   using SymmetricMatrixCoefficient::Eval;
+
    /// Evaluate the matrix coefficient at @a ip.
    virtual void Eval(DenseSymmetricMatrix &M, ElementTransformation &T,
                      const IntegrationPoint &ip) { M = mat; }
+   using SymmetricMatrixCoefficient::Eval;
 };
 
 
@@ -1532,10 +1485,10 @@ public:
    /// Set the time for internally stored coefficients
    void SetTime(double t);
 
-   using SymmetricMatrixCoefficient::Eval;
    /// Evaluate the matrix coefficient at @a ip.
    virtual void Eval(DenseSymmetricMatrix &K, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using SymmetricMatrixCoefficient::Eval;
 
    virtual ~SymmetricMatrixFunctionCoefficient() { }
 };
@@ -1682,6 +1635,7 @@ private:
 
    mutable Vector va;
    mutable Vector vb;
+
 public:
    /// Construct with the two vector coefficients.  Result is \f$ A \cdot B \f$.
    InnerProductCoefficient(VectorCoefficient &A, VectorCoefficient &B);
@@ -2254,9 +2208,9 @@ public:
 
    const QuadratureFunction& GetQuadFunction() const { return QuadF; }
 
-   using VectorCoefficient::Eval;
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    virtual void Project(QuadratureFunction &qf);
 
@@ -2320,6 +2274,7 @@ protected:
    int vdim; ///< Number of values per quadrature point.
    QuadratureSpaceBase &qs; ///< Associated QuadratureSpaceBase.
    QuadratureFunction *qf; ///< Internal QuadratureFunction (owned, may be NULL).
+
 public:
    /// Create an empty CoefficientVector.
    CoefficientVector(QuadratureSpaceBase &qs_,
@@ -2421,3 +2376,4 @@ double ComputeGlobalLpNorm(double p, VectorCoefficient &coeff, ParMesh &pmesh,
 }
 
 #endif
+
diff --git a/fem/doftrans.cpp b/fem/doftrans.cpp
index 93d5588de..27bfc05e2 100644
--- a/fem/doftrans.cpp
+++ b/fem/doftrans.cpp
@@ -60,16 +60,15 @@ void TransformDual(const DofTransformation *ran_dof_trans,
    }
 }
 
-void StatelessVDofTransformation::TransformPrimal(const Array<int> & face_ori,
-                                                  double *v) const
+void VDofTransformation::TransformPrimal(double *v) const
 {
-   int size = sdoftrans_->Size();
+   int size = dof_trans_->Size();
 
    if ((Ordering::Type)ordering_ == Ordering::byNODES || vdim_ == 1)
    {
       for (int i=0; i<vdim_; i++)
       {
-         sdoftrans_->TransformPrimal(face_ori, &v[i*size]);
+         dof_trans_->TransformPrimal(Fo, &v[i*size]);
       }
    }
    else
@@ -81,7 +80,7 @@ void StatelessVDofTransformation::TransformPrimal(const Array<int> & face_ori,
          {
             vec(j) = v[j*vdim_+i];
          }
-         sdoftrans_->TransformPrimal(face_ori, vec);
+         dof_trans_->TransformPrimal(Fo, vec);
          for (int j=0; j<size; j++)
          {
             v[j*vdim_+i] = vec(j);
@@ -90,17 +89,15 @@ void StatelessVDofTransformation::TransformPrimal(const Array<int> & face_ori,
    }
 }
 
-void StatelessVDofTransformation::InvTransformPrimal(
-   const Array<int> & face_ori,
-   double *v) const
+void VDofTransformation::InvTransformPrimal(double *v) const
 {
-   int size = sdoftrans_->Height();
+   int size = dof_trans_->Height();
 
    if ((Ordering::Type)ordering_ == Ordering::byNODES)
    {
       for (int i=0; i<vdim_; i++)
       {
-         sdoftrans_->InvTransformPrimal(face_ori, &v[i*size]);
+         dof_trans_->InvTransformPrimal(Fo, &v[i*size]);
       }
    }
    else
@@ -112,7 +109,7 @@ void StatelessVDofTransformation::InvTransformPrimal(
          {
             vec(j) = v[j*vdim_+i];
          }
-         sdoftrans_->InvTransformPrimal(face_ori, vec);
+         dof_trans_->InvTransformPrimal(Fo, vec);
          for (int j=0; j<size; j++)
          {
             v[j*vdim_+i] = vec(j);
@@ -121,16 +118,15 @@ void StatelessVDofTransformation::InvTransformPrimal(
    }
 }
 
-void StatelessVDofTransformation::TransformDual(const Array<int> & face_ori,
-                                                double *v) const
+void VDofTransformation::TransformDual(double *v) const
 {
-   int size = sdoftrans_->Size();
+   int size = dof_trans_->Size();
 
    if ((Ordering::Type)ordering_ == Ordering::byNODES)
    {
       for (int i=0; i<vdim_; i++)
       {
-         sdoftrans_->TransformDual(face_ori, &v[i*size]);
+         dof_trans_->TransformDual(Fo, &v[i*size]);
       }
    }
    else
@@ -142,7 +138,7 @@ void StatelessVDofTransformation::TransformDual(const Array<int> & face_ori,
          {
             vec(j) = v[j*vdim_+i];
          }
-         sdoftrans_->TransformDual(face_ori, vec);
+         dof_trans_->TransformDual(Fo, vec);
          for (int j=0; j<size; j++)
          {
             v[j*vdim_+i] = vec(j);
@@ -151,16 +147,15 @@ void StatelessVDofTransformation::TransformDual(const Array<int> & face_ori,
    }
 }
 
-void StatelessVDofTransformation::InvTransformDual(const Array<int> & face_ori,
-                                                   double *v) const
+void VDofTransformation::InvTransformDual(double *v) const
 {
-   int size = sdoftrans_->Size();
+   int size = dof_trans_->Size();
 
    if ((Ordering::Type)ordering_ == Ordering::byNODES)
    {
       for (int i=0; i<vdim_; i++)
       {
-         sdoftrans_->InvTransformDual(face_ori, &v[i*size]);
+         dof_trans_->InvTransformDual(Fo, &v[i*size]);
       }
    }
    else
@@ -172,7 +167,7 @@ void StatelessVDofTransformation::InvTransformDual(const Array<int> & face_ori,
          {
             vec(j) = v[j*vdim_+i];
          }
-         sdoftrans_->InvTransformDual(face_ori, vec);
+         dof_trans_->InvTransformDual(Fo, vec);
          for (int j=0; j<size; j++)
          {
             v[j*vdim_+i] = vec(j);
@@ -182,7 +177,7 @@ void StatelessVDofTransformation::InvTransformDual(const Array<int> & face_ori,
 }
 
 // ordering (i0j0, i1j0, i0j1, i1j1), each row is a column major matrix
-const double ND_StatelessDofTransformation::T_data[24] =
+const double ND_DofTransformation::T_data[24] =
 {
    1.0,  0.0,  0.0,  1.0,
    -1.0, -1.0,  0.0,  1.0,
@@ -192,11 +187,11 @@ const double ND_StatelessDofTransformation::T_data[24] =
    0.0,  1.0,  1.0,  0.0
 };
 
-const DenseTensor ND_StatelessDofTransformation
-::T(const_cast<double*>(ND_StatelessDofTransformation::T_data), 2, 2, 6);
+const DenseTensor ND_DofTransformation
+::T(const_cast<double *>(ND_DofTransformation::T_data), 2, 2, 6);
 
 // ordering (i0j0, i1j0, i0j1, i1j1), each row is a column major matrix
-const double ND_StatelessDofTransformation::TInv_data[24] =
+const double ND_DofTransformation::TInv_data[24] =
 {
    1.0,  0.0,  0.0,  1.0,
    -1.0, -1.0,  0.0,  1.0,
@@ -206,12 +201,11 @@ const double ND_StatelessDofTransformation::TInv_data[24] =
    0.0,  1.0,  1.0,  0.0
 };
 
-const DenseTensor ND_StatelessDofTransformation
-::TInv(const_cast<double*>(TInv_data), 2, 2, 6);
+const DenseTensor ND_DofTransformation
+::TInv(const_cast<double *>(TInv_data), 2, 2, 6);
 
-ND_StatelessDofTransformation::ND_StatelessDofTransformation(int size, int p,
-                                                             int num_edges,
-                                                             int num_tri_faces)
+ND_DofTransformation::ND_DofTransformation(int size, int p, int num_edges,
+                                           int num_tri_faces)
    : StatelessDofTransformation(size)
    , order(p)
    , nedofs(p)
@@ -221,18 +215,19 @@ ND_StatelessDofTransformation::ND_StatelessDofTransformation(int size, int p,
 {
 }
 
-void ND_StatelessDofTransformation::TransformPrimal(const Array<int> & Fo,
-                                                    double *v) const
+void ND_DofTransformation::TransformPrimal(const Array<int> & Fo,
+                                           double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= nfaces,
                "Face orientation array is shorter than the number of faces in "
-               "ND_StatelessDofTransformation");
+               "ND_DofTransformation");
 
    double data[2];
    Vector v2(data, 2);
+   DenseMatrix T2;
 
    // Transform face DoFs
    for (int f=0; f<nfaces; f++)
@@ -240,23 +235,25 @@ void ND_StatelessDofTransformation::TransformPrimal(const Array<int> & Fo,
       for (int i=0; i<nfdofs/2; i++)
       {
          v2 = &v[nedges*nedofs + f*nfdofs + 2*i];
-         T(Fo[f]).Mult(v2, &v[nedges*nedofs + f*nfdofs + 2*i]);
+         T2.UseExternalData(const_cast<double *>(T.GetData(Fo[f])), 2, 2);
+         T2.Mult(v2, &v[nedges*nedofs + f*nfdofs + 2*i]);
       }
    }
 }
 
-void ND_StatelessDofTransformation::InvTransformPrimal(const Array<int> & Fo,
-                                                       double *v) const
+void ND_DofTransformation::InvTransformPrimal(const Array<int> & Fo,
+                                              double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= nfaces,
                "Face orientation array is shorter than the number of faces in "
-               "ND_StatelessDofTransformation");
+               "ND_DofTransformation");
 
    double data[2];
    Vector v2(data, 2);
+   DenseMatrix T2Inv;
 
    // Transform face DoFs
    for (int f=0; f<nfaces; f++)
@@ -264,23 +261,24 @@ void ND_StatelessDofTransformation::InvTransformPrimal(const Array<int> & Fo,
       for (int i=0; i<nfdofs/2; i++)
       {
          v2 = &v[nedges*nedofs + f*nfdofs + 2*i];
-         TInv(Fo[f]).Mult(v2, &v[nedges*nedofs + f*nfdofs + 2*i]);
+         T2Inv.UseExternalData(const_cast<double *>(TInv.GetData(Fo[f])), 2, 2);
+         T2Inv.Mult(v2, &v[nedges*nedofs + f*nfdofs + 2*i]);
       }
    }
 }
 
-void ND_StatelessDofTransformation::TransformDual(const Array<int> & Fo,
-                                                  double *v) const
+void ND_DofTransformation::TransformDual(const Array<int> & Fo, double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= nfaces,
                "Face orientation array is shorter than the number of faces in "
-               "ND_StatelessDofTransformation");
+               "ND_DofTransformation");
 
    double data[2];
    Vector v2(data, 2);
+   DenseMatrix T2Inv;
 
    // Transform face DoFs
    for (int f=0; f<nfaces; f++)
@@ -288,23 +286,25 @@ void ND_StatelessDofTransformation::TransformDual(const Array<int> & Fo,
       for (int i=0; i<nfdofs/2; i++)
       {
          v2 = &v[nedges*nedofs + f*nfdofs + 2*i];
-         TInv(Fo[f]).MultTranspose(v2, &v[nedges*nedofs + f*nfdofs + 2*i]);
+         T2Inv.UseExternalData(const_cast<double *>(TInv.GetData(Fo[f])), 2, 2);
+         T2Inv.MultTranspose(v2, &v[nedges*nedofs + f*nfdofs + 2*i]);
       }
    }
 }
 
-void ND_StatelessDofTransformation::InvTransformDual(const Array<int> & Fo,
-                                                     double *v) const
+void ND_DofTransformation::InvTransformDual(const Array<int> & Fo,
+                                            double *v) const
 {
    // Return immediately when no face DoFs are present
-   if (nfdofs < 2) { return; }
+   if (IsEmpty()) { return; }
 
    MFEM_VERIFY(Fo.Size() >= nfaces,
                "Face orientation array is shorter than the number of faces in "
-               "ND_StatelessDofTransformation");
+               "ND_DofTransformation");
 
    double data[2];
    Vector v2(data, 2);
+   DenseMatrix T2;
 
    // Transform face DoFs
    for (int f=0; f<nfaces; f++)
@@ -312,7 +312,8 @@ void ND_StatelessDofTransformation::InvTransformDual(const Array<int> & Fo,
       for (int i=0; i<nfdofs/2; i++)
       {
          v2 = &v[nedges*nedofs + f*nfdofs + 2*i];
-         T(Fo[f]).MultTranspose(v2, &v[nedges*nedofs + f*nfdofs + 2*i]);
+         T2.UseExternalData(const_cast<double *>(T.GetData(Fo[f])), 2, 2);
+         T2.MultTranspose(v2, &v[nedges*nedofs + f*nfdofs + 2*i]);
       }
    }
 }
diff --git a/fem/doftrans.hpp b/fem/doftrans.hpp
index 1bad23185..001f9b647 100644
--- a/fem/doftrans.hpp
+++ b/fem/doftrans.hpp
@@ -80,6 +80,9 @@ public:
    inline int Width() const { return size_; }
    inline int NumCols() const { return size_; }
 
+   /// If the DofTransformation performs no transformation
+   virtual bool IsEmpty() const = 0;
+
    /** Transform local DoFs to align with the global DoFs. For example, this
        transformation can be used to map the local vector computed by
        FiniteElement::Project() to the transformed vector stored within a
@@ -115,6 +118,8 @@ public:
    inline void InvTransformDual(const Array<int> & face_orientation,
                                 Vector &v) const
    { InvTransformDual(face_orientation, v.GetData()); }
+
+   virtual ~StatelessDofTransformation() = default;
 };
 
 /** The DofTransformation class is an extension of the
@@ -133,15 +138,22 @@ public:
     transferring finite element degrees of freedom between different meshes.
     For examples of its use see the TransferMap used by the SubMesh class.
    */
-class DofTransformation : virtual public StatelessDofTransformation
+class DofTransformation
 {
 protected:
    Array<int> Fo;
-
-   DofTransformation(int size)
-      : StatelessDofTransformation(size) {}
+   StatelessDofTransformation * dof_trans_;
 
 public:
+   /** @brief Default constructor which requires that SetDofTransformation be
+       called before use. */
+   DofTransformation() : dof_trans_(NULL)
+   {}
+
+   /// Constructor with a known StatelessDofTransformation
+   DofTransformation(StatelessDofTransformation & dof_trans)
+      : dof_trans_(&dof_trans)
+   {}
 
    /** @brief Configure the transformation using face orientations for the
        current element. */
@@ -149,19 +161,37 @@ public:
    inline void SetFaceOrientations(const Array<int> & face_orientation)
    { Fo = face_orientation; }
 
+   /// Return the face orientations for the current element
    inline const Array<int> & GetFaceOrientations() const { return Fo; }
 
-   using StatelessDofTransformation::TransformPrimal;
-   using StatelessDofTransformation::InvTransformPrimal;
-   using StatelessDofTransformation::TransformDual;
-   using StatelessDofTransformation::InvTransformDual;
+   /// Set or change the nested StatelessDofTransformation object
+   inline void SetDofTransformation(StatelessDofTransformation & dof_trans)
+   {
+      dof_trans_ = &dof_trans;
+   }
+   inline void SetDofTransformation(StatelessDofTransformation * dof_trans)
+   {
+      dof_trans_ = dof_trans;
+   }
+
+   /// Return the nested StatelessDofTransformation object
+   inline StatelessDofTransformation * GetDofTransformation() const
+   { return dof_trans_; }
+
+   inline int Size() const { return dof_trans_->Size(); }
+   inline int Height() const { return dof_trans_->Height(); }
+   inline int NumRows() const { return dof_trans_->NumRows(); }
+   inline int Width() const { return dof_trans_->Width(); }
+   inline int NumCols() const { return dof_trans_->NumCols(); }
+
+   inline bool IsEmpty() const { return dof_trans_->IsEmpty(); }
 
    /** Transform local DoFs to align with the global DoFs. For example, this
        transformation can be used to map the local vector computed by
        FiniteElement::Project() to the transformed vector stored within a
        GridFunction object. */
-   inline void TransformPrimal(double *v) const
-   { TransformPrimal(Fo, v); }
+   virtual inline void TransformPrimal(double *v) const
+   { dof_trans_->TransformPrimal(Fo, v); }
    inline void TransformPrimal(Vector &v) const
    { TransformPrimal(v.GetData()); }
 
@@ -179,21 +209,21 @@ public:
        transform the vector obtained using GridFunction::GetSubVector before it
        can be used to compute a local interpolation.
    */
-   inline void InvTransformPrimal(double *v) const
-   { InvTransformPrimal(Fo, v); }
+   virtual inline void InvTransformPrimal(double *v) const
+   { dof_trans_->InvTransformPrimal(Fo, v); }
    inline void InvTransformPrimal(Vector &v) const
    { InvTransformPrimal(v.GetData()); }
 
    /** Transform dual DoFs as computed by a LinearFormIntegrator before summing
        into a LinearForm object. */
-   inline void TransformDual(double *v) const
-   { TransformDual(Fo, v); }
+   virtual inline void TransformDual(double *v) const
+   { dof_trans_->TransformDual(Fo, v); }
    inline void TransformDual(Vector &v) const
    { TransformDual(v.GetData()); }
 
    /** Inverse Transform dual DoFs */
-   inline void InvTransformDual(double *v) const
-   { InvTransformDual(Fo, v); }
+   virtual inline void InvTransformDual(double *v) const
+   { dof_trans_->InvTransformDual(Fo, v); }
    inline void InvTransformDual(Vector &v) const
    { InvTransformDual(v.GetData()); }
 
@@ -245,143 +275,50 @@ void TransformDual(const DofTransformation *ran_dof_trans,
                    const DofTransformation *dom_dof_trans,
                    DenseMatrix &elmat);
 
-/** The StatelessVDofTransformation class implements a nested transformation
-    where an arbitrary StatelessDofTransformation is replicated with a
-    vdim >= 1.
+/** The VDofTransformation class implements a nested transformation where an
+    arbitrary StatelessDofTransformation is replicated with a vdim >= 1.
 */
-class StatelessVDofTransformation : virtual public StatelessDofTransformation
+class VDofTransformation : public DofTransformation
 {
 protected:
    int vdim_;
    int ordering_;
-   StatelessDofTransformation * sdoftrans_;
 
 public:
    /** @brief Default constructor which requires that SetDofTransformation be
        called before use. */
-   StatelessVDofTransformation(int vdim = 1, int ordering = 0)
-      : StatelessDofTransformation(0)
+   VDofTransformation(int vdim = 1, int ordering = 0)
+      : DofTransformation()
       , vdim_(vdim)
       , ordering_(ordering)
-      , sdoftrans_(NULL)
    {}
 
    /// Constructor with a known StatelessDofTransformation
-   StatelessVDofTransformation(StatelessDofTransformation & doftrans,
-                               int vdim = 1,
-                               int ordering = 0)
-      : StatelessDofTransformation(vdim * doftrans.Size())
+   VDofTransformation(StatelessDofTransformation & dof_trans, int vdim = 1,
+                      int ordering = 0)
+      : DofTransformation(dof_trans)
       , vdim_(vdim)
       , ordering_(ordering)
-      , sdoftrans_(&doftrans)
    {}
 
    /// Set or change the vdim parameter
-   inline void SetVDim(int vdim)
-   {
-      vdim_ = vdim;
-      if (sdoftrans_)
-      {
-         size_ = vdim_ * sdoftrans_->Size();
-      }
-   }
+   inline void SetVDim(int vdim) { vdim_ = vdim; }
 
    /// Return the current vdim value
    inline int GetVDim() const { return vdim_; }
 
-   /// Set or change the nested StatelessDofTransformation object
-   inline void SetDofTransformation(StatelessDofTransformation & doftrans)
-   {
-      size_ = vdim_ * doftrans.Size();
-      sdoftrans_ = &doftrans;
-   }
-
-   /// Return the nested StatelessDofTransformation object
-   inline StatelessDofTransformation * GetDofTransformation() const
-   { return sdoftrans_; }
-
-   using StatelessDofTransformation::TransformPrimal;
-   using StatelessDofTransformation::InvTransformPrimal;
-   using StatelessDofTransformation::TransformDual;
-   using StatelessDofTransformation::InvTransformDual;
-
-   /** Specializations of these base class methods which account for the vdim
-       and ordering of the full set of DoFs.
-   */
-   void TransformPrimal(const Array<int> & face_ori, double *v) const;
-   void InvTransformPrimal(const Array<int> & face_ori, double *v) const;
-   void TransformDual(const Array<int> & face_ori, double *v) const;
-   void InvTransformDual(const Array<int> & face_ori, double *v) const;
-};
-
-/** The VDofTransformation class implements a nested transformation where an
-    arbitrary DofTransformation is replicated with a vdim >= 1.
-*/
-class VDofTransformation : public StatelessVDofTransformation,
-   public DofTransformation
-{
-protected:
-   DofTransformation * doftrans_;
-
-public:
-   /** @brief Default constructor which requires that SetDofTransformation be
-       called before use. */
-   VDofTransformation(int vdim = 1, int ordering = 0)
-      : StatelessDofTransformation(0)
-      , StatelessVDofTransformation(vdim, ordering)
-      , DofTransformation(0)
-      , doftrans_(NULL)
-   {}
-
-   /// Constructor with a known DofTransformation
-   /// @note The face orientations in @a doftrans will be copied into the
-   /// new VDofTransformation object.
-   VDofTransformation(DofTransformation & doftrans, int vdim = 1,
-                      int ordering = 0)
-      : StatelessDofTransformation(vdim * doftrans.Size())
-      , StatelessVDofTransformation(doftrans, vdim, ordering)
-      , DofTransformation(vdim * doftrans.Size())
-      , doftrans_(&doftrans)
-   {
-      DofTransformation::SetFaceOrientations(doftrans.GetFaceOrientations());
-   }
-
-   using StatelessVDofTransformation::SetDofTransformation;
-
-   /// Set or change the nested DofTransformation object
-   /// @note The face orientations in @a doftrans will be copied into the
-   /// VDofTransformation object.
-   void SetDofTransformation(DofTransformation & doftrans)
-   {
-      doftrans_ = &doftrans;
-      StatelessVDofTransformation::SetDofTransformation(doftrans);
-      DofTransformation::SetFaceOrientations(doftrans.GetFaceOrientations());
-   }
-
-   /// Return the nested DofTransformation object
-   inline DofTransformation * GetDofTransformation() const { return doftrans_; }
-
-   /// Set new face orientations in both the VDofTransformation and the
-   /// DofTransformation contained within (if there is one).
-   inline void SetFaceOrientations(const Array<int> & face_orientation)
-   {
-      DofTransformation::SetFaceOrientations(face_orientation);
-      if (doftrans_) { doftrans_->SetFaceOrientations(face_orientation); }
-   }
-
    using DofTransformation::TransformPrimal;
    using DofTransformation::InvTransformPrimal;
    using DofTransformation::TransformDual;
    using DofTransformation::InvTransformDual;
 
-   inline void TransformPrimal(double *v) const
-   { TransformPrimal(Fo, v); }
-   inline void InvTransformPrimal(double *v) const
-   { InvTransformPrimal(Fo, v); }
-   inline void TransformDual(double *v) const
-   { TransformDual(Fo, v); }
-   inline void InvTransformDual(double *v) const
-   { InvTransformDual(Fo, v); }
+   /** Specializations of these base class methods which account for the vdim
+       and ordering of the full set of DoFs.
+   */
+   void TransformPrimal(double *v) const;
+   void InvTransformPrimal(double *v) const;
+   void TransformDual(double *v) const;
+   void InvTransformDual(double *v) const;
 };
 
 /** Abstract base class for high-order Nedelec spaces on elements with
@@ -396,7 +333,7 @@ public:
     be accessed as DenseMatrices using the GetFaceTransform() and
     GetFaceInverseTransform() methods.
 */
-class ND_StatelessDofTransformation : virtual public StatelessDofTransformation
+class ND_DofTransformation : public StatelessDofTransformation
 {
 private:
    static const double T_data[24];
@@ -410,8 +347,7 @@ protected:
    const int nedges; // number of edges per element
    const int nfaces; // number of triangular faces per element
 
-   ND_StatelessDofTransformation(int size, int order,
-                                 int num_edges, int num_tri_faces);
+   ND_DofTransformation(int size, int order, int num_edges, int num_tri_faces);
 
 public:
    // Return the 2x2 transformation operator for the given face orientation
@@ -421,116 +357,41 @@ public:
    static const DenseMatrix & GetFaceInverseTransform(int ori)
    { return TInv(ori); }
 
-   void TransformPrimal(const Array<int> & face_orientation,
-                        double *v) const;
-
-   void InvTransformPrimal(const Array<int> & face_orientation,
-                           double *v) const;
+   bool IsEmpty() const { return nfdofs < 2; }
 
-   void TransformDual(const Array<int> & face_orientation,
-                      double *v) const;
-
-   void InvTransformDual(const Array<int> & face_orientation,
-                         double *v) const;
+   void TransformPrimal(const Array<int> & face_orientation, double *v) const;
+   void InvTransformPrimal(const Array<int> & face_orientation, double *v) const;
+   void TransformDual(const Array<int> & face_orientation, double *v) const;
+   void InvTransformDual(const Array<int> & face_orientation, double *v) const;
 };
 
 /// Stateless DoF transformation implementation for the Nedelec basis on
 /// triangles
-class ND_TriStatelessDofTransformation : public ND_StatelessDofTransformation
-{
-public:
-   ND_TriStatelessDofTransformation(int order)
-      : StatelessDofTransformation(order*(order + 2))
-      , ND_StatelessDofTransformation(order*(order + 2), order, 3, 1)
-   {}
-};
-
-/// DoF transformation implementation for the Nedelec basis on triangles
-class ND_TriDofTransformation : public DofTransformation,
-   public ND_TriStatelessDofTransformation
+class ND_TriDofTransformation : public ND_DofTransformation
 {
 public:
    ND_TriDofTransformation(int order)
-      : StatelessDofTransformation(order*(order + 2))
-      , DofTransformation(order*(order + 2))
-      , ND_TriStatelessDofTransformation(order)
-   {}
-
-   using DofTransformation::TransformPrimal;
-   using DofTransformation::InvTransformPrimal;
-   using DofTransformation::TransformDual;
-   using DofTransformation::InvTransformDual;
-
-   using ND_TriStatelessDofTransformation::TransformPrimal;
-   using ND_TriStatelessDofTransformation::InvTransformPrimal;
-   using ND_TriStatelessDofTransformation::TransformDual;
-   using ND_TriStatelessDofTransformation::InvTransformDual;
-};
-
-/// DoF transformation implementation for the Nedelec basis on tetrahedra
-class ND_TetStatelessDofTransformation : public ND_StatelessDofTransformation
-{
-public:
-   ND_TetStatelessDofTransformation(int order)
-      : StatelessDofTransformation(order*(order + 2)*(order + 3)/2)
-      , ND_StatelessDofTransformation(order*(order + 2)*(order + 3)/2, order,
-                                      6, 4)
+      : ND_DofTransformation(order*(order + 2), order, 3, 1)
    {}
 };
 
 /// DoF transformation implementation for the Nedelec basis on tetrahedra
-class ND_TetDofTransformation : public DofTransformation,
-   public ND_TetStatelessDofTransformation
+class ND_TetDofTransformation : public ND_DofTransformation
 {
 public:
    ND_TetDofTransformation(int order)
-      : StatelessDofTransformation(order*(order + 2)*(order + 3)/2)
-      , DofTransformation(order*(order + 2)*(order + 3)/2)
-      , ND_TetStatelessDofTransformation(order)
+      : ND_DofTransformation(order*(order + 2)*(order + 3)/2, order, 6, 4)
    {}
-
-   using DofTransformation::TransformPrimal;
-   using DofTransformation::InvTransformPrimal;
-   using DofTransformation::TransformDual;
-   using DofTransformation::InvTransformDual;
-
-   using ND_TetStatelessDofTransformation::TransformPrimal;
-   using ND_TetStatelessDofTransformation::InvTransformPrimal;
-   using ND_TetStatelessDofTransformation::TransformDual;
-   using ND_TetStatelessDofTransformation::InvTransformDual;
 };
 
 /// DoF transformation implementation for the Nedelec basis on wedge elements
-class ND_WedgeStatelessDofTransformation : public ND_StatelessDofTransformation
-{
-public:
-   ND_WedgeStatelessDofTransformation(int order)
-      : StatelessDofTransformation(3 * order * ((order + 1) * (order + 2))/2)
-      , ND_StatelessDofTransformation(3 * order * ((order + 1) * (order + 2))/2,
-                                      order, 9, 2)
-   {}
-};
-
-/// DoF transformation implementation for the Nedelec basis on wedge elements
-class ND_WedgeDofTransformation : public DofTransformation,
-   public ND_WedgeStatelessDofTransformation
+class ND_WedgeDofTransformation : public ND_DofTransformation
 {
 public:
    ND_WedgeDofTransformation(int order)
-      : StatelessDofTransformation(3 * order * ((order + 1) * (order + 2))/2)
-      , DofTransformation(3 * order * ((order + 1) * (order + 2))/2)
-      , ND_WedgeStatelessDofTransformation(order)
+      : ND_DofTransformation(3 * order * ((order + 1) * (order + 2))/2,
+                             order, 9, 2)
    {}
-
-   using DofTransformation::TransformPrimal;
-   using DofTransformation::InvTransformPrimal;
-   using DofTransformation::TransformDual;
-   using DofTransformation::InvTransformDual;
-
-   using ND_WedgeStatelessDofTransformation::TransformPrimal;
-   using ND_WedgeStatelessDofTransformation::InvTransformPrimal;
-   using ND_WedgeStatelessDofTransformation::TransformDual;
-   using ND_WedgeStatelessDofTransformation::InvTransformDual;
 };
 
 } // namespace mfem
diff --git a/fem/eltrans.cpp b/fem/eltrans.cpp
index a4af691d7..b0bf84145 100644
--- a/fem/eltrans.cpp
+++ b/fem/eltrans.cpp
@@ -355,15 +355,11 @@ int InverseElementTransformation::Transform(const Vector &pt,
          }
          else
          {
-            const int old_type = GlobGeometryRefiner.GetType();
-            GlobGeometryRefiner.SetType(qpts_type);
-            RefinedGeometry &RefG =
-               *GlobGeometryRefiner.Refine(T->GetGeometryType(), order);
+            RefinedGeometry &RefG = *refiner.Refine(T->GetGeometryType(), order);
             int closest_idx = (init_guess_type == ClosestPhysNode) ?
                               FindClosestPhysPoint(pt, RefG.RefPts) :
                               FindClosestRefPoint(pt, RefG.RefPts);
             ip0 = &RefG.RefPts.IntPoint(closest_idx);
-            GlobGeometryRefiner.SetType(old_type);
          }
          break;
       }
diff --git a/fem/eltrans.hpp b/fem/eltrans.hpp
index 198e20df3..43eccd499 100644
--- a/fem/eltrans.hpp
+++ b/fem/eltrans.hpp
@@ -234,6 +234,7 @@ protected:
    const IntegrationPoint *ip0;
    int init_guess_type; // algorithm to use
    int qpts_type; // Quadrature1D type for the initial guess type
+   GeometryRefiner refiner; // geometry refiner for initial guess
    int rel_qpts_order; // num_1D_qpts = max(trans_order+rel_qpts_order,0)+1
    int solver_type; // solution strategy to use
    int max_iter; // max. number of Newton iterations
@@ -277,6 +278,7 @@ public:
         ip0(NULL),
         init_guess_type(Center),
         qpts_type(Quadrature1D::OpenHalfUniform),
+        refiner(qpts_type),
         rel_qpts_order(-1),
         solver_type(NewtonElementProject),
         max_iter(16),
@@ -301,7 +303,8 @@ public:
    { ip0 = &init_ip; SetInitialGuessType(GivenPoint); }
 
    /// Set the Quadrature1D type used for the `Closest*` initial guess types.
-   void SetInitGuessPointsType(int q_type) { qpts_type = q_type; }
+   void SetInitGuessPointsType(int q_type)
+   { qpts_type = q_type; refiner.SetType(q_type); }
 
    /// Set the relative order used for the `Closest*` initial guess types.
    /** The number of points in each spatial direction is given by the formula
@@ -361,7 +364,7 @@ public:
 class IsoparametricTransformation : public ElementTransformation
 {
 private:
-   DenseMatrix dshape,d2shape;
+   DenseMatrix dshape, d2shape;
    Vector shape;
 
    const FiniteElement *FElem;
diff --git a/fem/fe/fe_base.cpp b/fem/fe/fe_base.cpp
index ded2ffc9c..7151a8c5e 100644
--- a/fem/fe/fe_base.cpp
+++ b/fem/fe/fe_base.cpp
@@ -359,135 +359,148 @@ void  FiniteElement::CalcPhysHessian(ElementTransformation &Trans,
 
    // Hessian in physical coords
    lhm.Invert();
-   Mult( hess, lhm, Hessian);
+   Mult(hess, lhm, Hessian);
 }
 
 const DofToQuad &FiniteElement::GetDofToQuad(const IntegrationRule &ir,
                                              DofToQuad::Mode mode) const
 {
+   DofToQuad *d2q = nullptr;
    MFEM_VERIFY(mode == DofToQuad::FULL, "invalid mode requested");
 
-   for (int i = 0; i < dof2quad_array.Size(); i++)
-   {
-      const DofToQuad &d2q = *dof2quad_array[i];
-      if (d2q.IntRule == &ir && d2q.mode == mode) { return d2q; }
-   }
-
-#ifdef MFEM_THREAD_SAFE
-   DenseMatrix vshape(dof, dim);
+#ifdef MFEM_USE_OPENMP
+   #pragma omp critical (DofToQuad)
 #endif
-
-   DofToQuad *d2q = new DofToQuad;
-   const int nqpt = ir.GetNPoints();
-   d2q->FE = this;
-   d2q->IntRule = &ir;
-   d2q->mode = mode;
-   d2q->ndof = dof;
-   d2q->nqpt = nqpt;
-   if (range_type == SCALAR)
-   {
-      d2q->B.SetSize(nqpt*dof);
-      d2q->Bt.SetSize(dof*nqpt);
-
-      Vector shape;
-      vshape.GetColumnReference(0, shape);
-      for (int i = 0; i < nqpt; i++)
-      {
-         const IntegrationPoint &ip = ir.IntPoint(i);
-         CalcShape(ip, shape);
-         for (int j = 0; j < dof; j++)
-         {
-            d2q->B[i+nqpt*j] = d2q->Bt[j+dof*i] = shape(j);
-         }
-      }
-   }
-   else if (range_type == VECTOR)
    {
-      d2q->B.SetSize(nqpt*dim*dof);
-      d2q->Bt.SetSize(dof*nqpt*dim);
-
-      for (int i = 0; i < nqpt; i++)
+      for (int i = 0; i < dof2quad_array.Size(); i++)
       {
-         const IntegrationPoint &ip = ir.IntPoint(i);
-         CalcVShape(ip, vshape);
-         for (int d = 0; d < dim; d++)
-         {
-            for (int j = 0; j < dof; j++)
-            {
-               d2q->B[i+nqpt*(d+dim*j)] = d2q->Bt[j+dof*(i+nqpt*d)] = vshape(j, d);
-            }
-         }
+         d2q = dof2quad_array[i];
+         if (d2q->IntRule != &ir || d2q->mode != mode) { d2q = nullptr; }
       }
-   }
-   else
-   {
-      // Skip B and Bt for unknown range type
-   }
-   switch (deriv_type)
-   {
-      case GRAD:
+      if (!d2q)
       {
-         d2q->G.SetSize(nqpt*dim*dof);
-         d2q->Gt.SetSize(dof*nqpt*dim);
-
-         for (int i = 0; i < nqpt; i++)
+#ifdef MFEM_THREAD_SAFE
+         DenseMatrix vshape(dof, dim);
+#endif
+         d2q = new DofToQuad;
+         const int nqpt = ir.GetNPoints();
+         d2q->FE = this;
+         d2q->IntRule = &ir;
+         d2q->mode = mode;
+         d2q->ndof = dof;
+         d2q->nqpt = nqpt;
+         switch (range_type)
          {
-            const IntegrationPoint &ip = ir.IntPoint(i);
-            CalcDShape(ip, vshape);
-            for (int d = 0; d < dim; d++)
+            case SCALAR:
             {
-               for (int j = 0; j < dof; j++)
+               d2q->B.SetSize(nqpt*dof);
+               d2q->Bt.SetSize(dof*nqpt);
+
+               Vector shape;
+               vshape.GetColumnReference(0, shape);
+               for (int i = 0; i < nqpt; i++)
                {
-                  d2q->G[i+nqpt*(d+dim*j)] = d2q->Gt[j+dof*(i+nqpt*d)] = vshape(j, d);
+                  const IntegrationPoint &ip = ir.IntPoint(i);
+                  CalcShape(ip, shape);
+                  for (int j = 0; j < dof; j++)
+                  {
+                     d2q->B[i+nqpt*j] = d2q->Bt[j+dof*i] = shape(j);
+                  }
                }
+               break;
             }
-         }
-         break;
-      }
-      case DIV:
-      {
-         d2q->G.SetSize(nqpt*dof);
-         d2q->Gt.SetSize(dof*nqpt);
+            case VECTOR:
+            {
+               d2q->B.SetSize(nqpt*dim*dof);
+               d2q->Bt.SetSize(dof*nqpt*dim);
 
-         Vector divshape;
-         vshape.GetColumnReference(0, divshape);
-         for (int i = 0; i < nqpt; i++)
+               for (int i = 0; i < nqpt; i++)
+               {
+                  const IntegrationPoint &ip = ir.IntPoint(i);
+                  CalcVShape(ip, vshape);
+                  for (int d = 0; d < dim; d++)
+                  {
+                     for (int j = 0; j < dof; j++)
+                     {
+                        d2q->B[i+nqpt*(d+dim*j)] =
+                           d2q->Bt[j+dof*(i+nqpt*d)] = vshape(j, d);
+                     }
+                  }
+               }
+               break;
+            }
+            case UNKNOWN_RANGE_TYPE:
+               // Skip B and Bt for unknown range type
+               break;
+         }
+         switch (deriv_type)
          {
-            const IntegrationPoint &ip = ir.IntPoint(i);
-            CalcDivShape(ip, divshape);
-            for (int j = 0; j < dof; j++)
+            case GRAD:
             {
-               d2q->G[i+nqpt*j] = d2q->Gt[j+dof*i] = divshape(j);
+               d2q->G.SetSize(nqpt*dim*dof);
+               d2q->Gt.SetSize(dof*nqpt*dim);
+
+               for (int i = 0; i < nqpt; i++)
+               {
+                  const IntegrationPoint &ip = ir.IntPoint(i);
+                  CalcDShape(ip, vshape);
+                  for (int d = 0; d < dim; d++)
+                  {
+                     for (int j = 0; j < dof; j++)
+                     {
+                        d2q->G[i+nqpt*(d+dim*j)] =
+                           d2q->Gt[j+dof*(i+nqpt*d)] = vshape(j, d);
+                     }
+                  }
+               }
+               break;
             }
-         }
-         break;
-      }
-      case CURL:
-      {
-         d2q->G.SetSize(nqpt*cdim*dof);
-         d2q->Gt.SetSize(dof*nqpt*cdim);
+            case DIV:
+            {
+               d2q->G.SetSize(nqpt*dof);
+               d2q->Gt.SetSize(dof*nqpt);
 
-         DenseMatrix curlshape(vshape.GetData(), dof, cdim);  // cdim <= dim
-         for (int i = 0; i < nqpt; i++)
-         {
-            const IntegrationPoint &ip = ir.IntPoint(i);
-            CalcCurlShape(ip, curlshape);
-            for (int d = 0; d < cdim; d++)
+               Vector divshape;
+               vshape.GetColumnReference(0, divshape);
+               for (int i = 0; i < nqpt; i++)
+               {
+                  const IntegrationPoint &ip = ir.IntPoint(i);
+                  CalcDivShape(ip, divshape);
+                  for (int j = 0; j < dof; j++)
+                  {
+                     d2q->G[i+nqpt*j] = d2q->Gt[j+dof*i] = divshape(j);
+                  }
+               }
+               break;
+            }
+            case CURL:
             {
-               for (int j = 0; j < dof; j++)
+               d2q->G.SetSize(nqpt*cdim*dof);
+               d2q->Gt.SetSize(dof*nqpt*cdim);
+
+               DenseMatrix curlshape(vshape.GetData(), dof, cdim);  // cdim <= dim
+               for (int i = 0; i < nqpt; i++)
                {
-                  d2q->G[i+nqpt*(d+cdim*j)] = d2q->Gt[j+dof*(i+nqpt*d)] = curlshape(j, d);
+                  const IntegrationPoint &ip = ir.IntPoint(i);
+                  CalcCurlShape(ip, curlshape);
+                  for (int d = 0; d < cdim; d++)
+                  {
+                     for (int j = 0; j < dof; j++)
+                     {
+                        d2q->G[i+nqpt*(d+cdim*j)] =
+                           d2q->Gt[j+dof*(i+nqpt*d)] = curlshape(j, d);
+                     }
+                  }
                }
+               break;
             }
+            case NONE:
+               // Skip G and Gt for unknown derivative type
+               break;
          }
-         break;
+         dof2quad_array.Append(d2q);
       }
-      case NONE:
-      default:
-         // Skip G and Gt for unknown derivative type
-         break;
    }
-   dof2quad_array.Append(d2q);
    return *d2q;
 }
 
@@ -904,14 +917,14 @@ VectorFiniteElement::VectorFiniteElement(int D, Geometry::Type G,
 }
 
 void VectorFiniteElement::CalcShape(
-   const IntegrationPoint &ip, Vector &shape ) const
+   const IntegrationPoint &ip, Vector &shape) const
 {
    mfem_error("Error: Cannot use scalar CalcShape(...) function with\n"
               "   VectorFiniteElements!");
 }
 
 void VectorFiniteElement::CalcDShape(
-   const IntegrationPoint &ip, DenseMatrix &dshape ) const
+   const IntegrationPoint &ip, DenseMatrix &dshape) const
 {
    mfem_error("Error: Cannot use scalar CalcDShape(...) function with\n"
               "   VectorFiniteElements!");
@@ -2183,51 +2196,72 @@ void Poly_1D::CalcChebyshev(const int p, const double x, double *u, double *d,
 
 const double *Poly_1D::GetPoints(const int p, const int btype)
 {
+   Array<double*> *pts;
    BasisType::Check(btype);
    const int qtype = BasisType::GetQuadrature1D(btype);
-
    if (qtype == Quadrature1D::Invalid) { return NULL; }
 
-   if (points_container.find(btype) == points_container.end())
-   {
-      points_container[btype] = new Array<double*>(h_mt);
-   }
-   Array<double*> &pts = *points_container[btype];
-   if (pts.Size() <= p)
-   {
-      pts.SetSize(p + 1, NULL);
-   }
-   if (pts[p] == NULL)
+#ifdef MFEM_USE_OPENMP
+   #pragma omp critical (Poly1DGetPoints)
+#endif
    {
-      pts[p] = new double[p + 1];
-      quad_func.GivePolyPoints(p+1, pts[p], qtype);
+      auto it = points_container.find(btype);
+      if (it != points_container.end())
+      {
+         pts = it->second;
+      }
+      else
+      {
+         pts = new Array<double*>(h_mt);
+         points_container[btype] = pts;
+      }
+      if (pts->Size() <= p)
+      {
+         pts->SetSize(p + 1, NULL);
+      }
+      if ((*pts)[p] == NULL)
+      {
+         (*pts)[p] = new double[p + 1];
+         quad_func.GivePolyPoints(p + 1, (*pts)[p], qtype);
+      }
    }
-   return pts[p];
+   return (*pts)[p];
 }
 
 Poly_1D::Basis &Poly_1D::GetBasis(const int p, const int btype)
 {
+   Array<Basis*> *bases;
    BasisType::Check(btype);
 
-   if ( bases_container.find(btype) == bases_container.end() )
-   {
-      // we haven't been asked for basis or points of this type yet
-      bases_container[btype] = new Array<Basis*>(h_mt);
-   }
-   Array<Basis*> &bases = *bases_container[btype];
-   if (bases.Size() <= p)
-   {
-      bases.SetSize(p + 1, NULL);
-   }
-   if (bases[p] == NULL)
+#ifdef MFEM_USE_OPENMP
+   #pragma omp critical (Poly1DGetBasis)
+#endif
    {
-      EvalType etype;
-      if (btype == BasisType::Positive) { etype = Positive; }
-      else if (btype == BasisType::IntegratedGLL) { etype = Integrated; }
-      else { etype = Barycentric; }
-      bases[p] = new Basis(p, GetPoints(p, btype), etype);
+      auto it = bases_container.find(btype);
+      if (it != bases_container.end())
+      {
+         bases = it->second;
+      }
+      else
+      {
+         // we haven't been asked for basis or points of this type yet
+         bases = new Array<Basis*>(h_mt);
+         bases_container[btype] = bases;
+      }
+      if (bases->Size() <= p)
+      {
+         bases->SetSize(p + 1, NULL);
+      }
+      if ((*bases)[p] == NULL)
+      {
+         EvalType etype;
+         if (btype == BasisType::Positive) { etype = Positive; }
+         else if (btype == BasisType::IntegratedGLL) { etype = Integrated; }
+         else { etype = Barycentric; }
+         (*bases)[p] = new Basis(p, GetPoints(p, btype), etype);
+      }
    }
-   return *bases[p];
+   return *(*bases)[p];
 }
 
 Poly_1D::~Poly_1D()
@@ -2236,7 +2270,7 @@ Poly_1D::~Poly_1D()
         it != points_container.end() ; ++it)
    {
       Array<double*>& pts = *it->second;
-      for ( int i = 0 ; i < pts.Size() ; ++i )
+      for (int i = 0; i < pts.Size(); ++i)
       {
          delete [] pts[i];
       }
@@ -2247,7 +2281,7 @@ Poly_1D::~Poly_1D()
         it != bases_container.end() ; ++it)
    {
       Array<Basis*>& bases = *it->second;
-      for ( int i = 0 ; i < bases.Size() ; ++i )
+      for (int i = 0; i < bases.Size(); ++i)
       {
          delete bases[i];
       }
@@ -2461,39 +2495,47 @@ const DofToQuad &TensorBasisElement::GetTensorDofToQuad(
    DofToQuad::Mode mode, const Poly_1D::Basis &basis, bool closed,
    Array<DofToQuad*> &dof2quad_array)
 {
+   DofToQuad *d2q = nullptr;
    MFEM_VERIFY(mode == DofToQuad::TENSOR, "invalid mode requested");
 
-   for (int i = 0; i < dof2quad_array.Size(); i++)
-   {
-      const DofToQuad &d2q = *dof2quad_array[i];
-      if (d2q.IntRule == &ir && d2q.mode == mode) { return d2q; }
-   }
-
-   DofToQuad *d2q = new DofToQuad;
-   const int ndof = closed ? fe.GetOrder() + 1 : fe.GetOrder();
-   const int nqpt = (int)floor(pow(ir.GetNPoints(), 1.0/fe.GetDim()) + 0.5);
-   d2q->FE = &fe;
-   d2q->IntRule = &ir;
-   d2q->mode = mode;
-   d2q->ndof = ndof;
-   d2q->nqpt = nqpt;
-   d2q->B.SetSize(nqpt*ndof);
-   d2q->Bt.SetSize(ndof*nqpt);
-   d2q->G.SetSize(nqpt*ndof);
-   d2q->Gt.SetSize(ndof*nqpt);
-   Vector val(ndof), grad(ndof);
-   for (int i = 0; i < nqpt; i++)
+#ifdef MFEM_USE_OPENMP
+   #pragma omp critical (DofToQuad)
+#endif
    {
-      // The first 'nqpt' points in 'ir' have the same x-coordinates as those
-      // of the 1D rule.
-      basis.Eval(ir.IntPoint(i).x, val, grad);
-      for (int j = 0; j < ndof; j++)
-      {
-         d2q->B[i+nqpt*j] = d2q->Bt[j+ndof*i] = val(j);
-         d2q->G[i+nqpt*j] = d2q->Gt[j+ndof*i] = grad(j);
+      for (int i = 0; i < dof2quad_array.Size(); i++)
+      {
+         d2q = dof2quad_array[i];
+         if (d2q->IntRule != &ir || d2q->mode != mode) { d2q = nullptr; }
+      }
+      if (!d2q)
+      {
+         d2q = new DofToQuad;
+         const int ndof = closed ? fe.GetOrder() + 1 : fe.GetOrder();
+         const int nqpt = (int)floor(pow(ir.GetNPoints(), 1.0/fe.GetDim()) + 0.5);
+         d2q->FE = &fe;
+         d2q->IntRule = &ir;
+         d2q->mode = mode;
+         d2q->ndof = ndof;
+         d2q->nqpt = nqpt;
+         d2q->B.SetSize(nqpt*ndof);
+         d2q->Bt.SetSize(ndof*nqpt);
+         d2q->G.SetSize(nqpt*ndof);
+         d2q->Gt.SetSize(ndof*nqpt);
+         Vector val(ndof), grad(ndof);
+         for (int i = 0; i < nqpt; i++)
+         {
+            // The first 'nqpt' points in 'ir' have the same x-coordinates as those
+            // of the 1D rule.
+            basis.Eval(ir.IntPoint(i).x, val, grad);
+            for (int j = 0; j < ndof; j++)
+            {
+               d2q->B[i+nqpt*j] = d2q->Bt[j+ndof*i] = val(j);
+               d2q->G[i+nqpt*j] = d2q->Gt[j+ndof*i] = grad(j);
+            }
+         }
+         dof2quad_array.Append(d2q);
       }
    }
-   dof2quad_array.Append(d2q);
    return *d2q;
 }
 
diff --git a/fem/fe/fe_base.hpp b/fem/fe/fe_base.hpp
index 73b948ce9..74d9eebc1 100644
--- a/fem/fe/fe_base.hpp
+++ b/fem/fe/fe_base.hpp
@@ -250,7 +250,7 @@ protected:
    /// Container for all DofToQuad objects created by the FiniteElement.
    /** Multiple DofToQuad objects may be needed when different quadrature rules
        or different DofToQuad::Mode are used. */
-   mutable Array<DofToQuad*> dof2quad_array;
+   mutable Array<DofToQuad *> dof2quad_array;
 
 public:
    /// Enumeration for range_type and deriv_range_type
@@ -1025,8 +1025,8 @@ public:
    };
 
 private:
-   typedef std::map< int, Array<double*>* > PointsMap;
-   typedef std::map< int, Array<Basis*>* > BasisMap;
+   typedef std::map<int, Array<double*>*> PointsMap;
+   typedef std::map<int, Array<Basis*>*> BasisMap;
 
    MemoryType h_mt;
    PointsMap points_container;
diff --git a/fem/fe/fe_nd.hpp b/fem/fe/fe_nd.hpp
index 231c050a7..b7e33fec3 100644
--- a/fem/fe/fe_nd.hpp
+++ b/fem/fe/fe_nd.hpp
@@ -179,7 +179,7 @@ class ND_TetrahedronElement : public VectorFiniteElement
    Array<int> dof2tk;
    DenseMatrixInverse Ti;
 
-   mutable ND_TetStatelessDofTransformation doftrans;
+   mutable ND_TetDofTransformation doftrans;
 
 public:
    /// Construct the ND_TetrahedronElement of order @a p
@@ -242,7 +242,7 @@ class ND_TriangleElement : public VectorFiniteElement
    Array<int> dof2tk;
    DenseMatrixInverse Ti;
 
-   mutable ND_TriStatelessDofTransformation doftrans;
+   mutable ND_TriDofTransformation doftrans;
 
 public:
    /// Construct the ND_TriangleElement of order @a p
@@ -346,7 +346,7 @@ private:
 #endif
    Array<int> dof2tk, t_dof, s_dof;
 
-   mutable ND_WedgeStatelessDofTransformation doftrans;
+   mutable ND_WedgeDofTransformation doftrans;
 
    H1_TriangleElement H1TriangleFE;
    ND_TriangleElement NDTriangleFE;
diff --git a/fem/fespace.cpp b/fem/fespace.cpp
index 3934a5fe8..68ca200e1 100644
--- a/fem/fespace.cpp
+++ b/fem/fespace.cpp
@@ -63,7 +63,7 @@ FiniteElementSpace::FiniteElementSpace()
      elem_dof(NULL), elem_fos(NULL), bdr_elem_dof(NULL), bdr_elem_fos(NULL),
      face_dof(NULL),
      NURBSext(NULL), own_ext(false),
-     DoFTrans(0), VDoFTrans(vdim, ordering),
+     VDoFTrans(vdim, ordering),
      cP(NULL), cR(NULL), cR_hp(NULL), cP_is_set(false),
      Th(Operator::ANY_TYPE),
      sequence(0), mesh_sequence(0), orders_changed(false), relaxed_hp(false)
@@ -212,7 +212,7 @@ void FiniteElementSpace::GetVDofs(int vd, Array<int>& dofs, int ndofs_) const
    }
 }
 
-void FiniteElementSpace::DofsToVDofs (Array<int> &dofs, int ndofs_) const
+void FiniteElementSpace::DofsToVDofs(Array<int> &dofs, int ndofs_) const
 {
    if (vdim == 1) { return; }
    if (ndofs_ < 0) { ndofs_ = this->ndofs; }
@@ -264,7 +264,7 @@ int FiniteElementSpace::DofToVDof(int dof, int vd, int ndofs_) const
 }
 
 // static function
-void FiniteElementSpace::AdjustVDofs (Array<int> &vdofs)
+void FiniteElementSpace::AdjustVDofs(Array<int> &vdofs)
 {
    int n = vdofs.Size(), *vdof = vdofs;
    for (int i = 0; i < n; i++)
@@ -280,7 +280,7 @@ void FiniteElementSpace::AdjustVDofs (Array<int> &vdofs)
 DofTransformation *
 FiniteElementSpace::GetElementVDofs(int i, Array<int> &vdofs) const
 {
-   DofTransformation * doftrans = GetElementDofs(i, vdofs);
+   DofTransformation *doftrans = GetElementDofs(i, vdofs);
    DofsToVDofs(vdofs);
    if (vdim == 1 || doftrans == NULL)
    {
@@ -288,7 +288,8 @@ FiniteElementSpace::GetElementVDofs(int i, Array<int> &vdofs) const
    }
    else
    {
-      VDoFTrans.SetDofTransformation(*doftrans);
+      VDoFTrans.SetDofTransformation(*doftrans->GetDofTransformation());
+      VDoFTrans.SetFaceOrientations(doftrans->GetFaceOrientations());
       return &VDoFTrans;
    }
 }
@@ -296,7 +297,7 @@ FiniteElementSpace::GetElementVDofs(int i, Array<int> &vdofs) const
 DofTransformation *
 FiniteElementSpace::GetBdrElementVDofs(int i, Array<int> &vdofs) const
 {
-   DofTransformation * doftrans = GetBdrElementDofs(i, vdofs);
+   DofTransformation *doftrans = GetBdrElementDofs(i, vdofs);
    DofsToVDofs(vdofs);
    if (vdim == 1 || doftrans == NULL)
    {
@@ -304,7 +305,8 @@ FiniteElementSpace::GetBdrElementVDofs(int i, Array<int> &vdofs) const
    }
    else
    {
-      VDoFTrans.SetDofTransformation(*doftrans);
+      VDoFTrans.SetDofTransformation(*doftrans->GetDofTransformation());
+      VDoFTrans.SetFaceOrientations(doftrans->GetFaceOrientations());
       return &VDoFTrans;
    }
 }
@@ -762,9 +764,9 @@ FiniteElementSpace::H2L_GlobalRestrictionMatrix (FiniteElementSpace *lfes)
    return R;
 }
 
-void FiniteElementSpace
-::AddDependencies(SparseMatrix& deps, Array<int>& master_dofs,
-                  Array<int>& slave_dofs, DenseMatrix& I, int skipfirst)
+void FiniteElementSpace::AddDependencies(
+   SparseMatrix& deps, Array<int>& master_dofs, Array<int>& slave_dofs,
+   DenseMatrix& I, int skipfirst)
 {
    for (int i = skipfirst; i < slave_dofs.Size(); i++)
    {
@@ -787,11 +789,9 @@ void FiniteElementSpace
    }
 }
 
-void FiniteElementSpace
-::AddEdgeFaceDependencies(SparseMatrix &deps, Array<int> &master_dofs,
-                          const FiniteElement *master_fe,
-                          Array<int> &slave_dofs, int slave_face,
-                          const DenseMatrix *pm) const
+void FiniteElementSpace::AddEdgeFaceDependencies(
+   SparseMatrix &deps, Array<int> &master_dofs, const FiniteElement *master_fe,
+   Array<int> &slave_dofs, int slave_face, const DenseMatrix *pm) const
 {
    // In variable-order spaces in 3D, we need to only constrain interior face
    // DOFs (this is done one level up), since edge dependencies can be more
@@ -1498,12 +1498,12 @@ SparseMatrix* FiniteElementSpace::RefinementMatrix(int old_ndofs,
                                 localP);
 }
 
-FiniteElementSpace::RefinementOperator::RefinementOperator
-(const FiniteElementSpace* fespace, Table* old_elem_dof, Table* old_elem_fos,
- int old_ndofs)
-   : fespace(fespace)
-   , old_elem_dof(old_elem_dof)
-   , old_elem_fos(old_elem_fos)
+FiniteElementSpace::RefinementOperator::RefinementOperator(
+   const FiniteElementSpace* fespace, Table* old_elem_dof, Table* old_elem_fos,
+   int old_ndofs)
+   : fespace(fespace),
+     old_elem_dof(old_elem_dof),
+     old_elem_fos(old_elem_fos)
 {
    MFEM_VERIFY(fespace->GetNE() >= old_elem_dof->Size(),
                "Previous mesh is not coarser.");
@@ -1518,7 +1518,7 @@ FiniteElementSpace::RefinementOperator::RefinementOperator
       fespace->GetLocalRefinementMatrices(elem_geoms[i], localP[elem_geoms[i]]);
    }
 
-   ConstructDoFTrans();
+   ConstructDoFTransArray();
 }
 
 FiniteElementSpace::RefinementOperator::RefinementOperator(
@@ -1543,59 +1543,58 @@ FiniteElementSpace::RefinementOperator::RefinementOperator(
       old_elem_fos = new Table(*coarse_fes->GetElementToFaceOrientationTable());
    }
 
-   ConstructDoFTrans();
+   ConstructDoFTransArray();
 }
 
 FiniteElementSpace::RefinementOperator::~RefinementOperator()
 {
    delete old_elem_dof;
    delete old_elem_fos;
-   for (int i=0; i<old_DoFTrans.Size(); i++)
+   for (int i=0; i<old_DoFTransArray.Size(); i++)
    {
-      delete old_DoFTrans[i];
+      delete old_DoFTransArray[i];
    }
 }
 
-void FiniteElementSpace::RefinementOperator
-::ConstructDoFTrans()
+void FiniteElementSpace::RefinementOperator::ConstructDoFTransArray()
 {
-   old_DoFTrans.SetSize(Geometry::NUM_GEOMETRIES);
-   for (int i=0; i<old_DoFTrans.Size(); i++)
+   old_DoFTransArray.SetSize(Geometry::NUM_GEOMETRIES);
+   for (int i=0; i<old_DoFTransArray.Size(); i++)
    {
-      old_DoFTrans[i] = NULL;
+      old_DoFTransArray[i] = NULL;
    }
 
    const FiniteElementCollection *fec_ref = fespace->FEColl();
    if (dynamic_cast<const ND_FECollection*>(fec_ref))
    {
-      const FiniteElement * nd_tri =
+      const FiniteElement *nd_tri =
          fec_ref->FiniteElementForGeometry(Geometry::TRIANGLE);
       if (nd_tri)
       {
-         old_DoFTrans[Geometry::TRIANGLE] =
+         old_DoFTransArray[Geometry::TRIANGLE] =
             new ND_TriDofTransformation(nd_tri->GetOrder());
       }
 
-      const FiniteElement * nd_tet =
+      const FiniteElement *nd_tet =
          fec_ref->FiniteElementForGeometry(Geometry::TETRAHEDRON);
       if (nd_tet)
       {
-         old_DoFTrans[Geometry::TETRAHEDRON] =
+         old_DoFTransArray[Geometry::TETRAHEDRON] =
             new ND_TetDofTransformation(nd_tet->GetOrder());
       }
 
-      const FiniteElement * nd_pri =
+      const FiniteElement *nd_pri =
          fec_ref->FiniteElementForGeometry(Geometry::PRISM);
       if (nd_pri)
       {
-         old_DoFTrans[Geometry::PRISM] =
+         old_DoFTransArray[Geometry::PRISM] =
             new ND_WedgeDofTransformation(nd_pri->GetOrder());
       }
    }
 }
 
-void FiniteElementSpace::RefinementOperator
-::Mult(const Vector &x, Vector &y) const
+void FiniteElementSpace::RefinementOperator::Mult(const Vector &x,
+                                                  Vector &y) const
 {
    Mesh* mesh_ref = fespace->GetMesh();
    const CoarseFineTransformations &trans_ref =
@@ -1635,15 +1634,16 @@ void FiniteElementSpace::RefinementOperator
       else
       {
          old_elem_fos->GetRow(emb.parent, old_Fo);
-         old_DoFTrans[geom]->SetFaceOrientations(old_Fo);
+         old_DoFTrans.SetDofTransformation(*old_DoFTransArray[geom]);
+         old_DoFTrans.SetFaceOrientations(old_Fo);
 
-         DofTransformation *new_doftrans = NULL;
          VDofTransformation *vdoftrans =
             dynamic_cast<VDofTransformation*>(doftrans);
+         int vdoftrans_vdim = 1;
          if (vdoftrans)
          {
-            new_doftrans = doftrans;
-            doftrans = vdoftrans->GetDofTransformation();
+            vdoftrans_vdim = vdoftrans->GetVDim();
+            vdoftrans->SetVDim(1);
          }
 
          for (int vd = 0; vd < rvdim; vd++)
@@ -1653,7 +1653,7 @@ void FiniteElementSpace::RefinementOperator
             old_dofs.Copy(old_vdofs);
             fespace->DofsToVDofs(vd, old_vdofs, old_ndofs);
             x.GetSubVector(old_vdofs, subX);
-            old_DoFTrans[geom]->InvTransformPrimal(subX);
+            old_DoFTrans.InvTransformPrimal(subX);
             lP.Mult(subX, subY);
             doftrans->TransformPrimal(subY);
             y.SetSubVector(vdofs, subY);
@@ -1661,14 +1661,14 @@ void FiniteElementSpace::RefinementOperator
 
          if (vdoftrans)
          {
-            doftrans = new_doftrans;
+            vdoftrans->SetVDim(vdoftrans_vdim);
          }
       }
    }
 }
 
-void FiniteElementSpace::RefinementOperator
-::MultTranspose(const Vector &x, Vector &y) const
+void FiniteElementSpace::RefinementOperator::MultTranspose(const Vector &x,
+                                                           Vector &y) const
 {
    y = 0.0;
 
@@ -1692,7 +1692,7 @@ void FiniteElementSpace::RefinementOperator
       const Geometry::Type geom = mesh_ref->GetElementBaseGeometry(k);
       const DenseMatrix &lP = localP[geom](emb.matrix);
 
-      DofTransformation * doftrans = fespace->GetElementDofs(k, f_dofs);
+      DofTransformation *doftrans = fespace->GetElementDofs(k, f_dofs);
       old_elem_dof->GetRow(emb.parent, c_dofs);
 
       if (!doftrans)
@@ -1725,15 +1725,16 @@ void FiniteElementSpace::RefinementOperator
          subYt.SetSize(lP.Width());
 
          old_elem_fos->GetRow(emb.parent, old_Fo);
-         old_DoFTrans[geom]->SetFaceOrientations(old_Fo);
+         old_DoFTrans.SetDofTransformation(*old_DoFTransArray[geom]);
+         old_DoFTrans.SetFaceOrientations(old_Fo);
 
-         DofTransformation *new_doftrans = NULL;
          VDofTransformation *vdoftrans =
             dynamic_cast<VDofTransformation*>(doftrans);
+         int vdoftrans_vdim = 1;
          if (vdoftrans)
          {
-            new_doftrans = doftrans;
-            doftrans = vdoftrans->GetDofTransformation();
+            vdoftrans_vdim = vdoftrans->GetVDim();
+            vdoftrans->SetVDim(1);
          }
 
          for (int vd = 0; vd < rvdim; vd++)
@@ -1754,13 +1755,13 @@ void FiniteElementSpace::RefinementOperator
             }
 
             lP.MultTranspose(subX, subYt);
-            old_DoFTrans[geom]->TransformDual(subYt);
+            old_DoFTrans.TransformDual(subYt);
             y.AddElementVector(c_vdofs, subYt);
          }
 
          if (vdoftrans)
          {
-            doftrans = new_doftrans;
+            vdoftrans->SetVDim(vdoftrans_vdim);
          }
       }
 
@@ -1989,8 +1990,8 @@ FiniteElementSpace::DerefinementOperator::~DerefinementOperator()
    delete coarse_elem_dof;
 }
 
-void FiniteElementSpace::DerefinementOperator
-::Mult(const Vector &x, Vector &y) const
+void FiniteElementSpace::DerefinementOperator::Mult(const Vector &x,
+                                                    Vector &y) const
 {
    Array<int> c_vdofs, f_vdofs;
    Vector loc_x, loc_y;
@@ -2189,7 +2190,7 @@ void FiniteElementSpace::Constructor(Mesh *mesh_, NURBSExtension *NURBSext_,
       cP = cR = cR_hp = NULL;
       cP_is_set = false;
 
-      ConstructDoFTrans();
+      ConstructDoFTransArray();
    }
    else
    {
@@ -2201,40 +2202,39 @@ void FiniteElementSpace::Constructor(Mesh *mesh_, NURBSExtension *NURBSext_,
    BuildElementToDofTable();
 }
 
-void FiniteElementSpace::ConstructDoFTrans()
+void FiniteElementSpace::ConstructDoFTransArray()
 {
-   DestroyDoFTrans();
+   DestroyDoFTransArray();
 
-   VDoFTrans.SetVDim(vdim);
-   DoFTrans.SetSize(Geometry::NUM_GEOMETRIES);
-   for (int i=0; i<DoFTrans.Size(); i++)
+   DoFTransArray.SetSize(Geometry::NUM_GEOMETRIES);
+   for (int i=0; i<DoFTransArray.Size(); i++)
    {
-      DoFTrans[i] = NULL;
+      DoFTransArray[i] = NULL;
    }
    if (mesh->Dimension() < 3) { return; }
    if (dynamic_cast<const ND_FECollection*>(fec))
    {
-      const FiniteElement * nd_tri =
+      const FiniteElement *nd_tri =
          fec->FiniteElementForGeometry(Geometry::TRIANGLE);
       if (nd_tri)
       {
-         DoFTrans[Geometry::TRIANGLE] =
+         DoFTransArray[Geometry::TRIANGLE] =
             new ND_TriDofTransformation(nd_tri->GetOrder());
       }
 
-      const FiniteElement * nd_tet =
+      const FiniteElement *nd_tet =
          fec->FiniteElementForGeometry(Geometry::TETRAHEDRON);
       if (nd_tet)
       {
-         DoFTrans[Geometry::TETRAHEDRON] =
+         DoFTransArray[Geometry::TETRAHEDRON] =
             new ND_TetDofTransformation(nd_tet->GetOrder());
       }
 
-      const FiniteElement * nd_pri =
+      const FiniteElement *nd_pri =
          fec->FiniteElementForGeometry(Geometry::PRISM);
       if (nd_pri)
       {
-         DoFTrans[Geometry::PRISM] =
+         DoFTransArray[Geometry::PRISM] =
             new ND_WedgeDofTransformation(nd_pri->GetOrder());
       }
    }
@@ -2435,7 +2435,7 @@ void FiniteElementSpace::Construct()
 
    ndofs = nvdofs + nedofs + nfdofs + nbdofs;
 
-   ConstructDoFTrans();
+   ConstructDoFTransArray();
 
    // record the current mesh sequence number to detect refinement etc.
    mesh_sequence = mesh->GetSequence();
@@ -2460,9 +2460,8 @@ int FiniteElementSpace::MinOrder(VarOrderBits bits)
    return 0;
 }
 
-void FiniteElementSpace
-::CalcEdgeFaceVarOrders(Array<VarOrderBits> &edge_orders,
-                        Array<VarOrderBits> &face_orders) const
+void FiniteElementSpace::CalcEdgeFaceVarOrders(
+   Array<VarOrderBits> &edge_orders, Array<VarOrderBits> &face_orders) const
 {
    MFEM_ASSERT(IsVariableOrder(), "");
    MFEM_ASSERT(Nonconforming(), "");
@@ -2688,8 +2687,8 @@ int FiniteElementSpace::GetNVariants(int entity, int index) const
 static const char* msg_orders_changed =
    "Element orders changed, you need to Update() the space first.";
 
-DofTransformation *
-FiniteElementSpace::GetElementDofs(int elem, Array<int> &dofs) const
+void FiniteElementSpace::GetElementDofs(int elem, Array<int> &dofs,
+                                        DofTransformation &doftrans) const
 {
    MFEM_VERIFY(!orders_changed, msg_orders_changed);
 
@@ -2697,13 +2696,15 @@ FiniteElementSpace::GetElementDofs(int elem, Array<int> &dofs) const
    {
       elem_dof->GetRow(elem, dofs);
 
-      if (DoFTrans[mesh->GetElementBaseGeometry(elem)])
+      if (DoFTransArray[mesh->GetElementBaseGeometry(elem)])
       {
          Array<int> Fo;
          elem_fos -> GetRow (elem, Fo);
-         DoFTrans[mesh->GetElementBaseGeometry(elem)]->SetFaceOrientations(Fo);
+         doftrans.SetDofTransformation(
+            *DoFTransArray[mesh->GetElementBaseGeometry(elem)]);
+         doftrans.SetFaceOrientations(Fo);
       }
-      return DoFTrans[mesh->GetElementBaseGeometry(elem)];
+      return;
    }
 
    Array<int> V, E, Eo, F, Fo; // TODO: LocalArray
@@ -2727,10 +2728,11 @@ FiniteElementSpace::GetElementDofs(int elem, Array<int> &dofs) const
       {
          nfd += fec->GetNumDof(mesh->GetFaceGeometry(F[i]), order);
       }
-      if (DoFTrans[mesh->GetElementBaseGeometry(elem)])
+      if (DoFTransArray[mesh->GetElementBaseGeometry(elem)])
       {
-         DoFTrans[mesh->GetElementBaseGeometry(elem)]
-         -> SetFaceOrientations(Fo);
+         doftrans.SetDofTransformation(
+            *DoFTransArray[mesh->GetElementBaseGeometry(elem)]);
+         doftrans.SetFaceOrientations(Fo);
       }
    }
 
@@ -2789,41 +2791,18 @@ FiniteElementSpace::GetElementDofs(int elem, Array<int> &dofs) const
          dofs.Append(bbase + j);
       }
    }
-   return DoFTrans[mesh->GetElementBaseGeometry(elem)];
 }
 
-const FiniteElement *FiniteElementSpace::GetFE(int i) const
+DofTransformation *FiniteElementSpace::GetElementDofs(int elem,
+                                                      Array<int> &dofs) const
 {
-   if (i < 0 || !mesh->GetNE()) { return NULL; }
-   MFEM_VERIFY(i < mesh->GetNE(),
-               "Invalid element id " << i << ", maximum allowed " << mesh->GetNE()-1);
-
-   const FiniteElement *FE =
-      fec->GetFE(mesh->GetElementGeometry(i), GetElementOrderImpl(i));
-
-   if (NURBSext)
-   {
-      NURBSext->LoadFE(i, FE);
-   }
-   else
-   {
-#ifdef MFEM_DEBUG
-      // consistency check: fec->GetOrder() and FE->GetOrder() should return
-      // the same value (for standard, constant-order spaces)
-      if (!IsVariableOrder() && FE->GetDim() > 0)
-      {
-         MFEM_ASSERT(FE->GetOrder() == fec->GetOrder(),
-                     "internal error: " <<
-                     FE->GetOrder() << " != " << fec->GetOrder());
-      }
-#endif
-   }
-
-   return FE;
+   DoFTrans.SetDofTransformation(NULL);
+   GetElementDofs(elem, dofs, DoFTrans);
+   return DoFTrans.GetDofTransformation() ? &DoFTrans : NULL;
 }
 
-DofTransformation *
-FiniteElementSpace::GetBdrElementDofs(int bel, Array<int> &dofs) const
+void FiniteElementSpace::GetBdrElementDofs(int bel, Array<int> &dofs,
+                                           DofTransformation &doftrans) const
 {
    MFEM_VERIFY(!orders_changed, msg_orders_changed);
 
@@ -2831,17 +2810,18 @@ FiniteElementSpace::GetBdrElementDofs(int bel, Array<int> &dofs) const
    {
       bdr_elem_dof->GetRow(bel, dofs);
 
-      if (DoFTrans[mesh->GetBdrElementBaseGeometry(bel)])
+      if (DoFTransArray[mesh->GetBdrElementBaseGeometry(bel)])
       {
          Array<int> Fo;
          bdr_elem_fos -> GetRow (bel, Fo);
-         DoFTrans[mesh->GetBdrElementBaseGeometry(bel)]->
-         SetFaceOrientations(Fo);
+         doftrans.SetDofTransformation(
+            *DoFTransArray[mesh->GetBdrElementBaseGeometry(bel)]);
+         doftrans.SetFaceOrientations(Fo);
       }
-      return DoFTrans[mesh->GetBdrElementBaseGeometry(bel)];
+      return;
    }
 
-   Array<int> V, E, Eo, Fo; // TODO: LocalArray
+   Array<int> V, E, Eo; // TODO: LocalArray
    int F, oF;
 
    int dim = mesh->Dimension();
@@ -2865,11 +2845,13 @@ FiniteElementSpace::GetBdrElementDofs(int bel, Array<int> &dofs) const
    {
       mesh->GetBdrElementFace(bel, &F, &oF);
 
-      if (DoFTrans[mesh->GetBdrElementBaseGeometry(bel)])
+      if (DoFTransArray[mesh->GetBdrElementBaseGeometry(bel)])
       {
-         Fo.Append(oF);
-         DoFTrans[mesh->GetBdrElementBaseGeometry(bel)]->
-         SetFaceOrientations(Fo);
+         mfem::Array<int> Fo(1);
+         Fo[0] = oF;
+         doftrans.SetDofTransformation(
+            *DoFTransArray[mesh->GetBdrElementBaseGeometry(bel)]);
+         doftrans.SetFaceOrientations(Fo);
       }
    }
 
@@ -2911,8 +2893,14 @@ FiniteElementSpace::GetBdrElementDofs(int bel, Array<int> &dofs) const
          dofs.Append(EncodeDof(nvdofs + nedofs + fbase, ind[j]));
       }
    }
+}
 
-   return DoFTrans[mesh->GetBdrElementBaseGeometry(bel)];
+DofTransformation *FiniteElementSpace::GetBdrElementDofs(int bel,
+                                                         Array<int> &dofs) const
+{
+   DoFTrans.SetDofTransformation(NULL);
+   GetBdrElementDofs(bel, dofs, DoFTrans);
+   return DoFTrans.GetDofTransformation() ? &DoFTrans : NULL;
 }
 
 int FiniteElementSpace::GetFaceDofs(int face, Array<int> &dofs,
@@ -3111,6 +3099,36 @@ void FiniteElementSpace::GetFaceInteriorDofs(int i, Array<int> &dofs) const
    }
 }
 
+const FiniteElement *FiniteElementSpace::GetFE(int i) const
+{
+   if (i < 0 || !mesh->GetNE()) { return NULL; }
+   MFEM_VERIFY(i < mesh->GetNE(),
+               "Invalid element id " << i << ", maximum allowed " << mesh->GetNE()-1);
+
+   const FiniteElement *FE =
+      fec->GetFE(mesh->GetElementGeometry(i), GetElementOrderImpl(i));
+
+   if (NURBSext)
+   {
+      NURBSext->LoadFE(i, FE);
+   }
+   else
+   {
+#ifdef MFEM_DEBUG
+      // consistency check: fec->GetOrder() and FE->GetOrder() should return
+      // the same value (for standard, constant-order spaces)
+      if (!IsVariableOrder() && FE->GetDim() > 0)
+      {
+         MFEM_ASSERT(FE->GetOrder() == fec->GetOrder(),
+                     "internal error: " <<
+                     FE->GetOrder() << " != " << fec->GetOrder());
+      }
+#endif
+   }
+
+   return FE;
+}
+
 const FiniteElement *FiniteElementSpace::GetBE(int i) const
 {
    int order = fec->GetOrder();
@@ -3183,8 +3201,8 @@ const FiniteElement *FiniteElementSpace::GetEdgeElement(int i,
    return fec->GetFE(Geometry::SEGMENT, eo);
 }
 
-const FiniteElement *FiniteElementSpace
-::GetTraceElement(int i, Geometry::Type geom_type) const
+const FiniteElement *FiniteElementSpace::GetTraceElement(
+   int i, Geometry::Type geom_type) const
 {
    return fec->TraceFiniteElementForGeometry(geom_type);
 }
@@ -3222,7 +3240,7 @@ void FiniteElementSpace::Destroy()
    }
    E2BFQ_array.SetSize(0);
 
-   DestroyDoFTrans();
+   DestroyDoFTransArray();
 
    dof_elem_array.DeleteAll();
    dof_ldof_array.DeleteAll();
@@ -3240,19 +3258,18 @@ void FiniteElementSpace::Destroy()
       delete bdr_elem_dof;
       delete bdr_elem_fos;
       delete face_dof;
-
       delete [] bdofs;
    }
    ceed::RemoveBasisAndRestriction(this);
 }
 
-void FiniteElementSpace::DestroyDoFTrans()
+void FiniteElementSpace::DestroyDoFTransArray()
 {
-   for (int i = 0; i < DoFTrans.Size(); i++)
+   for (int i = 0; i < DoFTransArray.Size(); i++)
    {
-      delete DoFTrans[i];
+      delete DoFTransArray[i];
    }
-   DoFTrans.SetSize(0);
+   DoFTransArray.SetSize(0);
 }
 
 void FiniteElementSpace::GetTransferOperator(
diff --git a/fem/fespace.hpp b/fem/fespace.hpp
index 9b3d2e70f..be962050a 100644
--- a/fem/fespace.hpp
+++ b/fem/fespace.hpp
@@ -271,7 +271,8 @@ protected:
    int own_ext;
    mutable Array<int> face_to_be; // NURBS FE space only
 
-   Array<DofTransformation*> DoFTrans;
+   Array<StatelessDofTransformation *> DoFTransArray;
+   mutable DofTransformation DoFTrans;
    mutable VDofTransformation VDoFTrans;
 
    /** Matrix representing the prolongation from the global conforming dofs to
@@ -326,8 +327,8 @@ protected:
    void Construct();
    void Destroy();
 
-   void ConstructDoFTrans();
-   void DestroyDoFTrans();
+   void ConstructDoFTransArray();
+   void DestroyDoFTransArray();
 
    void BuildElementToDofTable() const;
    void BuildBdrElementToDofTable() const;
@@ -414,10 +415,11 @@ protected:
       Table* old_elem_dof; // Owned.
       Table* old_elem_fos; // Owned.
 
-      Array<DofTransformation*> old_DoFTrans;
+      Array<StatelessDofTransformation*> old_DoFTransArray;
+      mutable DofTransformation old_DoFTrans;
       mutable VDofTransformation old_VDoFTrans;
 
-      void ConstructDoFTrans();
+      void ConstructDoFTransArray();
 
    public:
       /** Construct the operator based on the elem_dof table of the original
@@ -784,6 +786,15 @@ public:
    /// @note The returned object should NOT be deleted by the caller.
    virtual DofTransformation *GetElementDofs(int elem, Array<int> &dofs) const;
 
+   /// @brief The same as GetElementDofs(), but with a user-allocated
+   /// DofTransformation object. @a doftrans must be allocated in advance and
+   /// will be owned by the caller. The user can use the
+   /// DofTransformation::GetDofTransformation method on the returned
+   /// @a doftrans object to detect if the DofTransformation should actually be
+   /// used.
+   virtual void GetElementDofs(int elem, Array<int> &dofs,
+                               DofTransformation &doftrans) const;
+
    /// @brief Returns indices of degrees of freedom for boundary element 'bel'.
    /// The returned indices are offsets into an @ref ldof vector. See also
    /// GetBdrElementVDofs().
@@ -799,6 +810,15 @@ public:
    virtual DofTransformation *GetBdrElementDofs(int bel,
                                                 Array<int> &dofs) const;
 
+   /// @brief The same as GetBdrElementDofs(), but with a user-allocated
+   /// DofTransformation object. @a doftrans must be allocated in advance and
+   /// will be owned by the caller. The user can use the
+   /// DofTransformation::GetDofTransformation method on the returned
+   /// @a doftrans object to detect if the DofTransformation should actually be
+   /// used.
+   virtual void GetBdrElementDofs(int bel, Array<int> &dofs,
+                                  DofTransformation &doftrans) const;
+
    /// @brief Returns the indices of the degrees of freedom for the specified
    /// face, including the DOFs for the edges and the vertices of the face.
    ///
@@ -1271,11 +1291,9 @@ public:
 /// @brief Return true if the mesh contains only one topology and the elements are tensor elements.
 inline bool UsesTensorBasis(const FiniteElementSpace& fes)
 {
-   Mesh & mesh = *fes.GetMesh();
-   const bool mixed = mesh.GetNumGeometries(mesh.Dimension()) > 1;
-   // Potential issue: empty local mesh --> no element 0.
-   return !mixed &&
-          dynamic_cast<const mfem::TensorBasisElement *>(fes.GetFE(0))!=nullptr;
+   Mesh &mesh = *fes.GetMesh();
+   return mesh.GetNE() > 0 && mesh.GetNumGeometries(mesh.Dimension()) == 1 &&
+          dynamic_cast<const mfem::TensorBasisElement *>(fes.GetFE(0)) != nullptr;
 }
 
 }
diff --git a/fem/geom.cpp b/fem/geom.cpp
index 5438d741f..885312923 100644
--- a/fem/geom.cpp
+++ b/fem/geom.cpp
@@ -262,7 +262,7 @@ Geometry::~Geometry()
    }
 }
 
-const IntegrationRule * Geometry::GetVertices(int GeomType)
+const IntegrationRule *Geometry::GetVertices(int GeomType) const
 {
    switch (GeomType)
    {
@@ -274,8 +274,9 @@ const IntegrationRule * Geometry::GetVertices(int GeomType)
       case Geometry::CUBE:        return GeomVert[5];
       case Geometry::PRISM:       return GeomVert[6];
       case Geometry::PYRAMID:     return GeomVert[7];
-      default:
-         mfem_error ("Geometry::GetVertices(...)");
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         mfem_error("Geometry::GetVertices(...)");
    }
    // make some compilers happy.
    return GeomVert[0];
@@ -370,7 +371,8 @@ void Geometry::GetRandomPoint(int GeomType, IntegrationPoint &ip)
             ip.x = 1.0 - z;
          }
          break;
-      default:
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
          MFEM_ABORT("Unknown type of reference element!");
    }
 }
@@ -435,12 +437,14 @@ bool Geometry::CheckPoint(int GeomType, const IntegrationPoint &ip)
          if (ip.x < 0.0 || ip.y < 0.0 || ip.x+ip.z > 1.0 || ip.y+ip.z > 1.0 ||
              ip.z < 0.0 || ip.z > 1.0) { return false; }
          break;
-      default:
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
          MFEM_ABORT("Unknown type of reference element!");
    }
    return true;
 }
 
+// static method
 bool Geometry::CheckPoint(int GeomType, const IntegrationPoint &ip, double eps)
 {
    switch (GeomType)
@@ -516,7 +520,8 @@ bool Geometry::CheckPoint(int GeomType, const IntegrationPoint &ip, double eps)
             return false;
          }
          break;
-      default:
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
          MFEM_ABORT("Unknown type of reference element!");
    }
    return true;
@@ -640,7 +645,8 @@ bool Geometry::ProjectPoint(int GeomType, const IntegrationPoint &beg,
                           };
          return internal::IntersectSegment<6,3>(lbeg, lend, end);
       }
-      default:
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
          MFEM_ABORT("Unknown type of reference element!");
    }
    return true;
@@ -774,13 +780,16 @@ bool Geometry::ProjectPoint(int GeomType, IntegrationPoint &ip)
          }
       }
 
-      default:
+      case Geometry::POINT:
          MFEM_ABORT("Reference element type is not supported!");
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
    return true;
 }
 
-void Geometry::GetPerfPointMat(int GeomType, DenseMatrix &pm)
+void Geometry::GetPerfPointMat(int GeomType, DenseMatrix &pm) const
 {
    switch (GeomType)
    {
@@ -859,8 +868,11 @@ void Geometry::GetPerfPointMat(int GeomType, DenseMatrix &pm)
       }
       break;
 
-      default:
-         mfem_error ("Geometry::GetPerfPointMat (...)");
+      case Geometry::POINT:
+         MFEM_ABORT("Reference element type is not supported!");
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
 }
 
@@ -1055,11 +1067,6 @@ Constants<Geometry::PYRAMID>::VertToVert::J[8][2] =
 };
 
 
-GeometryRefiner::GeometryRefiner()
-{
-   type = Quadrature1D::ClosedUniform;
-}
-
 GeometryRefiner::~GeometryRefiner()
 {
    for (int i = 0; i < Geometry::NumGeom; i++)
@@ -1070,10 +1077,9 @@ GeometryRefiner::~GeometryRefiner()
 }
 
 RefinedGeometry *GeometryRefiner::FindInRGeom(Geometry::Type Geom,
-                                              int Times, int ETimes,
-                                              int Type)
+                                              int Times, int ETimes) const
 {
-   Array<RefinedGeometry *> &RGA = RGeom[Geom];
+   const Array<RefinedGeometry *> &RGA = RGeom[Geom];
    for (int i = 0; i < RGA.Size(); i++)
    {
       RefinedGeometry &RG = *RGA[i];
@@ -1085,9 +1091,10 @@ RefinedGeometry *GeometryRefiner::FindInRGeom(Geometry::Type Geom,
    return NULL;
 }
 
-IntegrationRule *GeometryRefiner::FindInIntPts(Geometry::Type Geom, int NPts)
+IntegrationRule *GeometryRefiner::FindInIntPts(Geometry::Type Geom,
+                                               int NPts) const
 {
-   Array<IntegrationRule *> &IPA = IntPts[Geom];
+   const Array<IntegrationRule *> &IPA = IntPts[Geom];
    for (int i = 0; i < IPA.Size(); i++)
    {
       IntegrationRule &ir = *IPA[i];
@@ -1096,491 +1103,538 @@ IntegrationRule *GeometryRefiner::FindInIntPts(Geometry::Type Geom, int NPts)
    return NULL;
 }
 
-RefinedGeometry * GeometryRefiner::Refine(Geometry::Type Geom,
-                                          int Times, int ETimes)
+RefinedGeometry *GeometryRefiner::Refine(Geometry::Type Geom, int Times,
+                                         int ETimes)
 {
+   RefinedGeometry *RG = NULL;
    int i, j, k, l, m;
-
    Times = std::max(Times, 1);
    ETimes = Geometry::Dimension[Geom] <= 1 ? 0 : std::max(ETimes, 1);
-   const double *cp = poly1d.GetPoints(Times, BasisType::GetNodalBasis(type));
+   const double *cp = poly1d.GetPoints(Times, BasisType::GetNodalBasis(Type));
 
-   RefinedGeometry *RG = FindInRGeom(Geom, Times, ETimes, type);
-   if (RG) { return RG; }
-
-   switch (Geom)
+#ifdef MFEM_USE_OPENMP
+   #pragma omp critical (Refine)
+#endif
    {
-      case Geometry::POINT:
+      RG = FindInRGeom(Geom, Times, ETimes);
+      if (!RG)
       {
-         RG = new RefinedGeometry(1, 1, 0);
-         RG->Times = 1;
-         RG->ETimes = 0;
-         RG->Type = type;
-         RG->RefPts.IntPoint(0).x = cp[0];
-         RG->RefGeoms[0] = 0;
-
-         RGeom[Geometry::POINT].Append(RG);
-         return RG;
-      }
-
-      case Geometry::SEGMENT:
-      {
-         RG = new RefinedGeometry(Times+1, 2*Times, 0);
-         RG->Times = Times;
-         RG->ETimes = 0;
-         RG->Type = type;
-         for (i = 0; i <= Times; i++)
-         {
-            IntegrationPoint &ip = RG->RefPts.IntPoint(i);
-            ip.x = cp[i];
-         }
-         Array<int> &G = RG->RefGeoms;
-         for (i = 0; i < Times; i++)
+         switch (Geom)
          {
-            G[2*i+0] = i;
-            G[2*i+1] = i+1;
-         }
-
-         RGeom[Geometry::SEGMENT].Append(RG);
-         return RG;
-      }
-
-      case Geometry::TRIANGLE:
-      {
-         RG = new RefinedGeometry((Times+1)*(Times+2)/2, 3*Times*Times,
-                                  3*Times*(ETimes+1), 3*Times);
-         RG->Times = Times;
-         RG->ETimes = ETimes;
-         RG->Type = type;
-         for (k = j = 0; j <= Times; j++)
-            for (i = 0; i <= Times-j; i++, k++)
+            case Geometry::POINT:
             {
-               IntegrationPoint &ip = RG->RefPts.IntPoint(k);
-               ip.x = cp[i]/(cp[i] + cp[j] + cp[Times-i-j]);
-               ip.y = cp[j]/(cp[i] + cp[j] + cp[Times-i-j]);
+               RG = new RefinedGeometry(1, 1, 0);
+               RG->Times = 1;
+               RG->ETimes = 0;
+               RG->Type = Type;
+               RG->RefPts.IntPoint(0).x = cp[0];
+               RG->RefGeoms[0] = 0;
+
+               RGeom[Geometry::POINT].Append(RG);
             }
-         Array<int> &G = RG->RefGeoms;
-         for (l = k = j = 0; j < Times; j++, k++)
-            for (i = 0; i < Times-j; i++, k++)
+            break;
+
+            case Geometry::SEGMENT:
             {
-               G[l++] = k;
-               G[l++] = k+1;
-               G[l++] = k+Times-j+1;
-               if (i+j+1 < Times)
+               RG = new RefinedGeometry(Times+1, 2*Times, 0);
+               RG->Times = Times;
+               RG->ETimes = 0;
+               RG->Type = Type;
+               for (i = 0; i <= Times; i++)
                {
-                  G[l++] = k+1;
-                  G[l++] = k+Times-j+2;
-                  G[l++] = k+Times-j+1;
+                  IntegrationPoint &ip = RG->RefPts.IntPoint(i);
+                  ip.x = cp[i];
+               }
+               Array<int> &G = RG->RefGeoms;
+               for (i = 0; i < Times; i++)
+               {
+                  G[2*i+0] = i;
+                  G[2*i+1] = i+1;
                }
-            }
-         Array<int> &E = RG->RefEdges;
-         int lb = 0, li = 2*RG->NumBdrEdges;
-         // horizontal edges
-         for (k = 0; k < Times; k += Times/ETimes)
-         {
-            int &lt = (k == 0) ? lb : li;
-            j = k*(Times+1)-((k-1)*k)/2;
-            for (i = 0; i < Times-k; i++)
-            {
-               E[lt++] = j; j++;
-               E[lt++] = j;
-            }
-         }
-         // diagonal edges
-         for (k = Times; k > 0; k -= Times/ETimes)
-         {
-            int &lt = (k == Times) ? lb : li;
-            j = k;
-            for (i = 0; i < k; i++)
-            {
-               E[lt++] = j; j += Times-i;
-               E[lt++] = j;
-            }
-         }
-         // vertical edges
-         for (k = 0; k < Times; k += Times/ETimes)
-         {
-            int &lt = (k == 0) ? lb : li;
-            j = k;
-            for (i = 0; i < Times-k; i++)
-            {
-               E[lt++] = j; j += Times-i+1;
-               E[lt++] = j;
-            }
-         }
-
-         RGeom[Geometry::TRIANGLE].Append(RG);
-         return RG;
-      }
 
-      case Geometry::SQUARE:
-      {
-         RG = new RefinedGeometry((Times+1)*(Times+1), 4*Times*Times,
-                                  4*(ETimes+1)*Times, 4*Times);
-         RG->Times = Times;
-         RG->ETimes = ETimes;
-         RG->Type = type;
-         for (k = j = 0; j <= Times; j++)
-            for (i = 0; i <= Times; i++, k++)
-            {
-               IntegrationPoint &ip = RG->RefPts.IntPoint(k);
-               ip.x = cp[i];
-               ip.y = cp[j];
-            }
-         Array<int> &G = RG->RefGeoms;
-         for (l = k = j = 0; j < Times; j++, k++)
-            for (i = 0; i < Times; i++, k++)
-            {
-               G[l++] = k;
-               G[l++] = k+1;
-               G[l++] = k+Times+2;
-               G[l++] = k+Times+1;
+               RGeom[Geometry::SEGMENT].Append(RG);
             }
-         Array<int> &E = RG->RefEdges;
-         int lb = 0, li = 2*RG->NumBdrEdges;
-         // horizontal edges
-         for (k = 0; k <= Times; k += Times/ETimes)
-         {
-            int &lt = (k == 0 || k == Times) ? lb : li;
-            for (i = 0, j = k*(Times+1); i < Times; i++)
-            {
-               E[lt++] = j; j++;
-               E[lt++] = j;
-            }
-         }
-         // vertical edges (in right-to-left order)
-         for (k = Times; k >= 0; k -= Times/ETimes)
-         {
-            int &lt = (k == Times || k == 0) ? lb : li;
-            for (i = 0, j = k; i < Times; i++)
+            break;
+
+            case Geometry::TRIANGLE:
             {
-               E[lt++] = j; j += Times+1;
-               E[lt++] = j;
-            }
-         }
+               RG = new RefinedGeometry((Times+1)*(Times+2)/2, 3*Times*Times,
+                                        3*Times*(ETimes+1), 3*Times);
+               RG->Times = Times;
+               RG->ETimes = ETimes;
+               RG->Type = Type;
+               for (k = j = 0; j <= Times; j++)
+               {
+                  for (i = 0; i <= Times-j; i++, k++)
+                  {
+                     IntegrationPoint &ip = RG->RefPts.IntPoint(k);
+                     ip.x = cp[i]/(cp[i] + cp[j] + cp[Times-i-j]);
+                     ip.y = cp[j]/(cp[i] + cp[j] + cp[Times-i-j]);
+                  }
+               }
+               Array<int> &G = RG->RefGeoms;
+               for (l = k = j = 0; j < Times; j++, k++)
+               {
+                  for (i = 0; i < Times-j; i++, k++)
+                  {
+                     G[l++] = k;
+                     G[l++] = k+1;
+                     G[l++] = k+Times-j+1;
+                     if (i+j+1 < Times)
+                     {
+                        G[l++] = k+1;
+                        G[l++] = k+Times-j+2;
+                        G[l++] = k+Times-j+1;
+                     }
+                  }
+               }
+               Array<int> &E = RG->RefEdges;
+               int lb = 0, li = 2*RG->NumBdrEdges;
+               // horizontal edges
+               for (k = 0; k < Times; k += Times/ETimes)
+               {
+                  int &lt = (k == 0) ? lb : li;
+                  j = k*(Times+1)-((k-1)*k)/2;
+                  for (i = 0; i < Times-k; i++)
+                  {
+                     E[lt++] = j; j++;
+                     E[lt++] = j;
+                  }
+               }
+               // diagonal edges
+               for (k = Times; k > 0; k -= Times/ETimes)
+               {
+                  int &lt = (k == Times) ? lb : li;
+                  j = k;
+                  for (i = 0; i < k; i++)
+                  {
+                     E[lt++] = j; j += Times-i;
+                     E[lt++] = j;
+                  }
+               }
+               // vertical edges
+               for (k = 0; k < Times; k += Times/ETimes)
+               {
+                  int &lt = (k == 0) ? lb : li;
+                  j = k;
+                  for (i = 0; i < Times-k; i++)
+                  {
+                     E[lt++] = j; j += Times-i+1;
+                     E[lt++] = j;
+                  }
+               }
 
-         RGeom[Geometry::SQUARE].Append(RG);
-         return RG;
-      }
+               RGeom[Geometry::TRIANGLE].Append(RG);
+            }
+            break;
 
-      case Geometry::CUBE:
-      {
-         RG = new RefinedGeometry ((Times+1)*(Times+1)*(Times+1),
-                                   8*Times*Times*Times, 0);
-         RG->Times = Times;
-         RG->ETimes = ETimes;
-         RG->Type = type;
-         for (l = k = 0; k <= Times; k++)
-            for (j = 0; j <= Times; j++)
-               for (i = 0; i <= Times; i++, l++)
+            case Geometry::SQUARE:
+            {
+               RG = new RefinedGeometry((Times+1)*(Times+1), 4*Times*Times,
+                                        4*(ETimes+1)*Times, 4*Times);
+               RG->Times = Times;
+               RG->ETimes = ETimes;
+               RG->Type = Type;
+               for (k = j = 0; j <= Times; j++)
                {
-                  IntegrationPoint &ip = RG->RefPts.IntPoint(l);
-                  ip.x = cp[i];
-                  ip.y = cp[j];
-                  ip.z = cp[k];
+                  for (i = 0; i <= Times; i++, k++)
+                  {
+                     IntegrationPoint &ip = RG->RefPts.IntPoint(k);
+                     ip.x = cp[i];
+                     ip.y = cp[j];
+                  }
                }
-         Array<int> &G = RG->RefGeoms;
-         for (l = k = 0; k < Times; k++)
-            for (j = 0; j < Times; j++)
-               for (i = 0; i < Times; i++)
+               Array<int> &G = RG->RefGeoms;
+               for (l = k = j = 0; j < Times; j++, k++)
                {
-                  G[l++] = i+0 + (j+0 + (k+0) * (Times+1)) * (Times+1);
-                  G[l++] = i+1 + (j+0 + (k+0) * (Times+1)) * (Times+1);
-                  G[l++] = i+1 + (j+1 + (k+0) * (Times+1)) * (Times+1);
-                  G[l++] = i+0 + (j+1 + (k+0) * (Times+1)) * (Times+1);
-                  G[l++] = i+0 + (j+0 + (k+1) * (Times+1)) * (Times+1);
-                  G[l++] = i+1 + (j+0 + (k+1) * (Times+1)) * (Times+1);
-                  G[l++] = i+1 + (j+1 + (k+1) * (Times+1)) * (Times+1);
-                  G[l++] = i+0 + (j+1 + (k+1) * (Times+1)) * (Times+1);
+                  for (i = 0; i < Times; i++, k++)
+                  {
+                     G[l++] = k;
+                     G[l++] = k+1;
+                     G[l++] = k+Times+2;
+                     G[l++] = k+Times+1;
+                  }
+               }
+               Array<int> &E = RG->RefEdges;
+               int lb = 0, li = 2*RG->NumBdrEdges;
+               // horizontal edges
+               for (k = 0; k <= Times; k += Times/ETimes)
+               {
+                  int &lt = (k == 0 || k == Times) ? lb : li;
+                  for (i = 0, j = k*(Times+1); i < Times; i++)
+                  {
+                     E[lt++] = j; j++;
+                     E[lt++] = j;
+                  }
+               }
+               // vertical edges (in right-to-left order)
+               for (k = Times; k >= 0; k -= Times/ETimes)
+               {
+                  int &lt = (k == Times || k == 0) ? lb : li;
+                  for (i = 0, j = k; i < Times; i++)
+                  {
+                     E[lt++] = j; j += Times+1;
+                     E[lt++] = j;
+                  }
                }
 
-         RGeom[Geometry::CUBE].Append(RG);
-         return RG;
-      }
+               RGeom[Geometry::SQUARE].Append(RG);
+            }
+            break;
 
-      case Geometry::TETRAHEDRON:
-      {
-         // subdivide the tetrahedron with vertices
-         // (0,0,0), (0,0,1), (1,1,1), (0,1,1)
-
-         // vertices: 0 <= i <= j <= k <= Times
-         // (3-combination with repetitions)
-         // number of vertices: (n+3)*(n+2)*(n+1)/6, n = Times
-
-         // elements: the vertices are: v1=(i,j,k), v2=v1+u1, v3=v2+u2, v4=v3+u3
-         // where 0 <= i <= j <= k <= n-1 and
-         // u1,u2,u3 is a permutation of (1,0,0),(0,1,0),(0,0,1)
-         // such that all v2,v3,v4 have non-decreasing components
-         // number of elements: n^3
-
-         const int n = Times;
-         RG = new RefinedGeometry((n+3)*(n+2)*(n+1)/6, 4*n*n*n, 0);
-         RG->Times = Times;
-         RG->ETimes = ETimes;
-         RG->Type = type;
-         // enumerate and define the vertices
-         Array<int> vi((n+1)*(n+1)*(n+1));
-         vi = -1;
-         m = 0;
-
-         // vertices are given in lexicographic ordering on the reference
-         // element
-         for (int kk = 0; kk <= n; kk++)
-            for (int jj = 0; jj <= n-kk; jj++)
-               for (int ii = 0; ii <= n-jj-kk; ii++)
+            case Geometry::CUBE:
+            {
+               RG = new RefinedGeometry ((Times+1)*(Times+1)*(Times+1),
+                                         8*Times*Times*Times, 0);
+               RG->Times = Times;
+               RG->ETimes = ETimes;
+               RG->Type = Type;
+               for (l = k = 0; k <= Times; k++)
+               {
+                  for (j = 0; j <= Times; j++)
+                  {
+                     for (i = 0; i <= Times; i++, l++)
+                     {
+                        IntegrationPoint &ip = RG->RefPts.IntPoint(l);
+                        ip.x = cp[i];
+                        ip.y = cp[j];
+                        ip.z = cp[k];
+                     }
+                  }
+               }
+               Array<int> &G = RG->RefGeoms;
+               for (l = k = 0; k < Times; k++)
                {
-                  IntegrationPoint &ip = RG->RefPts.IntPoint(m);
-                  double w = cp[ii] + cp[jj] + cp[kk] + cp[Times-ii-jj-kk];
-                  ip.x = cp[ii]/w;
-                  ip.y = cp[jj]/w;
-                  ip.z = cp[kk]/w;
-                  // (ii,jj,kk) are coordinates in the reference tetrahedron,
-                  // transform to coordinates (i,j,k) in the auxiliary
-                  // tetrahedron defined by (0,0,0), (0,0,1), (1,1,1), (0,1,1)
-                  i = jj;
-                  j = jj+kk;
-                  k = ii+jj+kk;
-                  l = i + (j + k * (n+1)) * (n+1);
-                  // map from linear Cartesian hex index in the auxiliary tet
-                  // to lexicographic in the reference tet
-                  vi[l] = m;
-                  m++;
+                  for (j = 0; j < Times; j++)
+                  {
+                     for (i = 0; i < Times; i++)
+                     {
+                        G[l++] = i+0 + (j+0 + (k+0) * (Times+1)) * (Times+1);
+                        G[l++] = i+1 + (j+0 + (k+0) * (Times+1)) * (Times+1);
+                        G[l++] = i+1 + (j+1 + (k+0) * (Times+1)) * (Times+1);
+                        G[l++] = i+0 + (j+1 + (k+0) * (Times+1)) * (Times+1);
+                        G[l++] = i+0 + (j+0 + (k+1) * (Times+1)) * (Times+1);
+                        G[l++] = i+1 + (j+0 + (k+1) * (Times+1)) * (Times+1);
+                        G[l++] = i+1 + (j+1 + (k+1) * (Times+1)) * (Times+1);
+                        G[l++] = i+0 + (j+1 + (k+1) * (Times+1)) * (Times+1);
+                     }
+                  }
                }
 
-         if (m != (n+3)*(n+2)*(n+1)/6)
-         {
-            mfem_error("GeometryRefiner::Refine() for TETRAHEDRON #1");
-         }
-         // elements
-         Array<int> &G = RG->RefGeoms;
-         m = 0;
-         for (k = 0; k < n; k++)
-            for (j = 0; j <= k; j++)
-               for (i = 0; i <= j; i++)
+               RGeom[Geometry::CUBE].Append(RG);
+            }
+            break;
+
+            case Geometry::TETRAHEDRON:
+            {
+               // subdivide the tetrahedron with vertices
+               // (0,0,0), (0,0,1), (1,1,1), (0,1,1)
+
+               // vertices: 0 <= i <= j <= k <= Times
+               // (3-combination with repetitions)
+               // number of vertices: (n+3)*(n+2)*(n+1)/6, n = Times
+
+               // elements: the vertices are: v1=(i,j,k), v2=v1+u1, v3=v2+u2, v4=v3+u3
+               // where 0 <= i <= j <= k <= n-1 and
+               // u1,u2,u3 is a permutation of (1,0,0),(0,1,0),(0,0,1)
+               // such that all v2,v3,v4 have non-decreasing components
+               // number of elements: n^3
+
+               const int n = Times;
+               RG = new RefinedGeometry((n+3)*(n+2)*(n+1)/6, 4*n*n*n, 0);
+               RG->Times = Times;
+               RG->ETimes = ETimes;
+               RG->Type = Type;
+               // enumerate and define the vertices
+               Array<int> vi((n+1)*(n+1)*(n+1));
+               vi = -1;
+               m = 0;
+
+               // vertices are given in lexicographic ordering on the reference
+               // element
+               for (int kk = 0; kk <= n; kk++)
                {
-                  // the ordering of the vertices is chosen to ensure:
-                  // 1) correct orientation
-                  // 2) the x,y,z edges are in the set of edges
-                  //    {(0,1),(2,3), (0,2),(1,3)}
-                  //    (goal is to ensure that subsequent refinement using
-                  //    this procedure preserves the six tetrahedral shapes)
-
-                  // zyx: (i,j,k)-(i,j,k+1)-(i+1,j+1,k+1)-(i,j+1,k+1)
-                  G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
-                  G[m++] = vi[i+0 + (j+0 + (k+1) * (n+1)) * (n+1)];
-                  G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                  G[m++] = vi[i+0 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                  if (j < k)
+                  for (int jj = 0; jj <= n-kk; jj++)
                   {
-                     // yzx: (i,j,k)-(i+1,j+1,k+1)-(i,j+1,k)-(i,j+1,k+1)
-                     G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+0 + (j+1 + (k+0) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+0 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                     // yxz: (i,j,k)-(i,j+1,k)-(i+1,j+1,k+1)-(i+1,j+1,k)
-                     G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+0 + (j+1 + (k+0) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+1 + (k+0) * (n+1)) * (n+1)];
+                     for (int ii = 0; ii <= n-jj-kk; ii++)
+                     {
+                        IntegrationPoint &ip = RG->RefPts.IntPoint(m);
+                        double w = cp[ii] + cp[jj] + cp[kk] + cp[Times-ii-jj-kk];
+                        ip.x = cp[ii]/w;
+                        ip.y = cp[jj]/w;
+                        ip.z = cp[kk]/w;
+                        // (ii,jj,kk) are coordinates in the reference tetrahedron,
+                        // transform to coordinates (i,j,k) in the auxiliary
+                        // tetrahedron defined by (0,0,0), (0,0,1), (1,1,1), (0,1,1)
+                        i = jj;
+                        j = jj+kk;
+                        k = ii+jj+kk;
+                        l = i + (j + k * (n+1)) * (n+1);
+                        // map from linear Cartesian hex index in the auxiliary tet
+                        // to lexicographic in the reference tet
+                        vi[l] = m;
+                        m++;
+                     }
                   }
-                  if (i < j)
+               }
+
+               if (m != (n+3)*(n+2)*(n+1)/6)
+               {
+                  MFEM_ABORT("GeometryRefiner::Refine() for TETRAHEDRON #1");
+               }
+               // elements
+               Array<int> &G = RG->RefGeoms;
+               m = 0;
+               for (k = 0; k < n; k++)
+               {
+                  for (j = 0; j <= k; j++)
                   {
-                     // xzy: (i,j,k)-(i+1,j,k)-(i+1,j+1,k+1)-(i+1,j,k+1)
-                     G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+0 + (k+0) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+0 + (k+1) * (n+1)) * (n+1)];
-                     if (j < k)
+                     for (i = 0; i <= j; i++)
                      {
-                        // xyz: (i,j,k)-(i+1,j+1,k+1)-(i+1,j,k)-(i+1,j+1,k)
+                        // the ordering of the vertices is chosen to ensure:
+                        // 1) correct orientation
+                        // 2) the x,y,z edges are in the set of edges
+                        //    {(0,1),(2,3), (0,2),(1,3)}
+                        //    (goal is to ensure that subsequent refinement using
+                        //    this procedure preserves the six tetrahedral shapes)
+
+                        // zyx: (i,j,k)-(i,j,k+1)-(i+1,j+1,k+1)-(i,j+1,k+1)
                         G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                        G[m++] = vi[i+0 + (j+0 + (k+1) * (n+1)) * (n+1)];
                         G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                        G[m++] = vi[i+1 + (j+0 + (k+0) * (n+1)) * (n+1)];
-                        G[m++] = vi[i+1 + (j+1 + (k+0) * (n+1)) * (n+1)];
+                        G[m++] = vi[i+0 + (j+1 + (k+1) * (n+1)) * (n+1)];
+                        if (j < k)
+                        {
+                           // yzx: (i,j,k)-(i+1,j+1,k+1)-(i,j+1,k)-(i,j+1,k+1)
+                           G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+0 + (j+1 + (k+0) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+0 + (j+1 + (k+1) * (n+1)) * (n+1)];
+                           // yxz: (i,j,k)-(i,j+1,k)-(i+1,j+1,k+1)-(i+1,j+1,k)
+                           G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+0 + (j+1 + (k+0) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+1 + (k+0) * (n+1)) * (n+1)];
+                        }
+                        if (i < j)
+                        {
+                           // xzy: (i,j,k)-(i+1,j,k)-(i+1,j+1,k+1)-(i+1,j,k+1)
+                           G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+0 + (k+1) * (n+1)) * (n+1)];
+                           if (j < k)
+                           {
+                              // xyz: (i,j,k)-(i+1,j+1,k+1)-(i+1,j,k)-(i+1,j+1,k)
+                              G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                              G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
+                              G[m++] = vi[i+1 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                              G[m++] = vi[i+1 + (j+1 + (k+0) * (n+1)) * (n+1)];
+                           }
+                           // zxy: (i,j,k)-(i+1,j+1,k+1)-(i,j,k+1)-(i+1,j,k+1)
+                           G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+0 + (j+0 + (k+1) * (n+1)) * (n+1)];
+                           G[m++] = vi[i+1 + (j+0 + (k+1) * (n+1)) * (n+1)];
+                        }
                      }
-                     // zxy: (i,j,k)-(i+1,j+1,k+1)-(i,j,k+1)-(i+1,j,k+1)
-                     G[m++] = vi[i+0 + (j+0 + (k+0) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+1 + (k+1) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+0 + (j+0 + (k+1) * (n+1)) * (n+1)];
-                     G[m++] = vi[i+1 + (j+0 + (k+1) * (n+1)) * (n+1)];
                   }
                }
-         if (m != 4*n*n*n)
-         {
-            mfem_error("GeometryRefiner::Refine() for TETRAHEDRON #2");
-         }
-         for (i = 0; i < m; i++)
-            if (G[i] < 0)
-            {
-               mfem_error("GeometryRefiner::Refine() for TETRAHEDRON #3");
-            }
+               if (m != 4*n*n*n)
+               {
+                  MFEM_ABORT("GeometryRefiner::Refine() for TETRAHEDRON #2");
+               }
+               for (i = 0; i < m; i++)
+               {
+                  if (G[i] < 0)
+                  {
+                     MFEM_ABORT("GeometryRefiner::Refine() for TETRAHEDRON #3");
+                  }
+               }
 
-         RGeom[Geometry::TETRAHEDRON].Append(RG);
-         return RG;
-      }
+               RGeom[Geometry::TETRAHEDRON].Append(RG);
+            }
+            break;
 
-      case Geometry::PYRAMID:
-      {
-         const int n = Times;
-         RG = new RefinedGeometry ((n+1)*(n+2)*(2*n+3)/6,
-                                   5*n*(2*n-1)*(2*n+1)/3, 0);
-         RG->Times = Times;
-         RG->ETimes = ETimes;
-         RG->Type = type;
-         // enumerate and define the vertices
-         m = 0;
-         for (k = 0; k <= n; k++)
-         {
-            const double *cpij =
-               poly1d.GetPoints(Times - k, BasisType::GetNodalBasis(type));
-            for (j = 0; j <= n - k; j++)
-               for (i = 0; i <= n - k; i++)
+            case Geometry::PYRAMID:
+            {
+               const int n = Times;
+               RG = new RefinedGeometry ((n+1)*(n+2)*(2*n+3)/6,
+                                         5*n*(2*n-1)*(2*n+1)/3, 0);
+               RG->Times = Times;
+               RG->ETimes = ETimes;
+               RG->Type = Type;
+               // enumerate and define the vertices
+               m = 0;
+               for (k = 0; k <= n; k++)
                {
-                  IntegrationPoint &ip = RG->RefPts.IntPoint(m);
-                  if (type == 0)
+                  const double *cpij =
+                     poly1d.GetPoints(Times - k, BasisType::GetNodalBasis(Type));
+                  for (j = 0; j <= n - k; j++)
                   {
-                     ip.x = (n > k) ? (double(i) / (n - k)) : 0.0;
-                     ip.y = (n > k) ? (double(j) / (n - k)) : 0.0;
-                     ip.z = double(k) / n;
+                     for (i = 0; i <= n - k; i++)
+                     {
+                        IntegrationPoint &ip = RG->RefPts.IntPoint(m);
+                        if (Type == 0)
+                        {
+                           ip.x = (n > k) ? (double(i) / (n - k)) : 0.0;
+                           ip.y = (n > k) ? (double(j) / (n - k)) : 0.0;
+                           ip.z = double(k) / n;
+                        }
+                        else
+                        {
+                           ip.x = cpij[i] * (1.0 - cp[k]);
+                           ip.y = cpij[j] * (1.0 - cp[k]);
+                           ip.z = cp[k];
+                        }
+                        m++;
+                     }
                   }
-                  else
+               }
+               if (m != (n+1)*(n+2)*(2*n+3)/6)
+               {
+                  MFEM_ABORT("GeometryRefiner::Refine() for PYRAMID #1");
+               }
+               // elements
+               Array<int> &G = RG->RefGeoms;
+               m = 0;
+               for (k = 0; k < n; k++)
+               {
+                  int lk = k * (k * (2 * k - 6 * n - 9) + 6 * n * (n + 3) + 13) / 6;
+                  int lkp1 = (k + 1) *
+                             (k * (2 * k - 6 * n -5) + 6 * n * (n + 2) + 6) / 6;
+                  for (j = 0; j < n - k; j++)
                   {
-                     ip.x = cpij[i] * (1.0 - cp[k]);
-                     ip.y = cpij[j] * (1.0 - cp[k]);
-                     ip.z = cp[k];
+                     for (i = 0; i < n - k; i++)
+                     {
+                        G[m++] = lk + j * (n - k + 1) + i;
+                        G[m++] = lk + j * (n - k + 1) + i + 1;
+                        G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
+                        G[m++] = lk + (j + 1) * (n - k + 1) + i;
+                        G[m++] = lkp1 + j * (n - k) + i;
+                     }
+                  }
+                  for (j = 0; j < n - k - 1; j++)
+                  {
+                     for (i = 0; i < n - k - 1; i++)
+                     {
+                        G[m++] = lkp1 + j * (n - k) + i;
+                        G[m++] = lkp1 + (j + 1) * (n - k) + i;
+                        G[m++] = lkp1 + (j + 1) * (n - k) + i + 1;
+                        G[m++] = lkp1 + j * (n - k) + i + 1;
+                        G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
+                     }
+                  }
+                  for (j = 0; j < n - k; j++)
+                  {
+                     for (i = 0; i < n - k - 1; i++)
+                     {
+                        G[m++] = lk + j * (n - k + 1) + i + 1;
+                        G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
+                        G[m++] = lkp1 + j * (n - k) + i;
+                        G[m++] = lkp1 + j * (n - k) + i + 1;
+                        G[m++] = -1;
+                     }
+                  }
+                  for (j = 0; j < n - k - 1; j++)
+                  {
+                     for (i = 0; i < n - k; i++)
+                     {
+                        G[m++] = lk + (j + 1) * (n - k + 1) + i;
+                        G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
+                        G[m++] = lkp1 + (j + 1) * (n - k) + i;
+                        G[m++] = lkp1 + j * (n - k) + i;
+                        G[m++] = -1;
+                     }
                   }
-                  m++;
                }
-         }
-         if (m != (n+1)*(n+2)*(2*n+3)/6)
-         {
-            mfem_error("GeometryRefiner::Refine() for PYRAMID #1");
-         }
-         // elements
-         Array<int> &G = RG->RefGeoms;
-         m = 0;
-         for (k = 0; k < n; k++)
-         {
-            int lk = k * (k * (2 * k - 6 * n - 9) + 6 * n * (n + 3) + 13) / 6;
-            int lkp1 = (k + 1) *
-                       (k * (2 * k - 6 * n -5) + 6 * n * (n + 2) + 6) / 6;
-            for (j = 0; j < n - k; j++)
-            {
-               for (i = 0; i < n - k; i++)
+               if (m != 5*n*(2*n-1)*(2*n+1)/3)
                {
-                  G[m++] = lk + j * (n - k + 1) + i;
-                  G[m++] = lk + j * (n - k + 1) + i + 1;
-                  G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
-                  G[m++] = lk + (j + 1) * (n - k + 1) + i;
-                  G[m++] = lkp1 + j * (n - k) + i;
+                  MFEM_ABORT("GeometryRefiner::Refine() for PYRAMID #2");
                }
+
+               RGeom[Geometry::PYRAMID].Append(RG);
             }
-            for (j = 0; j < n - k - 1; j++)
+            break;
+
+            case Geometry::PRISM:
             {
-               for (i = 0; i < n - k - 1; i++)
+               const int n = Times;
+               RG = new RefinedGeometry ((n+1)*(n+1)*(n+2)/2, 6*n*n*n, 0);
+               RG->Times = Times;
+               RG->ETimes = ETimes;
+               RG->Type = Type;
+               // enumerate and define the vertices
+               m = 0;
+               for (l = k = 0; k <= n; k++)
                {
-                  G[m++] = lkp1 + j * (n - k) + i;
-                  G[m++] = lkp1 + (j + 1) * (n - k) + i;
-                  G[m++] = lkp1 + (j + 1) * (n - k) + i + 1;
-                  G[m++] = lkp1 + j * (n - k) + i + 1;
-                  G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
+                  for (j = 0; j <= n; j++)
+                  {
+                     for (i = 0; i <= n-j; i++, l++)
+                     {
+                        IntegrationPoint &ip = RG->RefPts.IntPoint(l);
+                        ip.x = cp[i]/(cp[i] + cp[j] + cp[n-i-j]);
+                        ip.y = cp[j]/(cp[i] + cp[j] + cp[n-i-j]);
+                        ip.z = cp[k];
+                        m++;
+                     }
+                  }
                }
-            }
-            for (j = 0; j < n - k; j++)
-            {
-               for (i = 0; i < n - k - 1; i++)
+               if (m != (n+1)*(n+1)*(n+2)/2)
                {
-                  G[m++] = lk + j * (n - k + 1) + i + 1;
-                  G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
-                  G[m++] = lkp1 + j * (n - k) + i;
-                  G[m++] = lkp1 + j * (n - k) + i + 1;
-                  G[m++] = -1;
+                  MFEM_ABORT("GeometryRefiner::Refine() for PRISM #1");
                }
-            }
-            for (j = 0; j < n - k - 1; j++)
-            {
-               for (i = 0; i < n - k; i++)
+               // elements
+               Array<int> &G = RG->RefGeoms;
+               m = 0;
+               for (m = k = 0; k < n; k++)
                {
-                  G[m++] = lk + (j + 1) * (n - k + 1) + i;
-                  G[m++] = lk + (j + 1) * (n - k + 1) + i + 1;
-                  G[m++] = lkp1 + (j + 1) * (n - k) + i;
-                  G[m++] = lkp1 + j * (n - k) + i;
-                  G[m++] = -1;
+                  for (l = j = 0; j < n; j++, l++)
+                  {
+                     for (i = 0; i < n-j; i++, l++)
+                     {
+                        G[m++] = l + (k+0) * (n+1) * (n+2) / 2;
+                        G[m++] = l + 1 + (k+0) * (n+1) * (n+2) / 2;
+                        G[m++] = l - j + (2 + (k+0) * (n+2)) * (n+1) / 2;
+                        G[m++] = l + (k+1) * (n+1) * (n+2) / 2;
+                        G[m++] = l + 1 + (k+1) * (n+1) * (Times+2) / 2;
+                        G[m++] = l - j + (2 + (k+1) * (n+2)) * (n+1) / 2;
+                        if (i+j+1 < n)
+                        {
+                           G[m++] = l + 1 + (k+0) * (n+1) * (n+2)/2;
+                           G[m++] = l - j + (2 + (k+0) * (n+1)) * (n+2) / 2;
+                           G[m++] = l - j + (2 + (k+0) * (n+2)) * (n+1) / 2;
+                           G[m++] = l + 1 + (k+1) * (n+1) * (n+2) / 2;
+                           G[m++] = l - j + (2 + (k+1) * (n+1)) * (n+2) / 2;
+                           G[m++] = l - j + (2 + (k+1) * (n+2)) * (n+1) / 2;
+                        }
+                     }
+                  }
                }
-            }
-         }
-         if (m != 5*n*(2*n-1)*(2*n+1)/3)
-         {
-            mfem_error("GeometryRefiner::Refine() for PYRAMID #2");
-         }
-         RGeom[Geometry::PYRAMID].Append(RG);
-         return RG;
-      }
-
-      case Geometry::PRISM:
-      {
-         const int n = Times;
-         RG = new RefinedGeometry ((n+1)*(n+1)*(n+2)/2, 6*n*n*n, 0);
-         RG->Times = Times;
-         RG->ETimes = ETimes;
-         RG->Type = type;
-         // enumerate and define the vertices
-         m = 0;
-         for (l = k = 0; k <= n; k++)
-            for (j = 0; j <= n; j++)
-               for (i = 0; i <= n-j; i++, l++)
+               if (m != 6*n*n*n)
                {
-                  IntegrationPoint &ip = RG->RefPts.IntPoint(l);
-                  ip.x = cp[i]/(cp[i] + cp[j] + cp[n-i-j]);
-                  ip.y = cp[j]/(cp[i] + cp[j] + cp[n-i-j]);
-                  ip.z = cp[k];
-                  m++;
+                  MFEM_ABORT("GeometryRefiner::Refine() for PRISM #2");
                }
-         if (m != (n+1)*(n+1)*(n+2)/2)
-         {
-            mfem_error("GeometryRefiner::Refine() for PRISM #1");
-         }
-         // elements
-         Array<int> &G = RG->RefGeoms;
-         m = 0;
-         for (m = k = 0; k < n; k++)
-            for (l = j = 0; j < n; j++, l++)
-               for (i = 0; i < n-j; i++, l++)
+               for (i = 0; i < m; i++)
                {
-                  G[m++] = l + (k+0) * (n+1) * (n+2) / 2;
-                  G[m++] = l + 1 + (k+0) * (n+1) * (n+2) / 2;
-                  G[m++] = l - j + (2 + (k+0) * (n+2)) * (n+1) / 2;
-                  G[m++] = l + (k+1) * (n+1) * (n+2) / 2;
-                  G[m++] = l + 1 + (k+1) * (n+1) * (Times+2) / 2;
-                  G[m++] = l - j + (2 + (k+1) * (n+2)) * (n+1) / 2;
-                  if (i+j+1 < n)
+                  if (G[i] < 0)
                   {
-                     G[m++] = l + 1 + (k+0) * (n+1) * (n+2)/2;
-                     G[m++] = l - j + (2 + (k+0) * (n+1)) * (n+2) / 2;
-                     G[m++] = l - j + (2 + (k+0) * (n+2)) * (n+1) / 2;
-                     G[m++] = l + 1 + (k+1) * (n+1) * (n+2) / 2;
-                     G[m++] = l - j + (2 + (k+1) * (n+1)) * (n+2) / 2;
-                     G[m++] = l - j + (2 + (k+1) * (n+2)) * (n+1) / 2;
+                     MFEM_ABORT("GeometryRefiner::Refine() for PRISM #3");
                   }
                }
-         if (m != 6*n*n*n)
-         {
-            mfem_error("GeometryRefiner::Refine() for PRISM #2");
-         }
-         for (i = 0; i < m; i++)
-            if (G[i] < 0)
-            {
-               mfem_error("GeometryRefiner::Refine() for PRISM #3");
+
+               RGeom[Geometry::PRISM].Append(RG);
             }
+            break;
 
-         RGeom[Geometry::PRISM].Append(RG);
-         return RG;
+            case Geometry::INVALID:
+            case Geometry::NUM_GEOMETRIES:
+               MFEM_ABORT("Unknown type of reference element!");
+         }
       }
-
-      default:
-
-         return NULL;
    }
+
+   return RG;
 }
 
 const IntegrationRule *GeometryRefiner::RefineInterior(Geometry::Type Geom,
@@ -1596,15 +1650,23 @@ const IntegrationRule *GeometryRefiner::RefineInterior(Geometry::Type Geom,
          {
             return NULL;
          }
-         ir = FindInIntPts(Geom, Times-1);
-         if (ir) { return ir; }
-
-         ir = new IntegrationRule(Times-1);
-         for (int i = 1; i < Times; i++)
+#ifdef MFEM_USE_OPENMP
+         #pragma omp critical (RefineInterior)
+#endif
          {
-            IntegrationPoint &ip = ir->IntPoint(i-1);
-            ip.x = double(i) / Times;
-            ip.y = ip.z = 0.0;
+            ir = FindInIntPts(Geometry::SEGMENT, Times-1);
+            if (!ir)
+            {
+               ir = new IntegrationRule(Times-1);
+               for (int i = 1; i < Times; i++)
+               {
+                  IntegrationPoint &ip = ir->IntPoint(i-1);
+                  ip.x = double(i) / Times;
+                  ip.y = ip.z = 0.0;
+               }
+
+               IntPts[Geometry::SEGMENT].Append(ir);
+            }
          }
       }
       break;
@@ -1615,18 +1677,28 @@ const IntegrationRule *GeometryRefiner::RefineInterior(Geometry::Type Geom,
          {
             return NULL;
          }
-         ir = FindInIntPts(Geom, ((Times-1)*(Times-2))/2);
-         if (ir) { return ir; }
-
-         ir = new IntegrationRule(((Times-1)*(Times-2))/2);
-         for (int k = 0, j = 1; j < Times-1; j++)
-            for (int i = 1; i < Times-j; i++, k++)
+#ifdef MFEM_USE_OPENMP
+         #pragma omp critical (RefineInterior)
+#endif
+         {
+            ir = FindInIntPts(Geometry::TRIANGLE, ((Times-1)*(Times-2))/2);
+            if (!ir)
             {
-               IntegrationPoint &ip = ir->IntPoint(k);
-               ip.x = double(i) / Times;
-               ip.y = double(j) / Times;
-               ip.z = 0.0;
+               ir = new IntegrationRule(((Times-1)*(Times-2))/2);
+               for (int k = 0, j = 1; j < Times-1; j++)
+               {
+                  for (int i = 1; i < Times-j; i++, k++)
+                  {
+                     IntegrationPoint &ip = ir->IntPoint(k);
+                     ip.x = double(i) / Times;
+                     ip.y = double(j) / Times;
+                     ip.z = 0.0;
+                  }
+               }
+
+               IntPts[Geometry::TRIANGLE].Append(ir);
             }
+         }
       }
       break;
 
@@ -1636,32 +1708,46 @@ const IntegrationRule *GeometryRefiner::RefineInterior(Geometry::Type Geom,
          {
             return NULL;
          }
-         ir = FindInIntPts(Geom, (Times-1)*(Times-1));
-         if (ir) { return ir; }
-
-         ir = new IntegrationRule((Times-1)*(Times-1));
-         for (int k = 0, j = 1; j < Times; j++)
-            for (int i = 1; i < Times; i++, k++)
+#ifdef MFEM_USE_OPENMP
+         #pragma omp critical (RefineInterior)
+#endif
+         {
+            ir = FindInIntPts(Geometry::SQUARE, (Times-1)*(Times-1));
+            if (!ir)
             {
-               IntegrationPoint &ip = ir->IntPoint(k);
-               ip.x = double(i) / Times;
-               ip.y = double(j) / Times;
-               ip.z = 0.0;
+               ir = new IntegrationRule((Times-1)*(Times-1));
+               for (int k = 0, j = 1; j < Times; j++)
+               {
+                  for (int i = 1; i < Times; i++, k++)
+                  {
+                     IntegrationPoint &ip = ir->IntPoint(k);
+                     ip.x = double(i) / Times;
+                     ip.y = double(j) / Times;
+                     ip.z = 0.0;
+                  }
+               }
+
+               IntPts[Geometry::SQUARE].Append(ir);
             }
+         }
       }
       break;
 
-      default:
-         mfem_error("GeometryRefiner::RefineInterior(...)");
+      case Geometry::POINT:
+      case Geometry::TETRAHEDRON:
+      case Geometry::CUBE:
+      case Geometry::PYRAMID:
+      case Geometry::PRISM:
+         MFEM_ABORT("Reference element type is not supported!");
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
 
-   MFEM_ASSERT(ir != NULL, "Failed to construct the refined IntegrationRule.");
-   IntPts[Geom].Append(ir);
-
    return ir;
 }
 
-
+// static method
 int GeometryRefiner::GetRefinementLevelFromPoints(Geometry::Type geom, int Npts)
 {
    switch (geom)
@@ -1719,16 +1805,17 @@ int GeometryRefiner::GetRefinementLevelFromPoints(Geometry::Type geom, int Npts)
          }
          return -1;
       }
-      default:
-      {
-         mfem_error("Non existing Geometry.");
-      }
+      case Geometry::PYRAMID:
+         MFEM_ABORT("Reference element type is not supported!");
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
 
    return -1;
 }
 
-
+// static method
 int GeometryRefiner::GetRefinementLevelFromElems(Geometry::Type geom, int Nels)
 {
    switch (geom)
@@ -1760,10 +1847,11 @@ int GeometryRefiner::GetRefinementLevelFromElems(Geometry::Type geom, int Nels)
          }
          return -1;
       }
-      default:
-      {
-         mfem_error("Non existing Geometry.");
-      }
+      case Geometry::PYRAMID:
+         MFEM_ABORT("Reference element type is not supported!");
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
 
    return -1;
diff --git a/fem/geom.hpp b/fem/geom.hpp
index 698912d97..1290f4e2a 100644
--- a/fem/geom.hpp
+++ b/fem/geom.hpp
@@ -65,10 +65,10 @@ public:
 
    /** @brief Return an IntegrationRule consisting of all vertices of the given
        Geometry::Type, @a GeomType. */
-   const IntegrationRule *GetVertices(int GeomType);
+   const IntegrationRule *GetVertices(int GeomType) const;
 
    /// Return the center of the given Geometry::Type, @a GeomType.
-   const IntegrationPoint &GetCenter(int GeomType)
+   const IntegrationPoint &GetCenter(int GeomType) const
    { return GeomCenter[GeomType]; }
 
    /// Get a random point in the reference element specified by @a GeomType.
@@ -97,9 +97,9 @@ public:
 
    const DenseMatrix &GetGeomToPerfGeomJac(int GeomType) const
    { return *GeomToPerfGeomJac[GeomType]; }
-   DenseMatrix *GetPerfGeomToGeomJac(int GeomType)
-   { return PerfGeomToGeomJac[GeomType]; }
-   void GetPerfPointMat(int GeomType, DenseMatrix &pm);
+   const DenseMatrix &GetPerfGeomToGeomJac(int GeomType) const
+   { return *PerfGeomToGeomJac[GeomType]; }
+   void GetPerfPointMat(int GeomType, DenseMatrix &pm) const;
    void JacToPerfJac(int GeomType, const DenseMatrix &J,
                      DenseMatrix &PJ) const;
 
@@ -123,7 +123,7 @@ public:
    }
 
    /// Return the number of boundary "faces" of a given Geometry::Type.
-   int NumBdr(int GeomType) { return NumBdrArray[GeomType]; }
+   int NumBdr(int GeomType) const { return NumBdrArray[GeomType]; }
 };
 
 template <> struct
@@ -317,27 +317,27 @@ public:
    int Type;
 
    RefinedGeometry(int NPts, int NRefG, int NRefE, int NBdrE = 0) :
-      RefPts(NPts), RefGeoms(NRefG), RefEdges(NRefE), NumBdrEdges(NBdrE) { }
+      RefPts(NPts), RefGeoms(NRefG), RefEdges(NRefE), NumBdrEdges(NBdrE) {}
 };
 
 class GeometryRefiner
 {
 private:
-   int type; // Quadrature1D type (ClosedUniform is default)
+   int Type; // Quadrature1D type (ClosedUniform is default)
    Array<RefinedGeometry *> RGeom[Geometry::NumGeom];
    Array<IntegrationRule *> IntPts[Geometry::NumGeom];
 
-   RefinedGeometry *FindInRGeom(Geometry::Type Geom, int Times, int ETimes,
-                                int Type);
-   IntegrationRule *FindInIntPts(Geometry::Type Geom, int NPts);
+   RefinedGeometry *FindInRGeom(Geometry::Type Geom, int Times,
+                                int ETimes) const;
+   IntegrationRule *FindInIntPts(Geometry::Type Geom, int NPts) const;
 
 public:
-   GeometryRefiner();
+   GeometryRefiner(int t = Quadrature1D::ClosedUniform) : Type(t) {}
 
    /// Set the Quadrature1D type of points to use for subdivision.
-   void SetType(const int t) { type = t; }
+   void SetType(int t) { Type = t; }
    /// Get the Quadrature1D type of points used for subdivision.
-   int GetType() const { return type; }
+   int GetType() const { return Type; }
 
    RefinedGeometry *Refine(Geometry::Type Geom, int Times, int ETimes = 1);
 
@@ -345,10 +345,10 @@ public:
    const IntegrationRule *RefineInterior(Geometry::Type Geom, int Times);
 
    /// Get the Refinement level based on number of points
-   virtual int GetRefinementLevelFromPoints(Geometry::Type Geom, int Npts);
+   static int GetRefinementLevelFromPoints(Geometry::Type Geom, int Npts);
 
    /// Get the Refinement level based on number of elements
-   virtual int GetRefinementLevelFromElems(Geometry::Type geom, int Npts);
+   static int GetRefinementLevelFromElems(Geometry::Type geom, int Npts);
 
    ~GeometryRefiner();
 };
diff --git a/fem/hybridization.cpp b/fem/hybridization.cpp
index f9d4699c2..06934064c 100644
--- a/fem/hybridization.cpp
+++ b/fem/hybridization.cpp
@@ -120,10 +120,10 @@ void Hybridization::ConstructC()
             vdofs[s1+j] = o2 + j;
          }
          c_fes->GetFaceVDofs(i, c_vdofs);
-         c_bfi->AssembleFaceMatrix(*c_fes->GetFaceElement(i),
-                                   *fes->GetFE(FTr->Elem1No),
-                                   *fes->GetFE(FTr->Elem2No),
-                                   *FTr, elmat);
+         c_bfi->AssembleFaceMatrix2(*c_fes->GetFaceElement(i),
+                                    *fes->GetFE(FTr->Elem1No),
+                                    *fes->GetFE(FTr->Elem2No),
+                                    *FTr, elmat);
          // zero-out small elements in elmat
          elmat.Threshold(1e-12 * elmat.MaxMaxNorm());
          Ct->AddSubMatrix(vdofs, c_vdofs, elmat, skip_zeros);
@@ -165,7 +165,7 @@ void Hybridization::ConstructC()
                vdofs[j] = o1 + j;
             }
             fe = fes->GetFE(FTr->Elem1No);
-            c_bfi->AssembleFaceMatrix(*face_fe, *fe, *fe, *FTr, elmat);
+            c_bfi->AssembleFaceMatrix2(*face_fe, *fe, *fe, *FTr, elmat);
             // zero-out small elements in elmat
             elmat.Threshold(1e-12 * elmat.MaxMaxNorm());
             Ct->AddSubMatrix(vdofs, c_vdofs, elmat, skip_zeros);
diff --git a/fem/integ/bilininteg_br2.cpp b/fem/integ/bilininteg_br2.cpp
index 159947029..846d72c7c 100644
--- a/fem/integ/bilininteg_br2.cpp
+++ b/fem/integ/bilininteg_br2.cpp
@@ -152,20 +152,7 @@ void DGDiffusionBR2Integrator::AssembleFaceMatrix(
    elmat.SetSize(ndofs);
    elmat = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int order;
-      if (ndof2)
-      {
-         order = 2*std::max(el1.GetOrder(), el2.GetOrder());
-      }
-      else
-      {
-         order = 2*el1.GetOrder();
-      }
-      ir = &IntRules.Get(Trans.FaceGeom, order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el1, el2, Trans);
 
    for (int p = 0; p < ir->GetNPoints(); p++)
    {
diff --git a/fem/integ/bilininteg_convection_mf.cpp b/fem/integ/bilininteg_convection_mf.cpp
index 22ed53c33..484c25b90 100644
--- a/fem/integ/bilininteg_convection_mf.cpp
+++ b/fem/integ/bilininteg_convection_mf.cpp
@@ -18,36 +18,47 @@ namespace mfem
 
 void ConvectionIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &Trans = *fes.GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFConvectionIntegrator(*this, fes, Q, alpha);
-      }
-      else
-      {
-         ceedOp = new ceed::MFConvectionIntegrator(fes, *ir, Q, alpha);
-      }
+      ceedOp = new ceed::MFConvectionIntegrator(*this, fes, Q, alpha);
       return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *fes.GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: ConvectionIntegrator::AssembleMF only implemented with"
               " libCEED");
 }
 
+void ConvectionIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::MFConvectionIntegrator(*this, fes, Q, alpha, true);
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *fes.GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: ConvectionIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
 void ConvectionIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -60,7 +71,7 @@ void ConvectionIntegrator::AddMultMF(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/bilininteg_convection_pa.cpp b/fem/integ/bilininteg_convection_pa.cpp
index 25928f002..c73e7a5c1 100644
--- a/fem/integ/bilininteg_convection_pa.cpp
+++ b/fem/integ/bilininteg_convection_pa.cpp
@@ -116,26 +116,19 @@ void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &Trans = *fes.GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Trans);
+   if (mesh->GetNE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAConvectionIntegrator(*this, fes, Q, alpha);
-      }
-      else
-      {
-         ceedOp = new ceed::PAConvectionIntegrator(fes, *ir, Q, alpha);
-      }
+      ceedOp = new ceed::PAConvectionIntegrator(*this, fes, Q, alpha);
       return;
    }
+
+   // Assumes tensor-product elements
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *fes.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    const int dims = el.GetDim();
    const int symmDims = dims;
    nq = ir->GetNPoints();
@@ -166,11 +159,30 @@ void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
+void ConvectionIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PAConvectionIntegrator(*this, fes, Q, alpha, true);
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *fes.GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: ConvectionIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
 void ConvectionIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -1527,7 +1539,7 @@ void ConvectionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/bilininteg_curlcurl_mf.cpp b/fem/integ/bilininteg_curlcurl_mf.cpp
new file mode 100644
index 000000000..cde2098bf
--- /dev/null
+++ b/fem/integ/bilininteg_curlcurl_mf.cpp
@@ -0,0 +1,89 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/curlcurl/curlcurl.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void CurlCurlIntegrator::AssembleMF(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, MQ); }
+      else if (DQ) { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, DQ); }
+      else { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, Q); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: CurlCurlIntegrator::AssembleMF only implemented with"
+              " libCEED");
+}
+
+void CurlCurlIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, MQ, true); }
+      else if (DQ) { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, DQ, true); }
+      else { ceedOp = new ceed::MFCurlCurlIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: CurlCurlIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
+void CurlCurlIntegrator::AssembleDiagonalMF(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlCurlIntegrator::AssembleDiagonalMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void CurlCurlIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlCurlIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_curlcurl_pa.cpp b/fem/integ/bilininteg_curlcurl_pa.cpp
index 68914fe14..aaeee22ea 100644
--- a/fem/integ/bilininteg_curlcurl_pa.cpp
+++ b/fem/integ/bilininteg_curlcurl_pa.cpp
@@ -10,6 +10,7 @@
 // CONTRIBUTING.md for details.
 
 #include "../qfunction.hpp"
+#include "../ceed/integrators/curlcurl/curlcurl.hpp"
 #include "bilininteg_hcurl_kernels.hpp"
 
 namespace mfem
@@ -17,32 +18,35 @@ namespace mfem
 
 void CurlCurlIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement *fel = fes.GetFE(0);
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, MQ); }
+      else if (DQ) { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, DQ); }
+      else { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, Q); }
+      return;
+   }
 
+   // Assumes tensor-product elements
+   const FiniteElement *fel = fes.GetFE(0);
    const VectorTensorFiniteElement *el =
       dynamic_cast<const VectorTensorFiniteElement*>(fel);
    MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*el, *el,
-                                                     *mesh->GetElementTransformation(0));
-
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
    const int dims = el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
-
    nq = ir->GetNPoints();
    dim = mesh->Dimension();
    MFEM_VERIFY(dim == 2 || dim == 3, "");
-
    ne = fes.GetNE();
    geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
    mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
    mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
    dofs1D = mapsC->ndof;
    quad1D = mapsC->nqpt;
-
    MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
 
    QuadratureSpace qs(*mesh, *ir);
@@ -75,131 +79,153 @@ void CurlCurlIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
-void CurlCurlIntegrator::AssembleDiagonalPA(Vector& diag)
+void CurlCurlIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
 {
-   if (dim == 3)
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, MQ, true); }
+      else if (DQ) { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, DQ, true); }
+      else { ceedOp = new ceed::PACurlCurlIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: CurlCurlIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void CurlCurlIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
    {
-      if (Device::Allows(Backend::DEVICE_MASK))
+      if (dim == 3)
       {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
+         if (Device::Allows(Backend::DEVICE_MASK))
          {
-            case 0x23:
-               return internal::SmemPACurlCurlAssembleDiagonal3D<2,3>(
-                         dofs1D,
-                         quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
-            case 0x34:
-               return internal::SmemPACurlCurlAssembleDiagonal3D<3,4>(
-                         dofs1D,
-                         quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
-            case 0x45:
-               return internal::SmemPACurlCurlAssembleDiagonal3D<4,5>(
-                         dofs1D,
-                         quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
-            case 0x56:
-               return internal::SmemPACurlCurlAssembleDiagonal3D<5,6>(
-                         dofs1D,
-                         quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
-            default:
-               return internal::SmemPACurlCurlAssembleDiagonal3D(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B,
-                         mapsO->G, mapsC->G,
-                         pa_data, diag);
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D<2,3>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+               case 0x34:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D<3,4>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+               case 0x45:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D<4,5>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+               case 0x56:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D<5,6>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+               default:
+                  return internal::SmemPACurlCurlAssembleDiagonal3D(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B,
+                            mapsO->G, mapsC->G,
+                            pa_data, diag);
+            }
          }
+         else
+         {
+            internal::PACurlCurlAssembleDiagonal3D(dofs1D, quad1D, symmetric, ne,
+                                                   mapsO->B, mapsC->B,
+                                                   mapsO->G, mapsC->G,
+                                                   pa_data, diag);
+         }
+      }
+      else if (dim == 2)
+      {
+         internal::PACurlCurlAssembleDiagonal2D(dofs1D, quad1D, ne,
+                                                mapsO->B, mapsC->G, pa_data, diag);
       }
       else
       {
-         internal::PACurlCurlAssembleDiagonal3D(dofs1D, quad1D, symmetric, ne,
-                                                mapsO->B, mapsC->B,
-                                                mapsO->G, mapsC->G,
-                                                pa_data, diag);
+         MFEM_ABORT("Unsupported dimension!");
       }
    }
-   else if (dim == 2)
-   {
-      internal::PACurlCurlAssembleDiagonal2D(dofs1D, quad1D, ne,
-                                             mapsO->B, mapsC->G, pa_data, diag);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
 }
 
 void CurlCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   if (dim == 3)
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
    {
-      if (Device::Allows(Backend::DEVICE_MASK))
+      if (dim == 3)
       {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
+         if (Device::Allows(Backend::DEVICE_MASK))
+         {
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPACurlCurlApply3D<2,3>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+               case 0x34:
+                  return internal::SmemPACurlCurlApply3D<3,4>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+               case 0x45:
+                  return internal::SmemPACurlCurlApply3D<4,5>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+               case 0x56:
+                  return internal::SmemPACurlCurlApply3D<5,6>(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+               default:
+                  return internal::SmemPACurlCurlApply3D(
+                            dofs1D, quad1D, symmetric, ne,
+                            mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
+                            mapsC->G, mapsC->Gt, pa_data, x, y);
+            }
+         }
+         else
          {
-            case 0x23:
-               return internal::SmemPACurlCurlApply3D<2,3>(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x34:
-               return internal::SmemPACurlCurlApply3D<3,4>(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x45:
-               return internal::SmemPACurlCurlApply3D<4,5>(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
-            case 0x56:
-               return internal::SmemPACurlCurlApply3D<5,6>(
-                         dofs1D, quad1D,
-                         symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
-            default:
-               return internal::SmemPACurlCurlApply3D(
-                         dofs1D, quad1D, symmetric, ne,
-                         mapsO->B, mapsC->B, mapsO->Bt, mapsC->Bt,
-                         mapsC->G, mapsC->Gt, pa_data, x, y);
+            internal::PACurlCurlApply3D(dofs1D, quad1D, symmetric, ne, mapsO->B, mapsC->B,
+                                        mapsO->Bt, mapsC->Bt, mapsC->G, mapsC->Gt,
+                                        pa_data, x, y);
          }
       }
+      else if (dim == 2)
+      {
+         internal::PACurlCurlApply2D(dofs1D, quad1D, ne, mapsO->B, mapsO->Bt,
+                                     mapsC->G, mapsC->Gt, pa_data, x, y);
+      }
       else
       {
-         internal::PACurlCurlApply3D(dofs1D, quad1D, symmetric, ne, mapsO->B, mapsC->B,
-                                     mapsO->Bt, mapsC->Bt, mapsC->G, mapsC->Gt,
-                                     pa_data, x, y);
+         MFEM_ABORT("Unsupported dimension!");
       }
    }
-   else if (dim == 2)
-   {
-      internal::PACurlCurlApply2D(dofs1D, quad1D, ne, mapsO->B, mapsO->Bt,
-                                  mapsC->G, mapsC->Gt, pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension!");
-   }
 }
 
 } // namespace mfem
diff --git a/fem/integ/bilininteg_curlcurlmass_pa.cpp b/fem/integ/bilininteg_curlcurlmass_pa.cpp
new file mode 100644
index 000000000..077b33237
--- /dev/null
+++ b/fem/integ/bilininteg_curlcurlmass_pa.cpp
@@ -0,0 +1,119 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/curlcurlmass/curlcurlmass.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void CurlCurlMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQd)
+      {
+         if (MQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, MQd, MQm); }
+         else if (VQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, MQd, VQm); }
+         else { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, MQd, Qm); }
+      }
+      else if (VQd)
+      {
+         if (MQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, VQd, MQm); }
+         else if (VQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, VQd, VQm); }
+         else { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, VQd, Qm); }
+      }
+      else
+      {
+         if (MQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, Qd, MQm); }
+         else if (VQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, Qd, VQm); }
+         else { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, Qd, Qm); }
+      }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: CurlCurlMassIntegrator::AssemblePA only implemented with"
+              " libCEED");
+}
+
+void CurlCurlMassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQd)
+      {
+         if (MQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, MQd, MQm, true); }
+         else if (VQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, MQd, VQm, true); }
+         else { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, MQd, Qm, true); }
+      }
+      else if (VQd)
+      {
+         if (MQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, VQd, MQm, true); }
+         else if (VQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, VQd, VQm, true); }
+         else { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, VQd, Qm, true); }
+      }
+      else
+      {
+         if (MQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, Qd, MQm, true); }
+         else if (VQm) { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, Qd, VQm, true); }
+         else { ceedOp = new ceed::PACurlCurlMassIntegrator(*this, fes, Qd, Qm, true); }
+      }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: CurlCurlMassIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void CurlCurlMassIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlCurlMassIntegrator::AssembleDiagonalPA only"
+                 " implemented with libCEED");
+   }
+}
+
+void CurlCurlMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlCurlMassIntegrator::AddMultPA only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_dgtrace_pa.cpp b/fem/integ/bilininteg_dgtrace_pa.cpp
index f4b8d837c..284191c13 100644
--- a/fem/integ/bilininteg_dgtrace_pa.cpp
+++ b/fem/integ/bilininteg_dgtrace_pa.cpp
@@ -123,9 +123,7 @@ void DGTraceIntegrator::SetupPA(const FiniteElementSpace &fes, FaceType type)
       *fes.GetTraceElement(0, fes.GetMesh()->GetFaceGeometry(0));
    FaceElementTransformations &T0 =
       *fes.GetMesh()->GetFaceElementTransformations(0);
-   const IntegrationRule *ir = IntRule?
-                               IntRule:
-                               &GetRule(el.GetGeomType(), el.GetOrder(), T0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*fes.GetFE(0), T0);
    const int symmDims = 4;
    nq = ir->GetNPoints();
    dim = mesh->Dimension();
diff --git a/fem/integ/bilininteg_diffusion_mf.cpp b/fem/integ/bilininteg_diffusion_mf.cpp
index 0896b8bf9..34a8fba40 100644
--- a/fem/integ/bilininteg_diffusion_mf.cpp
+++ b/fem/integ/bilininteg_diffusion_mf.cpp
@@ -18,38 +18,51 @@ namespace mfem
 
 void DiffusionIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      MFEM_VERIFY(!VQ && !MQ,
-                  "Only scalar coefficient supported for DiffusionIntegrator"
-                  " with libCEED");
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFDiffusionIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFDiffusionIntegrator(fes, *ir, Q);
-      }
+      if (MQ) { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, MQ); }
+      else if (VQ) { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, VQ); }
+      else { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, Q); }
       return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: DiffusionIntegrator::AssembleMF only implemented with"
               " libCEED");
 }
 
+void DiffusionIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, MQ, true); }
+      else if (VQ) { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, VQ, true); }
+      else { ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: DiffusionIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
 void DiffusionIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -62,7 +75,7 @@ void DiffusionIntegrator::AddMultMF(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/bilininteg_diffusion_pa.cpp b/fem/integ/bilininteg_diffusion_pa.cpp
index a966c8520..fedf0cb46 100644
--- a/fem/integ/bilininteg_diffusion_pa.cpp
+++ b/fem/integ/bilininteg_diffusion_pa.cpp
@@ -22,29 +22,21 @@ void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      MFEM_VERIFY(!VQ && !MQ,
-                  "Only scalar coefficient supported for DiffusionIntegrator"
-                  " with libCEED");
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPADiffusionIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PADiffusionIntegrator(fes, *ir, Q);
-      }
+      if (MQ) { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, MQ); }
+      else if (VQ) { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, VQ); }
+      else { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, Q); }
       return;
    }
+
+   // Assuming the same element type
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    const int dims = el.GetDim();
    const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
    const int nq = ir->GetNPoints();
@@ -73,11 +65,32 @@ void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
                               ir->GetWeights(), geom->J, coeff, pa_data);
 }
 
+void DiffusionIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, MQ, true); }
+      else if (VQ) { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, VQ, true); }
+      else { ceedOp = new ceed::PADiffusionIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: DiffusionIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
 void DiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -90,7 +103,7 @@ void DiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/bilininteg_diffusionmass_pa.cpp b/fem/integ/bilininteg_diffusionmass_pa.cpp
new file mode 100644
index 000000000..55fd1b6cb
--- /dev/null
+++ b/fem/integ/bilininteg_diffusionmass_pa.cpp
@@ -0,0 +1,89 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/diffusionmass/diffusionmass.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void DiffusionMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQd) { ceedOp = new ceed::PADiffusionMassIntegrator(*this, fes, MQd, Qm); }
+      else if (VQd) { ceedOp = new ceed::PADiffusionMassIntegrator(*this, fes, VQd, Qm); }
+      else { ceedOp = new ceed::PADiffusionMassIntegrator(*this, fes, Qd, Qm); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DiffusionMassIntegrator::AssemblePA only implemented with"
+              " libCEED");
+}
+
+void DiffusionMassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQd) { ceedOp = new ceed::PADiffusionMassIntegrator(*this, fes, MQd, Qm, true); }
+      else if (VQd) { ceedOp = new ceed::PADiffusionMassIntegrator(*this, fes, VQd, Qm, true); }
+      else { ceedOp = new ceed::PADiffusionMassIntegrator(*this, fes, Qd, Qm, true); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DiffusionMassIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void DiffusionMassIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: DiffusionMassIntegrator::AssembleDiagonalPA only"
+                 " implemented with libCEED");
+   }
+}
+
+void DiffusionMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: DiffusionMassIntegrator::AddMultPA only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_divdiv_mf.cpp b/fem/integ/bilininteg_divdiv_mf.cpp
new file mode 100644
index 000000000..8ed401f0a
--- /dev/null
+++ b/fem/integ/bilininteg_divdiv_mf.cpp
@@ -0,0 +1,85 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/divdiv/divdiv.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void DivDivIntegrator::AssembleMF(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::MFDivDivIntegrator(*this, fes, Q);
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DivDivIntegrator::AssembleMF only implemented with"
+              " libCEED");
+}
+
+void DivDivIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::MFDivDivIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DivDivIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
+void DivDivIntegrator::AssembleDiagonalMF(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: DivDivIntegrator::AssembleDiagonalMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void DivDivIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: DivDivIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_divdiv_pa.cpp b/fem/integ/bilininteg_divdiv_pa.cpp
index aee788e55..c01b03900 100644
--- a/fem/integ/bilininteg_divdiv_pa.cpp
+++ b/fem/integ/bilininteg_divdiv_pa.cpp
@@ -12,6 +12,7 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/divdiv/divdiv.hpp"
 #include "bilininteg_hdiv_kernels.hpp"
 
 namespace mfem
@@ -19,33 +20,34 @@ namespace mfem
 
 void DivDivIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement *fel = fes.GetFE(0);
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PADivDivIntegrator(*this, fes, Q);
+      return;
+   }
 
+   // Assumes tensor-product elements
+   const FiniteElement *fel = fes.GetFE(0);
    const VectorTensorFiniteElement *el =
       dynamic_cast<const VectorTensorFiniteElement*>(fel);
    MFEM_VERIFY(el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir = IntRule ? IntRule : &MassIntegrator::GetRule
-                               (*el, *el, *mesh->GetElementTransformation(0));
-
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
    const int dims = el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
-
    const int nq = ir->GetNPoints();
    dim = mesh->Dimension();
    MFEM_VERIFY(dim == 2 || dim == 3, "");
-
    ne = fes.GetNE();
    geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
    mapsC = &el->GetDofToQuad(*ir, DofToQuad::TENSOR);
    mapsO = &el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
    dofs1D = mapsC->ndof;
    quad1D = mapsC->nqpt;
-
    MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
    pa_data.SetSize(nq * ne, Device::GetMemoryType());
 
    QuadratureSpace qs(*mesh, *ir);
@@ -67,31 +69,72 @@ void DivDivIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
-void DivDivIntegrator::AssembleDiagonalPA(Vector& diag)
+void DivDivIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
 {
-   if (dim == 3)
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
    {
-      internal::PADivDivAssembleDiagonal3D(dofs1D, quad1D, ne,
-                                           mapsO->B, mapsC->G, pa_data, diag);
+      delete ceedOp;
+      ceedOp = new ceed::PADivDivIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DivDivIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void DivDivIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
-      internal::PADivDivAssembleDiagonal2D(dofs1D, quad1D, ne,
-                                           mapsO->B, mapsC->G, pa_data, diag);
+      if (dim == 3)
+      {
+         internal::PADivDivAssembleDiagonal3D(dofs1D, quad1D, ne,
+                                              mapsO->B, mapsC->G, pa_data, diag);
+      }
+      else if (dim == 2)
+      {
+         internal::PADivDivAssembleDiagonal2D(dofs1D, quad1D, ne,
+                                              mapsO->B, mapsC->G, pa_data, diag);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension!");
+      }
    }
 }
 
 void DivDivIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   if (dim == 3)
-      internal::PADivDivApply3D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
-                                mapsO->Bt, mapsC->Gt, pa_data, x, y);
-   else if (dim == 2)
-      internal::PADivDivApply2D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
-                                mapsO->Bt, mapsC->Gt, pa_data, x, y);
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
    else
    {
-      MFEM_ABORT("Unsupported dimension!");
+      if (dim == 3)
+      {
+         internal::PADivDivApply3D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
+                                   mapsO->Bt, mapsC->Gt, pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         internal::PADivDivApply2D(dofs1D, quad1D, ne, mapsO->B, mapsC->G,
+                                   mapsO->Bt, mapsC->Gt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension!");
+      }
    }
 }
 
diff --git a/fem/integ/bilininteg_divdivmass_pa.cpp b/fem/integ/bilininteg_divdivmass_pa.cpp
new file mode 100644
index 000000000..07bcf3eff
--- /dev/null
+++ b/fem/integ/bilininteg_divdivmass_pa.cpp
@@ -0,0 +1,89 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/divdivmass/divdivmass.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void DivDivMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQm) { ceedOp = new ceed::PADivDivMassIntegrator(*this, fes, Qd, MQm); }
+      else if (VQm) { ceedOp = new ceed::PADivDivMassIntegrator(*this, fes, Qd, VQm); }
+      else { ceedOp = new ceed::PADivDivMassIntegrator(*this, fes, Qd, Qm); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DivDivMassIntegrator::AssemblePA only implemented with"
+              " libCEED");
+}
+
+void DivDivMassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQm) { ceedOp = new ceed::PADivDivMassIntegrator(*this, fes, Qd, MQm, true); }
+      else if (VQm) { ceedOp = new ceed::PADivDivMassIntegrator(*this, fes, Qd, VQm, true); }
+      else { ceedOp = new ceed::PADivDivMassIntegrator(*this, fes, Qd, Qm, true); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el, T);
+   MFEM_ABORT("Error: DivDivMassIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void DivDivMassIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: DivDivMassIntegrator::AssembleDiagonalPA only"
+                 " implemented with libCEED");
+   }
+}
+
+void DivDivMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: DivDivMassIntegrator::AddMultPA only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_gradient_pa.cpp b/fem/integ/bilininteg_gradient_pa.cpp
index 20ef4684d..cb37e981a 100644
--- a/fem/integ/bilininteg_gradient_pa.cpp
+++ b/fem/integ/bilininteg_gradient_pa.cpp
@@ -167,9 +167,8 @@ void GradientIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    Mesh *mesh = trial_fes.GetMesh();
    const FiniteElement &trial_fe = *trial_fes.GetFE(0);
    const FiniteElement &test_fe = *test_fes.GetFE(0);
-   ElementTransformation *trans = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
-                                                            *trans);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe, T);
    const int dims = trial_fe.GetDim();
    const int dimsToStore = dims * dims;
    nq = ir->GetNPoints();
diff --git a/fem/integ/bilininteg_interp_curl_pa.cpp b/fem/integ/bilininteg_interp_curl_pa.cpp
new file mode 100644
index 000000000..73c33b02b
--- /dev/null
+++ b/fem/integ/bilininteg_interp_curl_pa.cpp
@@ -0,0 +1,65 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../ceed/integrators/interp/interp.hpp"
+
+namespace mfem
+{
+
+void CurlInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                  const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PADiscreteInterpolator(*this, trial_fes, test_fes);
+      return;
+   }
+
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   // const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   // const FiniteElement *test_fel = test_fes.GetFE(0);
+   MFEM_ABORT("Error: CurlInterpolator::AssemblePA only implemented with libCEED");
+}
+
+void CurlInterpolator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlInterpolator::AddMultPA only implemented with"
+                 " libCEED");
+   }
+}
+
+void CurlInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMultTranspose(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: CurlInterpolator::AddMultTransposePA only implemented"
+                 "with libCEED");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_interp_pa.cpp b/fem/integ/bilininteg_interp_grad_pa.cpp
similarity index 55%
rename from fem/integ/bilininteg_interp_pa.cpp
rename to fem/integ/bilininteg_interp_grad_pa.cpp
index 0ec03faec..8b3213746 100644
--- a/fem/integ/bilininteg_interp_pa.cpp
+++ b/fem/integ/bilininteg_interp_grad_pa.cpp
@@ -13,10 +13,68 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/interp/interp.hpp"
 
 namespace mfem
 {
 
+void GradientInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PADiscreteInterpolator(*this, trial_fes, test_fes);
+      return;
+   }
+
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "Bad dimension!");
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "Bad dimension!");
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(),
+               "Orders do not match!");
+   ne = trial_fes.GetNE();
+
+   const int order = trial_el->GetOrder();
+   dofquad_fe = new H1_SegmentElement(order, trial_el->GetBasisType());
+   mfem::QuadratureFunctions1D qf1d;
+   mfem::IntegrationRule closed_ir;
+   closed_ir.SetSize(order + 1);
+   qf1d.GaussLobatto(order + 1, &closed_ir);
+   mfem::IntegrationRule open_ir;
+   open_ir.SetSize(order);
+   qf1d.GaussLegendre(order, &open_ir);
+
+   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
+   o_dofs1D = maps_O_C->nqpt;
+   if (trial_el->GetBasisType() == BasisType::GaussLobatto)
+   {
+      B_id = true;
+      c_dofs1D = maps_O_C->ndof;
+   }
+   else
+   {
+      B_id = false;
+      maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
+      c_dofs1D = maps_C_C->nqpt;
+   }
+}
+
 // Apply to x corresponding to DOFs in H^1 (domain) the (topological) gradient
 // to get a dof in H(curl) (range). You can think of the range as the "test" space
 // and the domain as the "trial" space, but there's no integration.
@@ -1018,920 +1076,85 @@ static void PAHcurlApplyGradientTranspose3DBId(
    });
 }
 
-void GradientInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                      const FiniteElementSpace &test_fes)
+void GradientInterpolator::AddMultPA(const Vector &x, Vector &y) const
 {
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "Bad dimension!");
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "Bad dimension!");
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(),
-               "Orders do not match!");
-   ne = trial_fes.GetNE();
-
-   const int order = trial_el->GetOrder();
-   dofquad_fe = new H1_SegmentElement(order, trial_el->GetBasisType());
-   mfem::QuadratureFunctions1D qf1d;
-   mfem::IntegrationRule closed_ir;
-   closed_ir.SetSize(order + 1);
-   qf1d.GaussLobatto(order + 1, &closed_ir);
-   mfem::IntegrationRule open_ir;
-   open_ir.SetSize(order);
-   qf1d.GaussLegendre(order, &open_ir);
-
-   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
-   o_dofs1D = maps_O_C->nqpt;
-   if (trial_el->GetBasisType() == BasisType::GaussLobatto)
+   if (DeviceCanUseCeed())
    {
-      B_id = true;
-      c_dofs1D = maps_O_C->ndof;
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
-      B_id = false;
-      maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
-      c_dofs1D = maps_C_C->nqpt;
-   }
-}
-
-void GradientInterpolator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      if (B_id)
+      if (dim == 3)
       {
-         PAHcurlApplyGradient3DBId(c_dofs1D, o_dofs1D, ne,
+         if (B_id)
+         {
+            PAHcurlApplyGradient3DBId(c_dofs1D, o_dofs1D, ne,
+                                      maps_O_C->G, x, y);
+         }
+         else
+         {
+            PAHcurlApplyGradient3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
                                    maps_O_C->G, x, y);
+         }
       }
-      else
-      {
-         PAHcurlApplyGradient3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                maps_O_C->G, x, y);
-      }
-   }
-   else if (dim == 2)
-   {
-      if (B_id)
+      else if (dim == 2)
       {
-         PAHcurlApplyGradient2DBId(c_dofs1D, o_dofs1D, ne,
-                                   maps_O_C->G, x, y);
+         if (B_id)
+         {
+            PAHcurlApplyGradient2DBId(c_dofs1D, o_dofs1D, ne,
+                                      maps_O_C->G, x, y);
+         }
+         else
+         {
+            PAHcurlApplyGradient2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->G,
+                                   x, y);
+         }
       }
       else
       {
-         PAHcurlApplyGradient2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->G,
-                                x, y);
+         MFEM_ABORT("Bad dimension!");
       }
    }
-   else
-   {
-      mfem_error("Bad dimension!");
-   }
 }
 
 void GradientInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
-   if (dim == 3)
-   {
-      if (B_id)
-      {
-         PAHcurlApplyGradientTranspose3DBId(c_dofs1D, o_dofs1D, ne,
-                                            maps_O_C->G, x, y);
-      }
-      else
-      {
-         PAHcurlApplyGradientTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                         maps_O_C->G, x, y);
-      }
-   }
-   else if (dim == 2)
+   if (DeviceCanUseCeed())
    {
-      if (B_id)
-      {
-         PAHcurlApplyGradientTranspose2DBId(c_dofs1D, o_dofs1D, ne,
-                                            maps_O_C->G, x, y);
-      }
-      else
-      {
-         PAHcurlApplyGradientTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                         maps_O_C->G, x, y);
-      }
+      if (ceedOp) { ceedOp->AddMultTranspose(x, y); }
    }
    else
    {
-      mfem_error("Bad dimension!");
-   }
-}
-
-static void PAHcurlVecH1IdentityApply2D(const int c_dofs1D,
-                                        const int o_dofs1D,
-                                        const int NE,
-                                        const Array<double> &Bclosed,
-                                        const Array<double> &Bopen,
-                                        const Vector &pa_data,
-                                        const Vector &x_,
-                                        Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, 2, NE);
-   auto y = Reshape(y_.ReadWrite(), (2 * c_dofs1D * o_dofs1D), NE);
-
-   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[2][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y)
-
-      // contract in y
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               w[j][dx][ey] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w[j][dx][ey] += Bc(ey, dy) * x(dx, dy, j, e);
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ey = 0; ey < c_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < o_dofs1D; ++ex)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += Bo(ex, dx) * w[j][dx][ey];
-               }
-               const int local_index = ey*o_dofs1D + ex;
-               y(local_index, e) += s * vk(j, local_index, e);
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x)
-
-      // contract in y
-      for (int ey = 0; ey < o_dofs1D; ++ey)
+      if (dim == 3)
       {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
+         if (B_id)
          {
-            for (int j=0; j<2; ++j)
-            {
-               w[j][dx][ey] = 0.0;
-               for (int dy = 0; dy < c_dofs1D; ++dy)
-               {
-                  w[j][dx][ey] += Bo(ey, dy) * x(dx, dy, j, e);
-               }
-            }
+            PAHcurlApplyGradientTranspose3DBId(c_dofs1D, o_dofs1D, ne,
+                                               maps_O_C->G, x, y);
          }
-      }
-
-      // contract in x
-      for (int ey = 0; ey < o_dofs1D; ++ey)
-      {
-         for (int ex = 0; ex < c_dofs1D; ++ex)
+         else
          {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  s += Bc(ex, dx) * w[j][dx][ey];
-               }
-               const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-               y(local_index, e) += s * vk(j, local_index, e);
-            }
+            PAHcurlApplyGradientTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                            maps_O_C->G, x, y);
          }
       }
-   });
-}
-
-static void PAHcurlVecH1IdentityApplyTranspose2D(const int c_dofs1D,
-                                                 const int o_dofs1D,
-                                                 const int NE,
-                                                 const Array<double> &Bclosed,
-                                                 const Array<double> &Bopen,
-                                                 const Vector &pa_data,
-                                                 const Vector &x_,
-                                                 Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), (2 * c_dofs1D * o_dofs1D), NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, 2, NE);
-
-   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   //constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w[2][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y)
-
-      // contract in x
-      for (int ey = 0; ey < c_dofs1D; ++ey)
+      else if (dim == 2)
       {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
-         }
-         for (int ex = 0; ex < o_dofs1D; ++ex)
+         if (B_id)
          {
-            const int local_index = ey*o_dofs1D + ex;
-            const double xd = x(local_index, e);
-
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<2; ++j)
-               {
-                  w[j][dx][ey] += Bo(ex, dx) * xd * vk(j, local_index, e);
-               }
-            }
+            PAHcurlApplyGradientTranspose2DBId(c_dofs1D, o_dofs1D, ne,
+                                               maps_O_C->G, x, y);
          }
-      }
-
-      // contract in y
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
+         else
          {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int ey = 0; ey < c_dofs1D; ++ey)
-               {
-                  s += w[j][dx][ey] * Bc(ey, dy);
-               }
-               y(dx, dy, j, e) += s;
-            }
+            PAHcurlApplyGradientTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                            maps_O_C->G, x, y);
          }
       }
-
-      // dofs that point parallel to y-axis (open in y, closed in x)
-
-      // contract in x
-      for (int ey = 0; ey < o_dofs1D; ++ey)
+      else
       {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
-         }
-         for (int ex = 0; ex < c_dofs1D; ++ex)
-         {
-            const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-            const double xd = x(local_index, e);
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<2; ++j)
-               {
-                  w[j][dx][ey] += Bc(ex, dx) * xd * vk(j, local_index, e);
-               }
-            }
-         }
+         MFEM_ABORT("Bad dimension!");
       }
-
-      // contract in y
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int j=0; j<2; ++j)
-            {
-               double s = 0.0;
-               for (int ey = 0; ey < o_dofs1D; ++ey)
-               {
-                  s += w[j][dx][ey] * Bo(ey, dy);
-               }
-               y(dx, dy, j, e) += s;
-            }
-         }
-      }
-   });
-}
-
-static void PAHcurlVecH1IdentityApply3D(const int c_dofs1D,
-                                        const int o_dofs1D,
-                                        const int NE,
-                                        const Array<double> &Bclosed,
-                                        const Array<double> &Bopen,
-                                        const Vector &pa_data,
-                                        const Vector &x_,
-                                        Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
-   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-
-   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
-                     NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < o_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bo(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-
-      // contract in z
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bo(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-
-      // contract in z
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int dz = 0; dz < c_dofs1D; ++dz)
-                  {
-                     w1[j][dx][dy][ez] += Bo(ez, dz) * x(dx, dy, dz, j, e);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int dx = 0; dx < c_dofs1D; ++dx)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-                  for (int dy = 0; dy < c_dofs1D; ++dy)
-                  {
-                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in x
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int ex = 0; ex < c_dofs1D; ++ex)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
-                  }
-                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-                  y(local_index, e) += s * vk(j, local_index, e);
-               }
-            }
-         }
-      }
-   });
-}
-
-static void PAHcurlVecH1IdentityApplyTranspose3D(const int c_dofs1D,
-                                                 const int o_dofs1D,
-                                                 const int NE,
-                                                 const Array<double> &Bclosed,
-                                                 const Array<double> &Bopen,
-                                                 const Vector &pa_data,
-                                                 const Vector &x_,
-                                                 Vector &y_)
-{
-   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
-   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
-
-   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
-   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
-
-   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
-                     NE);
-
-   constexpr static int MAX_D1D = HCURL_MAX_D1D;
-
-   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
-
-   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
-   {
-      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
-      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
-
-      // dofs that point parallel to x-axis (open in x, closed in y, z)
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < o_dofs1D; ++ex)
-               {
-                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bo(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < c_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < c_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to y-axis (open in y, closed in x, z)
-
-      // contract in x
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < o_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < c_dofs1D; ++ex)
-               {
-                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < c_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < o_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bo(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < c_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-
-      // dofs that point parallel to z-axis (open in z, closed in x, y)
-
-      // contract in x
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int ey = 0; ey < c_dofs1D; ++ey)
-         {
-            for (int j=0; j<3; ++j)
-            {
-               for (int dx = 0; dx < c_dofs1D; ++dx)
-               {
-                  w2[j][dx][ey][ez] = 0.0;
-               }
-               for (int ex = 0; ex < c_dofs1D; ++ex)
-               {
-                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
-                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
-                  const double xv = x(local_index, e) * vk(j, local_index, e);
-                  for (int dx = 0; dx < c_dofs1D; ++dx)
-                  {
-                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in y
-      for (int ez = 0; ez < o_dofs1D; ++ez)
-      {
-         for (int dx = 0; dx < c_dofs1D; ++dx)
-         {
-            for (int dy = 0; dy < c_dofs1D; ++dy)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  w1[j][dx][dy][ez] = 0.0;
-                  for (int ey = 0; ey < c_dofs1D; ++ey)
-                  {
-                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
-                  }
-               }
-            }
-         }
-      }
-
-      // contract in z
-      for (int dx = 0; dx < c_dofs1D; ++dx)
-      {
-         for (int dy = 0; dy < c_dofs1D; ++dy)
-         {
-            for (int dz = 0; dz < c_dofs1D; ++dz)
-            {
-               for (int j=0; j<3; ++j)
-               {
-                  double s = 0.0;
-                  for (int ez = 0; ez < o_dofs1D; ++ez)
-                  {
-                     s += w1[j][dx][dy][ez] * Bo(ez, dz);
-                  }
-                  y(dx, dy, dz, j, e) += s;
-               }
-            }
-         }
-      }
-   });
-}
-
-void IdentityInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
-                                      const FiniteElementSpace &test_fes)
-{
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
-
-   ne = trial_fes.GetNE();
-
-   const int order = trial_el->GetOrder();
-   dofquad_fe = new H1_SegmentElement(order);
-   mfem::QuadratureFunctions1D qf1d;
-   mfem::IntegrationRule closed_ir;
-   closed_ir.SetSize(order + 1);
-   qf1d.GaussLobatto(order + 1, &closed_ir);
-   mfem::IntegrationRule open_ir;
-   open_ir.SetSize(order);
-   qf1d.GaussLegendre(order, &open_ir);
-
-   maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
-   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
-
-   o_dofs1D = maps_O_C->nqpt;
-   c_dofs1D = maps_C_C->nqpt;
-   MFEM_VERIFY(maps_O_C->ndof == c_dofs1D &&
-               maps_C_C->ndof == c_dofs1D, "Discrepancy in the number of DOFs");
-
-   const int ndof_test = (dim == 3) ? 3 * c_dofs1D * c_dofs1D * o_dofs1D
-                         : 2 * c_dofs1D * o_dofs1D;
-
-   const IntegrationRule & Nodes = test_el->GetNodes();
-
-   pa_data.SetSize(dim * ndof_test * ne, Device::GetMemoryType());
-   auto op = Reshape(pa_data.HostWrite(), dim, ndof_test, ne);
-
-   const Array<int> &dofmap = test_el->GetDofMap();
-
-   if (dim == 3)
-   {
-      // Note that ND_HexahedronElement uses 6 vectors in tk rather than 3, with
-      // the last 3 having negative signs. Here the signs are all positive, as
-      // signs are applied in ElementRestriction.
-
-      const double tk[9] = { 1.,0.,0.,  0.,1.,0.,  0.,0.,1. };
-
-      for (int c=0; c<3; ++c)
-      {
-         for (int i=0; i<ndof_test/3; ++i)
-         {
-            const int d = (c*ndof_test/3) + i;
-            // ND_HexahedronElement sets dof2tk = (dofmap < 0) ? 3+c : c, but here
-            // no signs should be applied due to ElementRestriction.
-            const int dof2tk = c;
-            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
-
-            for (int e=0; e<ne; ++e)
-            {
-               double v[3];
-               ElementTransformation *tr = mesh->GetElementTransformation(e);
-               tr->SetIntPoint(&Nodes.IntPoint(id));
-               tr->Jacobian().Mult(tk + dof2tk*dim, v);
-
-               for (int j=0; j<3; ++j)
-               {
-                  op(j,d,e) = v[j];
-               }
-            }
-         }
-      }
-   }
-   else // 2D case
-   {
-      const double tk[4] = { 1.,0.,  0.,1. };
-      for (int c=0; c<2; ++c)
-      {
-         for (int i=0; i<ndof_test/2; ++i)
-         {
-            const int d = (c*ndof_test/2) + i;
-            // ND_QuadrilateralElement sets dof2tk = (dofmap < 0) ? 2+c : c, but here
-            // no signs should be applied due to ElementRestriction.
-            const int dof2tk = c;
-            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
-
-            for (int e=0; e<ne; ++e)
-            {
-               double v[2];
-               ElementTransformation *tr = mesh->GetElementTransformation(e);
-               tr->SetIntPoint(&Nodes.IntPoint(id));
-               tr->Jacobian().Mult(tk + dof2tk*dim, v);
-
-               for (int j=0; j<2; ++j)
-               {
-                  op(j,d,e) = v[j];
-               }
-            }
-         }
-      }
-   }
-}
-
-void IdentityInterpolator::AddMultPA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      PAHcurlVecH1IdentityApply3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
-                                  pa_data, x, y);
-   }
-   else if (dim == 2)
-   {
-      PAHcurlVecH1IdentityApply2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
-                                  pa_data, x, y);
-   }
-   else
-   {
-      mfem_error("Bad dimension!");
-   }
-}
-
-void IdentityInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
-{
-   if (dim == 3)
-   {
-      PAHcurlVecH1IdentityApplyTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                           maps_O_C->B, pa_data, x, y);
-   }
-   else if (dim == 2)
-   {
-      PAHcurlVecH1IdentityApplyTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
-                                           maps_O_C->B, pa_data, x, y);
-   }
-   else
-   {
-      mfem_error("Bad dimension!");
    }
 }
 
diff --git a/fem/integ/bilininteg_interp_id_pa.cpp b/fem/integ/bilininteg_interp_id_pa.cpp
new file mode 100644
index 000000000..62cbe6c9b
--- /dev/null
+++ b/fem/integ/bilininteg_interp_id_pa.cpp
@@ -0,0 +1,843 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../../general/forall.hpp"
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../qfunction.hpp"
+#include "../ceed/integrators/interp/interp.hpp"
+
+namespace mfem
+{
+
+void IdentityInterpolator::AssemblePA(const FiniteElementSpace &trial_fes,
+                                      const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PADiscreteInterpolator(*this, trial_fes, test_fes);
+      return;
+   }
+
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
+
+   ne = trial_fes.GetNE();
+
+   const int order = trial_el->GetOrder();
+   dofquad_fe = new H1_SegmentElement(order);
+   mfem::QuadratureFunctions1D qf1d;
+   mfem::IntegrationRule closed_ir;
+   closed_ir.SetSize(order + 1);
+   qf1d.GaussLobatto(order + 1, &closed_ir);
+   mfem::IntegrationRule open_ir;
+   open_ir.SetSize(order);
+   qf1d.GaussLegendre(order, &open_ir);
+
+   maps_C_C = &dofquad_fe->GetDofToQuad(closed_ir, DofToQuad::TENSOR);
+   maps_O_C = &dofquad_fe->GetDofToQuad(open_ir, DofToQuad::TENSOR);
+
+   o_dofs1D = maps_O_C->nqpt;
+   c_dofs1D = maps_C_C->nqpt;
+   MFEM_VERIFY(maps_O_C->ndof == c_dofs1D &&
+               maps_C_C->ndof == c_dofs1D, "Discrepancy in the number of DOFs");
+
+   const int ndof_test = (dim == 3) ? 3 * c_dofs1D * c_dofs1D * o_dofs1D
+                         : 2 * c_dofs1D * o_dofs1D;
+
+   const IntegrationRule & Nodes = test_el->GetNodes();
+
+   pa_data.SetSize(dim * ndof_test * ne, Device::GetMemoryType());
+   auto op = Reshape(pa_data.HostWrite(), dim, ndof_test, ne);
+
+   const Array<int> &dofmap = test_el->GetDofMap();
+
+   if (dim == 3)
+   {
+      // Note that ND_HexahedronElement uses 6 vectors in tk rather than 3, with
+      // the last 3 having negative signs. Here the signs are all positive, as
+      // signs are applied in ElementRestriction.
+
+      const double tk[9] = { 1.,0.,0.,  0.,1.,0.,  0.,0.,1. };
+
+      for (int c=0; c<3; ++c)
+      {
+         for (int i=0; i<ndof_test/3; ++i)
+         {
+            const int d = (c*ndof_test/3) + i;
+            // ND_HexahedronElement sets dof2tk = (dofmap < 0) ? 3+c : c, but here
+            // no signs should be applied due to ElementRestriction.
+            const int dof2tk = c;
+            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
+
+            for (int e=0; e<ne; ++e)
+            {
+               double v[3];
+               ElementTransformation *tr = mesh->GetElementTransformation(e);
+               tr->SetIntPoint(&Nodes.IntPoint(id));
+               tr->Jacobian().Mult(tk + dof2tk*dim, v);
+
+               for (int j=0; j<3; ++j)
+               {
+                  op(j,d,e) = v[j];
+               }
+            }
+         }
+      }
+   }
+   else // 2D case
+   {
+      const double tk[4] = { 1.,0.,  0.,1. };
+      for (int c=0; c<2; ++c)
+      {
+         for (int i=0; i<ndof_test/2; ++i)
+         {
+            const int d = (c*ndof_test/2) + i;
+            // ND_QuadrilateralElement sets dof2tk = (dofmap < 0) ? 2+c : c, but here
+            // no signs should be applied due to ElementRestriction.
+            const int dof2tk = c;
+            const int id = (dofmap[d] >= 0) ? dofmap[d] : -1 - dofmap[d];
+
+            for (int e=0; e<ne; ++e)
+            {
+               double v[2];
+               ElementTransformation *tr = mesh->GetElementTransformation(e);
+               tr->SetIntPoint(&Nodes.IntPoint(id));
+               tr->Jacobian().Mult(tk + dof2tk*dim, v);
+
+               for (int j=0; j<2; ++j)
+               {
+                  op(j,d,e) = v[j];
+               }
+            }
+         }
+      }
+   }
+}
+
+static void PAHcurlVecH1IdentityApply2D(const int c_dofs1D,
+                                        const int o_dofs1D,
+                                        const int NE,
+                                        const Array<double> &Bclosed,
+                                        const Array<double> &Bopen,
+                                        const Vector &pa_data,
+                                        const Vector &x_,
+                                        Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, 2, NE);
+   auto y = Reshape(y_.ReadWrite(), (2 * c_dofs1D * o_dofs1D), NE);
+
+   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[2][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y)
+
+      // contract in y
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               w[j][dx][ey] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w[j][dx][ey] += Bc(ey, dy) * x(dx, dy, j, e);
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += Bo(ex, dx) * w[j][dx][ey];
+               }
+               const int local_index = ey*o_dofs1D + ex;
+               y(local_index, e) += s * vk(j, local_index, e);
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x)
+
+      // contract in y
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               w[j][dx][ey] = 0.0;
+               for (int dy = 0; dy < c_dofs1D; ++dy)
+               {
+                  w[j][dx][ey] += Bo(ey, dy) * x(dx, dy, j, e);
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  s += Bc(ex, dx) * w[j][dx][ey];
+               }
+               const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+               y(local_index, e) += s * vk(j, local_index, e);
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApplyTranspose2D(const int c_dofs1D,
+                                                 const int o_dofs1D,
+                                                 const int NE,
+                                                 const Array<double> &Bclosed,
+                                                 const Array<double> &Bopen,
+                                                 const Vector &pa_data,
+                                                 const Vector &x_,
+                                                 Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), (2 * c_dofs1D * o_dofs1D), NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, 2, NE);
+
+   auto vk = Reshape(pa_data.Read(), 2, (2 * c_dofs1D * o_dofs1D), NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   //constexpr static int MAX_Q1D = HCURL_MAX_Q1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w[2][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y)
+
+      // contract in x
+      for (int ey = 0; ey < c_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
+         }
+         for (int ex = 0; ex < o_dofs1D; ++ex)
+         {
+            const int local_index = ey*o_dofs1D + ex;
+            const double xd = x(local_index, e);
+
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<2; ++j)
+               {
+                  w[j][dx][ey] += Bo(ex, dx) * xd * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int ey = 0; ey < c_dofs1D; ++ey)
+               {
+                  s += w[j][dx][ey] * Bc(ey, dy);
+               }
+               y(dx, dy, j, e) += s;
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x)
+
+      // contract in x
+      for (int ey = 0; ey < o_dofs1D; ++ey)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int j=0; j<2; ++j) { w[j][dx][ey] = 0.0; }
+         }
+         for (int ex = 0; ex < c_dofs1D; ++ex)
+         {
+            const int local_index = c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+            const double xd = x(local_index, e);
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<2; ++j)
+               {
+                  w[j][dx][ey] += Bc(ex, dx) * xd * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int j=0; j<2; ++j)
+            {
+               double s = 0.0;
+               for (int ey = 0; ey < o_dofs1D; ++ey)
+               {
+                  s += w[j][dx][ey] * Bo(ey, dy);
+               }
+               y(dx, dy, j, e) += s;
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApply3D(const int c_dofs1D,
+                                        const int o_dofs1D,
+                                        const int NE,
+                                        const Array<double> &Bclosed,
+                                        const Array<double> &Bopen,
+                                        const Vector &pa_data,
+                                        const Vector &x_,
+                                        Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
+   auto y = Reshape(y_.ReadWrite(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+
+   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
+                     NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < o_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bo(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+
+      // contract in z
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bc(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bo(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+
+      // contract in z
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int dz = 0; dz < c_dofs1D; ++dz)
+                  {
+                     w1[j][dx][dy][ez] += Bo(ez, dz) * x(dx, dy, dz, j, e);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int dx = 0; dx < c_dofs1D; ++dx)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+                  for (int dy = 0; dy < c_dofs1D; ++dy)
+                  {
+                     w2[j][dx][ey][ez] += Bc(ey, dy) * w1[j][dx][dy][ez];
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in x
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int ex = 0; ex < c_dofs1D; ++ex)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     s += Bc(ex, dx) * w2[j][dx][ey][ez];
+                  }
+                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+                  y(local_index, e) += s * vk(j, local_index, e);
+               }
+            }
+         }
+      }
+   });
+}
+
+static void PAHcurlVecH1IdentityApplyTranspose3D(const int c_dofs1D,
+                                                 const int o_dofs1D,
+                                                 const int NE,
+                                                 const Array<double> &Bclosed,
+                                                 const Array<double> &Bopen,
+                                                 const Vector &pa_data,
+                                                 const Vector &x_,
+                                                 Vector &y_)
+{
+   auto Bc = Reshape(Bclosed.Read(), c_dofs1D, c_dofs1D);
+   auto Bo = Reshape(Bopen.Read(), o_dofs1D, c_dofs1D);
+
+   auto x = Reshape(x_.Read(), (3 * c_dofs1D * c_dofs1D * o_dofs1D), NE);
+   auto y = Reshape(y_.ReadWrite(), c_dofs1D, c_dofs1D, c_dofs1D, 3, NE);
+
+   auto vk = Reshape(pa_data.Read(), 3, (3 * c_dofs1D * c_dofs1D * o_dofs1D),
+                     NE);
+
+   constexpr static int MAX_D1D = HCURL_MAX_D1D;
+
+   MFEM_VERIFY(c_dofs1D <= MAX_D1D && o_dofs1D <= c_dofs1D, "");
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      double w1[3][MAX_D1D][MAX_D1D][MAX_D1D];
+      double w2[3][MAX_D1D][MAX_D1D][MAX_D1D];
+
+      // dofs that point parallel to x-axis (open in x, closed in y, z)
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < o_dofs1D; ++ex)
+               {
+                  const int local_index = ez*c_dofs1D*o_dofs1D + ey*o_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bo(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < c_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < c_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to y-axis (open in y, closed in x, z)
+
+      // contract in x
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < o_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < c_dofs1D; ++ex)
+               {
+                  const int local_index = c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*o_dofs1D + ey*c_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < c_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < o_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bo(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < c_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bc(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+
+      // dofs that point parallel to z-axis (open in z, closed in x, y)
+
+      // contract in x
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int ey = 0; ey < c_dofs1D; ++ey)
+         {
+            for (int j=0; j<3; ++j)
+            {
+               for (int dx = 0; dx < c_dofs1D; ++dx)
+               {
+                  w2[j][dx][ey][ez] = 0.0;
+               }
+               for (int ex = 0; ex < c_dofs1D; ++ex)
+               {
+                  const int local_index = 2*c_dofs1D*c_dofs1D*o_dofs1D +
+                                          ez*c_dofs1D*c_dofs1D + ey*c_dofs1D + ex;
+                  const double xv = x(local_index, e) * vk(j, local_index, e);
+                  for (int dx = 0; dx < c_dofs1D; ++dx)
+                  {
+                     w2[j][dx][ey][ez] += xv * Bc(ex, dx);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in y
+      for (int ez = 0; ez < o_dofs1D; ++ez)
+      {
+         for (int dx = 0; dx < c_dofs1D; ++dx)
+         {
+            for (int dy = 0; dy < c_dofs1D; ++dy)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  w1[j][dx][dy][ez] = 0.0;
+                  for (int ey = 0; ey < c_dofs1D; ++ey)
+                  {
+                     w1[j][dx][dy][ez] += w2[j][dx][ey][ez] * Bc(ey, dy);
+                  }
+               }
+            }
+         }
+      }
+
+      // contract in z
+      for (int dx = 0; dx < c_dofs1D; ++dx)
+      {
+         for (int dy = 0; dy < c_dofs1D; ++dy)
+         {
+            for (int dz = 0; dz < c_dofs1D; ++dz)
+            {
+               for (int j=0; j<3; ++j)
+               {
+                  double s = 0.0;
+                  for (int ez = 0; ez < o_dofs1D; ++ez)
+                  {
+                     s += w1[j][dx][dy][ez] * Bo(ez, dz);
+                  }
+                  y(dx, dy, dz, j, e) += s;
+               }
+            }
+         }
+      }
+   });
+}
+
+void IdentityInterpolator::AddMultPA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      if (dim == 3)
+      {
+         PAHcurlVecH1IdentityApply3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
+                                     pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         PAHcurlVecH1IdentityApply2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B, maps_O_C->B,
+                                     pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Bad dimension!");
+      }
+   }
+}
+
+void IdentityInterpolator::AddMultTransposePA(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMultTranspose(x, y); }
+   }
+   else
+   {
+      if (dim == 3)
+      {
+         PAHcurlVecH1IdentityApplyTranspose3D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                              maps_O_C->B, pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         PAHcurlVecH1IdentityApplyTranspose2D(c_dofs1D, o_dofs1D, ne, maps_C_C->B,
+                                              maps_O_C->B, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Bad dimension!");
+      }
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_mass_mf.cpp b/fem/integ/bilininteg_mass_mf.cpp
index b1e98f682..68362a569 100644
--- a/fem/integ/bilininteg_mass_mf.cpp
+++ b/fem/integ/bilininteg_mass_mf.cpp
@@ -18,49 +18,47 @@ namespace mfem
 
 void MassIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation *T = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFMassIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFMassIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::MFMassIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: MassIntegrator::AssembleMF only implemented with"
               " libCEED");
 }
 
-void MassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+void MassIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
 {
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Error: MassIntegrator::AddMultMF only implemented with"
-                 " libCEED");
+      delete ceedOp;
+      ceedOp = new ceed::MFMassIntegrator(*this, fes, Q, true);
+      return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: MassIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
 }
 
 void MassIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -69,4 +67,17 @@ void MassIntegrator::AssembleDiagonalMF(Vector &diag)
    }
 }
 
+void MassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: MassIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
 } // namespace mfem
diff --git a/fem/integ/bilininteg_mass_pa.cpp b/fem/integ/bilininteg_mass_pa.cpp
index ea52b6953..cc7314f5e 100644
--- a/fem/integ/bilininteg_mass_pa.cpp
+++ b/fem/integ/bilininteg_mass_pa.cpp
@@ -23,28 +23,19 @@ void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
-
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation *T0 = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T0);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAMassIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PAMassIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::PAMassIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assuming the same element type
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T =* mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    int map_type = el.GetMapType();
    dim = mesh->Dimension();
    ne = fes.GetMesh()->GetNE();
@@ -116,14 +107,19 @@ void MassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
-
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PAMassIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assuming the same element type
    const FiniteElement &el = *fes.GetBE(0);
    ElementTransformation *T0 = mesh->GetBdrElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T0);
-
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, *T0);
    int map_type = el.GetMapType();
    dim = el.GetDim(); // Dimension of the boundary element, *not* the mesh
    ne = fes.GetMesh()->GetNBE();
@@ -189,7 +185,7 @@ void MassIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -202,7 +198,7 @@ void MassIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/bilininteg_mixedcurl_mf.cpp b/fem/integ/bilininteg_mixedcurl_mf.cpp
new file mode 100644
index 000000000..4e5418c64
--- /dev/null
+++ b/fem/integ/bilininteg_mixedcurl_mf.cpp
@@ -0,0 +1,108 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/mixedveccurl/mixedveccurl.hpp"
+
+namespace mfem
+{
+
+void MixedVectorCurlIntegrator::AssembleMF(const FiniteElementSpace &trial_fes,
+                                           const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, Q);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorCurlIntegrator::AssembleMF only implemented with"
+              " libCEED");
+}
+
+void MixedVectorCurlIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: MixedVectorCurlIntegrator::AddMultMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void MixedVectorWeakCurlIntegrator::AssembleMF(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, Q);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakCurlIntegrator::AssembleMF only"
+              " implemented with libCEED");
+}
+
+void MixedVectorWeakCurlIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: MixedVectorWeakCurlIntegrator::AddMultMF only"
+                 " implemented with libCEED");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_mixedcurl_pa.cpp b/fem/integ/bilininteg_mixedcurl_pa.cpp
index a3c113982..3ae534657 100644
--- a/fem/integ/bilininteg_mixedcurl_pa.cpp
+++ b/fem/integ/bilininteg_mixedcurl_pa.cpp
@@ -12,6 +12,7 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/mixedveccurl/mixedveccurl.hpp"
 #include "bilininteg_hcurl_kernels.hpp"
 #include "bilininteg_hcurlhdiv_kernels.hpp"
 
@@ -35,9 +36,8 @@ void MixedScalarCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
       MFEM_ABORT("Unknown kernel.");
    }
 
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*eltest, *eltest,
-                                                     *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*fel, *eltest, T);
 
    const int dims = el->GetDim();
    MFEM_VERIFY(dims == 2, "");
@@ -110,8 +110,30 @@ void MixedScalarCurlIntegrator::AddMultTransposePA(const Vector &x,
 void MixedVectorCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                            const FiniteElementSpace &test_fes)
 {
-   // Assumes tensor-product elements, with vector test and trial spaces.
    Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorCurlIntegrator(*this, trial_fes,
+                                                        test_fes, Q);
+      }
+      return;
+   }
+
+   // Assumes tensor-product elements, with vector test and trial spaces.
    const FiniteElement *trial_fel = trial_fes.GetFE(0);
    const FiniteElement *test_fel = test_fes.GetFE(0);
 
@@ -123,9 +145,10 @@ void MixedVectorCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
       dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
    MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
 
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
+                                                            T);
+
    const int dims = trial_el->GetDim();
    MFEM_VERIFY(dims == 3, "");
 
@@ -193,84 +216,121 @@ void MixedVectorCurlIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
 
 void MixedVectorCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
+   if (DeviceCanUseCeed())
    {
-      const int ndata = coeffDim == 1 ? 1 : 9;
-
-      if (Device::Allows(Backend::DEVICE_MASK))
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      if (testType == mfem::FiniteElement::CURL &&
+          trialType == mfem::FiniteElement::CURL && dim == 3)
       {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
+         const int ndata = coeffDim == 1 ? 1 : 9;
+
+         if (Device::Allows(Backend::DEVICE_MASK))
          {
-            case 0x23:
-               return internal::SmemPAHcurlL2Apply3D<2,3>(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
-            case 0x34:
-               return internal::SmemPAHcurlL2Apply3D<3,4>(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
-            case 0x45:
-               return internal::SmemPAHcurlL2Apply3D<4,5>(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
-            case 0x56:
-               return internal::SmemPAHcurlL2Apply3D<5,6>(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
-            default:
-               return internal::SmemPAHcurlL2Apply3D(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B, mapsC->G,
-                         pa_data, x, y);
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPAHcurlL2Apply3D<2,3>(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+               case 0x34:
+                  return internal::SmemPAHcurlL2Apply3D<3,4>(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+               case 0x45:
+                  return internal::SmemPAHcurlL2Apply3D<4,5>(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+               case 0x56:
+                  return internal::SmemPAHcurlL2Apply3D<5,6>(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+               default:
+                  return internal::SmemPAHcurlL2Apply3D(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B, mapsC->G,
+                            pa_data, x, y);
+            }
+         }
+         else
+         {
+            internal::PAHcurlL2Apply3D(dofs1D, quad1D, ndata, ne, mapsO->B, mapsC->B,
+                                       mapsO->Bt, mapsC->Bt, mapsC->G, pa_data, x, y);
          }
       }
+      else if (testType == mfem::FiniteElement::DIV &&
+               trialType == mfem::FiniteElement::CURL && dim == 3)
+      {
+         internal::PAHcurlHdivApply3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
+                                      mapsC->B, mapsOtest->Bt, mapsCtest->Bt, mapsC->G,
+                                      pa_data, x, y);
+      }
       else
       {
-         internal::PAHcurlL2Apply3D(dofs1D, quad1D, ndata, ne, mapsO->B, mapsC->B,
-                                    mapsO->Bt, mapsC->Bt, mapsC->G, pa_data, x, y);
+         MFEM_ABORT("Unsupported dimension or space!");
       }
    }
-   else if (testType == mfem::FiniteElement::DIV &&
-            trialType == mfem::FiniteElement::CURL && dim == 3)
-   {
-      internal::PAHcurlHdivApply3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
-                                   mapsC->B, mapsOtest->Bt, mapsCtest->Bt, mapsC->G,
-                                   pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension or space!");
-   }
 }
 
 void MixedVectorCurlIntegrator::AddMultTransposePA(const Vector &x,
                                                    Vector &y) const
 {
-   if (testType == mfem::FiniteElement::DIV &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
+   if (DeviceCanUseCeed())
    {
-      internal::PAHcurlHdivApplyTranspose3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
-                                            mapsC->B, mapsOtest->Bt, mapsCtest->Bt,
-                                            mapsC->Gt, pa_data, x, y);
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " MixedVectorCurlIntegrator.");
    }
    else
    {
-      MFEM_ABORT("Unsupported dimension or space!");
+      if (testType == mfem::FiniteElement::DIV &&
+          trialType == mfem::FiniteElement::CURL && dim == 3)
+      {
+         internal::PAHcurlHdivApplyTranspose3D(dofs1D, dofs1Dtest, quad1D, ne, mapsO->B,
+                                               mapsC->B, mapsOtest->Bt, mapsCtest->Bt,
+                                               mapsC->Gt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension or space!");
+      }
    }
 }
 
-void MixedVectorWeakCurlIntegrator::AssemblePA(
-   const FiniteElementSpace &trial_fes,
-   const FiniteElementSpace &test_fes)
+void MixedVectorWeakCurlIntegrator::AssemblePA(const FiniteElementSpace
+                                               &trial_fes,
+                                               const FiniteElementSpace &test_fes)
 {
-   // Assumes tensor-product elements, with vector test and trial spaces.
    Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorWeakCurlIntegrator(*this, trial_fes,
+                                                            test_fes, Q);
+      }
+      return;
+   }
+
+   // Assumes tensor-product elements, with vector test and trial spaces.
    const FiniteElement *trial_fel = trial_fes.GetFE(0);
    const FiniteElement *test_fel = test_fes.GetFE(0);
 
@@ -282,9 +342,10 @@ void MixedVectorWeakCurlIntegrator::AssemblePA(
       dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
    MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
 
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
+                                                            T);
+
    const int dims = trial_el->GetDim();
    MFEM_VERIFY(dims == 3, "");
 
@@ -348,75 +409,90 @@ void MixedVectorWeakCurlIntegrator::AssemblePA(
 
 void MixedVectorWeakCurlIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::CURL && dim == 3)
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
    {
-      const int ndata = coeffDim == 1 ? 1 : 9;
-      if (Device::Allows(Backend::DEVICE_MASK))
+      if (testType == mfem::FiniteElement::CURL &&
+          trialType == mfem::FiniteElement::CURL && dim == 3)
       {
-         const int ID = (dofs1D << 4) | quad1D;
-         switch (ID)
+         const int ndata = coeffDim == 1 ? 1 : 9;
+         if (Device::Allows(Backend::DEVICE_MASK))
          {
-            case 0x23:
-               return internal::SmemPAHcurlL2ApplyTranspose3D<2,3>(
-                         dofs1D, quad1D, ndata,
-                         ne, mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
-            case 0x34:
-               return internal::SmemPAHcurlL2ApplyTranspose3D<3,4>(
-                         dofs1D, quad1D, ndata,
-                         ne, mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
-            case 0x45:
-               return internal::SmemPAHcurlL2ApplyTranspose3D<4,5>(
-                         dofs1D, quad1D, ndata,
-                         ne, mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
-            case 0x56:
-               return internal::SmemPAHcurlL2ApplyTranspose3D<5,6>(
-                         dofs1D, quad1D, ndata,
-                         ne, mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
-            default:
-               return internal::SmemPAHcurlL2ApplyTranspose3D(
-                         dofs1D, quad1D, ndata, ne,
-                         mapsO->B, mapsC->B,
-                         mapsC->G, pa_data, x, y);
+            const int ID = (dofs1D << 4) | quad1D;
+            switch (ID)
+            {
+               case 0x23:
+                  return internal::SmemPAHcurlL2ApplyTranspose3D<2,3>(
+                            dofs1D, quad1D, ndata,
+                            ne, mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+               case 0x34:
+                  return internal::SmemPAHcurlL2ApplyTranspose3D<3,4>(
+                            dofs1D, quad1D, ndata,
+                            ne, mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+               case 0x45:
+                  return internal::SmemPAHcurlL2ApplyTranspose3D<4,5>(
+                            dofs1D, quad1D, ndata,
+                            ne, mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+               case 0x56:
+                  return internal::SmemPAHcurlL2ApplyTranspose3D<5,6>(
+                            dofs1D, quad1D, ndata,
+                            ne, mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+               default:
+                  return internal::SmemPAHcurlL2ApplyTranspose3D(
+                            dofs1D, quad1D, ndata, ne,
+                            mapsO->B, mapsC->B,
+                            mapsC->G, pa_data, x, y);
+            }
+         }
+         else
+         {
+            internal::PAHcurlL2ApplyTranspose3D(dofs1D, quad1D, ndata, ne, mapsO->B,
+                                                mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->Gt,
+                                                pa_data, x, y);
          }
       }
+      else if (testType == mfem::FiniteElement::CURL &&
+               trialType == mfem::FiniteElement::DIV && dim == 3)
+      {
+         internal::PAHcurlHdivApplyTranspose3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
+                                               mapsC->B, mapsO->Bt, mapsC->Bt,
+                                               mapsC->Gt, pa_data, x, y);
+      }
       else
       {
-         internal::PAHcurlL2ApplyTranspose3D(dofs1D, quad1D, ndata, ne, mapsO->B,
-                                             mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->Gt,
-                                             pa_data, x, y);
+         MFEM_ABORT("Unsupported dimension or space!");
       }
    }
-   else if (testType == mfem::FiniteElement::CURL &&
-            trialType == mfem::FiniteElement::DIV && dim == 3)
-   {
-      internal::PAHcurlHdivApplyTranspose3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
-                                            mapsC->B, mapsO->Bt, mapsC->Bt,
-                                            mapsC->Gt, pa_data, x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Unsupported dimension or space!");
-   }
 }
 
 void MixedVectorWeakCurlIntegrator::AddMultTransposePA(const Vector &x,
                                                        Vector &y) const
 {
-   if (testType == mfem::FiniteElement::CURL &&
-       trialType == mfem::FiniteElement::DIV && dim == 3)
+   if (DeviceCanUseCeed())
    {
-      internal::PAHcurlHdivApply3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
-                                   mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->G,
-                                   pa_data, x, y);
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " MixedVectorWeakCurlIntegrator.");
    }
    else
    {
-      MFEM_ABORT("Unsupported dimension or space!");
+      if (testType == mfem::FiniteElement::CURL &&
+          trialType == mfem::FiniteElement::DIV && dim == 3)
+      {
+         internal::PAHcurlHdivApply3D(dofs1D, dofs1D, quad1D, ne, mapsO->B,
+                                      mapsC->B, mapsO->Bt, mapsC->Bt, mapsC->G,
+                                      pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension or space!");
+      }
    }
 }
 
diff --git a/fem/integ/bilininteg_mixedvecgrad_mf.cpp b/fem/integ/bilininteg_mixedvecgrad_mf.cpp
new file mode 100644
index 000000000..76afe676c
--- /dev/null
+++ b/fem/integ/bilininteg_mixedvecgrad_mf.cpp
@@ -0,0 +1,174 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/mixedvecgrad/mixedvecgrad.hpp"
+
+namespace mfem
+{
+
+void MixedVectorGradientIntegrator::AssembleMF(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, Q);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorGradientIntegrator::AssembleMF only"
+              " implemented with libCEED");
+}
+
+void MixedVectorGradientIntegrator::AssembleMFBoundary(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, MQ, true);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, DQ, true);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, Q, true);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorGradientIntegrator::AssembleMFBoundary only"
+              " implemented with libCEED");
+}
+
+void MixedVectorGradientIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: MixedVectorGradientIntegrator::AddMultMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void MixedVectorWeakDivergenceIntegrator::AssembleMF(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, Q);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AssembleMF only"
+              " implemented with libCEED");
+}
+
+void MixedVectorWeakDivergenceIntegrator::AssembleMFBoundary(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, MQ, true);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, DQ, true);
+      }
+      else
+      {
+         ceedOp = new ceed::MFMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, Q, true);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AssembleMFBoundary only"
+              " implemented with libCEED");
+}
+
+void MixedVectorWeakDivergenceIntegrator::AddMultMF(const Vector &x,
+                                                    Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      ceedOp->AddMult(x, y);
+   }
+   else
+   {
+      MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AddMultMF only"
+                 " implemented with libCEED");
+   }
+}
+
+} // namespace mfem
diff --git a/fem/integ/bilininteg_mixedvecgrad_pa.cpp b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
index f9e6d3ee8..3e0479252 100644
--- a/fem/integ/bilininteg_mixedvecgrad_pa.cpp
+++ b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
@@ -13,11 +13,128 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/mixedvecgrad/mixedvecgrad.hpp"
 #include "bilininteg_diffusion_kernels.hpp"
 
 namespace mfem
 {
 
+void MixedVectorGradientIntegrator::AssemblePA(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, Q);
+      }
+      return;
+   }
+
+   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
+   const FiniteElement *trial_fel = trial_fes.GetFE(0);
+   const FiniteElement *test_fel = test_fes.GetFE(0);
+
+   const NodalTensorFiniteElement *trial_el =
+      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
+   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
+
+   const VectorTensorFiniteElement *test_el =
+      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
+   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
+
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
+                                                            T);
+
+   const int dims = trial_el->GetDim();
+   MFEM_VERIFY(dims == 2 || dims == 3, "");
+
+   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
+   const int nq = ir->GetNPoints();
+   dim = mesh->Dimension();
+   MFEM_VERIFY(dim == 2 || dim == 3, "");
+
+   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
+
+   ne = trial_fes.GetNE();
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
+   mapsC = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
+   mapsO = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
+   dofs1D = mapsC->ndof;
+   quad1D = mapsC->nqpt;
+
+   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
+
+   pa_data.SetSize(symmDims * nq * ne, Device::GetMemoryType());
+
+   QuadratureSpace qs(*mesh, *ir);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
+
+   // Use the same setup functions as VectorFEMassIntegrator.
+   if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 3)
+   {
+      internal::PADiffusionSetup3D(quad1D, 1, ne, ir->GetWeights(), geom->J,
+                                   coeff, pa_data);
+   }
+   else if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 2)
+   {
+      internal::PADiffusionSetup2D<2>(quad1D, 1, ne, ir->GetWeights(), geom->J,
+                                      coeff, pa_data);
+   }
+   else
+   {
+      MFEM_ABORT("Unknown kernel.");
+   }
+}
+
+void MixedVectorGradientIntegrator::AssemblePABoundary(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, MQ, true);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, DQ, true);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorGradientIntegrator(*this, trial_fes,
+                                                            test_fes, Q, true);
+      }
+      return;
+   }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorGradientIntegrator::AssemblePABoundary only"
+              " implemented with libCEED");
+}
+
 // Apply to x corresponding to DOFs in H^1 (trial), whose gradients are
 // integrated against H(curl) test functions corresponding to y.
 static void PAHcurlH1Apply2D(const int D1D,
@@ -656,101 +773,133 @@ static void PAHcurlH1ApplyTranspose3D(const int D1D,
    }); // end of element loop
 }
 
-void MixedVectorGradientIntegrator::AssemblePA(
-   const FiniteElementSpace &trial_fes,
-   const FiniteElementSpace &test_fes)
+void MixedVectorGradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   // Assumes tensor-product elements, with a vector test space and H^1 trial space.
-   Mesh *mesh = trial_fes.GetMesh();
-   const FiniteElement *trial_fel = trial_fes.GetFE(0);
-   const FiniteElement *test_fel = test_fes.GetFE(0);
-
-   const NodalTensorFiniteElement *trial_el =
-      dynamic_cast<const NodalTensorFiniteElement*>(trial_fel);
-   MFEM_VERIFY(trial_el != NULL, "Only NodalTensorFiniteElement is supported!");
-
-   const VectorTensorFiniteElement *test_el =
-      dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
-   MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
-   const int dims = trial_el->GetDim();
-   MFEM_VERIFY(dims == 2 || dims == 3, "");
-
-   const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
-   const int nq = ir->GetNPoints();
-   dim = mesh->Dimension();
-   MFEM_VERIFY(dim == 2 || dim == 3, "");
-
-   MFEM_VERIFY(trial_el->GetOrder() == test_el->GetOrder(), "");
-
-   ne = trial_fes.GetNE();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
-   mapsC = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
-   mapsO = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
-   dofs1D = mapsC->ndof;
-   quad1D = mapsC->nqpt;
-
-   MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
-   pa_data.SetSize(symmDims * nq * ne, Device::GetMemoryType());
-
-   QuadratureSpace qs(*mesh, *ir);
-   CoefficientVector coeff(Q, qs, CoefficientStorage::FULL);
-
-   // Use the same setup functions as VectorFEMassIntegrator.
-   if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 3)
+   if (DeviceCanUseCeed())
    {
-      internal::PADiffusionSetup3D(quad1D, 1, ne, ir->GetWeights(), geom->J,
-                                   coeff, pa_data);
-   }
-   else if (test_el->GetDerivType() == mfem::FiniteElement::CURL && dim == 2)
-   {
-      internal::PADiffusionSetup2D<2>(quad1D, 1, ne, ir->GetWeights(), geom->J,
-                                      coeff, pa_data);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
-      MFEM_ABORT("Unknown kernel.");
+      if (dim == 3)
+      {
+         PAHcurlH1Apply3D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
+                          mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         PAHcurlH1Apply2D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
+                          mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension!");
+      }
    }
 }
 
-void MixedVectorGradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
+void MixedVectorGradientIntegrator::AddMultTransposePA(const Vector &x,
+                                                       Vector &y) const
 {
-   if (dim == 3)
+   if (DeviceCanUseCeed())
    {
-      PAHcurlH1Apply3D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
-                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " MixedVectorGradientIntegrator.");
    }
-   else if (dim == 2)
+   else
    {
-      PAHcurlH1Apply2D(dofs1D, quad1D, ne, mapsC->B, mapsC->G,
-                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
+      if (dim == 3)
+      {
+         PAHcurlH1ApplyTranspose3D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
+                                   mapsC->Bt, mapsC->Gt, pa_data, x, y);
+      }
+      else if (dim == 2)
+      {
+         PAHcurlH1ApplyTranspose2D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
+                                   mapsC->Bt, mapsC->Gt, pa_data, x, y);
+      }
+      else
+      {
+         MFEM_ABORT("Unsupported dimension!");
+      }
    }
-   else
+}
+
+void MixedVectorWeakDivergenceIntegrator::AssemblePA(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
+{
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
    {
-      MFEM_ABORT("Unsupported dimension!");
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, MQ);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, DQ);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, Q);
+      }
+      return;
    }
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AssemblePA only"
+              " implemented with libCEED");
 }
 
-void MixedVectorGradientIntegrator::AddMultTransposePA(const Vector &x,
-                                                       Vector &y) const
+void MixedVectorWeakDivergenceIntegrator::AssemblePABoundary(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
 {
-   if (dim == 3)
+   Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
    {
-      PAHcurlH1ApplyTranspose3D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
-                                mapsC->Bt, mapsC->Gt, pa_data, x, y);
+      delete ceedOp;
+      if (MQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, MQ, true);
+      }
+      else if (DQ)
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, DQ, true);
+      }
+      else
+      {
+         ceedOp = new ceed::PAMixedVectorWeakDivergenceIntegrator(*this, trial_fes,
+                                                                  test_fes, Q, true);
+      }
+      return;
    }
-   else if (dim == 2)
+
+   // Assuming the same element type
+   MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AssemblePABoundary only"
+              " implemented with libCEED");
+}
+
+void MixedVectorWeakDivergenceIntegrator::AddMultPA(const Vector &x,
+                                                    Vector &y) const
+{
+   if (DeviceCanUseCeed())
    {
-      PAHcurlH1ApplyTranspose2D(dofs1D, quad1D, ne, mapsC->B, mapsO->B,
-                                mapsC->Bt, mapsC->Gt, pa_data, x, y);
+      ceedOp->AddMult(x, y);
    }
    else
    {
-      MFEM_ABORT("Unsupported dimension!");
+      MFEM_ABORT("Error: MixedVectorWeakDivergenceIntegrator::AddMultMF only"
+                 " implemented with libCEED");
    }
 }
 
diff --git a/fem/integ/bilininteg_vecdiffusion_mf.cpp b/fem/integ/bilininteg_vecdiffusion_mf.cpp
index 150b662f1..52d38b1e5 100644
--- a/fem/integ/bilininteg_vecdiffusion_mf.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_mf.cpp
@@ -18,52 +18,52 @@ namespace mfem
 
 void VectorDiffusionIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &DiffusionIntegrator::GetRule(el, el);
    if (DeviceCanUseCeed())
    {
-      delete ceedOp;
       MFEM_VERIFY(!VQ && !MQ,
-                  "Only scalar coefficient supported for DiffusionIntegrator"
-                  " with libCEED");
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFDiffusionIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFDiffusionIntegrator(fes, *ir, Q);
-      }
+                  "Only scalar coefficient is supported for matrix-free assembly for VectorDiffusionIntegrator");
+      delete ceedOp;
+      ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: VectorDiffusionIntegrator::AssembleMF only implemented"
               " with libCEED");
 }
 
-void VectorDiffusionIntegrator::AddMultMF(const Vector &x, Vector &y) const
+void VectorDiffusionIntegrator::AssembleMFBoundary(
+   const FiniteElementSpace &fes)
 {
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Error: VectorDiffusionIntegrator::AddMultMF only implemented"
-                 " with libCEED");
+      MFEM_VERIFY(!VQ && !MQ,
+                  "Only scalar coefficient is supported for matrix-free assembly for VectorDiffusionIntegrator");
+      delete ceedOp;
+      ceedOp = new ceed::MFDiffusionIntegrator(*this, fes, Q, true);
+      return;
    }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorDiffusionIntegrator::AssembleMFBoundary only implemented"
+              " with libCEED");
 }
 
 void VectorDiffusionIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -72,4 +72,17 @@ void VectorDiffusionIntegrator::AssembleDiagonalMF(Vector &diag)
    }
 }
 
+void VectorDiffusionIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: VectorDiffusionIntegrator::AddMultMF only implemented"
+                 " with libCEED");
+   }
+}
+
 } // namespace mfem
diff --git a/fem/integ/bilininteg_vecdiffusion_pa.cpp b/fem/integ/bilininteg_vecdiffusion_pa.cpp
index 84e4d5b2a..983f0e39d 100644
--- a/fem/integ/bilininteg_vecdiffusion_pa.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_pa.cpp
@@ -114,26 +114,21 @@ static void PAVectorDiffusionSetup3D(const int Q1D,
 
 void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement &el = *fes.GetFE(0);
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &DiffusionIntegrator::GetRule(el, el);
+   if (mesh->GetNE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
+      MFEM_VERIFY(!VQ && !MQ,
+                  "Only scalar coefficient is supported for partial assembly for VectorDiffusionIntegrator");
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPADiffusionIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PADiffusionIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::PADiffusionIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assumes tensor-product elements
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    const int dims = el.GetDim();
    const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
    const int nq = ir->GetNPoints();
@@ -209,6 +204,28 @@ void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
+void VectorDiffusionIntegrator::AssemblePABoundary(
+   const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      MFEM_VERIFY(!VQ && !MQ,
+                  "Only scalar coefficient is supported for partial assembly for VectorDiffusionIntegrator");
+      delete ceedOp;
+      ceedOp = new ceed::PADiffusionIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorDiffusionIntegrator::AssemblePABoundary only implemented"
+              " with libCEED");
+}
+
 template<int T_D1D = 0, int T_Q1D = 0>
 static void PAVectorDiffusionDiagonal2D(const int NE,
                                         const Array<double> &b,
@@ -382,7 +399,7 @@ void VectorDiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -721,7 +738,7 @@ void VectorDiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/bilininteg_vecdiv_pa.cpp b/fem/integ/bilininteg_vecdiv_pa.cpp
index 63f7a3308..cf58df9ea 100644
--- a/fem/integ/bilininteg_vecdiv_pa.cpp
+++ b/fem/integ/bilininteg_vecdiv_pa.cpp
@@ -105,9 +105,8 @@ void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    Mesh *mesh = trial_fes.GetMesh();
    const FiniteElement &trial_fe = *trial_fes.GetFE(0);
    const FiniteElement &test_fe = *test_fes.GetFE(0);
-   ElementTransformation *trans = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
-                                                            *trans);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe, T);
    const int dims = trial_fe.GetDim();
    const int dimsToStore = dims * dims;
    nq = ir->GetNPoints();
diff --git a/fem/integ/bilininteg_vecmass_mf.cpp b/fem/integ/bilininteg_vecmass_mf.cpp
index d71f05808..f44503dcc 100644
--- a/fem/integ/bilininteg_vecmass_mf.cpp
+++ b/fem/integ/bilininteg_vecmass_mf.cpp
@@ -18,50 +18,47 @@ namespace mfem
 
 void VectorMassIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation *T = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(el, el, *T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFMassIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFMassIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::MFMassIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    MFEM_ABORT("Error: VectorMassIntegrator::AssembleMF only implemented with"
               " libCEED");
 }
 
-void VectorMassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+void VectorMassIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
 {
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
-   }
-   else
-   {
-      MFEM_ABORT("Error: VectorMassIntegrator::AddMultMF only implemented with"
-                 " libCEED");
+      delete ceedOp;
+      ceedOp = new ceed::MFMassIntegrator(*this, fes, Q, true);
+      return;
    }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorMassIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
 }
 
 void VectorMassIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -70,4 +67,17 @@ void VectorMassIntegrator::AssembleDiagonalMF(Vector &diag)
    }
 }
 
+void VectorMassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: VectorMassIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
 } // namespace mfem
diff --git a/fem/integ/bilininteg_vecmass_pa.cpp b/fem/integ/bilininteg_vecmass_pa.cpp
index b1c20b4c4..5474f23a8 100644
--- a/fem/integ/bilininteg_vecmass_pa.cpp
+++ b/fem/integ/bilininteg_vecmass_pa.cpp
@@ -19,33 +19,23 @@ namespace mfem
 
 void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
-   // Assuming the same element type
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation *T = mesh->GetElementTransformation(0);
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(el, el, *T);
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAMassIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PAMassIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::PAMassIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assuming the same element type
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    dim = mesh->Dimension();
    ne = fes.GetMesh()->GetNE();
    nq = ir->GetNPoints();
-   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::COORDINATES |
-                                    GeometricFactors::JACOBIANS);
+   geom = mesh->GetGeometricFactors(*ir, GeometricFactors::JACOBIANS);
    maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
    dofs1D = maps->ndof;
    quad1D = maps->nqpt;
@@ -106,6 +96,25 @@ void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
+void VectorMassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      ceedOp = new ceed::PAMassIntegrator(*this, fes, Q, true);
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorMassIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
 template<const int T_D1D = 0, const int T_Q1D = 0>
 static void PAVectorMassAssembleDiagonal2D(const int NE,
                                            const Array<double> &B_,
@@ -238,7 +247,7 @@ void VectorMassIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->GetDiagonal(diag);
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
    }
    else
    {
@@ -503,7 +512,7 @@ void VectorMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/bilininteg_vectorfediv_pa.cpp b/fem/integ/bilininteg_vectorfediv_pa.cpp
index 97843a576..0e56e4f2b 100644
--- a/fem/integ/bilininteg_vectorfediv_pa.cpp
+++ b/fem/integ/bilininteg_vectorfediv_pa.cpp
@@ -35,9 +35,9 @@ VectorFEDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
       dynamic_cast<const NodalTensorFiniteElement*>(test_fel);
    MFEM_VERIFY(test_el != NULL, "Only NodalTensorFiniteElement is supported!");
 
-   const IntegrationRule *ir = IntRule ? IntRule : &MassIntegrator::GetRule(
-                                  *trial_el, *trial_el,
-                                  *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
+                                                            T);
 
    const int dims = trial_el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
diff --git a/fem/integ/bilininteg_vectorfemass_mf.cpp b/fem/integ/bilininteg_vectorfemass_mf.cpp
new file mode 100644
index 000000000..eddf6c5f5
--- /dev/null
+++ b/fem/integ/bilininteg_vectorfemass_mf.cpp
@@ -0,0 +1,89 @@
+// Copyright (c) 2010-2023, Lawrence Livermore National Security, LLC. Produced
+// at the Lawrence Livermore National Laboratory. All Rights reserved. See files
+// LICENSE and NOTICE for details. LLNL-CODE-806117.
+//
+// This file is part of the MFEM library. For more information and source code
+// availability visit https://mfem.org.
+//
+// MFEM is free software; you can redistribute it and/or modify it under the
+// terms of the BSD-3 license. We welcome feedback and contributions, see file
+// CONTRIBUTING.md for details.
+
+#include "../bilininteg.hpp"
+#include "../gridfunc.hpp"
+#include "../ceed/integrators/vecfemass/vecfemass.hpp"
+
+using namespace std;
+
+namespace mfem
+{
+
+void VectorFEMassIntegrator::AssembleMF(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, MQ); }
+      else if (DQ) { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, DQ); }
+      else { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, Q); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorFEMassIntegrator::AssembleMF only implemented with"
+              " libCEED");
+}
+
+void VectorFEMassIntegrator::AssembleMFBoundary(const FiniteElementSpace &fes)
+{
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, MQ, true); }
+      else if (DQ) { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, DQ, true); }
+      else { ceedOp = new ceed::MFVectorFEMassIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assumes tensor-product elements
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorFEMassIntegrator::AssembleMFBoundary only implemented with"
+              " libCEED");
+}
+
+void VectorFEMassIntegrator::AssembleDiagonalMF(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: VectorFEMassIntegrator::AssembleDiagonalMF only"
+                 " implemented with libCEED");
+   }
+}
+
+void VectorFEMassIntegrator::AddMultMF(const Vector &x, Vector &y) const
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
+   {
+      MFEM_ABORT("Error: VectorFEMassIntegrator::AddMultMF only implemented with"
+                 " libCEED");
+   }
+}
+
+}
diff --git a/fem/integ/bilininteg_vectorfemass_pa.cpp b/fem/integ/bilininteg_vectorfemass_pa.cpp
index c07e9f816..588d76642 100644
--- a/fem/integ/bilininteg_vectorfemass_pa.cpp
+++ b/fem/integ/bilininteg_vectorfemass_pa.cpp
@@ -12,6 +12,7 @@
 #include "../bilininteg.hpp"
 #include "../gridfunc.hpp"
 #include "../qfunction.hpp"
+#include "../ceed/integrators/vecfemass/vecfemass.hpp"
 #include "bilininteg_diffusion_kernels.hpp"
 #include "bilininteg_hcurl_kernels.hpp"
 #include "bilininteg_hdiv_kernels.hpp"
@@ -23,30 +24,37 @@ namespace mfem
 void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                         const FiniteElementSpace &test_fes)
 {
-   // Assumes tensor-product elements
    Mesh *mesh = trial_fes.GetMesh();
+   if (mesh->GetNE() == 0) { return; }
+   if (DeviceCanUseCeed())
+   {
+      MFEM_VERIFY(&trial_fes == &test_fes,
+                  "VectorFEMassIntegrator with mixed FE spaces is not supported by libCEED!");
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, trial_fes, MQ); }
+      else if (DQ) { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, trial_fes, DQ); }
+      else { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, trial_fes, Q); }
+      return;
+   }
 
+   // Assumes tensor-product elements
    const FiniteElement *trial_fel = trial_fes.GetFE(0);
    const VectorTensorFiniteElement *trial_el =
       dynamic_cast<const VectorTensorFiniteElement*>(trial_fel);
    MFEM_VERIFY(trial_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
    const FiniteElement *test_fel = test_fes.GetFE(0);
    const VectorTensorFiniteElement *test_el =
       dynamic_cast<const VectorTensorFiniteElement*>(test_fel);
    MFEM_VERIFY(test_el != NULL, "Only VectorTensorFiniteElement is supported!");
-
-   const IntegrationRule *ir
-      = IntRule ? IntRule : &MassIntegrator::GetRule(*trial_el, *trial_el,
-                                                     *mesh->GetElementTransformation(0));
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*trial_el, *test_el,
+                                                            T);
    const int dims = trial_el->GetDim();
    MFEM_VERIFY(dims == 2 || dims == 3, "");
-
    const int symmDims = (dims * (dims + 1)) / 2; // 1x1: 1, 2x2: 3, 3x3: 6
    nq = ir->GetNPoints();
    dim = mesh->Dimension();
    MFEM_VERIFY(dim == 2 || dim == 3, "");
-
    ne = trial_fes.GetNE();
    MFEM_VERIFY(ne == test_fes.GetNE(),
                "Different meshes for test and trial spaces");
@@ -55,13 +63,10 @@ void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    mapsO = &trial_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
    dofs1D = mapsC->ndof;
    quad1D = mapsC->nqpt;
-
    mapsCtest = &test_el->GetDofToQuad(*ir, DofToQuad::TENSOR);
    mapsOtest = &test_el->GetDofToQuadOpen(*ir, DofToQuad::TENSOR);
    dofs1Dtest = mapsCtest->ndof;
-
    MFEM_VERIFY(dofs1D == mapsO->ndof + 1 && quad1D == mapsO->nqpt, "");
-
    trial_fetype = trial_el->GetDerivType();
    test_fetype = test_el->GetDerivType();
 
@@ -72,6 +77,7 @@ void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
 
    QuadratureSpace qs(*mesh, *ir);
    CoefficientVector coeff(qs, CoefficientStorage::SYMMETRIC);
+
    if (Q) { coeff.Project(*Q); }
    else if (MQ) { coeff.ProjectTranspose(*MQ); }
    else if (DQ) { coeff.Project(*DQ); }
@@ -138,172 +144,206 @@ void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    }
 }
 
-void VectorFEMassIntegrator::AssembleDiagonalPA(Vector& diag)
+void VectorFEMassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
 {
-   if (dim == 3)
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   if (DeviceCanUseCeed())
    {
-      if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
+      delete ceedOp;
+      if (MQ) { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, fes, MQ, true); }
+      else if (DQ) { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, fes, DQ, true); }
+      else { ceedOp = new ceed::PAVectorFEMassIntegrator(*this, fes, Q, true); }
+      return;
+   }
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetBE(0);
+   // ElementTransformation &T = *mesh->GetBdrElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorFEMassIntegrator::AssemblePABoundary only implemented with"
+              " libCEED");
+}
+
+void VectorFEMassIntegrator::AssembleDiagonalPA(Vector &diag)
+{
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->GetDiagonal(diag); }
+   }
+   else
+   {
+      if (dim == 3)
       {
-         if (Device::Allows(Backend::DEVICE_MASK))
+         if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
          {
-            const int ID = (dofs1D << 4) | quad1D;
-            switch (ID)
+            if (Device::Allows(Backend::DEVICE_MASK))
+            {
+               const int ID = (dofs1D << 4) | quad1D;
+               switch (ID)
+               {
+                  case 0x23:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D<2,3>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+                  case 0x34:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D<3,4>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+                  case 0x45:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D<4,5>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+                  case 0x56:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D<5,6>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+                  default:
+                     return internal::SmemPAHcurlMassAssembleDiagonal3D(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, pa_data, diag);
+               }
+            }
+            else
             {
-               case 0x23:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D<2,3>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
-               case 0x34:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D<3,4>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
-               case 0x45:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D<4,5>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
-               case 0x56:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D<5,6>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
-               default:
-                  return internal::SmemPAHcurlMassAssembleDiagonal3D(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, pa_data, diag);
+               internal::PAHcurlMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
+                                                       mapsO->B, mapsC->B, pa_data, diag);
             }
          }
+         else if (trial_fetype == mfem::FiniteElement::DIV &&
+                  test_fetype == trial_fetype)
+         {
+            internal::PAHdivMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
+                                                   mapsO->B, mapsC->B, pa_data, diag);
+         }
          else
          {
-            internal::PAHcurlMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
-                                                    mapsO->B, mapsC->B, pa_data, diag);
+            MFEM_ABORT("Unknown kernel.");
          }
       }
-      else if (trial_fetype == mfem::FiniteElement::DIV &&
-               test_fetype == trial_fetype)
+      else // 2D
       {
-         internal::PAHdivMassAssembleDiagonal3D(dofs1D, quad1D, ne, symmetric,
-                                                mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
-      }
-   }
-   else // 2D
-   {
-      if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
-      {
-         internal::PAHcurlMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
-                                                 mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else if (trial_fetype == mfem::FiniteElement::DIV &&
-               test_fetype == trial_fetype)
-      {
-         internal::PAHdivMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
-                                                mapsO->B, mapsC->B, pa_data, diag);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
+         if (trial_fetype == mfem::FiniteElement::CURL && test_fetype == trial_fetype)
+         {
+            internal::PAHcurlMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
+                                                    mapsO->B, mapsC->B, pa_data, diag);
+         }
+         else if (trial_fetype == mfem::FiniteElement::DIV &&
+                  test_fetype == trial_fetype)
+         {
+            internal::PAHdivMassAssembleDiagonal2D(dofs1D, quad1D, ne, symmetric,
+                                                   mapsO->B, mapsC->B, pa_data, diag);
+         }
+         else
+         {
+            MFEM_ABORT("Unknown kernel.");
+         }
       }
    }
 }
 
 void VectorFEMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
-   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
-   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
-   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
-
-   if (dim == 3)
+   if (DeviceCanUseCeed())
+   {
+      if (ceedOp) { ceedOp->AddMult(x, y); }
+   }
+   else
    {
-      if (trial_curl && test_curl)
+      const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
+      const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
+      const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
+      const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
+
+      if (dim == 3)
       {
-         if (Device::Allows(Backend::DEVICE_MASK))
+         if (trial_curl && test_curl)
          {
-            const int ID = (dofs1D << 4) | quad1D;
-            switch (ID)
+            if (Device::Allows(Backend::DEVICE_MASK))
+            {
+               const int ID = (dofs1D << 4) | quad1D;
+               switch (ID)
+               {
+                  case 0x23:
+                     return internal::SmemPAHcurlMassApply3D<2,3>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+                  case 0x34:
+                     return internal::SmemPAHcurlMassApply3D<3,4>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+                  case 0x45:
+                     return internal::SmemPAHcurlMassApply3D<4,5>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+                  case 0x56:
+                     return internal::SmemPAHcurlMassApply3D<5,6>(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+                  default:
+                     return internal::SmemPAHcurlMassApply3D(
+                               dofs1D, quad1D, ne, symmetric,
+                               mapsO->B, mapsC->B, mapsO->Bt,
+                               mapsC->Bt, pa_data, x, y);
+               }
+            }
+            else
             {
-               case 0x23:
-                  return internal::SmemPAHcurlMassApply3D<2,3>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
-               case 0x34:
-                  return internal::SmemPAHcurlMassApply3D<3,4>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
-               case 0x45:
-                  return internal::SmemPAHcurlMassApply3D<4,5>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
-               case 0x56:
-                  return internal::SmemPAHcurlMassApply3D<5,6>(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
-               default:
-                  return internal::SmemPAHcurlMassApply3D(
-                            dofs1D, quad1D, ne, symmetric,
-                            mapsO->B, mapsC->B, mapsO->Bt,
-                            mapsC->Bt, pa_data, x, y);
+               internal::PAHcurlMassApply3D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                            mapsO->Bt, mapsC->Bt, pa_data, x, y);
             }
          }
+         else if (trial_div && test_div)
+         {
+            internal::PAHdivMassApply(3, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                      mapsO->Bt, mapsC->Bt, pa_data, x, y);
+         }
+         else if (trial_curl && test_div)
+         {
+            const bool scalarCoeff = !(DQ || MQ);
+            internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                             true, false, mapsO->B, mapsC->B, mapsOtest->Bt,
+                                             mapsCtest->Bt, pa_data, x, y);
+         }
+         else if (trial_div && test_curl)
+         {
+            const bool scalarCoeff = !(DQ || MQ);
+            internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                             false, false, mapsO->B, mapsC->B, mapsOtest->Bt,
+                                             mapsCtest->Bt, pa_data, x, y);
+         }
          else
          {
-            internal::PAHcurlMassApply3D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
-                                         mapsO->Bt, mapsC->Bt, pa_data, x, y);
+            MFEM_ABORT("Unknown kernel.");
          }
       }
-      else if (trial_div && test_div)
-      {
-         internal::PAHdivMassApply(3, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
-                                   mapsO->Bt, mapsC->Bt, pa_data, x, y);
-      }
-      else if (trial_curl && test_div)
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                          true, false, mapsO->B, mapsC->B, mapsOtest->Bt,
-                                          mapsCtest->Bt, pa_data, x, y);
-      }
-      else if (trial_div && test_curl)
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                          false, false, mapsO->B, mapsC->B, mapsOtest->Bt,
-                                          mapsCtest->Bt, pa_data, x, y);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
-      }
-   }
-   else // 2D
-   {
-      if (trial_curl && test_curl)
+      else // 2D
       {
-         internal::PAHcurlMassApply2D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+         if (trial_curl && test_curl)
+         {
+            internal::PAHcurlMassApply2D(dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
+                                         mapsO->Bt, mapsC->Bt, pa_data, x, y);
+         }
+         else if (trial_div && test_div)
+         {
+            internal::PAHdivMassApply(2, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
                                       mapsO->Bt, mapsC->Bt, pa_data, x, y);
-      }
-      else if (trial_div && test_div)
-      {
-         internal::PAHdivMassApply(2, dofs1D, quad1D, ne, symmetric, mapsO->B, mapsC->B,
-                                   mapsO->Bt,
-                                   mapsC->Bt, pa_data, x, y);
-      }
-      else if ((trial_curl && test_div) || (trial_div && test_curl))
-      {
-         const bool scalarCoeff = !(DQ || MQ);
-         internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                          trial_curl, false, mapsO->B, mapsC->B,
-                                          mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
-      }
-      else
-      {
-         MFEM_ABORT("Unknown kernel.");
+         }
+         else if ((trial_curl && test_div) || (trial_div && test_curl))
+         {
+            const bool scalarCoeff = !(DQ || MQ);
+            internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                             trial_curl, false, mapsO->B, mapsC->B,
+                                             mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+         }
+         else
+         {
+            MFEM_ABORT("Unknown kernel.");
+         }
       }
    }
 }
@@ -311,35 +351,43 @@ void VectorFEMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
 void VectorFEMassIntegrator::AddMultTransposePA(const Vector &x,
                                                 Vector &y) const
 {
-   const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
-   const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
-   const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
-   const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
-
-   bool symmetricSpaces = true;
-   if (dim == 3 && ((trial_div && test_curl) || (trial_curl && test_div)))
-   {
-      const bool scalarCoeff = !(DQ || MQ);
-      internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                       trial_div, true, mapsO->B, mapsC->B,
-                                       mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
-      symmetricSpaces = false;
-   }
-   else if (dim == 2 && ((trial_curl && test_div) || (trial_div && test_curl)))
+   if (DeviceCanUseCeed())
    {
-      const bool scalarCoeff = !(DQ || MQ);
-      internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
-                                       !trial_curl, true, mapsO->B, mapsC->B,
-                                       mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
-      symmetricSpaces = false;
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " VectorFEMassIntegrator.");
    }
-   if (symmetricSpaces)
+   else
    {
-      if (MQ && dynamic_cast<SymmetricMatrixCoefficient*>(MQ) == NULL)
+      const bool trial_curl = (trial_fetype == mfem::FiniteElement::CURL);
+      const bool trial_div = (trial_fetype == mfem::FiniteElement::DIV);
+      const bool test_curl = (test_fetype == mfem::FiniteElement::CURL);
+      const bool test_div = (test_fetype == mfem::FiniteElement::DIV);
+
+      bool symmetricSpaces = true;
+      if (dim == 3 && ((trial_div && test_curl) || (trial_curl && test_div)))
+      {
+         const bool scalarCoeff = !(DQ || MQ);
+         internal::PAHcurlHdivMassApply3D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                          trial_div, true, mapsO->B, mapsC->B,
+                                          mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+         symmetricSpaces = false;
+      }
+      else if (dim == 2 && ((trial_curl && test_div) || (trial_div && test_curl)))
       {
-         MFEM_ABORT("VectorFEMassIntegrator transpose not implemented for asymmetric MatrixCoefficient");
+         const bool scalarCoeff = !(DQ || MQ);
+         internal::PAHcurlHdivMassApply2D(dofs1D, dofs1Dtest, quad1D, ne, scalarCoeff,
+                                          !trial_curl, true, mapsO->B, mapsC->B,
+                                          mapsOtest->Bt, mapsCtest->Bt, pa_data, x, y);
+         symmetricSpaces = false;
+      }
+      if (symmetricSpaces)
+      {
+         if (MQ && dynamic_cast<SymmetricMatrixCoefficient*>(MQ) == NULL)
+         {
+            MFEM_ABORT("VectorFEMassIntegrator transpose not implemented for asymmetric MatrixCoefficient");
+         }
+         AddMultPA(x, y);
       }
-      AddMultPA(x, y);
    }
 }
 
diff --git a/fem/integ/lininteg_boundary.cpp b/fem/integ/lininteg_boundary.cpp
index 9b785335c..92f1ff8a5 100644
--- a/fem/integ/lininteg_boundary.cpp
+++ b/fem/integ/lininteg_boundary.cpp
@@ -214,30 +214,28 @@ void BoundaryLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                           const Array<int> &markers,
                                           Vector &b)
 {
-   const FiniteElement &fe = *fes.GetBE(0);
-   const int qorder = oa * fe.GetOrder() + ob;
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule &ir = IntRule ? *IntRule : IntRules.Get(gtype, qorder);
    Mesh &mesh = *fes.GetMesh();
+   const FiniteElement &fe = *fes.GetBE(0);
+   ElementTransformation &T = *mesh.GetBdrElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T, oa, ob);
 
-   FaceQuadratureSpace qs(mesh, ir, FaceType::Boundary);
+   FaceQuadratureSpace qs(mesh, *ir, FaceType::Boundary);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
-   BLFEvalAssemble(fes, ir, markers, coeff, false, b);
+   BLFEvalAssemble(fes, *ir, markers, coeff, false, b);
 }
 
 void BoundaryNormalLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                                 const Array<int> &markers,
                                                 Vector &b)
 {
-   const FiniteElement &fe = *fes.GetBE(0);
-   const int qorder = oa * fe.GetOrder() + ob;
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule &ir = IntRule ? *IntRule : IntRules.Get(gtype, qorder);
    Mesh &mesh = *fes.GetMesh();
+   const FiniteElement &fe = *fes.GetBE(0);
+   ElementTransformation &T = *mesh.GetBdrElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T, oa, ob);
 
-   FaceQuadratureSpace qs(mesh, ir, FaceType::Boundary);
+   FaceQuadratureSpace qs(mesh, *ir, FaceType::Boundary);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
-   BLFEvalAssemble(fes, ir, markers, coeff, true, b);
+   BLFEvalAssemble(fes, *ir, markers, coeff, true, b);
 }
 
 } // namespace mfem
diff --git a/fem/integ/lininteg_boundary_flux.cpp b/fem/integ/lininteg_boundary_flux.cpp
index b9f047817..a6e422b94 100644
--- a/fem/integ/lininteg_boundary_flux.cpp
+++ b/fem/integ/lininteg_boundary_flux.cpp
@@ -166,15 +166,14 @@ void VectorFEBoundaryFluxLFIntegrator::AssembleDevice(
    const Array<int> &markers,
    Vector &b)
 {
-   const FiniteElement &fe = *fes.GetBE(0);
-   const int qorder = oa * fe.GetOrder() + ob;
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule &ir = IntRule ? *IntRule : IntRules.Get(gtype, qorder);
    Mesh &mesh = *fes.GetMesh();
+   const FiniteElement &fe = *fes.GetBE(0);
+   ElementTransformation &T = *mesh.GetBdrElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T, oa, ob);
 
-   FaceQuadratureSpace qs(mesh, ir, FaceType::Boundary);
+   FaceQuadratureSpace qs(mesh, *ir, FaceType::Boundary);
    CoefficientVector coeff(F, qs, CoefficientStorage::COMPRESSED);
-   BFLFEvalAssemble(fes, ir, markers, coeff, b);
+   BFLFEvalAssemble(fes, *ir, markers, coeff, b);
 }
 
 } // namespace mfem
diff --git a/fem/integ/lininteg_domain.cpp b/fem/integ/lininteg_domain.cpp
index 6ff7b090d..438da4df2 100644
--- a/fem/integ/lininteg_domain.cpp
+++ b/fem/integ/lininteg_domain.cpp
@@ -242,10 +242,10 @@ void DomainLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                         const Array<int> &markers,
                                         Vector &b)
 {
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = oa * fe.GetOrder() + ob;
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T, oa, ob);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
@@ -256,10 +256,10 @@ void VectorDomainLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                               const Array<int> &markers,
                                               Vector &b)
 {
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = 2 * fe.GetOrder();
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
diff --git a/fem/integ/lininteg_domain_grad.cpp b/fem/integ/lininteg_domain_grad.cpp
index 5cca01a1d..735ea56c4 100644
--- a/fem/integ/lininteg_domain_grad.cpp
+++ b/fem/integ/lininteg_domain_grad.cpp
@@ -321,11 +321,10 @@ void DomainLFGradIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                             const Array<int> &markers,
                                             Vector &b)
 {
-
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = 2 * fe.GetOrder();
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
@@ -336,10 +335,10 @@ void VectorDomainLFGradIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                                   const Array<int> &markers,
                                                   Vector &b)
 {
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = 2 * fe.GetOrder();
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
diff --git a/fem/integ/lininteg_domain_vectorfe.cpp b/fem/integ/lininteg_domain_vectorfe.cpp
index 16d9e866c..0765d58bc 100644
--- a/fem/integ/lininteg_domain_vectorfe.cpp
+++ b/fem/integ/lininteg_domain_vectorfe.cpp
@@ -325,10 +325,10 @@ void VectorFEDomainLFIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                                 const Array<int> &markers,
                                                 Vector &b)
 {
+   Mesh &mesh = *fes.GetMesh();
    const FiniteElement &fe = *fes.GetFE(0);
-   const int qorder = 2 * fe.GetOrder();
-   const Geometry::Type gtype = fe.GetGeomType();
-   const IntegrationRule *ir = IntRule ? IntRule : &IntRules.Get(gtype, qorder);
+   ElementTransformation &T = *mesh.GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(fe, T);
 
    QuadratureSpace qs(*fes.GetMesh(), *ir);
    CoefficientVector coeff(QF, qs, CoefficientStorage::COMPRESSED);
diff --git a/fem/integ/nonlininteg_vecconvection_mf.cpp b/fem/integ/nonlininteg_vecconvection_mf.cpp
index edcf7d20f..d7fb41ac0 100644
--- a/fem/integ/nonlininteg_vecconvection_mf.cpp
+++ b/fem/integ/nonlininteg_vecconvection_mf.cpp
@@ -18,34 +18,29 @@ namespace mfem
 void VectorConvectionNLFIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    MFEM_ASSERT(fes.GetOrdering() == Ordering::byNODES,
-               "PA Only supports Ordering::byNODES!");
+               "MF only supports Ordering::byNODES!");
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T = *mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   if (mesh->GetNE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedMFVectorConvectionNLIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::MFVectorConvectionNLFIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::MFVectorConvectionNLIntegrator(*this, fes, Q);
       return;
    }
-   MFEM_ABORT("Not yet implemented.");
+
+   // Assuming the same element type
+   // const FiniteElement &el = *fes.GetFE(0);
+   // ElementTransformation &T = *mesh->GetElementTransformation(0);
+   // const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   MFEM_ABORT("Error: VectorConvectionNLFIntegrator::AssembleMF only"
+              " implemented with libCEED");
 }
 
 void VectorConvectionNLFIntegrator::AddMultMF(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/integ/nonlininteg_vecconvection_pa.cpp b/fem/integ/nonlininteg_vecconvection_pa.cpp
index f2f9e242b..1d9fccc10 100644
--- a/fem/integ/nonlininteg_vecconvection_pa.cpp
+++ b/fem/integ/nonlininteg_vecconvection_pa.cpp
@@ -21,24 +21,18 @@ void VectorConvectionNLFIntegrator::AssemblePA(const FiniteElementSpace &fes)
    MFEM_ASSERT(fes.GetOrdering() == Ordering::byNODES,
                "PA Only supports Ordering::byNODES!");
    Mesh *mesh = fes.GetMesh();
-   const FiniteElement &el = *fes.GetFE(0);
-   ElementTransformation &T = *mesh->GetElementTransformation(0);
-   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+   if (mesh->GetNE() == 0) { return; }
    if (DeviceCanUseCeed())
    {
       delete ceedOp;
-      const bool mixed = mesh->GetNumGeometries(mesh->Dimension()) > 1 ||
-                         fes.IsVariableOrder();
-      if (mixed)
-      {
-         ceedOp = new ceed::MixedPAVectorConvectionNLIntegrator(*this, fes, Q);
-      }
-      else
-      {
-         ceedOp = new ceed::PAVectorConvectionNLFIntegrator(fes, *ir, Q);
-      }
+      ceedOp = new ceed::PAVectorConvectionNLIntegrator(*this, fes, Q);
       return;
    }
+
+   // Assumes tensor-product elements
+   const FiniteElement &el = *fes.GetFE(0);
+   ElementTransformation &T = *mesh->GetElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
    dim = mesh->Dimension();
    ne = fes.GetMesh()->GetNE();
    nq = ir->GetNPoints();
@@ -808,7 +802,7 @@ void VectorConvectionNLFIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      ceedOp->AddMult(x, y);
+      if (ceedOp) { ceedOp->AddMult(x, y); }
    }
    else
    {
diff --git a/fem/intrules.cpp b/fem/intrules.cpp
index 67ab66320..1d21feb84 100644
--- a/fem/intrules.cpp
+++ b/fem/intrules.cpp
@@ -680,7 +680,7 @@ void QuadratureFunctions1D::GivePolyPoints(const int np, double *pts,
          ClosedGL(np, &ir);
          break;
       }
-      default:
+      case Quadrature1D::Invalid:
       {
          MFEM_ABORT("Asking for an unknown type of 1D Quadrature points, "
                     "type = " << type);
@@ -774,7 +774,10 @@ void QuadratureFunctions1D::CalculateUniformWeights(IntegrationRule *ir,
          hinv = p+1;
          ihoffset = 1;
          break;
-      default:
+      case Quadrature1D::GaussLegendre:
+      case Quadrature1D::GaussLobatto:
+      case Quadrature1D::ClosedGL:
+      case Quadrature1D::Invalid:
          MFEM_ABORT("invalid Quadrature1D type: " << type);
    }
    // set w0 = (-1)^p*(p!)/(hinv^p)
@@ -883,10 +886,10 @@ IntegrationRules IntRules(0, Quadrature1D::GaussLegendre);
 
 IntegrationRules RefinedIntRules(1, Quadrature1D::GaussLegendre);
 
-IntegrationRules::IntegrationRules(int Ref, int type_):
-   quad_type(type_)
+IntegrationRules::IntegrationRules(int ref, int type)
+   : quad_type(type)
 {
-   refined = Ref;
+   refined = ref;
 
    if (refined < 0) { own_rules = 0; return; }
 
@@ -918,11 +921,19 @@ IntegrationRules::IntegrationRules(int Ref, int type_):
 
    CubeIntRules.SetSize(32, h_mt);
    CubeIntRules = NULL;
+
+#ifdef MFEM_USE_OPENMP
+   IntRuleLocks.SetSize(Geometry::NUM_GEOMETRIES, h_mt);
+   for (int i = 0; i < Geometry::NUM_GEOMETRIES; i++)
+   {
+      omp_init_lock(&IntRuleLocks[i]);
+   }
+#endif
 }
 
 const IntegrationRule &IntegrationRules::Get(int GeomType, int Order)
 {
-   Array<IntegrationRule *> *ir_array;
+   Array<IntegrationRule *> *ir_array = NULL;
 
    switch (GeomType)
    {
@@ -934,9 +945,9 @@ const IntegrationRule &IntegrationRules::Get(int GeomType, int Order)
       case Geometry::CUBE:        ir_array = &CubeIntRules; break;
       case Geometry::PRISM:       ir_array = &PrismIntRules; break;
       case Geometry::PYRAMID:     ir_array = &PyramidIntRules; break;
-      default:
-         mfem_error("IntegrationRules::Get(...) : Unknown geometry type!");
-         ir_array = NULL;
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
 
    if (Order < 0)
@@ -944,32 +955,31 @@ const IntegrationRule &IntegrationRules::Get(int GeomType, int Order)
       Order = 0;
    }
 
+#ifdef MFEM_USE_OPENMP
+   omp_set_lock(&IntRuleLocks[GeomType]);
+#endif
+
    if (!HaveIntRule(*ir_array, Order))
    {
-#ifdef MFEM_USE_LEGACY_OPENMP
-      #pragma omp critical
-#endif
+      IntegrationRule *ir = GenerateIntegrationRule(GeomType, Order);
+      int RealOrder = Order;
+      while (RealOrder+1 < ir_array->Size() && (*ir_array)[RealOrder+1] == ir)
       {
-         if (!HaveIntRule(*ir_array, Order))
-         {
-            IntegrationRule *ir = GenerateIntegrationRule(GeomType, Order);
-            int RealOrder = Order;
-            while (RealOrder+1 < ir_array->Size() &&
-                   (*ir_array)[RealOrder+1] == ir)
-            {
-               RealOrder++;
-            }
-            ir->SetOrder(RealOrder);
-         }
+         RealOrder++;
       }
+      ir->SetOrder(RealOrder);
    }
 
+#ifdef MFEM_USE_OPENMP
+   omp_unset_lock(&IntRuleLocks[GeomType]);
+#endif
+
    return *(*ir_array)[Order];
 }
 
 void IntegrationRules::Set(int GeomType, int Order, IntegrationRule &IntRule)
 {
-   Array<IntegrationRule *> *ir_array;
+   Array<IntegrationRule *> *ir_array = NULL;
 
    switch (GeomType)
    {
@@ -981,11 +991,15 @@ void IntegrationRules::Set(int GeomType, int Order, IntegrationRule &IntRule)
       case Geometry::CUBE:        ir_array = &CubeIntRules; break;
       case Geometry::PRISM:       ir_array = &PrismIntRules; break;
       case Geometry::PYRAMID:     ir_array = &PyramidIntRules; break;
-      default:
-         mfem_error("IntegrationRules::Set(...) : Unknown geometry type!");
-         ir_array = NULL;
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
 
+#ifdef MFEM_USE_OPENMP
+   omp_set_lock(&IntRuleLocks[GeomType]);
+#endif
+
    if (HaveIntRule(*ir_array, Order))
    {
       MFEM_ABORT("Overwriting set rules is not supported!");
@@ -994,16 +1008,19 @@ void IntegrationRules::Set(int GeomType, int Order, IntegrationRule &IntRule)
    AllocIntRule(*ir_array, Order);
 
    (*ir_array)[Order] = &IntRule;
+
+#ifdef MFEM_USE_OPENMP
+   omp_unset_lock(&IntRuleLocks[GeomType]);
+#endif
 }
 
-void IntegrationRules::DeleteIntRuleArray(Array<IntegrationRule *> &ir_array)
+void IntegrationRules::DeleteIntRuleArray(
+   Array<IntegrationRule *> &ir_array) const
 {
-   int i;
-   IntegrationRule *ir = NULL;
-
    // Many of the intrules have multiple contiguous copies in the ir_array
    // so we have to be careful to not delete them twice.
-   for (i = 0; i < ir_array.Size(); i++)
+   IntegrationRule *ir = NULL;
+   for (int i = 0; i < ir_array.Size(); i++)
    {
       if (ir_array[i] != NULL && ir_array[i] != ir)
       {
@@ -1015,6 +1032,13 @@ void IntegrationRules::DeleteIntRuleArray(Array<IntegrationRule *> &ir_array)
 
 IntegrationRules::~IntegrationRules()
 {
+#ifdef MFEM_USE_OPENMP
+   for (int i = 0; i < Geometry::NUM_GEOMETRIES; i++)
+   {
+      omp_destroy_lock(&IntRuleLocks[i]);
+   }
+#endif
+
    if (!own_rules) { return; }
 
    DeleteIntRuleArray(PointIntRules);
@@ -1049,10 +1073,11 @@ IntegrationRule *IntegrationRules::GenerateIntegrationRule(int GeomType,
          return PrismIntegrationRule(Order);
       case Geometry::PYRAMID:
          return PyramidIntegrationRule(Order);
-      default:
-         mfem_error("IntegrationRules::Set(...) : Unknown geometry type!");
-         return NULL;
+      case Geometry::INVALID:
+      case Geometry::NUM_GEOMETRIES:
+         MFEM_ABORT("Unknown type of reference element!");
    }
+   return NULL;
 }
 
 
@@ -1061,7 +1086,7 @@ IntegrationRule *IntegrationRules::PointIntegrationRule(int Order)
 {
    if (Order > 1)
    {
-      mfem_error("Point Integration Rule of Order > 1 not defined");
+      MFEM_ABORT("Point Integration Rule of Order > 1 not defined");
       return NULL;
    }
 
@@ -1123,7 +1148,7 @@ IntegrationRule *IntegrationRules::SegmentIntegrationRule(int Order)
          QuadratureFunctions1D::OpenHalfUniform(n, ir);
          break;
       }
-      default:
+      case Quadrature1D::Invalid:
       {
          MFEM_ABORT("unknown Quadrature1D type: " << quad_type);
       }
@@ -1671,8 +1696,8 @@ IntegrationRule *IntegrationRules::PyramidIntegrationRule(int Order)
 
    for (int k=0; k<npts; k++)
    {
-      const IntegrationPoint & ipc = irc.IntPoint(k);
-      IntegrationPoint & ipp = PyramidIntRules[Order]->IntPoint(k);
+      const IntegrationPoint &ipc = irc.IntPoint(k);
+      IntegrationPoint &ipp = PyramidIntRules[Order]->IntPoint(k);
       ipp.x = ipc.x * (1.0 - ipc.z);
       ipp.y = ipc.y * (1.0 - ipc.z);
       ipp.z = ipc.z;
@@ -1684,8 +1709,8 @@ IntegrationRule *IntegrationRules::PyramidIntegrationRule(int Order)
 // Integration rules for reference prism
 IntegrationRule *IntegrationRules::PrismIntegrationRule(int Order)
 {
-   const IntegrationRule & irt = Get(Geometry::TRIANGLE, Order);
-   const IntegrationRule & irs = Get(Geometry::SEGMENT, Order);
+   const IntegrationRule &irt = Get(Geometry::TRIANGLE, Order);
+   const IntegrationRule &irs = Get(Geometry::SEGMENT, Order);
    int nt = irt.GetNPoints();
    int ns = irs.GetNPoints();
    AllocIntRule(PrismIntRules, Order);
@@ -1693,12 +1718,12 @@ IntegrationRule *IntegrationRules::PrismIntegrationRule(int Order)
 
    for (int ks=0; ks<ns; ks++)
    {
-      const IntegrationPoint & ips = irs.IntPoint(ks);
+      const IntegrationPoint &ips = irs.IntPoint(ks);
       for (int kt=0; kt<nt; kt++)
       {
          int kp = ks * nt + kt;
-         const IntegrationPoint & ipt = irt.IntPoint(kt);
-         IntegrationPoint & ipp = PrismIntRules[Order]->IntPoint(kp);
+         const IntegrationPoint &ipt = irt.IntPoint(kt);
+         IntegrationPoint &ipp = PrismIntRules[Order]->IntPoint(kp);
          ipp.x = ipt.x;
          ipp.y = ipt.y;
          ipp.z = ips.x;
diff --git a/fem/intrules.hpp b/fem/intrules.hpp
index 9d55a5588..4c2a08d02 100644
--- a/fem/intrules.hpp
+++ b/fem/intrules.hpp
@@ -14,6 +14,9 @@
 
 #include "../config/config.hpp"
 #include "../general/array.hpp"
+#ifdef MFEM_USE_OPENMP
+#include <omp.h>
+#endif
 
 namespace mfem
 {
@@ -327,14 +330,18 @@ private:
    Array<IntegrationRule *> PrismIntRules;
    Array<IntegrationRule *> CubeIntRules;
 
-   void AllocIntRule(Array<IntegrationRule *> &ir_array, int Order)
+#ifdef MFEM_USE_OPENMP
+   Array<omp_lock_t> IntRuleLocks;
+#endif
+
+   void AllocIntRule(Array<IntegrationRule *> &ir_array, int Order) const
    {
       if (ir_array.Size() <= Order)
       {
          ir_array.SetSize(Order + 1, NULL);
       }
    }
-   bool HaveIntRule(Array<IntegrationRule *> &ir_array, int Order)
+   bool HaveIntRule(Array<IntegrationRule *> &ir_array, int Order) const
    {
       return (ir_array.Size() > Order && ir_array[Order] != NULL);
    }
@@ -342,6 +349,7 @@ private:
    {
       return Order | 1; // valid for all quad_type's
    }
+   void DeleteIntRuleArray(Array<IntegrationRule *> &ir_array) const;
 
    /// The following methods allocate new IntegrationRule objects without
    /// checking if they already exist.  To avoid memory leaks use
@@ -356,12 +364,10 @@ private:
    IntegrationRule *PrismIntegrationRule(int Order);
    IntegrationRule *CubeIntegrationRule(int Order);
 
-   void DeleteIntRuleArray(Array<IntegrationRule *> &ir_array);
-
 public:
    /// Sets initial sizes for the integration rule arrays, but rules
    /// are defined the first time they are requested with the Get method.
-   explicit IntegrationRules(int Ref = 0,
+   explicit IntegrationRules(int ref = 0,
                              int type = Quadrature1D::GaussLegendre);
 
    /// Returns an integration rule for given GeomType and Order.
diff --git a/fem/lininteg.cpp b/fem/lininteg.cpp
index c9b6b4699..25e7c2823 100644
--- a/fem/lininteg.cpp
+++ b/fem/lininteg.cpp
@@ -15,6 +15,22 @@
 namespace mfem
 {
 
+const IntegrationRule &LinearFormIntegrator::GetRule(
+   const FiniteElement &el,
+   ElementTransformation &Tr,
+   int oa, int ob) const
+{
+   return IntRules.Get(el.GetGeomType(), oa * el.GetOrder() + ob);
+}
+
+const IntegrationRule &LinearFormIntegrator::GetRule(
+   const FiniteElement &el,
+   FaceElementTransformations &Tr,
+   int oa, int ob) const
+{
+   return IntRules.Get(Tr.GetGeometryType(), oa * el.GetOrder() + ob);
+}
+
 void LinearFormIntegrator::AssembleDevice(const FiniteElementSpace &fes,
                                           const Array<int> &markers,
                                           Vector &b)
@@ -41,17 +57,11 @@ void DomainLFIntegrator::AssembleRHSElementVect(const FiniteElement &el,
 {
    int dof = el.GetDof();
 
-   shape.SetSize(dof);       // vector of size dof
+   shape.SetSize(dof);  // vector of size dof
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // ir = &IntRules.Get(el.GetGeomType(),
-      //                    oa * el.GetOrder() + ob + Tr.OrderW());
-      ir = &IntRules.Get(el.GetGeomType(), oa * el.GetOrder() + ob);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -86,12 +96,7 @@ void DomainLFGradIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2 * el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -128,16 +133,11 @@ void BoundaryLFIntegrator::AssembleRHSElementVect(
 {
    int dof = el.GetDof();
 
-   shape.SetSize(dof);        // vector of size dof
+   shape.SetSize(dof);  // vector of size dof
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -157,16 +157,11 @@ void BoundaryLFIntegrator::AssembleRHSElementVect(
 {
    int dof = el.GetDof();
 
-   shape.SetSize(dof);        // vector of size dof
+   shape.SetSize(dof);  // vector of size dof
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;    // <------ user control
-      ir = &IntRules.Get(Tr.FaceGeom, intorder); // of integration order
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -197,12 +192,7 @@ void BoundaryNormalLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -241,12 +231,7 @@ void BoundaryTangentialLFIntegrator::AssembleRHSElementVect(
       mfem_error("These methods make sense only in 2D problems.");
    }
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -273,17 +258,12 @@ void VectorDomainLFIntegrator::AssembleRHSElementVect(
 
    double val,cf;
 
-   shape.SetSize(dof);       // vector of size dof
+   shape.SetSize(dof);  // vector of size dof
 
    elvect.SetSize(dof * vdim);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -337,12 +317,7 @@ void VectorDomainLFGradIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof*(vdim/sdim));
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2 * el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    Vector pelvect(dof);
    Vector part_x(dim);
@@ -384,12 +359,7 @@ void VectorBoundaryLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof * vdim);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -419,12 +389,7 @@ void VectorBoundaryLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof * vdim);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(Tr.GetGeometryType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -463,13 +428,8 @@ void VectorFEDomainLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // int intorder = 2*el.GetOrder() - 1; // ok for O(h^{k+1}) conv. in L2
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   // Previously: 2 * el.GetOrder() - 1; // ok for O(h^{k+1}) conv. in L2
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -512,12 +472,7 @@ void VectorFEDomainLFCurlIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2*el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -554,16 +509,11 @@ void VectorFEDomainLFDivIntegrator::AssembleRHSElementVect(
 {
    int dof = el.GetDof();
 
-   divshape.SetSize(dof);       // vector of size dof
+   divshape.SetSize(dof);  // vector of size dof
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = 2 * el.GetOrder();
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -596,11 +546,7 @@ void VectorBoundaryFluxLFIntegrator::AssembleRHSElementVect(
    nor.SetSize (dim);
    elvect.SetSize (dim*dof);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      ir = &IntRules.Get(el.GetGeomType(), el.GetOrder() + 1);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, 1, 1);
 
    elvect = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
@@ -618,7 +564,6 @@ void VectorBoundaryFluxLFIntegrator::AssembleRHSElementVect(
    }
 }
 
-
 void VectorFEBoundaryFluxLFIntegrator::AssembleRHSElementVect(
    const FiniteElement &el, ElementTransformation &Tr, Vector &elvect)
 {
@@ -628,12 +573,7 @@ void VectorFEBoundaryFluxLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -667,12 +607,7 @@ void VectorFEBoundaryTangentLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(dof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      int intorder = oa * el.GetOrder() + ob;  // <----------
-      ir = &IntRules.Get(el.GetGeomType(), intorder);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr, oa, ob);
 
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -707,6 +642,20 @@ void VectorFEBoundaryTangentLFIntegrator::AssembleRHSElementVect(
    }
 }
 
+const IntegrationRule &BoundaryFlowIntegrator::GetRule(
+   const FiniteElement &el,
+   FaceElementTransformations &Tr,
+   int oa, int ob) const
+{
+   // Assuming order(u) == order(mesh)
+   int order = 2 * el.GetOrder() + Tr.Elem1->OrderW();
+   if (el.Space() == FunctionSpace::Pk)
+   {
+      order++;
+   }
+   return IntRules.Get(Tr.GetGeometryType(), order);
+}
+
 void BoundaryFlowIntegrator::AssembleRHSElementVect(
    const FiniteElement &el, ElementTransformation &Tr, Vector &elvect)
 {
@@ -719,24 +668,14 @@ void BoundaryFlowIntegrator::AssembleRHSElementVect(
 void BoundaryFlowIntegrator::AssembleRHSElementVect(
    const FiniteElement &el, FaceElementTransformations &Tr, Vector &elvect)
 {
-   int dim, ndof, order;
+   int dim, ndof;
    double un, w, vu_data[3], nor_data[3];
 
    dim  = el.GetDim();
    ndof = el.GetDof();
    Vector vu(vu_data, dim), nor(nor_data, dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // Assuming order(u)==order(mesh)
-      order = Tr.Elem1->OrderW() + 2*el.GetOrder();
-      if (el.Space() == FunctionSpace::Pk)
-      {
-         order++;
-      }
-      ir = &IntRules.Get(Tr.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    shape.SetSize(ndof);
    elvect.SetSize(ndof);
@@ -805,13 +744,7 @@ void DGDirichletLFIntegrator::AssembleRHSElementVect(
    elvect.SetSize(ndof);
    elvect = 0.0;
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      // a simple choice for the integration order; is this OK?
-      int order = 2*el.GetOrder();
-      ir = &IntRules.Get(Tr.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int p = 0; p < ir->GetNPoints(); p++)
    {
@@ -902,12 +835,7 @@ void DGElasticityDirichletLFIntegrator::AssembleRHSElementVect(
    dshape_du.SetSize(ndofs);
    u_dir.SetSize(dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (ir == NULL)
-   {
-      const int order = 2*el.GetOrder(); // <-----
-      ir = &IntRules.Get(Tr.GetGeometryType(), order);
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Tr);
 
    for (int pi = 0; pi < ir->GetNPoints(); ++pi)
    {
@@ -1000,12 +928,10 @@ void DGElasticityDirichletLFIntegrator::AssembleRHSElementVect(
    }
 }
 
-
-
-void WhiteGaussianNoiseDomainLFIntegrator::AssembleRHSElementVect
-(const FiniteElement &el,
- ElementTransformation &Tr,
- Vector &elvect)
+void WhiteGaussianNoiseDomainLFIntegrator::AssembleRHSElementVect(
+   const FiniteElement &el,
+   ElementTransformation &Tr,
+   Vector &elvect)
 {
    int n = el.GetDof();
    elvect.SetSize(n);
@@ -1040,13 +966,18 @@ void WhiteGaussianNoiseDomainLFIntegrator::AssembleRHSElementVect
    }
 }
 
+const IntegrationRule &VectorQuadratureLFIntegrator::GetRule(
+   const FiniteElement &el,
+   ElementTransformation &Tr,
+   int oa, int ob) const
+{
+   return vqfc.GetQuadFunction().GetSpace()->GetIntRule(Tr.ElementNo);
+}
 
 void VectorQuadratureLFIntegrator::AssembleRHSElementVect(
    const FiniteElement &fe, ElementTransformation &Tr, Vector &elvect)
 {
-   const IntegrationRule *ir =
-      &vqfc.GetQuadFunction().GetSpace()->GetIntRule(Tr.ElementNo);
-
+   const IntegrationRule *ir = &GetRule(fe, Tr);
    const int nqp = ir->GetNPoints();
    const int vdim = vqfc.GetVDim();
    const int ndofs = fe.GetDof();
@@ -1071,14 +1002,19 @@ void VectorQuadratureLFIntegrator::AssembleRHSElementVect(
    }
 }
 
+const IntegrationRule &QuadratureLFIntegrator::GetRule(
+   const FiniteElement &el,
+   ElementTransformation &Tr,
+   int oa, int ob) const
+{
+   return qfc.GetQuadFunction().GetSpace()->GetIntRule(Tr.ElementNo);
+}
 
 void QuadratureLFIntegrator::AssembleRHSElementVect(const FiniteElement &fe,
                                                     ElementTransformation &Tr,
                                                     Vector &elvect)
 {
-   const IntegrationRule *ir =
-      &qfc.GetQuadFunction().GetSpace()->GetIntRule(Tr.ElementNo);
-
+   const IntegrationRule *ir = &GetRule(fe, Tr);
    const int nqp = ir->GetNPoints();
    const int ndofs = fe.GetDof();
    Vector shape(ndofs);
diff --git a/fem/lininteg.hpp b/fem/lininteg.hpp
index 02fde00c9..5bcdfdb83 100644
--- a/fem/lininteg.hpp
+++ b/fem/lininteg.hpp
@@ -29,10 +29,20 @@ protected:
    LinearFormIntegrator(const IntegrationRule *ir = NULL) { IntRule = ir; }
 
 public:
-
    /// Method probing for assembly on device
    virtual bool SupportsDevice() const { return false; }
 
+   virtual void SetIntRule(const IntegrationRule *ir) { IntRule = ir; }
+
+   const IntegrationRule *GetIntRule() { return IntRule; }
+
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          ElementTransformation &Tr,
+                                          int oa = 2, int ob = 0) const;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          FaceElementTransformations &Tr,
+                                          int oa = 2, int ob = 0) const;
+
    /// Method defining assembly on device
    virtual void AssembleDevice(const FiniteElementSpace &fes,
                                const Array<int> &markers,
@@ -51,13 +61,9 @@ public:
                                        FaceElementTransformations &Tr,
                                        Vector &elvect);
 
-   virtual void SetIntRule(const IntegrationRule *ir) { IntRule = ir; }
-   const IntegrationRule* GetIntRule() { return IntRule; }
-
-   virtual ~LinearFormIntegrator() { }
+   virtual ~LinearFormIntegrator() {}
 };
 
-
 /// Abstract class for integrators that support delta coefficients
 class DeltaLFIntegrator : public LinearFormIntegrator
 {
@@ -70,7 +76,7 @@ protected:
    DeltaLFIntegrator(Coefficient &q, const IntegrationRule *ir = NULL)
       : LinearFormIntegrator(ir),
         delta(dynamic_cast<DeltaCoefficient*>(&q)),
-        vec_delta(NULL) { }
+        vec_delta(NULL) {}
 
    /** @brief This constructor should be used by derived classes that use a
        VectorDeltaCoefficient. */
@@ -78,7 +84,7 @@ protected:
                      const IntegrationRule *ir = NULL)
       : LinearFormIntegrator(ir),
         delta(NULL),
-        vec_delta(dynamic_cast<VectorDeltaCoefficient*>(&vq)) { }
+        vec_delta(dynamic_cast<VectorDeltaCoefficient*>(&vq)) {}
 
 public:
    /// Returns true if the derived class instance uses a delta coefficient.
@@ -103,23 +109,23 @@ public:
                                          Vector &elvect) = 0;
 };
 
-
 /// Class for domain integration L(v) := (f, v)
 class DomainLFIntegrator : public DeltaLFIntegrator
 {
    Vector shape;
    Coefficient &Q;
    int oa, ob;
+
 public:
    /// Constructs a domain integrator with a given Coefficient
+   /// the old default was a = 1, b = 1
+   /// for simple elliptic problems a = 2, b = -2 is OK
    DomainLFIntegrator(Coefficient &QF, int a = 2, int b = 0)
-   // the old default was a = 1, b = 1
-   // for simple elliptic problems a = 2, b = -2 is OK
-      : DeltaLFIntegrator(QF), Q(QF), oa(a), ob(b) { }
+      : DeltaLFIntegrator(QF), Q(QF), oa(a), ob(b) {}
 
    /// Constructs a domain integrator with a given Coefficient
    DomainLFIntegrator(Coefficient &QF, const IntegrationRule *ir)
-      : DeltaLFIntegrator(QF, ir), Q(QF), oa(1), ob(1) { }
+      : DeltaLFIntegrator(QF, ir), Q(QF), oa(1), ob(1) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -152,7 +158,7 @@ private:
 public:
    /// Constructs the domain integrator (Q, grad v)
    DomainLFGradIntegrator(VectorCoefficient &QF)
-      : DeltaLFIntegrator(QF), Q(QF) { }
+      : DeltaLFIntegrator(QF), Q(QF) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -174,18 +180,18 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /// Class for boundary integration L(v) := (g, v)
 class BoundaryLFIntegrator : public LinearFormIntegrator
 {
    Vector shape;
    Coefficient &Q;
    int oa, ob;
+
 public:
    /** @brief Constructs a boundary integrator with a given Coefficient @a QG.
        Integration order will be @a a * basis_order + @a b. */
    BoundaryLFIntegrator(Coefficient &QG, int a = 1, int b = 1)
-      : Q(QG), oa(a), ob(b) { }
+      : Q(QG), oa(a), ob(b) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -212,10 +218,11 @@ class BoundaryNormalLFIntegrator : public LinearFormIntegrator
    Vector shape;
    VectorCoefficient &Q;
    int oa, ob;
+
 public:
    /// Constructs a boundary integrator with a given Coefficient QG
    BoundaryNormalLFIntegrator(VectorCoefficient &QG, int a = 1, int b = 1)
-      : Q(QG), oa(a), ob(b) { }
+      : Q(QG), oa(a), ob(b) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -237,10 +244,11 @@ class BoundaryTangentialLFIntegrator : public LinearFormIntegrator
    Vector shape;
    VectorCoefficient &Q;
    int oa, ob;
+
 public:
    /// Constructs a boundary integrator with a given Coefficient QG
    BoundaryTangentialLFIntegrator(VectorCoefficient &QG, int a = 1, int b = 1)
-      : Q(QG), oa(a), ob(b) { }
+      : Q(QG), oa(a), ob(b) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -260,7 +268,7 @@ private:
 public:
    /// Constructs a domain integrator with a given VectorCoefficient
    VectorDomainLFIntegrator(VectorCoefficient &QF)
-      : DeltaLFIntegrator(QF), Q(QF) { }
+      : DeltaLFIntegrator(QF), Q(QF) {}
 
    virtual bool SupportsDevice() const { return true; }
 
@@ -294,7 +302,7 @@ private:
 public:
    /// Constructs the domain integrator (Q, grad v)
    VectorDomainLFGradIntegrator(VectorCoefficient &QF)
-      : DeltaLFIntegrator(QF), Q(QF) { }
+      : DeltaLFIntegrator(QF), Q(QF) {}
 
    virtual bool SupportsDevice() const override { return true; }
 
@@ -326,7 +334,7 @@ private:
 
 public:
    /// Constructs a boundary integrator with a given VectorCoefficient QG
-   VectorBoundaryLFIntegrator(VectorCoefficient &QG) : Q(QG) { }
+   VectorBoundaryLFIntegrator(VectorCoefficient &QG) : Q(QG) {}
 
    /** Given a particular boundary Finite Element and a transformation (Tr)
        computes the element boundary vector, elvect. */
@@ -352,7 +360,9 @@ private:
 
 public:
    VectorFEDomainLFIntegrator(VectorCoefficient &F)
-      : DeltaLFIntegrator(F), QF(F) { }
+      : DeltaLFIntegrator(F), QF(F) {}
+
+   virtual bool SupportsDevice() const { return true; }
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -362,8 +372,6 @@ public:
                                          ElementTransformation &Trans,
                                          Vector &elvect);
 
-   virtual bool SupportsDevice() const { return true; }
-
    virtual void AssembleDevice(const FiniteElementSpace &fes,
                                const Array<int> &markers,
                                Vector &b);
@@ -382,7 +390,7 @@ private:
 public:
    /// Constructs the domain integrator (Q, curl v)
    VectorFEDomainLFCurlIntegrator(VectorCoefficient &F)
-      : DeltaLFIntegrator(F), QF(&F) { }
+      : DeltaLFIntegrator(F), QF(&F) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -401,10 +409,11 @@ class VectorFEDomainLFDivIntegrator : public DeltaLFIntegrator
 private:
    Vector divshape;
    Coefficient &Q;
+
 public:
    /// Constructs the domain integrator (Q, div v)
    VectorFEDomainLFDivIntegrator(Coefficient &QF)
-      : DeltaLFIntegrator(QF), Q(QF) { }
+      : DeltaLFIntegrator(QF), Q(QF) {}
 
    /** Given a particular Finite Element and a transformation (Tr)
        computes the element right hand side element vector, elvect. */
@@ -432,7 +441,7 @@ private:
 public:
    VectorBoundaryFluxLFIntegrator(Coefficient &f, double s = 1.0,
                                   const IntegrationRule *ir = NULL)
-      : LinearFormIntegrator(ir), Sign(s), F(&f) { }
+      : LinearFormIntegrator(ir), Sign(s), F(&f) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -453,21 +462,21 @@ private:
 
 public:
    VectorFEBoundaryFluxLFIntegrator(int a = 1, int b = -1)
-      : F(NULL), oa(a), ob(b) { }
+      : F(NULL), oa(a), ob(b) {}
    VectorFEBoundaryFluxLFIntegrator(Coefficient &f, int a = 2, int b = 0)
-      : F(&f), oa(a), ob(b) { }
+      : F(&f), oa(a), ob(b) {}
+
+   virtual bool SupportsDevice() const { return true; }
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
                                        Vector &elvect);
 
-   using LinearFormIntegrator::AssembleRHSElementVect;
-
-   virtual bool SupportsDevice() const { return true; }
-
    virtual void AssembleDevice(const FiniteElementSpace &fes,
                                const Array<int> &markers,
                                Vector &b);
+
+   using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
 /// Class for boundary integration \f$ L(v) = (n \times f, v) \f$
@@ -480,7 +489,7 @@ private:
 public:
    VectorFEBoundaryTangentLFIntegrator(VectorCoefficient &QG,
                                        int a = 2, int b = 0)
-      : f(QG), oa(a), ob(b) { }
+      : f(QG), oa(a), ob(b) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -489,7 +498,6 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /** Class for boundary integration of the linear form:
     (alpha/2) < (u.n) f, w > - beta < |u.n| f, w >,
     where f and u are given scalar and vector coefficients, respectively,
@@ -512,6 +520,11 @@ public:
                           double a, double b)
    { f = &f_; u = &u_; alpha = a; beta = b; }
 
+   using LinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          FaceElementTransformations &Tr,
+                                          int oa = 2, int ob = 0) const;
+
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
                                        Vector &elvect);
@@ -522,7 +535,6 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /** Boundary linear integrator for imposing non-zero Dirichlet boundary
     conditions, to be used in conjunction with DGDiffusionIntegrator.
     Specifically, given the Dirichlet data u_D, the linear form assembles the
@@ -546,13 +558,13 @@ protected:
 
 public:
    DGDirichletLFIntegrator(Coefficient &u, const double s, const double k)
-      : uD(&u), Q(NULL), MQ(NULL), sigma(s), kappa(k) { }
+      : uD(&u), Q(NULL), MQ(NULL), sigma(s), kappa(k) {}
    DGDirichletLFIntegrator(Coefficient &u, Coefficient &q,
                            const double s, const double k)
-      : uD(&u), Q(&q), MQ(NULL), sigma(s), kappa(k) { }
+      : uD(&u), Q(&q), MQ(NULL), sigma(s), kappa(k) {}
    DGDirichletLFIntegrator(Coefficient &u, MatrixCoefficient &q,
                            const double s, const double k)
-      : uD(&u), Q(NULL), MQ(&q), sigma(s), kappa(k) { }
+      : uD(&u), Q(NULL), MQ(&q), sigma(s), kappa(k) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -564,7 +576,6 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /** Boundary linear form integrator for imposing non-zero Dirichlet boundary
     conditions, in a DG elasticity formulation. Specifically, the linear form is
     given by
@@ -597,7 +608,7 @@ public:
    DGElasticityDirichletLFIntegrator(VectorCoefficient &uD_,
                                      Coefficient &lambda_, Coefficient &mu_,
                                      double alpha_, double kappa_)
-      : uD(uD_), lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) { }
+      : uD(uD_), lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) {}
 
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
@@ -609,7 +620,6 @@ public:
    using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
-
 /** Class for spatial white Gaussian noise integration.
 
     The target problem is the linear SPDE a(u,v) = F(v) with F(v) := <W,v>,
@@ -637,8 +647,8 @@ class WhiteGaussianNoiseDomainLFIntegrator : public LinearFormIntegrator
    std::normal_distribution<double> dist;
 
    bool save_factors = false;
-public:
 
+public:
 #ifdef MFEM_USE_MPI
    /** @brief Sets the @a seed_ of the random number generator. A fixed seed
        allows for a reproducible sequence of white noise vectors. */
@@ -669,13 +679,13 @@ public:
       if (seed_ > 0) { SetSeed(seed_); }
    }
 #endif
+
    /// @brief Sets/resets the @a seed of the random number generator.
    void SetSeed(int seed)
    {
       generator.seed(seed);
    }
 
-   using LinearFormIntegrator::AssembleRHSElementVect;
    virtual void AssembleRHSElementVect(const FiniteElement &el,
                                        ElementTransformation &Tr,
                                        Vector &elvect);
@@ -715,8 +725,9 @@ public:
       }
       L.DeleteAll();
    }
-};
 
+   using LinearFormIntegrator::AssembleRHSElementVect;
+};
 
 /** Class for domain integration of L(v) := (f, v), where
     f=(f1,...,fn) and v=(v1,...,vn). that makes use of
@@ -738,18 +749,23 @@ public:
       }
    }
 
-   using LinearFormIntegrator::AssembleRHSElementVect;
-   virtual void AssembleRHSElementVect(const FiniteElement &fe,
-                                       ElementTransformation &Tr,
-                                       Vector &elvect);
-
    virtual void SetIntRule(const IntegrationRule *ir)
    {
       MFEM_WARNING("Integration rule not used in this class. "
                    "The QuadratureFunction integration rules are used instead");
    }
-};
 
+   using LinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          ElementTransformation &Tr,
+                                          int oa = 2, int ob = 0) const;
+
+   virtual void AssembleRHSElementVect(const FiniteElement &fe,
+                                       ElementTransformation &Tr,
+                                       Vector &elvect);
+
+   using LinearFormIntegrator::AssembleRHSElementVect;
+};
 
 /** Class for domain integration L(v) := (f, v) that makes use
     of QuadratureFunctionCoefficient. */
@@ -770,19 +786,24 @@ public:
       }
    }
 
-   using LinearFormIntegrator::AssembleRHSElementVect;
-   virtual void AssembleRHSElementVect(const FiniteElement &fe,
-                                       ElementTransformation &Tr,
-                                       Vector &elvect);
-
    virtual void SetIntRule(const IntegrationRule *ir)
    {
       MFEM_WARNING("Integration rule not used in this class. "
                    "The QuadratureFunction integration rules are used instead");
    }
+
+   using LinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el,
+                                          ElementTransformation &Tr,
+                                          int oa = 2, int ob = 0) const;
+
+   virtual void AssembleRHSElementVect(const FiniteElement &fe,
+                                       ElementTransformation &Tr,
+                                       Vector &elvect);
+
+   using LinearFormIntegrator::AssembleRHSElementVect;
 };
 
 }
 
-
 #endif
diff --git a/fem/nonlininteg.cpp b/fem/nonlininteg.cpp
index 5ee1febea..a704ee207 100644
--- a/fem/nonlininteg.cpp
+++ b/fem/nonlininteg.cpp
@@ -15,26 +15,44 @@
 namespace mfem
 {
 
+const IntegrationRule &NonlinearFormIntegrator::GetRule(
+   const FiniteElement&, const FiniteElement&,
+   ElementTransformation&) const
+{
+   MFEM_ABORT("NonlinearFormIntegrator::GetRule(...)\n"
+              "   is not implemented for this class.");
+   return IntRules.Get(0, 0);
+}
+
+const IntegrationRule &NonlinearFormIntegrator::GetRule(
+   const FiniteElement&, const FiniteElement&,
+   FaceElementTransformations&) const
+{
+   MFEM_ABORT("NonlinearFormIntegrator::GetRule(...)\n"
+              "   is not implemented for this class.");
+   return IntRules.Get(0, 0);
+}
+
 void NonlinearFormIntegrator::AssemblePA(const FiniteElementSpace&)
 {
    MFEM_ABORT("NonlinearFormIntegrator::AssemblePA(...)\n"
               "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleGradPA(const Vector &x,
-                                             const FiniteElementSpace &fes)
+void NonlinearFormIntegrator::AssembleGradPA(const Vector&,
+                                             const FiniteElementSpace&)
 {
    MFEM_ABORT("NonlinearFormIntegrator::AssembleGradPA(...)\n"
               "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleGradDiagonalPA(Vector &diag) const
+void NonlinearFormIntegrator::AssembleGradDiagonalPA(Vector&) const
 {
    MFEM_ABORT("NonlinearFormIntegrator::AssembleGradDiagonalPA(...)\n"
               "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AddMultPA(const Vector &, Vector &) const
+void NonlinearFormIntegrator::AddMultPA(const Vector&, Vector&) const
 {
    MFEM_ABORT("NonlinearFormIntegrator::AddMultPA(...)\n"
               "   is not implemented for this class.");
@@ -46,119 +64,141 @@ void NonlinearFormIntegrator::AddMultGradPA(const Vector&, Vector&) const
               "   is not implemented for this class.");
 }
 
-double NonlinearFormIntegrator::GetLocalStateEnergyPA(const Vector &x) const
+double NonlinearFormIntegrator::GetLocalStateEnergyPA(const Vector&) const
 {
    MFEM_ABORT("NonlinearFormIntegrator::GetLocalStateEnergyPA(...)\n"
               "   is not implemented for this class.");
    return 0.0;
 }
 
-void NonlinearFormIntegrator::AssembleMF(const FiniteElementSpace &fes)
+void NonlinearFormIntegrator::AssembleMF(const FiniteElementSpace&)
 {
    MFEM_ABORT("NonlinearFormIntegrator::AssembleMF(...)\n"
               "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AddMultMF(const Vector &, Vector &) const
+void NonlinearFormIntegrator::AddMultMF(const Vector&, Vector&) const
 {
    MFEM_ABORT("NonlinearFormIntegrator::AddMultMF(...)\n"
               "   is not implemented for this class.");
 }
 
-double NonlinearFormIntegrator::GetElementEnergy(
-   const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun)
+double NonlinearFormIntegrator::GetElementEnergy(const FiniteElement&,
+                                                 ElementTransformation&,
+                                                 const Vector&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::GetElementEnergy"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::GetElementEnergy(...)"
+              "   is not implemented for this class.");
    return 0.0;
 }
 
-void NonlinearFormIntegrator::AssembleElementVector(
-   const FiniteElement &el, ElementTransformation &Tr,
-   const Vector &elfun, Vector &elvect)
+void NonlinearFormIntegrator::AssembleElementVector(const FiniteElement&,
+                                                    ElementTransformation&,
+                                                    const Vector&,
+                                                    Vector&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementVector"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementVector(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleFaceVector(
-   const FiniteElement &el1, const FiniteElement &el2,
-   FaceElementTransformations &Tr, const Vector &elfun, Vector &elvect)
+void NonlinearFormIntegrator::AssembleFaceVector(const FiniteElement&,
+                                                 const FiniteElement&,
+                                                 FaceElementTransformations&,
+                                                 const Vector&,
+                                                 Vector&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceVector"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceVector(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleElementGrad(
-   const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun,
-   DenseMatrix &elmat)
+void NonlinearFormIntegrator::AssembleElementGrad(const FiniteElement&,
+                                                  ElementTransformation&,
+                                                  const Vector&,
+                                                  DenseMatrix&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementGrad"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementGrad(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleFaceGrad(
-   const FiniteElement &el1, const FiniteElement &el2,
-   FaceElementTransformations &Tr, const Vector &elfun,
-   DenseMatrix &elmat)
+void NonlinearFormIntegrator::AssembleFaceGrad(const FiniteElement&,
+                                               const FiniteElement&,
+                                               FaceElementTransformations&,
+                                               const Vector&,
+                                               DenseMatrix&)
 {
-   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceGrad"
-              " is not overloaded!");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceGrad(...)\n"
+              "   is not implemented for this class.");
 }
 
+const IntegrationRule &BlockNonlinearFormIntegrator::GetRule(
+   const FiniteElement&, const FiniteElement&test_fe,
+   ElementTransformation&) const
+{
+   MFEM_ABORT("BlockNonlinearFormIntegrator::GetRule(...)\n"
+              "   is not implemented for this class.");
+   return IntRules.Get(0, 0);
+}
 
-void BlockNonlinearFormIntegrator::AssembleElementVector(
-   const Array<const FiniteElement *> &el,
-   ElementTransformation &Tr,
-   const Array<const Vector *> &elfun,
-   const Array<Vector *> &elvec)
+const IntegrationRule &BlockNonlinearFormIntegrator::GetRule(
+   const FiniteElement&, const FiniteElement&,
+   FaceElementTransformations&) const
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementVector"
-              " is not overloaded!");
+   MFEM_ABORT("BlockNonlinearFormIntegrator::GetRule(...)\n"
+              "   is not implemented for this class.");
+   return IntRules.Get(0, 0);
 }
 
-void BlockNonlinearFormIntegrator::AssembleFaceVector(
-   const Array<const FiniteElement *> &el1,
-   const Array<const FiniteElement *> &el2,
-   FaceElementTransformations &Tr,
-   const Array<const Vector *> &elfun,
-   const Array<Vector *> &elvect)
+double BlockNonlinearFormIntegrator::GetElementEnergy(
+   const Array<const FiniteElement *>&,
+   ElementTransformation&,
+   const Array<const Vector *>&)
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceVector"
-              " is not overloaded!");
+   MFEM_ABORT("BlockNonlinearFormIntegrator::GetElementEnergy(...)\n"
+              "   is not implemented for this class.");
+   return 0.0;
 }
 
-void BlockNonlinearFormIntegrator::AssembleElementGrad(
-   const Array<const FiniteElement*> &el,
-   ElementTransformation &Tr,
-   const Array<const Vector *> &elfun,
-   const Array2D<DenseMatrix *> &elmats)
+void BlockNonlinearFormIntegrator::AssembleElementVector(
+   const Array<const FiniteElement *>&,
+   ElementTransformation&,
+   const Array<const Vector *>&,
+   const Array<Vector *>&)
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementGrad"
-              " is not overloaded!");
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementVector(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BlockNonlinearFormIntegrator::AssembleFaceGrad(
-   const Array<const FiniteElement *>&el1,
-   const Array<const FiniteElement *>&el2,
-   FaceElementTransformations &Tr,
-   const Array<const Vector *> &elfun,
-   const Array2D<DenseMatrix *> &elmats)
+void BlockNonlinearFormIntegrator::AssembleFaceVector(
+   const Array<const FiniteElement *>&,
+   const Array<const FiniteElement *>&,
+   FaceElementTransformations&,
+   const Array<const Vector *>&,
+   const Array<Vector *>&)
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceGrad"
-              " is not overloaded!");
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceVector(...)\n"
+              "   is not implemented for this class.");
 }
 
-double BlockNonlinearFormIntegrator::GetElementEnergy(
-   const Array<const FiniteElement *>&el,
-   ElementTransformation &Tr,
-   const Array<const Vector *>&elfun)
+void BlockNonlinearFormIntegrator::AssembleElementGrad(
+   const Array<const FiniteElement*>&,
+   ElementTransformation&,
+   const Array<const Vector *>&,
+   const Array2D<DenseMatrix *>&)
 {
-   MFEM_ABORT("BlockNonlinearFormIntegrator::GetElementEnergy"
-              " is not overloaded!");
-   return 0.0;
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementGrad(...)\n"
+              "   is not implemented for this class.");
 }
 
+void BlockNonlinearFormIntegrator::AssembleFaceGrad(
+   const Array<const FiniteElement *>&,
+   const Array<const FiniteElement *>&,
+   FaceElementTransformations&,
+   const Array<const Vector *>&,
+   const Array2D<DenseMatrix *>&)
+{
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceGrad(...)\n"
+              "   is not implemented for this class.");
+}
 
 double InverseHarmonicModel::EvalW(const DenseMatrix &J) const
 {
@@ -260,7 +300,6 @@ void InverseHarmonicModel::AssembleH(
       }
 }
 
-
 inline void NeoHookeanModel::EvalCoeffs() const
 {
    mu = c_mu->Eval(*Ttr, Ttr->GetIntPoint());
@@ -376,6 +415,13 @@ void NeoHookeanModel::AssembleH(const DenseMatrix &J, const DenseMatrix &DS,
             }
 }
 
+const IntegrationRule &HyperelasticNLFIntegrator::GetRule(
+   const FiniteElement &trial_fe, const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() + 3;
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
 
 double HyperelasticNLFIntegrator::GetElementEnergy(const FiniteElement &el,
                                                    ElementTransformation &Ttr,
@@ -390,11 +436,7 @@ double HyperelasticNLFIntegrator::GetElementEnergy(const FiniteElement &el,
    Jpt.SetSize(dim);
    PMatI.UseExternalData(elfun.GetData(), dof, dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (!ir)
-   {
-      ir = &(IntRules.Get(el.GetGeomType(), 2*el.GetOrder() + 3)); // <---
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Ttr);
 
    energy = 0.0;
    model->SetTransformation(Ttr);
@@ -429,11 +471,7 @@ void HyperelasticNLFIntegrator::AssembleElementVector(
    elvect.SetSize(dof*dim);
    PMatO.UseExternalData(elvect.GetData(), dof, dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (!ir)
-   {
-      ir = &(IntRules.Get(el.GetGeomType(), 2*el.GetOrder() + 3)); // <---
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Ttr);
 
    elvect = 0.0;
    model->SetTransformation(Ttr);
@@ -468,11 +506,7 @@ void HyperelasticNLFIntegrator::AssembleElementGrad(const FiniteElement &el,
    PMatI.UseExternalData(elfun.GetData(), dof, dim);
    elmat.SetSize(dof*dim);
 
-   const IntegrationRule *ir = IntRule;
-   if (!ir)
-   {
-      ir = &(IntRules.Get(el.GetGeomType(), 2*el.GetOrder() + 3)); // <---
-   }
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, Ttr);
 
    elmat = 0.0;
    model->SetTransformation(Ttr);
@@ -490,6 +524,13 @@ void HyperelasticNLFIntegrator::AssembleElementGrad(const FiniteElement &el,
    }
 }
 
+const IntegrationRule &IncompressibleNeoHookeanIntegrator::GetRule(
+   const FiniteElement &trial_fe, const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
+{
+   int order = trial_fe.GetOrder() + test_fe.GetOrder() + 3;
+   return IntRules.Get(trial_fe.GetGeomType(), order);
+}
 
 double IncompressibleNeoHookeanIntegrator::GetElementEnergy(
    const Array<const FiniteElement *>&el,
@@ -511,15 +552,14 @@ double IncompressibleNeoHookeanIntegrator::GetElementEnergy(
    J.SetSize(dim);
    PMatI_u.UseExternalData(elfun[0]->GetData(), dof_u, dim);
 
-   int intorder = 2*el[0]->GetOrder() + 3; // <---
-   const IntegrationRule &ir = IntRules.Get(el[0]->GetGeomType(), intorder);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el[0], Tr);
 
    double energy = 0.0;
    double mu = 0.0;
 
-   for (int i = 0; i < ir.GetNPoints(); ++i)
+   for (int i = 0; i < ir->GetNPoints(); ++i)
    {
-      const IntegrationPoint &ip = ir.IntPoint(i);
+      const IntegrationPoint &ip = ir->IntPoint(i);
       Tr.SetIntPoint(&ip);
       CalcInverse(Tr.Jacobian(), J0i);
 
@@ -572,15 +612,14 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementVector(
    Sh_p.SetSize(dof_p);
    elvec[1]->SetSize(dof_p);
 
-   int intorder = 2*el[0]->GetOrder() + 3; // <---
-   const IntegrationRule &ir = IntRules.Get(el[0]->GetGeomType(), intorder);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el[0], Tr);
 
    *elvec[0] = 0.0;
    *elvec[1] = 0.0;
 
-   for (int i = 0; i < ir.GetNPoints(); ++i)
+   for (int i = 0; i < ir->GetNPoints(); ++i)
    {
-      const IntegrationPoint &ip = ir.IntPoint(i);
+      const IntegrationPoint &ip = ir->IntPoint(i);
       Tr.SetIntPoint(&ip);
       CalcInverse(Tr.Jacobian(), J0i);
 
@@ -605,7 +644,6 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementVector(
 
       elvec[1]->Add(ip.weight * Tr.Weight() * (dJ - 1.0), Sh_p);
    }
-
 }
 
 void IncompressibleNeoHookeanIntegrator::AssembleElementGrad(
@@ -639,12 +677,11 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementGrad(
    PMatI_u.UseExternalData(elfun[0]->GetData(), dof_u, dim);
    Sh_p.SetSize(dof_p);
 
-   int intorder = 2*el[0]->GetOrder() + 3; // <---
-   const IntegrationRule &ir = IntRules.Get(el[0]->GetGeomType(), intorder);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(*el[0], Tr);
 
-   for (int i = 0; i < ir.GetNPoints(); ++i)
+   for (int i = 0; i < ir->GetNPoints(); ++i)
    {
-      const IntegrationPoint &ip = ir.IntPoint(i);
+      const IntegrationPoint &ip = ir->IntPoint(i);
       Tr.SetIntPoint(&ip);
       CalcInverse(Tr.Jacobian(), J0i);
 
@@ -721,16 +758,15 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementGrad(
          }
       }
    }
-
 }
 
-
-const IntegrationRule&
-VectorConvectionNLFIntegrator::GetRule(const FiniteElement &fe,
-                                       ElementTransformation &T)
+const IntegrationRule &VectorConvectionNLFIntegrator::GetRule(
+   const FiniteElement &trial_fe, const FiniteElement &test_fe,
+   ElementTransformation &Trans) const
 {
-   const int order = 2 * fe.GetOrder() + T.OrderGrad(&fe);
-   return IntRules.Get(fe.GetGeomType(), order);
+   int order = Trans.OrderGrad(&trial_fe) + trial_fe.GetOrder() +
+               test_fe.GetOrder();
+   return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
 void VectorConvectionNLFIntegrator::AssembleElementVector(
@@ -751,7 +787,9 @@ void VectorConvectionNLFIntegrator::AssembleElementVector(
    ELV.UseExternalData(elvect.GetData(), nd, dim);
 
    Vector vec1(dim), vec2(dim);
+
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, T);
+
    ELV = 0.0;
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
@@ -841,7 +879,6 @@ void VectorConvectionNLFIntegrator::AssembleElementGrad(
    }
 }
 
-
 void ConvectiveVectorConvectionNLFIntegrator::AssembleElementGrad(
    const FiniteElement &el,
    ElementTransformation &trans,
@@ -890,7 +927,6 @@ void ConvectiveVectorConvectionNLFIntegrator::AssembleElementGrad(
    }
 }
 
-
 void SkewSymmetricVectorConvectionNLFIntegrator::AssembleElementGrad(
    const FiniteElement &el,
    ElementTransformation &trans,
diff --git a/fem/nonlininteg.hpp b/fem/nonlininteg.hpp
index 38b133244..4c2ee2470 100644
--- a/fem/nonlininteg.hpp
+++ b/fem/nonlininteg.hpp
@@ -17,6 +17,7 @@
 #include "coefficient.hpp"
 #include "fespace.hpp"
 #include "ceed/interface/operator.hpp"
+#include "ceed/interface/util.hpp"
 
 namespace mfem
 {
@@ -37,23 +38,43 @@ protected:
       : IntRule(ir), ceedOp(NULL) {}
 
 public:
+   /// Set the memory type used for GeometricFactors and other large allocations
+   /// in PA extensions.
+   void SetPAMemoryType(MemoryType mt) { pa_mt = mt; }
+
+   /// Indicates whether this integrator can use a Ceed backend.
+   virtual bool SupportsCeed() const { return false; }
+
+   /// Access the underlying ceed::Operator for libCEED backends, after the
+   /// integrator has been assembled.
+   ceed::Operator &GetCeedOp() { return *ceedOp; }
+
    /** @brief Prescribe a fixed IntegrationRule to use (when @a ir != NULL) or
        let the integrator choose (when @a ir == NULL). */
    virtual void SetIntRule(const IntegrationRule *ir) { IntRule = ir; }
-
-   /// Prescribe a fixed IntegrationRule to use.
    void SetIntegrationRule(const IntegrationRule &ir) { SetIntRule(&ir); }
 
-   /// Set the memory type used for GeometricFactors and other large allocations
-   /// in PA extensions.
-   void SetPAMemoryType(MemoryType mt) { pa_mt = mt; }
-
    /// Get the integration rule of the integrator (possibly NULL).
    const IntegrationRule *GetIntegrationRule() const { return IntRule; }
 
+   /// Get the integration rule of the integrator as a function of the finite
+   /// element and geometry orders.
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Trans) const;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Trans) const;
+   const IntegrationRule &GetRule(const FiniteElement &el,
+                                  ElementTransformation &Trans) const
+   { return GetRule(el, el, Trans); }
+   const IntegrationRule &GetRule(const FiniteElement &el,
+                                  FaceElementTransformations &Trans) const
+   { return GetRule(el, el, Trans); }
+
    /// Method defining partial assembly.
    /** The result of the partial assembly is stored internally so that it can be
-       used later in the methods AddMultPA(). */
+       used later in the methods AddMultPA() and AddMultTransposePA(). */
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
    /** @brief Prepare the integrator for partial assembly (PA) gradient
@@ -132,11 +153,6 @@ public:
                                  FaceElementTransformations &Tr,
                                  const Vector &elfun, DenseMatrix &elmat);
 
-   /// Indicates whether this integrator can use a Ceed backend.
-   virtual bool SupportsCeed() const { return false; }
-
-   ceed::Operator &GetCeedOp() { return *ceedOp; }
-
    virtual ~NonlinearFormIntegrator()
    {
       delete ceedOp;
@@ -149,7 +165,36 @@ public:
     for block state vectors. */
 class BlockNonlinearFormIntegrator
 {
+protected:
+   const IntegrationRule *IntRule;
+
+   BlockNonlinearFormIntegrator(const IntegrationRule *ir = NULL)
+      : IntRule(ir) {}
+
 public:
+   /** @brief Prescribe a fixed IntegrationRule to use (when @a ir != NULL) or
+       let the integrator choose (when @a ir == NULL). */
+   virtual void SetIntRule(const IntegrationRule *ir) { IntRule = ir; }
+   void SetIntegrationRule(const IntegrationRule &ir) { SetIntRule(&ir); }
+
+   /// Get the integration rule of the integrator (possibly NULL).
+   const IntegrationRule *GetIntegrationRule() const { return IntRule; }
+
+   /// Get the integration rule of the integrator as a function of the finite
+   /// element and geometry orders.
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Tr) const;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          FaceElementTransformations &Tr) const;
+   const IntegrationRule &GetRule(const FiniteElement &el,
+                                  ElementTransformation &Trans) const
+   { return GetRule(el, el, Trans); }
+   const IntegrationRule &GetRule(const FiniteElement &el,
+                                  FaceElementTransformations &Trans) const
+   { return GetRule(el, el, Trans); }
+
    /// Compute the local energy
    virtual double GetElementEnergy(const Array<const FiniteElement *>&el,
                                    ElementTransformation &Tr,
@@ -182,8 +227,7 @@ public:
    virtual ~BlockNonlinearFormIntegrator() {}
 };
 
-
-/// Abstract class for hyperelastic models
+/// Abstract base class for hyperelastic models
 class HyperelasticModel
 {
 protected:
@@ -228,7 +272,6 @@ public:
                           const double weight, DenseMatrix &A) const = 0;
 };
 
-
 /** Inverse-harmonic hyperelastic model with a strain energy density function
     given by the formula: W(J) = (1/2) det(J) Tr((J J^t)^{-1}) where J is the
     deformation gradient. */
@@ -247,7 +290,6 @@ public:
                           const double weight, DenseMatrix &A) const;
 };
 
-
 /** Neo-Hookean hyperelastic model with a strain energy density function given
     by the formula: \f$(\mu/2)(\bar{I}_1 - dim) + (K/2)(det(J)/g - 1)^2\f$ where
     J is the deformation gradient and \f$\bar{I}_1 = (det(J))^{-2/dim} Tr(J
@@ -281,7 +323,6 @@ public:
                           const double weight, DenseMatrix &A) const;
 };
 
-
 /** Hyperelastic integrator for any given HyperelasticModel.
 
     Represents @f$ \int W(Jpt) dx @f$ over a target zone, where W is the
@@ -310,10 +351,11 @@ public:
    /** @param[in] m  HyperelasticModel that will be integrated. */
    HyperelasticNLFIntegrator(HyperelasticModel *m) : model(m) {}
 
-   /** @brief Computes the integral of W(Jacobian(Trt)) over a target zone
-       @param[in] el     Type of FiniteElement.
-       @param[in] Ttr    Represents ref->target coordinates transformation.
-       @param[in] elfun  Physical coordinates of the zone. */
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Trans) const;
+
    virtual double GetElementEnergy(const FiniteElement &el,
                                    ElementTransformation &Ttr,
                                    const Vector &elfun);
@@ -342,24 +384,26 @@ private:
 public:
    IncompressibleNeoHookeanIntegrator(Coefficient &mu_) : c_mu(&mu_) {}
 
+   using BlockNonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Trans) const;
+
    virtual double GetElementEnergy(const Array<const FiniteElement *>&el,
                                    ElementTransformation &Tr,
                                    const Array<const Vector *> &elfun);
 
-   /// Perform the local action of the NonlinearFormIntegrator
    virtual void AssembleElementVector(const Array<const FiniteElement *> &el,
                                       ElementTransformation &Tr,
                                       const Array<const Vector *> &elfun,
                                       const Array<Vector *> &elvec);
 
-   /// Assemble the local gradient matrix
    virtual void AssembleElementGrad(const Array<const FiniteElement*> &el,
                                     ElementTransformation &Tr,
                                     const Array<const Vector *> &elfun,
                                     const Array2D<DenseMatrix *> &elmats);
 };
 
-
 class VectorConvectionNLFIntegrator : public NonlinearFormIntegrator
 {
 private:
@@ -378,8 +422,12 @@ public:
 
    VectorConvectionNLFIntegrator() = default;
 
-   static const IntegrationRule &GetRule(const FiniteElement &fe,
-                                         ElementTransformation &T);
+   virtual bool SupportsCeed() const { return DeviceCanUseCeed(); }
+
+   using NonlinearFormIntegrator::GetRule;
+   virtual const IntegrationRule &GetRule(const FiniteElement &el1,
+                                          const FiniteElement &el2,
+                                          ElementTransformation &Trans) const;
 
    virtual void AssembleElementVector(const FiniteElement &el,
                                       ElementTransformation &trans,
@@ -400,7 +448,6 @@ public:
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 };
 
-
 /** This class is used to assemble the convective form of the nonlinear term
     arising in the Navier-Stokes equations \f$(u \cdot \nabla v, w )\f$ */
 class ConvectiveVectorConvectionNLFIntegrator :
@@ -422,7 +469,6 @@ public:
                                     DenseMatrix &elmat);
 };
 
-
 /** This class is used to assemble the skew-symmetric form of the nonlinear term
     arising in the Navier-Stokes equations
     \f$.5*(u \cdot \nabla v, w ) - .5*(u \cdot \nabla w, v )\f$ */
diff --git a/fem/pbilinearform.cpp b/fem/pbilinearform.cpp
index ee2dc79b2..9822654a8 100644
--- a/fem/pbilinearform.cpp
+++ b/fem/pbilinearform.cpp
@@ -19,108 +19,6 @@
 namespace mfem
 {
 
-void ParBilinearForm::pAllocMat()
-{
-   int nbr_size = pfes->GetFaceNbrVSize();
-
-   if (precompute_sparsity == 0 || fes->GetVDim() > 1)
-   {
-      if (keep_nbr_block)
-      {
-         mat = new SparseMatrix(height + nbr_size, width + nbr_size);
-      }
-      else
-      {
-         mat = new SparseMatrix(height, width + nbr_size);
-      }
-      return;
-   }
-
-   // the sparsity pattern is defined from the map: face->element->dof
-   const Table &lelem_ldof = fes->GetElementToDofTable(); // <-- dofs
-   const Table &nelem_ndof = pfes->face_nbr_element_dof; // <-- vdofs
-   Table elem_dof; // element + nbr-element <---> dof
-   if (nbr_size > 0)
-   {
-      // merge lelem_ldof and nelem_ndof into elem_dof
-      int s1 = lelem_ldof.Size(), s2 = nelem_ndof.Size();
-      const int *I1 = lelem_ldof.GetI(), *J1 = lelem_ldof.GetJ();
-      const int *I2 = nelem_ndof.GetI(), *J2 = nelem_ndof.GetJ();
-      const int nnz1 = I1[s1], nnz2 = I2[s2];
-
-      elem_dof.SetDims(s1 + s2, nnz1 + nnz2);
-
-      int *I = elem_dof.GetI(), *J = elem_dof.GetJ();
-      for (int i = 0; i <= s1; i++)
-      {
-         I[i] = I1[i];
-      }
-      for (int j = 0; j < nnz1; j++)
-      {
-         J[j] = J1[j];
-      }
-      for (int i = 0; i <= s2; i++)
-      {
-         I[s1+i] = I2[i] + nnz1;
-      }
-      for (int j = 0; j < nnz2; j++)
-      {
-         J[nnz1+j] = J2[j] + height;
-      }
-   }
-   //   dof_elem x  elem_face x face_elem x elem_dof  (keep_nbr_block = true)
-   // ldof_lelem x lelem_face x face_elem x elem_dof  (keep_nbr_block = false)
-   Table dof_dof;
-   {
-      Table face_dof; // face_elem x elem_dof
-      {
-         Table *face_elem = pfes->GetParMesh()->GetFaceToAllElementTable();
-         if (nbr_size > 0)
-         {
-            mfem::Mult(*face_elem, elem_dof, face_dof);
-         }
-         else
-         {
-            mfem::Mult(*face_elem, lelem_ldof, face_dof);
-         }
-         delete face_elem;
-         if (nbr_size > 0)
-         {
-            elem_dof.Clear();
-         }
-      }
-
-      if (keep_nbr_block)
-      {
-         Table dof_face;
-         Transpose(face_dof, dof_face, height + nbr_size);
-         mfem::Mult(dof_face, face_dof, dof_dof);
-      }
-      else
-      {
-         Table ldof_face;
-         {
-            Table face_ldof;
-            Table *face_lelem = fes->GetMesh()->GetFaceToElementTable();
-            mfem::Mult(*face_lelem, lelem_ldof, face_ldof);
-            delete face_lelem;
-            Transpose(face_ldof, ldof_face, height);
-         }
-         mfem::Mult(ldof_face, face_dof, dof_dof);
-      }
-   }
-
-   int *I = dof_dof.GetI();
-   int *J = dof_dof.GetJ();
-   int nrows = dof_dof.Size();
-   double *data = Memory<double>(I[nrows]);
-
-   mat = new SparseMatrix(I, J, data, nrows, height + nbr_size);
-   *mat = 0.0;
-
-   dof_dof.LoseData();
-}
-
 void ParBilinearForm::ParallelRAP(SparseMatrix &loc_A, OperatorHandle &A,
                                   bool steal_loc_A)
 {
@@ -224,10 +122,8 @@ void ParBilinearForm::AssembleSharedFaces(int skip_zeros)
    ParMesh *pmesh = pfes->GetParMesh();
    FaceElementTransformations *T;
    Array<int> vdofs1, vdofs2, vdofs_all;
-   DenseMatrix elemmat;
 
-   int nfaces = pmesh->GetNSharedFaces();
-   for (int i = 0; i < nfaces; i++)
+   for (int i = 0; i < pmesh->GetNSharedFaces(); i++)
    {
       T = pmesh->GetSharedFaceTransformations(i);
       int Elem2NbrNo = T->Elem2No - pmesh->GetNE();
@@ -270,7 +166,15 @@ void ParBilinearForm::Assemble(int skip_zeros)
       pfes->ExchangeFaceNbrData();
       if (!ext && mat == NULL)
       {
-         pAllocMat();
+         int nbr_size = pfes->GetFaceNbrVSize();
+         if (keep_nbr_block)
+         {
+            mat = new SparseMatrix(height + nbr_size, width + nbr_size);
+         }
+         else
+         {
+            mat = new SparseMatrix(height, width + nbr_size);
+         }
       }
    }
 
diff --git a/fem/pbilinearform.hpp b/fem/pbilinearform.hpp
index ffb0e9c6b..66a944cac 100644
--- a/fem/pbilinearform.hpp
+++ b/fem/pbilinearform.hpp
@@ -30,26 +30,25 @@ class ParBilinearForm : public BilinearForm
    friend FABilinearFormExtension;
 
 protected:
-   ParFiniteElementSpace *pfes; ///< Points to the same object as #fes
+   ///< Points to the same object as #fes
+   ParFiniteElementSpace *pfes;
 
    /// Auxiliary vectors used in TrueAddMult(): L-, L-, and T-vector, resp.
    mutable Vector Xaux, Yaux, Ytmp;
 
+   /// Matrix and eliminated matrix
    OperatorHandle p_mat, p_mat_e;
 
    bool keep_nbr_block;
 
-   // Allocate mat - called when (mat == NULL && fbfi.Size() > 0)
-   void pAllocMat();
-
    void AssembleSharedFaces(int skip_zeros = 1);
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   ParBilinearForm(const ParBilinearForm &);
+   /// Copy construction is not supported.
+   ParBilinearForm(const ParBilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   ParBilinearForm &operator=(const ParBilinearForm &);
+   /// Copy assignment is not supported.
+   ParBilinearForm &operator=(const ParBilinearForm &) = delete;
 
 public:
    /// Creates parallel bilinear form associated with the FE space @a *pf.
@@ -219,6 +218,7 @@ protected:
    ParFiniteElementSpace *trial_pfes;
    /// Points to the same object as #test_fes
    ParFiniteElementSpace *test_pfes;
+
    /// Auxiliary objects used in TrueAddMult().
    mutable ParGridFunction Xaux, Yaux;
 
@@ -226,11 +226,11 @@ protected:
    OperatorHandle p_mat, p_mat_e;
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   ParMixedBilinearForm(const ParMixedBilinearForm &);
+   /// Copy construction is not supported.
+   ParMixedBilinearForm(const ParMixedBilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   ParMixedBilinearForm &operator=(const ParMixedBilinearForm &);
+   /// Copy assignment is not supported.
+   ParMixedBilinearForm &operator=(const ParMixedBilinearForm &) = delete;
 
 public:
    /** @brief Construct a ParMixedBilinearForm on the given FiniteElementSpace%s
@@ -312,11 +312,12 @@ protected:
    ParFiniteElementSpace *range_fes;
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   ParDiscreteLinearOperator(const ParDiscreteLinearOperator &);
+   /// Copy construction is not supported.
+   ParDiscreteLinearOperator(const ParDiscreteLinearOperator &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   ParDiscreteLinearOperator &operator=(const ParDiscreteLinearOperator &);
+   /// Copy assignment is not supported.
+   ParDiscreteLinearOperator &operator=(const ParDiscreteLinearOperator &) =
+      delete;
 
 public:
    /** @brief Construct a ParDiscreteLinearOperator on the given
@@ -326,7 +327,11 @@ public:
        object. */
    ParDiscreteLinearOperator(ParFiniteElementSpace *dfes,
                              ParFiniteElementSpace *rfes)
-      : DiscreteLinearOperator(dfes, rfes) { domain_fes=dfes; range_fes=rfes; }
+      : DiscreteLinearOperator(dfes, rfes)
+   {
+      domain_fes = dfes;
+      range_fes = rfes;
+   }
 
    /// Returns the matrix "assembled" on the true dofs
    HypreParMatrix *ParallelAssemble() const;
diff --git a/fem/pfespace.cpp b/fem/pfespace.cpp
index 6beb97c72..8e4de18d6 100644
--- a/fem/pfespace.cpp
+++ b/fem/pfespace.cpp
@@ -465,53 +465,68 @@ void ParFiniteElementSpace::ApplyLDofSigns(Table &el_dof) const
    ApplyLDofSigns(all_dofs);
 }
 
-DofTransformation *
-ParFiniteElementSpace::GetElementDofs(int i, Array<int> &dofs) const
+void ParFiniteElementSpace::GetElementDofs(int i, Array<int> &dofs,
+                                           DofTransformation &doftrans) const
 {
    if (elem_dof)
    {
       elem_dof->GetRow(i, dofs);
 
-      if (DoFTrans[mesh->GetElementBaseGeometry(i)])
+      if (DoFTransArray[mesh->GetElementBaseGeometry(i)])
       {
          Array<int> Fo;
          elem_fos->GetRow(i, Fo);
-         DoFTrans[mesh->GetElementBaseGeometry(i)]->SetFaceOrientations(Fo);
-         return DoFTrans[mesh->GetElementBaseGeometry(i)];
+         doftrans.SetDofTransformation(
+            *DoFTransArray[mesh->GetElementBaseGeometry(i)]);
+         doftrans.SetFaceOrientations(Fo);
       }
-      return NULL;
+      return;
    }
-   DofTransformation * doftrans = FiniteElementSpace::GetElementDofs(i, dofs);
+   FiniteElementSpace::GetElementDofs(i, dofs, doftrans);
    if (Conforming())
    {
       ApplyLDofSigns(dofs);
    }
-   return doftrans;
 }
 
 DofTransformation *
-ParFiniteElementSpace::GetBdrElementDofs(int i, Array<int> &dofs) const
+ParFiniteElementSpace::GetElementDofs(int i, Array<int> &dofs) const
+{
+   DoFTrans.SetDofTransformation(NULL);
+   GetElementDofs(i, dofs, DoFTrans);
+   return DoFTrans.GetDofTransformation() ? &DoFTrans : NULL;
+}
+
+void ParFiniteElementSpace::GetBdrElementDofs(int i, Array<int> &dofs,
+                                              DofTransformation &doftrans) const
 {
    if (bdr_elem_dof)
    {
       bdr_elem_dof->GetRow(i, dofs);
 
-      if (DoFTrans[mesh->GetBdrElementBaseGeometry(i)])
+      if (DoFTransArray[mesh->GetBdrElementBaseGeometry(i)])
       {
          Array<int> Fo;
-         bdr_elem_fos -> GetRow (i, Fo);
-         DoFTrans[mesh->GetBdrElementBaseGeometry(i)]->SetFaceOrientations(Fo);
-         return DoFTrans[mesh->GetBdrElementBaseGeometry(i)];
+         bdr_elem_fos->GetRow(i, Fo);
+         doftrans.SetDofTransformation(
+            *DoFTransArray[mesh->GetBdrElementBaseGeometry(i)]);
+         doftrans.SetFaceOrientations(Fo);
       }
-      return NULL;
+      return;
    }
-   DofTransformation * doftrans =
-      FiniteElementSpace::GetBdrElementDofs(i, dofs);
+   FiniteElementSpace::GetBdrElementDofs(i, dofs, doftrans);
    if (Conforming())
    {
       ApplyLDofSigns(dofs);
    }
-   return doftrans;
+}
+
+DofTransformation *
+ParFiniteElementSpace::GetBdrElementDofs(int i, Array<int> &dofs) const
+{
+   DoFTrans.SetDofTransformation(NULL);
+   GetBdrElementDofs(i, dofs, DoFTrans);
+   return DoFTrans.GetDofTransformation() ? &DoFTrans : NULL;
 }
 
 int ParFiniteElementSpace::GetFaceDofs(int i, Array<int> &dofs,
@@ -938,8 +953,8 @@ void ParFiniteElementSpace::Build_Dof_TrueDof_Matrix() const // matrix P
          }
          else if (i_offd[i+1] == i_offd[i] + 2)
          {
-            const double * T = ND_StatelessDofTransformation
-                               ::GetFaceTransform(ltori[i]).GetData();
+            const double * T =
+               ND_DofTransformation::GetFaceTransform(ltori[i]).GetData();
             j_offd[i_offd[i] + 1] = j_offd[i_offd[i]] + 1;
             d_offd[i_offd[i]] = T[0]; d_offd[i_offd[i] + 1] = T[2];
             i++;
@@ -1423,13 +1438,14 @@ DofTransformation *ParFiniteElementSpace::GetFaceNbrElementVDofs(
    face_nbr_element_dof.GetRow(i, vdofs);
 
    DofTransformation *doftrans = NULL;
-   Geometry::Type geom = GetFaceNbrFE(i)->GetGeomType();
-   if (DoFTrans[geom])
+   if (DoFTransArray[GetFaceNbrFE(i)->GetGeomType()])
    {
       Array<int> F, Fo;
       pmesh->GetFaceNbrElementFaces(pmesh->GetNE() + i, F, Fo);
-      doftrans = DoFTrans[geom];
-      doftrans->SetFaceOrientations(Fo);
+      DoFTrans.SetDofTransformation(
+         *DoFTransArray[GetFaceNbrFE(i)->GetGeomType()]);
+      DoFTrans.SetFaceOrientations(Fo);
+      doftrans = &DoFTrans;
    }
    if (vdim == 1 || doftrans == NULL)
    {
@@ -1437,7 +1453,8 @@ DofTransformation *ParFiniteElementSpace::GetFaceNbrElementVDofs(
    }
    else
    {
-      VDoFTrans.SetDofTransformation(*doftrans);
+      VDoFTrans.SetDofTransformation(*doftrans->GetDofTransformation());
+      VDoFTrans.SetFaceOrientations(doftrans->GetFaceOrientations());
       return &VDoFTrans;
    }
 }
diff --git a/fem/pfespace.hpp b/fem/pfespace.hpp
index c4a95a365..61448c3b7 100644
--- a/fem/pfespace.hpp
+++ b/fem/pfespace.hpp
@@ -286,9 +286,19 @@ public:
    /// Returns indexes of degrees of freedom in array dofs for i'th element.
    virtual DofTransformation *GetElementDofs(int i, Array<int> &dofs) const;
 
+   /// Returns indexes of degrees of freedom in array dofs for i'th element and
+   /// returns the DofTransformation data in a user-provided object.
+   virtual void GetElementDofs(int i, Array<int> &dofs,
+                               DofTransformation &doftrans) const;
+
    /// Returns indexes of degrees of freedom for i'th boundary element.
    virtual DofTransformation *GetBdrElementDofs(int i, Array<int> &dofs) const;
 
+   /// Returns indexes of degrees of freedom for i'th boundary element and
+   /// returns the DofTransformation data in a user-provided object.
+   virtual void GetBdrElementDofs(int i, Array<int> &dofs,
+                                  DofTransformation &doftrans) const;
+
    /** Returns the indexes of the degrees of freedom for i'th face
        including the dofs for the edges and the vertices of the face. */
    virtual int GetFaceDofs(int i, Array<int> &dofs, int variant = 0) const;
diff --git a/fem/transfer.cpp b/fem/transfer.cpp
index 7f95ca9fe..a7dd0731c 100644
--- a/fem/transfer.cpp
+++ b/fem/transfer.cpp
@@ -930,17 +930,13 @@ TransferOperator::TransferOperator(const FiniteElementSpace& lFESpace_,
       P.SetOperatorOwner(false);
       opr = P.Ptr();
    }
-   else if (lFESpace_.GetMesh()->GetNE() > 0
-            && hFESpace_.GetMesh()->GetNE() > 0
-            && lFESpace_.GetVDim() == 1
-            && hFESpace_.GetVDim() == 1
-            && dynamic_cast<const TensorBasisElement*>(lFESpace_.GetFE(0))
-            && dynamic_cast<const TensorBasisElement*>(hFESpace_.GetFE(0))
-            && !isvar_order
-            && (hFESpace_.FEColl()->GetContType() ==
-                mfem::FiniteElementCollection::CONTINUOUS ||
-                hFESpace_.FEColl()->GetContType() ==
-                mfem::FiniteElementCollection::DISCONTINUOUS))
+   else if (UsesTensorBasis(lFESpace_) && UsesTensorBasis(hFESpace_) &&
+            lFESpace_.GetVDim() == 1 && hFESpace_.GetVDim() == 1 &&
+            !isvar_order &&
+            (hFESpace_.FEColl()->GetContType() ==
+             mfem::FiniteElementCollection::CONTINUOUS ||
+             hFESpace_.FEColl()->GetContType() ==
+             mfem::FiniteElementCollection::DISCONTINUOUS))
    {
       opr = new TensorProductPRefinementTransferOperator(lFESpace_, hFESpace_);
    }
diff --git a/general/array.cpp b/general/array.cpp
index 12c3e3c06..e1a81e2d1 100644
--- a/general/array.cpp
+++ b/general/array.cpp
@@ -175,6 +175,7 @@ void Array2D<T>::Print(std::ostream &os, int width_)
    }
 }
 
+template class Array<bool>;
 template class Array<char>;
 template class Array<int>;
 template class Array<long long>;
diff --git a/general/device.cpp b/general/device.cpp
index ccee71cd7..c8362f63c 100644
--- a/general/device.cpp
+++ b/general/device.cpp
@@ -15,9 +15,9 @@
 #include "../fem/ceed/interface/util.hpp"
 #endif
 
-#include <unordered_map>
-#include <string>
 #include <map>
+#include <string>
+#include <unordered_map>
 
 namespace mfem
 {
@@ -34,7 +34,6 @@ occa::device occaDevice;
 
 #ifdef MFEM_USE_CEED
 Ceed ceed = NULL;
-
 ceed::BasisMap ceed_basis_map;
 ceed::RestrMap ceed_restr_map;
 #endif
@@ -144,27 +143,31 @@ Device::Device()
    }
 }
 
-
 Device::~Device()
 {
-   if ( device_env && !destroy_mm) { return; }
+   if (device_env && !destroy_mm) { return; }
    if (!device_env &&  destroy_mm && !mem_host_env)
    {
       free(device_option);
 #ifdef MFEM_USE_CEED
-      // Destroy FES -> CeedBasis, CeedElemRestriction hash table contents
-      for (auto entry : internal::ceed_basis_map)
-      {
-         CeedBasisDestroy(&entry.second);
-      }
-      internal::ceed_basis_map.clear();
-      for (auto entry : internal::ceed_restr_map)
+#ifdef MFEM_USE_OPENMP
+      #pragma omp parallel
+#endif
       {
-         CeedElemRestrictionDestroy(&entry.second);
+         // Destroy FES -> CeedBasis, CeedElemRestriction hash table contents
+         for (auto entry : internal::ceed_basis_map)
+         {
+            CeedBasisDestroy(&entry.second);
+         }
+         internal::ceed_basis_map.clear();
+         for (auto entry : internal::ceed_restr_map)
+         {
+            CeedElemRestrictionDestroy(&entry.second);
+         }
+         internal::ceed_restr_map.clear();
+         // Destroy Ceed context
+         CeedDestroy(&internal::ceed);
       }
-      internal::ceed_restr_map.clear();
-      // Destroy Ceed context
-      CeedDestroy(&internal::ceed);
 #endif
       mm.Destroy();
    }
@@ -481,22 +484,27 @@ static void OccaDeviceSetup(const int dev)
 #endif
 }
 
-static void CeedDeviceSetup(const char* ceed_spec)
+static void CeedDeviceSetup(const char *ceed_spec)
 {
 #ifdef MFEM_USE_CEED
-   CeedInit(ceed_spec, &internal::ceed);
-   const char *ceed_backend;
-   CeedGetResource(internal::ceed, &ceed_backend);
-   if (strcmp(ceed_spec, ceed_backend) && strcmp(ceed_spec, "/cpu/self") &&
-       strcmp(ceed_spec, "/gpu/hip"))
+#ifdef MFEM_USE_OPENMP
+   #pragma omp parallel
+#endif
    {
-      mfem::out << std::endl << "WARNING!!!\n"
-                "libCEED is not using the requested backend!!!\n"
-                "WARNING!!!\n" << std::endl;
-   }
+      CeedInit(ceed_spec, &internal::ceed);
+      const char *ceed_backend;
+      CeedGetResource(internal::ceed, &ceed_backend);
+      size_t ceed_spec_len = strlen(ceed_spec);
+      if (strncmp(ceed_spec, ceed_backend, ceed_spec_len))
+      {
+         mfem::out << std::endl << "WARNING!!!\n"
+                   "libCEED is not using the requested backend!!!\n"
+                   "WARNING!!!\n" << std::endl;
+      }
 #ifdef MFEM_DEBUG
-   CeedSetErrorHandler(internal::ceed, CeedErrorStore);
+      CeedSetErrorHandler(internal::ceed, CeedErrorStore);
 #endif
+   }
 #else
    MFEM_CONTRACT_VAR(ceed_spec);
 #endif
diff --git a/general/version.cpp b/general/version.cpp
index d2b05f8ed..f4c402d51 100644
--- a/general/version.cpp
+++ b/general/version.cpp
@@ -103,9 +103,6 @@ const char *GetConfigStr()
 #ifdef MFEM_USE_LAPACK
       "MFEM_USE_LAPACK\n"
 #endif
-#ifdef MFEM_USE_LEGACY_OPENMP
-      "MFEM_USE_LEGACY_OPENMP\n"
-#endif
 #ifdef MFEM_USE_LIBUNWIND
       "MFEM_USE_LIBUNWIND\n"
 #endif
diff --git a/linalg/auxiliary.cpp b/linalg/auxiliary.cpp
index 22c2aa8e0..bcb55ca3e 100644
--- a/linalg/auxiliary.cpp
+++ b/linalg/auxiliary.cpp
@@ -171,7 +171,6 @@ MatrixFreeAuxiliarySpace::MatrixFreeAuxiliarySpace(
    {
       a_lor.AddDomainIntegrator(new VectorMassIntegrator);
    }
-   a_lor.UsePrecomputedSparsity();
    a_lor.Assemble();
    a_lor.EliminateEssentialBC(ess_bdr, policy);
    a_lor.Finalize();
@@ -244,7 +243,6 @@ MatrixFreeAuxiliarySpace::MatrixFreeAuxiliarySpace(
    {
       a_lor.AddDomainIntegrator(new DiffusionIntegrator);
    }
-   a_lor.UsePrecomputedSparsity();
    a_lor.Assemble();
    if (ess_bdr.Size())
    {
diff --git a/linalg/sparsemat.cpp b/linalg/sparsemat.cpp
index 145379c00..e55ea47b4 100644
--- a/linalg/sparsemat.cpp
+++ b/linalg/sparsemat.cpp
@@ -764,7 +764,6 @@ void SparseMatrix::AddMult(const Vector &x, Vector &y, const double a) const
       return;
    }
 
-#ifndef MFEM_USE_LEGACY_OPENMP
    const int height = this->height;
    const int nnz = J.Capacity();
    auto d_I = Read(I, height+1);
@@ -885,24 +884,6 @@ void SparseMatrix::AddMult(const Vector &x, Vector &y, const double a) const
       });
 
    }
-
-#else // MFEM_USE_LEGACY_OPENMP
-   const double *Ap = A, *xp = x.GetData();
-   double *yp = y.GetData();
-   const int *Jp = J, *Ip = I;
-
-   #pragma omp parallel for
-   for (int i = 0; i < height; i++)
-   {
-      double d = 0.0;
-      const int end = Ip[i+1];
-      for (int j = Ip[i]; j < end; j++)
-      {
-         d += Ap[j] * xp[Jp[j]];
-      }
-      yp[i] += a * d;
-   }
-#endif // MFEM_USE_LEGACY_OPENMP
 }
 
 void SparseMatrix::MultTranspose(const Vector &x, Vector &y) const
diff --git a/linalg/vector.cpp b/linalg/vector.cpp
index a51d6ac9c..ef68efe77 100644
--- a/linalg/vector.cpp
+++ b/linalg/vector.cpp
@@ -106,9 +106,6 @@ const double &Vector::Elem(int i) const
 double Vector::operator*(const double *v) const
 {
    double dot = 0.0;
-#ifdef MFEM_USE_LEGACY_OPENMP
-   #pragma omp parallel for reduction(+:dot)
-#endif
    for (int i = 0; i < size; i++)
    {
       dot += data[i] * v[i];
@@ -319,7 +316,6 @@ void add(const Vector &v1, const Vector &v2, Vector &v)
    MFEM_ASSERT(v.size == v1.size && v.size == v2.size,
                "incompatible Vectors!");
 
-#if !defined(MFEM_USE_LEGACY_OPENMP)
    const bool use_dev = v1.UseDevice() || v2.UseDevice() || v.UseDevice();
    const int N = v.size;
    // Note: get read access first, in case v is the same as v1/v2.
@@ -327,13 +323,6 @@ void add(const Vector &v1, const Vector &v2, Vector &v)
    auto x2 = v2.Read(use_dev);
    auto y = v.Write(use_dev);
    mfem::forall_switch(use_dev, N, [=] MFEM_HOST_DEVICE (int i) { y[i] = x1[i] + x2[i]; });
-#else
-   #pragma omp parallel for
-   for (int i = 0; i < v.size; i++)
-   {
-      v.data[i] = v1.data[i] + v2.data[i];
-   }
-#endif
 }
 
 void add(const Vector &v1, double alpha, const Vector &v2, Vector &v)
@@ -351,7 +340,6 @@ void add(const Vector &v1, double alpha, const Vector &v2, Vector &v)
    }
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = v1.UseDevice() || v2.UseDevice() || v.UseDevice();
       const int N = v.size;
       // Note: get read access first, in case v is the same as v1/v2.
@@ -362,16 +350,6 @@ void add(const Vector &v1, double alpha, const Vector &v2, Vector &v)
       {
          d_z[i] = d_x[i] + alpha * d_y[i];
       });
-#else
-      const double *v1p = v1.data, *v2p = v2.data;
-      double *vp = v.data;
-      const int s = v.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         vp[i] = v1p[i] + alpha*v2p[i];
-      }
-#endif
    }
 }
 
@@ -390,7 +368,6 @@ void add(const double a, const Vector &x, const Vector &y, Vector &z)
    }
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
       const int N = x.size;
       // Note: get read access first, in case z is the same as x/y.
@@ -401,17 +378,6 @@ void add(const double a, const Vector &x, const Vector &y, Vector &z)
       {
          zd[i] = a * (xd[i] + yd[i]);
       });
-#else
-      const double *xp = x.data;
-      const double *yp = y.data;
-      double       *zp = z.data;
-      const int      s = x.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         zp[i] = a * (xp[i] + yp[i]);
-      }
-#endif
    }
 }
 
@@ -445,7 +411,6 @@ void add(const double a, const Vector &x,
 #endif
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
       const int N = x.size;
       // Note: get read access first, in case z is the same as x/y.
@@ -456,17 +421,6 @@ void add(const double a, const Vector &x,
       {
          zd[i] = a * xd[i] + b * yd[i];
       });
-#else
-      const double *xp = x.data;
-      const double *yp = y.data;
-      double       *zp = z.data;
-      const int      s = x.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         zp[i] = a * xp[i] + b * yp[i];
-      }
-#endif
    }
 }
 
@@ -475,7 +429,6 @@ void subtract(const Vector &x, const Vector &y, Vector &z)
    MFEM_ASSERT(x.size == y.size && x.size == z.size,
                "incompatible Vectors!");
 
-#if !defined(MFEM_USE_LEGACY_OPENMP)
    const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
    const int N = x.size;
    // Note: get read access first, in case z is the same as x/y.
@@ -486,17 +439,6 @@ void subtract(const Vector &x, const Vector &y, Vector &z)
    {
       zd[i] = xd[i] - yd[i];
    });
-#else
-   const double *xp = x.data;
-   const double *yp = y.data;
-   double       *zp = z.data;
-   const int     s = x.size;
-   #pragma omp parallel for
-   for (int i = 0; i < s; i++)
-   {
-      zp[i] = xp[i] - yp[i];
-   }
-#endif
 }
 
 void subtract(const double a, const Vector &x, const Vector &y, Vector &z)
@@ -514,7 +456,6 @@ void subtract(const double a, const Vector &x, const Vector &y, Vector &z)
    }
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
       const int N = x.size;
       // Note: get read access first, in case z is the same as x/y.
@@ -525,17 +466,6 @@ void subtract(const double a, const Vector &x, const Vector &y, Vector &z)
       {
          zd[i] = a * (xd[i] - yd[i]);
       });
-#else
-      const double *xp = x.data;
-      const double *yp = y.data;
-      double       *zp = z.data;
-      const int      s = x.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         zp[i] = a * (xp[i] - yp[i]);
-      }
-#endif
    }
 }
 
diff --git a/makefile b/makefile
index 6f71bd0fd..0716a898f 100644
--- a/makefile
+++ b/makefile
@@ -265,23 +265,12 @@ endif
 
 DEP_CXX ?= $(MFEM_CXX)
 
-# Check legacy OpenMP configuration
-ifeq ($(MFEM_USE_LEGACY_OPENMP),YES)
-   MFEM_THREAD_SAFE ?= YES
-   ifneq ($(MFEM_THREAD_SAFE),YES)
-      $(error Incompatible config: MFEM_USE_LEGACY_OPENMP requires MFEM_THREAD_SAFE)
-   endif
-   # NOTE: MFEM_USE_LEGACY_OPENMP cannot be combined with any of:
-   # MFEM_USE_OPENMP, MFEM_USE_CUDA, MFEM_USE_RAJA, MFEM_USE_OCCA
-endif
-
 # List of MFEM dependencies, that require the *_LIB variable to be non-empty
 MFEM_REQ_LIB_DEPS = ENZYME SUPERLU MUMPS METIS FMS CONDUIT SIDRE LAPACK SUNDIALS\
  SUITESPARSE STRUMPACK GINKGO GNUTLS NETCDF PETSC SLEPC MPFR PUMI HIOP\
  GSLIB OCCA CEED RAJA UMPIRE MKL_CPARDISO MKL_PARDISO AMGX CALIPER PARELAG BENCHMARK\
  MOONOLITH ALGOIM
 
-
 PETSC_ERROR_MSG = $(if $(PETSC_FOUND),,. PETSC config not found: $(PETSC_VARS))
 SLEPC_ERROR_MSG = $(if $(SLEPC_FOUND),,. SLEPC config not found: $(SLEPC_VARS))
 
@@ -339,16 +328,16 @@ endif
 MFEM_DEFINES = MFEM_VERSION MFEM_VERSION_STRING MFEM_GIT_STRING MFEM_USE_MPI\
  MFEM_USE_METIS MFEM_USE_METIS_5 MFEM_DEBUG MFEM_USE_EXCEPTIONS MFEM_USE_ZLIB\
  MFEM_USE_LIBUNWIND MFEM_USE_LAPACK MFEM_THREAD_SAFE MFEM_USE_OPENMP\
- MFEM_USE_LEGACY_OPENMP MFEM_USE_MEMALLOC MFEM_TIMER_TYPE MFEM_USE_SUNDIALS\
- MFEM_USE_SUITESPARSE MFEM_USE_GINKGO MFEM_USE_SUPERLU MFEM_USE_SUPERLU5\
- MFEM_USE_STRUMPACK MFEM_USE_GNUTLS MFEM_USE_NETCDF MFEM_USE_PETSC\
- MFEM_USE_SLEPC MFEM_USE_MPFR MFEM_USE_SIDRE MFEM_USE_FMS MFEM_USE_CONDUIT\
- MFEM_USE_PUMI MFEM_USE_HIOP MFEM_USE_GSLIB MFEM_USE_CUDA MFEM_USE_HIP\
- MFEM_USE_OCCA MFEM_USE_MOONOLITH MFEM_USE_CEED MFEM_USE_RAJA MFEM_USE_UMPIRE\
- MFEM_USE_SIMD MFEM_USE_ADIOS2 MFEM_USE_MKL_CPARDISO MFEM_USE_MKL_PARDISO MFEM_USE_AMGX\
- MFEM_USE_MUMPS MFEM_USE_ADFORWARD MFEM_USE_CODIPACK MFEM_USE_CALIPER\
- MFEM_USE_BENCHMARK MFEM_USE_PARELAG MFEM_USE_ALGOIM MFEM_USE_ENZYME\
- MFEM_SOURCE_DIR MFEM_INSTALL_DIR MFEM_SHARED_BUILD
+ MFEM_USE_MEMALLOC MFEM_TIMER_TYPE MFEM_USE_SUNDIALS MFEM_USE_SUITESPARSE\
+ MFEM_USE_GINKGO MFEM_USE_SUPERLU MFEM_USE_SUPERLU5 MFEM_USE_STRUMPACK\
+ MFEM_USE_GNUTLS MFEM_USE_NETCDF MFEM_USE_PETSC MFEM_USE_SLEPC MFEM_USE_MPFR\
+ MFEM_USE_SIDRE MFEM_USE_FMS MFEM_USE_CONDUIT MFEM_USE_PUMI MFEM_USE_HIOP\
+ MFEM_USE_GSLIB MFEM_USE_CUDA MFEM_USE_HIP MFEM_USE_OCCA MFEM_USE_MOONOLITH\
+ MFEM_USE_CEED MFEM_USE_RAJA MFEM_USE_UMPIRE MFEM_USE_SIMD MFEM_USE_ADIOS2\
+ MFEM_USE_MKL_CPARDISO MFEM_USE_MKL_PARDISO MFEM_USE_AMGX MFEM_USE_MUMPS\
+ MFEM_USE_ADFORWARD MFEM_USE_CODIPACK MFEM_USE_CALIPER MFEM_USE_BENCHMARK\
+ MFEM_USE_PARELAG MFEM_USE_ALGOIM MFEM_USE_ENZYME MFEM_SOURCE_DIR\
+ MFEM_INSTALL_DIR MFEM_SHARED_BUILD
 
 # List of makefile variables that will be written to config.mk:
 MFEM_CONFIG_VARS = MFEM_CXX MFEM_HOST_CXX MFEM_CPPFLAGS MFEM_CXXFLAGS\
@@ -419,7 +408,12 @@ endif
 DIRS = general linalg linalg/simd mesh mesh/submesh fem fem/ceed/interface \
        fem/ceed/integrators/mass fem/ceed/integrators/convection \
        fem/ceed/integrators/diffusion fem/ceed/integrators/nlconvection \
-       fem/ceed/solvers fem/fe fem/lor fem/qinterp fem/integ fem/tmop
+       fem/ceed/integrators/vecfemass fem/ceed/integrators/divdiv \
+       fem/ceed/integrators/curlcurl fem/ceed/integrators/diffusionmass \
+       fem/ceed/integrators/divdivmass fem/ceed/integrators/curlcurlmass \
+       fem/ceed/integrators/mixedvecgrad fem/ceed/integrators/mixedveccurl \
+       fem/ceed/integrators/interp fem/ceed/integrators/util fem/ceed/solvers \
+       fem/fe fem/lor fem/qinterp fem/integ fem/tmop
 
 ifeq ($(MFEM_USE_MOONOLITH),YES)
    MFEM_CXXFLAGS += $(MOONOLITH_CXX_FLAGS)
@@ -433,7 +427,7 @@ RELSRC_FILES = $(patsubst $(SRC)%,%,$(SOURCE_FILES))
 OBJECT_FILES = $(patsubst $(SRC)%,$(BLD)%,$(SOURCE_FILES:.cpp=.o))
 OKL_DIRS = fem
 
-.PHONY: lib all clean distclean install config status info deps serial parallel	\
+.PHONY: lib all clean distclean install config status info deps serial parallel \
 	debug pdebug cuda hip pcuda cudebug pcudebug hpc style check test unittest \
 	deprecation-warnings
 
@@ -613,6 +607,20 @@ install: $(if $(static),$(BLD)libmfem.a) $(if $(shared),$(BLD)libmfem.$(SO_EXT))
 	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/diffusion/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/diffusion
 	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/nlconvection
 	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/nlconvection/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/nlconvection
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/vecfemass
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/vecfemass/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/vecfemass
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/divdiv
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/divdiv/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/divdiv
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/curlcurl
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/curlcurl/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/curlcurl
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/diffusionmass
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/diffusionmass/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/diffusionmass
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/divdivmass
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/divdivmass/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/divdivmass
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/curlcurlmass
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/curlcurlmass/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/curlcurlmass
+	mkdir -p $(PREFIX_INC)/mfem/fem/ceed/integrators/util
+	$(INSTALL) -m 640 $(SRC)fem/ceed/integrators/util/*.h $(PREFIX_INC)/mfem/fem/ceed/integrators/util
 # install config.mk in $(PREFIX_SHARE)
 	mkdir -p $(PREFIX_SHARE)
 	$(MAKE) -C $(BLD)config config-mk CONFIG_MK=config-install.mk
@@ -672,7 +680,6 @@ status info:
 	$(info MFEM_USE_LAPACK        = $(MFEM_USE_LAPACK))
 	$(info MFEM_THREAD_SAFE       = $(MFEM_THREAD_SAFE))
 	$(info MFEM_USE_OPENMP        = $(MFEM_USE_OPENMP))
-	$(info MFEM_USE_LEGACY_OPENMP = $(MFEM_USE_LEGACY_OPENMP))
 	$(info MFEM_USE_MEMALLOC      = $(MFEM_USE_MEMALLOC))
 	$(info MFEM_TIMER_TYPE        = $(MFEM_TIMER_TYPE))
 	$(info MFEM_USE_SUNDIALS      = $(MFEM_USE_SUNDIALS))
@@ -738,17 +745,16 @@ status info:
 ASTYLE_BIN = astyle
 ASTYLE = $(ASTYLE_BIN) --options=$(SRC)config/mfem.astylerc
 ASTYLE_VER = "Artistic Style Version 3.1"
-FORMAT_FILES = $(foreach dir,$(DIRS) $(EM_DIRS) config,$(dir)/*.?pp)
-FORMAT_FILES += tests/unit/*.?pp
-UNIT_TESTS_SUBDIRS = general linalg mesh fem miniapps ceed
-MINIAPPS_SUBDIRS = dpg/util hooke/operators hooke/preconditioners hooke/materials hooke/kernels
-FORMAT_FILES += $(foreach dir,$(UNIT_TESTS_SUBDIRS),tests/unit/$(dir)/*.?pp)
-FORMAT_FILES += $(foreach dir,$(MINIAPPS_SUBDIRS),miniapps/$(dir)/*.?pp)
-FORMAT_EXCLUDE = general/tinyxml2.cpp tests/unit/catch.hpp
+FORMAT_FILES = $(foreach dir,$(DIRS) $(EM_DIRS) config,$(dir)/*.[ch]pp $(dir)/*.[ch])
+FORMAT_FILES += tests/unit/*.[ch]pp
+FORMAT_FILES += $(foreach dir,$(wildcard tests/unit/*),$(dir)/*.[ch]pp $(dir)/*.[ch])
+FORMAT_FILES += $(foreach dir,$(wildcard miniapps/*/*),$(dir)/*.[ch]pp $(dir)/*.[ch])
+FORMAT_EXCLUDE = general/tinyxml2.cpp tests/unit/catch.hpp fem/picojson.h general/tinyxml2.h
 FORMAT_LIST = $(filter-out $(FORMAT_EXCLUDE),$(wildcard $(FORMAT_FILES)))
 
-COUT_CERR_FILES = $(foreach dir,$(DIRS),$(dir)/*.[ch]pp)
-COUT_CERR_EXCLUDE = '^general/error\.cpp' '^general/globals\.[ch]pp'
+COUT_CERR_FILES = $(foreach dir,$(DIRS),$(dir)/*.[ch]pp $(dir)/*.[ch])
+COUT_CERR_EXCLUDE = general/error.cpp general/globals.cpp general/globals.hpp
+COUT_CERR_LIST = $(filter-out $(COUT_CERR_EXCLUDE),$(wildcard $(COUT_CERR_FILES)))
 
 DEPRECATION_WARNING := \
 "This feature is planned for removal in the next release."\
@@ -757,10 +763,6 @@ deprecation-warnings:
 	@if [ -t 1 ]; then\
 	   red="\033[0;31m"; yellow="\033[0;33m"; end="\033[0m";\
 	 fi;\
-	if [ $(MFEM_USE_LEGACY_OPENMP) = YES ]; then\
-	  printf $$red"[MFEM_USE_LEGACY_OPENMP]"$$end": "$$yellow"%s"$$end"\n"\
-	  $(DEPRECATION_WARNING);\
-	fi
 
 # $(call mfem_check_command, command-to-execute, success_msg, failed_msg)
 mfem_check_command = \
@@ -788,12 +790,12 @@ style:
 	    "Please make sure the changes are committed");\
 	echo "Checking for use of std::cout...";\
 	$(call mfem_check_command,\
-	   grep cout $(COUT_CERR_FILES) | grep -v $(COUT_CERR_EXCLUDE:%=-e %),\
+	   grep cout $(COUT_CERR_LIST),\
 	   "No use of std::cout found", "Use mfem::out instead of std::cout");\
 	echo "Checking for use of std::cerr...";\
 	$(call mfem_check_command,\
-	   grep cerr $(COUT_CERR_FILES) |\
-	      grep -v $(COUT_CERR_EXCLUDE:%=-e %) -e cerrno,\
+	   grep cerr $(COUT_CERR_LIST) |\
+	      grep -v -e cerrno,\
 	   "No use of std::cerr found", "Use mfem::err instead of std::cerr");\
 	exit $$err_code
 
diff --git a/mesh/mesh.cpp b/mesh/mesh.cpp
index 01772ce19..3279df161 100644
--- a/mesh/mesh.cpp
+++ b/mesh/mesh.cpp
@@ -384,6 +384,12 @@ void Mesh::GetElementTransformation(int i, IsoparametricTransformation *ElTr)
    }
 }
 
+ElementTransformation *Mesh::GetElementTransformation(int i)
+{
+   GetElementTransformation(i, &Transformation);
+   return &Transformation;
+}
+
 void Mesh::GetElementTransformation(int i, const Vector &nodes,
                                     IsoparametricTransformation *ElTr)
 {
@@ -428,19 +434,6 @@ void Mesh::GetElementTransformation(int i, const Vector &nodes,
    }
 }
 
-ElementTransformation *Mesh::GetElementTransformation(int i)
-{
-   GetElementTransformation(i, &Transformation);
-
-   return &Transformation;
-}
-
-ElementTransformation *Mesh::GetBdrElementTransformation(int i)
-{
-   GetBdrElementTransformation(i, &BdrTransformation);
-   return &BdrTransformation;
-}
-
 void Mesh::GetBdrElementTransformation(int i, IsoparametricTransformation* ElTr)
 {
    ElTr->Attribute = GetBdrAttribute(i);
@@ -501,6 +494,12 @@ void Mesh::GetBdrElementTransformation(int i, IsoparametricTransformation* ElTr)
    }
 }
 
+ElementTransformation *Mesh::GetBdrElementTransformation(int i)
+{
+   GetBdrElementTransformation(i, &BdrTransformation);
+   return &BdrTransformation;
+}
+
 void Mesh::GetFaceTransformation(int FaceNo, IsoparametricTransformation *FTr)
 {
    FTr->Attribute = (Dim == 1) ? 1 : faces[FaceNo]->GetAttribute();
@@ -4434,9 +4433,7 @@ void Mesh::MakeRefined_(Mesh &orig_mesh, const Array<int> ref_factors,
 
    Array<int> rdofs;
    DenseMatrix phys_pts;
-
-   GeometryRefiner refiner;
-   refiner.SetType(q_type);
+   GeometryRefiner refiner(q_type);
 
    // Add refined elements and set vertex coordinates
    for (int el = 0; el < orig_ne; el++)
diff --git a/miniapps/hdiv-linear-solver/hdiv_linear_solver.cpp b/miniapps/hdiv-linear-solver/hdiv_linear_solver.cpp
index 8951d1023..dad856887 100644
--- a/miniapps/hdiv-linear-solver/hdiv_linear_solver.cpp
+++ b/miniapps/hdiv-linear-solver/hdiv_linear_solver.cpp
@@ -59,7 +59,8 @@ const IntegrationRule &GetMassIntRule(FiniteElementSpace &fes_l2)
 {
    Mesh *mesh = fes_l2.GetMesh();
    const FiniteElement *fe = fes_l2.GetFE(0);
-   return MassIntegrator::GetRule(*fe, *fe, *mesh->GetElementTransformation(0));
+   return MassIntegrator::GetRuleStatic(*fe, *fe,
+                                        *mesh->GetElementTransformation(0));
 }
 
 HdivSaddlePointSolver::HdivSaddlePointSolver(
diff --git a/miniapps/performance/ex1.cpp b/miniapps/performance/ex1.cpp
index e2271585c..916e7022e 100644
--- a/miniapps/performance/ex1.cpp
+++ b/miniapps/performance/ex1.cpp
@@ -317,8 +317,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ref_levels, int order, int basis,
    cout << "Assembling the bilinear form ..." << flush;
    tic_toc.Clear();
    tic_toc.Start();
-   // Pre-allocate sparsity assuming dense element matrices
-   a->UsePrecomputedSparsity();
 
    HPCBilinearForm *a_hpc = NULL;
    Operator *a_oper = NULL;
@@ -373,7 +371,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ref_levels, int order, int basis,
    {
       // TODO: assemble the LOR matrix using the performance code
       a_pc->AddDomainIntegrator(new DiffusionIntegrator(one));
-      a_pc->UsePrecomputedSparsity();
       a_pc->Assemble();
       a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
    }
@@ -385,7 +382,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ref_levels, int order, int basis,
       }
       else
       {
-         a_pc->UsePrecomputedSparsity();
          a_hpc->AssembleBilinearForm(*a_pc);
          a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
       }
diff --git a/miniapps/performance/ex1p.cpp b/miniapps/performance/ex1p.cpp
index 79735c7ff..1e80576bb 100644
--- a/miniapps/performance/ex1p.cpp
+++ b/miniapps/performance/ex1p.cpp
@@ -390,8 +390,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ser_ref_levels, int par_ref_levels,
    }
    tic_toc.Clear();
    tic_toc.Start();
-   // Pre-allocate sparsity assuming dense element matrices
-   a->UsePrecomputedSparsity();
 
    HPCBilinearForm *a_hpc = NULL;
    Operator *a_oper = NULL;
@@ -460,7 +458,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ser_ref_levels, int par_ref_levels,
    {
       // TODO: assemble the LOR matrix using the performance code
       a_pc->AddDomainIntegrator(new DiffusionIntegrator(one));
-      a_pc->UsePrecomputedSparsity();
       a_pc->Assemble();
       a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
    }
@@ -472,7 +469,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ser_ref_levels, int par_ref_levels,
       }
       else
       {
-         a_pc->UsePrecomputedSparsity();
          a_hpc->AssembleBilinearForm(*a_pc);
          a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
       }
diff --git a/miniapps/shifted/sbm_solver.hpp b/miniapps/shifted/sbm_solver.hpp
index db16738d5..b8830bf31 100644
--- a/miniapps/shifted/sbm_solver.hpp
+++ b/miniapps/shifted/sbm_solver.hpp
@@ -121,7 +121,6 @@ public:
         par_shared_face_count(0),
         cut_marker(cut_marker_) { }
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
@@ -241,7 +240,6 @@ public:
         par_shared_face_count(0),
         cut_marker(cut_marker_) { }
 
-   using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
                                    FaceElementTransformations &Trans,
diff --git a/tests/unit/ceed/test_ceed.cpp b/tests/unit/ceed/test_ceed.cpp
index 971b68e24..9176157a8 100644
--- a/tests/unit/ceed/test_ceed.cpp
+++ b/tests/unit/ceed/test_ceed.cpp
@@ -21,7 +21,15 @@ namespace ceed_test
 
 #ifdef MFEM_USE_CEED
 
-enum class CeedCoeffType { Const, Grid, Quad, VecConst, VecGrid, VecQuad };
+enum class CeedCoeffType { Const,
+                           Grid,
+                           Quad,
+                           VecConst,
+                           VecGrid,
+                           VecQuad,
+                           MatConst,
+                           MatQuad
+                         };
 
 double coeff_function(const Vector &x)
 {
@@ -41,11 +49,24 @@ void velocity_function(const Vector &x, Vector &v)
    }
 }
 
+// Matrix-valued velocity coefficient
+void matrix_velocity_function(const Vector &x, DenseMatrix &m)
+{
+   int dim = x.Size();
+   Vector v(dim);
+   velocity_function(x, v);
+   m.SetSize(dim);
+   m = 0.5;
+   for (int i = 0; i < dim; i++)
+   {
+      m(i, i) = 1.0 + v(i);
+   }
+}
+
 // Vector valued quantity to convect
 void quantity(const Vector &x, Vector &u)
 {
    int dim = x.Size();
-
    switch (dim)
    {
       case 1: u(0) = x[0]*x[0]; break;
@@ -59,7 +80,6 @@ void quantity(const Vector &x, Vector &u)
 void convected_quantity(const Vector &x, Vector &u)
 {
    double a, b, c;
-
    int dim = x.Size();
    switch (dim)
    {
@@ -82,7 +102,7 @@ void convected_quantity(const Vector &x, Vector &u)
    }
 }
 
-std::string getString(AssemblyLevel assembly)
+std::string GetString(AssemblyLevel assembly)
 {
    switch (assembly)
    {
@@ -106,7 +126,7 @@ std::string getString(AssemblyLevel assembly)
    return "";
 }
 
-std::string getString(CeedCoeffType coeff_type)
+std::string GetString(CeedCoeffType coeff_type)
 {
    switch (coeff_type)
    {
@@ -128,6 +148,12 @@ std::string getString(CeedCoeffType coeff_type)
       case CeedCoeffType::VecQuad:
          return "VecQuad";
          break;
+      case CeedCoeffType::MatConst:
+         return "MatConst";
+         break;
+      case CeedCoeffType::MatQuad:
+         return "MatQuad";
+         break;
    }
    MFEM_ABORT("Unknown CeedCoeffType.");
    return "";
@@ -138,10 +164,18 @@ enum class Problem { Mass,
                      Diffusion,
                      VectorMass,
                      VectorDiffusion,
-                     MassDiffusion
+                     HDivMass,
+                     HCurlMass,
+                     DivDiv,
+                     CurlCurl,
+                     MassDiffusion,
+                     HDivMassDivDiv,
+                     HCurlMassCurlCurl,
+                     MixedVectorGradient,
+                     MixedVectorCurl
                    };
 
-std::string getString(Problem pb)
+std::string GetString(Problem pb)
 {
    switch (pb)
    {
@@ -160,9 +194,33 @@ std::string getString(Problem pb)
       case Problem::VectorDiffusion:
          return "VectorDiffusion";
          break;
+      case Problem::HDivMass:
+         return "HDivMass";
+         break;
+      case Problem::HCurlMass:
+         return "HCurlMass";
+         break;
+      case Problem::DivDiv:
+         return "DivDiv";
+         break;
+      case Problem::CurlCurl:
+         return "CurlCurl";
+         break;
       case Problem::MassDiffusion:
          return "MassDiffusion";
          break;
+      case Problem::HDivMassDivDiv:
+         return "HDivMassDivDiv";
+         break;
+      case Problem::HCurlMassCurlCurl:
+         return "HCurlMassCurlCurl";
+         break;
+      case Problem::MixedVectorGradient:
+         return "MixedVectorGradient";
+         break;
+      case Problem::MixedVectorCurl:
+         return "MixedVectorCurl";
+         break;
    }
    MFEM_ABORT("Unknown Problem.");
    return "";
@@ -170,7 +228,7 @@ std::string getString(Problem pb)
 
 enum class NLProblem {Convection};
 
-std::string getString(NLProblem pb)
+std::string GetString(NLProblem pb)
 {
    switch (pb)
    {
@@ -178,14 +236,15 @@ std::string getString(NLProblem pb)
          return "Convection";
          break;
    }
-   MFEM_ABORT("Unknown Problem.");
+   MFEM_ABORT("Unknown NLProblem.");
    return "";
 }
 
 void InitCoeff(Mesh &mesh, FiniteElementCollection &fec, const int dim,
                const CeedCoeffType coeff_type, GridFunction *&gf,
-               FiniteElementSpace *& coeff_fes,
-               Coefficient *&coeff, VectorCoefficient *&vcoeff)
+               FiniteElementSpace *&coeff_fes,
+               Coefficient *&coeff, VectorCoefficient *&vcoeff,
+               MatrixCoefficient *&mcoeff)
 {
    switch (coeff_type)
    {
@@ -209,7 +268,7 @@ void InitCoeff(Mesh &mesh, FiniteElementCollection &fec, const int dim,
          Vector val(dim);
          for (int i = 0; i < dim; i++)
          {
-            val(i) = 1.0;
+            val(i) = 1.0 + i;
          }
          vcoeff = new VectorConstantCoefficient(val);
          break;
@@ -226,21 +285,90 @@ void InitCoeff(Mesh &mesh, FiniteElementCollection &fec, const int dim,
       case CeedCoeffType::VecQuad:
          vcoeff = new VectorFunctionCoefficient(dim, velocity_function);
          break;
+      case CeedCoeffType::MatConst:
+      {
+         DenseMatrix val(dim);
+         val = 0.5;
+         for (int i = 0; i < dim; i++)
+         {
+            val(i, i) = 1.0 + i;
+         }
+         mcoeff = new MatrixConstantCoefficient(val);
+         break;
+      }
+      case CeedCoeffType::MatQuad:
+         mcoeff = new MatrixFunctionCoefficient(dim, matrix_velocity_function);
+         break;
    }
 }
 
-void test_ceed_operator(const char* input, int order,
+class DiffusionIntegrator2 : public DiffusionIntegrator
+{
+public:
+   DiffusionIntegrator2(Coefficient &q, const IntegrationRule *ir = nullptr)
+      : DiffusionIntegrator(q, ir) {}
+
+   DiffusionIntegrator2(VectorCoefficient &q,
+                        const IntegrationRule *ir = nullptr)
+      : DiffusionIntegrator(q, ir) {}
+
+   DiffusionIntegrator2(MatrixCoefficient &q,
+                        const IntegrationRule *ir = nullptr)
+      : DiffusionIntegrator(q, ir) {}
+
+   const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                  const FiniteElement &test_fe,
+                                  ElementTransformation &Trans) const override
+   { return MassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
+};
+
+class DivDivIntegrator2 : public DivDivIntegrator
+{
+public:
+   DivDivIntegrator2(Coefficient &q, const IntegrationRule *ir = nullptr)
+      : DivDivIntegrator(q, ir) {}
+
+   const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                  const FiniteElement &test_fe,
+                                  ElementTransformation &Trans) const override
+   { return VectorFEMassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
+};
+
+class CurlCurlIntegrator2 : public CurlCurlIntegrator
+{
+public:
+   CurlCurlIntegrator2(Coefficient &q, const IntegrationRule *ir = nullptr)
+      : CurlCurlIntegrator(q, ir) {}
+
+   CurlCurlIntegrator2(VectorCoefficient &q,
+                       const IntegrationRule *ir = nullptr)
+      : CurlCurlIntegrator(q, ir) {}
+
+   CurlCurlIntegrator2(MatrixCoefficient &q,
+                       const IntegrationRule *ir = nullptr)
+      : CurlCurlIntegrator(q, ir) {}
+
+   const IntegrationRule &GetRule(const FiniteElement &trial_fe,
+                                  const FiniteElement &test_fe,
+                                  ElementTransformation &Trans) const override
+   { return VectorFEMassIntegrator::GetRuleStatic(trial_fe, test_fe, Trans); }
+};
+
+void test_ceed_operator(const char *input, int order,
                         const CeedCoeffType coeff_type, const Problem pb,
-                        const AssemblyLevel assembly)
+                        const AssemblyLevel assembly, bool mixed_p, bool bdr_integ)
 {
-   std::string section = "assembly: " + getString(assembly) + "\n" +
-                         "coeff_type: " + getString(coeff_type) + "\n" +
-                         "pb: " + getString(pb) + "\n" +
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "coeff_type: " + GetString(coeff_type) + "\n" +
+                         "pb: " + GetString(pb) + "\n" +
                          "order: " + std::to_string(order) + "\n" +
+                         (mixed_p ? "mixed_p: true\n" : "") +
+                         (bdr_integ ? "bdr_integ: true\n" : "") +
                          "mesh: " + input;
    INFO(section);
    Mesh mesh(input, 1, 1);
    mesh.EnsureNodes();
+   if (mixed_p) { mesh.EnsureNCMesh(); }
    int dim = mesh.Dimension();
    H1_FECollection fec(order, dim);
 
@@ -249,43 +377,59 @@ void test_ceed_operator(const char* input, int order,
    FiniteElementSpace *coeff_fes = nullptr;
    Coefficient *coeff = nullptr;
    VectorCoefficient *vcoeff = nullptr;
-   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff);
+   MatrixCoefficient *mcoeff = nullptr;
+   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff, mcoeff);
+   MFEM_VERIFY(!mcoeff,
+               "Unexpected matrix-valued coefficient in test_ceed_operator.");
 
    // Build the BilinearForm
    bool vecOp = pb == Problem::VectorMass || pb == Problem::VectorDiffusion;
    const int vdim = vecOp ? dim : 1;
    FiniteElementSpace fes(&mesh, &fec, vdim);
+   if (mixed_p)
+   {
+      fes.SetElementOrder(0, order+1);
+      fes.SetElementOrder(fes.GetNE() - 1, order+1);
+      fes.Update(false);
+   }
 
-   BilinearForm k_test(&fes);
    BilinearForm k_ref(&fes);
+   BilinearForm k_test(&fes);
+   auto AddIntegrator = [&bdr_integ](BilinearForm &k, BilinearFormIntegrator *blfi)
+   {
+      if (bdr_integ)
+      {
+         k.AddBoundaryIntegrator(blfi);
+      }
+      else
+      {
+         k.AddDomainIntegrator(blfi);
+      }
+   };
    switch (pb)
    {
       case Problem::Mass:
-         k_ref.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new MassIntegrator(*coeff));
+         AddIntegrator(k_ref, new MassIntegrator(*coeff));
+         AddIntegrator(k_test, new MassIntegrator(*coeff));
          break;
       case Problem::Convection:
-         k_ref.AddDomainIntegrator(new ConvectionIntegrator(*vcoeff,-1));
-         k_test.AddDomainIntegrator(new ConvectionIntegrator(*vcoeff,-1));
+         AddIntegrator(k_ref, new ConvectionIntegrator(*vcoeff, -1));
+         AddIntegrator(k_test, new ConvectionIntegrator(*vcoeff, -1));
          break;
       case Problem::Diffusion:
-         k_ref.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
+         AddIntegrator(k_ref, new DiffusionIntegrator(*coeff));
+         AddIntegrator(k_test, new DiffusionIntegrator(*coeff));
          break;
       case Problem::VectorMass:
-         k_ref.AddDomainIntegrator(new VectorMassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new VectorMassIntegrator(*coeff));
+         AddIntegrator(k_ref, new VectorMassIntegrator(*coeff));
+         AddIntegrator(k_test, new VectorMassIntegrator(*coeff));
          break;
       case Problem::VectorDiffusion:
-         k_ref.AddDomainIntegrator(new VectorDiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new VectorDiffusionIntegrator(*coeff));
-         break;
-      case Problem::MassDiffusion:
-         k_ref.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_ref.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
+         AddIntegrator(k_ref, new VectorDiffusionIntegrator(*coeff));
+         AddIntegrator(k_test, new VectorDiffusionIntegrator(*coeff));
          break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
    }
 
    k_ref.Assemble();
@@ -294,121 +438,618 @@ void test_ceed_operator(const char* input, int order,
    k_test.SetAssemblyLevel(assembly);
    k_test.Assemble();
 
-   // Compare ceed with mfem.
+   // Compare ceed with mfem
    GridFunction x(&fes), y_ref(&fes), y_test(&fes);
+   Vector d_ref(fes.GetTrueVSize()), d_test(fes.GetTrueVSize());
 
    x.Randomize(1);
 
-   k_ref.Mult(x,y_ref);
-   k_test.Mult(x,y_test);
+   k_ref.Mult(x, y_ref);
+   k_test.Mult(x, y_test);
 
    y_test -= y_ref;
 
-   REQUIRE(y_test.Norml2() < 1.e-12);
+   REQUIRE(y_test.Norml2() < 1.e-12 * std::max(y_ref.Norml2(), 1.0));
+
+   if (mesh.Nonconforming())
+   {
+      k_ref.ConformingAssemble();
+   }
+   k_ref.AssembleDiagonal(d_ref);
+   k_test.AssembleDiagonal(d_test);
+
+   d_test -= d_ref;
+
+   // // TODO: Debug
+   // if (mesh.Nonconforming() &&
+   //    d_test.Norml2() > 0.1 * d_ref.Norml2())
+   // {
+   //    out << "\nDIAGONAL ASSEMBLY DELTA\n\n";
+   //    d_test.Print();
+   //    out << "\nDIAGONAL ASSEMBLY REF\n\n";
+   //    d_ref.Print();
+   //    // Vector temp(d_test);
+   //    // temp += d_ref;
+   //    // out << "\nDIAGONAL ASSEMBLY TEST\n\n";
+   //    // temp.Print();
+   // }
+
+   REQUIRE(d_test.Norml2() <
+           (mesh.Nonconforming() ? 1.0 : 1.e-12) * std::max(d_ref.Norml2(), 1.0));
    delete gf;
    delete coeff_fes;
    delete coeff;
    delete vcoeff;
+   delete mcoeff;
 }
 
-void test_mixed_p_ceed_operator(const char* input, int order,
-                                const CeedCoeffType coeff_type, const Problem pb,
-                                const AssemblyLevel assembly)
+void test_ceed_vectorfe_operator(const char *input, int order,
+                                 const CeedCoeffType coeff_type, const Problem pb,
+                                 const AssemblyLevel assembly, bool bdr_integ)
 {
-   std::string section = "assembly: " + getString(assembly) + "\n" +
-                         "coeff_type: " + getString(coeff_type) + "\n" +
-                         "pb: " + getString(pb) + "\n" +
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "coeff_type: " + GetString(coeff_type) + "\n" +
+                         "pb: " + GetString(pb) + "\n" +
                          "order: " + std::to_string(order) + "\n" +
+                         (bdr_integ ? "bdr_integ: true\n" : "") +
                          "mesh: " + input;
    INFO(section);
    Mesh mesh(input, 1, 1);
    mesh.EnsureNodes();
-   mesh.EnsureNCMesh();
    int dim = mesh.Dimension();
-   MFEM_VERIFY(dim == 2, "p-adaptivity only supported in serial 2D.");
-   H1_FECollection fec(order, dim);
+   FiniteElementCollection *fec = nullptr;
+   if ((pb == Problem::HDivMass || pb == Problem::DivDiv ||
+        pb == Problem::HDivMassDivDiv) && bdr_integ)
+   {
+      // Boundary RT elements in 2D and 3D are actually L2
+      return;
+   }
+   if ((pb == Problem::CurlCurl || pb == Problem::HCurlMassCurlCurl) &&
+       dim - bdr_integ < 2)
+   {
+      // No 1D ND curl shape
+      return;
+   }
+   if (assembly == AssemblyLevel::NONE && (pb == Problem::MassDiffusion ||
+                                           pb == Problem::HDivMassDivDiv ||
+                                           pb == Problem::HCurlMassCurlCurl))
+   {
+      // No MF assembly for these integrators.
+      return;
+   }
+   switch (pb)
+   {
+      case Problem::Mass:
+      case Problem::Diffusion:
+      case Problem::MassDiffusion:
+         fec = new H1_FECollection(order, dim);
+         break;
+      case Problem::HDivMass:
+      case Problem::DivDiv:
+      case Problem::HDivMassDivDiv:
+         fec = new RT_FECollection(order-1, dim);
+         break;
+      case Problem::HCurlMass:
+      case Problem::CurlCurl:
+      case Problem::HCurlMassCurlCurl:
+         fec = new ND_FECollection(order, dim);
+         break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
+   }
 
    // Coefficient Initialization
    GridFunction *gf = nullptr;
    FiniteElementSpace *coeff_fes = nullptr;
    Coefficient *coeff = nullptr;
    VectorCoefficient *vcoeff = nullptr;
-   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff);
+   MatrixCoefficient *mcoeff = nullptr;
+   InitCoeff(mesh, *fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff, mcoeff);
+   if (!coeff && (pb == Problem::Mass || pb == Problem::DivDiv ||
+                  (pb == Problem::CurlCurl && dim - bdr_integ < 3)))
+   {
+      delete gf;
+      delete coeff_fes;
+      delete coeff;
+      delete vcoeff;
+      delete mcoeff;
+      delete fec;
+      return;
+   }
+   if (!coeff && (pb == Problem::MassDiffusion || pb == Problem::HDivMassDivDiv ||
+                  (pb == Problem::HCurlMassCurlCurl && dim - bdr_integ < 3)))
+   {
+      coeff = new ConstantCoefficient(1.0);
+   }
 
    // Build the BilinearForm
-   bool vecOp = pb == Problem::VectorMass || pb == Problem::VectorDiffusion;
-   const int vdim = vecOp ? dim : 1;
-   FiniteElementSpace fes(&mesh, &fec, vdim);
-   fes.SetElementOrder(0, order+1);
-   fes.SetElementOrder(fes.GetNE() - 1, order+1);
-   fes.Update(false);
+   FiniteElementSpace fes(&mesh, fec);
 
-   BilinearForm k_test(&fes);
    BilinearForm k_ref(&fes);
+   BilinearForm k_test(&fes);
+   auto AddIntegrator = [&bdr_integ](BilinearForm &k, BilinearFormIntegrator *blfi)
+   {
+      if (bdr_integ)
+      {
+         k.AddBoundaryIntegrator(blfi);
+      }
+      else
+      {
+         k.AddDomainIntegrator(blfi);
+      }
+   };
    switch (pb)
    {
       case Problem::Mass:
-         k_ref.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new MassIntegrator(*coeff));
-         break;
-      case Problem::Convection:
-         k_ref.AddDomainIntegrator(new ConvectionIntegrator(*vcoeff,-1));
-         k_test.AddDomainIntegrator(new ConvectionIntegrator(*vcoeff,-1));
+         AddIntegrator(k_ref, new MassIntegrator(*coeff));
+         AddIntegrator(k_test, new MassIntegrator(*coeff));
          break;
       case Problem::Diffusion:
-         k_ref.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
+         if (mcoeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator(*mcoeff));
+            AddIntegrator(k_test, new DiffusionIntegrator(*mcoeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator(*vcoeff));
+            AddIntegrator(k_test, new DiffusionIntegrator(*vcoeff));
+         }
+         else if (coeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator(*coeff));
+            AddIntegrator(k_test, new DiffusionIntegrator(*coeff));
+         }
          break;
-      case Problem::VectorMass:
-         k_ref.AddDomainIntegrator(new VectorMassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new VectorMassIntegrator(*coeff));
+      case Problem::MassDiffusion:
+         if (mcoeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator2(*mcoeff));
+            AddIntegrator(k_ref, new MassIntegrator(*coeff));
+            AddIntegrator(k_test, new DiffusionMassIntegrator(*mcoeff, *coeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator2(*vcoeff));
+            AddIntegrator(k_ref, new MassIntegrator(*coeff));
+            AddIntegrator(k_test, new DiffusionMassIntegrator(*vcoeff, *coeff));
+         }
+         else if (coeff)
+         {
+            AddIntegrator(k_ref, new DiffusionIntegrator2(*coeff));
+            AddIntegrator(k_ref, new MassIntegrator(*coeff));
+            AddIntegrator(k_test, new DiffusionMassIntegrator(*coeff, *coeff));
+         }
          break;
-      case Problem::VectorDiffusion:
-         k_ref.AddDomainIntegrator(new VectorDiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new VectorDiffusionIntegrator(*coeff));
+      case Problem::HDivMass:
+      case Problem::HCurlMass:
+         if (mcoeff)
+         {
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*mcoeff));
+            AddIntegrator(k_test, new VectorFEMassIntegrator(*mcoeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*vcoeff));
+            AddIntegrator(k_test, new VectorFEMassIntegrator(*vcoeff));
+         }
+         else if (coeff)
+         {
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*coeff));
+            AddIntegrator(k_test, new VectorFEMassIntegrator(*coeff));
+         }
          break;
-      case Problem::MassDiffusion:
-         k_ref.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new MassIntegrator(*coeff));
-         k_ref.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
-         k_test.AddDomainIntegrator(new DiffusionIntegrator(*coeff));
+      case Problem::DivDiv:
+         AddIntegrator(k_ref, new DivDivIntegrator(*coeff));
+         AddIntegrator(k_test, new DivDivIntegrator(*coeff));
+         break;
+      case Problem::HDivMassDivDiv:
+         if (mcoeff)
+         {
+            AddIntegrator(k_ref, new DivDivIntegrator2(*coeff));
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*mcoeff));
+            AddIntegrator(k_test, new DivDivMassIntegrator(*coeff, *mcoeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new DivDivIntegrator2(*coeff));
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*vcoeff));
+            AddIntegrator(k_test, new DivDivMassIntegrator(*coeff, *vcoeff));
+         }
+         else if (coeff)
+         {
+            AddIntegrator(k_ref, new DivDivIntegrator2(*coeff));
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*coeff));
+            AddIntegrator(k_test, new DivDivMassIntegrator(*coeff, *coeff));
+         }
          break;
+      case Problem::CurlCurl:
+         if (mcoeff)
+         {
+            AddIntegrator(k_ref, new CurlCurlIntegrator(*mcoeff));
+            AddIntegrator(k_test, new CurlCurlIntegrator(*mcoeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new CurlCurlIntegrator(*vcoeff));
+            AddIntegrator(k_test, new CurlCurlIntegrator(*vcoeff));
+         }
+         else if (coeff)
+         {
+            AddIntegrator(k_ref, new CurlCurlIntegrator(*coeff));
+            AddIntegrator(k_test, new CurlCurlIntegrator(*coeff));
+         }
+         break;
+      case Problem::HCurlMassCurlCurl:
+         if (mcoeff)
+         {
+            if (coeff)
+            {
+               AddIntegrator(k_ref, new CurlCurlIntegrator2(*coeff));
+               AddIntegrator(k_ref, new VectorFEMassIntegrator(*mcoeff));
+               AddIntegrator(k_test, new CurlCurlMassIntegrator(*coeff, *mcoeff));
+            }
+            else
+            {
+               AddIntegrator(k_ref, new CurlCurlIntegrator2(*mcoeff));
+               AddIntegrator(k_ref, new VectorFEMassIntegrator(*mcoeff));
+               AddIntegrator(k_test, new CurlCurlMassIntegrator(*mcoeff, *mcoeff));
+            }
+         }
+         else if (vcoeff)
+         {
+            if (coeff)
+            {
+               AddIntegrator(k_ref, new CurlCurlIntegrator2(*coeff));
+               AddIntegrator(k_ref, new VectorFEMassIntegrator(*vcoeff));
+               AddIntegrator(k_test, new CurlCurlMassIntegrator(*coeff, *vcoeff));
+            }
+            else
+            {
+               AddIntegrator(k_ref, new CurlCurlIntegrator2(*vcoeff));
+               AddIntegrator(k_ref, new VectorFEMassIntegrator(*vcoeff));
+               AddIntegrator(k_test, new CurlCurlMassIntegrator(*vcoeff, *vcoeff));
+            }
+         }
+         else if (coeff)
+         {
+            AddIntegrator(k_ref, new CurlCurlIntegrator2(*coeff));
+            AddIntegrator(k_ref, new VectorFEMassIntegrator(*coeff));
+            AddIntegrator(k_test, new CurlCurlMassIntegrator(*coeff, *coeff));
+         }
+         break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
    }
 
+   // Timer for profiling
+   const int trials = 1;
+   const bool debug = false;
+   StopWatch chrono_setup_ref, chrono_setup_test;
+   StopWatch chrono_apply_ref, chrono_apply_test;
+   chrono_setup_ref.Clear();
+   chrono_setup_ref.Start();
+
    k_ref.Assemble();
    k_ref.Finalize();
 
+   chrono_setup_ref.Stop();
+   chrono_setup_test.Clear();
+   chrono_setup_test.Start();
+
    k_test.SetAssemblyLevel(assembly);
    k_test.Assemble();
 
-   // Compare ceed with mfem.
+   chrono_setup_test.Stop();
+
+   // Compare ceed with mfem
    GridFunction x(&fes), y_ref(&fes), y_test(&fes);
+   Vector d_ref(fes.GetTrueVSize()), d_test(fes.GetTrueVSize());
+
+   x.Randomize(1);
+
+   chrono_apply_ref.Clear();
+   chrono_apply_ref.Start();
+
+   for (int trial = 0; trial < trials; trial++)
+   {
+      k_ref.Mult(x, y_ref);
+   }
+
+   chrono_apply_ref.Stop();
+   chrono_apply_test.Clear();
+   chrono_apply_test.Start();
+
+   for (int trial = 0; trial < trials; trial++)
+   {
+      k_test.Mult(x, y_test);
+   }
+
+   chrono_apply_test.Stop();
+
+   y_test -= y_ref;
+
+   REQUIRE(y_test.Norml2() < 1.e-12 * std::max(y_ref.Norml2(), 1.0));
+
+   if (mesh.Nonconforming())
+   {
+      k_ref.ConformingAssemble();
+   }
+   k_ref.AssembleDiagonal(d_ref);
+   k_test.AssembleDiagonal(d_test);
+
+   d_test -= d_ref;
+
+   // // TODO: Debug
+   // if (!UsesTensorBasis(fes) && order > 1 &&
+   //     (pb == Problem::HCurlMass || pb == Problem::CurlCurl ||
+   //      pb == Problem::HCurlMassCurlCurl) &&
+   //    d_test.Norml2() > 0.1 * d_ref.Norml2())
+   // {
+   //    out << "\nH(CURL) DIAGONAL ASSEMBLY DELTA\n\n";
+   //    d_test.Print();
+   //    out << "\nH(CURL) DIAGONAL ASSEMBLY REF\n\n";
+   //    d_ref.Print();
+   //    // Vector temp(d_test);
+   //    // temp += d_ref;
+   //    // out << "\nH(CURL) DIAGONAL ASSEMBLY TEST\n\n";
+   //    // temp.Print();
+   // }
+
+   REQUIRE(d_test.Norml2() <
+           (mesh.Nonconforming() ||
+            (!UsesTensorBasis(fes) && order > 1 &&
+             (pb == Problem::HCurlMass || pb == Problem::CurlCurl ||
+              pb == Problem::HCurlMassCurlCurl)) ?
+            1.0 : 1.e-12) * std::max(d_ref.Norml2(), 1.0));
+
+   if (debug)
+   {
+      // Estimates only for non-mixed meshes
+      std::size_t mem_test = 0;
+      if (mesh.GetNumGeometries(dim) == 1)
+      {
+         // Estimate for QFunction memory
+         const FiniteElement &fe = bdr_integ ? *fes.GetBE(0) : *fes.GetFE(0);
+         ElementTransformation &T =
+            bdr_integ ? *mesh.GetBdrElementTransformation(0) :
+            *mesh.GetElementTransformation(0);
+         const int Q =
+            bdr_integ ? (*k_ref.GetBBFI())[0]->GetRule(fe, T).GetNPoints() :
+            (*k_ref.GetDBFI())[0]->GetRule(fe, T).GetNPoints();
+         const int P = fe.GetDof();
+         const int Qd = dim - bdr_integ;
+         switch (pb)
+         {
+            case Problem::Mass:
+               mem_test = Q * 1 * 8;
+               mem_test += P * 4;
+               break;
+            case Problem::Diffusion:
+               mem_test = Q * (Qd * (Qd + 1)) / 2 * 8;
+               mem_test += P * 4;
+               break;
+            case Problem::MassDiffusion:
+               mem_test = Q * ((Qd * (Qd + 1)) + 1) / 2 * 8;
+               mem_test += P * 4;
+               break;
+            case Problem::HDivMass:
+               mem_test = Q * (Qd * (Qd + 1)) / 2 * 8;
+               mem_test += P * (4 + 1);
+               break;
+            case Problem::DivDiv:
+               mem_test = Q * 1 * 8;
+               mem_test += P * (4 + 1);
+               break;
+            case Problem::HDivMassDivDiv:
+               mem_test = Q * (1 + (Qd * (Qd + 1)) / 2 * 8) * 8;
+               mem_test += P * (4 + 1);
+               break;
+            case Problem::HCurlMass:
+               mem_test = Q * (Qd * (Qd + 1)) / 2 * 8;
+               mem_test += P * (4 + 3 * 1);  // Tri-diagonal curl orientations
+               break;
+            case Problem::CurlCurl:
+               mem_test = Q * (Qd < 3 ? 1 : Qd * (Qd + 1) / 2) * 8;
+               mem_test += P * (4 + 3 * 1);
+               break;
+            case Problem::HCurlMassCurlCurl:
+               mem_test = Q * (Qd < 3 ? 1 : Qd * (Qd + 1) / 2) * 8;
+               mem_test += Q * (Qd * (Qd + 1)) / 2 * 8;
+               mem_test += P * (4 + 3 * 1);
+               break;
+            default:
+               MFEM_ABORT("Unexpected problem type.");
+         }
+         mem_test *= bdr_integ ? mesh.GetNBE() : mesh.GetNE();
+      }
+      std::size_t mem_ref = k_ref.SpMat().NumNonZeroElems() * (8 + 4) +
+                            k_ref.Height() * 4;
+
+      out << "\n" << section << "\n";
+      out << "benchmark (" << fes.GetTrueVSize() << " unknowns)\n"
+          << "    setup: ref = "
+          << chrono_setup_ref.RealTime() * 1e3 << " ms\n"
+          << "           test = "
+          << chrono_setup_test.RealTime() * 1e3 << " ms\n"
+          << "    apply: ref = "
+          << chrono_apply_ref.RealTime() * 1e3 / trials << " ms\n"
+          << "           test = "
+          << chrono_apply_test.RealTime() * 1e3 / trials << " ms\n"
+          << "    mem usage: ref = " << mem_ref / 1e6 << " MB\n"
+          << "               test = " << mem_test / 1e6 << " MB\n";
+   }
+   delete gf;
+   delete coeff_fes;
+   delete coeff;
+   delete vcoeff;
+   delete mcoeff;
+   delete fec;
+}
+
+void test_ceed_mixed_operator(const char *input, int order,
+                              const CeedCoeffType coeff_type, const Problem pb,
+                              const AssemblyLevel assembly, bool bdr_integ)
+{
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "coeff_type: " + GetString(coeff_type) + "\n" +
+                         "pb: " + GetString(pb) + "\n" +
+                         "order: " + std::to_string(order) + "\n" +
+                         (bdr_integ ? "bdr_integ: true\n" : "") +
+                         "mesh: " + input;
+   INFO(section);
+   Mesh mesh(input, 1, 1);
+   mesh.EnsureNodes();
+   int dim = mesh.Dimension();
+   FiniteElementCollection *trial_fec = nullptr, *test_fec = nullptr;
+   if (pb == Problem::MixedVectorGradient && dim - bdr_integ < 2)
+   {
+      // MixedVectorGradient is only supported in 2D or 3D
+      return;
+   }
+   if (pb == Problem::MixedVectorCurl && dim - bdr_integ < 3)
+   {
+      // MixedVectorCurl is only supported in 3D
+      return;
+   }
+   switch (pb)
+   {
+      case Problem::MixedVectorGradient:
+         trial_fec = new H1_FECollection(order, dim);
+         test_fec = new ND_FECollection(order, dim);
+         break;
+      case Problem::MixedVectorCurl:
+         trial_fec = new ND_FECollection(order, dim);
+         test_fec = new RT_FECollection(order - 1, dim);
+         break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
+   }
+
+   // Coefficient Initialization
+   GridFunction *gf = nullptr;
+   FiniteElementSpace *coeff_fes = nullptr;
+   Coefficient *coeff = nullptr;
+   VectorCoefficient *vcoeff = nullptr;
+   MatrixCoefficient *mcoeff = nullptr;
+   InitCoeff(mesh, *trial_fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff,
+             mcoeff);
+
+   // Build the BilinearForm
+   FiniteElementSpace trial_fes(&mesh, trial_fec);
+   FiniteElementSpace test_fes(&mesh, test_fec);
+
+   MixedBilinearForm k_ref(&trial_fes, &test_fes);
+   MixedBilinearForm k_test(&trial_fes, &test_fes);
+   MixedBilinearForm k_test_t(&test_fes, &trial_fes);
+   auto AddIntegrator = [&bdr_integ](MixedBilinearForm &k,
+                                     BilinearFormIntegrator *blfi)
+   {
+      if (bdr_integ)
+      {
+         k.AddBoundaryIntegrator(blfi);
+      }
+      else
+      {
+         k.AddDomainIntegrator(blfi);
+      }
+   };
+   switch (pb)
+   {
+      case Problem::MixedVectorGradient:
+         if (coeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorGradientIntegrator(*coeff));
+            AddIntegrator(k_test, new MixedVectorGradientIntegrator(*coeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakDivergenceIntegrator(*coeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorGradientIntegrator(*vcoeff));
+            AddIntegrator(k_test, new MixedVectorGradientIntegrator(*vcoeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakDivergenceIntegrator(*vcoeff));
+         }
+         else if (mcoeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorGradientIntegrator(*mcoeff));
+            AddIntegrator(k_test, new MixedVectorGradientIntegrator(*mcoeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakDivergenceIntegrator(*mcoeff));
+         }
+         break;
+      case Problem::MixedVectorCurl:
+         if (coeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorCurlIntegrator(*coeff));
+            AddIntegrator(k_test, new MixedVectorCurlIntegrator(*coeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakCurlIntegrator(*coeff));
+         }
+         else if (vcoeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorCurlIntegrator(*vcoeff));
+            AddIntegrator(k_test, new MixedVectorCurlIntegrator(*vcoeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakCurlIntegrator(*vcoeff));
+         }
+         else if (mcoeff)
+         {
+            AddIntegrator(k_ref, new MixedVectorCurlIntegrator(*mcoeff));
+            AddIntegrator(k_test, new MixedVectorCurlIntegrator(*mcoeff));
+            AddIntegrator(k_test_t, new MixedVectorWeakCurlIntegrator(*mcoeff));
+         }
+         break;
+      default:
+         MFEM_ABORT("Unexpected problem type.");
+   }
+
+   k_ref.Assemble();
+   k_ref.Finalize();
+
+   k_test.SetAssemblyLevel(assembly);
+   k_test.Assemble();
+
+   k_test_t.SetAssemblyLevel(assembly);
+   k_test_t.Assemble();
+
+   // Compare ceed with mfem
+   GridFunction x(&trial_fes), y_ref(&test_fes), y_test(&test_fes);
+   GridFunction x_t(&test_fes), y_t_ref(&trial_fes), y_t_test(&trial_fes);
 
    x.Randomize(1);
 
-   k_ref.Mult(x,y_ref);
-   k_test.Mult(x,y_test);
+   k_ref.Mult(x, y_ref);
+   k_test.Mult(x, y_test);
 
    y_test -= y_ref;
 
-   REQUIRE(y_test.Norml2() < 1.e-12);
+   REQUIRE(y_test.Norml2() < 1.e-12 * std::max(y_ref.Norml2(), 1.0));
+
+   x_t.Randomize(1);
+
+   k_ref.MultTranspose(x_t, y_t_ref);
+   k_test_t.Mult(x_t, y_t_test);
+
+   y_t_test.Add((pb == Problem::MixedVectorCurl) ? -1.0 : 1.0, y_t_ref);
+
+   REQUIRE(y_t_test.Norml2() < 1.e-12 * std::max(y_t_ref.Norml2(), 1.0));
    delete gf;
    delete coeff_fes;
    delete coeff;
    delete vcoeff;
+   delete mcoeff;
+   delete trial_fec;
+   delete test_fec;
 }
 
-void test_ceed_nloperator(const char* mesh_filename, int order,
+void test_ceed_nloperator(const char *input, int order,
                           const CeedCoeffType coeff_type,
                           const NLProblem pb, const AssemblyLevel assembly)
 {
-   std::string section = "assembly: " + getString(assembly) + "\n" +
-                         "coeff_type: " + getString(coeff_type) + "\n" +
-                         "pb: " + getString(pb) + "\n" +
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "coeff_type: " + GetString(coeff_type) + "\n" +
+                         "pb: " + GetString(pb) + "\n" +
                          "order: " + std::to_string(order) + "\n" +
-                         "mesh: " + mesh_filename;
+                         "mesh: " + input;
    INFO(section);
-   Mesh mesh(mesh_filename, 1, 1);
+   Mesh mesh(input, 1, 1);
    mesh.EnsureNodes();
    int dim = mesh.Dimension();
    H1_FECollection fec(order, dim);
@@ -418,15 +1059,18 @@ void test_ceed_nloperator(const char* mesh_filename, int order,
    FiniteElementSpace *coeff_fes = nullptr;
    Coefficient *coeff = nullptr;
    VectorCoefficient *vcoeff = nullptr;
-   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff);
+   MatrixCoefficient *mcoeff = nullptr;
+   InitCoeff(mesh, fec, dim, coeff_type, gf, coeff_fes, coeff, vcoeff, mcoeff);
+   MFEM_VERIFY(!vcoeff && !mcoeff,
+               "Unexpected vector- or matrix-valued coefficient in test_ceed_nloperator.");
 
    // Build the NonlinearForm
    bool vecOp = pb == NLProblem::Convection;
    const int vdim = vecOp ? dim : 1;
    FiniteElementSpace fes(&mesh, &fec, vdim);
 
-   NonlinearForm k_test(&fes);
    NonlinearForm k_ref(&fes);
+   NonlinearForm k_test(&fes);
    switch (pb)
    {
       case NLProblem::Convection:
@@ -435,42 +1079,48 @@ void test_ceed_nloperator(const char* mesh_filename, int order,
          break;
    }
 
+   k_ref.Setup();
    k_test.SetAssemblyLevel(assembly);
    k_test.Setup();
-   k_ref.Setup();
 
-   // Compare ceed with mfem.
+   // Compare ceed with mfem
    GridFunction x(&fes), y_ref(&fes), y_test(&fes);
 
    x.Randomize(1);
 
-   k_ref.Mult(x,y_ref);
-   k_test.Mult(x,y_test);
+   k_ref.Mult(x, y_ref);
+   k_test.Mult(x, y_test);
 
    y_test -= y_ref;
 
-   REQUIRE(y_test.Norml2() < 1.e-12);
+   REQUIRE(y_test.Norml2() < 1.e-12 * std::max(y_ref.Norml2(), 1.0));
    delete gf;
    delete coeff_fes;
    delete coeff;
    delete vcoeff;
+   delete mcoeff;
 }
 
 // This function specifically tests convection of a vector valued quantity and
 // using a custom integration rule. The integration rule is chosen s.t. in
 // combination with an appropriate order, it can represent the analytical
 // polynomial functions correctly.
-void test_ceed_convection(const char* mesh_filename, int order,
+void test_ceed_convection(const char *input, int order,
                           const AssemblyLevel assembly)
 {
-   Mesh mesh(mesh_filename, 1, 1);
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "order: " + std::to_string(order) + "\n" +
+                         "mesh: " + input;
+   INFO(section);
+   Mesh mesh(input, 1, 1);
    mesh.EnsureNodes();
    int dim = mesh.Dimension();
    H1_FECollection fec(order, dim);
 
    VectorFunctionCoefficient velocity_coeff(dim, velocity_function);
 
-   FiniteElementSpace fes(&mesh, &fec, dim);
+   FiniteElementSpace fes(&mesh, &fec, 1);
+   FiniteElementSpace vfes(&mesh, &fec, dim);
    BilinearForm conv_op(&fes);
 
    IntegrationRules rules(0, Quadrature1D::GaussLobatto);
@@ -483,7 +1133,7 @@ void test_ceed_convection(const char* mesh_filename, int order,
    conv_op.SetAssemblyLevel(assembly);
    conv_op.Assemble();
 
-   GridFunction q(&fes), r(&fes), ex(&fes);
+   GridFunction q(&vfes), r(&vfes), ex(&vfes);
 
    VectorFunctionCoefficient quantity_coeff(dim, quantity);
    q.ProjectCoefficient(quantity_coeff);
@@ -492,9 +1142,15 @@ void test_ceed_convection(const char* mesh_filename, int order,
    ex.ProjectCoefficient(convected_quantity_coeff);
 
    r = 0.0;
-   conv_op.Mult(q, r);
+   for (int i = 0; i < dim; i++)
+   {
+      GridFunction qi, ri;
+      qi.MakeRef(&fes, q, i * fes.GetVSize());
+      ri.MakeRef(&fes, r, i * fes.GetVSize());
+      conv_op.Mult(qi, ri);
+   }
 
-   LinearForm f(&fes);
+   LinearForm f(&vfes);
    VectorDomainLFIntegrator *vlf_integ = new VectorDomainLFIntegrator(
       convected_quantity_coeff);
    vlf_integ->SetIntRule(&ir);
@@ -503,27 +1159,465 @@ void test_ceed_convection(const char* mesh_filename, int order,
 
    r -= f;
 
-   REQUIRE(r.Norml2() < 1e-12);
+   REQUIRE(r.Norml2() < 1.e-12 * std::max(f.Norml2(), 1.0));
+}
+
+void test_ceed_full_assembly(const char *input, int order,
+                             const AssemblyLevel assembly)
+{
+   std::string section = "assembly: " + GetString(assembly) + "\n" +
+                         "order: " + std::to_string(order) + "\n" +
+                         "mesh: " + input;
+   INFO(section);
+   Mesh mesh(input, 1, 1);
+   mesh.EnsureNodes();
+   int dim = mesh.Dimension();
+
+   DenseMatrix val(dim);
+   val = 0.0;
+   for (int i = 0; i < dim; i++)
+   {
+      val(i, i) = 1.0 + i;
+   }
+   MatrixConstantCoefficient diff_coeff(val);
+   ConstantCoefficient mass_coeff(1.0);
+
+   for (int t = 0; t < 3; t++)
+   {
+      FiniteElementCollection *fec = nullptr;
+      switch (t)
+      {
+         case 0:
+            fec = new H1_FECollection(order, dim);
+            break;
+         case 1:
+            fec = new ND_FECollection(order, dim);
+            break;
+         case 2:
+            fec = new RT_FECollection(order - 1, dim);
+            break;
+         default:
+            MFEM_ABORT("Unexpected problem type.");
+      }
+
+      FiniteElementSpace fes(&mesh, fec, 1);
+      BilinearForm k_test(&fes);
+      BilinearForm k_ref(&fes);
+
+      switch (t)
+      {
+         case 0:
+            k_ref.AddDomainIntegrator(new DiffusionIntegrator2(diff_coeff));
+            k_ref.AddDomainIntegrator(new MassIntegrator(mass_coeff));
+            k_ref.AddBoundaryIntegrator(new MassIntegrator(mass_coeff));
+            if (assembly == AssemblyLevel::NONE)
+            {
+               k_test.AddDomainIntegrator(new DiffusionIntegrator2(diff_coeff));
+               k_test.AddDomainIntegrator(new MassIntegrator(mass_coeff));
+            }
+            else
+            {
+               k_test.AddDomainIntegrator(new DiffusionMassIntegrator(diff_coeff, mass_coeff));
+            }
+            k_test.AddBoundaryIntegrator(new MassIntegrator(mass_coeff));
+            break;
+         case 1:
+            if (dim < 3)
+            {
+               k_ref.AddDomainIntegrator(new CurlCurlIntegrator2(mass_coeff));
+            }
+            else
+            {
+               k_ref.AddDomainIntegrator(new CurlCurlIntegrator2(diff_coeff));
+            }
+            k_ref.AddDomainIntegrator(new VectorFEMassIntegrator(mass_coeff));
+            k_ref.AddBoundaryIntegrator(new VectorFEMassIntegrator(mass_coeff));
+            if (assembly == AssemblyLevel::NONE)
+            {
+               if (dim < 3)
+               {
+                  k_test.AddDomainIntegrator(new CurlCurlIntegrator2(mass_coeff));
+               }
+               else
+               {
+                  k_test.AddDomainIntegrator(new CurlCurlIntegrator2(diff_coeff));
+               }
+               k_test.AddDomainIntegrator(new VectorFEMassIntegrator(mass_coeff));
+            }
+            else
+            {
+               if (dim < 3)
+               {
+                  k_test.AddDomainIntegrator(new CurlCurlMassIntegrator(mass_coeff, mass_coeff));
+               }
+               else
+               {
+                  k_test.AddDomainIntegrator(new CurlCurlMassIntegrator(diff_coeff, mass_coeff));
+               }
+            }
+            k_test.AddBoundaryIntegrator(new VectorFEMassIntegrator(mass_coeff));
+            break;
+         case 2:
+            k_ref.AddDomainIntegrator(new DivDivIntegrator2(mass_coeff));
+            k_ref.AddDomainIntegrator(new VectorFEMassIntegrator(mass_coeff));
+            if (assembly == AssemblyLevel::NONE)
+            {
+               k_test.AddDomainIntegrator(new DivDivIntegrator2(mass_coeff));
+               k_test.AddDomainIntegrator(new VectorFEMassIntegrator(mass_coeff));
+            }
+            else
+            {
+               k_test.AddDomainIntegrator(new DivDivMassIntegrator(mass_coeff, mass_coeff));
+            }
+            break;
+         default:
+            MFEM_ABORT("Unexpected problem type.");
+      }
+
+      k_ref.Assemble();
+      k_ref.Finalize();
+
+      k_test.SetAssemblyLevel(assembly);
+      k_test.Assemble();
+
+      SparseMatrix *mat_ref = &k_ref.SpMat();
+      SparseMatrix *mat_test = ceed::CeedOperatorFullAssemble(k_test);
+      SparseMatrix *mat_diff = Add(1.0, *mat_ref, -1.0, *mat_test);
+
+      REQUIRE(mat_diff->MaxNorm() < 1.e-12 * std::max(mat_ref->MaxNorm(), 1.0));
+      delete mat_diff;
+      delete mat_test;
+      delete fec;
+   }
+}
+
+void test_ceed_linear_interpolator(const char *input, int order)
+{
+   std::string section = "order: " + std::to_string(order) + "\n" +
+                         "mesh: " + input;
+   INFO(section);
+   Mesh mesh(input, 1, 1);
+   mesh.EnsureNodes();
+   int dim = mesh.Dimension();
+   H1_FECollection h1_fec(order, dim);
+   ND_FECollection nd_fec(order, dim);
+   RT_FECollection rt_fec(order - 1, dim);
+
+   // Build the DiscreteLinearOperator
+   FiniteElementSpace h1_fes(&mesh, &h1_fec);
+   FiniteElementSpace nd_fes(&mesh, &nd_fec);
+   FiniteElementSpace rt_fes(&mesh, &rt_fec);
+
+   // Discrete gradient
+   DiscreteLinearOperator grad_ref(&h1_fes, &nd_fes);
+   DiscreteLinearOperator grad_test(&h1_fes, &nd_fes);
+   grad_ref.AddDomainInterpolator(new GradientInterpolator);
+   grad_test.AddDomainInterpolator(new GradientInterpolator);
+
+   // Timer for profiling
+   const int trials = 1;
+   const bool debug = false;
+   StopWatch chrono_setup_grad_ref, chrono_setup_grad_test;
+   StopWatch chrono_apply_grad_ref, chrono_apply_grad_test;
+   StopWatch chrono_apply_id_ref, chrono_apply_id_test;
+   chrono_setup_grad_ref.Clear();
+   chrono_setup_grad_ref.Start();
+
+   grad_ref.Assemble();
+   grad_ref.Finalize();
+
+   chrono_setup_grad_ref.Stop();
+   chrono_setup_grad_test.Clear();
+   chrono_setup_grad_test.Start();
+
+   grad_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   grad_test.Assemble();
+
+   chrono_setup_grad_test.Stop();
+
+   // Compare ceed with mfem
+   {
+      GridFunction x(&h1_fes), y_ref(&nd_fes), y_test(&nd_fes);
+      GridFunction x_t(&nd_fes), y_t_ref(&h1_fes), y_t_test(&h1_fes);
+
+      x.Randomize(1);
+
+      chrono_apply_grad_ref.Clear();
+      chrono_apply_grad_ref.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         grad_ref.Mult(x, y_ref);
+      }
+
+      chrono_apply_grad_ref.Stop();
+      chrono_apply_grad_test.Clear();
+      chrono_apply_grad_test.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         grad_test.Mult(x, y_test);
+      }
+
+      chrono_apply_grad_test.Stop();
+
+      y_test -= y_ref;
+
+      REQUIRE(y_test.Norml2() < 1.e-12);
+
+      x_t.Randomize(1);
+
+      chrono_apply_grad_ref.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         grad_ref.MultTranspose(x_t, y_t_ref);
+      }
+
+      chrono_apply_grad_ref.Stop();
+      chrono_apply_grad_test.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         grad_test.MultTranspose(x_t, y_t_test);
+      }
+
+      chrono_apply_grad_test.Stop();
+
+      y_t_test -= y_t_ref;
+
+      REQUIRE(y_t_test.Norml2() < 1.e-12);
+   }
+
+   // Discrete curl
+   if (dim == 3)
+   {
+      DiscreteLinearOperator curl_ref(&nd_fes, &rt_fes);
+      DiscreteLinearOperator curl_test(&nd_fes, &rt_fes);
+      curl_ref.AddDomainInterpolator(new CurlInterpolator);
+      curl_test.AddDomainInterpolator(new CurlInterpolator);
+
+      curl_ref.Assemble();
+      curl_ref.Finalize();
+
+      curl_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+      curl_test.Assemble();
+
+      // Compare ceed with mfem
+      {
+         GridFunction x(&nd_fes), y_ref(&rt_fes), y_test(&rt_fes);
+         GridFunction x_t(&rt_fes), y_t_ref(&nd_fes), y_t_test(&nd_fes);
+
+         x.Randomize(1);
+
+         curl_ref.Mult(x, y_ref);
+         curl_test.Mult(x, y_test);
+
+         y_test -= y_ref;
+
+         REQUIRE(y_test.Norml2() < 1.e-10);
+
+         x_t.Randomize(1);
+
+         curl_ref.MultTranspose(x_t, y_t_ref);
+         curl_test.MultTranspose(x_t, y_t_test);
+
+         y_t_test -= y_t_ref;
+
+         REQUIRE(y_t_test.Norml2() < 1.e-10);
+      }
+   }
+
+   // Prolongation and restriction
+   H1_FECollection fine_h1_fec(order + 1, dim);
+   ND_FECollection fine_nd_fec(order + 1, dim);
+   RT_FECollection fine_rt_fec(order, dim);
+
+   FiniteElementSpace fine_h1_fes(&mesh, &fine_h1_fec);
+   FiniteElementSpace fine_nd_fes(&mesh, &fine_nd_fec);
+   FiniteElementSpace fine_rt_fes(&mesh, &fine_rt_fec);
+
+   DiscreteLinearOperator id_h1_test(&h1_fes, &fine_h1_fes);
+   DiscreteLinearOperator id_nd_test(&nd_fes, &fine_nd_fes);
+   DiscreteLinearOperator id_rt_test(&rt_fes, &fine_rt_fes);
+   id_h1_test.AddDomainInterpolator(new IdentityInterpolator);
+   id_nd_test.AddDomainInterpolator(new IdentityInterpolator);
+   id_rt_test.AddDomainInterpolator(new IdentityInterpolator);
+
+   id_h1_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   id_h1_test.Assemble();
+
+   id_nd_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   id_nd_test.Assemble();
+
+   id_rt_test.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   id_rt_test.Assemble();
+
+   TransferOperator id_h1_ref(h1_fes, fine_h1_fes);
+   TransferOperator id_nd_ref(nd_fes, fine_nd_fes);
+   TransferOperator id_rt_ref(rt_fes, fine_rt_fes);
+
+   // Compare ceed with mfem
+   for (int t = 0; t < 3; t++)
+   {
+      GridFunction *x = nullptr, *y_t_ref = nullptr, *y_t_test = nullptr;
+      GridFunction *y_exact = nullptr, *y_ref = nullptr, *y_test = nullptr;
+      switch (t)
+      {
+         case 0:
+            x = new GridFunction(&h1_fes);
+            y_t_ref = new GridFunction(&h1_fes);
+            y_t_test = new GridFunction(&h1_fes);
+            y_exact = new GridFunction(&fine_h1_fes);
+            y_ref = new GridFunction(&fine_h1_fes);
+            y_test = new GridFunction(&fine_h1_fes);
+            break;
+         case 1:
+            x = new GridFunction(&nd_fes);
+            y_t_ref = new GridFunction(&nd_fes);
+            y_t_test = new GridFunction(&nd_fes);
+            y_exact = new GridFunction(&fine_nd_fes);
+            y_ref = new GridFunction(&fine_nd_fes);
+            y_test = new GridFunction(&fine_nd_fes);
+            break;
+         case 2:
+            x = new GridFunction(&rt_fes);
+            y_t_ref = new GridFunction(&rt_fes);
+            y_t_test = new GridFunction(&rt_fes);
+            y_exact = new GridFunction(&fine_rt_fes);
+            y_ref = new GridFunction(&fine_rt_fes);
+            y_test = new GridFunction(&fine_rt_fes);
+            break;
+         default:
+            MFEM_ABORT("Unexpected problem type.");
+      }
+
+      if (t == 0)
+      {
+         FunctionCoefficient f_coeff(coeff_function);
+         x->ProjectCoefficient(f_coeff);
+         y_exact->ProjectCoefficient(f_coeff);
+      }
+      else
+      {
+         VectorFunctionCoefficient vf_coeff(dim, velocity_function);
+         x->ProjectCoefficient(vf_coeff);
+         y_exact->ProjectCoefficient(vf_coeff);
+      }
+
+      chrono_apply_id_ref.Clear();
+      chrono_apply_id_ref.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         switch (t)
+         {
+            case 0:
+               id_h1_ref.Mult(*x, *y_ref);
+               id_h1_ref.MultTranspose(*y_exact, *y_t_ref);
+               break;
+            case 1:
+               id_nd_ref.Mult(*x, *y_ref);
+               id_nd_ref.MultTranspose(*y_exact, *y_t_ref);
+               break;
+            case 2:
+               id_rt_ref.Mult(*x, *y_ref);
+               id_rt_ref.MultTranspose(*y_exact, *y_t_ref);
+               break;
+            default:
+               MFEM_ABORT("Unexpected problem type.");
+         }
+      }
+
+      chrono_apply_id_ref.Stop();
+      chrono_apply_id_test.Clear();
+      chrono_apply_id_test.Start();
+
+      for (int trial = 0; trial < trials; trial++)
+      {
+         switch (t)
+         {
+            case 0:
+               id_h1_test.Mult(*x, *y_test);
+               id_h1_test.MultTranspose(*y_exact, *y_t_test);
+               break;
+            case 1:
+               id_nd_test.Mult(*x, *y_test);
+               id_nd_test.MultTranspose(*y_exact, *y_t_test);
+               break;
+            case 2:
+               id_rt_test.Mult(*x, *y_test);
+               id_rt_test.MultTranspose(*y_exact, *y_t_test);
+               break;
+            default:
+               MFEM_ABORT("Unexpected problem type.");
+         }
+      }
+
+      chrono_apply_id_test.Stop();
+
+      *y_test -= *y_ref;
+
+      REQUIRE(y_test->Norml2() < 1.e-10);
+
+      *y_t_test -= *y_t_ref;
+
+      REQUIRE(y_t_test->Norml2() < 1.e-10);
+      delete x;
+      delete y_t_ref;
+      delete y_t_test;
+      delete y_exact;
+      delete y_ref;
+      delete y_test;
+   }
+
+   if (debug)
+   {
+      out << "\n" << section << "\n";
+      out << "benchmark (unknowns: H1: " << h1_fes.GetTrueVSize()
+          << ", ND: " << nd_fes.GetTrueVSize()
+          << ", RT: " << rt_fes.GetTrueVSize() << ",\n"
+          << "                     fine H1: " << fine_h1_fes.GetTrueVSize()
+          << ", fine ND: " << fine_nd_fes.GetTrueVSize()
+          << ", fine RT: " << fine_rt_fes.GetTrueVSize() << ")\n"
+          << "    discrete gradient interpolator\n"
+          << "    setup: ref = "
+          << chrono_setup_grad_ref.RealTime() * 1e3 << " ms\n"
+          << "           test = "
+          << chrono_setup_grad_test.RealTime() * 1e3 << " ms\n"
+          << "    apply: ref = "
+          << chrono_apply_grad_ref.RealTime() * 1e3 / trials << " ms\n"
+          << "           test = "
+          << chrono_apply_grad_test.RealTime() * 1e3 / trials << " ms\n"
+          << "    identity interpolator\n"
+          << "    apply: ref = "
+          << chrono_apply_id_ref.RealTime() * 1e3 / trials << " ms\n"
+          << "           test = "
+          << chrono_apply_id_test.RealTime() * 1e3 / trials << " ms\n";
+   }
 }
 
-TEST_CASE("CEED mass & diffusion", "[CEED]")
+TEST_CASE("CEED mass and diffusion", "[CEED]")
 {
    auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
    auto coeff_type = GENERATE(CeedCoeffType::Const,CeedCoeffType::Grid,
                               CeedCoeffType::Quad);
-   auto pb = GENERATE(Problem::Mass,Problem::Diffusion,Problem::MassDiffusion,
+   auto pb = GENERATE(Problem::Mass,Problem::Diffusion,
                       Problem::VectorMass,Problem::VectorDiffusion);
-   auto order = GENERATE(1);
+   auto order = GENERATE(1,2);
+   auto bdr_integ = GENERATE(false,true);
    auto mesh = GENERATE("../../data/inline-quad.mesh",
                         "../../data/inline-hex.mesh",
-                        "../../data/periodic-square.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
                         "../../data/star-q2.mesh",
                         "../../data/fichera-q2.mesh",
                         "../../data/amr-quad.mesh",
                         "../../data/fichera-amr.mesh",
                         "../../data/square-mixed.mesh",
                         "../../data/fichera-mixed.mesh");
-   test_ceed_operator(mesh, order, coeff_type, pb, assembly);
+   bool mixed_p = false;
+   test_ceed_operator(mesh, order, coeff_type, pb, assembly, mixed_p, bdr_integ);
 } // test case
 
 TEST_CASE("CEED p-adaptivity", "[CEED]")
@@ -531,7 +1625,7 @@ TEST_CASE("CEED p-adaptivity", "[CEED]")
    auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
    auto coeff_type = GENERATE(CeedCoeffType::Const,CeedCoeffType::Grid,
                               CeedCoeffType::Quad);
-   auto pb = GENERATE(Problem::Mass,Problem::Diffusion,Problem::MassDiffusion,
+   auto pb = GENERATE(Problem::Mass,Problem::Diffusion,
                       Problem::VectorMass,Problem::VectorDiffusion);
    auto order = GENERATE(1);
    auto mesh = GENERATE("../../data/inline-quad.mesh",
@@ -539,46 +1633,98 @@ TEST_CASE("CEED p-adaptivity", "[CEED]")
                         "../../data/star-q2.mesh",
                         "../../data/amr-quad.mesh",
                         "../../data/square-mixed.mesh");
-   test_mixed_p_ceed_operator(mesh, order, coeff_type, pb, assembly);
+   bool mixed_p = true;
+   bool bdr_integ = false;
+   test_ceed_operator(mesh, order, coeff_type, pb, assembly, mixed_p, bdr_integ);
 } // test case
 
-TEST_CASE("CEED convection low", "[CEED],[Convection]")
+TEST_CASE("CEED vector FE operators", "[CEED], [VectorFE]")
 {
    auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
-   auto coeff_type = GENERATE(CeedCoeffType::VecConst,CeedCoeffType::VecGrid,
-                              CeedCoeffType::VecQuad);
+   auto coeff_type = GENERATE(CeedCoeffType::Const,CeedCoeffType::Quad,
+                              CeedCoeffType::VecConst,CeedCoeffType::VecQuad,
+                              CeedCoeffType::MatConst,CeedCoeffType::MatQuad);
+   auto pb = GENERATE(Problem::Mass,Problem::Diffusion,Problem::MassDiffusion,
+                      Problem::HDivMass,Problem::DivDiv,Problem::HDivMassDivDiv,
+                      Problem::HCurlMass,Problem::CurlCurl,Problem::HCurlMassCurlCurl);
+   auto order = GENERATE(1,2);
+   auto bdr_integ = GENERATE(false,true);
    auto mesh = GENERATE("../../data/inline-quad.mesh",
                         "../../data/inline-hex.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
                         "../../data/star-q2.mesh",
                         "../../data/fichera-q2.mesh",
                         "../../data/amr-quad.mesh",
                         "../../data/fichera-amr.mesh",
                         "../../data/square-mixed.mesh",
                         "../../data/fichera-mixed.mesh");
-   Problem pb = Problem::Convection;
+   test_ceed_vectorfe_operator(mesh, order, coeff_type, pb, assembly, bdr_integ);
+} // test case
 
-   // Test that the CEED and MFEM integrators give the same answer
-   int low_order = 1;
-   test_ceed_operator(mesh, low_order, coeff_type, pb, assembly);
+TEST_CASE("CEED mixed integrators",
+          "[CEED], [MixedVectorIntegrator], [VectorFE]")
+{
+   auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
+   auto coeff_type = GENERATE(CeedCoeffType::Const,CeedCoeffType::Quad,
+                              CeedCoeffType::VecConst,CeedCoeffType::VecQuad,
+                              CeedCoeffType::MatConst,CeedCoeffType::MatQuad);
+   auto pb = GENERATE(Problem::MixedVectorGradient,Problem::MixedVectorCurl);
+   auto order = GENERATE(2);
+   auto bdr_integ = GENERATE(false,true);
+   auto mesh = GENERATE("../../data/inline-quad.mesh",
+                        "../../data/inline-hex.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
+                        "../../data/star-q2.mesh",
+                        "../../data/fichera-q2.mesh",
+                        "../../data/amr-quad.mesh",
+                        "../../data/fichera-amr.mesh",
+                        "../../data/square-mixed.mesh",
+                        "../../data/fichera-mixed.mesh");
+   test_ceed_mixed_operator(mesh, order, coeff_type, pb, assembly, bdr_integ);
 } // test case
 
-TEST_CASE("CEED convection high", "[CEED],[Convection]")
+TEST_CASE("CEED convection low", "[CEED], [Convection]")
 {
    auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
+   auto coeff_type = GENERATE(CeedCoeffType::VecConst,CeedCoeffType::VecGrid,
+                              CeedCoeffType::VecQuad);
    auto mesh = GENERATE("../../data/inline-quad.mesh",
                         "../../data/inline-hex.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
+                        "../../data/periodic-square.mesh",
                         "../../data/star-q2.mesh",
                         "../../data/fichera-q2.mesh",
                         "../../data/amr-quad.mesh",
-                        "../../data/fichera-amr.mesh");
+                        "../../data/fichera-amr.mesh",
+                        "../../data/square-mixed.mesh",
+                        "../../data/fichera-mixed.mesh");
+   Problem pb = Problem::Convection;
+   int low_order = 1;
+   bool mixed_p = false;
+   bool bdr_integ = false;
+   test_ceed_operator(mesh, low_order, coeff_type, pb, assembly, mixed_p,
+                      bdr_integ);
+} // test case
 
+TEST_CASE("CEED convection high", "[CEED], [Convection]")
+{
    // Apply the CEED convection integrator applied to a vector quantity, check
    // that we get the exact answer (with sufficiently high polynomial degree)
+   auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
+   auto mesh = GENERATE("../../data/inline-quad.mesh",
+                        "../../data/periodic-square.mesh",
+                        "../../data/star-q2.mesh",
+                        "../../data/fichera-q2.mesh",
+                        "../../data/amr-quad.mesh",
+                        "../../data/fichera-amr.mesh");
    int high_order = 4;
    test_ceed_convection(mesh, high_order, assembly);
 } // test case
 
-TEST_CASE("CEED non-linear convection", "[CEED],[NLConvection]")
+TEST_CASE("CEED nonlinear convection", "[CEED], [NLConvection]")
 {
    auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
    auto coeff_type = GENERATE(CeedCoeffType::Const,CeedCoeffType::Grid,
@@ -587,6 +1733,8 @@ TEST_CASE("CEED non-linear convection", "[CEED],[NLConvection]")
    auto order = GENERATE(1);
    auto mesh = GENERATE("../../data/inline-quad.mesh",
                         "../../data/inline-hex.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
                         "../../data/periodic-square.mesh",
                         "../../data/star-q2.mesh",
                         "../../data/fichera.mesh",
@@ -595,6 +1743,37 @@ TEST_CASE("CEED non-linear convection", "[CEED],[NLConvection]")
    test_ceed_nloperator(mesh, order, coeff_type, pb, assembly);
 } // test case
 
+TEST_CASE("CEED full assembly", "[CEED]")
+{
+   auto assembly = GENERATE(AssemblyLevel::PARTIAL,AssemblyLevel::NONE);
+   auto mesh = GENERATE("../../data/inline-quad.mesh",
+                        "../../data/inline-hex.mesh",
+                        "../../data/inline-tri.mesh",
+                        "../../data/inline-tet.mesh",
+                        "../../data/star-q2.mesh",
+                        "../../data/fichera-q2.mesh",
+                        "../../data/amr-quad.mesh",
+                        "../../data/fichera-amr.mesh",
+                        "../../data/square-mixed.mesh",
+                        "../../data/fichera-mixed.mesh");
+   int order = 2;
+   test_ceed_full_assembly(mesh, order, assembly);
+} // test case
+
+TEST_CASE("CEED linear interpolators", "[CEED]")
+{
+   auto mesh = GENERATE("../../data/inline-quad.mesh",
+                        "../../data/inline-hex.mesh",
+                        "../../data/star-q2.mesh",
+                        "../../data/fichera-q2.mesh",
+                        "../../data/amr-quad.mesh",
+                        "../../data/fichera-amr.mesh",
+                        "../../data/square-mixed.mesh",
+                        "../../data/fichera-mixed.mesh");
+   int order = 2;
+   test_ceed_linear_interpolator(mesh, order);
+} // test case
+
 #endif
 
 } // namespace ceed_test
diff --git a/tests/unit/enzyme/compatibility.cpp b/tests/unit/enzyme/compatibility.cpp
index 8cbb658d1..118f11b12 100644
--- a/tests/unit/enzyme/compatibility.cpp
+++ b/tests/unit/enzyme/compatibility.cpp
@@ -8,38 +8,40 @@
 template<typename VectorT>
 void square(const VectorT& v, double& y)
 {
-  for (int i = 0; i < 4; i++) {
-    y += v[i]*v[i];
-  }
+   for (int i = 0; i < 4; i++)
+   {
+      y += v[i]*v[i];
+   }
 }
 
 template<typename VectorT>
 void dsquare(const VectorT& v, double& y, VectorT& dydv)
 {
-  double seed = 1.0;
-  __enzyme_autodiff<void>(square<VectorT>, &v, &dydv, &y, &seed);
+   double seed = 1.0;
+   __enzyme_autodiff<void>(square<VectorT>, &v, &dydv, &y, &seed);
 }
 
 template<typename VectorT>
-void run_test() {
-  VectorT v(4);
-  v[0] = 2.0;
-  v[1] = 3.0;
-  v[2] = 1.0;
-  v[3] = 7.0;
-
-  double yy = 0;
-  VectorT dydv(4);
-  dydv[0] = 0;
-  dydv[1] = 0;
-  dydv[2] = 0;
-  dydv[3] = 0;
-  dsquare(v, yy, dydv);
-
-  REQUIRE(dydv[0] == MFEM_Approx(4.0));
-  REQUIRE(dydv[1] == MFEM_Approx(6.0));
-  REQUIRE(dydv[2] == MFEM_Approx(2.0));
-  REQUIRE(dydv[3] == MFEM_Approx(14.0));
+void run_test()
+{
+   VectorT v(4);
+   v[0] = 2.0;
+   v[1] = 3.0;
+   v[2] = 1.0;
+   v[3] = 7.0;
+
+   double yy = 0;
+   VectorT dydv(4);
+   dydv[0] = 0;
+   dydv[1] = 0;
+   dydv[2] = 0;
+   dydv[3] = 0;
+   dsquare(v, yy, dydv);
+
+   REQUIRE(dydv[0] == MFEM_Approx(4.0));
+   REQUIRE(dydv[1] == MFEM_Approx(6.0));
+   REQUIRE(dydv[2] == MFEM_Approx(2.0));
+   REQUIRE(dydv[3] == MFEM_Approx(14.0));
 }
 
 TEST_CASE("AD Vector implementation", "[Enzyme]")
diff --git a/tests/unit/fem/test_assemblediagonalpa.cpp b/tests/unit/fem/test_assemblediagonalpa.cpp
index 050561e1d..42cdc76ba 100644
--- a/tests/unit/fem/test_assemblediagonalpa.cpp
+++ b/tests/unit/fem/test_assemblediagonalpa.cpp
@@ -447,8 +447,8 @@ TEST_CASE("Hcurl/Hdiv diagonal PA",
                      else
                      {
                         const FiniteElement *fel = fespace.GetFE(0);
-                        const IntegrationRule *intRule = &MassIntegrator::GetRule(*fel, *fel,
-                                                                                  *mesh.GetElementTransformation(0));
+                        ElementTransformation *T = mesh.GetElementTransformation(0);
+                        const IntegrationRule *intRule = &MassIntegrator::GetRuleStatic(*fel, *fel, *T);
 
                         if (spaceType == Hcurl)
                         {
diff --git a/tests/unit/fem/test_bilinearform.cpp b/tests/unit/fem/test_bilinearform.cpp
index 5fd00b3e1..647ae38f2 100644
--- a/tests/unit/fem/test_bilinearform.cpp
+++ b/tests/unit/fem/test_bilinearform.cpp
@@ -127,7 +127,7 @@ TEST_CASE("FormLinearSystem/SolutionScope",
    // Legacy full assembly
    {
       GridFunction sol(&fes);
-      SolvePDE(AssemblyLevel::LEGACYFULL, sol);
+      SolvePDE(AssemblyLevel::LEGACY, sol);
       // Make sure the solution is still accessible after 'X' is destroyed
       sol.HostRead();
       REQUIRE(AsConst(sol)(bdr_dof) == 0.0);
diff --git a/tests/unit/fem/test_doftrans.cpp b/tests/unit/fem/test_doftrans.cpp
index 4518b4a5a..6eaf2dd5a 100644
--- a/tests/unit/fem/test_doftrans.cpp
+++ b/tests/unit/fem/test_doftrans.cpp
@@ -28,7 +28,7 @@ TEST_CASE("DoF Transformation Classes",
 
    SECTION("Nedelec Tetrahedral Transformations")
    {
-      ND_TetDofTransformation T(p);
+      ND_TetDofTransformation Tnd(p);
 
       Array<int> ori(4);
       ori[0] = 1;
@@ -36,6 +36,7 @@ TEST_CASE("DoF Transformation Classes",
       ori[2] = 5;
       ori[3] = 1;
 
+      DofTransformation T(Tnd);
       T.SetFaceOrientations(ori);
 
       Vector u(T.Width());
@@ -146,8 +147,8 @@ TEST_CASE("DoF Transformation Functions",
 
    double tol = 1e-13;
 
-   ND_TetDofTransformation Tp(p);
-   ND_TetDofTransformation Tq(q);
+   ND_TetDofTransformation Tndp(p);
+   ND_TetDofTransformation Tndq(q);
 
    Array<int> ori(4);
    ori[0] = 1;
@@ -155,6 +156,7 @@ TEST_CASE("DoF Transformation Functions",
    ori[2] = 5;
    ori[3] = 1;
 
+   DofTransformation Tp(Tndp), Tq(Tndq);
    Tp.SetFaceOrientations(ori);
    Tq.SetFaceOrientations(ori);
 
@@ -253,11 +255,10 @@ TEST_CASE("VDoF Transformation Class",
    ori[2] = 5;
    ori[3] = 1;
 
-   Tnd.SetFaceOrientations(ori);
-
    SECTION("VDim == 1")
    {
       VDofTransformation T(Tnd);
+      T.SetFaceOrientations(ori);
 
       Vector v(T.Width());
       Vector f(T.Width());
@@ -312,6 +313,7 @@ TEST_CASE("VDoF Transformation Class",
       SECTION("Ordering == byNODES")
       {
          VDofTransformation T(Tnd, vdim, Ordering::byNODES);
+         T.SetFaceOrientations(ori);
 
          SECTION("Inverse DoF transformation")
          {
@@ -348,6 +350,7 @@ TEST_CASE("VDoF Transformation Class",
       SECTION("Ordering == byVDIM")
       {
          VDofTransformation T(Tnd, vdim, Ordering::byVDIM);
+         T.SetFaceOrientations(ori);
 
          SECTION("Inverse DoF transformation")
          {
diff --git a/tests/unit/fem/test_lexicographic_ordering.cpp b/tests/unit/fem/test_lexicographic_ordering.cpp
index f68395bfc..6c73cb4e3 100644
--- a/tests/unit/fem/test_lexicographic_ordering.cpp
+++ b/tests/unit/fem/test_lexicographic_ordering.cpp
@@ -20,8 +20,7 @@ void VerifyOrdering(NodalFiniteElement &el)
    Geometry::Type geom = el.GetGeomType();
    const Array<int> &p = el.GetLexicographicOrdering();
 
-   GeometryRefiner refiner;
-   refiner.SetType(BasisType::GaussLobatto);
+   GeometryRefiner refiner(BasisType::GaussLobatto);
    RefinedGeometry *ref_geom = refiner.Refine(geom, order);
 
    double error = 0.0;
diff --git a/tests/unit/fem/test_pa_coeff.cpp b/tests/unit/fem/test_pa_coeff.cpp
index b45738fad..270359f3c 100644
--- a/tests/unit/fem/test_pa_coeff.cpp
+++ b/tests/unit/fem/test_pa_coeff.cpp
@@ -530,8 +530,8 @@ TEST_CASE("Hcurl/Hdiv PA Coefficient",
                         if (spaceType == Hcurl)
                         {
                            const FiniteElement *fel = fespace.GetFE(0);
-                           const IntegrationRule *intRule = &MassIntegrator::GetRule(*fel, *fel,
-                                                                                     *mesh.GetElementTransformation(0));
+                           ElementTransformation *T = mesh.GetElementTransformation(0);
+                           const IntegrationRule *intRule = &MassIntegrator::GetRuleStatic(*fel, *fel, *T);
 
                            if (coeffType >= 3 && dimension == 3)
                            {
