diff --git a/INSTALL b/INSTALL
index 1a325fdf6..ee3f7c03c 100644
--- a/INSTALL
+++ b/INSTALL
@@ -659,8 +659,7 @@ The specific libraries and their options are:
   requires the PT-Scotch and Scalapack libraries as well as ParMETIS, which
   includes METIS 5 in its distribution. Starting with STRUMPACK v2.2.0, ParMETIS
   and PT-Scotch are optional dependencies.
-  The support for STRUMPACK was added in MFEM v3.3.2 and it requires STRUMPACK
-  2.0.0 or later.
+  The support for STRUMPACK was added in MFEM v3.3.2.
   URL: http://portal.nersc.gov/project/sparse/strumpack
   Options: STRUMPACK_OPT, STRUMPACK_LIB.
   Versions: STRUMPACK >= 3.0.0.
diff --git a/config/defaults.cmake b/config/defaults.cmake
index 06531934d..526c87c4f 100644
--- a/config/defaults.cmake
+++ b/config/defaults.cmake
@@ -157,7 +157,8 @@ set(STRUMPACK_DIR "${MFEM_DIR}/../STRUMPACK-build" CACHE PATH
 # STRUMPACK may also depend on "OpenMP", depending on how it was compiled.
 # Starting with v2.2.0 of STRUMPACK, ParMETIS and Scotch are optional.
 set(STRUMPACK_REQUIRED_PACKAGES "MPI" "MPI_Fortran" "ParMETIS" "METIS"
-    "ScaLAPACK" "Scotch/ptscotch/ptscotcherr/scotch/scotcherr" CACHE STRING
+    "Scotch/ptscotch/ptscotcherr/scotch/scotcherr"
+    "ScaLAPACK" "LAPACK" "BLAS" CACHE STRING
     "Additional packages required by STRUMPACK.")
 # If the MPI package does not find all required Fortran libraries:
 # set(STRUMPACK_REQUIRED_LIBRARIES "gfortran" "mpi_mpifh" CACHE STRING
diff --git a/examples/ex11p.cpp b/examples/ex11p.cpp
index 216a6f443..eca3ce929 100644
--- a/examples/ex11p.cpp
+++ b/examples/ex11p.cpp
@@ -262,12 +262,13 @@ int main(int argc, char *argv[])
 #ifdef MFEM_USE_STRUMPACK
       if (sp_solver)
       {
-         STRUMPACKSolver * strumpack = new STRUMPACKSolver(argc, argv, MPI_COMM_WORLD);
+         STRUMPACKSolver * strumpack = new STRUMPACKSolver(MPI_COMM_WORLD, argc, argv);
          strumpack->SetPrintFactorStatistics(true);
          strumpack->SetPrintSolveStatistics(false);
          strumpack->SetKrylovSolver(strumpack::KrylovSolver::DIRECT);
          strumpack->SetReorderingStrategy(strumpack::ReorderingStrategy::METIS);
-         strumpack->DisableMatching();
+         strumpack->SetMatching(strumpack::MatchingJob::NONE);
+         strumpack->SetCompression(strumpack::CompressionType::NONE);
          strumpack->SetOperator(*Arow);
          strumpack->SetFromCommandLine();
          precond = strumpack;
diff --git a/examples/ex25p.cpp b/examples/ex25p.cpp
index e3848b848..cf5daf412 100644
--- a/examples/ex25p.cpp
+++ b/examples/ex25p.cpp
@@ -170,6 +170,7 @@ int main(int argc, char *argv[])
    bool herm_conv = true;
    bool slu_solver  = false;
    bool mumps_solver = false;
+   bool strumpack_solver = false;
    bool visualization = 1;
    bool pa = false;
    const char *device_config = "cpu";
@@ -200,6 +201,11 @@ int main(int argc, char *argv[])
 #ifdef MFEM_USE_MUMPS
    args.AddOption(&mumps_solver, "-mumps", "--mumps-solver", "-no-mumps",
                   "--no-mumps-solver", "Use the MUMPS Solver.");
+#endif
+#ifdef MFEM_USE_STRUMPACK
+   args.AddOption(&strumpack_solver, "-strumpack", "--strumpack-solver",
+                  "-no-strumpack", "--no-strumpack-solver",
+                  "Use the STRUMPACK Solver.");
 #endif
    args.AddOption(&visualization, "-vis", "--visualization", "-no-vis",
                   "--no-visualization",
@@ -209,13 +215,14 @@ int main(int argc, char *argv[])
    args.AddOption(&device_config, "-d", "--device",
                   "Device configuration string, see Device::Configure().");
    args.Parse();
-   if (slu_solver && mumps_solver)
+   if (slu_solver + mumps_solver + strumpack_solver > 1)
    {
       if (myid == 0)
-         cout << "WARNING: Both SuperLU and MUMPS have been selected,"
-              << " please choose either one." << endl
+         cout << "WARNING: More than one of SuperLU, MUMPS, and STRUMPACK have"
+              << " been selected, please choose only one." << endl
               << "         Defaulting to SuperLU." << endl;
       mumps_solver = false;
+      strumpack_solver = false;
    }
 
    if (iprob > 4) { iprob = 4; }
@@ -474,6 +481,24 @@ int main(int argc, char *argv[])
       delete A;
    }
 #endif
+#ifdef MFEM_USE_STRUMPACK
+   if (!pa && strumpack_solver)
+   {
+      HypreParMatrix *A = Ah.As<ComplexHypreParMatrix>()->GetSystemMatrix();
+      STRUMPACKRowLocMatrix SA(*A);
+      STRUMPACKSolver strumpack(MPI_COMM_WORLD, argc, argv);
+      strumpack.SetPrintFactorStatistics(false);
+      strumpack.SetPrintSolveStatistics(false);
+      strumpack.SetKrylovSolver(strumpack::KrylovSolver::DIRECT);
+      strumpack.SetReorderingStrategy(strumpack::ReorderingStrategy::METIS);
+      strumpack.SetMatching(strumpack::MatchingJob::NONE);
+      strumpack.SetCompression(strumpack::CompressionType::NONE);
+      strumpack.SetFromCommandLine();
+      strumpack.SetOperator(SA);
+      strumpack.Mult(B, X);
+      delete A;
+   }
+#endif
 #ifdef MFEM_USE_MUMPS
    if (!pa && mumps_solver)
    {
@@ -493,7 +518,7 @@ int main(int argc, char *argv[])
    //
    //    In PML:   1/mu (abs(1/det(J) J^T J) Curl E, Curl F)
    //              + omega^2 * epsilon (abs(det(J) * (J^T J)^-1) * E, F)
-   if (pa || (!slu_solver && !mumps_solver))
+   if (pa || (!slu_solver && !mumps_solver && !strumpack_solver))
    {
       ConstantCoefficient absomeg(pow(omega, 2) * epsilon);
       RestrictedCoefficient restr_absomeg(absomeg,attr);
diff --git a/examples/petsc/ex11p.cpp b/examples/petsc/ex11p.cpp
index 51238c4d7..e6f4730fe 100644
--- a/examples/petsc/ex11p.cpp
+++ b/examples/petsc/ex11p.cpp
@@ -273,12 +273,13 @@ int main(int argc, char *argv[])
 #ifdef MFEM_USE_STRUMPACK
          if (sp_solver)
          {
-            STRUMPACKSolver * strumpack = new STRUMPACKSolver(argc, argv, MPI_COMM_WORLD);
+            STRUMPACKSolver * strumpack = new STRUMPACKSolver(MPI_COMM_WORLD, argc, argv);
             strumpack->SetPrintFactorStatistics(true);
             strumpack->SetPrintSolveStatistics(false);
             strumpack->SetKrylovSolver(strumpack::KrylovSolver::DIRECT);
             strumpack->SetReorderingStrategy(strumpack::ReorderingStrategy::METIS);
-            strumpack->DisableMatching();
+            strumpack->SetMatching(strumpack::MatchingJob::NONE);
+            strumpack->SetCompression(strumpack::CompressionType::NONE);
             strumpack->SetOperator(*Arow);
             strumpack->SetFromCommandLine();
             precond = strumpack;
diff --git a/general/communication.cpp b/general/communication.cpp
index 10fa6988c..0c2fffc1f 100644
--- a/general/communication.cpp
+++ b/general/communication.cpp
@@ -26,6 +26,10 @@
 #include "sort_pairs.hpp"
 #include "globals.hpp"
 
+#ifdef MFEM_USE_STRUMPACK
+#include <StrumpackConfig.hpp> // STRUMPACK_USE_PTSCOTCH, etc.
+#endif
+
 #include <iostream>
 #include <map>
 
@@ -34,6 +38,14 @@ using namespace std;
 namespace mfem
 {
 
+#if defined(MFEM_USE_STRUMPACK) && \
+    (defined(STRUMPACK_USE_PTSCOTCH) || defined(STRUMPACK_USE_SLATE_SCALAPACK))
+int Mpi::default_thread_required = MPI_THREAD_MULTIPLE;
+#else
+int Mpi::default_thread_required = MPI_THREAD_SINGLE;
+#endif
+
+
 GroupTopology::GroupTopology(const GroupTopology &gt)
    : MyComm(gt.MyComm),
      group_lproc(gt.group_lproc)
diff --git a/general/communication.hpp b/general/communication.hpp
index 474486f1b..46d4f9f21 100644
--- a/general/communication.hpp
+++ b/general/communication.hpp
@@ -22,7 +22,6 @@
 #include "globals.hpp"
 #include <mpi.h>
 
-
 namespace mfem
 {
 
@@ -32,10 +31,25 @@ namespace mfem
 class Mpi
 {
 public:
-   /// Singleton creation with Mpi::Init();
-   static void Init() { Init_(NULL, NULL); }
-   /// Singleton creation with Mpi::Init(argc,argv);
-   static void Init(int &argc, char **&argv) { Init_(&argc, &argv); }
+   /// Singleton creation with Mpi::Init(argc, argv).
+   static void Init(int &argc, char **&argv,
+                    int required = default_thread_required,
+                    int *provided = nullptr)
+   { Init(&argc, &argv, required, provided); }
+   /// Singleton creation with Mpi::Init().
+   static void Init(int *argc = nullptr, char ***argv = nullptr,
+                    int required = default_thread_required,
+                    int *provided = nullptr)
+   {
+      MFEM_VERIFY(!IsInitialized(), "MPI already initialized!");
+      int mpi_provided;
+      int mpi_err = MPI_Init_thread(argc, argv, required, &mpi_provided);
+      MFEM_VERIFY(!mpi_err, "error in MPI_Init()!");
+      if (provided) { *provided = mpi_provided; }
+      // The Mpi singleton object below needs to be created after MPI_Init() for
+      // some MPI implementations.
+      Singleton();
+   }
    /// Finalize MPI (if it has been initialized and not yet already finalized).
    static void Finalize()
    {
@@ -71,20 +85,19 @@ public:
    }
    /// Return true if the rank in MPI_COMM_WORLD is zero.
    static bool Root() { return WorldRank() == 0; }
+   /// Default level of thread support for MPI_Init_thread.
+   static MFEM_EXPORT int default_thread_required;
 private:
-   /// Initialize MPI
-   static void Init_(int *argc, char ***argv)
+   /// Initialize the Mpi singleton.
+   static Mpi &Singleton()
    {
-      MFEM_VERIFY(!IsInitialized(), "MPI already initialized!")
-      MPI_Init(argc, argv);
-      // The "mpi" object below needs to be created after MPI_Init() for some
-      // MPI implementations
       static Mpi mpi;
+      return mpi;
    }
-   /// Finalize MPI
+   /// Finalize MPI.
    ~Mpi() { Finalize(); }
-   /// Prevent direct construction of objects of this class
-   Mpi() { }
+   /// Prevent direct construction of objects of this class.
+   Mpi() {}
 };
 
 /** @brief A simple convenience class based on the Mpi singleton class above.
diff --git a/linalg/strumpack.cpp b/linalg/strumpack.cpp
index f0ff11ab4..5b54994aa 100644
--- a/linalg/strumpack.cpp
+++ b/linalg/strumpack.cpp
@@ -16,238 +16,470 @@
 
 #include "strumpack.hpp"
 
-using namespace std;
-using namespace strumpack;
-
 namespace mfem
 {
 
 STRUMPACKRowLocMatrix::STRUMPACKRowLocMatrix(MPI_Comm comm,
-                                             int num_loc_rows, int first_loc_row,
-                                             int glob_nrows, int glob_ncols,
-                                             int *I, int *J, double *data)
-   : comm_(comm), A_(NULL)
+                                             int num_loc_rows,
+                                             HYPRE_BigInt first_loc_row,
+                                             HYPRE_BigInt glob_nrows,
+                                             HYPRE_BigInt glob_ncols,
+                                             int *I, HYPRE_BigInt *J,
+                                             double *data, bool sym_sparse)
 {
    // Set mfem::Operator member data
    height = num_loc_rows;
    width  = num_loc_rows;
 
-   // Allocate STRUMPACK's CSRMatrixMPI
-   int nprocs, rank;
-   MPI_Comm_rank(comm_, &rank);
-   MPI_Comm_size(comm_, &nprocs);
-   int * dist = new int[nprocs + 1];
-   dist[rank + 1] = first_loc_row + num_loc_rows;
+   // Allocate STRUMPACK's CSRMatrixMPI (copies all inputs)
+   int rank, nprocs;
+   MPI_Comm_rank(comm, &rank);
+   MPI_Comm_size(comm, &nprocs);
+   Array<HYPRE_BigInt> dist(nprocs + 1);
    dist[0] = 0;
-   MPI_Allgather(MPI_IN_PLACE, 0, MPI_INT, dist + 1, 1, MPI_INT, comm_);
-   A_ = new CSRMatrixMPI<double,int>(num_loc_rows, I, J, data, dist, comm_, false);
-   delete[] dist;
+   dist[rank + 1] = first_loc_row + (HYPRE_BigInt)num_loc_rows;
+   MPI_Allgather(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL,
+                 dist.GetData() + 1, 1, HYPRE_MPI_BIG_INT, comm);
+
+#if !(defined(HYPRE_BIGINT) || defined(HYPRE_MIXEDINT))
+   A_ = new strumpack::CSRMatrixMPI<double, HYPRE_BigInt>(
+      (HYPRE_BigInt)num_loc_rows, I, J, data, dist.GetData(),
+      comm, sym_sparse);
+#else
+   Array<HYPRE_BigInt> II(num_loc_rows+1);
+   for (int i = 0; i <= num_loc_rows; i++) { II[i] = (HYPRE_BigInt)I[i]; }
+   A_ = new strumpack::CSRMatrixMPI<double, HYPRE_BigInt>(
+      (HYPRE_BigInt)num_loc_rows, II.GetData(), J, data, dist.GetData(),
+      comm, sym_sparse);
+#endif
 }
 
-STRUMPACKRowLocMatrix::STRUMPACKRowLocMatrix(const HypreParMatrix & hypParMat)
-   : comm_(hypParMat.GetComm()),
-     A_(NULL)
+STRUMPACKRowLocMatrix::STRUMPACKRowLocMatrix(const Operator &op,
+                                             bool sym_sparse)
 {
-   // First cast the parameter to a hypre_ParCSRMatrix
-   hypre_ParCSRMatrix * parcsr_op =
-      (hypre_ParCSRMatrix *)const_cast<HypreParMatrix&>(hypParMat);
+   const HypreParMatrix *APtr = dynamic_cast<const HypreParMatrix *>(&op);
+   MFEM_VERIFY(APtr, "Not a compatible matrix type");
+   MPI_Comm comm = APtr->GetComm();
 
-   MFEM_ASSERT(parcsr_op != NULL,"STRUMPACK: const_cast failed in SetOperator");
+   // Set mfem::Operator member data
+   height = op.Height();
+   width  = op.Width();
 
-   // Create the CSRMatrixMPI A_ by borrowing the internal data from a
-   // hypre_CSRMatrix.
-   hypParMat.HostRead();
-   hypre_CSRMatrix * csr_op = hypre_MergeDiagAndOffd(parcsr_op);
-   hypParMat.HypreRead();
-   hypre_CSRMatrixSetDataOwner(csr_op,0);
+   // First cast the parameter to a hypre_ParCSRMatrix
+   hypre_ParCSRMatrix *parcsr_op =
+      (hypre_ParCSRMatrix *)const_cast<HypreParMatrix &>(*APtr);
+
+   // Create the CSRMatrixMPI A by taking the internal data from a
+   // hypre_CSRMatrix
+   APtr->HostRead();
+   hypre_CSRMatrix *csr_op = hypre_MergeDiagAndOffd(parcsr_op);
+   APtr->HypreRead();
+   HYPRE_Int       *Iptr   = csr_op->i;
 #if MFEM_HYPRE_VERSION >= 21600
-   // For now, this method assumes that HYPRE_Int is int. Also, csr_op->num_cols
-   // is of type HYPRE_Int, so if we want to check for big indices in
-   // csr_op->big_j, we'll have to check all entries and that check will only be
-   // necessary in HYPRE_MIXEDINT mode which is not supported at the moment.
-   hypre_CSRMatrixBigJtoJ(csr_op);
+   HYPRE_BigInt    *Jptr   = csr_op->big_j;
+#else
+   HYPRE_Int       *Jptr   = csr_op->j;
 #endif
+   double          *data   = csr_op->data;
 
-   height = csr_op->num_rows;
-   width  = csr_op->num_rows;
+   HYPRE_BigInt fst_row = parcsr_op->first_row_index;
+   HYPRE_Int    m_loc   = csr_op->num_rows;
 
-   int nprocs, rank;
-   MPI_Comm_rank(comm_, &rank);
-   MPI_Comm_size(comm_, &nprocs);
-   int * dist = new int[nprocs + 1];
-   dist[rank + 1] = parcsr_op->first_row_index + csr_op->num_rows;
+   // Allocate STRUMPACK's CSRMatrixMPI
+   int rank, nprocs;
+   MPI_Comm_rank(comm, &rank);
+   MPI_Comm_size(comm, &nprocs);
+   Array<HYPRE_BigInt> dist(nprocs + 1);
    dist[0] = 0;
-   MPI_Allgather(MPI_IN_PLACE, 0, MPI_INT, dist + 1, 1, MPI_INT, comm_);
-   A_ = new CSRMatrixMPI<double,int>(csr_op->num_rows, csr_op->i, csr_op->j,
-                                     csr_op->data, dist, comm_, false);
-   delete[] dist;
+   dist[rank + 1] = fst_row + (HYPRE_BigInt)m_loc;
+   MPI_Allgather(MPI_IN_PLACE, 0, MPI_DATATYPE_NULL,
+                 dist.GetData() + 1, 1, HYPRE_MPI_BIG_INT, comm);
+
+#if !defined(HYPRE_MIXEDINT)
+   A_ = new strumpack::CSRMatrixMPI<double, HYPRE_BigInt>(
+      (HYPRE_BigInt)m_loc, Iptr, Jptr, data, dist.GetData(),
+      comm, sym_sparse);
+#else
+   Array<HYPRE_BigInt> II(m_loc+1);
+   for (int i = 0; i <= m_loc; i++) { II[i] = (HYPRE_BigInt)Iptr[i]; }
+   A_ = new strumpack::CSRMatrixMPI<double, HYPRE_BigInt>(
+      (HYPRE_BigInt)m_loc, II.GetData(), Jptr, data, dist.GetData(),
+      comm, sym_sparse);
+#endif
 
-   // Everything has been copied or abducted so delete the structure
+   // Everything has been copied so delete the structure
    hypre_CSRMatrixDestroy(csr_op);
 }
 
 STRUMPACKRowLocMatrix::~STRUMPACKRowLocMatrix()
 {
-   // Delete the struct
-   if ( A_ != NULL ) { delete A_; }
+   delete A_;
 }
 
-STRUMPACKSolver::STRUMPACKSolver( int argc, char* argv[], MPI_Comm comm )
-   : comm_(comm),
-     APtr_(NULL),
-     solver_(NULL)
+template <typename STRUMPACKSolverType>
+STRUMPACKSolverBase<STRUMPACKSolverType>::
+STRUMPACKSolverBase(MPI_Comm comm, int argc, char *argv[])
+   : APtr_(NULL),
+     factor_verbose_(false),
+     solve_verbose_(false),
+     reorder_reuse_(false),
+     nrhs_(-1)
 {
-   this->Init(argc, argv);
+   solver_ = new STRUMPACKSolverType(comm, argc, argv, false);
 }
 
-STRUMPACKSolver::STRUMPACKSolver( STRUMPACKRowLocMatrix & A )
-   : comm_(A.GetComm()),
-     APtr_(&A),
-     solver_(NULL)
+template <typename STRUMPACKSolverType>
+STRUMPACKSolverBase<STRUMPACKSolverType>::
+STRUMPACKSolverBase(STRUMPACKRowLocMatrix &A, int argc, char *argv[])
+   : APtr_(&A),
+     factor_verbose_(false),
+     solve_verbose_(false),
+     reorder_reuse_(false),
+     nrhs_(-1)
 {
-   height = A.Height();
-   width  = A.Width();
+   solver_ = new STRUMPACKSolverType(A.GetComm(), argc, argv, false);
+   SetOperator(A);
+}
 
-   this->Init(0, NULL);
+template <typename STRUMPACKSolverType>
+STRUMPACKSolverBase<STRUMPACKSolverType>::
+~STRUMPACKSolverBase()
+{
+   delete solver_;
 }
 
-STRUMPACKSolver::~STRUMPACKSolver()
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+SetFromCommandLine()
 {
-   if ( solver_ != NULL ) { delete solver_; }
+   solver_->options().set_from_command_line();
 }
 
-void STRUMPACKSolver::Init( int argc, char* argv[] )
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+SetPrintFactorStatistics(bool print_stat)
 {
-   MPI_Comm_size(comm_, &numProcs_);
-   MPI_Comm_rank(comm_, &myid_);
+   factor_verbose_ = print_stat;
+}
 
-   factor_verbose_ = false;
-   solve_verbose_ = false;
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+SetPrintSolveStatistics(bool print_stat)
+{
+   solve_verbose_ = print_stat;
+}
 
-   solver_ = new StrumpackSparseSolverMPIDist<double,int>(comm_, argc, argv,
-                                                          false);
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>
+::SetRelTol(double rtol)
+{
+   solver_->options().set_rel_tol(rtol);
 }
 
-void STRUMPACKSolver::SetFromCommandLine( )
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>
+::SetAbsTol(double atol)
 {
-   solver_->options().set_from_command_line( );
+   solver_->options().set_abs_tol(atol);
 }
 
-void STRUMPACKSolver::SetPrintFactorStatistics( bool print_stat )
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>
+::SetMaxIter(int max_it)
 {
-   factor_verbose_ = print_stat;
+   solver_->options().set_maxit(max_it);
 }
 
-void STRUMPACKSolver::SetPrintSolveStatistics( bool print_stat )
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>
+::SetReorderingReuse(bool reuse)
 {
-   solve_verbose_ = print_stat;
+   reorder_reuse_ = reuse;
+}
+
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>
+::EnableGPU()
+{
+   solver_->options().enable_gpu();
 }
 
-void STRUMPACKSolver::SetKrylovSolver( strumpack::KrylovSolver method )
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>
+::DisableGPU()
 {
-   solver_->options().set_Krylov_solver( method );
+   solver_->options().disable_gpu();
 }
 
-void STRUMPACKSolver::SetReorderingStrategy( strumpack::ReorderingStrategy
-                                             method )
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+SetKrylovSolver(strumpack::KrylovSolver method)
 {
-   solver_->options().set_reordering_method( method );
+   solver_->options().set_Krylov_solver(method);
 }
 
-void STRUMPACKSolver::DisableMatching( )
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+SetReorderingStrategy(strumpack::ReorderingStrategy method)
 {
-#if STRUMPACK_VERSION_MAJOR >= 3
-   solver_->options().set_matching( strumpack::MatchingJob::NONE );
+   solver_->options().set_reordering_method(method);
+}
+
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+SetMatching(strumpack::MatchingJob job)
+{
+   solver_->options().set_matching(job);
+}
+
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+SetCompression(strumpack::CompressionType type)
+{
+#if STRUMPACK_VERSION_MAJOR >= 5
+   solver_->options().set_compression(type);
 #else
-   solver_->options().set_mc64job( strumpack::MC64Job::NONE );
+   switch (type)
+   {
+      case strumpack::NONE:
+         solver_->options().disable_BLR();
+         solver_->options().disable_HSS();
+         break;
+      case strumpack::BLR:
+         solver_->options().enable_BLR();
+         break;
+      case strumpack::HSS:
+         solver_->options().enable_HSS();
+         break;
+      default:
+         MFEM_ABORT("Invalid compression type for STRUMPACK version " <<
+                    STRUMPACK_VERSION_MAJOR << "!");
+         break;
+   }
 #endif
 }
 
-void STRUMPACKSolver::EnableMatching( )
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+SetCompressionRelTol(double rtol)
 {
-#if STRUMPACK_VERSION_MAJOR >= 3
-   solver_->options().set_matching
-   ( strumpack::MatchingJob::MAX_DIAGONAL_PRODUCT_SCALING );
+#if STRUMPACK_VERSION_MAJOR >= 5
+   solver_->options().set_compression_rel_tol(rtol);
 #else
-   solver_->options().set_mc64job
-   ( strumpack::MC64Job::MAX_DIAGONAL_PRODUCT_SCALING );
+   solver_->options().BLR_options().set_rel_tol(rtol);
+   solver_->options().HSS_options().set_rel_tol(rtol);
 #endif
 }
 
-#if STRUMPACK_VERSION_MAJOR >= 3
-void STRUMPACKSolver::EnableParallelMatching( )
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+SetCompressionAbsTol(double atol)
 {
-   solver_->options().set_matching
-   ( strumpack::MatchingJob::COMBBLAS );
-}
+#if STRUMPACK_VERSION_MAJOR >= 5
+   solver_->options().set_compression_abs_tol(atol);
+#else
+   solver_->options().BLR_options().set_abs_tol(atol);
+   solver_->options().HSS_options().set_abs_tol(atol);
 #endif
+}
 
-void STRUMPACKSolver::SetRelTol( double rtol )
+#if STRUMPACK_VERSION_MAJOR >= 5
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+SetCompressionLossyPrecision(int precision)
 {
-   solver_->options().set_rel_tol( rtol );
+   solver_->options().set_lossy_precision(precision);
 }
 
-void STRUMPACKSolver::SetAbsTol( double atol )
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+SetCompressionButterflyLevels(int levels)
 {
-   solver_->options().set_abs_tol( atol );
+   solver_->options().HODLR_options().set_butterfly_levels(levels);
 }
+#endif
 
-
-void STRUMPACKSolver::Mult( const Vector & x, Vector & y ) const
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+SetOperator(const Operator &op)
 {
-   MFEM_ASSERT(APtr_ != NULL,
-               "STRUMPACK Error: The operator must be set before"
-               " the system can be solved.");
-   MFEM_ASSERT(x.Size() == Width(), "invalid x.Size() = " << x.Size()
-               << ", expected size = " << Width());
-   MFEM_ASSERT(y.Size() == Height(), "invalid y.Size() = " << y.Size()
-               << ", expected size = " << Height());
+   // Verify that we have a compatible operator
+   bool first_mat = !APtr_;
+   APtr_ = dynamic_cast<const STRUMPACKRowLocMatrix *>(&op);
+   MFEM_VERIFY(APtr_,
+               "STRUMPACK: Operator is not a STRUMPACKRowLocMatrix!");
 
-   double*  yPtr = y.HostWrite();
-   const double*  xPtr = x.HostRead();
+   // Set mfem::Operator member data
+   height = op.Height();
+   width  = op.Width();
 
-   solver_->options().set_verbose( factor_verbose_ );
-   ReturnCode ret = solver_->factor();
-   switch (ret)
+   if (first_mat || !reorder_reuse_)
    {
-      case ReturnCode::SUCCESS: break;
-      case ReturnCode::MATRIX_NOT_SET:
-      {
-         MFEM_ABORT("STRUMPACK:  Matrix was not set!");
-      }
-      break;
-      case ReturnCode::REORDERING_ERROR:
-      {
-         MFEM_ABORT("STRUMPACK:  Matrix reordering failed!");
-      }
-      break;
-      default:
-      {
-         MFEM_ABORT("STRUMPACK: 'factor()' error code = " << ret);
-      }
+      solver_->set_matrix(*(APtr_->GetA()));
+   }
+   else
+   {
+      solver_->update_matrix_values(*(APtr_->GetA()));
    }
-   solver_->options().set_verbose( solve_verbose_ );
-   solver_->solve(xPtr, yPtr);
+}
 
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+FactorInternal() const
+{
+   MFEM_ASSERT(APtr_,
+               "STRUMPACK: Operator must be set before the system can be "
+               "solved!");
+   solver_->options().set_verbose(factor_verbose_);
+   strumpack::ReturnCode ret = solver_->factor();
+   if (ret != strumpack::ReturnCode::SUCCESS)
+   {
+#if STRUMPACK_VERSION_MAJOR >= 7
+      MFEM_ABORT("STRUMPACK: Factor failed with return code " << ret << "!");
+#else
+      MFEM_ABORT("STRUMPACK: Factor failed!");
+#endif
+   }
 }
 
-void STRUMPACKSolver::SetOperator( const Operator & op )
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+Mult(const Vector &x, Vector &y) const
 {
-   // Verify that we have a compatible operator
-   APtr_ = dynamic_cast<const STRUMPACKRowLocMatrix*>(&op);
-   if ( APtr_ == NULL )
+   MFEM_ASSERT(x.Size() == Width(),
+               "STRUMPACK: Invalid x.Size() = " << x.Size() <<
+               ", expected size = " << Width() << "!");
+   MFEM_ASSERT(y.Size() == Height(),
+               "STRUMPACK: Invalid y.Size() = " << y.Size() <<
+               ", expected size = " << Height() << "!");
+
+   const double *xPtr = x.HostRead();
+   double *yPtr       = y.HostReadWrite();
+
+   FactorInternal();
+   solver_->options().set_verbose(solve_verbose_);
+   strumpack::ReturnCode ret = solver_->solve(xPtr, yPtr, false);
+   if (ret != strumpack::ReturnCode::SUCCESS)
    {
-      mfem_error("STRUMPACKSolver::SetOperator : not STRUMPACKRowLocMatrix!");
+#if STRUMPACK_VERSION_MAJOR >= 7
+      MFEM_ABORT("STRUMPACK: Solve failed with return code " << ret << "!");
+#else
+      MFEM_ABORT("STRUMPACK: Solve failed!");
+#endif
    }
+}
 
-   solver_->set_matrix( *(APtr_->getA()) );
+template <typename STRUMPACKSolverType>
+void STRUMPACKSolverBase<STRUMPACKSolverType>::
+ArrayMult(const Array<const Vector *> &X, Array<Vector *> &Y) const
+{
+   MFEM_ASSERT(X.Size() == Y.Size(),
+               "Number of columns mismatch in STRUMPACK solve!");
+   if (X.Size() == 1)
+   {
+      nrhs_ = 1;
+      MFEM_ASSERT(X[0] && Y[0], "Missing Vector in STRUMPACK solve!");
+      Mult(*X[0], *Y[0]);
+      return;
+   }
 
-   // Set mfem::Operator member data
-   height = op.Height();
-   width  = op.Width();
+   // Multiple RHS case
+   int ldx = Height();
+   if (nrhs_ != X.Size())
+   {
+      rhs_.SetSize(X.Size() * ldx);
+      sol_.SetSize(X.Size() * ldx);
+      nrhs_ = X.Size();
+   }
+   for (int i = 0; i < nrhs_; i++)
+   {
+      MFEM_ASSERT(X[i] && X[i]->Size() == Width(),
+                  "STRUMPACK: Missing or invalid sized RHS Vector in solve!");
+      Vector s(rhs_, i * ldx, ldx);
+      s = *X[i];
+   }
+   const double *xPtr = rhs_.HostRead();
+   double *yPtr       = sol_.HostReadWrite();
+
+   FactorInternal();
+   solver_->options().set_verbose(solve_verbose_);
+   strumpack::ReturnCode ret = solver_->solve(nrhs_, xPtr, ldx, yPtr, ldx,
+                                              false);
+   if (ret != strumpack::ReturnCode::SUCCESS)
+   {
+#if STRUMPACK_VERSION_MAJOR >= 7
+      MFEM_ABORT("STRUMPACK: Solve failed with return code " << ret << "!");
+#else
+      MFEM_ABORT("STRUMPACK: Solve failed!");
+#endif
+   }
 
+   for (int i = 0; i < nrhs_; i++)
+   {
+      MFEM_ASSERT(Y[i] && Y[i]->Size() == Width(),
+                  "STRUMPACK: Missing or invalid sized solution Vector in solve!");
+      Vector s(sol_, i * ldx, ldx);
+      *Y[i] = s;
+   }
 }
 
+STRUMPACKSolver::
+STRUMPACKSolver(MPI_Comm comm)
+   : STRUMPACKSolverBase<strumpack::
+     SparseSolverMPIDist<double, HYPRE_BigInt>>
+     (comm, 0, NULL) {}
+
+STRUMPACKSolver::
+STRUMPACKSolver(STRUMPACKRowLocMatrix &A)
+   : STRUMPACKSolverBase<strumpack::
+     SparseSolverMPIDist<double, HYPRE_BigInt>>
+     (A, 0, NULL) {}
+
+STRUMPACKSolver::
+STRUMPACKSolver(MPI_Comm comm, int argc, char *argv[])
+   : STRUMPACKSolverBase<strumpack::
+     SparseSolverMPIDist<double, HYPRE_BigInt>>
+     (comm, argc, argv) {}
+
+STRUMPACKSolver::
+STRUMPACKSolver(STRUMPACKRowLocMatrix &A, int argc, char *argv[])
+   : STRUMPACKSolverBase<strumpack::
+     SparseSolverMPIDist<double, HYPRE_BigInt>>
+     (A, argc, argv) {}
+
+#if STRUMPACK_VERSION_MAJOR >= 7
+STRUMPACKMixedPrecisionSolver::
+STRUMPACKMixedPrecisionSolver(MPI_Comm comm)
+   : STRUMPACKSolverBase<strumpack::
+     SparseSolverMixedPrecisionMPIDist<float, double, HYPRE_BigInt>>
+     (comm, 0, NULL) {}
+
+STRUMPACKMixedPrecisionSolver::
+STRUMPACKMixedPrecisionSolver(STRUMPACKRowLocMatrix &A)
+   : STRUMPACKSolverBase<strumpack::
+     SparseSolverMixedPrecisionMPIDist<float, double, HYPRE_BigInt>>
+     (A, 0, NULL) {}
+
+STRUMPACKMixedPrecisionSolver::
+STRUMPACKMixedPrecisionSolver(MPI_Comm comm, int argc, char *argv[])
+   : STRUMPACKSolverBase<strumpack::
+     SparseSolverMixedPrecisionMPIDist<float, double, HYPRE_BigInt>>
+     (comm, argc, argv) {}
+
+STRUMPACKMixedPrecisionSolver::
+STRUMPACKMixedPrecisionSolver(STRUMPACKRowLocMatrix &A, int argc, char *argv[])
+   : STRUMPACKSolverBase<strumpack::
+     SparseSolverMixedPrecisionMPIDist<float, double, HYPRE_BigInt>>
+     (A, argc, argv) {}
+#endif
+
+template class STRUMPACKSolverBase<strumpack::
+                                   SparseSolverMPIDist<double, HYPRE_BigInt>>;
+#if STRUMPACK_VERSION_MAJOR >= 7
+template class STRUMPACKSolverBase<strumpack::
+                                   SparseSolverMixedPrecisionMPIDist<float, double, HYPRE_BigInt>>;
+#endif
+
 } // mfem namespace
 
 #endif // MFEM_USE_MPI
diff --git a/linalg/strumpack.hpp b/linalg/strumpack.hpp
index 300b8415e..42ae555c7 100644
--- a/linalg/strumpack.hpp
+++ b/linalg/strumpack.hpp
@@ -16,12 +16,14 @@
 
 #ifdef MFEM_USE_STRUMPACK
 #ifdef MFEM_USE_MPI
+
 #include "operator.hpp"
 #include "hypre.hpp"
-
 #include <mpi.h>
 
+// STRUMPACK headers
 #include "StrumpackSparseSolverMPIDist.hpp"
+#include "StrumpackSparseSolverMixedPrecisionMPIDist.hpp"
 
 namespace mfem
 {
@@ -34,63 +36,80 @@ public:
        be of size (local) nrows by (global) glob_ncols. The new parallel matrix
        contains copies of all input arrays (so they can be deleted). */
    STRUMPACKRowLocMatrix(MPI_Comm comm,
-                         int num_loc_rows, int first_loc_row,
-                         int glob_nrows, int glob_ncols,
-                         int *I, int *J, double *data);
+                         int num_loc_rows, HYPRE_BigInt first_loc_row,
+                         HYPRE_BigInt glob_nrows, HYPRE_BigInt glob_ncols,
+                         int *I, HYPRE_BigInt *J, double *data,
+                         bool sym_sparse = false);
 
    /** Creates a copy of the parallel matrix hypParMat in STRUMPACK's RowLoc
        format. All data is copied so the original matrix may be deleted. */
-   STRUMPACKRowLocMatrix(const HypreParMatrix & hypParMat);
+   STRUMPACKRowLocMatrix(const Operator &op, bool sym_sparse = false);
 
    ~STRUMPACKRowLocMatrix();
 
    void Mult(const Vector &x, Vector &y) const
    {
-      mfem_error("STRUMPACKRowLocMatrix::Mult(...)\n"
-                 "  matrix vector products are not supported.");
+      MFEM_ABORT("STRUMPACKRowLocMatrix::Mult: Matrix vector products are not "
+                 "supported!");
    }
 
-   MPI_Comm GetComm() const { return comm_; }
+   MPI_Comm GetComm() const { return A_->comm(); }
 
-   strumpack::CSRMatrixMPI<double,int>* getA() const { return A_; }
+   strumpack::CSRMatrixMPI<double, HYPRE_BigInt> *GetA() const { return A_; }
 
 private:
-   MPI_Comm   comm_;
-   strumpack::CSRMatrixMPI<double,int>* A_;
-
-}; // mfem::STRUMPACKRowLocMatrix
+   strumpack::CSRMatrixMPI<double, HYPRE_BigInt> *A_;
+};
 
 /** The MFEM STRUMPACK Direct Solver class.
 
     The mfem::STRUMPACKSolver class uses the STRUMPACK library to perform LU
     factorization of a parallel sparse matrix. The solver is capable of handling
-    double precision types. See http://portal.nersc.gov/project/sparse/strumpack
+    double precision types. See
+    http://portal.nersc.gov/project/sparse/strumpack/.
 */
-class STRUMPACKSolver : public mfem::Solver
+template <typename STRUMPACKSolverType>
+class STRUMPACKSolverBase : public Solver
 {
-public:
-   // Constructor with MPI_Comm parameter.
-   STRUMPACKSolver( int argc, char* argv[], MPI_Comm comm );
+protected:
+   // Constructor with MPI_Comm parameter and command line arguments.
+   STRUMPACKSolverBase(MPI_Comm comm, int argc, char *argv[]);
 
-   // Constructor with STRUMPACK Matrix Object.
-   STRUMPACKSolver( STRUMPACKRowLocMatrix & A);
+   // Constructor with STRUMPACK matrix object and command line arguments.
+   STRUMPACKSolverBase(STRUMPACKRowLocMatrix &A, int argc, char *argv[]);
 
+public:
    // Default destructor.
-   ~STRUMPACKSolver( void );
+   virtual ~STRUMPACKSolverBase();
 
    // Factor and solve the linear system y = Op^{-1} x.
-   void Mult( const Vector & x, Vector & y ) const;
+   void Mult(const Vector &x, Vector &y) const;
+   void ArrayMult(const Array<const Vector *> &X, Array<Vector *> &Y) const;
 
    // Set the operator.
-   void SetOperator( const Operator & op );
+   void SetOperator(const Operator &op);
 
    // Set various solver options. Refer to STRUMPACK documentation for
    // details.
-   void SetFromCommandLine( );
-   void SetPrintFactorStatistics( bool print_stat );
-   void SetPrintSolveStatistics( bool print_stat );
-   void SetRelTol( double rtol );
-   void SetAbsTol( double atol );
+   void SetFromCommandLine();
+   void SetPrintFactorStatistics(bool print_stat);
+   void SetPrintSolveStatistics(bool print_stat);
+
+   // Set tolerances and iterations for iterative solvers. Compression
+   // tolerance is handled below.
+   void SetRelTol(double rtol);
+   void SetAbsTol(double atol);
+   void SetMaxIter(int max_it);
+
+   // Set the flag controlling reuse of the symbolic factorization for multiple
+   // operators. This method has to be called before repeated calls to
+   // SetOperator.
+   void SetReorderingReuse(bool reuse);
+
+   // Enable or not GPU off-loading available if STRUMPACK was compiled with CUDA. Note
+   // that input/output from MFEM to STRUMPACK is all still through host memory.
+   void EnableGPU();
+   void DisableGPU();
 
    /**
     * STRUMPACK is an (approximate) direct solver. It can be used as a direct
@@ -100,70 +119,153 @@ public:
     * used without preconditioner.
     *
     * Supported values are:
-    *    AUTO:           Use iterative refinement if no HSS compression is used,
-    *                    otherwise use GMRes.
-    *    DIRECT:         No outer iterative solver, just a single application of
-    *                    the multifrontal solver.
-    *    REFINE:         Iterative refinement.
-    *    PREC_GMRES:     Preconditioned GMRes.
-    *                    The preconditioner is the (approx) multifrontal solver.
-    *    GMRES:          UN-preconditioned GMRes. (for testing mainly)
-    *    PREC_BICGSTAB:  Preconditioned BiCGStab.
-    *                    The preconditioner is the (approx) multifrontal solver.
+    *    AUTO:           Use iterative refinement if no HSS compression is
+    *                    used, otherwise use GMRes
+    *    DIRECT:         No outer iterative solver, just a single application
+    *                    of the multifrontal solver
+    *    REFINE:         Iterative refinement
+    *    PREC_GMRES:     Preconditioned GMRes
+    *                    The preconditioner is the (approx) multifrontal solver
+    *    GMRES:          UN-preconditioned GMRes (for testing mainly)
+    *    PREC_BICGSTAB:  Preconditioned BiCGStab
+    *                    The preconditioner is the (approx) multifrontal solver
     *    BICGSTAB:       UN-preconditioned BiCGStab. (for testing mainly)
     */
-   void SetKrylovSolver( strumpack::KrylovSolver method );
+   void SetKrylovSolver(strumpack::KrylovSolver method);
 
    /**
     * Supported reorderings are:
-    *    METIS, PARMETIS, SCOTCH, PTSCOTCH, RCM
+    *    NATURAL:    Do not reorder the system
+    *    METIS:      Use Metis nested-dissection reordering (default)
+    *    PARMETIS:   Use ParMetis nested-dissection reordering
+    *    SCOTCH:     Use Scotch nested-dissection reordering
+    *    PTSCOTCH:   Use PT-Scotch nested-dissection reordering
+    *    RCM:        Use RCM reordering
+    *    GEOMETRIC:  A simple geometric nested dissection code that
+    *                only works for regular meshes
+    *    AMD:        Approximate minimum degree
+    *    MMD:        Multiple minimum degree
+    *    AND:        Nested dissection
+    *    MLF:        Minimum local fill
+    *    SPECTRAL:   Spectral nested dissection
     */
-   void SetReorderingStrategy( strumpack::ReorderingStrategy method );
+   void SetReorderingStrategy(strumpack::ReorderingStrategy method);
 
    /**
-    * Disable static pivoting for stability. The static pivoting in strumpack
+    * Configure static pivoting for stability. The static pivoting in STRUMPACK
     * permutes the sparse input matrix in order to get large (nonzero) elements
     * on the diagonal. If the input matrix is already diagonally dominant, this
     * reordering can be disabled.
+    *
+    * Supported matching algorithms are:
+    *    NONE:                          Don't do anything
+    *    MAX_CARDINALITY:               Maximum cardinality
+    *    MAX_SMALLEST_DIAGONAL:         Maximum smallest diagonal value
+    *    MAX_SMALLEST_DIAGONAL_2:       Same as MAX_SMALLEST_DIAGONAL
+    *                                   but different algorithm
+    *    MAX_DIAGONAL_SUM:              Maximum sum of diagonal values
+    *    MAX_DIAGONAL_PRODUCT_SCALING:  Maximum product of diagonal values
+    *                                   and row and column scaling (default)
+    *    COMBBLAS:                      Use AWPM from CombBLAS (only with
+    *                                   version >= 3)
     */
-   void DisableMatching();
-
-   /**
-    * Enable static pivoting for stability using the MC64 algorithm with
-    * job=5. Using a matching algorithm, this will permute the sparse input
-    * matrix in order to get nonzero elements (as large as possible) on the
-    * diagonal. And will also scale the rows and columns of the matrix.
-    */
-   void EnableMatching();
+   void SetMatching(strumpack::MatchingJob job);
 
-#if STRUMPACK_VERSION_MAJOR >= 3
    /**
-    * Use the AWPM (approximate weight perfect matching) algorithm from the
-    * Combinatorial BLAS library for static pivoting, i.e. getting large
-    * nonzeros on the diagonal. This requires that strumpack was compiled with
-    * support for Combinatorial BLAS.
+    * Enable support for rank-structured data formats, which can be used
+    * for compression within the sparse solver.
+    *
+    * Supported compression types are:
+    *    NONE:           No compression, purely direct solver (default)
+    *    HSS:            HSS compression of frontal matrices
+    *    BLR:            Block low-rank compression of fronts
+    *    HODLR:          Hierarchically Off-diagonal Low-Rank
+    *                    compression of frontal matrices
+    *    BLR_HODLR:      Block low-rank compression of medium
+    *                    fronts and Hierarchically Off-diagonal
+    *                    Low-Rank compression of large fronts
+    *    ZFP_BLR_HODLR:  ZFP compression for small fronts,
+    *                    Block low-rank compression of medium
+    *                    fronts and Hierarchically Off-diagonal
+    *                    Low-Rank compression of large fronts
+    *    LOSSLESS:       Lossless compression
+    *    LOSSY:          Lossy compression
+    *
+    * For versions of STRUMPACK < 5, we support only NONE, HSS, and BLR.
+    * BLR_HODLR and ZPR_BLR_HODLR are supported in STRUMPACK >= 6.
     */
-   void EnableParallelMatching();
+   void SetCompression(strumpack::CompressionType type);
+   void SetCompressionRelTol(double rtol);
+   void SetCompressionAbsTol(double atol);
+#if STRUMPACK_VERSION_MAJOR >= 5
+   void SetCompressionLossyPrecision(int precision);
+   void SetCompressionButterflyLevels(int levels);
 #endif
 
 private:
-   void Init( int argc, char* argv[] );
+   // Helper method for calling the STRUMPACK factoriation routine.
+   void FactorInternal() const;
 
 protected:
-
-   MPI_Comm      comm_;
-   int           numProcs_;
-   int           myid_;
+   const STRUMPACKRowLocMatrix *APtr_;
+   STRUMPACKSolverType         *solver_;
 
    bool factor_verbose_;
    bool solve_verbose_;
+   bool reorder_reuse_;
+
+   mutable Vector rhs_, sol_;
+   mutable int    nrhs_;
+};
 
-   const STRUMPACKRowLocMatrix * APtr_;
-   strumpack::StrumpackSparseSolverMPIDist<double,int> * solver_;
+class STRUMPACKSolver :
+   public STRUMPACKSolverBase<strumpack::
+   SparseSolverMPIDist<double, HYPRE_BigInt>>
+{
+public:
+   // Constructor with MPI_Comm parameter.
+   STRUMPACKSolver(MPI_Comm comm);
+
+   // Constructor with STRUMPACK matrix object.
+   STRUMPACKSolver(STRUMPACKRowLocMatrix &A);
 
-}; // mfem::STRUMPACKSolver class
+   // Constructor with MPI_Comm parameter and command line arguments.
+   STRUMPACKSolver(MPI_Comm comm, int argc, char *argv[]);
+   MFEM_DEPRECATED STRUMPACKSolver(int argc, char *argv[], MPI_Comm comm)
+      : STRUMPACKSolver(comm, argc, argv) {}
+
+   // Constructor with STRUMPACK matrix object and command line arguments.
+   STRUMPACKSolver(STRUMPACKRowLocMatrix &A, int argc, char *argv[]);
+
+   // Destructor.
+   ~STRUMPACKSolver() {}
+};
+
+#if STRUMPACK_VERSION_MAJOR >= 7
+class STRUMPACKMixedPrecisionSolver :
+   public STRUMPACKSolverBase<strumpack::
+   SparseSolverMixedPrecisionMPIDist<float, double, HYPRE_BigInt>>
+{
+public:
+   // Constructor with MPI_Comm parameter.
+   STRUMPACKMixedPrecisionSolver(MPI_Comm comm);
+
+   // Constructor with STRUMPACK matrix object.
+   STRUMPACKMixedPrecisionSolver(STRUMPACKRowLocMatrix &A);
+
+   // Constructor with MPI_Comm parameter and command line arguments.
+   STRUMPACKMixedPrecisionSolver(MPI_Comm comm, int argc, char *argv[]);
+
+   // Constructor with STRUMPACK matrix object and command line arguments.
+   STRUMPACKMixedPrecisionSolver(STRUMPACKRowLocMatrix &A,
+                                 int argc, char *argv[]);
+
+   // Destructor.
+   ~STRUMPACKMixedPrecisionSolver() {}
+};
+#endif
 
-} // mfem namespace
+} // namespace mfem
 
 #endif // MFEM_USE_MPI
 #endif // MFEM_USE_STRUMPACK
diff --git a/miniapps/multidomain/multidomain.cpp b/miniapps/multidomain/multidomain.cpp
index dfb669224..83ebb9813 100644
--- a/miniapps/multidomain/multidomain.cpp
+++ b/miniapps/multidomain/multidomain.cpp
@@ -322,17 +322,19 @@ int main(int argc, char *argv[])
 
    char vishost[] = "localhost";
    int  visport   = 19916;
-   socketstream cyl_sol_sock(vishost, visport);
+   socketstream cyl_sol_sock;
    if (visualization)
    {
+      cyl_sol_sock.open(vishost, visport);
       cyl_sol_sock << "parallel " << num_procs << " " << myid << "\n";
       cyl_sol_sock.precision(8);
       cyl_sol_sock << "solution\n" << cylinder_submesh << temperature_cylinder_gf <<
                    "pause\n" << std::flush;
    }
-   socketstream block_sol_sock(vishost, visport);
+   socketstream block_sol_sock;
    if (visualization)
    {
+      block_sol_sock.open(vishost, visport);
       block_sol_sock << "parallel " << num_procs << " " << myid << "\n";
       block_sol_sock.precision(8);
       block_sol_sock << "solution\n" << block_submesh << temperature_block_gf <<
diff --git a/miniapps/nurbs/nurbs_ex11p.cpp b/miniapps/nurbs/nurbs_ex11p.cpp
index 7b8e3bd2d..e5cf95062 100644
--- a/miniapps/nurbs/nurbs_ex11p.cpp
+++ b/miniapps/nurbs/nurbs_ex11p.cpp
@@ -281,12 +281,13 @@ int main(int argc, char *argv[])
 #ifdef MFEM_USE_STRUMPACK
       if (sp_solver)
       {
-         STRUMPACKSolver * strumpack = new STRUMPACKSolver(argc, argv, MPI_COMM_WORLD);
+         STRUMPACKSolver * strumpack = new STRUMPACKSolver(MPI_COMM_WORLD, argc, argv);
          strumpack->SetPrintFactorStatistics(true);
          strumpack->SetPrintSolveStatistics(false);
          strumpack->SetKrylovSolver(strumpack::KrylovSolver::DIRECT);
          strumpack->SetReorderingStrategy(strumpack::ReorderingStrategy::METIS);
-         strumpack->DisableMatching();
+         strumpack->SetMatching(strumpack::MatchingJob::NONE);
+         strumpack->SetCompression(strumpack::CompressionType::NONE);
          strumpack->SetOperator(*Arow);
          strumpack->SetFromCommandLine();
          precond = strumpack;
diff --git a/tests/unit/linalg/test_direct_solvers.cpp b/tests/unit/linalg/test_direct_solvers.cpp
index 48a1ac30e..5b74a98fa 100644
--- a/tests/unit/linalg/test_direct_solvers.cpp
+++ b/tests/unit/linalg/test_direct_solvers.cpp
@@ -26,6 +26,9 @@ using namespace mfem;
 #ifdef MFEM_USE_SUPERLU
 #define DIRECT_SOLVE_PARALLEL
 #endif
+#ifdef MFEM_USE_STRUMPACK
+#define DIRECT_SOLVE_PARALLEL
+#endif
 
 #if defined(DIRECT_SOLVE_SERIAL) || defined(DIRECT_SOLVE_PARALLEL)
 
@@ -103,7 +106,7 @@ TEST_CASE("Serial Direct Solvers", "[CUDA]")
       Mesh mesh;
       if (dim == 1)
       {
-         mesh = Mesh::MakeCartesian1D(ne,  1.0);
+         mesh = Mesh::MakeCartesian1D(ne, 1.0);
       }
       else if (dim == 2)
       {
@@ -187,13 +190,13 @@ TEST_CASE("Parallel Direct Solvers", "[Parallel], [CUDA]")
 {
    int rank;
    MPI_Comm_rank(MPI_COMM_WORLD, &rank);
-   const int ne = 2;
+   const int ne = 4;
    for (int dim = 1; dim < 4; ++dim)
    {
       Mesh mesh;
       if (dim == 1)
       {
-         mesh = Mesh::MakeCartesian1D(ne,  1.0);
+         mesh = Mesh::MakeCartesian1D(ne, 1.0);
       }
       else if (dim == 2)
       {
@@ -312,6 +315,39 @@ TEST_CASE("Parallel Direct Solvers", "[Parallel], [CUDA]")
          REQUIRE(error < 1.e-12);
       }
 #endif
+#ifdef MFEM_USE_STRUMPACK
+      // Transform to monolithic HypreParMatrix
+      {
+         STRUMPACKRowLocMatrix SA(*A.As<HypreParMatrix>());
+         STRUMPACKSolver strumpack(MPI_COMM_WORLD);
+         strumpack.SetPrintFactorStatistics(false);
+         strumpack.SetPrintSolveStatistics(false);
+         strumpack.SetKrylovSolver(strumpack::KrylovSolver::DIRECT);
+         strumpack.SetReorderingStrategy(dim > 1 ? strumpack::ReorderingStrategy::METIS :
+                                         strumpack::ReorderingStrategy::NATURAL);
+         strumpack.SetOperator(SA);
+         strumpack.Mult(B, X);
+
+         Vector Y(X.Size());
+         A->Mult(X, Y);
+         Y -= B;
+         REQUIRE(Y.Norml2() < 1.e-12);
+
+         strumpack.ArrayMult(BB, XX);
+
+         for (int i = 0; i < XX.Size(); i++)
+         {
+            A->Mult(*XX[i], Y);
+            Y -= *BB[i];
+            REQUIRE(Y.Norml2() < 1.e-12);
+         }
+
+         a.RecoverFEMSolution(X, b, x);
+         VectorFunctionCoefficient grad(dim, gradexact);
+         double error = x.ComputeH1Error(&uex, &grad);
+         REQUIRE(error < 1.e-12);
+      }
+#endif
    }
 }
 
