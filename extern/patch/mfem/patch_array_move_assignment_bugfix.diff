diff --git a/general/array.hpp b/general/array.hpp
index 8ea01dbd8b..cefe92d3cb 100644
--- a/general/array.hpp
+++ b/general/array.hpp
@@ -114,11 +114,25 @@ public:
    Array<T> &operator=(const Array<T> &src) { src.Copy(*this); return *this; }
 
    /// Move assignment operator
+   /** If this Array is a non-owning view (e.g., from MakeRef), the data is
+       copied instead of moved to preserve the view semantics. */
    Array<T> &operator=(Array<T> &&src)
    {
       if (this == &src) { return *this; }
-      Swap(src);  // Swap does not use move assignment!
-      src.DeleteAll();
+      // If this is a view (non-owning), we must copy data into the external
+      // storage rather than replacing the data pointer via move semantics.
+      if (!OwnsData())
+      {
+         // Convert rvalue to lvalue to force invoke copy assignment
+         *this = static_cast<Array<T>&>(src);
+         src.DeleteAll();  // Leave src in valid moved-from state
+      }
+      else
+      {
+         // Default move semantics for owning arrays
+         Swap(src);
+         src.DeleteAll();
+      }
       return *this;
    }
 
diff --git a/tests/unit/general/test_array.cpp b/tests/unit/general/test_array.cpp
index de88b18e28..0ed86984f4 100644
--- a/tests/unit/general/test_array.cpp
+++ b/tests/unit/general/test_array.cpp
@@ -125,6 +125,83 @@ TEST_CASE("Array stl-interactions", "[Array]")
    }
 }
 
+
+TEST_CASE("Array move assignment to view (MakeRef)", "[Array]")
+{
+   constexpr int n = 5;
+
+   // Helper function that returns an Array by value (rvalue)
+   auto make_sequence_array = [](int n)
+   {
+      Array<int> arr(n);
+      for (int i = 0; i < n; i++)
+      {
+         arr[i] = i + 1;  // 1, 2, 3, ...
+      }
+      return arr;
+   }
+
+   SECTION("Move assignment from rvalue to Array view")
+   {
+      // Create backing storage
+      Array<int> backing(n);
+      backing = 0.0;
+
+      // Create a view into the backing storage
+      Array<int> view;
+      view.MakeRef(backing);
+
+      // Assign from rvalue - this triggers move assignment
+      view = make_sequence_array(n);
+
+      // The backing storage should now contain [1, 2, 3, 4, 5]
+      // Without falling back to copy assignment, this would error.
+      for (int i = 0; i < n; i++)
+      {
+         CHECK(backing[i] == i + 1);
+      }
+   }
+
+   SECTION("Copy assignment from lvalue to Array view - workaround")
+   {
+      // Create backing storage
+      Array<int> backing(n);
+      backing = 0.0;
+
+      // Create a view into the backing storage
+      Array<int> view;
+      view.MakeRef(backing);
+
+      // Workaround: Store in local variable first (forces copy assignment)
+      Array<int> temp = make_sequence_array(n);
+      view = temp;
+
+      for (int i = 0; i < n; i++)
+      {
+         CHECK(backing[i] == i + 1);
+      }
+   }
+
+   SECTION("MakeRef with raw pointer")
+   {
+      // Create backing storage as raw array
+      int backing[n] = {0, 0, 0, 0, 0};
+
+      // Create a view into the backing storage
+      Array<int> view;
+      view.MakeRef(backing, n);
+
+      // Assign from rvalue
+      view = MakeSequenceArray(n);
+
+      // The backing storage should now contain [1, 2, 3, 4, 5]
+      for (int i = 0; i < n; i++)
+      {
+         CHECK(backing[i] == i + 1);
+      }
+   }
+}
+
 TEST_CASE("Array delete at indices", "[Array],[GPU]")
 {
    for (int use_dev = 0; use_dev < 2; use_dev++)
diff --git a/tests/unit/linalg/test_matrix_dense.cpp b/tests/unit/linalg/test_matrix_dense.cpp
index 0e3422711d..1c22de160e 100644
--- a/tests/unit/linalg/test_matrix_dense.cpp
+++ b/tests/unit/linalg/test_matrix_dense.cpp
@@ -961,3 +961,70 @@ TEST_CASE("NNLS", "[DenseMatrix]")
 }
 
 #endif // if MFEM_USE_LAPACK
+
+TEST_CASE("DenseMatrix assignment to DenseTensor view",
+          "[DenseMatrix][DenseTensor]")
+{
+   // This test demonstrates a bug in DenseMatrix move assignment when
+   // the target is a non-owning view (e.g., from DenseTensor::operator()).
+   //
+   // The bug: When move-assigning to a DenseTensor view, the Array move
+   // assignment does Swap() then DeleteAll(), which replaces the view's
+   // data pointer instead of copying data into the external storage.
+   // The DenseTensor's memory is never written to.
+
+   auto make_identity_matrix = [](int n)
+   {
+      DenseMatrix M(n, n);
+      M = 0.0;
+      for (int i = 0; i < n; i++)
+         for (int j = 0; j < n; j++)
+         {
+            M(i, j) = i+j*n+1;
+         }
+      return M;
+   };
+
+   constexpr int n = 3;
+   constexpr int k = 2;
+
+   DenseTensor tensor(n, n, k);
+   tensor = 0.0;
+
+   SECTION("Move assignment from rvalue to DenseTensor view")
+   {
+      // Get a view to tensor slice 0 and assign from rvalue
+      // This triggers move assignment: view = MakeIdentityMatrix(n)
+      tensor(0) = make_identity_matrix(n);
+
+      // The tensor's memory should now contain the identity matrix
+      // BUG: With the current implementation, the tensor's memory is NOT updated!
+      // The move assignment replaces the view's data pointer instead of copying.
+
+      // Check that the tensor was actually updated
+      for (int i = 0; i < n; i++)
+      {
+         for (int j = 0; j < n; j++)
+         {
+            CHECK(tensor(i, j, 0) == i + j*n + 1);
+         }
+      }
+   }
+
+   SECTION("Copy assignment from lvalue to DenseTensor view")
+   {
+      // Get a view to tensor slice 0 and assign from rvalue
+      // This triggers move assignment: view = MakeIdentityMatrix(n)
+      DenseMatrix temp = make_identity_matrix(n);
+      tensor(0) = temp;
+
+      // Check that the tensor was actually updated
+      for (int i = 0; i < n; i++)
+      {
+         for (int j = 0; j < n; j++)
+         {
+            CHECK(tensor(i, j, 0) == i + j*n + 1);
+         }
+      }
+   }
+}
