diff --git a/CMakeLists.txt b/CMakeLists.txt
index e9e6ae0b7..967c7de98 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -218,10 +218,7 @@ if (MFEM_USE_HIP)
 endif()
 
 # OpenMP
-if (MFEM_USE_OPENMP OR MFEM_USE_LEGACY_OPENMP)
-  if (NOT MFEM_THREAD_SAFE AND MFEM_USE_LEGACY_OPENMP)
-    message(FATAL_ERROR " *** MFEM_USE_LEGACY_OPENMP requires MFEM_THREAD_SAFE=ON.")
-  endif()
+if (MFEM_USE_OPENMP)
   find_package(OpenMP REQUIRED)
   set(OPENMP_LIBRARIES ${OpenMP_CXX_LIBRARIES})
   if(APPLE)
diff --git a/INSTALL b/INSTALL
index cb092cc1b..e48618821 100644
--- a/INSTALL
+++ b/INSTALL
@@ -309,10 +309,6 @@ MFEM_THREAD_SAFE = YES/NO
    Use thread-safe implementation for some classes/methods. This comes at the
    cost of extra memory allocation and de-allocation.
 
-MFEM_USE_LEGACY_OPENMP = YES/NO
-   Enable (basic) experimental OpenMP support. Requires MFEM_THREAD_SAFE.
-   This option is deprecated.
-
 MFEM_USE_OPENMP = YES/NO
    Enable the OpenMP backend.
 
@@ -611,8 +607,8 @@ The specific libraries and their options are:
        http://math-atlas.sourceforge.net (ATLAS)
   Options: LAPACK_OPT (currently not used/needed), LAPACK_LIB.
 
-- OpenMP (optional), usually part of compiler, used when either MFEM_USE_OPENMP
-  or MFEM_USE_LEGACY_OPENMP is set to YES.
+- OpenMP (optional), usually part of compiler, used when MFEM_USE_OPENMP is set
+  to YES.
   Options: OPENMP_OPT, OPENMP_LIB.
 
 - High-resolution POSIX clocks: when using MFEM_TIMER_TYPE = 2, it may be
@@ -956,7 +952,6 @@ MFEM_USE_METIS - Set to ${MFEM_USE_MPI}, can be overwritten.
 MFEM_USE_LIBUNWIND
 MFEM_USE_LAPACK
 MFEM_THREAD_SAFE
-MFEM_USE_LEGACY_OPENMP
 MFEM_USE_OPENMP
 MFEM_USE_MEMALLOC
 MFEM_TIMER_TYPE - Set automatically, can be overwritten.
diff --git a/config/cmake/MFEMConfig.cmake.in b/config/cmake/MFEMConfig.cmake.in
index 9d5eef52f..43b6d0671 100644
--- a/config/cmake/MFEMConfig.cmake.in
+++ b/config/cmake/MFEMConfig.cmake.in
@@ -25,7 +25,6 @@ set(MFEM_USE_LIBUNWIND @MFEM_USE_LIBUNWIND@)
 set(MFEM_USE_LAPACK @MFEM_USE_LAPACK@)
 set(MFEM_THREAD_SAFE @MFEM_THREAD_SAFE@)
 set(MFEM_USE_OPENMP @MFEM_USE_OPENMP@)
-set(MFEM_USE_LEGACY_OPENMP @MFEM_USE_LEGACY_OPENMP@)
 set(MFEM_USE_MEMALLOC @MFEM_USE_MEMALLOC@)
 set(MFEM_TIMER_TYPE @MFEM_TIMER_TYPE@)
 set(MFEM_USE_SUNDIALS @MFEM_USE_SUNDIALS@)
diff --git a/config/cmake/config.hpp.in b/config/cmake/config.hpp.in
index adde511fb..347354b04 100644
--- a/config/cmake/config.hpp.in
+++ b/config/cmake/config.hpp.in
@@ -74,9 +74,6 @@
 // Enable the OpenMP backend.
 #cmakedefine MFEM_USE_OPENMP
 
-// [Deprecated] Enable experimental OpenMP support. Requires MFEM_THREAD_SAFE.
-#cmakedefine MFEM_USE_LEGACY_OPENMP
-
 // Internal MFEM option: enable group/batch allocation for some small objects.
 #cmakedefine MFEM_USE_MEMALLOC
 
diff --git a/config/cmake/modules/MfemCmakeUtilities.cmake b/config/cmake/modules/MfemCmakeUtilities.cmake
index 204b7d87f..9a629330b 100644
--- a/config/cmake/modules/MfemCmakeUtilities.cmake
+++ b/config/cmake/modules/MfemCmakeUtilities.cmake
@@ -843,16 +843,16 @@ function(mfem_export_mk_files)
   # Convert Boolean vars to YES/NO without writing the values to cache
   set(CONFIG_MK_BOOL_VARS MFEM_USE_MPI MFEM_USE_METIS MFEM_USE_METIS_5
       MFEM_DEBUG MFEM_USE_EXCEPTIONS MFEM_USE_ZLIB MFEM_USE_LIBUNWIND
-      MFEM_USE_LAPACK MFEM_THREAD_SAFE MFEM_USE_LEGACY_OPENMP MFEM_USE_OPENMP
-      MFEM_USE_MEMALLOC MFEM_USE_SUNDIALS MFEM_USE_SUITESPARSE
-      MFEM_USE_SUPERLU MFEM_USE_SUPERLU5 MFEM_USE_MUMPS MFEM_USE_STRUMPACK
-      MFEM_USE_GINKGO MFEM_USE_AMGX MFEM_USE_GNUTLS MFEM_USE_NETCDF
-      MFEM_USE_PETSC MFEM_USE_SLEPC MFEM_USE_MPFR MFEM_USE_SIDRE MFEM_USE_FMS
-      MFEM_USE_CONDUIT MFEM_USE_PUMI MFEM_USE_HIOP MFEM_USE_GSLIB MFEM_USE_CUDA
-      MFEM_USE_HIP MFEM_USE_RAJA MFEM_USE_OCCA MFEM_USE_CEED MFEM_USE_CALIPER
-      MFEM_USE_UMPIRE MFEM_USE_SIMD MFEM_USE_ADIOS2 MFEM_USE_MKL_CPARDISO
-      MFEM_USE_ADFORWARD MFEM_USE_CODIPACK MFEM_USE_BENCHMARK MFEM_USE_PARELAG
-      MFEM_USE_MOONOLITH MFEM_USE_ALGOIM MFEM_USE_ENZYME)
+      MFEM_USE_LAPACK MFEM_THREAD_SAFE MFEM_USE_OPENMP MFEM_USE_MEMALLOC
+      MFEM_USE_SUNDIALS MFEM_USE_SUITESPARSE MFEM_USE_SUPERLU MFEM_USE_SUPERLU5
+      MFEM_USE_MUMPS MFEM_USE_STRUMPACK MFEM_USE_GINKGO MFEM_USE_AMGX
+      MFEM_USE_GNUTLS MFEM_USE_NETCDF MFEM_USE_PETSC MFEM_USE_SLEPC
+      MFEM_USE_MPFR MFEM_USE_SIDRE MFEM_USE_FMS MFEM_USE_CONDUIT MFEM_USE_PUMI
+      MFEM_USE_HIOP MFEM_USE_GSLIB MFEM_USE_CUDA MFEM_USE_HIP MFEM_USE_RAJA
+      MFEM_USE_OCCA MFEM_USE_CEED MFEM_USE_CALIPER MFEM_USE_UMPIRE
+      MFEM_USE_SIMD MFEM_USE_ADIOS2 MFEM_USE_MKL_CPARDISO MFEM_USE_ADFORWARD
+      MFEM_USE_CODIPACK MFEM_USE_BENCHMARK MFEM_USE_PARELAG MFEM_USE_MOONOLITH
+      MFEM_USE_ALGOIM MFEM_USE_ENZYME)
   foreach(var ${CONFIG_MK_BOOL_VARS})
     if (${var})
       set(${var} YES)
diff --git a/config/config.hpp.in b/config/config.hpp.in
index 7a737720e..638c9e96d 100644
--- a/config/config.hpp.in
+++ b/config/config.hpp.in
@@ -74,9 +74,6 @@
 // Enable the OpenMP backend.
 // #define MFEM_USE_OPENMP
 
-// [Deprecated] Enable experimental OpenMP support. Requires MFEM_THREAD_SAFE.
-// #define MFEM_USE_LEGACY_OPENMP
-
 // Internal MFEM option: enable group/batch allocation for some small objects.
 // #define MFEM_USE_MEMALLOC
 
diff --git a/config/config.mk.in b/config/config.mk.in
index baf5c2955..8858d01b8 100644
--- a/config/config.mk.in
+++ b/config/config.mk.in
@@ -24,7 +24,6 @@ MFEM_USE_ZLIB          = @MFEM_USE_ZLIB@
 MFEM_USE_LIBUNWIND     = @MFEM_USE_LIBUNWIND@
 MFEM_USE_LAPACK        = @MFEM_USE_LAPACK@
 MFEM_THREAD_SAFE       = @MFEM_THREAD_SAFE@
-MFEM_USE_LEGACY_OPENMP = @MFEM_USE_LEGACY_OPENMP@
 MFEM_USE_OPENMP        = @MFEM_USE_OPENMP@
 MFEM_USE_MEMALLOC      = @MFEM_USE_MEMALLOC@
 MFEM_TIMER_TYPE        = @MFEM_TIMER_TYPE@
diff --git a/config/defaults.cmake b/config/defaults.cmake
index 390026414..cc83ef98a 100644
--- a/config/defaults.cmake
+++ b/config/defaults.cmake
@@ -28,7 +28,6 @@ option(MFEM_USE_LIBUNWIND "Enable backtrace for errors." OFF)
 option(MFEM_USE_LAPACK "Enable LAPACK usage" OFF)
 option(MFEM_THREAD_SAFE "Enable thread safety" OFF)
 option(MFEM_USE_OPENMP "Enable the OpenMP backend" OFF)
-option(MFEM_USE_LEGACY_OPENMP "Enable legacy OpenMP usage" OFF)
 option(MFEM_USE_MEMALLOC "Enable the internal MEMALLOC option." ON)
 option(MFEM_USE_SUNDIALS "Enable SUNDIALS usage" OFF)
 option(MFEM_USE_SUITESPARSE "Enable SuiteSparse usage" OFF)
diff --git a/config/defaults.mk b/config/defaults.mk
index e149ae452..00d149e68 100644
--- a/config/defaults.mk
+++ b/config/defaults.mk
@@ -127,7 +127,6 @@ MFEM_USE_LIBUNWIND     = NO
 MFEM_USE_LAPACK        = NO
 MFEM_THREAD_SAFE       = NO
 MFEM_USE_OPENMP        = NO
-MFEM_USE_LEGACY_OPENMP = NO
 MFEM_USE_MEMALLOC      = YES
 MFEM_TIMER_TYPE        = $(if $(NOTMAC),2,4)
 MFEM_USE_SUNDIALS      = NO
diff --git a/fem/bilinearform.cpp b/fem/bilinearform.cpp
index fad9717aa..a549d03a7 100644
--- a/fem/bilinearform.cpp
+++ b/fem/bilinearform.cpp
@@ -18,84 +18,31 @@
 namespace mfem
 {
 
-void BilinearForm::AllocMat()
-{
-   if (static_cond) { return; }
-
-   if (precompute_sparsity == 0 || fes->GetVDim() > 1)
-   {
-      mat = new SparseMatrix(height);
-      return;
-   }
-
-   const Table &elem_dof = fes->GetElementToDofTable();
-   Table dof_dof;
-
-   if (interior_face_integs.Size() > 0)
-   {
-      // the sparsity pattern is defined from the map: face->element->dof
-      Table face_dof, dof_face;
-      {
-         Table *face_elem = fes->GetMesh()->GetFaceToElementTable();
-         mfem::Mult(*face_elem, elem_dof, face_dof);
-         delete face_elem;
-      }
-      Transpose(face_dof, dof_face, height);
-      mfem::Mult(dof_face, face_dof, dof_dof);
-   }
-   else
-   {
-      // the sparsity pattern is defined from the map: element->dof
-      Table dof_elem;
-      Transpose(elem_dof, dof_elem, height);
-      mfem::Mult(dof_elem, elem_dof, dof_dof);
-   }
-
-   dof_dof.SortRows();
-
-   int *I = dof_dof.GetI();
-   int *J = dof_dof.GetJ();
-   double *data = Memory<double>(I[height]);
-
-   mat = new SparseMatrix(I, J, data, height, height, true, true, true);
-   *mat = 0.0;
-
-   dof_dof.LoseData();
-}
-
-BilinearForm::BilinearForm(FiniteElementSpace * f)
-   : Matrix (f->GetVSize())
+BilinearForm::BilinearForm(FiniteElementSpace *f)
+   : Matrix(f->GetVSize())
 {
    fes = f;
    sequence = f->GetSequence();
    mat = mat_e = NULL;
    extern_bfs = 0;
-   element_matrices = NULL;
    static_cond = NULL;
    hybridization = NULL;
-   precompute_sparsity = 0;
    diag_policy = DIAG_KEEP;
-
    assembly = AssemblyLevel::LEGACY;
-   batch = 1;
    ext = NULL;
 }
 
-BilinearForm::BilinearForm (FiniteElementSpace * f, BilinearForm * bf, int ps)
-   : Matrix (f->GetVSize())
+BilinearForm::BilinearForm(FiniteElementSpace *f, BilinearForm *bf)
+   : Matrix(f->GetVSize())
 {
    fes = f;
    sequence = f->GetSequence();
-   mat_e = NULL;
+   mat = mat_e = NULL;
    extern_bfs = 1;
-   element_matrices = NULL;
    static_cond = NULL;
    hybridization = NULL;
-   precompute_sparsity = ps;
    diag_policy = DIAG_KEEP;
-
    assembly = AssemblyLevel::LEGACY;
-   batch = 1;
    ext = NULL;
 
    // Copy the pointers to the integrators
@@ -108,8 +55,6 @@ BilinearForm::BilinearForm (FiniteElementSpace * f, BilinearForm * bf, int ps)
 
    boundary_face_integs = bf->boundary_face_integs;
    boundary_face_integs_marker = bf->boundary_face_integs_marker;
-
-   AllocMat();
 }
 
 void BilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
@@ -124,7 +69,7 @@ void BilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
       case AssemblyLevel::LEGACY:
          break;
       case AssemblyLevel::FULL:
-         SetDiagonalPolicy( DIAG_ONE ); // Only diagonal policy supported on device
+         SetDiagonalPolicy(DIAG_ONE); // Only diagonal policy supported on device
          ext = new FABilinearFormExtension(this);
          break;
       case AssemblyLevel::ELEMENT:
@@ -181,48 +126,71 @@ void BilinearForm::EnableHybridization(FiniteElementSpace *constr_space,
    hybridization->Init(ess_tdof_list);
 }
 
-void BilinearForm::UseSparsity(int *I, int *J, bool isSorted)
+double &BilinearForm::Elem(int i, int j)
 {
-   if (static_cond) { return; }
+   return mat->Elem(i,j);
+}
+
+const double &BilinearForm::Elem(int i, int j) const
+{
+   return mat->Elem(i,j);
+}
 
-   if (mat)
+void BilinearForm::Mult(const Vector &x, Vector &y) const
+{
+   if (ext)
    {
-      if (mat->Finalized() && mat->GetI() == I && mat->GetJ() == J)
-      {
-         return; // mat is already using the given sparsity
-      }
-      delete mat;
+      ext->Mult(x, y);
+   }
+   else
+   {
+      mat->Mult(x, y);
    }
-   height = width = fes->GetVSize();
-   mat = new SparseMatrix(I, J, NULL, height, width, false, true, isSorted);
 }
 
-void BilinearForm::UseSparsity(SparseMatrix &A)
+void BilinearForm::AddMult(const Vector &x, Vector &y, const double a) const
 {
-   MFEM_ASSERT(A.Height() == fes->GetVSize() && A.Width() == fes->GetVSize(),
-               "invalid matrix A dimensions: "
-               << A.Height() << " x " << A.Width());
-   MFEM_ASSERT(A.Finalized(), "matrix A must be Finalized");
-
-   UseSparsity(A.GetI(), A.GetJ(), A.ColumnsAreSorted());
+   if (ext)
+   {
+      ext->AddMult(x, y, a);
+   }
+   else
+   {
+      mat->AddMult(x, y, a);
+   }
 }
 
-double& BilinearForm::Elem (int i, int j)
+void BilinearForm::MultTranspose(const Vector &x, Vector &y) const
 {
-   return mat -> Elem(i,j);
+   if (ext)
+   {
+      ext->MultTranspose(x, y);
+   }
+   else
+   {
+      mat->MultTranspose(x, y);
+   }
 }
 
-const double& BilinearForm::Elem (int i, int j) const
+void BilinearForm::AddMultTranspose(const Vector &x, Vector &y,
+                                    const double a) const
 {
-   return mat -> Elem(i,j);
+   if (ext)
+   {
+      ext->AddMultTranspose(x, y, a);
+   }
+   else
+   {
+      mat->AddMultTranspose(x, y, a);
+   }
 }
 
-MatrixInverse * BilinearForm::Inverse() const
+MatrixInverse *BilinearForm::Inverse() const
 {
-   return mat -> Inverse();
+   return mat->Inverse();
 }
 
-void BilinearForm::Finalize (int skip_zeros)
+void BilinearForm::Finalize(int skip_zeros)
 {
    if (assembly == AssemblyLevel::LEGACY)
    {
@@ -246,22 +214,22 @@ void BilinearForm::AddDomainIntegrator(BilinearFormIntegrator *bfi,
    domain_integs_marker.Append(&elem_marker);
 }
 
-void BilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi)
+void BilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(NULL); // NULL marker means apply everywhere
 }
 
-void BilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi,
-                                          Array<int> &bdr_marker)
+void BilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi,
+                                         Array<int> &bdr_marker)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(&bdr_marker);
 }
 
-void BilinearForm::AddInteriorFaceIntegrator(BilinearFormIntegrator * bfi)
+void BilinearForm::AddInteriorFaceIntegrator(BilinearFormIntegrator *bfi)
 {
-   interior_face_integs.Append (bfi);
+   interior_face_integs.Append(bfi);
 }
 
 void BilinearForm::AddBdrFaceIntegrator(BilinearFormIntegrator *bfi)
@@ -278,55 +246,6 @@ void BilinearForm::AddBdrFaceIntegrator(BilinearFormIntegrator *bfi,
    boundary_face_integs_marker.Append(&bdr_marker);
 }
 
-void BilinearForm::ComputeElementMatrix(int i, DenseMatrix &elmat)
-{
-   if (element_matrices)
-   {
-      elmat.SetSize(element_matrices->SizeI(), element_matrices->SizeJ());
-      elmat = element_matrices->GetData(i);
-      return;
-   }
-
-   if (domain_integs.Size())
-   {
-      const FiniteElement &fe = *fes->GetFE(i);
-      ElementTransformation *eltrans = fes->GetElementTransformation(i);
-      domain_integs[0]->AssembleElementMatrix(fe, *eltrans, elmat);
-      for (int k = 1; k < domain_integs.Size(); k++)
-      {
-         domain_integs[k]->AssembleElementMatrix(fe, *eltrans, elemmat);
-         elmat += elemmat;
-      }
-   }
-   else
-   {
-      fes->GetElementVDofs(i, vdofs);
-      elmat.SetSize(vdofs.Size());
-      elmat = 0.0;
-   }
-}
-
-void BilinearForm::ComputeBdrElementMatrix(int i, DenseMatrix &elmat)
-{
-   if (boundary_integs.Size())
-   {
-      const FiniteElement &be = *fes->GetBE(i);
-      ElementTransformation *eltrans = fes->GetBdrElementTransformation(i);
-      boundary_integs[0]->AssembleElementMatrix(be, *eltrans, elmat);
-      for (int k = 1; k < boundary_integs.Size(); k++)
-      {
-         boundary_integs[k]->AssembleElementMatrix(be, *eltrans, elemmat);
-         elmat += elemmat;
-      }
-   }
-   else
-   {
-      fes->GetBdrElementVDofs(i, vdofs);
-      elmat.SetSize(vdofs.Size());
-      elmat = 0.0;
-   }
-}
-
 void BilinearForm::AssembleElementMatrix(
    int i, const DenseMatrix &elmat, int skip_zeros)
 {
@@ -345,7 +264,7 @@ void BilinearForm::AssembleElementMatrix(
    {
       if (mat == NULL)
       {
-         AllocMat();
+         mat = new SparseMatrix(height);
       }
       mat->AddSubMatrix(vdofs_, vdofs_, elmat, skip_zeros);
       if (hybridization)
@@ -373,7 +292,7 @@ void BilinearForm::AssembleBdrElementMatrix(
    {
       if (mat == NULL)
       {
-         AllocMat();
+         mat = new SparseMatrix(height);
       }
       mat->AddSubMatrix(vdofs_, vdofs_, elmat, skip_zeros);
       if (hybridization)
@@ -392,23 +311,14 @@ void BilinearForm::Assemble(int skip_zeros)
    }
 
    ElementTransformation *eltrans;
-   DofTransformation * doftrans;
-   Mesh *mesh = fes -> GetMesh();
-   DenseMatrix elmat, *elmat_p;
-
-   if (mat == NULL)
-   {
-      AllocMat();
-   }
+   DofTransformation *doftrans;
+   Mesh *mesh = fes->GetMesh();
+   DenseMatrix elmat;
 
-#ifdef MFEM_USE_LEGACY_OPENMP
-   int free_element_matrices = 0;
-   if (!element_matrices)
+   if (mat == NULL && !static_cond)
    {
-      ComputeElementMatrices();
-      free_element_matrices = 1;
+      mat = new SparseMatrix(height);
    }
-#endif
 
    if (domain_integs.Size())
    {
@@ -423,61 +333,49 @@ void BilinearForm::Assemble(int skip_zeros)
          }
       }
 
-      for (int i = 0; i < fes -> GetNE(); i++)
+      for (int i = 0; i < fes->GetNE(); i++)
       {
          int elem_attr = fes->GetMesh()->GetAttribute(i);
          doftrans = fes->GetElementVDofs(i, vdofs);
-         if (element_matrices)
-         {
-            elmat_p = &(*element_matrices)(i);
-         }
-         else
+         elmat.SetSize(0);
+         for (int k = 0; k < domain_integs.Size(); k++)
          {
-            elmat.SetSize(0);
-            for (int k = 0; k < domain_integs.Size(); k++)
+            if ( domain_integs_marker[k] == NULL ||
+                 (*(domain_integs_marker[k]))[elem_attr-1] == 1)
             {
-               if ( domain_integs_marker[k] == NULL ||
-                    (*(domain_integs_marker[k]))[elem_attr-1] == 1)
+               const FiniteElement &fe = *fes->GetFE(i);
+               eltrans = fes->GetElementTransformation(i);
+               domain_integs[k]->AssembleElementMatrix(fe, *eltrans, elemmat);
+               if (elmat.Size() == 0)
                {
-                  const FiniteElement &fe = *fes->GetFE(i);
-                  eltrans = fes->GetElementTransformation(i);
-                  domain_integs[k]->AssembleElementMatrix(fe, *eltrans, elemmat);
-                  if (elmat.Size() == 0)
-                  {
-                     elmat = elemmat;
-                  }
-                  else
-                  {
-                     elmat += elemmat;
-                  }
+                  elmat = elemmat;
+               }
+               else
+               {
+                  elmat += elemmat;
                }
             }
-            if (elmat.Size() == 0)
-            {
-               continue;
-            }
-            else
-            {
-               elmat_p = &elmat;
-            }
-            if (doftrans)
-            {
-               doftrans->TransformDual(elmat);
-            }
-            elmat_p = &elmat;
          }
-         if (static_cond)
+         if (elmat.Size() == 0)
          {
-            static_cond->AssembleMatrix(i, *elmat_p);
+            continue;
          }
-         else
+         if (doftrans)
          {
-            mat->AddSubMatrix(vdofs, vdofs, *elmat_p, skip_zeros);
+            doftrans->TransformDual(elmat);
+         }
+         if (!static_cond)
+         {
+            mat->AddSubMatrix(vdofs, vdofs, elmat, skip_zeros);
             if (hybridization)
             {
-               hybridization->AssembleMatrix(i, *elmat_p);
+               hybridization->AssembleMatrix(i, elmat);
             }
          }
+         else
+         {
+            static_cond->AssembleMatrix(i, elmat);
+         }
       }
    }
 
@@ -504,14 +402,14 @@ void BilinearForm::Assemble(int skip_zeros)
          }
       }
 
-      for (int i = 0; i < fes -> GetNBE(); i++)
+      for (int i = 0; i < fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
 
          const FiniteElement &be = *fes->GetBE(i);
-         doftrans = fes -> GetBdrElementVDofs (i, vdofs);
-         eltrans = fes -> GetBdrElementTransformation (i);
+         doftrans = fes->GetBdrElementVDofs(i, vdofs);
+         eltrans = fes->GetBdrElementTransformation(i);
          int k = 0;
          for (; k < boundary_integs.Size(); k++)
          {
@@ -534,18 +432,17 @@ void BilinearForm::Assemble(int skip_zeros)
          {
             doftrans->TransformDual(elmat);
          }
-         elmat_p = &elmat;
          if (!static_cond)
          {
-            mat->AddSubMatrix(vdofs, vdofs, *elmat_p, skip_zeros);
+            mat->AddSubMatrix(vdofs, vdofs, elmat, skip_zeros);
             if (hybridization)
             {
-               hybridization->AssembleBdrMatrix(i, *elmat_p);
+               hybridization->AssembleBdrMatrix(i, elmat);
             }
          }
          else
          {
-            static_cond->AssembleBdrMatrix(i, *elmat_p);
+            static_cond->AssembleBdrMatrix(i, elmat);
          }
       }
    }
@@ -558,19 +455,18 @@ void BilinearForm::Assemble(int skip_zeros)
       int nfaces = mesh->GetNumFaces();
       for (int i = 0; i < nfaces; i++)
       {
-         tr = mesh -> GetInteriorFaceTransformations (i);
+         tr = mesh->GetInteriorFaceTransformations(i);
          if (tr != NULL)
          {
-            fes -> GetElementVDofs (tr -> Elem1No, vdofs);
-            fes -> GetElementVDofs (tr -> Elem2No, vdofs2);
-            vdofs.Append (vdofs2);
+            fes->GetElementVDofs(tr->Elem1No, vdofs);
+            fes->GetElementVDofs(tr->Elem2No, vdofs2);
+            vdofs.Append(vdofs2);
             for (int k = 0; k < interior_face_integs.Size(); k++)
             {
-               interior_face_integs[k]->
-               AssembleFaceMatrix(*fes->GetFE(tr->Elem1No),
-                                  *fes->GetFE(tr->Elem2No),
-                                  *tr, elemmat);
-               mat -> AddSubMatrix (vdofs, vdofs, elemmat, skip_zeros);
+               interior_face_integs[k]->AssembleFaceMatrix(*fes->GetFE(tr->Elem1No),
+                                                           *fes->GetFE(tr->Elem2No),
+                                                           *tr, elemmat);
+               mat->AddSubMatrix(vdofs, vdofs, elemmat, skip_zeros);
             }
          }
       }
@@ -602,16 +498,16 @@ void BilinearForm::Assemble(int skip_zeros)
          }
       }
 
-      for (int i = 0; i < fes -> GetNBE(); i++)
+      for (int i = 0; i < fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
 
-         tr = mesh -> GetBdrFaceTransformations (i);
+         tr = mesh->GetBdrFaceTransformations(i);
          if (tr != NULL)
          {
-            fes -> GetElementVDofs (tr -> Elem1No, vdofs);
-            fe1 = fes -> GetFE (tr -> Elem1No);
+            fes->GetElementVDofs(tr->Elem1No, vdofs);
+            fe1 = fes->GetFE(tr->Elem1No);
             // The fe2 object is really a dummy and not used on the boundaries,
             // but we can't dereference a NULL pointer, and we don't want to
             // actually make a fake element.
@@ -622,20 +518,13 @@ void BilinearForm::Assemble(int skip_zeros)
                    (*boundary_face_integs_marker[k])[bdr_attr-1] == 0)
                { continue; }
 
-               boundary_face_integs[k] -> AssembleFaceMatrix (*fe1, *fe2, *tr,
-                                                              elemmat);
-               mat -> AddSubMatrix (vdofs, vdofs, elemmat, skip_zeros);
+               boundary_face_integs[k]->AssembleFaceMatrix(*fe1, *fe2, *tr,
+                                                           elemmat);
+               mat->AddSubMatrix(vdofs, vdofs, elemmat, skip_zeros);
             }
          }
       }
    }
-
-#ifdef MFEM_USE_LEGACY_OPENMP
-   if (free_element_matrices)
-   {
-      FreeElementMatrices();
-   }
-#endif
 }
 
 void BilinearForm::ConformingAssemble()
@@ -644,8 +533,9 @@ void BilinearForm::ConformingAssemble()
    // matrix which in turn will give rise to symmetric structure in the new
    // matrix. This ensures that subsequent calls to EliminateRowCol will work
    // correctly.
-   Finalize(0);
    MFEM_ASSERT(mat, "the BilinearForm is not assembled");
+   const int remove_zeros = 0;
+   Finalize(remove_zeros);
 
    const SparseMatrix *P = fes->GetConformingProlongation();
    if (!P) { return; } // conforming mesh
@@ -693,7 +583,6 @@ void BilinearForm::AssembleDiagonal(Vector &diag) const
       return;
    }
    // Here, we have extension, ext, and conforming prolongation, cP.
-
    // For an AMR mesh, a convergent diagonal is assembled with |P^T| d_l,
    // where |P^T| has the entry-wise absolute values of the conforming
    // prolongation transpose operator.
@@ -708,12 +597,26 @@ void BilinearForm::FormLinearSystem(const Array<int> &ess_tdof_list, Vector &x,
 {
    if (ext)
    {
-      ext->FormLinearSystem(ess_tdof_list, x, b, A, X, B, copy_interior);
+      Operator *oper;
+      ext->FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         delete oper;
+         FormSystemMatrix(ess_tdof_list, A);
+      }
+      else
+      {
+         A.Reset(oper);
+      }
       return;
    }
-   const SparseMatrix *P = fes->GetConformingProlongation();
+
+   // Finish the matrix assembly and perform BC elimination, storing the
+   // eliminated part of the matrix.
    FormSystemMatrix(ess_tdof_list, A);
 
+   const SparseMatrix *P = fes->GetConformingProlongation();
+
    // Transform the system and perform the elimination in B, based on the
    // essential BC values from x. Restrict the BC part of x in X, and set the
    // non-BC part to zero. Since there is no good initial guess for the Lagrange
@@ -776,7 +679,23 @@ void BilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
 {
    if (ext)
    {
-      ext->FormSystemMatrix(ess_tdof_list, A);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         // Always does `DIAG_ONE` policy to be consistent with
+         // `Operator::FormConstrainedSystemOperator`.
+         MFEM_VERIFY(diag_policy == DiagonalPolicy::DIAG_ONE,
+                     "Only DiagonalPolicy::DIAG_ONE supported with"
+                     " FABilinearFormExtension.");
+         ConformingAssemble();
+         mat->EliminateBC(ess_tdof_list, DiagonalPolicy::DIAG_ONE);
+         A.Reset(mat, false);
+      }
+      else
+      {
+         Operator *oper;
+         ext->FormSystemOperator(ess_tdof_list, oper);
+         A.Reset(oper);
+      }
       return;
    }
 
@@ -797,8 +716,7 @@ void BilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
    {
       if (!mat_e)
       {
-         const SparseMatrix *P = fes->GetConformingProlongation();
-         if (P) { ConformingAssemble(); }
+         ConformingAssemble();
          EliminateVDofs(ess_tdof_list, diag_policy);
          const int remove_zeros = 0;
          Finalize(remove_zeros);
@@ -872,48 +790,6 @@ void BilinearForm::RecoverFEMSolution(const Vector &X,
    }
 }
 
-void BilinearForm::ComputeElementMatrices()
-{
-   if (element_matrices || domain_integs.Size() == 0 || fes->GetNE() == 0)
-   {
-      return;
-   }
-
-   int num_elements = fes->GetNE();
-   int num_dofs_per_el = fes->GetFE(0)->GetDof() * fes->GetVDim();
-
-   element_matrices = new DenseTensor(num_dofs_per_el, num_dofs_per_el,
-                                      num_elements);
-
-   DenseMatrix tmp;
-   IsoparametricTransformation eltrans;
-
-#ifdef MFEM_USE_LEGACY_OPENMP
-   #pragma omp parallel for private(tmp,eltrans)
-#endif
-   for (int i = 0; i < num_elements; i++)
-   {
-      DenseMatrix elmat(element_matrices->GetData(i),
-                        num_dofs_per_el, num_dofs_per_el);
-      const FiniteElement &fe = *fes->GetFE(i);
-#ifdef MFEM_DEBUG
-      if (num_dofs_per_el != fe.GetDof()*fes->GetVDim())
-         mfem_error("BilinearForm::ComputeElementMatrices:"
-                    " all elements must have same number of dofs");
-#endif
-      fes->GetElementTransformation(i, &eltrans);
-
-      domain_integs[0]->AssembleElementMatrix(fe, eltrans, elmat);
-      for (int k = 1; k < domain_integs.Size(); k++)
-      {
-         // note: some integrators may not be thread-safe
-         domain_integs[k]->AssembleElementMatrix(fe, eltrans, tmp);
-         elmat += tmp;
-      }
-      elmat.ClearExternalData();
-   }
-}
-
 void BilinearForm::EliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
                                         const Vector &sol, Vector &rhs,
                                         DiagonalPolicy dpolicy)
@@ -949,8 +825,8 @@ void BilinearForm::EliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
    }
 }
 
-void BilinearForm::EliminateEssentialBCDiag (const Array<int> &bdr_attr_is_ess,
-                                             double value)
+void BilinearForm::EliminateEssentialBCDiag(const Array<int> &bdr_attr_is_ess,
+                                            double value)
 {
    Array<int> ess_dofs, conf_ess_dofs;
    fes->GetEssentialVDofs(bdr_attr_is_ess, ess_dofs);
@@ -976,11 +852,11 @@ void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
       int vdof = vdofs_[i];
       if ( vdof >= 0 )
       {
-         mat -> EliminateRowCol (vdof, sol(vdof), rhs, dpolicy);
+         mat->EliminateRowCol(vdof, sol(vdof), rhs, dpolicy);
       }
       else
       {
-         mat -> EliminateRowCol (-1-vdof, sol(-1-vdof), rhs, dpolicy);
+         mat->EliminateRowCol(-1-vdof, sol(-1-vdof), rhs, dpolicy);
       }
    }
 }
@@ -999,11 +875,11 @@ void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
       int vdof = vdofs_[i];
       if ( vdof >= 0 )
       {
-         mat -> EliminateRowCol (vdof, *mat_e, dpolicy);
+         mat->EliminateRowCol(vdof, *mat_e, dpolicy);
       }
       else
       {
-         mat -> EliminateRowCol (-1-vdof, *mat_e, dpolicy);
+         mat->EliminateRowCol(-1-vdof, *mat_e, dpolicy);
       }
    }
 }
@@ -1019,31 +895,31 @@ void BilinearForm::EliminateEssentialBCFromDofs(
    for (int i = 0; i < ess_dofs.Size(); i++)
       if (ess_dofs[i] < 0)
       {
-         mat -> EliminateRowCol (i, sol(i), rhs, dpolicy);
+         mat->EliminateRowCol(i, sol(i), rhs, dpolicy);
       }
 }
 
-void BilinearForm::EliminateEssentialBCFromDofs (const Array<int> &ess_dofs,
-                                                 DiagonalPolicy dpolicy)
+void BilinearForm::EliminateEssentialBCFromDofs(const Array<int> &ess_dofs,
+                                                DiagonalPolicy dpolicy)
 {
    MFEM_ASSERT(ess_dofs.Size() == height, "incorrect dof Array size");
 
    for (int i = 0; i < ess_dofs.Size(); i++)
       if (ess_dofs[i] < 0)
       {
-         mat -> EliminateRowCol (i, dpolicy);
+         mat->EliminateRowCol(i, dpolicy);
       }
 }
 
-void BilinearForm::EliminateEssentialBCFromDofsDiag (const Array<int> &ess_dofs,
-                                                     double value)
+void BilinearForm::EliminateEssentialBCFromDofsDiag(const Array<int> &ess_dofs,
+                                                    double value)
 {
    MFEM_ASSERT(ess_dofs.Size() == height, "incorrect dof Array size");
 
    for (int i = 0; i < ess_dofs.Size(); i++)
       if (ess_dofs[i] < 0)
       {
-         mat -> EliminateRowColDiag (i, value);
+         mat->EliminateRowColDiag(i, value);
       }
 }
 
@@ -1054,31 +930,6 @@ void BilinearForm::EliminateVDofsInRHS(
    mat->PartMult(vdofs_, x, b);
 }
 
-void BilinearForm::Mult(const Vector &x, Vector &y) const
-{
-   if (ext)
-   {
-      ext->Mult(x, y);
-   }
-   else
-   {
-      mat->Mult(x, y);
-   }
-}
-
-void BilinearForm::MultTranspose(const Vector & x, Vector & y) const
-{
-   if (ext)
-   {
-      ext->MultTranspose(x, y);
-   }
-   else
-   {
-      y = 0.0;
-      AddMultTranspose (x, y);
-   }
-}
-
 void BilinearForm::Update(FiniteElementSpace *nfes)
 {
    bool full_update;
@@ -1098,7 +949,6 @@ void BilinearForm::Update(FiniteElementSpace *nfes)
 
    delete mat_e;
    mat_e = NULL;
-   FreeElementMatrices();
    delete static_cond;
    static_cond = NULL;
 
@@ -1121,16 +971,10 @@ void BilinearForm::Update(FiniteElementSpace *nfes)
    if (ext) { ext->Update(); }
 }
 
-void BilinearForm::SetDiagonalPolicy(DiagonalPolicy policy)
-{
-   diag_policy = policy;
-}
-
 BilinearForm::~BilinearForm()
 {
    delete mat_e;
    delete mat;
-   delete element_matrices;
    delete static_cond;
    delete hybridization;
 
@@ -1148,9 +992,8 @@ BilinearForm::~BilinearForm()
    delete ext;
 }
 
-
-MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
-                                      FiniteElementSpace *te_fes)
+MixedBilinearForm::MixedBilinearForm(FiniteElementSpace *tr_fes,
+                                     FiniteElementSpace *te_fes)
    : Matrix(te_fes->GetVSize(), tr_fes->GetVSize())
 {
    trial_fes = tr_fes;
@@ -1162,9 +1005,9 @@ MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
    ext = NULL;
 }
 
-MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
-                                      FiniteElementSpace *te_fes,
-                                      MixedBilinearForm * mbf)
+MixedBilinearForm::MixedBilinearForm(FiniteElementSpace *tr_fes,
+                                     FiniteElementSpace *te_fes,
+                                     MixedBilinearForm *mbf)
    : Matrix(te_fes->GetVSize(), tr_fes->GetVSize())
 {
    trial_fes = tr_fes;
@@ -1173,6 +1016,8 @@ MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
    mat_e = NULL;
    extern_bfs = 1;
    ext = NULL;
+   assembly = AssemblyLevel::LEGACY;
+   ext = NULL;
 
    // Copy the pointers to the integrators
    domain_integs = mbf->domain_integs;
@@ -1182,9 +1027,6 @@ MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
 
    boundary_integs_marker = mbf->boundary_integs_marker;
    boundary_trace_face_integs_marker = mbf->boundary_trace_face_integs_marker;
-
-   assembly = AssemblyLevel::LEGACY;
-   ext = NULL;
 }
 
 void MixedBilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
@@ -1210,31 +1052,36 @@ void MixedBilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
          ext = new PAMixedBilinearFormExtension(this);
          break;
       case AssemblyLevel::NONE:
-         mfem_error("Matrix-free action not supported yet... stay tuned!");
-         // ext = new MFMixedBilinearFormExtension(this);
+         ext = new MFMixedBilinearFormExtension(this);
          break;
       default:
          mfem_error("Unknown assembly level");
    }
 }
 
-double & MixedBilinearForm::Elem (int i, int j)
+double &MixedBilinearForm::Elem(int i, int j)
 {
    return (*mat)(i, j);
 }
 
-const double & MixedBilinearForm::Elem (int i, int j) const
+const double &MixedBilinearForm::Elem(int i, int j) const
 {
    return (*mat)(i, j);
 }
 
-void MixedBilinearForm::Mult(const Vector & x, Vector & y) const
+void MixedBilinearForm::Mult(const Vector &x, Vector &y) const
 {
-   y = 0.0;
-   AddMult(x, y);
+   if (ext)
+   {
+      ext->Mult(x, y);
+   }
+   else
+   {
+      mat->Mult(x, y);
+   }
 }
 
-void MixedBilinearForm::AddMult(const Vector & x, Vector & y,
+void MixedBilinearForm::AddMult(const Vector &x, Vector &y,
                                 const double a) const
 {
    if (ext)
@@ -1247,13 +1094,19 @@ void MixedBilinearForm::AddMult(const Vector & x, Vector & y,
    }
 }
 
-void MixedBilinearForm::MultTranspose(const Vector & x, Vector & y) const
+void MixedBilinearForm::MultTranspose(const Vector &x, Vector &y) const
 {
-   y = 0.0;
-   AddMultTranspose(x, y);
+   if (ext)
+   {
+      ext->MultTranspose(x, y);
+   }
+   else
+   {
+      mat->MultTranspose(x, y);
+   }
 }
 
-void MixedBilinearForm::AddMultTranspose(const Vector & x, Vector & y,
+void MixedBilinearForm::AddMultTranspose(const Vector &x, Vector &y,
                                          const double a) const
 {
    if (ext)
@@ -1266,7 +1119,7 @@ void MixedBilinearForm::AddMultTranspose(const Vector & x, Vector & y,
    }
 }
 
-MatrixInverse * MixedBilinearForm::Inverse() const
+MatrixInverse *MixedBilinearForm::Inverse() const
 {
    if (assembly != AssemblyLevel::LEGACY)
    {
@@ -1276,15 +1129,15 @@ MatrixInverse * MixedBilinearForm::Inverse() const
    }
    else
    {
-      return mat -> Inverse ();
+      return mat->Inverse();
    }
 }
 
-void MixedBilinearForm::Finalize (int skip_zeros)
+void MixedBilinearForm::Finalize(int skip_zeros)
 {
    if (assembly == AssemblyLevel::LEGACY)
    {
-      mat -> Finalize (skip_zeros);
+      mat->Finalize(skip_zeros);
    }
 }
 
@@ -1300,27 +1153,27 @@ void MixedBilinearForm::GetBlocks(Array2D<SparseMatrix *> &blocks) const
    mat->GetBlocks(blocks);
 }
 
-void MixedBilinearForm::AddDomainIntegrator (BilinearFormIntegrator * bfi)
+void MixedBilinearForm::AddDomainIntegrator(BilinearFormIntegrator *bfi)
 {
-   domain_integs.Append (bfi);
+   domain_integs.Append(bfi);
 }
 
-void MixedBilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi)
+void MixedBilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(NULL); // NULL marker means apply everywhere
 }
 
-void MixedBilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi,
-                                               Array<int> &bdr_marker)
+void MixedBilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi,
+                                              Array<int> &bdr_marker)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(&bdr_marker);
 }
 
-void MixedBilinearForm::AddTraceFaceIntegrator (BilinearFormIntegrator * bfi)
+void MixedBilinearForm::AddTraceFaceIntegrator(BilinearFormIntegrator *bfi)
 {
-   trace_face_integs.Append (bfi);
+   trace_face_integs.Append(bfi);
 }
 
 void MixedBilinearForm::AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi)
@@ -1337,7 +1190,45 @@ void MixedBilinearForm::AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi,
    boundary_trace_face_integs_marker.Append(&bdr_marker);
 }
 
-void MixedBilinearForm::Assemble (int skip_zeros)
+void MixedBilinearForm::AssembleElementMatrix(
+   int i, const DenseMatrix &elmat, int skip_zeros)
+{
+   AssembleElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
+}
+
+void MixedBilinearForm::AssembleElementMatrix(
+   int i, const DenseMatrix &elmat, Array<int> &trial_vdofs_,
+   Array<int> &test_vdofs_, int skip_zeros)
+{
+   trial_fes->GetElementVDofs(i, trial_vdofs_);
+   test_fes->GetElementVDofs(i, test_vdofs_);
+   if (mat == NULL)
+   {
+      mat = new SparseMatrix(height, width);
+   }
+   mat->AddSubMatrix(test_vdofs_, trial_vdofs_, elmat, skip_zeros);
+}
+
+void MixedBilinearForm::AssembleBdrElementMatrix(
+   int i, const DenseMatrix &elmat, int skip_zeros)
+{
+   AssembleBdrElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
+}
+
+void MixedBilinearForm::AssembleBdrElementMatrix(
+   int i, const DenseMatrix &elmat, Array<int> &trial_vdofs_,
+   Array<int> &test_vdofs_, int skip_zeros)
+{
+   trial_fes->GetBdrElementVDofs(i, trial_vdofs_);
+   test_fes->GetBdrElementVDofs(i, test_vdofs_);
+   if (mat == NULL)
+   {
+      mat = new SparseMatrix(height, width);
+   }
+   mat->AddSubMatrix(test_vdofs_, trial_vdofs_, elmat, skip_zeros);
+}
+
+void MixedBilinearForm::Assemble(int skip_zeros)
 {
    if (ext)
    {
@@ -1346,12 +1237,11 @@ void MixedBilinearForm::Assemble (int skip_zeros)
    }
 
    ElementTransformation *eltrans;
-   DofTransformation * dom_dof_trans;
-   DofTransformation * ran_dof_trans;
+   DofTransformation *dom_dof_trans;
+   DofTransformation *ran_dof_trans;
+   Mesh *mesh = test_fes->GetMesh();
    DenseMatrix elmat;
 
-   Mesh *mesh = test_fes -> GetMesh();
-
    if (mat == NULL)
    {
       mat = new SparseMatrix(height, width);
@@ -1359,26 +1249,26 @@ void MixedBilinearForm::Assemble (int skip_zeros)
 
    if (domain_integs.Size())
    {
-      for (int i = 0; i < test_fes -> GetNE(); i++)
+      for (int i = 0; i < test_fes->GetNE(); i++)
       {
-         dom_dof_trans = trial_fes -> GetElementVDofs (i, trial_vdofs);
-         ran_dof_trans = test_fes  -> GetElementVDofs (i, test_vdofs);
-         eltrans = test_fes -> GetElementTransformation (i);
+         dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
+         ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
+         eltrans = test_fes->GetElementTransformation(i);
 
          elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
          elmat = 0.0;
          for (int k = 0; k < domain_integs.Size(); k++)
          {
-            domain_integs[k] -> AssembleElementMatrix2 (*trial_fes -> GetFE(i),
-                                                        *test_fes  -> GetFE(i),
-                                                        *eltrans, elemmat);
+            domain_integs[k]->AssembleElementMatrix2(*trial_fes->GetFE(i),
+                                                     *test_fes->GetFE(i),
+                                                     *eltrans, elemmat);
             elmat += elemmat;
          }
          if (ran_dof_trans || dom_dof_trans)
          {
             TransformDual(ran_dof_trans, dom_dof_trans, elmat);
          }
-         mat -> AddSubMatrix (test_vdofs, trial_vdofs, elmat, skip_zeros);
+         mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 
@@ -1405,14 +1295,14 @@ void MixedBilinearForm::Assemble (int skip_zeros)
          }
       }
 
-      for (int i = 0; i < test_fes -> GetNBE(); i++)
+      for (int i = 0; i < test_fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
 
-         dom_dof_trans = trial_fes -> GetBdrElementVDofs (i, trial_vdofs);
-         ran_dof_trans = test_fes  -> GetBdrElementVDofs (i, test_vdofs);
-         eltrans = test_fes -> GetBdrElementTransformation (i);
+         dom_dof_trans = trial_fes->GetBdrElementVDofs(i, trial_vdofs);
+         ran_dof_trans = test_fes->GetBdrElementVDofs(i, test_vdofs);
+         eltrans = test_fes->GetBdrElementTransformation(i);
 
          elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
          elmat = 0.0;
@@ -1421,16 +1311,16 @@ void MixedBilinearForm::Assemble (int skip_zeros)
             if (boundary_integs_marker[k] &&
                 (*boundary_integs_marker[k])[bdr_attr-1] == 0) { continue; }
 
-            boundary_integs[k]->AssembleElementMatrix2 (*trial_fes -> GetBE(i),
-                                                        *test_fes  -> GetBE(i),
-                                                        *eltrans, elemmat);
+            boundary_integs[k]->AssembleElementMatrix2(*trial_fes->GetBE(i),
+                                                       *test_fes->GetBE(i),
+                                                       *eltrans, elemmat);
             elmat += elemmat;
          }
          if (ran_dof_trans || dom_dof_trans)
          {
             TransformDual(ran_dof_trans, dom_dof_trans, elmat);
          }
-         mat -> AddSubMatrix (test_vdofs, trial_vdofs, elmat, skip_zeros);
+         mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 
@@ -1497,7 +1387,7 @@ void MixedBilinearForm::Assemble (int skip_zeros)
          }
       }
 
-      for (int i = 0; i < trial_fes -> GetNBE(); i++)
+      for (int i = 0; i < trial_fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
@@ -1530,6 +1420,37 @@ void MixedBilinearForm::Assemble (int skip_zeros)
    }
 }
 
+void MixedBilinearForm::ConformingAssemble()
+{
+   if (assembly != AssemblyLevel::LEGACY)
+   {
+      MFEM_WARNING("Conforming assemble not supported for this assembly level!");
+      return;
+   }
+
+   const int remove_zeros = 0;
+   Finalize(remove_zeros);
+
+   const SparseMatrix *test_P = test_fes->GetConformingProlongation();
+   if (test_P)
+   {
+      SparseMatrix *RA = mfem::TransposeMult(*test_P, *mat);
+      delete mat;
+      mat = RA;
+   }
+
+   const SparseMatrix *trial_P = trial_fes->GetConformingProlongation();
+   if (trial_P)
+   {
+      SparseMatrix *RAP = mfem::Mult(*mat, *trial_P);
+      delete mat;
+      mat = RAP;
+   }
+
+   height = mat->Height();
+   width = mat->Width();
+}
+
 void MixedBilinearForm::AssembleDiagonal_ADAt(const Vector &D,
                                               Vector &diag) const
 {
@@ -1578,259 +1499,119 @@ void MixedBilinearForm::AssembleDiagonal_ADAt(const Vector &D,
    }
 }
 
-void MixedBilinearForm::ConformingAssemble()
+void MixedBilinearForm::FormRectangularLinearSystem(
+   const Array<int> &trial_tdof_list,
+   const Array<int> &test_tdof_list,
+   Vector &x, Vector &b,
+   OperatorHandle &A,
+   Vector &X, Vector &B)
 {
-   if (assembly != AssemblyLevel::LEGACY)
+   if (ext)
    {
-      MFEM_WARNING("Conforming assemble not supported for this assembly level!");
+      Operator *oper;
+      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
+                                       x, b, oper, X, B);
+      A.Reset(oper);
       return;
    }
 
-   Finalize();
-
-   const SparseMatrix *P2 = test_fes->GetConformingProlongation();
-   if (P2)
-   {
-      SparseMatrix *R = Transpose(*P2);
-      SparseMatrix *RA = mfem::Mult(*R, *mat);
-      delete R;
-      delete mat;
-      mat = RA;
-   }
+   const Operator *Pi = this->GetProlongation();
+   const Operator *Po = this->GetOutputProlongation();
+   const Operator *Ri = this->GetRestriction();
+   InitTVectors(Po, Ri, Pi, x, b, X, B);
 
-   const SparseMatrix *P1 = trial_fes->GetConformingProlongation();
-   if (P1)
+   if (!mat_e)
    {
-      SparseMatrix *RAP = mfem::Mult(*mat, *P1);
-      delete mat;
-      mat = RAP;
+      // Set A = mat_e
+      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, A);
    }
+   // Eliminate essential BCs with B -= Ab xb
+   mat_e->AddMult(X, B, -1.0);
 
-   height = mat->Height();
-   width = mat->Width();
-}
-
-
-void MixedBilinearForm::ComputeElementMatrix(int i, DenseMatrix &elmat)
-{
-   if (domain_integs.Size())
-   {
-      const FiniteElement &trial_fe = *trial_fes->GetFE(i);
-      const FiniteElement &test_fe = *test_fes->GetFE(i);
-      ElementTransformation *eltrans = test_fes->GetElementTransformation(i);
-      domain_integs[0]->AssembleElementMatrix2(trial_fe, test_fe, *eltrans,
-                                               elmat);
-      for (int k = 1; k < domain_integs.Size(); k++)
-      {
-         domain_integs[k]->AssembleElementMatrix2(trial_fe, test_fe, *eltrans,
-                                                  elemmat);
-         elmat += elemmat;
-      }
-   }
-   else
-   {
-      trial_fes->GetElementVDofs(i, trial_vdofs);
-      test_fes->GetElementVDofs(i, test_vdofs);
-      elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
-      elmat = 0.0;
-   }
+   B.SetSubVector(test_tdof_list, 0.0);
 }
 
-void MixedBilinearForm::ComputeBdrElementMatrix(int i, DenseMatrix &elmat)
+void MixedBilinearForm::FormRectangularSystemMatrix(
+   const Array<int> &trial_tdof_list,
+   const Array<int> &test_tdof_list,
+   OperatorHandle &A)
 {
-   if (boundary_integs.Size())
-   {
-      const FiniteElement &trial_be = *trial_fes->GetBE(i);
-      const FiniteElement &test_be = *test_fes->GetBE(i);
-      ElementTransformation *eltrans = test_fes->GetBdrElementTransformation(i);
-      boundary_integs[0]->AssembleElementMatrix2(trial_be, test_be, *eltrans,
-                                                 elmat);
-      for (int k = 1; k < boundary_integs.Size(); k++)
-      {
-         boundary_integs[k]->AssembleElementMatrix2(trial_be, test_be, *eltrans,
-                                                    elemmat);
-         elmat += elemmat;
-      }
-   }
-   else
+   if (ext)
    {
-      trial_fes->GetBdrElementVDofs(i, trial_vdofs);
-      test_fes->GetBdrElementVDofs(i, test_vdofs);
-      elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
-      elmat = 0.0;
+      Operator *oper;
+      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, oper);
+      A.Reset(oper);
+      return;
    }
-}
 
-void MixedBilinearForm::AssembleElementMatrix(
-   int i, const DenseMatrix &elmat, int skip_zeros)
-{
-   AssembleElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
-}
+   ConformingAssemble();
 
-void MixedBilinearForm::AssembleElementMatrix(
-   int i, const DenseMatrix &elmat, Array<int> &trial_vdofs_,
-   Array<int> &test_vdofs_, int skip_zeros)
-{
-   trial_fes->GetElementVDofs(i, trial_vdofs_);
-   test_fes->GetElementVDofs(i, test_vdofs_);
-   if (mat == NULL)
-   {
-      mat = new SparseMatrix(height, width);
-   }
-   mat->AddSubMatrix(test_vdofs_, trial_vdofs_, elmat, skip_zeros);
-}
+   Array<int> ess_trial_tdof_marker, ess_test_tdof_marker;
+   FiniteElementSpace::ListToMarker(trial_tdof_list, trial_fes->GetTrueVSize(),
+                                    ess_trial_tdof_marker);
+   FiniteElementSpace::ListToMarker(test_tdof_list, test_fes->GetTrueVSize(),
+                                    ess_test_tdof_marker);
 
-void MixedBilinearForm::AssembleBdrElementMatrix(
-   int i, const DenseMatrix &elmat, int skip_zeros)
-{
-   AssembleBdrElementMatrix(i, elmat, trial_vdofs, test_vdofs, skip_zeros);
-}
+   mat_e = new SparseMatrix(mat->Height(), mat->Width());
+   mat->EliminateCols(ess_trial_tdof_marker, *mat_e);
 
-void MixedBilinearForm::AssembleBdrElementMatrix(
-   int i, const DenseMatrix &elmat, Array<int> &trial_vdofs_,
-   Array<int> &test_vdofs_, int skip_zeros)
-{
-   trial_fes->GetBdrElementVDofs(i, trial_vdofs_);
-   test_fes->GetBdrElementVDofs(i, test_vdofs_);
-   if (mat == NULL)
+   for (int i = 0; i < test_tdof_list.Size(); i++)
    {
-      mat = new SparseMatrix(height, width);
+      mat->EliminateRow(test_tdof_list[i]);
    }
-   mat->AddSubMatrix(test_vdofs_, trial_vdofs_, elmat, skip_zeros);
+   mat_e->Finalize();
+   A.Reset(mat, false);
 }
 
-void MixedBilinearForm::EliminateTrialDofs (
+void MixedBilinearForm::EliminateTrialDofs(
    const Array<int> &bdr_attr_is_ess, const Vector &sol, Vector &rhs )
 {
    int i, j, k;
-   Array<int> tr_vdofs, cols_marker (trial_fes -> GetVSize());
+   Array<int> tr_vdofs, cols_marker(trial_fes->GetVSize());
 
    cols_marker = 0;
-   for (i = 0; i < trial_fes -> GetNBE(); i++)
-      if (bdr_attr_is_ess[trial_fes -> GetBdrAttribute (i)-1])
+   for (i = 0; i < trial_fes->GetNBE(); i++)
+      if (bdr_attr_is_ess[trial_fes->GetBdrAttribute(i)-1])
       {
-         trial_fes -> GetBdrElementVDofs (i, tr_vdofs);
+         trial_fes->GetBdrElementVDofs(i, tr_vdofs);
          for (j = 0; j < tr_vdofs.Size(); j++)
          {
-            if ( (k = tr_vdofs[j]) < 0 )
+            if ((k = tr_vdofs[j]) < 0)
             {
                k = -1-k;
             }
             cols_marker[k] = 1;
          }
       }
-   mat -> EliminateCols (cols_marker, &sol, &rhs);
+   mat->EliminateCols(cols_marker, &sol, &rhs);
 }
 
-void MixedBilinearForm::EliminateEssentialBCFromTrialDofs (
+void MixedBilinearForm::EliminateEssentialBCFromTrialDofs(
    const Array<int> &marked_vdofs, const Vector &sol, Vector &rhs)
 {
-   mat -> EliminateCols (marked_vdofs, &sol, &rhs);
+   mat->EliminateCols(marked_vdofs, &sol, &rhs);
 }
 
-void MixedBilinearForm::EliminateTestDofs (const Array<int> &bdr_attr_is_ess)
+void MixedBilinearForm::EliminateTestDofs(const Array<int> &bdr_attr_is_ess)
 {
    int i, j, k;
    Array<int> te_vdofs;
 
-   for (i = 0; i < test_fes -> GetNBE(); i++)
-      if (bdr_attr_is_ess[test_fes -> GetBdrAttribute (i)-1])
+   for (i = 0; i < test_fes->GetNBE(); i++)
+      if (bdr_attr_is_ess[test_fes->GetBdrAttribute(i)-1])
       {
-         test_fes -> GetBdrElementVDofs (i, te_vdofs);
+         test_fes->GetBdrElementVDofs(i, te_vdofs);
          for (j = 0; j < te_vdofs.Size(); j++)
          {
-            if ( (k = te_vdofs[j]) < 0 )
+            if ((k = te_vdofs[j]) < 0)
             {
                k = -1-k;
             }
-            mat -> EliminateRow (k);
+            mat->EliminateRow(k);
          }
       }
 }
 
-void MixedBilinearForm::FormRectangularSystemMatrix(
-   const Array<int> &trial_tdof_list,
-   const Array<int> &test_tdof_list,
-   OperatorHandle &A)
-
-{
-   if (ext)
-   {
-      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, A);
-      return;
-   }
-
-   const SparseMatrix *test_P = test_fes->GetConformingProlongation();
-   const SparseMatrix *trial_P = trial_fes->GetConformingProlongation();
-
-   mat->Finalize();
-
-   if (test_P && trial_P)
-   {
-      SparseMatrix *m = RAP(*test_P, *mat, *trial_P);
-      delete mat;
-      mat = m;
-   }
-   else if (test_P)
-   {
-      SparseMatrix *m = TransposeMult(*test_P, *mat);
-      delete mat;
-      mat = m;
-   }
-   else if (trial_P)
-   {
-      SparseMatrix *m = mfem::Mult(*mat, *trial_P);
-      delete mat;
-      mat = m;
-   }
-
-   Array<int> ess_trial_tdof_marker, ess_test_tdof_marker;
-   FiniteElementSpace::ListToMarker(trial_tdof_list, trial_fes->GetTrueVSize(),
-                                    ess_trial_tdof_marker);
-   FiniteElementSpace::ListToMarker(test_tdof_list, test_fes->GetTrueVSize(),
-                                    ess_test_tdof_marker);
-
-   mat_e = new SparseMatrix(mat->Height(), mat->Width());
-   mat->EliminateCols(ess_trial_tdof_marker, *mat_e);
-
-   for (int i=0; i<test_tdof_list.Size(); ++i)
-   {
-      mat->EliminateRow(test_tdof_list[i]);
-   }
-   mat_e->Finalize();
-   A.Reset(mat, false);
-}
-
-void MixedBilinearForm::FormRectangularLinearSystem(
-   const Array<int> &trial_tdof_list,
-   const Array<int> &test_tdof_list,
-   Vector &x, Vector &b,
-   OperatorHandle &A,
-   Vector &X, Vector &B)
-{
-   if (ext)
-   {
-      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
-                                       x, b, A, X, B);
-      return;
-   }
-
-   const Operator *Pi = this->GetProlongation();
-   const Operator *Po = this->GetOutputProlongation();
-   const Operator *Ri = this->GetRestriction();
-   InitTVectors(Po, Ri, Pi, x, b, X, B);
-
-   if (!mat_e)
-   {
-      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list,
-                                  A); // Set A = mat_e
-   }
-   // Eliminate essential BCs with B -= Ab xb
-   mat_e->AddMult(X, B, -1.0);
-
-   B.SetSubVector(test_tdof_list, 0.0);
-}
-
 void MixedBilinearForm::Update()
 {
    delete mat;
@@ -1895,66 +1676,97 @@ void DiscreteLinearOperator::Assemble(int skip_zeros)
       return;
    }
 
-   Array<int> dom_vdofs, ran_vdofs;
-   ElementTransformation *T;
-   DofTransformation * dom_dof_trans;
-   DofTransformation * ran_dof_trans;
-   const FiniteElement *dom_fe, *ran_fe;
-   DenseMatrix totelmat, elmat;
+   ElementTransformation *eltrans;
+   DofTransformation *dom_dof_trans;
+   DofTransformation *ran_dof_trans;
+   Mesh *mesh = test_fes->GetMesh();
+   DenseMatrix elmat;
 
    if (mat == NULL)
    {
       mat = new SparseMatrix(height, width);
    }
 
-   if (domain_integs.Size() > 0)
+   if (domain_integs.Size())
    {
       for (int i = 0; i < test_fes->GetNE(); i++)
       {
-         dom_dof_trans = trial_fes->GetElementVDofs(i, dom_vdofs);
-         ran_dof_trans = test_fes->GetElementVDofs(i, ran_vdofs);
-         T = test_fes->GetElementTransformation(i);
-         dom_fe = trial_fes->GetFE(i);
-         ran_fe = test_fes->GetFE(i);
-
-         domain_integs[0]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                  totelmat);
-         for (int j = 1; j < domain_integs.Size(); j++)
+         dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
+         ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
+         eltrans = test_fes->GetElementTransformation(i);
+
+         elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
+         elmat = 0.0;
+         for (int j = 0; j < domain_integs.Size(); j++)
          {
-            domain_integs[j]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                     elmat);
-            totelmat += elmat;
+            domain_integs[j]->AssembleElementMatrix2(*trial_fes->GetFE(i),
+                                                     *test_fes->GetFE(i),
+                                                     *eltrans, elemmat);
+            elmat += elemmat;
          }
          if (ran_dof_trans || dom_dof_trans)
          {
-            TransformPrimal(ran_dof_trans, dom_dof_trans, totelmat);
+            TransformPrimal(ran_dof_trans, dom_dof_trans, elmat);
          }
-         mat->SetSubMatrix(ran_vdofs, dom_vdofs, totelmat, skip_zeros);
+         mat->SetSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 
    if (trace_face_integs.Size())
    {
-      const int nfaces = test_fes->GetMesh()->GetNumFaces();
+      const int nfaces = mesh->GetNumFaces();
       for (int i = 0; i < nfaces; i++)
       {
-         trial_fes->GetFaceVDofs(i, dom_vdofs);
-         test_fes->GetFaceVDofs(i, ran_vdofs);
-         T = test_fes->GetMesh()->GetFaceTransformation(i);
-         dom_fe = trial_fes->GetFaceElement(i);
-         ran_fe = test_fes->GetFaceElement(i);
-
-         trace_face_integs[0]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                      totelmat);
-         for (int j = 1; j < trace_face_integs.Size(); j++)
+         trial_fes->GetFaceVDofs(i, trial_vdofs);
+         test_fes->GetFaceVDofs(i, test_vdofs);
+         eltrans = mesh->GetFaceTransformation(i);
+
+         elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
+         elmat = 0.0;
+         for (int j = 0; j < trace_face_integs.Size(); j++)
          {
-            trace_face_integs[j]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                         elmat);
-            totelmat += elmat;
+            trace_face_integs[j]->AssembleElementMatrix2(*trial_fes->GetFaceElement(i),
+                                                         *test_fes->GetFaceElement(i),
+                                                         *eltrans, elemmat);
+            elmat += elemmat;
          }
-         mat->SetSubMatrix(ran_vdofs, dom_vdofs, totelmat, skip_zeros);
+         mat->SetSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 }
 
+void DiscreteLinearOperator::FormDiscreteOperatorMatrix(OperatorHandle &A)
+{
+   if (ext)
+   {
+      Operator *oper;
+      ext->FormDiscreteOperator(oper);
+      A.Reset(oper);
+      return;
+   }
+
+   mat->Finalize();
+
+   const SparseMatrix *test_R = test_fes->GetConformingRestriction();
+   if (test_R)
+   {
+      SparseMatrix *RA = mfem::Mult(*test_R, *mat);
+      delete mat;
+      mat = RA;
+   }
+
+   const SparseMatrix *trial_P = trial_fes->GetConformingProlongation();
+   if (trial_P)
+   {
+      SparseMatrix *RAP = mfem::Mult(*mat, *trial_P);
+      delete mat;
+      mat = RAP;
+   }
+
+   height = mat->Height();
+   width = mat->Width();
+
+   A.Reset(mat, false);
+}
+
 }
diff --git a/fem/bilinearform.hpp b/fem/bilinearform.hpp
index b23df9280..df4dd80f6 100644
--- a/fem/bilinearform.hpp
+++ b/fem/bilinearform.hpp
@@ -36,8 +36,6 @@ enum class AssemblyLevel
    /// is fully evaluated on the fly.
    /// This assembly level is ALWAYS performed on the host.
    LEGACY = 0,
-   /// @deprecated Use LEGACY instead.
-   LEGACYFULL = 0,
    /// Fully assembled form, i.e. a global sparse matrix in MFEM format. This
    /// assembly is compatible with device execution.
    FULL,
@@ -66,7 +64,7 @@ protected:
    SparseMatrix *mat;
 
    /** @brief Sparse Matrix \f$ M_e \f$ used to store the eliminations
-        from the b.c.  Owned.
+        from the b.c. Owned.
        \f$ M + M_e = M_{original} \f$ */
    SparseMatrix *mat_e;
 
@@ -75,11 +73,11 @@ protected:
 
    /// The assembly level of the form (full, partial, etc.)
    AssemblyLevel assembly;
-   /// Element batch size used in the form action (1, 8, num_elems, etc.)
-   int batch;
+
    /** @brief Extension for supporting Full Assembly (FA), Element Assembly (EA),
        Partial Assembly (PA), or Matrix Free assembly (MF). */
    BilinearFormExtension *ext;
+
    /** Indicates if the sparse matrix is sorted after assembly when using
        Full Assembly (FA). */
    bool sort_sparse_matrix = false;
@@ -113,11 +111,6 @@ protected:
    Array<BilinearFormIntegrator*> boundary_face_integs;
    Array<Array<int>*> boundary_face_integs_marker; ///< Entries are not owned.
 
-   DenseMatrix elemmat;
-   Array<int>  vdofs;
-
-   DenseTensor *element_matrices; ///< Owned.
-
    StaticCondensation *static_cond; ///< Owned.
    Hybridization *hybridization; ///< Owned.
 
@@ -126,31 +119,29 @@ protected:
        the constrained DoFs. */
    DiagonalPolicy diag_policy;
 
-   int precompute_sparsity;
-   // Allocate appropriate SparseMatrix and assign it to mat
-   void AllocMat();
-
-   void ConformingAssemble();
+   DenseMatrix elemmat;
+   Array<int>  vdofs;
 
    // may be used in the construction of derived classes
-   BilinearForm() : Matrix (0)
+   BilinearForm() : Matrix(0)
    {
-      fes = NULL; sequence = -1;
-      mat = mat_e = NULL; extern_bfs = 0; element_matrices = NULL;
-      static_cond = NULL; hybridization = NULL;
-      precompute_sparsity = 0;
+      fes = NULL;
+      sequence = -1;
+      mat = mat_e = NULL;
+      extern_bfs = 0;
+      static_cond = NULL;
+      hybridization = NULL;
       diag_policy = DIAG_KEEP;
       assembly = AssemblyLevel::LEGACY;
-      batch = 1;
       ext = NULL;
    }
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   BilinearForm(const BilinearForm &);
+   /// Copy construction is not supported.
+   BilinearForm(const BilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   BilinearForm &operator=(const BilinearForm &);
+   /// Copy assignment is not supported.
+   BilinearForm &operator=(const BilinearForm &) = delete;
 
 public:
    /// Creates bilinear form associated with FE space @a *f.
@@ -163,11 +154,8 @@ public:
        The pointer @a f is not owned by the newly constructed object.
 
        The integrators in @a bf are copied as pointers and they are not owned by
-       the newly constructed BilinearForm.
-
-       The optional parameter @a ps is used to initialize the internal flag
-       #precompute_sparsity, see UsePrecomputedSparsity() for details. */
-   BilinearForm(FiniteElementSpace *f, BilinearForm *bf, int ps = 0);
+       the newly constructed BilinearForm. */
+   BilinearForm(FiniteElementSpace *f, BilinearForm *bf);
 
    /// Get the size of the BilinearForm as a square matrix.
    int Size() const { return height; }
@@ -184,6 +172,18 @@ public:
        If used, this method must be called before assembly. */
    void SetAssemblyLevel(AssemblyLevel assembly_level);
 
+   /// Returns the assembly level
+   AssemblyLevel GetAssemblyLevel() const { return assembly; }
+
+   /// Sets diagonal policy used upon construction of the linear system.
+   /** Policies include:
+
+       - DIAG_ZERO (Set the diagonal values to zero)
+       - DIAG_ONE  (Set the diagonal values to one)
+       - DIAG_KEEP (Keep the diagonal values)
+   */
+   void SetDiagonalPolicy(DiagonalPolicy policy) { diag_policy = policy; }
+
    /** @brief Force the sparse matrix column indices to be sorted when using
        AssemblyLevel::FULL.
 
@@ -199,8 +199,16 @@ public:
       sort_sparse_matrix = enable_it;
    }
 
-   /// Returns the assembly level
-   AssemblyLevel GetAssemblyLevel() const { return assembly; }
+   /// Indicate that integrators are not owned by the BilinearForm
+   void UseExternalIntegrators() { extern_bfs = 1; }
+
+   /// Enable hybridization.
+   /** For details see the description for class
+       Hybridization in fem/hybridization.hpp. This method should be called
+       before assembly. */
+   void EnableHybridization(FiniteElementSpace *constr_space,
+                            BilinearFormIntegrator *constr_integ,
+                            const Array<int> &ess_tdof_list);
 
    Hybridization *GetHybridization() const { return hybridization; }
 
@@ -218,60 +226,6 @@ public:
    FiniteElementSpace *SCFESpace() const
    { return static_cond ? static_cond->GetTraceFESpace() : NULL; }
 
-   /// Enable hybridization.
-   /** For details see the description for class
-       Hybridization in fem/hybridization.hpp. This method should be called
-       before assembly. */
-   void EnableHybridization(FiniteElementSpace *constr_space,
-                            BilinearFormIntegrator *constr_integ,
-                            const Array<int> &ess_tdof_list);
-
-   /** @brief For scalar FE spaces, precompute the sparsity pattern of the matrix
-       (assuming dense element matrices) based on the types of integrators
-       present in the bilinear form. */
-   void UsePrecomputedSparsity(int ps = 1) { precompute_sparsity = ps; }
-
-   /** @brief Use the given CSR sparsity pattern to allocate the internal
-       SparseMatrix.
-
-       - The @a I and @a J arrays must define a square graph with size equal to
-         GetVSize() of the associated FiniteElementSpace.
-       - This method should be called after enabling static condensation or
-         hybridization, if used.
-       - In the case of static condensation, @a I and @a J are not used.
-       - The ownership of the arrays @a I and @a J remains with the caller. */
-   void UseSparsity(int *I, int *J, bool isSorted);
-
-   /// Use the sparsity of @a A to allocate the internal SparseMatrix.
-   void UseSparsity(SparseMatrix &A);
-
-   /// Pre-allocate the internal SparseMatrix before assembly.
-   /**  If the flag 'precompute sparsity'
-       is set, the matrix is allocated in CSR format (i.e.
-       finalized) and the entries are initialized with zeros. */
-   void AllocateMatrix() { if (mat == NULL) { AllocMat(); } }
-
-   /// Access all the integrators added with AddDomainIntegrator().
-   Array<BilinearFormIntegrator*> *GetDBFI() { return &domain_integs; }
-
-   /// Access all the integrators added with AddBoundaryIntegrator().
-   Array<BilinearFormIntegrator*> *GetBBFI() { return &boundary_integs; }
-   /** @brief Access all boundary markers added with AddBoundaryIntegrator().
-       If no marker was specified when the integrator was added, the
-       corresponding pointer (to Array<int>) will be NULL. */
-   Array<Array<int>*> *GetBBFI_Marker() { return &boundary_integs_marker; }
-
-   /// Access all integrators added with AddInteriorFaceIntegrator().
-   Array<BilinearFormIntegrator*> *GetFBFI() { return &interior_face_integs; }
-
-   /// Access all integrators added with AddBdrFaceIntegrator().
-   Array<BilinearFormIntegrator*> *GetBFBFI() { return &boundary_face_integs; }
-   /** @brief Access all boundary markers added with AddBdrFaceIntegrator().
-       If no marker was specified when the integrator was added, the
-       corresponding pointer (to Array<int>) will be NULL. */
-   Array<Array<int>*> *GetBFBFI_Marker()
-   { return &boundary_face_integs_marker; }
-
    /// Returns a reference to: \f$ M_{ij} \f$
    const double &operator()(int i, int j) { return (*mat)(i,j); }
 
@@ -284,42 +238,52 @@ public:
    /// Matrix vector multiplication:  \f$ y = M x \f$
    virtual void Mult(const Vector &x, Vector &y) const;
 
+   /// Add the matrix vector multiple to a vector:  \f$ y += a M x \f$
+   virtual void AddMult(const Vector &x, Vector &y,
+                        const double a = 1.0) const;
+
+   /// Matrix transpose vector multiplication:  \f$ y = M^T x \f$
+   virtual void MultTranspose(const Vector &x, Vector &y) const;
+
+   /// Add the matrix transpose vector multiplication:  \f$ y += a M^T x \f$
+   virtual void AddMultTranspose(const Vector &x, Vector &y,
+                                 const double a = 1.0) const;
+
    /** @brief Matrix vector multiplication with the original uneliminated
        matrix.  The original matrix is \f$ M + M_e \f$ so we have:
        \f$ y = M x + M_e x \f$ */
    void FullMult(const Vector &x, Vector &y) const
    { mat->Mult(x, y); mat_e->AddMult(x, y); }
 
-   /// Add the matrix vector multiple to a vector:  \f$ y += a M x \f$
-   virtual void AddMult(const Vector &x, Vector &y, const double a = 1.0) const
-   { mat -> AddMult (x, y, a); }
-
    /** @brief Add the original uneliminated matrix vector multiple to a vector.
        The original matrix is \f$ M + Me \f$ so we have:
        \f$ y += M x + M_e x \f$ */
    void FullAddMult(const Vector &x, Vector &y) const
    { mat->AddMult(x, y); mat_e->AddMult(x, y); }
 
-   /// Add the matrix transpose vector multiplication:  \f$ y += a M^T x \f$
-   virtual void AddMultTranspose(const Vector & x, Vector & y,
-                                 const double a = 1.0) const
-   { mat->AddMultTranspose(x, y, a); }
-
    /** @brief Add the original uneliminated matrix transpose vector
        multiple to a vector. The original matrix is \f$ M + M_e \f$
        so we have: \f$ y += M^T x + {M_e}^T x \f$ */
-   void FullAddMultTranspose(const Vector & x, Vector & y) const
+   void FullAddMultTranspose(const Vector &x, Vector &y) const
    { mat->AddMultTranspose(x, y); mat_e->AddMultTranspose(x, y); }
 
-   /// Matrix transpose vector multiplication:  \f$ y = M^T x \f$
-   virtual void MultTranspose(const Vector & x, Vector & y) const;
+   /// Compute inner product for full uneliminated matrix \f$ y^T M x + y^T M_e x \f$
+   double FullInnerProduct(const Vector &x, const Vector &y) const
+   { return mat->InnerProduct(x, y) + mat_e->InnerProduct(x, y); }
+
+   /// Returns a pointer to (approximation) of the matrix inverse:  \f$ M^{-1} \f$
+   virtual MatrixInverse *Inverse() const;
 
    /// Compute \f$ y^T M x \f$
    double InnerProduct(const Vector &x, const Vector &y) const
-   { return mat->InnerProduct (x, y); }
+   { return mat->InnerProduct(x, y); }
 
-   /// Returns a pointer to (approximation) of the matrix inverse:  \f$ M^{-1} \f$
-   virtual MatrixInverse *Inverse() const;
+   /// Sets all sparse values of \f$ M \f$ and \f$ M_e \f$ to 'a'.
+   void operator=(const double a)
+   {
+      if (mat != NULL) { *mat = a; }
+      if (mat_e != NULL) { *mat_e = a; }
+   }
 
    /// Finalizes the matrix initialization.
    virtual void Finalize(int skip_zeros = 1);
@@ -345,15 +309,7 @@ public:
    /** @brief Returns true if the sparse matrix is not null, false otherwise.
 
        @sa SpMat(). */
-   bool HasSpMat()
-   {
-      return mat != nullptr;
-   }
-
-
-   /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
-        to it.  Used for transferring ownership. */
-   SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
+   bool HasSpMat() const { return mat != nullptr; }
 
    /** @brief Returns a const reference to the sparse matrix of eliminated b.c.:
        \f$ M_e \f$
@@ -379,11 +335,31 @@ public:
         false otherwise.
 
         @sa SpMatElim(). */
-   bool HasSpMatElim()
+   bool HasSpMatElim() const { return mat_e != nullptr; }
+
+   /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
+        to it.  Used for transferring ownership. */
+   SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
+
+   /** Returns a const reference to the extension for assembly levels other
+    than AssemblyLevel::LEGACY. */
+   const BilinearFormExtension &Ext() const
    {
-      return mat_e != nullptr;
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
    }
 
+   /** Returns a reference to the extension for assembly levels other than
+       AssemblyLevel::LEGACY. */
+   BilinearFormExtension &Ext()
+   {
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
+   }
+
+   /// Returns true if the extension is not null, false otherwise.
+   bool HasExt() const { return ext != nullptr; }
+
    /// Adds new Domain Integrator. Assumes ownership of @a bfi.
    void AddDomainIntegrator(BilinearFormIntegrator *bfi);
    /// Adds new Domain Integrator restricted to certain elements specified by
@@ -416,16 +392,72 @@ public:
    void AddBdrFaceIntegrator(BilinearFormIntegrator *bfi,
                              Array<int> &bdr_marker);
 
-   /// Sets all sparse values of \f$ M \f$ and \f$ M_e \f$ to 'a'.
-   void operator=(const double a)
-   {
-      if (mat != NULL) { *mat = a; }
-      if (mat_e != NULL) { *mat_e = a; }
-   }
+   /// Access all the integrators added with AddDomainIntegrator().
+   Array<BilinearFormIntegrator*> *GetDBFI() { return &domain_integs; }
+
+   /// Access all the integrators added with AddBoundaryIntegrator().
+   Array<BilinearFormIntegrator*> *GetBBFI() { return &boundary_integs; }
+   /** @brief Access all boundary markers added with AddBoundaryIntegrator().
+       If no marker was specified when the integrator was added, the
+       corresponding pointer (to Array<int>) will be NULL. */
+   Array<Array<int>*> *GetBBFI_Marker() { return &boundary_integs_marker; }
+
+   /// Access all integrators added with AddInteriorFaceIntegrator().
+   Array<BilinearFormIntegrator*> *GetFBFI() { return &interior_face_integs; }
+
+   /// Access all integrators added with AddBdrFaceIntegrator().
+   Array<BilinearFormIntegrator*> *GetBFBFI() { return &boundary_face_integs; }
+   /** @brief Access all boundary markers added with AddBdrFaceIntegrator().
+       If no marker was specified when the integrator was added, the
+       corresponding pointer (to Array<int>) will be NULL. */
+   Array<Array<int>*> *GetBFBFI_Marker()
+   { return &boundary_face_integs_marker; }
+
+   /// Assemble the given element matrix
+   /** The element matrix @a elmat is assembled for the element @a i, i.e.
+       added to the system matrix. The flag @a skip_zeros skips the zero
+       elements of the matrix, unless they are breaking the symmetry of
+       the system matrix.
+   */
+   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
+                              int skip_zeros = 1);
+
+   /// Assemble the given element matrix
+   /** The element matrix @a elmat is assembled for the element @a i, i.e.
+       added to the system matrix. The vdofs of the element are returned
+       in @a vdofs. The flag @a skip_zeros skips the zero elements of the
+       matrix, unless they are breaking the symmetry of the system matrix.
+   */
+   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
+                              Array<int> &vdofs, int skip_zeros = 1);
+
+   /// Assemble the given boundary element matrix
+   /** The boundary element matrix @a elmat is assembled for the boundary
+       element @a i, i.e. added to the system matrix. The flag @a skip_zeros
+       skips the zero elements of the matrix, unless they are breaking the
+       symmetry of the system matrix.
+   */
+   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
+                                 int skip_zeros = 1);
+
+   /// Assemble the given boundary element matrix
+   /** The boundary element matrix @a elmat is assembled for the boundary
+       element @a i, i.e. added to the system matrix. The vdofs of the element
+       are returned in @a vdofs. The flag @a skip_zeros skips the zero elements
+       of the matrix, unless they are breaking the symmetry of the system matrix.
+   */
+   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
+                                 Array<int> &vdofs, int skip_zeros = 1);
 
    /// Assembles the form i.e. sums over all domain/bdr integrators.
    void Assemble(int skip_zeros = 1);
 
+   /** For a partially conforming FE space, complete the assembly process by
+       performing A := P^t A P where A is the internal sparse matrix; P is the
+       conforming prolongation matrices of the FE space. After this call the
+       BilinearForm becomes an operator on the conforming FE spaces. */
+   void ConformingAssemble();
+
    /** @brief Assemble the diagonal of the bilinear form into @a diag. Note that
        @a diag is a tdof Vector.
 
@@ -439,32 +471,20 @@ public:
 
    /// Get the finite element space prolongation operator.
    virtual const Operator *GetProlongation() const
-   { return fes->GetConformingProlongation(); }
+   { return fes->GetProlongationMatrix(); }
+
    /// Get the finite element space restriction operator
    virtual const Operator *GetRestriction() const
-   { return fes->GetConformingRestriction(); }
+   { return fes->GetRestrictionMatrix(); }
+
    /// Get the output finite element space prolongation matrix
    virtual const Operator *GetOutputProlongation() const
    { return GetProlongation(); }
-   /** @brief Returns the output fe space restriction matrix, transposed
 
-       Logically, this is the transpose of GetOutputRestriction, but in
-       practice it is convenient to have it in transposed form for
-       construction of RAP operators in matrix-free methods. */
-   virtual const Operator *GetOutputRestrictionTranspose() const
-   { return GetOutputProlongation(); }
    /// Get the output finite element space restriction matrix
    virtual const Operator *GetOutputRestriction() const
    { return GetRestriction(); }
 
-   /// @brief Compute serial RAP operator and store it in @a A as a SparseMatrix.
-   void SerialRAP(OperatorHandle &A)
-   {
-      MFEM_ASSERT(mat, "SerialRAP requires the SparseMatrix to be assembled.");
-      ConformingAssemble();
-      A.Reset(mat, false);
-   }
-
    /** @brief Form the linear system A X = B, corresponding to this bilinear
        form and the linear form @a b(.). */
    /** This method applies any necessary transformations to the linear system
@@ -541,59 +561,6 @@ public:
    */
    virtual void RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x);
 
-   /// Compute and store internally all element matrices.
-   void ComputeElementMatrices();
-
-   /// Free the memory used by the element matrices.
-   void FreeElementMatrices()
-   { delete element_matrices; element_matrices = NULL; }
-
-   /// Compute the element matrix of the given element
-   /** The element matrix is computed by calling the domain integrators
-       or the one stored internally by a prior call of ComputeElementMatrices()
-       is returned when available.
-   */
-   void ComputeElementMatrix(int i, DenseMatrix &elmat);
-
-   /// Compute the boundary element matrix of the given boundary element
-   void ComputeBdrElementMatrix(int i, DenseMatrix &elmat);
-
-   /// Assemble the given element matrix
-   /** The element matrix @a elmat is assembled for the element @a i, i.e.
-       added to the system matrix. The flag @a skip_zeros skips the zero
-       elements of the matrix, unless they are breaking the symmetry of
-       the system matrix.
-   */
-   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
-                              int skip_zeros = 1);
-
-   /// Assemble the given element matrix
-   /** The element matrix @a elmat is assembled for the element @a i, i.e.
-       added to the system matrix. The vdofs of the element are returned
-       in @a vdofs. The flag @a skip_zeros skips the zero elements of the
-       matrix, unless they are breaking the symmetry of the system matrix.
-   */
-   void AssembleElementMatrix(int i, const DenseMatrix &elmat,
-                              Array<int> &vdofs, int skip_zeros = 1);
-
-   /// Assemble the given boundary element matrix
-   /** The boundary element matrix @a elmat is assembled for the boundary
-       element @a i, i.e. added to the system matrix. The flag @a skip_zeros
-       skips the zero elements of the matrix, unless they are breaking the
-       symmetry of the system matrix.
-   */
-   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
-                                 int skip_zeros = 1);
-
-   /// Assemble the given boundary element matrix
-   /** The boundary element matrix @a elmat is assembled for the boundary
-       element @a i, i.e. added to the system matrix. The vdofs of the element
-       are returned in @a vdofs. The flag @a skip_zeros skips the zero elements
-       of the matrix, unless they are breaking the symmetry of the system matrix.
-   */
-   void AssembleBdrElementMatrix(int i, const DenseMatrix &elmat,
-                                 Array<int> &vdofs, int skip_zeros = 1);
-
    /// Eliminate essential boundary DOFs from the system.
    /** The array @a bdr_attr_is_ess marks boundary attributes that constitute
        the essential part of the boundary. By default, the diagonal at the
@@ -645,34 +612,14 @@ public:
    void EliminateVDofsInRHS(const Array<int> &vdofs, const Vector &x,
                             Vector &b);
 
-   /// Compute inner product for full uneliminated matrix \f$ y^T M x + y^T M_e x \f$
-   double FullInnerProduct(const Vector &x, const Vector &y) const
-   { return mat->InnerProduct(x, y) + mat_e->InnerProduct(x, y); }
-
    /// Update the @a FiniteElementSpace and delete all data associated with the old one.
    virtual void Update(FiniteElementSpace *nfes = NULL);
 
-   /// (DEPRECATED) Return the FE space associated with the BilinearForm.
-   /** @deprecated Use FESpace() instead. */
-   MFEM_DEPRECATED FiniteElementSpace *GetFES() { return fes; }
-
    /// Return the FE space associated with the BilinearForm.
    FiniteElementSpace *FESpace() { return fes; }
    /// Read-only access to the associated FiniteElementSpace.
    const FiniteElementSpace *FESpace() const { return fes; }
 
-   /// Sets diagonal policy used upon construction of the linear system.
-   /** Policies include:
-
-       - DIAG_ZERO (Set the diagonal values to zero)
-       - DIAG_ONE  (Set the diagonal values to one)
-       - DIAG_KEEP (Keep the diagonal values)
-   */
-   void SetDiagonalPolicy(DiagonalPolicy policy);
-
-   /// Indicate that integrators are not owned by the BilinearForm
-   void UseExternalIntegrators() { extern_bfs = 1; }
-
    /// Destroys bilinear form.
    virtual ~BilinearForm();
 };
@@ -696,11 +643,12 @@ public:
 class MixedBilinearForm : public Matrix
 {
 protected:
-   SparseMatrix *mat; ///< Owned.
-   SparseMatrix *mat_e; ///< Owned.
+   /** Sparse matrices associated with the form and the eliminations from
+       the b.c. Owned. */
+   SparseMatrix *mat, *mat_e;
 
-   FiniteElementSpace *trial_fes, ///< Not owned
-                      *test_fes;  ///< Not owned
+   /// FE space on which the form lives. Not owned.
+   FiniteElementSpace *trial_fes, *test_fes;
 
    /// The form assembly level (full, partial, etc.)
    AssemblyLevel assembly;
@@ -733,11 +681,11 @@ protected:
    Array<int>  trial_vdofs, test_vdofs;
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   MixedBilinearForm(const MixedBilinearForm &);
+   /// Copy construction is not supported.
+   MixedBilinearForm(const MixedBilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   MixedBilinearForm &operator=(const MixedBilinearForm &);
+   /// Copy assignment is not supported.
+   MixedBilinearForm &operator=(const MixedBilinearForm &) = delete;
 
 public:
    /** @brief Construct a MixedBilinearForm on the given trial, @a tr_fes, and
@@ -760,6 +708,13 @@ public:
                      FiniteElementSpace *te_fes,
                      MixedBilinearForm *mbf);
 
+   /// Set the desired assembly level. The default is AssemblyLevel::LEGACY.
+   /** This method must be called before assembly. */
+   void SetAssemblyLevel(AssemblyLevel assembly_level);
+
+   /// Returns the assembly level
+   AssemblyLevel GetAssemblyLevel() const { return assembly; }
+
    /// Returns a reference to: \f$ M_{ij} \f$
    virtual double &Elem(int i, int j);
 
@@ -767,17 +722,21 @@ public:
    virtual const double &Elem(int i, int j) const;
 
    /// Matrix multiplication: \f$ y = M x \f$
-   virtual void Mult(const Vector & x, Vector & y) const;
+   virtual void Mult(const Vector &x, Vector &y) const;
 
-   virtual void AddMult(const Vector & x, Vector & y,
+   virtual void AddMult(const Vector &x, Vector &y,
                         const double a = 1.0) const;
 
-   virtual void MultTranspose(const Vector & x, Vector & y) const;
-   virtual void AddMultTranspose(const Vector & x, Vector & y,
+   virtual void MultTranspose(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTranspose(const Vector &x, Vector &y,
                                  const double a = 1.0) const;
 
    virtual MatrixInverse *Inverse() const;
 
+   /// Sets all sparse values of \f$ M \f$ to @a a.
+   void operator=(const double a) { *mat = a; }
+
    /// Finalizes the matrix initialization.
    virtual void Finalize(int skip_zeros = 1);
 
@@ -787,15 +746,45 @@ public:
    void GetBlocks(Array2D<SparseMatrix *> &blocks) const;
 
    /// Returns a const reference to the sparse matrix:  \f$ M \f$
-   const SparseMatrix &SpMat() const { return *mat; }
+   const SparseMatrix &SpMat() const
+   {
+      MFEM_VERIFY(mat, "mat is NULL and can't be dereferenced");
+      return *mat;
+   }
 
    /// Returns a reference to the sparse matrix:  \f$ M \f$
-   SparseMatrix &SpMat() { return *mat; }
+   SparseMatrix &SpMat()
+   {
+      MFEM_VERIFY(mat, "mat is NULL and can't be dereferenced");
+      return *mat;
+   }
+
+   /// Returns true if the sparse matrix is not null, false otherwise.
+   bool HasSpMat() const { return mat != nullptr; }
 
    /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
         to it.  Used for transferring ownership. */
    SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
 
+   /** Returns a const reference to the extension for assembly levels other
+    than AssemblyLevel::LEGACY. */
+   const MixedBilinearFormExtension &Ext() const
+   {
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
+   }
+
+   /** Returns a reference to the extension for assembly levels other than
+       AssemblyLevel::LEGACY. */
+   MixedBilinearFormExtension &Ext()
+   {
+      MFEM_VERIFY(ext, "ext is NULL and can't be dereferenced");
+      return *ext;
+   }
+
+   /// Returns true if the extension is not null, false otherwise.
+   bool HasExt() const { return ext != nullptr; }
+
    /// Adds a domain integrator. Assumes ownership of @a bfi.
    void AddDomainIntegrator(BilinearFormIntegrator *bfi);
 
@@ -803,8 +792,8 @@ public:
    void AddBoundaryIntegrator(BilinearFormIntegrator *bfi);
 
    /// Adds a boundary integrator. Assumes ownership of @a bfi.
-   void AddBoundaryIntegrator (BilinearFormIntegrator * bfi,
-                               Array<int> &bdr_marker);
+   void AddBoundaryIntegrator(BilinearFormIntegrator *bfi,
+                              Array<int> &bdr_marker);
 
    /** @brief Add a trace face integrator. Assumes ownership of @a bfi.
 
@@ -814,11 +803,11 @@ public:
    void AddTraceFaceIntegrator(BilinearFormIntegrator *bfi);
 
    /// Adds a boundary trace face integrator. Assumes ownership of @a bfi.
-   void AddBdrTraceFaceIntegrator (BilinearFormIntegrator * bfi);
+   void AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi);
 
    /// Adds a boundary trace face integrator. Assumes ownership of @a bfi.
-   void AddBdrTraceFaceIntegrator (BilinearFormIntegrator * bfi,
-                                   Array<int> &bdr_marker);
+   void AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi,
+                                  Array<int> &bdr_marker);
 
    /// Access all integrators added with AddDomainIntegrator().
    Array<BilinearFormIntegrator*> *GetDBFI() { return &domain_integs; }
@@ -842,48 +831,6 @@ public:
    Array<Array<int>*> *GetBTFBFI_Marker()
    { return &boundary_trace_face_integs_marker; }
 
-   /// Sets all sparse values of \f$ M \f$ to @a a.
-   void operator=(const double a) { *mat = a; }
-
-   /// Set the desired assembly level. The default is AssemblyLevel::LEGACY.
-   /** This method must be called before assembly. */
-   void SetAssemblyLevel(AssemblyLevel assembly_level);
-
-   void Assemble(int skip_zeros = 1);
-
-   /** @brief Assemble the diagonal of ADA^T into diag, where A is this mixed
-       bilinear form and D is a diagonal. */
-   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
-
-   /// Get the input finite element space prolongation matrix
-   virtual const Operator *GetProlongation() const
-   { return trial_fes->GetProlongationMatrix(); }
-
-   /// Get the input finite element space restriction matrix
-   virtual const Operator *GetRestriction() const
-   { return trial_fes->GetRestrictionMatrix(); }
-
-   /// Get the test finite element space prolongation matrix
-   virtual const Operator *GetOutputProlongation() const
-   { return test_fes->GetProlongationMatrix(); }
-
-   /// Get the test finite element space restriction matrix
-   virtual const Operator *GetOutputRestriction() const
-   { return test_fes->GetRestrictionMatrix(); }
-
-   /** For partially conforming trial and/or test FE spaces, complete the
-       assembly process by performing A := P2^t A P1 where A is the internal
-       sparse matrix; P1 and P2 are the conforming prolongation matrices of the
-       trial and test FE spaces, respectively. After this call the
-       MixedBilinearForm becomes an operator on the conforming FE spaces. */
-   void ConformingAssemble();
-
-   /// Compute the element matrix of the given element
-   void ComputeElementMatrix(int i, DenseMatrix &elmat);
-
-   /// Compute the boundary element matrix of the given boundary element
-   void ComputeBdrElementMatrix(int i, DenseMatrix &elmat);
-
    /// Assemble the given element matrix
    /** The element matrix @a elmat is assembled for the element @a i, i.e.
        added to the system matrix. The flag @a skip_zeros skips the zero
@@ -924,40 +871,34 @@ public:
                                  Array<int> &trial_vdofs, Array<int> &test_vdofs,
                                  int skip_zeros = 1);
 
-   void EliminateTrialDofs(const Array<int> &bdr_attr_is_ess,
-                           const Vector &sol, Vector &rhs);
+   void Assemble(int skip_zeros = 1);
 
-   void EliminateEssentialBCFromTrialDofs(const Array<int> &marked_vdofs,
-                                          const Vector &sol, Vector &rhs);
+   /** For partially conforming trial and/or test FE spaces, complete the
+       assembly process by performing A := P2^t A P1 where A is the internal
+       sparse matrix; P1 and P2 are the conforming prolongation matrices of the
+       trial and test FE spaces, respectively. After this call the
+       MixedBilinearForm becomes an operator on the conforming FE spaces. */
+   void ConformingAssemble();
 
-   virtual void EliminateTestDofs(const Array<int> &bdr_attr_is_ess);
+   /** @brief Assemble the diagonal of ADA^T into diag, where A is this mixed
+       bilinear form and D is a diagonal. */
+   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
 
-   /** @brief Return in @a A that is column-constrained.
+   /// Get the input finite element space prolongation matrix
+   virtual const Operator *GetProlongation() const
+   { return trial_fes->GetProlongationMatrix(); }
 
-      This returns the same operator as FormRectangularLinearSystem(), but does
-      without the transformations of the right-hand side. */
-   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
-                                            const Array<int> &test_tdof_list,
-                                            OperatorHandle &A);
+   /// Get the input finite element space restriction matrix
+   virtual const Operator *GetRestriction() const
+   { return trial_fes->GetRestrictionMatrix(); }
 
-   /** @brief Form the column-constrained linear system matrix A.
-       See FormRectangularSystemMatrix() for details.
+   /// Get the test finite element space prolongation matrix
+   virtual const Operator *GetOutputProlongation() const
+   { return test_fes->GetProlongationMatrix(); }
 
-       Version of the method FormRectangularSystemMatrix() where the system matrix is
-       returned in the variable @a A, of type OpType, holding a *reference* to
-       the system matrix (created with the method OpType::MakeRef()). The
-       reference will be invalidated when SetOperatorType(), Update(), or the
-       destructor is called. */
-   template <typename OpType>
-   void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
-                                    const Array<int> &test_tdof_list, OpType &A)
-   {
-      OperatorHandle Ah;
-      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, Ah);
-      OpType *A_ptr = Ah.Is<OpType>();
-      MFEM_VERIFY(A_ptr, "invalid OpType used");
-      A.MakeRef(*A_ptr);
-   }
+   /// Get the test finite element space restriction matrix
+   virtual const Operator *GetOutputRestriction() const
+   { return test_fes->GetRestrictionMatrix(); }
 
    /** @brief Form the linear system A X = B, corresponding to this mixed bilinear
        form and the linear form @a b(.).
@@ -992,6 +933,41 @@ public:
       A.MakeRef(*A_ptr);
    }
 
+   /** @brief Return in @a A that is column-constrained.
+
+      This returns the same operator as FormRectangularLinearSystem(), but does
+      without the transformations of the right-hand side. */
+   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
+                                            const Array<int> &test_tdof_list,
+                                            OperatorHandle &A);
+
+   /** @brief Form the column-constrained linear system matrix A.
+       See FormRectangularSystemMatrix() for details.
+
+       Version of the method FormRectangularSystemMatrix() where the system matrix is
+       returned in the variable @a A, of type OpType, holding a *reference* to
+       the system matrix (created with the method OpType::MakeRef()). The
+       reference will be invalidated when SetOperatorType(), Update(), or the
+       destructor is called. */
+   template <typename OpType>
+   void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
+                                    const Array<int> &test_tdof_list, OpType &A)
+   {
+      OperatorHandle Ah;
+      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, Ah);
+      OpType *A_ptr = Ah.Is<OpType>();
+      MFEM_VERIFY(A_ptr, "invalid OpType used");
+      A.MakeRef(*A_ptr);
+   }
+
+   void EliminateTrialDofs(const Array<int> &bdr_attr_is_ess,
+                           const Vector &sol, Vector &rhs);
+
+   void EliminateEssentialBCFromTrialDofs(const Array<int> &marked_vdofs,
+                                          const Vector &sol, Vector &rhs);
+
+   virtual void EliminateTestDofs(const Array<int> &bdr_attr_is_ess);
+
    void Update();
 
    /// Return the trial FE space associated with the BilinearForm.
@@ -1041,11 +1017,11 @@ public:
 class DiscreteLinearOperator : public MixedBilinearForm
 {
 private:
-   /// Copy construction is not supported; body is undefined.
-   DiscreteLinearOperator(const DiscreteLinearOperator &);
+   /// Copy construction is not supported.
+   DiscreteLinearOperator(const DiscreteLinearOperator &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   DiscreteLinearOperator &operator=(const DiscreteLinearOperator &);
+   /// Copy assignment is not supported.
+   DiscreteLinearOperator &operator=(const DiscreteLinearOperator &) = delete;
 
 public:
    /** @brief Construct a DiscreteLinearOperator on the given
@@ -1065,9 +1041,12 @@ public:
    { AddTraceFaceIntegrator(di); }
 
    /// Access all interpolators added with AddDomainInterpolator().
-   Array<BilinearFormIntegrator*> *GetDI() { return &domain_integs; }
+   Array<BilinearFormIntegrator*> *GetDI() { return GetDBFI(); }
+
+   /// Access all interpolators added with AddTraceFaceInterpolator().
+   Array<BilinearFormIntegrator*> *GetTFI() { return GetTFBFI(); }
 
-   /// Set the desired assembly level. The default is AssemblyLevel::FULL.
+   /// Set the desired assembly level. The default is AssemblyLevel::LEGACY.
    /** This method must be called before assembly. */
    void SetAssemblyLevel(AssemblyLevel assembly_level);
 
@@ -1075,10 +1054,26 @@ public:
        linear operator. */
    virtual void Assemble(int skip_zeros = 1);
 
-   /** @brief Get the output finite element space restriction matrix in
-       transposed form. */
-   virtual const Operator *GetOutputRestrictionTranspose() const
-   { return test_fes->GetRestrictionTransposeOperator(); }
+   /** @brief Return in @a A that is column-constrained. */
+   virtual void FormDiscreteOperatorMatrix(OperatorHandle &A);
+
+   /** @brief Form the column-constrained discrete linear operator matrix A.
+       See FormDiscreteOperatorMatrix() for details.
+
+       Version of the method FormDiscreteOperatorMatrix() where the discrete
+       operator matrix is returned in the variable @a A, of type OpType,
+       holding a *reference* to the discrete operator  matrix (created with the
+       method OpType::MakeRef()). The reference will be invalidated when
+       SetOperatorType(), Update(), or the destructor is called. */
+   template <typename OpType>
+   void FormDiscreteOperatorMatrix(OpType &A)
+   {
+      OperatorHandle Ah;
+      FormDiscreteOperatorMatrix(Ah);
+      OpType *A_ptr = Ah.Is<OpType>();
+      MFEM_VERIFY(A_ptr, "invalid OpType used");
+      A.MakeRef(*A_ptr);
+   }
 };
 
 }
diff --git a/fem/bilinearform_ext.cpp b/fem/bilinearform_ext.cpp
index 50c2cf198..eaf27863a 100644
--- a/fem/bilinearform_ext.cpp
+++ b/fem/bilinearform_ext.cpp
@@ -21,10 +21,10 @@
 namespace mfem
 {
 
+/// Base class for extensions to the BilinearForm class
 BilinearFormExtension::BilinearFormExtension(BilinearForm *form)
    : Operator(form->Size()), a(form)
 {
-   // empty
 }
 
 const Operator *BilinearFormExtension::GetProlongation() const
@@ -37,812 +37,1261 @@ const Operator *BilinearFormExtension::GetRestriction() const
    return a->GetRestriction();
 }
 
-// Data and methods for partially-assembled bilinear forms
+/// Data and methods for matrix-free bilinear forms
 MFBilinearFormExtension::MFBilinearFormExtension(BilinearForm *form)
-   : BilinearFormExtension(form),
-     trial_fes(a->FESpace()),
-     test_fes(a->FESpace())
+   : BilinearFormExtension(form)
 {
-   elem_restrict = NULL;
-   int_face_restrict_lex = NULL;
-   bdr_face_restrict_lex = NULL;
+   Update();
 }
 
-void MFBilinearFormExtension::Assemble()
+void MFBilinearFormExtension::SetupRestrictionOperators(const L2FaceValues m)
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
+   if (DeviceCanUseCeed()) { return; }
+   ElementDofOrdering ordering = UsesTensorBasis(*fes) ?
+                                 ElementDofOrdering::LEXICOGRAPHIC :
+                                 ElementDofOrdering::NATIVE;
+   elem_restrict = fes->GetElementRestriction(ordering);
+   if (elem_restrict)
    {
-      integrators[i]->AssembleMF(*a->FESpace());
+      local_x.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
+      local_y.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
+      local_y.UseDevice(true); // ensure 'local_y = 0.0' is done on device
    }
-}
-
-void MFBilinearFormExtension::AssembleDiagonal(Vector &y) const
-{
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
 
-   const int iSz = integrators.Size();
-   if (elem_restrict && !DeviceCanUseCeed())
+   // Construct face restriction operators only if the bilinear form has
+   // interior or boundary face integrators
+   if (int_face_restrict_lex == nullptr && a->GetFBFI()->Size() > 0)
    {
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
-      {
-         integrators[i]->AssembleDiagonalMF(localY);
-      }
-      const ElementRestriction* H1elem_restrict =
-         dynamic_cast<const ElementRestriction*>(elem_restrict);
-      if (H1elem_restrict)
-      {
-         H1elem_restrict->MultTransposeUnsigned(localY, y);
-      }
-      else
-      {
-         elem_restrict->MultTranspose(localY, y);
-      }
+      int_face_restrict_lex = fes->GetFaceRestriction(
+                                 ElementDofOrdering::LEXICOGRAPHIC,
+                                 FaceType::Interior);
+      int_face_x.SetSize(int_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      int_face_y.SetSize(int_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      int_face_y.UseDevice(true);
    }
-   else
+
+   if (bdr_face_restrict_lex == nullptr &&
+       (a->GetBFBFI()->Size() > 0 || a->GetBBFI()->Size() > 0))
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
-      {
-         integrators[i]->AssembleDiagonalMF(y);
-      }
+      bdr_face_restrict_lex = fes->GetFaceRestriction(
+                                 ElementDofOrdering::LEXICOGRAPHIC,
+                                 FaceType::Boundary,
+                                 m);
+      bdr_face_x.SetSize(bdr_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      bdr_face_y.SetSize(bdr_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      bdr_face_y.UseDevice(true);
    }
 }
 
-void MFBilinearFormExtension::Update()
+void MFBilinearFormExtension::Assemble()
 {
-   FiniteElementSpace *fes = a->FESpace();
-   height = width = fes->GetVSize();
-   trial_fes = fes;
-   test_fes = fes;
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
 
-   elem_restrict = nullptr;
-   int_face_restrict_lex = nullptr;
-   bdr_face_restrict_lex = nullptr;
-}
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
+   {
+      integ->AssembleMF(*fes);
+   }
 
-void MFBilinearFormExtension::FormSystemMatrix(const Array<int> &ess_tdof_list,
-                                               OperatorHandle &A)
-{
-   Operator *oper;
-   Operator::FormSystemOperator(ess_tdof_list, oper);
-   A.Reset(oper); // A will own oper
-}
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
+   {
+      integ->AssembleMFBoundary(*fes);
+   }
 
-void MFBilinearFormExtension::FormLinearSystem(const Array<int> &ess_tdof_list,
-                                               Vector &x, Vector &b,
-                                               OperatorHandle &A,
-                                               Vector &X, Vector &B,
-                                               int copy_interior)
-{
-   Operator *oper;
-   Operator::FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
-   A.Reset(oper); // A will own oper
+   MFEM_VERIFY(a->GetFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in MFBilinearFormExtension");
+
+   MFEM_VERIFY(a->GetBFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in MFBilinearFormExtension");
 }
 
-void MFBilinearFormExtension::Mult(const Vector &x, Vector &y) const
+void MFBilinearFormExtension::AssembleDiagonal(Vector &diag) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-   if (DeviceCanUseCeed() || !elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultMF(x, y);
+         integ->AssembleDiagonalMF(local_y);
       }
+      elem_restrict->MultTransposeUnsigned(local_y, diag);
    }
    else
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      diag.UseDevice(true); // typically this is a large vector, so store on device
+      diag = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultMF(localX, localY);
+         integ->AssembleDiagonalMF(diag);
       }
-      elem_restrict->MultTranspose(localY, y);
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      if (bdr_face_restrict_lex)
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         bdr_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            intFaceIntegrators[i]->AddMultMF(int_face_X, int_face_Y);
+            integ->AssembleDiagonalMF(bdr_face_y);
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+         bdr_face_restrict_lex->AddMultTransposeUnsigned(bdr_face_y, diag);
       }
-   }
-
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
-   {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      else
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            bdrFaceIntegrators[i]->AddMultMF(bdr_face_X, bdr_face_Y);
+            integ->AssembleDiagonalMF(diag);
          }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
       }
    }
 }
 
-void MFBilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
+void MFBilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-   if (elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultTransposeMF(localX, localY);
+         integ->AddMultMF(local_x, local_y);
       }
-      elem_restrict->MultTranspose(localY, y);
+      elem_restrict->MultTranspose(local_y, y);
    }
    else
    {
-      y.UseDevice(true);
+      y.UseDevice(true); // typically this is a large vector, so store on device
       y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultTransposeMF(x, y);
+         integ->AddMultMF(x, y);
       }
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      if (bdr_face_restrict_lex)
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
          {
-            intFaceIntegrators[i]->AddMultTransposeMF(int_face_X, int_face_Y);
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(bdr_face_x, bdr_face_y);
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
       }
-   }
-
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
-   {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      else
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            bdrFaceIntegrators[i]->AddMultTransposeMF(bdr_face_X, bdr_face_Y);
+            integ->AddMultMF(x, y);
          }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
       }
    }
 }
 
-// Data and methods for partially-assembled bilinear forms
-PABilinearFormExtension::PABilinearFormExtension(BilinearForm *form)
-   : BilinearFormExtension(form),
-     trial_fes(a->FESpace()),
-     test_fes(a->FESpace())
-{
-   elem_restrict = NULL;
-   int_face_restrict_lex = NULL;
-   bdr_face_restrict_lex = NULL;
-}
-
-void PABilinearFormExtension::SetupRestrictionOperators(const L2FaceValues m)
+void MFBilinearFormExtension::AddMult(const Vector &x, Vector &y,
+                                      const double c) const
 {
-   if ( Device::Allows(Backend::CEED_MASK) ) { return; }
-   ElementDofOrdering ordering = UsesTensorBasis(*a->FESpace())?
-                                 ElementDofOrdering::LEXICOGRAPHIC:
-                                 ElementDofOrdering::NATIVE;
-   elem_restrict = trial_fes->GetElementRestriction(ordering);
-   if (elem_restrict)
-   {
-      localX.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
-      localY.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
-      localY.UseDevice(true); // ensure 'localY = 0.0' is done on device
-   }
-
-   // Construct face restriction operators only if the bilinear form has
-   // interior or boundary face integrators
-   if (int_face_restrict_lex == NULL && a->GetFBFI()->Size() > 0)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      int_face_restrict_lex = trial_fes->GetFaceRestriction(
-                                 ElementDofOrdering::LEXICOGRAPHIC,
-                                 FaceType::Interior);
-      int_face_X.SetSize(int_face_restrict_lex->Height(), Device::GetMemoryType());
-      int_face_Y.SetSize(int_face_restrict_lex->Height(), Device::GetMemoryType());
-      int_face_Y.UseDevice(true); // ensure 'int_face_Y = 0.0' is done on device
+      if (elem_restrict)
+      {
+         elem_restrict->Mult(x, local_x);
+         local_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultMF(local_x, local_y);
+         }
+         if (c != 1.0)
+         {
+            local_y *= c;
+         }
+         elem_restrict->AddMultTranspose(local_y, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultMF(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultMF(x, y);
+            }
+         }
+      }
    }
 
-   if (bdr_face_restrict_lex == NULL && a->GetBFBFI()->Size() > 0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      bdr_face_restrict_lex = trial_fes->GetFaceRestriction(
-                                 ElementDofOrdering::LEXICOGRAPHIC,
-                                 FaceType::Boundary,
-                                 m);
-      bdr_face_X.SetSize(bdr_face_restrict_lex->Height(), Device::GetMemoryType());
-      bdr_face_Y.SetSize(bdr_face_restrict_lex->Height(), Device::GetMemoryType());
-      bdr_face_Y.UseDevice(true); // ensure 'faceBoundY = 0.0' is done on device
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(bdr_face_x, bdr_face_y);
+            }
+            if (c != 1.0)
+            {
+               bdr_face_y *= c;
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(x, y);
+            }
+         }
+      }
    }
 }
 
-void PABilinearFormExtension::Assemble()
+void MFBilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 {
-   SetupRestrictionOperators(L2FaceValues::DoubleValued);
-
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      integrators[i]->AssemblePA(*a->FESpace());
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposeMF(local_x, local_y);
+      }
+      elem_restrict->MultTranspose(local_y, y);
    }
-
-   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
-               "Partial assembly does not support AddBoundaryIntegrator yet.");
-
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int intFaceIntegratorCount = intFaceIntegrators.Size();
-   for (int i = 0; i < intFaceIntegratorCount; ++i)
+   else
    {
-      intFaceIntegrators[i]->AssemblePAInteriorFaces(*a->FESpace());
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposeMF(x, y);
+      }
    }
 
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int boundFaceIntegratorCount = bdrFaceIntegrators.Size();
-   for (int i = 0; i < boundFaceIntegratorCount; ++i)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      bdrFaceIntegrators[i]->AssemblePABoundaryFaces(*a->FESpace());
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(bdr_face_x, bdr_face_y);
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposeMF(x, y);
+         }
+      }
    }
 }
 
-void PABilinearFormExtension::AssembleDiagonal(Vector &y) const
+void MFBilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
+                                               const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-   if (elem_restrict && !DeviceCanUseCeed())
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      if (elem_restrict)
       {
-         integrators[i]->AssembleDiagonalPA(localY);
-      }
-      const ElementRestriction* H1elem_restrict =
-         dynamic_cast<const ElementRestriction*>(elem_restrict);
-      if (H1elem_restrict)
-      {
-         H1elem_restrict->MultTransposeUnsigned(localY, y);
+         elem_restrict->Mult(x, local_x);
+         local_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposeMF(local_x, local_y);
+         }
+         if (c != 1.0)
+         {
+            local_y *= c;
+         }
+         elem_restrict->AddMultTranspose(local_y, y);
       }
       else
       {
-         elem_restrict->MultTranspose(localY, y);
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(x, y);
+            }
+         }
       }
    }
-   else
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(bdr_face_x, bdr_face_y);
+            }
+            if (c != 1.0)
+            {
+               bdr_face_y *= c;
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
       {
-         integrators[i]->AssembleDiagonalPA(y);
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(x, y);
+            }
+         }
       }
    }
 }
 
-void PABilinearFormExtension::Update()
+void MFBilinearFormExtension::Update()
 {
-   FiniteElementSpace *fes = a->FESpace();
+   fes = a->FESpace();
    height = width = fes->GetVSize();
-   trial_fes = fes;
-   test_fes = fes;
 
    elem_restrict = nullptr;
    int_face_restrict_lex = nullptr;
    bdr_face_restrict_lex = nullptr;
 }
 
-void PABilinearFormExtension::FormSystemMatrix(const Array<int> &ess_tdof_list,
-                                               OperatorHandle &A)
+/// Data and methods for partially-assembled bilinear forms
+PABilinearFormExtension::PABilinearFormExtension(BilinearForm *form)
+   : MFBilinearFormExtension(form)
 {
-   Operator *oper;
-   Operator::FormSystemOperator(ess_tdof_list, oper);
-   A.Reset(oper); // A will own oper
 }
 
-void PABilinearFormExtension::FormLinearSystem(const Array<int> &ess_tdof_list,
-                                               Vector &x, Vector &b,
-                                               OperatorHandle &A,
-                                               Vector &X, Vector &B,
-                                               int copy_interior)
+void PABilinearFormExtension::Assemble()
 {
-   Operator *oper;
-   Operator::FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
-   A.Reset(oper); // A will own oper
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
+
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
+   {
+      integ->AssemblePA(*fes);
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
+   {
+      integ->AssemblePABoundary(*fes);
+   }
+
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   for (BilinearFormIntegrator *integ : int_face_integrators)
+   {
+      integ->AssemblePAInteriorFaces(*fes);
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   for (BilinearFormIntegrator *integ : bdr_face_integrators)
+   {
+      integ->AssemblePABoundaryFaces(*fes);
+   }
 }
 
-void PABilinearFormExtension::Mult(const Vector &x, Vector &y) const
+void PABilinearFormExtension::AssembleDiagonal(Vector &diag) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-   if (DeviceCanUseCeed() || !elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultPA(x, y);
+         integ->AssembleDiagonalPA(local_y);
       }
+      elem_restrict->MultTransposeUnsigned(local_y, diag);
    }
    else
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      diag.UseDevice(true); // typically this is a large vector, so store on device
+      diag = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultPA(localX, localY);
+         integ->AssembleDiagonalPA(diag);
       }
-      elem_restrict->MultTranspose(localY, y);
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      if (bdr_face_restrict_lex)
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         bdr_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            intFaceIntegrators[i]->AddMultPA(int_face_X, int_face_Y);
+            integ->AssembleDiagonalPA(bdr_face_y);
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+         bdr_face_restrict_lex->AddMultTransposeUnsigned(bdr_face_y, diag);
       }
-   }
-
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
-   {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      else
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            bdrFaceIntegrators[i]->AddMultPA(bdr_face_X, bdr_face_Y);
+            integ->AssembleDiagonalPA(diag);
          }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
       }
    }
 }
 
-void PABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
+void PABilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-   if (elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultTransposePA(localX, localY);
+         integ->AddMultPA(local_x, local_y);
       }
-      elem_restrict->MultTranspose(localY, y);
+      elem_restrict->MultTranspose(local_y, y);
    }
    else
    {
-      y.UseDevice(true);
+      y.UseDevice(true); // typically this is a large vector, so store on device
       y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultTransposePA(x, y);
+         integ->AddMultPA(x, y);
       }
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      if (int_face_restrict_lex)
+      {
+         int_face_restrict_lex->Mult(x, int_face_x);
+         if (int_face_x.Size() > 0)
+         {
+            int_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultPA(int_face_x, int_face_y);
+            }
+            int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+         }
+      }
+      else
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         for (BilinearFormIntegrator *integ : int_face_integrators)
          {
-            intFaceIntegrators[i]->AddMultTransposePA(int_face_X, int_face_Y);
+            integ->AddMultPA(x, y);
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
       }
    }
 
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_integrators.Size() > 0 || bdr_face_integrators.Size() > 0)
    {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(bdr_face_x, bdr_face_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultPA(bdr_face_x, bdr_face_y);
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            bdrFaceIntegrators[i]->AddMultTransposePA(bdr_face_X, bdr_face_Y);
+            integ->AddMultPA(x, y);
+         }
+         for (BilinearFormIntegrator *integ : bdr_face_integrators)
+         {
+            integ->AddMultPA(x, y);
          }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
       }
    }
 }
 
-// Data and methods for element-assembled bilinear forms
-EABilinearFormExtension::EABilinearFormExtension(BilinearForm *form)
-   : PABilinearFormExtension(form),
-     factorize_face_terms(false)
+void PABilinearFormExtension::AddMult(const Vector &x, Vector &y,
+                                      const double c) const
 {
-   if (form->FESpace()->IsDGSpace() && form->FESpace()->Conforming())
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      factorize_face_terms = true;
+      if (elem_restrict)
+      {
+         elem_restrict->Mult(x, local_x);
+         local_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultPA(local_x, local_y);
+         }
+         if (c != 1.0)
+         {
+            local_y *= c;
+         }
+         elem_restrict->AddMultTranspose(local_y, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultPA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultPA(x, y);
+            }
+         }
+      }
    }
-}
-
-void EABilinearFormExtension::Assemble()
-{
-   SetupRestrictionOperators(L2FaceValues::SingleValued);
-
-   ne = trial_fes->GetMesh()->GetNE();
-   elemDofs = trial_fes->GetFE(0)->GetDof();
 
-   ea_data.SetSize(ne*elemDofs*elemDofs, Device::GetMemoryType());
-   ea_data.UseDevice(true);
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
+   {
+      if (int_face_restrict_lex)
+      {
+         int_face_restrict_lex->Mult(x, int_face_x);
+         if (int_face_x.Size() > 0)
+         {
+            int_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultPA(int_face_x, int_face_y);
+            }
+            if (c != 1.0)
+            {
+               int_face_y *= c;
+            }
+            int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+         }
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultPA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultPA(x, y);
+            }
+         }
+      }
+   }
 
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   if ( integratorCount == 0 )
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_integrators.Size() > 0 || bdr_face_integrators.Size() > 0)
    {
-      ea_data = 0.0;
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(bdr_face_x, bdr_face_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultPA(bdr_face_x, bdr_face_y);
+            }
+            if (c != 1.0)
+            {
+               bdr_face_y *= c;
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(x, temp_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultPA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(x, y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultPA(x, y);
+            }
+         }
+      }
+   }
+}
+
+void PABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
+   {
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposePA(local_x, local_y);
+      }
+      elem_restrict->MultTranspose(local_y, y);
    }
-   for (int i = 0; i < integratorCount; ++i)
+   else
    {
-      integrators[i]->AssembleEA(*a->FESpace(), ea_data, i);
+      y.UseDevice(true);
+      y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposePA(x, y);
+      }
    }
 
-   faceDofs = trial_fes ->
-              GetTraceElement(0, trial_fes->GetMesh()->GetFaceGeometry(0)) ->
-              GetDof();
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
+   {
+      if (int_face_restrict_lex)
+      {
+         int_face_restrict_lex->Mult(x, int_face_x);
+         if (int_face_x.Size() > 0)
+         {
+            int_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultTransposePA(int_face_x, int_face_y);
+            }
+            int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+         }
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : int_face_integrators)
+         {
+            integ->AddMultTransposePA(x, y);
+         }
+      }
+   }
 
-   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
-               "Element assembly does not support AddBoundaryIntegrator yet.");
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_integrators.Size() > 0 || bdr_face_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposePA(x, y);
+         }
+         for (BilinearFormIntegrator *integ : bdr_face_integrators)
+         {
+            integ->AddMultTransposePA(x, y);
+         }
+      }
+   }
+}
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int intFaceIntegratorCount = intFaceIntegrators.Size();
-   if (intFaceIntegratorCount>0)
+void PABilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
+                                               const double c) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      nf_int = trial_fes->GetNFbyType(FaceType::Interior);
-      ea_data_int.SetSize(2*nf_int*faceDofs*faceDofs, Device::GetMemoryType());
-      ea_data_ext.SetSize(2*nf_int*faceDofs*faceDofs, Device::GetMemoryType());
+      if (elem_restrict)
+      {
+         elem_restrict->Mult(x, local_x);
+         local_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposePA(local_x, local_y);
+         }
+         if (c != 1.0)
+         {
+            local_y *= c;
+         }
+         elem_restrict->AddMultTranspose(local_y, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(x, y);
+            }
+         }
+      }
    }
-   for (int i = 0; i < intFaceIntegratorCount; ++i)
+
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
    {
-      intFaceIntegrators[i]->AssembleEAInteriorFaces(*a->FESpace(),
-                                                     ea_data_int,
-                                                     ea_data_ext,
-                                                     i);
+      if (int_face_restrict_lex)
+      {
+         int_face_restrict_lex->Mult(x, int_face_x);
+         if (int_face_x.Size() > 0)
+         {
+            int_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultTransposePA(int_face_x, int_face_y);
+            }
+            if (c != 1.0)
+            {
+               int_face_y *= c;
+            }
+            int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+         }
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultTransposePA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultTransposePA(x, y);
+            }
+         }
+      }
    }
 
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int boundFaceIntegratorCount = bdrFaceIntegrators.Size();
-   if (boundFaceIntegratorCount>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_integrators.Size() > 0 || bdr_face_integrators.Size() > 0)
    {
-      nf_bdr = trial_fes->GetNFbyType(FaceType::Boundary);
-      ea_data_bdr.SetSize(nf_bdr*faceDofs*faceDofs, Device::GetMemoryType());
-      ea_data_bdr = 0.0;
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+            }
+            if (c != 1.0)
+            {
+               bdr_face_y *= c;
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(x, temp_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultTransposePA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(x, y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultTransposePA(x, y);
+            }
+         }
+      }
+   }
+}
+
+/// Data and methods for element-assembled bilinear forms
+EABilinearFormExtension::EABilinearFormExtension(BilinearForm *form)
+   : PABilinearFormExtension(form),
+     factorize_face_terms(fes->IsDGSpace() && fes->Conforming())
+{
+}
+
+void EABilinearFormExtension::Assemble()
+{
+   SetupRestrictionOperators(L2FaceValues::SingleValued);
+
+   ne = fes->GetNE();
+   elem_dofs = fes->GetFE(0)->GetDof();
+
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
+   {
+      ea_data.SetSize(ne * elem_dofs * elem_dofs, Device::GetMemoryType());
+      ea_data.UseDevice(true);
+      ea_data = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AssembleEA(*fes, ea_data);
+      }
+   }
+
+   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
+               "Element assembly does not support AddBoundaryIntegrator yet.");
+
+   nf_int = fes->GetNFbyType(FaceType::Interior);
+   nf_bdr = fes->GetNFbyType(FaceType::Boundary);
+   face_dofs = fes->GetTraceElement(0,
+                                    fes->GetMesh()->GetFaceGeometry(0))->GetDof();
+
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
+   {
+      ea_data_int.SetSize(2 * nf_int * face_dofs * face_dofs,
+                          Device::GetMemoryType());
+      ea_data_ext.SetSize(2 * nf_int * face_dofs * face_dofs,
+                          Device::GetMemoryType());
+      ea_data_int = 0.0;
+      ea_data_ext = 0.0;
+      for (BilinearFormIntegrator *integ : int_face_integrators)
+      {
+         integ->AssembleEAInteriorFaces(*fes, ea_data_int, ea_data_ext);
+      }
    }
-   for (int i = 0; i < boundFaceIntegratorCount; ++i)
+
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_face_integrators.Size() > 0)
    {
-      bdrFaceIntegrators[i]->AssembleEABoundaryFaces(*a->FESpace(),ea_data_bdr,i);
+      ea_data_bdr.SetSize(nf_bdr * face_dofs * face_dofs, Device::GetMemoryType());
+      ea_data_bdr = 0.0;
+      for (BilinearFormIntegrator *integ : bdr_face_integrators)
+      {
+         integ->AssembleEABoundaryFaces(*fes, ea_data_bdr);
+      }
    }
 
    if (factorize_face_terms && int_face_restrict_lex)
    {
-      auto restFint = dynamic_cast<const L2FaceRestriction*>(int_face_restrict_lex);
-      restFint->AddFaceMatricesToElementMatrices(ea_data_int, ea_data);
+      auto l2_face_restrict = dynamic_cast<const L2FaceRestriction &>
+                              (*int_face_restrict_lex);
+      l2_face_restrict.AddFaceMatricesToElementMatrices(ea_data_int, ea_data);
    }
    if (factorize_face_terms && bdr_face_restrict_lex)
    {
-      auto restFbdr = dynamic_cast<const L2FaceRestriction*>(bdr_face_restrict_lex);
-      restFbdr->AddFaceMatricesToElementMatrices(ea_data_bdr, ea_data);
+      auto l2_face_restrict = dynamic_cast<const L2FaceRestriction &>
+                              (*bdr_face_restrict_lex);
+      l2_face_restrict.AddFaceMatricesToElementMatrices(ea_data_bdr, ea_data);
    }
 }
 
 void EABilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   // Apply the Element Restriction
-   const bool useRestrict = !DeviceCanUseCeed() && elem_restrict;
-   if (!useRestrict)
-   {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-   }
-   else
-   {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-   }
-   // Apply the Element Matrices
-   {
-      const int NDOFS = elemDofs;
-      auto X = Reshape(useRestrict?localX.Read():x.Read(), NDOFS, ne);
-      auto Y = Reshape(useRestrict?localY.ReadWrite():y.ReadWrite(), NDOFS, ne);
-      auto A = Reshape(ea_data.Read(), NDOFS, NDOFS, ne);
-      mfem::forall(ne*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   auto Apply = [](const int nelem, const int ndofs, const Vector &data,
+                   const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, nelem);
+      auto Y = Reshape(y.ReadWrite(), ndofs, nelem);
+      auto A = Reshape(data.Read(), ndofs, ndofs, nelem);
+      mfem::forall(nelem * ndofs, [=] MFEM_HOST_DEVICE (int k)
       {
-         const int e = glob_j/NDOFS;
-         const int j = glob_j%NDOFS;
+         const int e = k / ndofs;
+         const int j = k % ndofs;
          double res = 0.0;
-         for (int i = 0; i < NDOFS; i++)
+         for (int i = 0; i < ndofs; i++)
          {
-            res += A(i, j, e)*X(i, e);
+            res += A(i, j, e) * X(i, e);
          }
          Y(j, e) += res;
       });
-      // Apply the Element Restriction transposed
-      if (useRestrict)
+   };
+   if (integrators.Size() > 0 && elem_restrict)
+   {
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      Apply(ne, elem_dofs, ea_data, local_x, local_y);
+      elem_restrict->MultTranspose(local_y, y);
+   }
+   else
+   {
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      y = 0.0;
+      if (integrators.Size() > 0)
       {
-         elem_restrict->MultTranspose(localY, y);
+         Apply(ne, elem_dofs, ea_data, x, y);
       }
    }
 
    // Treatment of interior faces
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
-   {
-      // Apply the Interior Face Restriction
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
-      {
-         int_face_Y = 0.0;
-         // Apply the interior face matrices
-         const int NDOFS = faceDofs;
-         auto X = Reshape(int_face_X.Read(), NDOFS, 2, nf_int);
-         auto Y = Reshape(int_face_Y.ReadWrite(), NDOFS, 2, nf_int);
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   auto ApplyIntFace = [](const int nface, const int ndofs, const Vector &data,
+                          const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 0, f) * X(i, 0, f);
+         }
+         Y(j, 0, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 1, f) * X(i, 1, f);
+         }
+         Y(j, 1, f) += res;
+      });
+   };
+   auto ApplyExtFace = [](const int nface, const int ndofs, const Vector &data,
+                          const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 0, f) * X(i, 0, f);
+         }
+         Y(j, 1, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 1, f) * X(i, 1, f);
+         }
+         Y(j, 0, f) += res;
+      });
+   };
+   if (int_face_restrict_lex && int_face_integrators.Size() > 0)
+   {
+      int_face_restrict_lex->Mult(x, int_face_x);
+      if (int_face_x.Size() > 0)
+      {
+         int_face_y = 0.0;
          if (!factorize_face_terms)
          {
-            auto A_int = Reshape(ea_data_int.Read(), NDOFS, NDOFS, 2, nf_int);
-            mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-            {
-               const int f = glob_j/NDOFS;
-               const int j = glob_j%NDOFS;
-               double res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(i, j, 0, f)*X(i, 0, f);
-               }
-               Y(j, 0, f) += res;
-               res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(i, j, 1, f)*X(i, 1, f);
-               }
-               Y(j, 1, f) += res;
-            });
-         }
-         auto A_ext = Reshape(ea_data_ext.Read(), NDOFS, NDOFS, 2, nf_int);
-         mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(i, j, 0, f)*X(i, 0, f);
-            }
-            Y(j, 1, f) += res;
-            res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(i, j, 1, f)*X(i, 1, f);
-            }
-            Y(j, 0, f) += res;
-         });
-         // Apply the Interior Face Restriction transposed
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+            ApplyIntFace(nf_int, face_dofs, ea_data_int, int_face_x, int_face_y);
+         }
+         ApplyExtFace(nf_int, face_dofs, ea_data_ext, int_face_x, int_face_y);
+         int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
       }
    }
 
    // Treatment of boundary faces
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (!factorize_face_terms && bdr_face_restrict_lex && bFISz>0)
-   {
-      // Apply the Boundary Face Restriction
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
-      {
-         bdr_face_Y = 0.0;
-         // Apply the boundary face matrices
-         const int NDOFS = faceDofs;
-         auto X = Reshape(bdr_face_X.Read(), NDOFS, nf_bdr);
-         auto Y = Reshape(bdr_face_Y.ReadWrite(), NDOFS, nf_bdr);
-         auto A = Reshape(ea_data_bdr.Read(), NDOFS, NDOFS, nf_bdr);
-         mfem::forall(nf_bdr*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A(i, j, f)*X(i, f);
-            }
-            Y(j, f) += res;
-         });
-         // Apply the Boundary Face Restriction transposed
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (!factorize_face_terms && bdr_face_restrict_lex &&
+       bdr_face_integrators.Size() > 0)
+   {
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
+      {
+         bdr_face_y = 0.0;
+         Apply(nf_bdr, face_dofs, ea_data_bdr, bdr_face_x, bdr_face_y);
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
       }
    }
 }
 
 void EABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 {
-   // Apply the Element Restriction
-   const bool useRestrict = !DeviceCanUseCeed() && elem_restrict;
-   if (!useRestrict)
-   {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-   }
-   else
-   {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-   }
-   // Apply the Element Matrices transposed
-   {
-      const int NDOFS = elemDofs;
-      auto X = Reshape(useRestrict?localX.Read():x.Read(), NDOFS, ne);
-      auto Y = Reshape(useRestrict?localY.ReadWrite():y.ReadWrite(), NDOFS, ne);
-      auto A = Reshape(ea_data.Read(), NDOFS, NDOFS, ne);
-      mfem::forall(ne*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   auto ApplyTranspose = [](const int nelem, const int ndofs, const Vector &data,
+                            const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, nelem);
+      auto Y = Reshape(y.ReadWrite(), ndofs, nelem);
+      auto A = Reshape(data.Read(), ndofs, ndofs, nelem);
+      mfem::forall(nelem * ndofs, [=] MFEM_HOST_DEVICE (int k)
       {
-         const int e = glob_j/NDOFS;
-         const int j = glob_j%NDOFS;
+         const int e = k / ndofs;
+         const int j = k % ndofs;
          double res = 0.0;
-         for (int i = 0; i < NDOFS; i++)
+         for (int i = 0; i < ndofs; i++)
          {
-            res += A(j, i, e)*X(i, e);
+            res += A(j, i, e) * X(i, e);
          }
          Y(j, e) += res;
       });
-      // Apply the Element Restriction transposed
-      if (useRestrict)
+   };
+   if (integrators.Size() > 0 && elem_restrict)
+   {
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      ApplyTranspose(ne, elem_dofs, ea_data, local_x, local_y);
+      elem_restrict->MultTranspose(local_y, y);
+   }
+   else
+   {
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      y = 0.0;
+      if (integrators.Size() > 0)
       {
-         elem_restrict->MultTranspose(localY, y);
+         ApplyTranspose(ne, elem_dofs, ea_data, x, y);
       }
    }
 
    // Treatment of interior faces
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
-   {
-      // Apply the Interior Face Restriction
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
-      {
-         int_face_Y = 0.0;
-         // Apply the interior face matrices transposed
-         const int NDOFS = faceDofs;
-         auto X = Reshape(int_face_X.Read(), NDOFS, 2, nf_int);
-         auto Y = Reshape(int_face_Y.ReadWrite(), NDOFS, 2, nf_int);
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   auto ApplyIntFaceTranspose = [](const int nface, const int ndofs,
+                                   const Vector &data, const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 0, f) * X(i, 0, f);
+         }
+         Y(j, 0, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 1, f) * X(i, 1, f);
+         }
+         Y(j, 1, f) += res;
+      });
+   };
+   auto ApplyExtFaceTranspose = [](const int nface, const int ndofs,
+                                   const Vector &data, const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 1, f) * X(i, 0, f);
+         }
+         Y(j, 1, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 0, f) * X(i, 1, f);
+         }
+         Y(j, 0, f) += res;
+      });
+   };
+   if (int_face_restrict_lex && int_face_integrators.Size() > 0)
+   {
+      int_face_restrict_lex->Mult(x, int_face_x);
+      if (int_face_x.Size() > 0)
+      {
+         int_face_y = 0.0;
          if (!factorize_face_terms)
          {
-            auto A_int = Reshape(ea_data_int.Read(), NDOFS, NDOFS, 2, nf_int);
-            mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-            {
-               const int f = glob_j/NDOFS;
-               const int j = glob_j%NDOFS;
-               double res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(j, i, 0, f)*X(i, 0, f);
-               }
-               Y(j, 0, f) += res;
-               res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(j, i, 1, f)*X(i, 1, f);
-               }
-               Y(j, 1, f) += res;
-            });
-         }
-         auto A_ext = Reshape(ea_data_ext.Read(), NDOFS, NDOFS, 2, nf_int);
-         mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(j, i, 1, f)*X(i, 0, f);
-            }
-            Y(j, 1, f) += res;
-            res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(j, i, 0, f)*X(i, 1, f);
-            }
-            Y(j, 0, f) += res;
-         });
-         // Apply the Interior Face Restriction transposed
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+            ApplyIntFaceTranspose(nf_int, face_dofs, ea_data_int, int_face_x, int_face_y);
+         }
+         ApplyExtFaceTranspose(nf_int, face_dofs, ea_data_ext, int_face_x, int_face_y);
+         int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
       }
    }
 
    // Treatment of boundary faces
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (!factorize_face_terms && bdr_face_restrict_lex && bFISz>0)
-   {
-      // Apply the Boundary Face Restriction
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
-      {
-         bdr_face_Y = 0.0;
-         // Apply the boundary face matrices transposed
-         const int NDOFS = faceDofs;
-         auto X = Reshape(bdr_face_X.Read(), NDOFS, nf_bdr);
-         auto Y = Reshape(bdr_face_Y.ReadWrite(), NDOFS, nf_bdr);
-         auto A = Reshape(ea_data_bdr.Read(), NDOFS, NDOFS, nf_bdr);
-         mfem::forall(nf_bdr*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A(j, i, f)*X(i, f);
-            }
-            Y(j, f) += res;
-         });
-         // Apply the Boundary Face Restriction transposed
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (!factorize_face_terms && bdr_face_restrict_lex &&
+       bdr_face_integrators.Size() > 0)
+   {
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
+      {
+         bdr_face_y = 0.0;
+         ApplyTranspose(nf_bdr, face_dofs, ea_data_bdr, bdr_face_x, bdr_face_y);
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
       }
    }
 }
 
-// Data and methods for fully-assembled bilinear forms
+/// Data and methods for fully-assembled bilinear forms
 FABilinearFormExtension::FABilinearFormExtension(BilinearForm *form)
    : EABilinearFormExtension(form),
      mat(a->mat)
 {
 #ifdef MFEM_USE_MPI
-   ParFiniteElementSpace *pfes = nullptr;
-   if ( a->GetFBFI()->Size()>0 &&
-        (pfes = dynamic_cast<ParFiniteElementSpace*>(form->FESpace())) )
+   const ParFiniteElementSpace *pfes = nullptr;
+   if (a->GetFBFI()->Size() > 0 &&
+       (pfes = dynamic_cast<const ParFiniteElementSpace *>(form->FESpace())))
    {
-      pfes->ExchangeFaceNbrData();
+      const_cast<ParFiniteElementSpace *>(pfes)->ExchangeFaceNbrData();
    }
 #endif
 }
@@ -850,20 +1299,20 @@ FABilinearFormExtension::FABilinearFormExtension(BilinearForm *form)
 void FABilinearFormExtension::Assemble()
 {
    EABilinearFormExtension::Assemble();
-   FiniteElementSpace &fes = *a->FESpace();
-   int width = fes.GetVSize();
-   int height = fes.GetVSize();
+
+   int width = fes->GetVSize();
+   int height = fes->GetVSize();
    bool keep_nbr_block = false;
 #ifdef MFEM_USE_MPI
-   ParFiniteElementSpace *pfes = nullptr;
-   if ( a->GetFBFI()->Size()>0 &&
-        (pfes = dynamic_cast<ParFiniteElementSpace*>(&fes)) )
+   const ParFiniteElementSpace *pfes = nullptr;
+   if (a->GetFBFI()->Size() > 0 &&
+       (pfes = dynamic_cast<const ParFiniteElementSpace *>(fes)))
    {
-      pfes->ExchangeFaceNbrData();
+      const_cast<ParFiniteElementSpace *>(pfes)->ExchangeFaceNbrData();
       width += pfes->GetFaceNbrVSize();
       dg_x.SetSize(width);
       ParBilinearForm *pb = nullptr;
-      if ((pb = dynamic_cast<ParBilinearForm*>(a)) && (pb->keep_nbr_block))
+      if ((pb = dynamic_cast<ParBilinearForm *>(a)) && pb->keep_nbr_block)
       {
          height += pfes->GetFaceNbrVSize();
          dg_y.SetSize(height);
@@ -873,15 +1322,14 @@ void FABilinearFormExtension::Assemble()
 #endif
    if (a->mat) // We reuse the sparse matrix memory
    {
-      if (fes.IsDGSpace())
+      if (fes->IsDGSpace())
       {
-         const L2ElementRestriction *restE =
-            static_cast<const L2ElementRestriction*>(elem_restrict);
-         const L2FaceRestriction *restF =
-            static_cast<const L2FaceRestriction*>(int_face_restrict_lex);
-         MFEM_VERIFY(
-            fes.Conforming(),
-            "Full Assembly not yet supported on NCMesh.");
+         const auto *restE =
+            static_cast<const L2ElementRestriction *>(elem_restrict);
+         const auto *restF =
+            static_cast<const L2FaceRestriction *>(int_face_restrict_lex);
+         MFEM_VERIFY(fes->Conforming(),
+                     "Full Assembly not yet supported on NCMesh.");
          // 1. Fill J and Data
          // 1.1 Fill J and Data with Elem ea_data
          restE->FillJAndData(ea_data, *mat);
@@ -897,8 +1345,8 @@ void FABilinearFormExtension::Assemble()
       }
       else
       {
-         const ElementRestriction &rest =
-            static_cast<const ElementRestriction&>(*elem_restrict);
+         const auto &rest =
+            static_cast<const ConformingElementRestriction&>(*elem_restrict);
          rest.FillJAndData(ea_data, *mat);
       }
    }
@@ -906,15 +1354,14 @@ void FABilinearFormExtension::Assemble()
    {
       mat = new SparseMatrix;
       mat->OverrideSize(height, width);
-      if (fes.IsDGSpace())
-      {
-         const L2ElementRestriction *restE =
-            static_cast<const L2ElementRestriction*>(elem_restrict);
-         const L2FaceRestriction *restF =
-            static_cast<const L2FaceRestriction*>(int_face_restrict_lex);
-         MFEM_VERIFY(
-            fes.Conforming(),
-            "Full Assembly not yet supported on NCMesh.");
+      if (fes->IsDGSpace())
+      {
+         const auto *restE =
+            static_cast<const L2ElementRestriction *>(elem_restrict);
+         const auto *restF =
+            static_cast<const L2FaceRestriction *>(int_face_restrict_lex);
+         MFEM_VERIFY(fes->Conforming(),
+                     "Full Assembly not yet supported on NCMesh.");
          // 1. Fill I
          mat->GetMemoryI().New(height+1, mat->GetMemoryI().GetMemoryType());
          //  1.1 Increment with restE
@@ -947,87 +1394,32 @@ void FABilinearFormExtension::Assemble()
          }
          I[0] = 0;
       }
-      else // continuous Galerkin case
+      else
       {
-         const ElementRestriction &rest =
-            static_cast<const ElementRestriction&>(*elem_restrict);
+         const auto &rest =
+            static_cast<const ConformingElementRestriction &>(*elem_restrict);
          rest.FillSparseMatrix(ea_data, *mat);
       }
       a->mat = mat;
    }
-   if ( a->sort_sparse_matrix )
+   if (a->sort_sparse_matrix)
    {
       a->mat->SortColumnIndices();
    }
 }
 
-
-void FABilinearFormExtension::RAP(OperatorHandle &A)
-{
-#ifdef MFEM_USE_MPI
-   if ( auto pa = dynamic_cast<ParBilinearForm*>(a) )
-   {
-      pa->ParallelRAP(*pa->mat, A);
-   }
-   else
-#endif
-   {
-      a->SerialRAP(A);
-   }
-}
-
-void FABilinearFormExtension::EliminateBC(const Array<int> &ess_dofs,
-                                          OperatorHandle &A)
-{
-   MFEM_VERIFY(a->diag_policy == DiagonalPolicy::DIAG_ONE,
-               "Only DiagonalPolicy::DIAG_ONE supported with"
-               " FABilinearFormExtension.");
-#ifdef MFEM_USE_MPI
-   if ( dynamic_cast<ParBilinearForm*>(a) )
-   {
-      A.As<HypreParMatrix>()->EliminateBC(ess_dofs,
-                                          DiagonalPolicy::DIAG_ONE);
-   }
-   else
-#endif
-   {
-      A.As<SparseMatrix>()->EliminateBC(ess_dofs,
-                                        DiagonalPolicy::DIAG_ONE);
-   }
-}
-
-void FABilinearFormExtension::FormSystemMatrix(const Array<int> &ess_dofs,
-                                               OperatorHandle &A)
-{
-   RAP(A);
-   EliminateBC(ess_dofs, A);
-}
-
-void FABilinearFormExtension::FormLinearSystem(const Array<int> &ess_tdof_list,
-                                               Vector &x, Vector &b,
-                                               OperatorHandle &A,
-                                               Vector &X, Vector &B,
-                                               int copy_interior)
-{
-   Operator *A_out;
-   Operator::FormLinearSystem(ess_tdof_list, x, b, A_out, X, B, copy_interior);
-   delete A_out;
-   FormSystemMatrix(ess_tdof_list, A);
-}
-
 void FABilinearFormExtension::DGMult(const Vector &x, Vector &y) const
 {
 #ifdef MFEM_USE_MPI
-   const ParFiniteElementSpace *pfes;
-   if ( (pfes = dynamic_cast<const ParFiniteElementSpace*>(test_fes)) )
+   if (const auto pfes = dynamic_cast<const ParFiniteElementSpace *>(fes))
    {
       // DG Prolongation
       ParGridFunction x_gf;
-      x_gf.MakeRef(const_cast<ParFiniteElementSpace*>(pfes),
-                   const_cast<Vector&>(x),0);
+      x_gf.MakeRef(const_cast<ParFiniteElementSpace *>(pfes),
+                   const_cast<Vector &>(x), 0);
       x_gf.ExchangeFaceNbrData();
       Vector &shared_x = x_gf.FaceNbrData();
-      const int local_size = a->FESpace()->GetVSize();
+      const int local_size = fes->GetVSize();
       auto dg_x_ptr = dg_x.Write();
       auto x_ptr = x.Read();
       mfem::forall(local_size, [=] MFEM_HOST_DEVICE (int i)
@@ -1040,8 +1432,8 @@ void FABilinearFormExtension::DGMult(const Vector &x, Vector &y) const
       {
          dg_x_ptr[local_size+i] = shared_x_ptr[i];
       });
-      ParBilinearForm *pform = nullptr;
-      if ((pform = dynamic_cast<ParBilinearForm*>(a)) && (pform->keep_nbr_block))
+      ParBilinearForm *pb = nullptr;
+      if ((pb = dynamic_cast<ParBilinearForm *>(a)) && pb->keep_nbr_block)
       {
          mat->Mult(dg_x, dg_y);
          // DG Restriction
@@ -1066,7 +1458,7 @@ void FABilinearFormExtension::DGMult(const Vector &x, Vector &y) const
 
 void FABilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   if ( a->GetFBFI()->Size()>0 )
+   if (a->GetFBFI()->Size() > 0)
    {
       DGMult(x, y);
    }
@@ -1079,16 +1471,15 @@ void FABilinearFormExtension::Mult(const Vector &x, Vector &y) const
 void FABilinearFormExtension::DGMultTranspose(const Vector &x, Vector &y) const
 {
 #ifdef MFEM_USE_MPI
-   const ParFiniteElementSpace *pfes;
-   if ( (pfes = dynamic_cast<const ParFiniteElementSpace*>(test_fes)) )
+   if (const auto pfes = dynamic_cast<const ParFiniteElementSpace *>(fes))
    {
       // DG Prolongation
       ParGridFunction x_gf;
-      x_gf.MakeRef(const_cast<ParFiniteElementSpace*>(pfes),
-                   const_cast<Vector&>(x),0);
+      x_gf.MakeRef(const_cast<ParFiniteElementSpace *>(pfes),
+                   const_cast<Vector &>(x), 0);
       x_gf.ExchangeFaceNbrData();
       Vector &shared_x = x_gf.FaceNbrData();
-      const int local_size = a->FESpace()->GetVSize();
+      const int local_size = fes->GetVSize();
       auto dg_x_ptr = dg_x.Write();
       auto x_ptr = x.Read();
       mfem::forall(local_size, [=] MFEM_HOST_DEVICE (int i)
@@ -1102,7 +1493,7 @@ void FABilinearFormExtension::DGMultTranspose(const Vector &x, Vector &y) const
          dg_x_ptr[local_size+i] = shared_x_ptr[i];
       });
       ParBilinearForm *pb = nullptr;
-      if ((pb = dynamic_cast<ParBilinearForm*>(a)) && (pb->keep_nbr_block))
+      if ((pb = dynamic_cast<ParBilinearForm *>(a)) && (pb->keep_nbr_block))
       {
          mat->MultTranspose(dg_x, dg_y);
          // DG Restriction
@@ -1127,7 +1518,7 @@ void FABilinearFormExtension::DGMultTranspose(const Vector &x, Vector &y) const
 
 void FABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 {
-   if ( a->GetFBFI()->Size()>0 )
+   if (a->GetFBFI()->Size() > 0)
    {
       DGMultTranspose(x, y);
    }
@@ -1138,403 +1529,738 @@ void FABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 }
 
 
+/// Base class for extensions to the MixedBilinearForm class
 MixedBilinearFormExtension::MixedBilinearFormExtension(MixedBilinearForm *form)
    : Operator(form->Height(), form->Width()), a(form)
 {
-   // empty
 }
 
-const Operator *MixedBilinearFormExtension::GetProlongation() const
+const Operator *MixedBilinearFormExtension::GetProlongation() const
+{
+   return a->GetProlongation();
+}
+
+const Operator *MixedBilinearFormExtension::GetRestriction() const
+{
+   return a->GetRestriction();
+}
+
+const Operator *MixedBilinearFormExtension::GetOutputProlongation() const
+{
+   return a->GetOutputProlongation();
+}
+
+const Operator *MixedBilinearFormExtension::GetOutputRestriction() const
+{
+   return a->GetOutputRestriction();
+}
+
+/// Data and methods for matrix-free mixed bilinear forms
+MFMixedBilinearFormExtension::MFMixedBilinearFormExtension(
+   MixedBilinearForm *form)
+   : MixedBilinearFormExtension(form)
+{
+   Update();
+}
+
+void MFMixedBilinearFormExtension::SetupRestrictionOperators(
+   const L2FaceValues m)
+{
+   if (DeviceCanUseCeed()) { return; }
+   ElementDofOrdering trial_ordering = UsesTensorBasis(*trial_fes) ?
+                                       ElementDofOrdering::LEXICOGRAPHIC :
+                                       ElementDofOrdering::NATIVE;
+   ElementDofOrdering test_ordering = UsesTensorBasis(*test_fes) ?
+                                      ElementDofOrdering::LEXICOGRAPHIC :
+                                      ElementDofOrdering::NATIVE;
+   elem_restrict_trial = trial_fes->GetElementRestriction(trial_ordering);
+   elem_restrict_test = test_fes->GetElementRestriction(test_ordering);
+   if (elem_restrict_trial)
+   {
+      local_trial.SetSize(elem_restrict_trial->Height(),
+                          Device::GetDeviceMemoryType());
+      local_trial.UseDevice(true); // ensure 'local_trial = 0.0' is done on device
+   }
+   if (elem_restrict_test)
+   {
+      local_test.SetSize(elem_restrict_test->Height(),
+                         Device::GetDeviceMemoryType());
+      local_test.UseDevice(true); // ensure 'local_test = 0.0' is done on device
+   }
+
+   // Construct face restriction operators only if the bilinear form has
+   // interior or boundary face integrators
+   if (a->GetTFBFI()->Size() > 0)
+   {
+      if (int_face_restrict_lex_trial == nullptr)
+      {
+         int_face_restrict_lex_trial = trial_fes->GetFaceRestriction(
+                                          ElementDofOrdering::LEXICOGRAPHIC,
+                                          FaceType::Interior);
+         int_face_trial.SetSize(int_face_restrict_lex_trial->Height(),
+                                Device::GetDeviceMemoryType());
+         int_face_trial.UseDevice(true);
+      }
+      if (int_face_restrict_lex_test == nullptr)
+      {
+         int_face_restrict_lex_test = test_fes->GetFaceRestriction(
+                                         ElementDofOrdering::LEXICOGRAPHIC,
+                                         FaceType::Interior);
+         int_face_test.SetSize(int_face_restrict_lex_test->Height(),
+                               Device::GetDeviceMemoryType());
+         int_face_test.UseDevice(true);
+      }
+   }
+
+   if (a->GetBTFBFI()->Size() > 0 || a->GetBBFI()->Size() > 0)
+   {
+      if (bdr_face_restrict_lex_trial == nullptr)
+      {
+         bdr_face_restrict_lex_trial = trial_fes->GetFaceRestriction(
+                                          ElementDofOrdering::LEXICOGRAPHIC,
+                                          FaceType::Boundary,
+                                          m);
+         bdr_face_trial.SetSize(bdr_face_restrict_lex_trial->Height(),
+                                Device::GetDeviceMemoryType());
+         bdr_face_trial.UseDevice(true);
+      }
+      if (bdr_face_restrict_lex_test == nullptr)
+      {
+         bdr_face_restrict_lex_test = test_fes->GetFaceRestriction(
+                                         ElementDofOrdering::LEXICOGRAPHIC,
+                                         FaceType::Boundary,
+                                         m);
+         bdr_face_test.SetSize(bdr_face_restrict_lex_test->Height(),
+                               Device::GetDeviceMemoryType());
+         bdr_face_test.UseDevice(true);
+      }
+   }
+}
+
+void MFMixedBilinearFormExtension::Assemble()
+{
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
+
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
+   {
+      integ->AssembleMF(*trial_fes, *test_fes);
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
+   {
+      integ->AssembleMFBoundary(*trial_fes, *test_fes);
+   }
+
+   MFEM_VERIFY(a->GetTFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in MFMixedBilinearFormExtension");
+
+   MFEM_VERIFY(a->GetBTFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in MFMixedBilinearFormExtension");
+}
+
+void MFMixedBilinearFormExtension::Mult(const Vector &x, Vector &y) const
+{
+   y = 0.0;
+   AddMult(x, y);
+}
+
+void MFMixedBilinearFormExtension::AddMult(const Vector &x, Vector &y,
+                                           const double c) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
+   {
+      if (elem_restrict_trial)
+      {
+         elem_restrict_trial->Mult(x, local_trial);
+      }
+      if (elem_restrict_test)
+      {
+         local_test = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultMF(elem_restrict_trial ? local_trial : x, local_test);
+         }
+         if (c != 1.0)
+         {
+            local_test *= c;
+         }
+         elem_restrict_test->AddMultTranspose(local_test, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_test.SetSize(y.Size());
+            temp_test.UseDevice(true);
+            temp_test = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultMF(elem_restrict_trial ? local_trial : x, temp_test);
+            }
+            y.Add(c, temp_test);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultMF(elem_restrict_trial ? local_trial : x, y);
+            }
+         }
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex_trial)
+      {
+         bdr_face_restrict_lex_trial->Mult(x, bdr_face_trial);
+      }
+      if (bdr_face_restrict_lex_test)
+      {
+         bdr_face_test = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultMF(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                             bdr_face_test);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_test *= c;
+         }
+         bdr_face_restrict_lex_test->AddMultTranspose(bdr_face_test, y);
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_test.SetSize(y.Size());
+            temp_test.UseDevice(true);
+            temp_test = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                                temp_test);
+            }
+            y.Add(c, temp_test);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(bdr_face_restrict_lex_trial ? bdr_face_trial : x, y);
+            }
+         }
+      }
+   }
+}
+
+void MFMixedBilinearFormExtension::MultTranspose(const Vector &x,
+                                                 Vector &y) const
 {
-   return a->GetProlongation();
+   y = 0.0;
+   AddMultTranspose(x, y);
 }
 
-const Operator *MixedBilinearFormExtension::GetRestriction() const
+void MFMixedBilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
+                                                    const double c) const
 {
-   return a->GetRestriction();
-}
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
+   {
+      if (elem_restrict_test)
+      {
+         elem_restrict_test->Mult(x, local_test);
+      }
+      if (elem_restrict_trial)
+      {
+         local_trial = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposeMF(elem_restrict_test ? local_test : x,
+                                      local_trial);
+         }
+         if (c != 1.0)
+         {
+            local_trial *= c;
+         }
+         elem_restrict_trial->AddMultTranspose(local_trial, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_trial.SetSize(y.Size());
+            temp_trial.UseDevice(true);
+            temp_trial = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(elem_restrict_test ? local_test : x,
+                                         temp_trial);
+            }
+            y.Add(c, temp_trial);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(elem_restrict_test ? local_test : x, y);
+            }
+         }
+      }
+   }
 
-const Operator *MixedBilinearFormExtension::GetOutputProlongation() const
-{
-   return a->GetOutputProlongation();
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex_test)
+      {
+         bdr_face_restrict_lex_test->Mult(x, bdr_face_test);
+      }
+      if (bdr_face_restrict_lex_trial)
+      {
+         bdr_face_trial = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposeMF(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                      bdr_face_trial);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_trial *= c;
+         }
+         bdr_face_restrict_lex_trial->AddMultTranspose(bdr_face_trial, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_trial.SetSize(y.Size());
+            temp_trial.UseDevice(true);
+            temp_trial = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                         temp_trial);
+            }
+            y.Add(c, temp_trial);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(bdr_face_restrict_lex_test ? bdr_face_test : x, y);
+            }
+         }
+      }
+   }
 }
 
-const Operator *MixedBilinearFormExtension::GetOutputRestriction() const
+void MFMixedBilinearFormExtension::Update()
 {
-   return a->GetOutputRestriction();
+   trial_fes = a->TrialFESpace();
+   test_fes  = a->TestFESpace();
+   height = test_fes->GetVSize();
+   width  = trial_fes->GetVSize();
+
+   elem_restrict_trial = nullptr;
+   elem_restrict_test = nullptr;
+   int_face_restrict_lex_trial = nullptr;
+   int_face_restrict_lex_test = nullptr;
+   bdr_face_restrict_lex_trial = nullptr;
+   bdr_face_restrict_lex_test = nullptr;
 }
 
-// Data and methods for partially-assembled bilinear forms
-
+/// Data and methods for partially-assembled mixed bilinear forms
 PAMixedBilinearFormExtension::PAMixedBilinearFormExtension(
    MixedBilinearForm *form)
-   : MixedBilinearFormExtension(form),
-     trial_fes(form->TrialFESpace()),
-     test_fes(form->TestFESpace()),
-     elem_restrict_trial(NULL),
-     elem_restrict_test(NULL)
+   : MFMixedBilinearFormExtension(form)
 {
-   Update();
 }
 
 void PAMixedBilinearFormExtension::Assemble()
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
-   {
-      integrators[i]->AssemblePA(*trial_fes, *test_fes);
-   }
-   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
-               "Partial assembly does not support AddBoundaryIntegrator yet.");
-   MFEM_VERIFY(a->GetTFBFI()->Size() == 0,
-               "Partial assembly does not support AddTraceFaceIntegrator yet.");
-   MFEM_VERIFY(a->GetBTFBFI()->Size() == 0,
-               "Partial assembly does not support AddBdrTraceFaceIntegrator yet.");
-}
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
 
-void PAMixedBilinearFormExtension::Update()
-{
-   trial_fes = a->TrialFESpace();
-   test_fes  = a->TestFESpace();
-   height = test_fes->GetVSize();
-   width = trial_fes->GetVSize();
-   elem_restrict_trial = trial_fes->GetElementRestriction(
-                            ElementDofOrdering::LEXICOGRAPHIC);
-   elem_restrict_test  =  test_fes->GetElementRestriction(
-                             ElementDofOrdering::LEXICOGRAPHIC);
-   if (elem_restrict_trial)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
    {
-      localTrial.UseDevice(true);
-      localTrial.SetSize(elem_restrict_trial->Height(),
-                         Device::GetMemoryType());
+      integ->AssemblePA(*trial_fes, *test_fes);
    }
-   if (elem_restrict_test)
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
    {
-      localTest.UseDevice(true); // ensure 'localY = 0.0' is done on device
-      localTest.SetSize(elem_restrict_test->Height(), Device::GetMemoryType());
+      integ->AssemblePABoundary(*trial_fes, *test_fes);
    }
-}
 
-void PAMixedBilinearFormExtension::FormRectangularSystemOperator(
-   const Array<int> &trial_tdof_list,
-   const Array<int> &test_tdof_list,
-   OperatorHandle &A)
-{
-   Operator * oper;
-   Operator::FormRectangularSystemOperator(trial_tdof_list, test_tdof_list,
-                                           oper);
-   A.Reset(oper); // A will own oper
-}
+   MFEM_VERIFY(a->GetTFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in PAMixedBilinearFormExtension");
 
-void PAMixedBilinearFormExtension::FormRectangularLinearSystem(
-   const Array<int> &trial_tdof_list,
-   const Array<int> &test_tdof_list,
-   Vector &x, Vector &b,
-   OperatorHandle &A,
-   Vector &X, Vector &B)
-{
-   Operator *oper;
-   Operator::FormRectangularLinearSystem(trial_tdof_list, test_tdof_list, x, b,
-                                         oper, X, B);
-   A.Reset(oper); // A will own oper
+   MFEM_VERIFY(a->GetBTFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in PAMixedBilinearFormExtension");
 }
 
-void PAMixedBilinearFormExtension::SetupMultInputs(
-   const Operator *elem_restrict_x,
-   const Vector &x,
-   Vector &localX,
-   const Operator *elem_restrict_y,
-   Vector &y,
-   Vector &localY,
-   const double c) const
+void PAMixedBilinearFormExtension::AssembleDiagonal_ADAt(const Vector &D,
+                                                         Vector &diag) const
 {
-   // * G operation: localX = c*local(x)
-   if (elem_restrict_x)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      elem_restrict_x->Mult(x, localX);
-      if (c != 1.0)
+      if (elem_restrict_trial)
+      {
+         elem_restrict_trial->MultUnsigned(D, local_trial);
+      }
+      if (elem_restrict_test)
       {
-         localX *= c;
+         local_test = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AssembleDiagonalPA_ADAt(elem_restrict_trial ? local_trial : D,
+                                           local_test);
+         }
+         elem_restrict_test->MultTransposeUnsigned(local_test, diag);
       }
    }
    else
    {
-      if (c == 1.0)
+      diag.UseDevice(true); // typically this is a large vector, so store on device
+      diag = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AssembleDiagonalPA_ADAt(elem_restrict_trial ? local_trial : D, diag);
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex_trial)
+      {
+         bdr_face_restrict_lex_trial->MultUnsigned(D, bdr_face_trial);
+      }
+      if (bdr_face_restrict_lex_test)
       {
-         localX.SyncAliasMemory(x);
+         bdr_face_test = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AssembleDiagonalPA_ADAt(bdr_face_restrict_lex_trial ? bdr_face_trial : D,
+                                           bdr_face_test);
+         }
+         bdr_face_restrict_lex_test->AddMultTransposeUnsigned(bdr_face_test, diag);
       }
       else
       {
-         localX.Set(c, x);
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AssembleDiagonalPA_ADAt(bdr_face_restrict_lex_trial ? bdr_face_trial : D,
+                                           diag);
+         }
       }
    }
-   if (elem_restrict_y)
-   {
-      localY = 0.0;
-   }
-   else
-   {
-      y.UseDevice(true);
-      localY.SyncAliasMemory(y);
-   }
-}
-
-void PAMixedBilinearFormExtension::Mult(const Vector &x, Vector &y) const
-{
-   y = 0.0;
-   AddMult(x, y);
 }
 
 void PAMixedBilinearFormExtension::AddMult(const Vector &x, Vector &y,
                                            const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // * G operation
-   SetupMultInputs(elem_restrict_trial, x, localTrial,
-                   elem_restrict_test, y, localTest, c);
-
-   // * B^TDB operation
-   for (int i = 0; i < iSz; ++i)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      integrators[i]->AddMultPA(localTrial, localTest);
+      if (elem_restrict_trial)
+      {
+         elem_restrict_trial->Mult(x, local_trial);
+      }
+      if (elem_restrict_test)
+      {
+         local_test = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultPA(elem_restrict_trial ? local_trial : x, local_test);
+         }
+         if (c != 1.0)
+         {
+            local_test *= c;
+         }
+         elem_restrict_test->AddMultTranspose(local_test, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_test.SetSize(y.Size());
+            temp_test.UseDevice(true);
+            temp_test = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultPA(elem_restrict_trial ? local_trial : x, temp_test);
+            }
+            y.Add(c, temp_test);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultPA(elem_restrict_trial ? local_trial : x, y);
+            }
+         }
+      }
    }
 
-   // * G^T operation
-   if (elem_restrict_test)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      tempY.SetSize(y.Size());
-      elem_restrict_test->MultTranspose(localTest, tempY);
-      y += tempY;
+      if (bdr_face_restrict_lex_trial)
+      {
+         bdr_face_restrict_lex_trial->Mult(x, bdr_face_trial);
+      }
+      if (bdr_face_restrict_lex_test)
+      {
+         bdr_face_test = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultPA(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                             bdr_face_test);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_test *= c;
+         }
+         bdr_face_restrict_lex_test->AddMultTranspose(bdr_face_test, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_test.SetSize(y.Size());
+            temp_test.UseDevice(true);
+            temp_test = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                                temp_test);
+            }
+            y.Add(c, temp_test);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(bdr_face_restrict_lex_trial ? bdr_face_trial : x, y);
+            }
+         }
+      }
    }
 }
 
-void PAMixedBilinearFormExtension::MultTranspose(const Vector &x,
-                                                 Vector &y) const
-{
-   y = 0.0;
-   AddMultTranspose(x, y);
-}
-
 void PAMixedBilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
                                                     const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // * G operation
-   SetupMultInputs(elem_restrict_test, x, localTest,
-                   elem_restrict_trial, y, localTrial, c);
-
-   // * B^TD^TB operation
-   for (int i = 0; i < iSz; ++i)
-   {
-      integrators[i]->AddMultTransposePA(localTest, localTrial);
-   }
-
-   // * G^T operation
-   if (elem_restrict_trial)
-   {
-      tempY.SetSize(y.Size());
-      elem_restrict_trial->MultTranspose(localTrial, tempY);
-      y += tempY;
-   }
-}
-
-void PAMixedBilinearFormExtension::AssembleDiagonal_ADAt(const Vector &D,
-                                                         Vector &diag) const
-{
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-
-   if (elem_restrict_trial)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      const ElementRestriction* H1elem_restrict_trial =
-         dynamic_cast<const ElementRestriction*>(elem_restrict_trial);
-      if (H1elem_restrict_trial)
+      if (elem_restrict_test)
       {
-         H1elem_restrict_trial->MultUnsigned(D, localTrial);
+         elem_restrict_test->Mult(x, local_test);
       }
-      else
+      if (elem_restrict_trial)
       {
-         elem_restrict_trial->Mult(D, localTrial);
+         local_trial = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposePA(elem_restrict_test ? local_test : x,
+                                      local_trial);
+         }
+         if (c != 1.0)
+         {
+            local_trial *= c;
+         }
+         elem_restrict_trial->AddMultTranspose(local_trial, y);
       }
-   }
-
-   if (elem_restrict_test)
-   {
-      localTest = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      else
       {
-         if (elem_restrict_trial)
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(localTrial, localTest);
+            temp_trial.SetSize(y.Size());
+            temp_trial.UseDevice(true);
+            temp_trial = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(elem_restrict_test ? local_test : x,
+                                         temp_trial);
+            }
+            y.Add(c, temp_trial);
          }
          else
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(D, localTest);
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(elem_restrict_test ? local_test : x, y);
+            }
          }
       }
-      const ElementRestriction* H1elem_restrict_test =
-         dynamic_cast<const ElementRestriction*>(elem_restrict_test);
-      if (H1elem_restrict_test)
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex_test)
       {
-         H1elem_restrict_test->MultTransposeUnsigned(localTest, diag);
+         bdr_face_restrict_lex_test->Mult(x, bdr_face_test);
       }
-      else
+      if (bdr_face_restrict_lex_trial)
       {
-         elem_restrict_test->MultTranspose(localTest, diag);
+         bdr_face_trial = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposePA(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                      bdr_face_trial);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_trial *= c;
+         }
+         bdr_face_restrict_lex_trial->AddMultTranspose(bdr_face_trial, y);
       }
-   }
-   else
-   {
-      diag.UseDevice(true); // typically this is a large vector, so store on device
-      diag = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      else
       {
-         if (elem_restrict_trial)
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(localTrial, diag);
+            temp_trial.SetSize(y.Size());
+            temp_trial.UseDevice(true);
+            temp_trial = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                         temp_trial);
+            }
+            y.Add(c, temp_trial);
          }
          else
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(D, diag);
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_restrict_lex_test ? bdr_face_test : x, y);
+            }
          }
       }
    }
 }
 
+/// Data and methods for partially-assembled discrete linear operators
 PADiscreteLinearOperatorExtension::PADiscreteLinearOperatorExtension(
    DiscreteLinearOperator *linop) :
    PAMixedBilinearFormExtension(linop)
 {
 }
 
-const
-Operator *PADiscreteLinearOperatorExtension::GetOutputRestrictionTranspose()
-const
-{
-   return a->GetOutputRestrictionTranspose();
-}
-
 void PADiscreteLinearOperatorExtension::Assemble()
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
-   {
-      integrators[i]->AssemblePA(*trial_fes, *test_fes);
-   }
+   PAMixedBilinearFormExtension::Assemble();
 
+   // Construct element vdof multiplicity (avoid use of elem_restrict_test
+   // because it might not exist for libCEED)
+   test_multiplicity.SetSize(height);
    test_multiplicity.UseDevice(true);
-   test_multiplicity.SetSize(elem_restrict_test->Width()); // l-vector
-   Vector ones(elem_restrict_test->Height()); // e-vector
-   ones = 1.0;
-
-   const ElementRestriction* elem_restrict =
-      dynamic_cast<const ElementRestriction*>(elem_restrict_test);
-   if (elem_restrict)
-   {
-      elem_restrict->MultTransposeUnsigned(ones, test_multiplicity);
-   }
-   else
-   {
-      mfem_error("A real ElementRestriction is required in this setting!");
+   test_multiplicity = 0.0;
+   Array<int> dofs;
+   for (int i = 0; i < test_fes->GetNE(); i++)
+   {
+      test_fes->GetElementVDofs(i, dofs);
+      const int ndofs = dofs.Size();
+      auto d_mult = test_multiplicity.HostReadWrite();
+      auto d_dofs = dofs.HostRead();
+      mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
+      {
+         const int j = d_dofs[i];
+         d_mult[(j >= 0) ? j : -1 - j] += 1.0;
+      });
    }
-
-   auto tm = test_multiplicity.ReadWrite();
-   mfem::forall(test_multiplicity.Size(), [=] MFEM_HOST_DEVICE (int i)
-   {
-      tm[i] = 1.0 / tm[i];
-   });
+   test_multiplicity.Reciprocal();
 }
 
-void PADiscreteLinearOperatorExtension::AddMult(
-   const Vector &x, Vector &y, const double c) const
+void PADiscreteLinearOperatorExtension::AddMult(const Vector &x, Vector &y,
+                                                const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // * G operation
-   SetupMultInputs(elem_restrict_trial, x, localTrial,
-                   elem_restrict_test, y, localTest, c);
-
-   // * B^TDB operation
-   for (int i = 0; i < iSz; ++i)
+   Array<BilinearFormIntegrator *> &interpolators = *a->GetDBFI();
+   temp_test.SetSize(y.Size());
+   temp_test.UseDevice(true);
+   if (elem_restrict_trial)
    {
-      integrators[i]->AddMultPA(localTrial, localTest);
+      elem_restrict_trial->Mult(x, local_trial);
    }
-
-   // do a kind of "set" rather than "add" in the below
-   // operation as compared to the BilinearForm case
-   // * G^T operation (kind of...)
-   const ElementRestriction* elem_restrict =
-      dynamic_cast<const ElementRestriction*>(elem_restrict_test);
-   if (elem_restrict)
+   if (elem_restrict_test)
    {
-      tempY.SetSize(y.Size());
-      elem_restrict->MultLeftInverse(localTest, tempY);
-      y += tempY;
+      local_test = 0.0;
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultPA(elem_restrict_trial ? local_trial : x, local_test);
+      }
+      elem_restrict_test->MultTranspose(local_test, temp_test);
    }
    else
    {
-      mfem_error("In this setting you need a real ElementRestriction!");
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultPA(elem_restrict_trial ? local_trial : x, temp_test);
+      }
    }
+   temp_test *= test_multiplicity;
+   y.Add(c, temp_test);
 }
 
-void PADiscreteLinearOperatorExtension::AddMultTranspose(
-   const Vector &x, Vector &y, const double c) const
+void PADiscreteLinearOperatorExtension::AddMultTranspose(const Vector &x,
+                                                         Vector &y,
+                                                         const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // do a kind of "set" rather than "add" in the below
-   // operation as compared to the BilinearForm case
-   // * G operation (kinda)
-   Vector xscaled(x);
-   MFEM_VERIFY(x.Size() == test_multiplicity.Size(), "Input vector of wrong size");
-   auto xs = xscaled.ReadWrite();
-   auto tm = test_multiplicity.Read();
-   mfem::forall(x.Size(), [=] MFEM_HOST_DEVICE (int i)
-   {
-      xs[i] *= tm[i];
-   });
-   SetupMultInputs(elem_restrict_test, xscaled, localTest,
-                   elem_restrict_trial, y, localTrial, c);
-
-   // * B^TD^TB operation
-   for (int i = 0; i < iSz; ++i)
+   Array<BilinearFormIntegrator *> &interpolators = *a->GetDBFI();
+   temp_test.SetSize(y.Size());
+   temp_test.UseDevice(true);
+   temp_test = x;
+   temp_test *= test_multiplicity;
+   if (elem_restrict_test)
    {
-      integrators[i]->AddMultTransposePA(localTest, localTrial);
+      elem_restrict_test->Mult(temp_test, local_test);
    }
-
-   // * G^T operation
    if (elem_restrict_trial)
    {
-      tempY.SetSize(y.Size());
-      elem_restrict_trial->MultTranspose(localTrial, tempY);
-      y += tempY;
+      local_trial = 0.0;
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test,
+                                    local_trial);
+      }
+      if (c != 1.0)
+      {
+         local_trial *= c;
+      }
+      elem_restrict_trial->AddMultTranspose(local_trial, y);
    }
    else
    {
-      mfem_error("Trial ElementRestriction not defined");
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      if (c != 1.0)
+      {
+         MFEM_ABORT("General coefficient case for PADiscreteLinearOperatorExtension::"
+                    "AddMultTranspose is not yet supported!");
+      }
+      else
+      {
+         for (BilinearFormIntegrator *interp : interpolators)
+         {
+            interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test, y);
+         }
+      }
    }
 }
 
-void PADiscreteLinearOperatorExtension::FormRectangularSystemOperator(
-   const Array<int>& ess1, const Array<int>& ess2, OperatorHandle &A)
-{
-   const Operator *Pi = this->GetProlongation();
-   const Operator *RoT = this->GetOutputRestrictionTranspose();
-   Operator *rap = SetupRAP(Pi, RoT);
-
-   RectangularConstrainedOperator *Arco
-      = new RectangularConstrainedOperator(rap, ess1, ess2, rap != this);
-
-   A.Reset(Arco);
-}
-
 } // namespace mfem
diff --git a/fem/bilinearform_ext.hpp b/fem/bilinearform_ext.hpp
index ef54dc71c..db26eb801 100644
--- a/fem/bilinearform_ext.hpp
+++ b/fem/bilinearform_ext.hpp
@@ -25,8 +25,8 @@ class DiscreteLinearOperator;
 
 /// Class extending the BilinearForm class to support different AssemblyLevels.
 /**  FA - Full Assembly
-     PA - Partial Assembly
      EA - Element Assembly
+     PA - Partial Assembly
      MF - Matrix Free
 */
 class BilinearFormExtension : public Operator
@@ -54,57 +54,59 @@ public:
       MFEM_ABORT("AssembleDiagonal not implemented for this assembly level!");
    }
 
-   virtual void FormSystemMatrix(const Array<int> &ess_tdof_list,
-                                 OperatorHandle &A) = 0;
-   virtual void FormLinearSystem(const Array<int> &ess_tdof_list,
-                                 Vector &x, Vector &b,
-                                 OperatorHandle &A, Vector &X, Vector &B,
-                                 int copy_interior = 0) = 0;
    virtual void Update() = 0;
 };
 
-/// Data and methods for partially-assembled bilinear forms
-class PABilinearFormExtension : public BilinearFormExtension
+/// Data and methods for matrix-free bilinear forms
+class MFBilinearFormExtension : public BilinearFormExtension
 {
 protected:
-   const FiniteElementSpace *trial_fes, *test_fes; // Not owned
-   mutable Vector localX, localY;
-   mutable Vector int_face_X, int_face_Y;
-   mutable Vector bdr_face_X, bdr_face_Y;
-   const Operator *elem_restrict; // Not owned
+   const FiniteElementSpace *fes; // Not owned
+   mutable Vector local_x, local_y, temp_y;
+   mutable Vector int_face_x, int_face_y;
+   mutable Vector bdr_face_x, bdr_face_y;
+   const ElementRestriction *elem_restrict; // Not owned
    const FaceRestriction *int_face_restrict_lex; // Not owned
    const FaceRestriction *bdr_face_restrict_lex; // Not owned
 
 public:
-   PABilinearFormExtension(BilinearForm*);
+   MFBilinearFormExtension(BilinearForm *form);
 
    void Assemble();
    void AssembleDiagonal(Vector &diag) const;
-   void FormSystemMatrix(const Array<int> &ess_tdof_list, OperatorHandle &A);
-   void FormLinearSystem(const Array<int> &ess_tdof_list,
-                         Vector &x, Vector &b,
-                         OperatorHandle &A, Vector &X, Vector &B,
-                         int copy_interior = 0);
    void Mult(const Vector &x, Vector &y) const;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
    void MultTranspose(const Vector &x, Vector &y) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
    void Update();
 
 protected:
    void SetupRestrictionOperators(const L2FaceValues m);
 };
 
+/// Data and methods for partially-assembled bilinear forms
+class PABilinearFormExtension : public MFBilinearFormExtension
+{
+public:
+   PABilinearFormExtension(BilinearForm *form);
+
+   void Assemble();
+   void AssembleDiagonal(Vector &diag) const;
+   void Mult(const Vector &x, Vector &y) const;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
+   void MultTranspose(const Vector &x, Vector &y) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
+};
+
 /// Data and methods for element-assembled bilinear forms
 class EABilinearFormExtension : public PABilinearFormExtension
 {
 protected:
-   int ne;
-   int elemDofs;
-   // The element matrices are stored row major
-   Vector ea_data;
-   int nf_int, nf_bdr;
-   int faceDofs;
+   const bool factorize_face_terms;
+   int ne, elem_dofs;
+   Vector ea_data;  // The element matrices are stored row major
+   int nf_int, nf_bdr, face_dofs;
    Vector ea_data_int, ea_data_ext, ea_data_bdr;
-   bool factorize_face_terms;
 
 public:
    EABilinearFormExtension(BilinearForm *form);
@@ -125,15 +127,6 @@ public:
    FABilinearFormExtension(BilinearForm *form);
 
    void Assemble();
-   void RAP(OperatorHandle &A);
-   /** @note Always does `DIAG_ONE` policy to be consistent with
-       `Operator::FormConstrainedSystemOperator`. */
-   void EliminateBC(const Array<int> &ess_dofs, OperatorHandle &A);
-   void FormSystemMatrix(const Array<int> &ess_tdof_list, OperatorHandle &A);
-   void FormLinearSystem(const Array<int> &ess_tdof_list,
-                         Vector &x, Vector &b,
-                         OperatorHandle &A, Vector &X, Vector &B,
-                         int copy_interior = 0);
    void Mult(const Vector &x, Vector &y) const;
    void MultTranspose(const Vector &x, Vector &y) const;
 
@@ -143,37 +136,10 @@ public:
    void DGMultTranspose(const Vector &x, Vector &y) const;
 };
 
-/// Data and methods for matrix-free bilinear forms
-class MFBilinearFormExtension : public BilinearFormExtension
-{
-protected:
-   const FiniteElementSpace *trial_fes, *test_fes; // Not owned
-   mutable Vector localX, localY;
-   mutable Vector int_face_X, int_face_Y;
-   mutable Vector bdr_face_X, bdr_face_Y;
-   const Operator *elem_restrict; // Not owned
-   const FaceRestriction *int_face_restrict_lex; // Not owned
-   const FaceRestriction *bdr_face_restrict_lex; // Not owned
-
-public:
-   MFBilinearFormExtension(BilinearForm *form);
-
-   void Assemble();
-   void AssembleDiagonal(Vector &diag) const;
-   void FormSystemMatrix(const Array<int> &ess_tdof_list, OperatorHandle &A);
-   void FormLinearSystem(const Array<int> &ess_tdof_list,
-                         Vector &x, Vector &b,
-                         OperatorHandle &A, Vector &X, Vector &B,
-                         int copy_interior = 0);
-   void Mult(const Vector &x, Vector &y) const;
-   void MultTranspose(const Vector &x, Vector &y) const;
-   void Update();
-};
-
 /// Class extending the MixedBilinearForm class to support different AssemblyLevels.
 /**  FA - Full Assembly
-     PA - Partial Assembly
      EA - Element Assembly
+     PA - Partial Assembly
      MF - Matrix Free
 */
 class MixedBilinearFormExtension : public Operator
@@ -185,7 +151,7 @@ public:
    MixedBilinearFormExtension(MixedBilinearForm *form);
 
    virtual MemoryClass GetMemoryClass() const
-   { return Device::GetMemoryClass(); }
+   { return Device::GetDeviceMemoryClass(); }
 
    /// Get the finite element space prolongation matrix
    virtual const Operator *GetProlongation() const;
@@ -199,101 +165,70 @@ public:
    /// Get the output finite element space restriction matrix
    virtual const Operator *GetOutputRestriction() const;
 
+   /// Assemble at the level given for the BilinearFormExtension subclass
    virtual void Assemble() = 0;
-   virtual void FormRectangularSystemOperator(const Array<int> &trial_tdof_list,
-                                              const Array<int> &test_tdof_list,
-                                              OperatorHandle &A) = 0;
-   virtual void FormRectangularLinearSystem(const Array<int> &trial_tdof_list,
-                                            const Array<int> &test_tdof_list,
-                                            Vector &x, Vector &b,
-                                            OperatorHandle &A, Vector &X, Vector &B) = 0;
 
-   virtual void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const = 0;
+   virtual void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const
+   {
+      MFEM_ABORT("AssembleDiagonal_ADAt not implemented for this assembly level!");
+   }
 
    virtual void Update() = 0;
 };
 
-/// Data and methods for partially-assembled mixed bilinear forms
-class PAMixedBilinearFormExtension : public MixedBilinearFormExtension
+/// Data and methods for matrix-free mixed bilinear forms
+class MFMixedBilinearFormExtension : public MixedBilinearFormExtension
 {
 protected:
    const FiniteElementSpace *trial_fes, *test_fes; // Not owned
-   mutable Vector localTrial, localTest, tempY;
-   const Operator *elem_restrict_trial; // Not owned
-   const Operator *elem_restrict_test;  // Not owned
-
-   /// Helper function to set up inputs/outputs for Mult or MultTranspose
-   void SetupMultInputs(const Operator *elem_restrict_x,
-                        const Vector &x, Vector &localX,
-                        const Operator *elem_restrict_y,
-                        Vector &y, Vector &localY, const double c) const;
+   mutable Vector local_trial, local_test, temp_trial, temp_test;
+   mutable Vector int_face_trial, int_face_test, int_face_y;
+   mutable Vector bdr_face_trial, bdr_face_test, bdr_face_y;
+   const ElementRestriction *elem_restrict_trial; // Not owned
+   const ElementRestriction *elem_restrict_test;  // Not owned
+   const FaceRestriction *int_face_restrict_lex_trial; // Not owned
+   const FaceRestriction *int_face_restrict_lex_test;  // Not owned
+   const FaceRestriction *bdr_face_restrict_lex_trial; // Not owned
+   const FaceRestriction *bdr_face_restrict_lex_test;  // Not owned
 
 public:
-   PAMixedBilinearFormExtension(MixedBilinearForm *form);
+   MFMixedBilinearFormExtension(MixedBilinearForm *form);
 
-   /// Partial assembly of all internal integrators
    void Assemble();
-   /**
-      @brief Setup OperatorHandle A to contain constrained linear operator
-
-      OperatorHandle A contains matrix-free constrained operator formed for RAP
-      system where ess_tdof_list are in trial space and eliminated from
-      "columns" of A.
-   */
-   void FormRectangularSystemOperator(const Array<int> &trial_tdof_list,
-                                      const Array<int> &test_tdof_list,
-                                      OperatorHandle &A);
-   /**
-      Setup OperatorHandle A to contain constrained linear operator and
-      eliminate columns corresponding to essential dofs from system,
-      updating RHS B vector with the results.
-   */
-   void FormRectangularLinearSystem(const Array<int> &trial_tdof_list,
-                                    const Array<int> &test_tdof_list,
-                                    Vector &x, Vector &b,
-                                    OperatorHandle &A, Vector &X, Vector &B);
-   /// y = A*x
    void Mult(const Vector &x, Vector &y) const;
-   /// y += c*A*x
-   void AddMult(const Vector &x, Vector &y, const double c=1.0) const;
-   /// y = A^T*x
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
    void MultTranspose(const Vector &x, Vector &y) const;
-   /// y += c*A^T*x
-   void AddMultTranspose(const Vector &x, Vector &y, const double c=1.0) const;
-   /// Assemble the diagonal of ADA^T for a diagonal vector D.
-   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
-
-   /// Update internals for when a new MixedBilinearForm is given to this class
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
    void Update();
+
+protected:
+   void SetupRestrictionOperators(const L2FaceValues m);
 };
 
+/// Data and methods for partially-assembled mixed bilinear forms
+class PAMixedBilinearFormExtension : public MFMixedBilinearFormExtension
+{
+public:
+   PAMixedBilinearFormExtension(MixedBilinearForm *form);
 
-/**
-   @brief Partial assembly extension for DiscreteLinearOperator
+   void Assemble();
+   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
+};
 
-   This acts very much like PAMixedBilinearFormExtension, but its
-   FormRectangularSystemOperator implementation emulates 'Set' rather than
-   'Add' in the assembly case.
-*/
+/// Data and methods for partially-assembled discrete linear operators
 class PADiscreteLinearOperatorExtension : public PAMixedBilinearFormExtension
 {
+private:
+   Vector test_multiplicity;
+
 public:
    PADiscreteLinearOperatorExtension(DiscreteLinearOperator *linop);
 
-   /// Partial assembly of all internal integrators
    void Assemble();
-
-   void AddMult(const Vector &x, Vector &y, const double c=1.0) const;
-
-   void AddMultTranspose(const Vector &x, Vector &y, const double c=1.0) const;
-
-   void FormRectangularSystemOperator(const Array<int>&, const Array<int>&,
-                                      OperatorHandle& A);
-
-   const Operator * GetOutputRestrictionTranspose() const;
-
-private:
-   Vector test_multiplicity;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
 };
 
 }
diff --git a/fem/bilininteg.cpp b/fem/bilininteg.cpp
index c552e9510..e6fc2a6ee 100644
--- a/fem/bilininteg.cpp
+++ b/fem/bilininteg.cpp
@@ -22,126 +22,162 @@ namespace mfem
 
 void BilinearFormIntegrator::AssemblePA(const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AssemblePA(fes)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePA(fes)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssemblePA(const FiniteElementSpace&,
                                         const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AssemblePA(fes, fes)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePA(fes, fes)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssemblePABoundary(const FiniteElementSpace&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePABoundary(fes)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssemblePABoundary(const FiniteElementSpace&,
+                                                const FiniteElementSpace&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePABoundary(fes, fes)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssemblePAInteriorFaces(const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AssemblePAInteriorFaces(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePAInteriorFaces(fes)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssemblePABoundaryFaces(const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AssemblePABoundaryFaces(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePABoundaryFaces(fes)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleDiagonalPA(Vector &)
+void BilinearFormIntegrator::AssembleDiagonalPA(Vector&)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleDiagonalPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalPA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                        Vector &emat,
-                                        const bool add)
+void BilinearFormIntegrator::AssembleDiagonalPA_ADAt(const Vector&, Vector&)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleEA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalPA_ADAt(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace
-                                                     &fes,
-                                                     Vector &ea_data_int,
-                                                     Vector &ea_data_ext,
-                                                     const bool add)
+void BilinearFormIntegrator::AddMultPA(const Vector&, Vector&) const
 {
-   mfem_error ("BilinearFormIntegrator::AssembleEAInteriorFaces(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::MultAssembled(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace
-                                                     &fes,
-                                                     Vector &ea_data_bdr,
-                                                     const bool add)
+void BilinearFormIntegrator::AddMultTransposePA(const Vector&, Vector&) const
 {
-   mfem_error ("BilinearFormIntegrator::AssembleEABoundaryFaces(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AddMultTransposePA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleDiagonalPA_ADAt(const Vector &, Vector &)
+void BilinearFormIntegrator::AssembleMF(const FiniteElementSpace&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalPA_ADAt(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMF(fes)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultPA(const Vector &, Vector &) const
+void BilinearFormIntegrator::AssembleMF(const FiniteElementSpace&,
+                                        const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::MultAssembled(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMF(fes, fes)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultTransposePA(const Vector &, Vector &) const
+void BilinearFormIntegrator::AssembleMFBoundary(const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AddMultTransposePA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMFBoundary(fes)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleMF(const FiniteElementSpace &fes)
+void BilinearFormIntegrator::AssembleMFBoundary(const FiniteElementSpace&,
+                                                const FiniteElementSpace&)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMFBoundary(fes, fes)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultMF(const Vector &, Vector &) const
+void BilinearFormIntegrator::AssembleDiagonalMF(Vector&)
 {
-   mfem_error ("BilinearFormIntegrator::AddMultMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalMF(...)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AddMultMF(const Vector&, Vector&) const
+{
+   MFEM_ABORT("BilinearFormIntegrator::AddMultMF(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultTransposeMF(const Vector &, Vector &) const
+void BilinearFormIntegrator::AddMultTransposeMF(const Vector&, Vector&) const
 {
-   mfem_error ("BilinearFormIntegrator::AddMultTransposeMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AddMultTransposeMF(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleDiagonalMF(Vector &)
+void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace&,
+                                        Vector&)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleDiagonalMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEA(...)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace&,
+                                        const FiniteElementSpace&,
+                                        Vector&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleElementMatrix (
+void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &,
+                                                     Vector&,
+                                                     Vector&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEAInteriorFaces(...)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace&,
+                                                     Vector&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEABoundaryFaces(...)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans,
-   DenseMatrix &elmat )
+   DenseMatrix &elmat)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleElementMatrix(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleElementMatrix(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleElementMatrix2 (
+void BilinearFormIntegrator::AssembleElementMatrix2(
    const FiniteElement &el1, const FiniteElement &el2,
-   ElementTransformation &Trans, DenseMatrix &elmat )
+   ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleElementMatrix2(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleElementMatrix2(...)\n"
+              "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleFaceMatrix (
+void BilinearFormIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
 {
-   mfem_error ("BilinearFormIntegrator::AssembleFaceMatrix(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("BilinearFormIntegrator::AssembleFaceMatrix(...)\n"
+              "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssembleFaceMatrix(
@@ -191,30 +227,30 @@ void TransposeIntegrator::SetIntRule(const IntegrationRule *ir)
    bfi->SetIntRule(ir);
 }
 
-void TransposeIntegrator::AssembleElementMatrix (
+void TransposeIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleElementMatrix (el, Trans, bfi_elmat);
+   bfi->AssembleElementMatrix(el, Trans, bfi_elmat);
    // elmat = bfi_elmat^t
-   elmat.Transpose (bfi_elmat);
+   elmat.Transpose(bfi_elmat);
 }
 
-void TransposeIntegrator::AssembleElementMatrix2 (
+void TransposeIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleElementMatrix2 (test_fe, trial_fe, Trans, bfi_elmat);
+   bfi->AssembleElementMatrix2(test_fe, trial_fe, Trans, bfi_elmat);
    // elmat = bfi_elmat^t
-   elmat.Transpose (bfi_elmat);
+   elmat.Transpose(bfi_elmat);
 }
 
-void TransposeIntegrator::AssembleFaceMatrix (
+void TransposeIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleFaceMatrix (el1, el2, Trans, bfi_elmat);
+   bfi->AssembleFaceMatrix(el1, el2, Trans, bfi_elmat);
    // elmat = bfi_elmat^t
-   elmat.Transpose (bfi_elmat);
+   elmat.Transpose(bfi_elmat);
 }
 
 void LumpedIntegrator::SetIntRule(const IntegrationRule *ir)
@@ -223,10 +259,10 @@ void LumpedIntegrator::SetIntRule(const IntegrationRule *ir)
    bfi->SetIntRule(ir);
 }
 
-void LumpedIntegrator::AssembleElementMatrix (
+void LumpedIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleElementMatrix (el, Trans, elmat);
+   bfi->AssembleElementMatrix(el, Trans, elmat);
    elmat.Lump();
 }
 
@@ -316,6 +352,15 @@ void SumIntegrator::AssemblePA(const FiniteElementSpace& fes)
    }
 }
 
+void SumIntegrator::AssemblePA(const FiniteElementSpace& trial_fes,
+                               const FiniteElementSpace& test_fes)
+{
+   for (int i = 0; i < integrators.Size(); i++)
+   {
+      integrators[i]->AssemblePA(trial_fes, test_fes);
+   }
+}
+
 void SumIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    for (int i = 0; i < integrators.Size(); i++)
@@ -364,57 +409,63 @@ void SumIntegrator::AssembleMF(const FiniteElementSpace &fes)
    }
 }
 
-void SumIntegrator::AddMultMF(const Vector& x, Vector& y) const
+void SumIntegrator::AssembleMF(const FiniteElementSpace& trial_fes,
+                               const FiniteElementSpace& test_fes)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AddMultTransposeMF(x, y);
+      integrators[i]->AssembleMF(trial_fes, test_fes);
    }
 }
 
-void SumIntegrator::AddMultTransposeMF(const Vector &x, Vector &y) const
+void SumIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AddMultMF(x, y);
+      integrators[i]->AssembleDiagonalMF(diag);
    }
 }
 
-void SumIntegrator::AssembleDiagonalMF(Vector &diag)
+void SumIntegrator::AddMultMF(const Vector& x, Vector& y) const
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleDiagonalMF(diag);
+      integrators[i]->AddMultTransposeMF(x, y);
+   }
+}
+
+void SumIntegrator::AddMultTransposeMF(const Vector &x, Vector &y) const
+{
+   for (int i = 0; i < integrators.Size(); i++)
+   {
+      integrators[i]->AddMultMF(x, y);
    }
 }
 
-void SumIntegrator::AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                               const bool add)
+void SumIntegrator::AssembleEA(const FiniteElementSpace &fes, Vector &emat)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleEA(fes, emat, add);
+      integrators[i]->AssembleEA(fes, emat);
    }
 }
 
 void SumIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                             Vector &ea_data_int,
-                                            Vector &ea_data_ext,
-                                            const bool add)
+                                            Vector &ea_data_ext)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleEAInteriorFaces(fes,ea_data_int,ea_data_ext,add);
+      integrators[i]->AssembleEAInteriorFaces(fes, ea_data_int, ea_data_ext);
    }
 }
 
 void SumIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                            Vector &ea_data_bdr,
-                                            const bool add)
+                                            Vector &ea_data_bdr)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleEABoundaryFaces(fes, ea_data_bdr, add);
+      integrators[i]->AssembleEABoundaryFaces(fes, ea_data_bdr);
    }
 }
 
@@ -642,15 +693,15 @@ void MixedVectorIntegrator::AssembleElementMatrix2(
       {
          if (Q)
          {
-            w *= Q -> Eval (Trans, ip);
+            w *= Q->Eval(Trans, ip);
          }
          if (same_shapes)
          {
-            AddMult_a_AAt (w, test_shape, elmat);
+            AddMult_a_AAt(w, test_shape, elmat);
          }
          else
          {
-            AddMult_a_ABt (w, test_shape, trial_shape, elmat);
+            AddMult_a_ABt(w, test_shape, trial_shape, elmat);
          }
       }
    }
@@ -724,7 +775,7 @@ void MixedScalarVectorIntegrator::AssembleElementMatrix2(
       VQ->Eval(V, Trans, ip);
       V *= w;
 
-      if ( vdim == 2 && cross_2d )
+      if (vdim == 2 && cross_2d)
       {
          vtmp = V[0];
          V[0] = -V[1];
@@ -736,7 +787,6 @@ void MixedScalarVectorIntegrator::AssembleElementMatrix2(
    }
 }
 
-
 void GradientIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans,  DenseMatrix &elmat)
@@ -793,19 +843,18 @@ void GradientIntegrator::AssembleElementMatrix2(
    }
 }
 
-const IntegrationRule &GradientIntegrator::GetRule(const FiniteElement
-                                                   &trial_fe,
-                                                   const FiniteElement &test_fe,
-                                                   ElementTransformation &Trans)
+const IntegrationRule &GradientIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans)
 {
    int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
-void DiffusionIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void DiffusionIntegrator::AssembleElementMatrix(
+   const FiniteElement &el, ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    dim = el.GetDim();
@@ -1044,10 +1093,14 @@ void DiffusionIntegrator::AssembleElementVector(
    }
 }
 
-void DiffusionIntegrator::ComputeElementFlux
-( const FiniteElement &el, ElementTransformation &Trans,
-  Vector &u, const FiniteElement &fluxelem, Vector &flux, bool with_coef,
-  const IntegrationRule *ir)
+void DiffusionIntegrator::ComputeElementFlux(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   Vector &u,
+   const FiniteElement &fluxelem,
+   Vector &flux,
+   bool with_coef,
+   const IntegrationRule *ir)
 {
    int nd, spaceDim, fnd;
 
@@ -1087,7 +1140,7 @@ void DiffusionIntegrator::ComputeElementFlux
       ir = &fluxelem.GetNodes();
    }
    fnd = ir->GetNPoints();
-   flux.SetSize( fnd * spaceDim );
+   flux.SetSize(fnd * spaceDim);
 
    for (int i = 0; i < fnd; i++)
    {
@@ -1095,7 +1148,7 @@ void DiffusionIntegrator::ComputeElementFlux
       el.CalcDShape(ip, dshape);
       dshape.MultTranspose(u, vec);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       CalcInverse(Trans.Jacobian(), invdfdx);
       invdfdx.MultTranspose(vec, vecdxt);
 
@@ -1143,9 +1196,11 @@ void DiffusionIntegrator::ComputeElementFlux
    }
 }
 
-double DiffusionIntegrator::ComputeFluxEnergy
-( const FiniteElement &fluxelem, ElementTransformation &Trans,
-  Vector &flux, Vector* d_energy)
+double DiffusionIntegrator::ComputeFluxEnergy(
+   const FiniteElement &fluxelem,
+   ElementTransformation &Trans,
+   Vector &flux,
+   Vector* d_energy)
 {
    int nd = fluxelem.GetDof();
    dim = fluxelem.GetDim();
@@ -1220,7 +1275,8 @@ double DiffusionIntegrator::ComputeFluxEnergy
 }
 
 const IntegrationRule &DiffusionIntegrator::GetRule(
-   const FiniteElement &trial_fe, const FiniteElement &test_fe)
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe)
 {
    int order;
    if (trial_fe.Space() == FunctionSpace::Pk)
@@ -1232,7 +1288,6 @@ const IntegrationRule &DiffusionIntegrator::GetRule(
       // order = 2*el.GetOrder() - 2;  // <-- this seems to work fine too
       order = trial_fe.GetOrder() + test_fe.GetOrder() + trial_fe.GetDim() - 1;
    }
-
    if (trial_fe.Space() == FunctionSpace::rQk)
    {
       return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
@@ -1240,10 +1295,10 @@ const IntegrationRule &DiffusionIntegrator::GetRule(
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
-void MassIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void MassIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    // int dim = el.GetDim();
@@ -1252,8 +1307,8 @@ void MassIntegrator::AssembleElementMatrix
 #ifdef MFEM_THREAD_SAFE
    Vector shape;
 #endif
-   elmat.SetSize(nd);
    shape.SetSize(nd);
+   elmat.SetSize(nd);
 
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, Trans);
 
@@ -1261,14 +1316,14 @@ void MassIntegrator::AssembleElementMatrix
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
 
       el.CalcPhysShape(Trans, shape);
 
       w = Trans.Weight() * ip.weight;
       if (Q)
       {
-         w *= Q -> Eval(Trans, ip);
+         w *= Q->Eval(Trans, ip);
       }
 
       AddMult_a_VVt(w, shape, elmat);
@@ -1300,11 +1355,11 @@ void MassIntegrator::AssembleElementMatrix2(
       trial_fe.CalcShape(ip, shape);
       test_fe.CalcShape(ip, te_shape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       w = Trans.Weight() * ip.weight;
       if (Q)
       {
-         w *= Q -> Eval(Trans, ip);
+         w *= Q->Eval(Trans, ip);
       }
 
       te_shape *= w;
@@ -1326,7 +1381,6 @@ const IntegrationRule &MassIntegrator::GetRule(const FiniteElement &trial_fe,
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
 void BoundaryMassIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
@@ -1366,7 +1420,7 @@ void BoundaryMassIntegrator::AssembleFaceMatrix(
       w = Trans.Weight() * ip.weight;
       if (Q)
       {
-         w *= Q -> Eval(Trans, ip);
+         w *= Q->Eval(Trans, ip);
       }
 
       AddMult_a_VVt(w, shape, elmat);
@@ -1420,9 +1474,18 @@ void ConvectionIntegrator::AssembleElementMatrix(
    }
 }
 
+const IntegrationRule &ConvectionIntegrator::GetRule(
+   const FiniteElement &fe,
+   ElementTransformation &Trans)
+{
+   int order = Trans.OrderGrad(&fe) + Trans.Order() + fe.GetOrder();
+   return IntRules.Get(fe.GetGeomType(), order);
+}
 
 void GroupConvectionIntegrator::AssembleElementMatrix(
-   const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    int dim = el.GetDim();
@@ -1473,24 +1536,10 @@ void GroupConvectionIntegrator::AssembleElementMatrix(
    }
 }
 
-const IntegrationRule &ConvectionIntegrator::GetRule(
-   const FiniteElement &trial_fe, const FiniteElement &test_fe,
-   ElementTransformation &Trans)
-{
-   int order = Trans.OrderGrad(&trial_fe) + Trans.Order() + test_fe.GetOrder();
-
-   return IntRules.Get(trial_fe.GetGeomType(), order);
-}
-
-const IntegrationRule &ConvectionIntegrator::GetRule(
-   const FiniteElement &el, ElementTransformation &Trans)
-{
-   return GetRule(el,el,Trans);
-}
-
-void VectorMassIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void VectorMassIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    int spaceDim = Trans.GetSpaceDim();
@@ -1533,7 +1582,7 @@ void VectorMassIntegrator::AssembleElementMatrix
       const IntegrationPoint &ip = ir->IntPoint(s);
       el.CalcShape(ip, shape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       norm = ip.weight * Trans.Weight();
 
       MultVVt(shape, partelmat);
@@ -1790,7 +1839,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
                "At least one of the finite elements must be in H(Curl)");
 
    int curl_nd, vec_nd;
-   if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+   if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
    {
       curl_nd = trial_nd;
       vec_nd  = test_nd;
@@ -1829,7 +1878,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
       Trans.SetIntPoint(&ip);
       if (dim == 3)
       {
-         if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+         if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
          {
             trial_fe.CalcCurlShape(ip, curlshapeTrial);
             test_fe.CalcVShape(Trans, vshapeTest);
@@ -1843,7 +1892,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
       }
       else
       {
-         if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+         if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
          {
             trial_fe.CalcCurlShape(ip, curlshapeTrial_dFT);
             test_fe.CalcShape(ip, shapeTest);
@@ -1863,7 +1912,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
       }
       // Note: shapeTest points to the same data as vshapeTest
       vshapeTest *= w;
-      if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+      if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
       {
          AddMultABt(vshapeTest, curlshapeTrial_dFT, elmat);
       }
@@ -1874,7 +1923,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
    }
 }
 
-void DerivativeIntegrator::AssembleElementMatrix2 (
+void DerivativeIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe,
    const FiniteElement &test_fe,
    ElementTransformation &Trans,
@@ -1888,12 +1937,12 @@ void DerivativeIntegrator::AssembleElementMatrix2 (
    int i, l;
    double det;
 
-   elmat.SetSize (test_nd,trial_nd);
-   dshape.SetSize (trial_nd,dim);
+   elmat.SetSize(test_nd,trial_nd);
+   dshape.SetSize(trial_nd,dim);
    dshapedxt.SetSize(trial_nd, spaceDim);
    dshapedxi.SetSize(trial_nd);
    invdfdx.SetSize(dim, spaceDim);
-   shape.SetSize (test_nd);
+   shape.SetSize(test_nd);
 
    const IntegrationRule *ir = IntRule;
    if (ir == NULL)
@@ -1925,10 +1974,10 @@ void DerivativeIntegrator::AssembleElementMatrix2 (
 
       trial_fe.CalcDShape(ip, dshape);
 
-      Trans.SetIntPoint (&ip);
-      CalcInverse (Trans.Jacobian(), invdfdx);
+      Trans.SetIntPoint(&ip);
+      CalcInverse(Trans.Jacobian(), invdfdx);
       det = Trans.Weight();
-      Mult (dshape, invdfdx, dshapedxt);
+      Mult(dshape, invdfdx, dshapedxt);
 
       test_fe.CalcShape(ip, shape);
 
@@ -1938,13 +1987,14 @@ void DerivativeIntegrator::AssembleElementMatrix2 (
       }
 
       shape *= Q->Eval(Trans,ip) * det * ip.weight;
-      AddMultVWt (shape, dshapedxi, elmat);
+      AddMultVWt(shape, dshapedxi, elmat);
    }
 }
 
-void CurlCurlIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void CurlCurlIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    dim = el.GetDim();
@@ -1959,6 +2009,7 @@ void CurlCurlIntegrator::AssembleElementMatrix
    curlshape_dFt.SetSize(nd,dimc);
 #endif
    elmat.SetSize(nd);
+
    if (MQ) { M.SetSize(dimc); }
    if (DQ) { D.SetSize(dimc); }
 
@@ -1983,7 +2034,7 @@ void CurlCurlIntegrator::AssembleElementMatrix
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
 
       w = ip.weight * Trans.Weight();
       el.CalcPhysCurlShape(Trans, curlshape_dFt);
@@ -2090,10 +2141,10 @@ void CurlCurlIntegrator::AssembleElementMatrix2(const FiniteElement &trial_fe,
    }
 }
 
-void CurlCurlIntegrator
-::ComputeElementFlux(const FiniteElement &el, ElementTransformation &Trans,
-                     Vector &u, const FiniteElement &fluxelem, Vector &flux,
-                     bool with_coef, const IntegrationRule *ir)
+void CurlCurlIntegrator::ComputeElementFlux(
+   const FiniteElement &el, ElementTransformation &Trans,
+   Vector &u, const FiniteElement &fluxelem, Vector &flux,
+   bool with_coef, const IntegrationRule *ir)
 {
 #ifdef MFEM_THREAD_SAFE
    DenseMatrix projcurl;
@@ -2215,7 +2266,9 @@ double CurlCurlIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
 }
 
 void VectorCurlCurlIntegrator::AssembleElementMatrix(
-   const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int dim = el.GetDim();
    int dof = el.GetDof();
@@ -2405,7 +2458,6 @@ void MixedCurlIntegrator::AssembleElementMatrix2(
    }
 }
 
-
 void VectorFEMassIntegrator::AssembleElementMatrix(
    const FiniteElement &el,
    ElementTransformation &Trans,
@@ -2443,7 +2495,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix(
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
 
       el.CalcVShape(Trans, trial_vshape);
 
@@ -2465,9 +2517,9 @@ void VectorFEMassIntegrator::AssembleElementMatrix(
       {
          if (Q)
          {
-            w *= Q -> Eval (Trans, ip);
+            w *= Q->Eval (Trans, ip);
          }
-         AddMult_a_AAt (w, trial_vshape, elmat);
+         AddMult_a_AAt(w, trial_vshape, elmat);
       }
    }
 }
@@ -2512,7 +2564,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
       {
          const IntegrationPoint &ip = ir->IntPoint(i);
 
-         Trans.SetIntPoint (&ip);
+         Trans.SetIntPoint(&ip);
 
          trial_fe.CalcVShape(Trans, trial_vshape);
          test_fe.CalcShape(ip, shape);
@@ -2598,7 +2650,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
 #endif
       DenseMatrix tmp(test_vshape.Height(), K.Width());
 
-      elmat.SetSize (test_dof, trial_dof);
+      elmat.SetSize(test_dof, trial_dof);
 
       const IntegrationRule *ir = IntRule;
       if (ir == NULL)
@@ -2612,7 +2664,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
       {
          const IntegrationPoint &ip = ir->IntPoint(i);
 
-         Trans.SetIntPoint (&ip);
+         Trans.SetIntPoint(&ip);
 
          trial_fe.CalcVShape(Trans, trial_vshape);
          test_fe.CalcVShape(Trans, test_vshape);
@@ -2635,7 +2687,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
          {
             if (Q)
             {
-               w *= Q -> Eval (Trans, ip);
+               w *= Q->Eval (Trans, ip);
             }
             AddMult_a_ABt(w,test_vshape,trial_vshape,elmat);
          }
@@ -2643,7 +2695,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
    }
    else
    {
-      mfem_error("VectorFEMassIntegrator::AssembleElementMatrix2(...)\n"
+      MFEM_ABORT("VectorFEMassIntegrator::AssembleElementMatrix2(...)\n"
                  "   is not implemented for given trial and test bases.");
    }
 }
@@ -2659,42 +2711,42 @@ void VectorDivergenceIntegrator::AssembleElementMatrix2(
    int test_dof = test_fe.GetDof();
    double c;
 
-   dshape.SetSize (trial_dof, dim);
-   gshape.SetSize (trial_dof, dim);
-   Jadj.SetSize (dim);
-   divshape.SetSize (dim*trial_dof);
-   shape.SetSize (test_dof);
+   dshape.SetSize(trial_dof, dim);
+   gshape.SetSize(trial_dof, dim);
+   Jadj.SetSize(dim);
+   divshape.SetSize(dim*trial_dof);
+   shape.SetSize(test_dof);
 
-   elmat.SetSize (test_dof, dim*trial_dof);
+   elmat.SetSize(test_dof, dim*trial_dof);
 
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
                                                             Trans);
 
    elmat = 0.0;
 
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      trial_fe.CalcDShape (ip, dshape);
-      test_fe.CalcShape (ip, shape);
+      trial_fe.CalcDShape(ip, dshape);
+      test_fe.CalcShape(ip, shape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       CalcAdjugate(Trans.Jacobian(), Jadj);
 
-      Mult (dshape, Jadj, gshape);
+      Mult(dshape, Jadj, gshape);
 
       gshape.GradToDiv (divshape);
 
       c = ip.weight;
       if (Q)
       {
-         c *= Q -> Eval (Trans, ip);
+         c *= Q->Eval (Trans, ip);
       }
 
       // elmat += c * shape * divshape ^ t
       shape *= c;
-      AddMultVWt (shape, divshape, elmat);
+      AddMultVWt(shape, divshape, elmat);
    }
 }
 
@@ -2707,7 +2759,6 @@ const IntegrationRule &VectorDivergenceIntegrator::GetRule(
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
 void DivDivIntegrator::AssembleElementMatrix(
    const FiniteElement &el,
    ElementTransformation &Trans,
@@ -2731,23 +2782,22 @@ void DivDivIntegrator::AssembleElementMatrix(
    }
 
    elmat = 0.0;
-
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      el.CalcDivShape (ip, divshape);
+      el.CalcDivShape(ip, divshape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       c = ip.weight / Trans.Weight();
 
       if (Q)
       {
-         c *= Q -> Eval (Trans, ip);
+         c *= Q->Eval (Trans, ip);
       }
 
       // elmat += c * divshape * divshape ^ t
-      AddMult_a_VVt (c, divshape, elmat);
+      AddMult_a_VVt(c, divshape, elmat);
    }
 }
 
@@ -2779,20 +2829,19 @@ void DivDivIntegrator::AssembleElementMatrix2(
    }
 
    elmat = 0.0;
-
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
       trial_fe.CalcDivShape(ip,divshape);
       test_fe.CalcDivShape(ip,te_divshape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       c = ip.weight / Trans.Weight();
 
       if (Q)
       {
-         c *= Q -> Eval (Trans, ip);
+         c *= Q->Eval (Trans, ip);
       }
 
       te_divshape *= c;
@@ -2836,7 +2885,7 @@ void VectorDiffusionIntegrator::AssembleElementMatrix(
 
    elmat = 0.0;
 
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
 
       const IntegrationPoint &ip = ir->IntPoint(i);
@@ -2972,7 +3021,6 @@ void VectorDiffusionIntegrator::AssembleElementVector(
    }
 }
 
-
 void ElasticityIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
@@ -3003,7 +3051,7 @@ void ElasticityIntegrator::AssembleElementMatrix(
 
    elmat = 0.0;
 
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
@@ -3038,7 +3086,7 @@ void ElasticityIntegrator::AssembleElementMatrix(
             for (int k = 0; k < dof; k++)
                for (int l = 0; l < dof; l++)
                {
-                  elmat (dof*d+k, dof*d+l) += (M * w) * pelmat(k, l);
+                  elmat(dof*d+k, dof*d+l) += (M * w) * pelmat(k, l);
                }
          }
          for (int ii = 0; ii < dim; ii++)
@@ -3360,7 +3408,6 @@ void DGTraceIntegrator::AssembleFaceMatrix(const FiniteElement &el1,
    }
 }
 
-
 const IntegrationRule &DGTraceIntegrator::GetRule(
    Geometry::Type geom, int order, FaceElementTransformations &T)
 {
@@ -3603,8 +3650,6 @@ void DGDiffusionIntegrator::AssembleFaceMatrix(
    }
 }
 
-
-// static method
 void DGElasticityIntegrator::AssembleBlock(
    const int dim, const int row_ndofs, const int col_ndofs,
    const int row_offset, const int col_offset,
@@ -3827,7 +3872,6 @@ void DGElasticityIntegrator::AssembleFaceMatrix(
    }
 }
 
-
 void TraceJumpIntegrator::AssembleFaceMatrix(
    const FiniteElement &trial_face_fe, const FiniteElement &test_fe1,
    const FiniteElement &test_fe2, FaceElementTransformations &Trans,
@@ -4243,7 +4287,6 @@ void NormalInterpolator::AssembleElementMatrix2(
    }
 }
 
-
 namespace internal
 {
 
@@ -4284,7 +4327,6 @@ ScalarProductInterpolator::AssembleElementMatrix2(const FiniteElement &dom_fe,
    ran_fe.Project(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 void
 ScalarVectorProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
@@ -4319,7 +4361,6 @@ ScalarVectorProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 void
 VectorScalarProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
@@ -4357,7 +4398,6 @@ VectorScalarProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 void
 ScalarCrossProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
@@ -4453,7 +4493,6 @@ VectorCrossProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 namespace internal
 {
 
@@ -4483,8 +4522,7 @@ struct VDotVShapeCoefficient : public VectorCoefficient
 
 }
 
-void
-VectorInnerProductInterpolator::AssembleElementMatrix2(
+void VectorInnerProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
diff --git a/fem/bilininteg.hpp b/fem/bilininteg.hpp
index 9858e984b..209898714 100644
--- a/fem/bilininteg.hpp
+++ b/fem/bilininteg.hpp
@@ -27,7 +27,6 @@ constexpr int HCURL_MAX_Q1D = 5;
 #else
 constexpr int HCURL_MAX_Q1D = 6;
 #endif
-
 constexpr int HDIV_MAX_D1D = 5;
 constexpr int HDIV_MAX_Q1D = 6;
 
@@ -36,7 +35,7 @@ class BilinearFormIntegrator : public NonlinearFormIntegrator
 {
 protected:
    BilinearFormIntegrator(const IntegrationRule *ir = NULL)
-      : NonlinearFormIntegrator(ir) { }
+      : NonlinearFormIntegrator(ir) {}
 
 public:
    // TODO: add support for other assembly levels (in addition to PA) and their
@@ -51,8 +50,6 @@ public:
    // make sense for the action of the nonlinear operator (but they all make
    // sense for its Jacobian).
 
-   using NonlinearFormIntegrator::AssemblePA;
-
    /// Method defining partial assembly.
    /** The result of the partial assembly is stored internally so that it can be
        used later in the methods AddMultPA() and AddMultTransposePA(). */
@@ -61,6 +58,11 @@ public:
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssemblePABoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
    virtual void AssemblePAInteriorFaces(const FiniteElementSpace &fes);
 
    virtual void AssemblePABoundaryFaces(const FiniteElementSpace &fes);
@@ -89,20 +91,21 @@ public:
        called. */
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   /// Method defining element assembly.
-   /** The result of the element assembly is added to the @a emat Vector if
-       @a add is true. Otherwise, if @a add is false, we set @a emat. */
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add = true);
-   /** Used with BilinearFormIntegrators that have different spaces. */
-   // virtual void AssembleEA(const FiniteElementSpace &trial_fes,
-   //                         const FiniteElementSpace &test_fes,
-   //                         Vector &emat);
-
    /// Method defining matrix-free assembly.
    /** The result of fully matrix-free assembly is stored internally so that it
        can be used later in the methods AddMultMF() and AddMultTransposeMF(). */
    virtual void AssembleMF(const FiniteElementSpace &fes);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssembleMFBoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
+   /// Assemble diagonal and add it to Vector @a diag.
+   virtual void AssembleDiagonalMF(Vector &diag);
 
    /** Perform the action of integrator on the input @a x and add the result to
        the output @a y. Both @a x and @a y are E-vectors, i.e. they represent
@@ -120,17 +123,20 @@ public:
        called. */
    virtual void AddMultTransposeMF(const Vector &x, Vector &y) const;
 
-   /// Assemble diagonal and add it to Vector @a diag.
-   virtual void AssembleDiagonalMF(Vector &diag);
+   /// Method defining element assembly.
+   /** The result of the element assembly is added to the @a emat Vector. */
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssembleEA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes,
+                           Vector &emat);
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add = true);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add = true);
+                                        Vector &ea_data_bdr);
 
    /// Given a particular Finite Element computes the element matrix elmat.
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -234,7 +240,7 @@ public:
                                    Vector &u,
                                    const FiniteElement &fluxelem,
                                    Vector &flux, bool with_coef = true,
-                                   const IntegrationRule *ir = NULL) { }
+                                   const IntegrationRule *ir = NULL) {}
 
    /** @brief Virtual method required for Zienkiewicz-Zhu type error estimators.
 
@@ -260,7 +266,7 @@ public:
                                     Vector &flux, Vector *d_energy = NULL)
    { return 0.0; }
 
-   virtual ~BilinearFormIntegrator() { }
+   virtual ~BilinearFormIntegrator() {}
 };
 
 /** Wraps a given @a BilinearFormIntegrator and transposes the resulting element
@@ -268,13 +274,12 @@ public:
 class TransposeIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_bfi;
+   bool own_bfi;
    BilinearFormIntegrator *bfi;
-
    DenseMatrix bfi_elmat;
 
 public:
-   TransposeIntegrator (BilinearFormIntegrator *bfi_, int own_bfi_ = 1)
+   TransposeIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
    { bfi = bfi_; own_bfi = own_bfi_; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
@@ -294,17 +299,24 @@ public:
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-
-   virtual void AssemblePA(const FiniteElementSpace& fes)
+   virtual void AssemblePA(const FiniteElementSpace &fes)
    {
       bfi->AssemblePA(fes);
    }
-
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes)
    {
-      bfi->AssemblePA(test_fes, trial_fes); // Reverse test and trial
+      bfi->AssemblePA(trial_fes, test_fes);
+   }
+
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes)
+   {
+      bfi->AssemblePABoundary(fes);
+   }
+   virtual void AssemblePABoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes)
+   {
+      bfi->AssemblePABoundary(trial_fes, test_fes);
    }
 
    virtual void AssemblePAInteriorFaces(const FiniteElementSpace &fes)
@@ -322,22 +334,20 @@ public:
       bfi->AddMultPA(x, y);
    }
 
-   virtual void AddMultPA(const Vector& x, Vector& y) const
+   virtual void AddMultPA(const Vector &x, Vector &y) const
    {
       bfi->AddMultTransposePA(x, y);
    }
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add);
+                                        Vector &ea_data_bdr);
 
    virtual ~TransposeIntegrator() { if (own_bfi) { delete bfi; } }
 };
@@ -345,11 +355,11 @@ public:
 class LumpedIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_bfi;
+   bool own_bfi;
    BilinearFormIntegrator *bfi;
 
 public:
-   LumpedIntegrator (BilinearFormIntegrator *bfi_, int own_bfi_ = 1)
+   LumpedIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
    { bfi = bfi_; own_bfi = own_bfi_; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
@@ -365,11 +375,11 @@ public:
 class InverseIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_integrator;
+   bool own_integrator;
    BilinearFormIntegrator *integrator;
 
 public:
-   InverseIntegrator(BilinearFormIntegrator *integ, int own_integ = 1)
+   InverseIntegrator(BilinearFormIntegrator *integ, bool own_integ = 1)
    { integrator = integ; own_integrator = own_integ; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
@@ -385,12 +395,12 @@ public:
 class SumIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_integrators;
+   bool own_integrators;
    mutable DenseMatrix elem_mat;
    Array<BilinearFormIntegrator*> integrators;
 
 public:
-   SumIntegrator(int own_integs = 1) { own_integrators = own_integs; }
+   SumIntegrator(bool own_integs = true) { own_integrators = own_integs; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
 
@@ -417,8 +427,9 @@ public:
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace& fes);
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
 
    virtual void AssembleDiagonalPA(Vector &diag);
 
@@ -428,27 +439,27 @@ public:
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   virtual void AddMultPA(const Vector& x, Vector& y) const;
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AssembleMF(const FiniteElementSpace &fes);
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposeMF(const Vector &x, Vector &y) const;
 
-   virtual void AssembleDiagonalMF(Vector &diag);
-
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add);
+                                        Vector &ea_data_bdr);
 
    virtual ~SumIntegrator();
 };
@@ -458,7 +469,6 @@ public:
 class MixedScalarIntegrator: public BilinearFormIntegrator
 {
 public:
-
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -480,44 +490,39 @@ protected:
    MixedScalarIntegrator(Coefficient &q) : same_calc_shape(false), Q(&q) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe, const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarIntegrator:  "
              "Trial and test spaces must both be scalar fields.";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     Vector & shape)
+                                     Vector &shape)
    { test_fe.CalcPhysShape(Trans, shape); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    { trial_fe.CalcPhysShape(Trans, shape); }
 
    Coefficient *Q;
 
 private:
-
 #ifndef MFEM_THREAD_SAFE
-   Vector test_shape;
-   Vector trial_shape;
+   Vector test_shape, trial_shape;
 #endif
-
 };
 
 /** An abstract class for integrating the inner product of two vector basis
@@ -525,7 +530,6 @@ private:
 class MixedVectorIntegrator: public BilinearFormIntegrator
 {
 public:
-
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -554,39 +558,38 @@ protected:
       : same_calc_shape(false), Q(NULL), VQ(NULL), DQ(NULL), MQ(&mq) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorIntegrator:  "
              "Trial and test spaces must both be vector fields";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return std::max(space_dim, test_fe.GetVDim()); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcVShape(Trans, shape); }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return std::max(space_dim, trial_fe.GetVDim()); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcVShape(Trans, shape); }
 
    int space_dim;
@@ -596,16 +599,10 @@ protected:
    MatrixCoefficient *MQ;
 
 private:
-
 #ifndef MFEM_THREAD_SAFE
-   Vector V;
-   Vector D;
-   DenseMatrix M;
-   DenseMatrix test_shape;
-   DenseMatrix trial_shape;
-   DenseMatrix shape_tmp;
+   Vector V, D;
+   DenseMatrix M, test_shape, trial_shape, shape_tmp;
 #endif
-
 };
 
 /** An abstract class for integrating the product of a scalar basis function and
@@ -614,7 +611,6 @@ private:
 class MixedScalarVectorIntegrator: public BilinearFormIntegrator
 {
 public:
-
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -631,14 +627,13 @@ public:
    { AssembleElementMatrix2(fe, fe, Trans, elmat); }
 
 protected:
-
    MixedScalarVectorIntegrator(VectorCoefficient &vq, bool transpose_ = false,
                                bool cross_2d_ = false)
       : VQ(&vq), transpose(transpose_), cross_2d(cross_2d_) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return ((transpose &&
                trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -649,9 +644,9 @@ protected:
              );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
-      if ( transpose )
+      if (transpose)
       {
          return "MixedScalarVectorIntegrator:  "
                 "Trial space must be a vector field "
@@ -665,23 +660,22 @@ protected:
       }
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return std::max(space_dim, vector_fe.GetVDim()); }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape_)
+                                  DenseMatrix &shape_)
    { vector_fe.CalcVShape(Trans, shape_); }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape_)
+                                 Vector &shape_)
    { scalar_fe.CalcPhysShape(Trans, shape_); }
 
    VectorCoefficient *VQ;
@@ -690,14 +684,12 @@ protected:
    bool cross_2d;  // In 2D use a cross product rather than a dot product
 
 private:
-
 #ifndef MFEM_THREAD_SAFE
    Vector V;
    DenseMatrix vshape;
    Vector      shape;
    Vector      vshape_tmp;
 #endif
-
 };
 
 /** Class for integrating the bilinear form a(u,v) := (Q u, v) in either 1D, 2D,
@@ -732,24 +724,24 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 1 && test_fe.GetDim() == 1 &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarDerivativeIntegrator:  "
              "Trial and test spaces must both be scalar fields in 1D "
              "and the trial space must implement CalcDShape.";
    }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       trial_fe.CalcPhysDShape(Trans, dshape);
@@ -767,15 +759,15 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 1 && test_fe.GetDim() == 1 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakDerivativeIntegrator:  "
              "Trial and test spaces must both be scalar fields in 1D "
@@ -783,9 +775,9 @@ protected:
              "map type \"VALUE\".";
    }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     Vector & shape)
+                                     Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       test_fe.CalcPhysDShape(Trans, dshape);
@@ -805,28 +797,28 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarDivergenceIntegrator:  "
              "Trial must be H(Div) and the test space must be a "
              "scalar field";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    { trial_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -841,14 +833,14 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorDivergenceIntegrator:  "
              "Trial must be H(Div) and the test space must be a "
@@ -857,14 +849,14 @@ protected:
 
    // Subtract one due to the divergence and add one for the coefficient
    // which is assumed to be at least linear.
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1 + 1; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -880,28 +872,28 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::DIV );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakGradientIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be H(Div)";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   virtual void CalcTestShape(const FiniteElement & test_fe,
+   virtual void CalcTestShape(const FiniteElement &test_fe,
                               ElementTransformation &Trans,
-                              Vector & shape)
+                              Vector &shape)
    {
       test_fe.CalcPhysDivShape(Trans, shape);
       shape *= -1.0;
@@ -920,29 +912,29 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCurlIntegrator:  "
              "Trial must be H(Curl) and the test space must be a "
              "scalar field";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       trial_fe.CalcPhysCurlShape(Trans, dshape);
@@ -952,7 +944,8 @@ protected:
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    // PA extension
@@ -976,24 +969,24 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCurlIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be H(Curl)";
    }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     Vector & shape)
+                                     Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       test_fe.CalcPhysCurlShape(Trans, dshape);
@@ -1034,14 +1027,14 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDotProductIntegrator:  "
              "Trial space must be a vector field "
@@ -1059,15 +1052,15 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::DIV );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakGradDotIntegrator:  "
              "Trial space must be a vector field "
@@ -1076,14 +1069,14 @@ public:
 
    // Subtract one due to the gradient and add one for the coefficient
    // which is assumed to be at least linear.
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1 + 1; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1096,8 +1089,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1105,19 +1098,19 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakDivCrossIntegrator:  "
              "Trial space must be a vector field in 3D "
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1136,8 +1129,8 @@ public:
       : MixedVectorIntegrator(mq) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
@@ -1145,15 +1138,15 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedGradGradIntegrator:  "
              "Trial and test spaces must both be scalar fields "
              "with a gradient operator.";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    {
       // Same as DiffusionIntegrator
@@ -1162,20 +1155,20 @@ public:
              trial_fe.GetOrder() + test_fe.GetOrder() + test_fe.GetDim() - 1;
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1188,8 +1181,8 @@ public:
       : MixedVectorIntegrator(vq, false) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
@@ -1197,27 +1190,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradGradIntegrator:  "
              "Trial and test spaces must both be scalar fields "
              "with a gradient operator.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1236,8 +1229,8 @@ public:
       : MixedVectorIntegrator(mq) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1246,27 +1239,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCurlCurlIntegrator"
              "Trial and test spaces must both be vector fields in 3D "
              "with a curl.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1279,8 +1272,8 @@ public:
       : MixedVectorIntegrator(vq, false) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && trial_fe.GetVDim() == 3 &&
               test_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
@@ -1290,27 +1283,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlCurlIntegrator:  "
              "Trial and test spaces must both be vector fields in 3D "
              "with a curl.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1323,8 +1316,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1333,27 +1326,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlGradIntegrator"
              "Trial space must be a vector field in 3D with a curl"
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1366,8 +1359,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
@@ -1376,27 +1369,27 @@ public:
               test_fe.GetDerivType() == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradCurlIntegrator"
              "Trial space must be a scalar field in 3D with a gradient"
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1410,8 +1403,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1419,19 +1412,19 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakCurlCrossIntegrator:  "
              "Trial space must be a vector field in 3D "
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1445,8 +1438,8 @@ public:
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1454,16 +1447,16 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCurlCrossIntegrator:  "
              "Trial space must be a vector field in 2D "
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       scalar_fe.CalcPhysCurlShape(Trans, dshape);
@@ -1480,8 +1473,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (test_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
@@ -1489,24 +1482,24 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradIntegrator:  "
              "Trial space must be a scalar field with a gradient operator"
              " and the test space must be a vector field both in 3D.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcVShape(Trans, shape); }
 };
 
@@ -1520,8 +1513,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1529,19 +1522,19 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlIntegrator:  "
              "Trial space must be a vector field in 3D with a curl "
              "and the test space must be a vector field";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1555,8 +1548,8 @@ public:
       : MixedScalarVectorIntegrator(vq, false, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1564,16 +1557,16 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlIntegrator:  "
              "Trial space must be a vector field in 2D with a curl "
              "and the test space must be a vector field";
    }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       scalar_fe.CalcPhysCurlShape(Trans, dshape); shape *= -1.0;
@@ -1589,8 +1582,8 @@ public:
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
@@ -1598,19 +1591,19 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCrossGradIntegrator:  "
              "Trial space must be a scalar field in 2D with a gradient "
              "and the test space must be a scalar field";
    }
 
-   inline int GetVDim(const FiniteElement & vector_fe)
+   inline int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1623,15 +1616,15 @@ public:
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCrossProductIntegrator:  "
              "Trial space must be a vector field in 2D "
@@ -1648,24 +1641,24 @@ public:
       : MixedScalarVectorIntegrator(vq, false, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCrossProductIntegrator:  "
              "Trial space must be a scalar field in 2D "
              "and the test space must be a vector field";
    }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1678,27 +1671,27 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDirectionalDerivativeIntegrator:  "
              "Trial space must be a scalar field with a gradient "
              "and the test space must be a scalar field";
    }
 
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1711,8 +1704,8 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
@@ -1720,24 +1713,24 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::DIV   );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedGradDivIntegrator:  "
              "Trial space must be a scalar field with a gradient"
              "and the test space must be a vector field with a divergence";
    }
 
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -1750,8 +1743,8 @@ public:
       : MixedScalarVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::DIV    &&
@@ -1760,24 +1753,24 @@ public:
              );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDivGradIntegrator:  "
              "Trial space must be a vector field with a divergence"
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -1790,27 +1783,27 @@ public:
       : MixedScalarVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD   );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakDivergenceIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline int GetVDim(const FiniteElement & vector_fe)
+   inline int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1831,40 +1824,40 @@ public:
    MixedVectorGradientIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorGradientIntegrator:  "
              "Trial spaces must be H1 and the test space must be a "
              "vector field in 2D or 3D";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    {
       trial_fe.CalcPhysDShape(Trans, shape);
    }
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
-private:
    DenseMatrix Jinv;
 
    // PA extension
@@ -1889,40 +1882,41 @@ public:
    MixedVectorCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorCurlIntegrator:  "
              "Trial space must be H(Curl) and the test space must be a "
              "vector field in 3D";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    {
       trial_fe.CalcPhysCurlShape(Trans, shape);
    }
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
 private:
    // PA extension
    Vector pa_data;
@@ -1948,40 +1942,41 @@ public:
    MixedVectorWeakCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorWeakCurlIntegrator:  "
              "Trial space must be vector field in 3D and the "
              "test space must be H(Curl)";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    {
       test_fe.CalcPhysCurlShape(Trans, shape);
    }
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
 private:
    // PA extension
    Vector pa_data;
@@ -2007,26 +2002,26 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorWeakDivergenceIntegrator:  "
              "Trial space must be vector field and the "
              "test space must be H1";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    {
       test_fe.CalcPhysDShape(Trans, shape);
       shape *= -1.0;
@@ -2049,6 +2044,7 @@ private:
    DenseMatrix gshape;
    DenseMatrix Jadj;
    DenseMatrix elmat_comp;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *trial_maps, *test_maps; ///< Not owned
@@ -2059,13 +2055,13 @@ private:
 public:
    GradientIntegrator() :
       Q{NULL}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
-   { }
+   {}
    GradientIntegrator(Coefficient *q_) :
       Q{q_}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
-   { }
+   {}
    GradientIntegrator(Coefficient &q) :
       Q{&q}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
-   { }
+   {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2077,6 +2073,7 @@ public:
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
@@ -2102,7 +2099,6 @@ private:
 #endif
 
    // PA extension
-   const FiniteElementSpace *fespace;
    const DofToQuad *maps;         ///< Not owned
    const GeometricFactors *geom;  ///< Not owned
    int dim, ne, dofs1D, quad1D;
@@ -2113,30 +2109,31 @@ public:
    /// Construct a diffusion integrator with coefficient Q = 1
    DiffusionIntegrator(const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(NULL), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) { }
+        Q(NULL), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a diffusion integrator with a scalar coefficient q
    DiffusionIntegrator(Coefficient &q, const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(&q), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) { }
+        Q(&q), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a diffusion integrator with a vector coefficient q
    DiffusionIntegrator(VectorCoefficient &q,
                        const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(NULL), VQ(&q), MQ(NULL), maps(NULL), geom(NULL) { }
+        Q(NULL), VQ(&q), MQ(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a diffusion integrator with a matrix coefficient q
    DiffusionIntegrator(MatrixCoefficient &q,
                        const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(NULL), VQ(NULL), MQ(&q), maps(NULL), geom(NULL) { }
+        Q(NULL), VQ(NULL), MQ(&q), maps(NULL), geom(NULL) {}
 
    /** Given a particular Finite Element computes the element stiffness matrix
        elmat. */
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    /** Given a trial and test Finite Element computes the element stiffness
        matrix elmat. */
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
@@ -2160,23 +2157,23 @@ public:
                                     Vector &flux, Vector *d_energy = NULL);
 
    using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+   virtual void AssembleDiagonalPA(Vector &diag);
 
-   virtual void AssemblePA(const FiniteElementSpace &fes);
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   virtual void AssembleDiagonalPA(Vector &diag);
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
 
    virtual void AssembleDiagonalMF(Vector &diag);
 
-   virtual void AddMultMF(const Vector&, Vector&) const;
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
                                          const FiniteElement &test_fe);
@@ -2189,55 +2186,62 @@ public:
 /** Class for local mass matrix assembling a(u,v) := (Q u, v) */
 class MassIntegrator: public BilinearFormIntegrator
 {
+private:
    friend class DGMassInverse;
+
 protected:
 #ifndef MFEM_THREAD_SAFE
    Vector shape, te_shape;
 #endif
    Coefficient *Q;
+
    // PA extension
-   const FiniteElementSpace *fespace;
    Vector pa_data;
-   const DofToQuad *maps;         ///< Not owned
-   const GeometricFactors *geom;  ///< Not owned
+   const DofToQuad *maps;                 ///< Not owned
+   const GeometricFactors *geom;          ///< Not owned
+   const FaceGeometricFactors *face_geom; ///< Not owned
    int dim, ne, nq, dofs1D, quad1D;
 
 public:
    MassIntegrator(const IntegrationRule *ir = NULL)
-      : BilinearFormIntegrator(ir), Q(NULL), maps(NULL), geom(NULL) { }
+      : BilinearFormIntegrator(ir), Q(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a mass integrator with coefficient q
    MassIntegrator(Coefficient &q, const IntegrationRule *ir = NULL)
-      : BilinearFormIntegrator(ir), Q(&q), maps(NULL), geom(NULL) { }
+      : BilinearFormIntegrator(ir), Q(&q), maps(NULL), geom(NULL) {}
 
    /** Given a particular Finite Element computes the element mass matrix
        elmat. */
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
    using BilinearFormIntegrator::AssemblePA;
-
-   virtual void AssembleMF(const FiniteElementSpace &fes);
-
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   using BilinearFormIntegrator::AssemblePABoundary;
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes);
 
    virtual void AssembleDiagonalPA(Vector &diag);
 
-   virtual void AssembleDiagonalMF(Vector &diag);
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
 
-   virtual void AddMultMF(const Vector&, Vector&) const;
+   virtual void AssembleDiagonalMF(Vector &diag);
 
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
                                          const FiniteElement &test_fe,
@@ -2252,7 +2256,7 @@ public:
 class BoundaryMassIntegrator : public MassIntegrator
 {
 public:
-   BoundaryMassIntegrator(Coefficient &q) : MassIntegrator(q) { }
+   BoundaryMassIntegrator(Coefficient &q) : MassIntegrator(q) {}
 
    using BilinearFormIntegrator::AssembleFaceMatrix;
 
@@ -2268,6 +2272,7 @@ class ConvectionIntegrator : public BilinearFormIntegrator
 protected:
    VectorCoefficient *Q;
    double alpha;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;         ///< Not owned
@@ -2284,34 +2289,30 @@ public:
    ConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
       : Q(&q) { alpha = a; }
 
-   virtual void AssembleElementMatrix(const FiniteElement &,
-                                      ElementTransformation &,
-                                      DenseMatrix &);
+   virtual void AssembleElementMatrix(const FiniteElement &fes,
+                                      ElementTransformation &Trans,
+                                      DenseMatrix &elmat);
 
    using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+   virtual void AssembleDiagonalPA(Vector &diag);
 
-   virtual void AssemblePA(const FiniteElementSpace&);
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   virtual void AssembleDiagonalPA(Vector &diag);
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
 
    virtual void AssembleDiagonalMF(Vector &diag);
 
-   virtual void AddMultMF(const Vector&, Vector&) const;
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-
-   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   static const IntegrationRule &GetRule(const FiniteElement &el,
-                                         ElementTransformation &Trans);
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe,
+   static const IntegrationRule &GetRule(const FiniteElement &fe,
                                          ElementTransformation &Trans);
 
    bool SupportsCeed() const { return DeviceCanUseCeed(); }
@@ -2325,7 +2326,7 @@ class ConservativeConvectionIntegrator : public TransposeIntegrator
 {
 public:
    ConservativeConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
-      : TransposeIntegrator(new ConvectionIntegrator(q, -a)) { }
+      : TransposeIntegrator(new ConvectionIntegrator(q, -a)) {}
 };
 
 /// alpha (q . grad u, v) using the "group" FE discretization
@@ -2342,6 +2343,7 @@ private:
 public:
    GroupConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
       : Q(&q) { alpha = a; }
+
    virtual void AssembleElementMatrix(const FiniteElement &,
                                       ElementTransformation &,
                                       DenseMatrix &);
@@ -2363,6 +2365,7 @@ protected:
    Coefficient *Q;
    VectorCoefficient *VQ;
    MatrixCoefficient *MQ;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;         ///< Not owned
@@ -2372,21 +2375,21 @@ protected:
 public:
    /// Construct an integrator with coefficient 1.0
    VectorMassIntegrator()
-      : vdim(-1), Q_order(0), Q(NULL), VQ(NULL), MQ(NULL) { }
+      : vdim(-1), Q_order(0), Q(NULL), VQ(NULL), MQ(NULL) {}
    /** Construct an integrator with scalar coefficient q.  If possible, save
        memory by using a scalar integrator since the resulting matrix is block
        diagonal with the same diagonal block repeated. */
    VectorMassIntegrator(Coefficient &q, int qo = 0)
-      : vdim(-1), Q_order(qo), Q(&q), VQ(NULL), MQ(NULL) { }
+      : vdim(-1), Q_order(qo), Q(&q), VQ(NULL), MQ(NULL) {}
    VectorMassIntegrator(Coefficient &q, const IntegrationRule *ir)
       : BilinearFormIntegrator(ir), vdim(-1), Q_order(0), Q(&q), VQ(NULL),
-        MQ(NULL) { }
+        MQ(NULL) {}
    /// Construct an integrator with diagonal coefficient q
    VectorMassIntegrator(VectorCoefficient &q, int qo = 0)
-      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(&q), MQ(NULL) { }
+      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(&q), MQ(NULL) {}
    /// Construct an integrator with matrix coefficient q
    VectorMassIntegrator(MatrixCoefficient &q, int qo = 0)
-      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(NULL), MQ(&q) { }
+      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(NULL), MQ(&q) {}
 
    int GetVDim() const { return vdim; }
    void SetVDim(int vdim_) { vdim = vdim_; }
@@ -2394,21 +2397,29 @@ public:
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
-   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    bool SupportsCeed() const { return DeviceCanUseCeed(); }
 };
 
-
 /** Class for integrating (div u, p) where u is a vector field given by
     VectorFiniteElement through Piola transformation (for RT elements); p is
     scalar function given by FiniteElement through standard transformation.
@@ -2422,13 +2433,6 @@ class VectorFEDivergenceIntegrator : public BilinearFormIntegrator
 protected:
    Coefficient *Q;
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector divshape, shape;
@@ -2444,17 +2448,26 @@ private:
 public:
    VectorFEDivergenceIntegrator() { Q = NULL; }
    VectorFEDivergenceIntegrator(Coefficient &q) { Q = &q; }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
-                                      DenseMatrix &elmat) { }
+                                      DenseMatrix &elmat) {}
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
    virtual void AssembleDiagonalPA_ADAt(const Vector &D, Vector &diag);
-};
 
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+};
 
 /** Integrator for `(-Q u, grad v)` for Nedelec (`u`) and H1 (`v`) elements.
     This is equivalent to a weak divergence of the Nedelec basis functions. */
@@ -2474,9 +2487,11 @@ private:
 public:
    VectorFEWeakDivergenceIntegrator() { Q = NULL; }
    VectorFEWeakDivergenceIntegrator(Coefficient &q) { Q = &q; }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
-                                      DenseMatrix &elmat) { }
+                                      DenseMatrix &elmat) {}
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2500,9 +2515,11 @@ private:
 public:
    VectorFECurlIntegrator() { Q = NULL; }
    VectorFECurlIntegrator(Coefficient &q) { Q = &q; }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
-                                      DenseMatrix &elmat) { }
+                                      DenseMatrix &elmat) {}
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2521,11 +2538,13 @@ private:
    Vector shape, dshapedxi;
 
 public:
-   DerivativeIntegrator(Coefficient &q, int i) : Q(&q), xi(i) { }
+   DerivativeIntegrator(Coefficient &q, int i) : Q(&q), xi(i) {}
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat)
    { AssembleElementMatrix2(el,el,Trans,elmat); }
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2561,12 +2580,12 @@ public:
    CurlCurlIntegrator() { Q = NULL; DQ = NULL; MQ = NULL; }
    /// Construct a bilinear form integrator for Nedelec elements
    CurlCurlIntegrator(Coefficient &q, const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(&q), DQ(NULL), MQ(NULL) { }
+      BilinearFormIntegrator(ir), Q(&q), DQ(NULL), MQ(NULL) {}
    CurlCurlIntegrator(DiagonalMatrixCoefficient &dq,
                       const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(NULL), DQ(&dq), MQ(NULL) { }
+      BilinearFormIntegrator(ir), Q(NULL), DQ(&dq), MQ(NULL) {}
    CurlCurlIntegrator(MatrixCoefficient &mq, const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(NULL), DQ(NULL), MQ(&mq) { }
+      BilinearFormIntegrator(ir), Q(NULL), DQ(NULL), MQ(&mq) {}
 
    /* Given a particular Finite Element, compute the
       element curl-curl matrix elmat */
@@ -2591,8 +2610,10 @@ public:
 
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
-   virtual void AssembleDiagonalPA(Vector& diag);
 
    const Coefficient *GetCoefficient() const { return Q; }
 };
@@ -2612,7 +2633,7 @@ protected:
 public:
    VectorCurlCurlIntegrator() { Q = NULL; }
 
-   VectorCurlCurlIntegrator(Coefficient &q) : Q(&q) { }
+   VectorCurlCurlIntegrator(Coefficient &q) : Q(&q) {}
 
    /// Assemble an element matrix
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -2643,9 +2664,9 @@ private:
    DenseMatrix curlshape;
    DenseMatrix elmat_comp;
 public:
-   MixedCurlIntegrator() : Q{NULL} { }
-   MixedCurlIntegrator(Coefficient *q_) :  Q{q_} { }
-   MixedCurlIntegrator(Coefficient &q) :  Q{&q} { }
+   MixedCurlIntegrator() : Q{NULL} {}
+   MixedCurlIntegrator(Coefficient *q_) :  Q{q_} {}
+   MixedCurlIntegrator(Coefficient &q) :  Q{&q} {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2699,18 +2720,21 @@ public:
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &fes);
+   virtual void AssemblePA(const FiniteElementSpace &fes) { AssemblePA(fes, fes); }
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
-   virtual void AssembleDiagonalPA(Vector& diag);
 
    const Coefficient *GetCoefficient() const { return Q; }
 };
@@ -2728,6 +2752,7 @@ private:
    DenseMatrix dshape;
    DenseMatrix gshape;
    DenseMatrix Jadj;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *trial_maps, *test_maps; ///< Not owned
@@ -2741,10 +2766,10 @@ public:
    {  }
    VectorDivergenceIntegrator(Coefficient *q_) :
       Q(q_), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   { }
+   {}
    VectorDivergenceIntegrator(Coefficient &q) :
       Q(&q), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   { }
+   {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2756,6 +2781,7 @@ public:
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
@@ -2769,11 +2795,6 @@ class DivDivIntegrator: public BilinearFormIntegrator
 protected:
    Coefficient *Q;
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &fes);
-   virtual void AddMultPA(const Vector &x, Vector &y) const;
-   virtual void AssembleDiagonalPA(Vector& diag);
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector divshape, te_divshape;
@@ -2789,7 +2810,7 @@ private:
 public:
    DivDivIntegrator() { Q = NULL; }
    DivDivIntegrator(Coefficient &q, const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(&q) { }
+      BilinearFormIntegrator(ir), Q(&q) {}
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
@@ -2800,6 +2821,13 @@ public:
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2836,7 +2864,7 @@ private:
    Vector vcoeff;
 
 public:
-   VectorDiffusionIntegrator() { }
+   VectorDiffusionIntegrator() {}
 
    /** \brief Integrator with unit coefficient for caller-specified vector
        dimension.
@@ -2844,13 +2872,13 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(int vector_dimension)
-      : vdim(vector_dimension) { }
+      : vdim(vector_dimension) {}
 
    VectorDiffusionIntegrator(Coefficient &q)
-      : Q(&q) { }
+      : Q(&q) {}
 
    VectorDiffusionIntegrator(Coefficient &q, const IntegrationRule *ir)
-      : BilinearFormIntegrator(ir), Q(&q) { }
+      : BilinearFormIntegrator(ir), Q(&q) {}
 
    /** \brief Integrator with scalar coefficient for caller-specified vector
        dimension.
@@ -2861,7 +2889,7 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(Coefficient &q, int vector_dimension)
-      : Q(&q), vdim(vector_dimension) { }
+      : Q(&q), vdim(vector_dimension) {}
 
    /** \brief Integrator with \c VectorCoefficient. The vector dimension of the
        \c FiniteElementSpace is assumed to be the same as the dimension of the
@@ -2873,7 +2901,7 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(VectorCoefficient &vq)
-      : VQ(&vq), vdim(vq.GetVDim()) { }
+      : VQ(&vq), vdim(vq.GetVDim()) {}
 
    /** \brief Integrator with \c MatrixCoefficient. The vector dimension of the
        \c FiniteElementSpace is assumed to be the same as the dimension of the
@@ -2885,21 +2913,30 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(MatrixCoefficient& mq)
-      : MQ(&mq), vdim(mq.GetVDim()) { }
+      : MQ(&mq), vdim(mq.GetVDim()) {}
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementVector(const FiniteElement &el,
                                       ElementTransformation &Tr,
                                       const Vector &elfun, Vector &elvect);
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
-   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    bool SupportsCeed() const { return DeviceCanUseCeed(); }
 };
 
@@ -2994,6 +3031,7 @@ protected:
    Coefficient *rho;
    VectorCoefficient *u;
    double alpha, beta;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;             ///< Not owned
@@ -3022,24 +3060,20 @@ public:
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-
    virtual void AssemblePAInteriorFaces(const FiniteElementSpace &fes);
 
    virtual void AssemblePABoundaryFaces(const FiniteElementSpace &fes);
 
-   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace& fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace& fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add);
+                                        Vector &ea_data_bdr);
 
    static const IntegrationRule &GetRule(Geometry::Type geom, int order,
                                          FaceElementTransformations &T);
@@ -3062,14 +3096,14 @@ class NonconservativeDGTraceIntegrator : public TransposeIntegrator
 {
 public:
    NonconservativeDGTraceIntegrator(VectorCoefficient &u, double a)
-      : TransposeIntegrator(new DGTraceIntegrator(u, -a, 0.5*a)) { }
+      : TransposeIntegrator(new DGTraceIntegrator(u, -a, 0.5*a)) {}
 
    NonconservativeDGTraceIntegrator(VectorCoefficient &u, double a, double b)
-      : TransposeIntegrator(new DGTraceIntegrator(u, -a, b)) { }
+      : TransposeIntegrator(new DGTraceIntegrator(u, -a, b)) {}
 
    NonconservativeDGTraceIntegrator(Coefficient &rho, VectorCoefficient &u,
                                     double a, double b)
-      : TransposeIntegrator(new DGTraceIntegrator(rho, u, -a, b)) { }
+      : TransposeIntegrator(new DGTraceIntegrator(rho, u, -a, b)) {}
 };
 
 /** Integrator for the DG form:
@@ -3097,11 +3131,12 @@ protected:
 
 public:
    DGDiffusionIntegrator(const double s, const double k)
-      : Q(NULL), MQ(NULL), sigma(s), kappa(k) { }
+      : Q(NULL), MQ(NULL), sigma(s), kappa(k) {}
    DGDiffusionIntegrator(Coefficient &q, const double s, const double k)
-      : Q(&q), MQ(NULL), sigma(s), kappa(k) { }
+      : Q(&q), MQ(NULL), sigma(s), kappa(k) {}
    DGDiffusionIntegrator(MatrixCoefficient &q, const double s, const double k)
-      : Q(NULL), MQ(&q), sigma(s), kappa(k) { }
+      : Q(NULL), MQ(&q), sigma(s), kappa(k) {}
+
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
@@ -3233,11 +3268,11 @@ class DGElasticityIntegrator : public BilinearFormIntegrator
 {
 public:
    DGElasticityIntegrator(double alpha_, double kappa_)
-      : lambda(NULL), mu(NULL), alpha(alpha_), kappa(kappa_) { }
+      : lambda(NULL), mu(NULL), alpha(alpha_), kappa(kappa_) {}
 
    DGElasticityIntegrator(Coefficient &lambda_, Coefficient &mu_,
                           double alpha_, double kappa_)
-      : lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) { }
+      : lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) {}
 
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
@@ -3288,7 +3323,8 @@ private:
    Vector face_shape, shape1, shape2;
 
 public:
-   TraceJumpIntegrator() { }
+   TraceJumpIntegrator() {}
+
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
                                    const FiniteElement &test_fe1,
@@ -3307,7 +3343,8 @@ private:
    DenseMatrix shape1, shape2;
 
 public:
-   NormalTraceJumpIntegrator() { }
+   NormalTraceJumpIntegrator() {}
+
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
                                    const FiniteElement &test_fe1,
@@ -3399,8 +3436,7 @@ public:
 
 /** Abstract class to serve as a base for local interpolators to be used in the
     DiscreteLinearOperator class. */
-class DiscreteInterpolator : public BilinearFormIntegrator { };
-
+class DiscreteInterpolator : public BilinearFormIntegrator {};
 
 /** Class for constructing the gradient as a DiscreteLinearOperator from an
     H1-conforming space to an H(curl)-conforming space. The range space can be
@@ -3408,7 +3444,7 @@ class DiscreteInterpolator : public BilinearFormIntegrator { };
 class GradientInterpolator : public DiscreteInterpolator
 {
 public:
-   GradientInterpolator() : dofquad_fe(NULL) { }
+   GradientInterpolator() : dofquad_fe(NULL) {}
    virtual ~GradientInterpolator() { delete dofquad_fe; }
 
    virtual void AssembleElementMatrix2(const FiniteElement &h1_fe,
@@ -3417,17 +3453,17 @@ public:
                                        DenseMatrix &elmat)
    { nd_fe.ProjectGrad(h1_fe, Trans, elmat); }
 
-   using BilinearFormIntegrator::AssemblePA;
-
    /** @brief Setup method for PA data.
 
        @param[in] trial_fes   H1 Lagrange space
        @param[in] test_fes    H(curl) Nedelec space
     */
+   using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
 private:
@@ -3440,7 +3476,6 @@ private:
    int dim, ne, o_dofs1D, c_dofs1D;
 };
 
-
 /** Class for constructing the identity map as a DiscreteLinearOperator. This
     is the discrete embedding matrix when the domain space is a subspace of
     the range space. Otherwise, a dof projection matrix is constructed. */
@@ -3456,11 +3491,11 @@ public:
    { ran_fe.Project(dom_fe, Trans, elmat); }
 
    using BilinearFormIntegrator::AssemblePA;
-
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    virtual ~IdentityInterpolator() { delete dofquad_fe; }
@@ -3476,7 +3511,6 @@ private:
    Vector pa_data;
 };
 
-
 /** Class for constructing the (local) discrete curl matrix which can be used
     as an integrator in a DiscreteLinearOperator object to assemble the global
     discrete curl matrix. */
@@ -3490,7 +3524,6 @@ public:
    { ran_fe.ProjectCurl(dom_fe, Trans, elmat); }
 };
 
-
 /** Class for constructing the (local) discrete divergence matrix which can
     be used as an integrator in a DiscreteLinearOperator object to assemble
     the global discrete divergence matrix.
@@ -3509,7 +3542,6 @@ public:
    { ran_fe.ProjectDiv(dom_fe, Trans, elmat); }
 };
 
-
 /** A trace face interpolator class for interpolating the normal component of
     the domain space, e.g. vector H1, into the range space, e.g. the trace of
     RT which uses FiniteElement::INTEGRAL map type. */
@@ -3528,7 +3560,7 @@ public:
 class ScalarProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarProductInterpolator(Coefficient & sc) : Q(&sc) { }
+   ScalarProductInterpolator(Coefficient &sc) : Q(&sc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
@@ -3545,13 +3577,14 @@ protected:
 class ScalarVectorProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarVectorProductInterpolator(Coefficient & sc)
-      : Q(&sc) { }
+   ScalarVectorProductInterpolator(Coefficient &sc)
+      : Q(&sc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    Coefficient *Q;
 };
@@ -3562,13 +3595,14 @@ protected:
 class VectorScalarProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorScalarProductInterpolator(VectorCoefficient & vc)
-      : VQ(&vc) { }
+   VectorScalarProductInterpolator(VectorCoefficient &vc)
+      : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
@@ -3578,13 +3612,14 @@ protected:
 class ScalarCrossProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarCrossProductInterpolator(VectorCoefficient & vc)
-      : VQ(&vc) { }
+   ScalarCrossProductInterpolator(VectorCoefficient &vc)
+      : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &nd_fe,
                                        const FiniteElement &l2_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
@@ -3595,13 +3630,14 @@ protected:
 class VectorCrossProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorCrossProductInterpolator(VectorCoefficient & vc)
-      : VQ(&vc) { }
+   VectorCrossProductInterpolator(VectorCoefficient &vc)
+      : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &nd_fe,
                                        const FiniteElement &rt_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
@@ -3612,12 +3648,13 @@ protected:
 class VectorInnerProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorInnerProductInterpolator(VectorCoefficient & vc) : VQ(&vc) { }
+   VectorInnerProductInterpolator(VectorCoefficient &vc) : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &rt_fe,
                                        const FiniteElement &l2_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
diff --git a/fem/ceed/interface/operator.cpp b/fem/ceed/interface/operator.cpp
index 8545ccaa8..745e474e5 100644
--- a/fem/ceed/interface/operator.cpp
+++ b/fem/ceed/interface/operator.cpp
@@ -46,7 +46,7 @@ void Operator::Mult(const mfem::Vector &x, mfem::Vector &y) const
    CeedScalar *y_ptr;
    CeedMemType mem;
    CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       x_ptr = x.Read();
       y_ptr = y.Write();
@@ -78,7 +78,7 @@ void Operator::AddMult(const mfem::Vector &x, mfem::Vector &y,
    CeedScalar *y_ptr;
    CeedMemType mem;
    CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       x_ptr = x.Read();
       y_ptr = y.ReadWrite();
@@ -107,7 +107,7 @@ void Operator::GetDiagonal(mfem::Vector &diag) const
    CeedScalar *d_ptr;
    CeedMemType mem;
    CeedGetPreferredMemType(mfem::internal::ceed, &mem);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       d_ptr = diag.ReadWrite();
    }
diff --git a/fem/ceed/interface/operator.hpp b/fem/ceed/interface/operator.hpp
index cffea2fc7..9e4a4faaf 100644
--- a/fem/ceed/interface/operator.hpp
+++ b/fem/ceed/interface/operator.hpp
@@ -37,11 +37,12 @@ public:
    /// This class takes ownership of op and will delete it
    Operator(CeedOperator op);
 #endif
+
    void Mult(const mfem::Vector &x, mfem::Vector &y) const override;
    void AddMult(const mfem::Vector &x, mfem::Vector &y,
                 const double a = 1.0) const override;
    void GetDiagonal(mfem::Vector &diag) const;
-   using mfem::Operator::SetupRAP;
+
    virtual ~Operator()
    {
 #ifdef MFEM_USE_CEED
diff --git a/fem/ceed/interface/util.cpp b/fem/ceed/interface/util.cpp
index d122c2ab5..b65fd2197 100644
--- a/fem/ceed/interface/util.cpp
+++ b/fem/ceed/interface/util.cpp
@@ -217,7 +217,7 @@ const IntegrationRule & GetRule<ConvectionIntegrator>(
    const FiniteElement &test_fe,
    ElementTransformation &trans)
 {
-   return ConvectionIntegrator::GetRule(trial_fe, test_fe, trans);
+   return ConvectionIntegrator::GetRule(trial_fe, trans);
 }
 
 template <>
diff --git a/fem/ceed/solvers/algebraic.cpp b/fem/ceed/solvers/algebraic.cpp
index 2cc325dbc..280a19960 100644
--- a/fem/ceed/solvers/algebraic.cpp
+++ b/fem/ceed/solvers/algebraic.cpp
@@ -46,7 +46,7 @@ private:
    Array<int> ess_tdofs;
    const mfem::Operator *P;
    ceed::Operator *unconstrained_op;
-   mfem::ConstrainedOperator *constrained_op;
+   mfem::Operator *constrained_op;
 };
 
 ConstrainedOperator::ConstrainedOperator(
@@ -56,10 +56,8 @@ ConstrainedOperator::ConstrainedOperator(
    : ess_tdofs(ess_tdofs_), P(P_)
 {
    unconstrained_op = new ceed::Operator(oper);
-   mfem::Operator *rap = unconstrained_op->SetupRAP(P, P);
-   height = width = rap->Height();
-   bool own_rap = (rap != unconstrained_op);
-   constrained_op = new mfem::ConstrainedOperator(rap, ess_tdofs, own_rap);
+   unconstrained_op->FormSystemOperator(ess_tdofs, constrained_op);
+   height = width = constrained_op->Height();
 }
 
 ConstrainedOperator::ConstrainedOperator(CeedOperator oper,
@@ -535,7 +533,7 @@ void AlgebraicInterpolation::Mult(const mfem::Vector& x, mfem::Vector& y) const
    CeedScalar *out_ptr;
    CeedMemType mem;
    ierr = CeedGetPreferredMemType(internal::ceed, &mem); PCeedChk(ierr);
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       in_ptr = x.Read();
       out_ptr = y.ReadWrite();
@@ -568,7 +566,7 @@ void AlgebraicInterpolation::MultTranspose(const mfem::Vector& x,
    ierr = CeedGetPreferredMemType(internal::ceed, &mem); PCeedChk(ierr);
    const CeedScalar *in_ptr;
    CeedScalar *out_ptr;
-   if ( Device::Allows(Backend::DEVICE_MASK) && mem==CEED_MEM_DEVICE )
+   if (Device::Allows(Backend::DEVICE_MASK) && mem == CEED_MEM_DEVICE)
    {
       in_ptr = x.Read();
       out_ptr = y.ReadWrite();
@@ -808,15 +806,6 @@ ParAlgebraicCoarseSpace::ParAlgebraicCoarseSpace(
       }
    }
    R_mat->Finalize();
-
-   if (Device::Allows(Backend::DEVICE_MASK))
-   {
-      P = new DeviceConformingProlongationOperator(*gc, R_mat);
-   }
-   else
-   {
-      P = new ConformingProlongationOperator(lsize, *gc);
-   }
    P_mat = NULL;
 }
 
@@ -828,8 +817,8 @@ HypreParMatrix *ParAlgebraicCoarseSpace::GetProlongationHypreParMatrix()
    MFEM_VERIFY(pmesh != NULL, "");
    Array<HYPRE_BigInt> dof_offsets, tdof_offsets, tdof_nb_offsets;
    Array<HYPRE_BigInt> *offsets[2] = {&dof_offsets, &tdof_offsets};
-   int lsize = P->Height();
-   int ltsize = P->Width();
+   int ltsize = R_mat->Height();
+   int lsize = R_mat->Width();
    HYPRE_BigInt loc_sizes[2] = {lsize, ltsize};
    pmesh->GenerateOffsets(2, loc_sizes, offsets);
 
@@ -936,7 +925,6 @@ HypreParMatrix *ParAlgebraicCoarseSpace::GetProlongationHypreParMatrix()
 
 ParAlgebraicCoarseSpace::~ParAlgebraicCoarseSpace()
 {
-   delete P;
    delete R_mat;
    delete P_mat;
    delete gc;
diff --git a/fem/ceed/solvers/algebraic.hpp b/fem/ceed/solvers/algebraic.hpp
index 49cdbca98..8ede8324e 100644
--- a/fem/ceed/solvers/algebraic.hpp
+++ b/fem/ceed/solvers/algebraic.hpp
@@ -33,12 +33,13 @@ class AlgebraicCoarseSpace : public FiniteElementSpace
 public:
    AlgebraicCoarseSpace(FiniteElementSpace &fine_fes, CeedElemRestriction fine_er,
                         int order, int dim, int order_reduction_);
+   ~AlgebraicCoarseSpace();
+
    int GetOrderReduction() const { return order_reduction; }
    CeedElemRestriction GetCeedElemRestriction() const { return ceed_elem_restriction; }
    CeedBasis GetCeedCoarseToFine() const { return coarse_to_fine; }
    virtual const mfem::Operator *GetProlongationMatrix() const override { return NULL; }
    virtual const SparseMatrix *GetRestrictionMatrix() const override { return NULL; }
-   ~AlgebraicCoarseSpace();
 
 protected:
    int *dof_map;
@@ -64,16 +65,16 @@ public:
       int order_reduction_,
       GroupCommunicator *gc_fine
    );
-   virtual const mfem::Operator *GetProlongationMatrix() const override { return P; }
+   ~ParAlgebraicCoarseSpace();
+
+   virtual const mfem::Operator *GetProlongationMatrix() const override { return P_mat; }
    virtual const SparseMatrix *GetRestrictionMatrix() const override { return R_mat; }
    GroupCommunicator *GetGroupCommunicator() const { return gc; }
    HypreParMatrix *GetProlongationHypreParMatrix();
-   ~ParAlgebraicCoarseSpace();
 
 private:
-   SparseMatrix *R_mat;
    GroupCommunicator *gc;
-   ConformingProlongationOperator *P;
+   SparseMatrix *R_mat;
    HypreParMatrix *P_mat;
    Array<int> ldof_group, ldof_ltdof;
 };
@@ -92,14 +93,11 @@ public:
       Ceed ceed, CeedBasis basisctof,
       CeedElemRestriction erestrictu_coarse,
       CeedElemRestriction erestrictu_fine);
-
    ~AlgebraicInterpolation();
 
    virtual void Mult(const mfem::Vector& x, mfem::Vector& y) const;
-
    virtual void MultTranspose(const mfem::Vector& x, mfem::Vector& y) const;
 
-   using mfem::Operator::SetupRAP;
 private:
    int Initialize(Ceed ceed, CeedBasis basisctof,
                   CeedElemRestriction erestrictu_coarse,
@@ -127,11 +125,6 @@ public:
        The given space is a real (geometric) space, but the coarse spaces are
        constructed semi-algebraically with no mesh information. */
    AlgebraicSpaceHierarchy(FiniteElementSpace &fespace);
-   AlgebraicCoarseSpace& GetAlgebraicCoarseSpace(int level)
-   {
-      MFEM_ASSERT(level < GetNumLevels() - 1, "");
-      return static_cast<AlgebraicCoarseSpace&>(*fespaces[level]);
-   }
    ~AlgebraicSpaceHierarchy()
    {
       for (int i=0; i<R_tr.Size(); ++i)
@@ -144,6 +137,12 @@ public:
       }
    }
 
+   AlgebraicCoarseSpace& GetAlgebraicCoarseSpace(int level)
+   {
+      MFEM_ASSERT(level < GetNumLevels() - 1, "");
+      return static_cast<AlgebraicCoarseSpace&>(*fespaces[level]);
+   }
+
 private:
    CeedElemRestriction fine_er;
    Array<AlgebraicInterpolation*> ceed_interpolations;
@@ -200,6 +199,7 @@ public:
     */
    AlgebraicSolver(BilinearForm &form, const Array<int>& ess_tdofs);
    ~AlgebraicSolver();
+
    void Mult(const Vector& x, Vector& y) const;
    void SetOperator(const mfem::Operator& op);
 };
diff --git a/fem/coefficient.cpp b/fem/coefficient.cpp
index 04b96a355..5b51454d6 100644
--- a/fem/coefficient.cpp
+++ b/fem/coefficient.cpp
@@ -187,8 +187,8 @@ double SphericalPolarCoefficient::Eval(ElementTransformation & T,
                 transip[2]);
 }
 
-double GridFunctionCoefficient::Eval (ElementTransformation &T,
-                                      const IntegrationPoint &ip)
+double GridFunctionCoefficient::Eval(ElementTransformation &T,
+                                     const IntegrationPoint &ip)
 {
    Mesh *gf_mesh = GridF->FESpace()->GetMesh();
    if (T.mesh->GetNE() == gf_mesh->GetNE())
@@ -673,12 +673,6 @@ void PWMatrixCoefficient::UpdateCoefficient(int attr, MatrixCoefficient & coef)
    MFEM_VERIFY(coef.GetWidth() == width,
                "PWMatrixCoefficient::UpdateCoefficient:  "
                "MatrixCoefficient has incompatible width.");
-   if (symmetric)
-   {
-      MFEM_VERIFY(coef.IsSymmetric(),
-                  "PWMatrixCoefficient::UpdateCoefficient:  "
-                  "MatrixCoefficient has incompatible symmetry.");
-   }
    pieces[attr] = &coef;
 }
 
@@ -730,68 +724,17 @@ void MatrixFunctionCoefficient::Eval(DenseMatrix &K, ElementTransformation &T,
 
    K.SetSize(height, width);
 
-   if (symmetric) // Use SymmFunction (deprecated version)
-   {
-      MFEM_VERIFY(height == width && SymmFunction,
-                  "MatrixFunctionCoefficient is not symmetric");
-
-      Vector Ksym((width * (width + 1)) / 2); // 1x1: 1, 2x2: 3, 3x3: 6
-
-      SymmFunction(transip, Ksym);
-
-      // Copy upper triangular values from Ksym to the full matrix K
-      int os = 0;
-      for (int i=0; i<height; ++i)
-      {
-         for (int j=i; j<width; ++j)
-         {
-            const double Kij = Ksym[j - i + os];
-            K(i,j) = Kij;
-            if (j != i) { K(j,i) = Kij; }
-         }
-
-         os += width - i;
-      }
-   }
-   else
+   if (Function)
    {
-      if (Function)
-      {
-         Function(transip, K);
-      }
-      else if (TDFunction)
-      {
-         TDFunction(transip, GetTime(), K);
-      }
-      else
-      {
-         K = mat;
-      }
+      Function(transip, K);
    }
-
-   if (Q)
+   else if (TDFunction)
    {
-      K *= Q->Eval(T, ip, GetTime());
+      TDFunction(transip, GetTime(), K);
    }
-}
-
-void MatrixFunctionCoefficient::EvalSymmetric(Vector &K,
-                                              ElementTransformation &T,
-                                              const IntegrationPoint &ip)
-{
-   MFEM_VERIFY(symmetric && height == width && SymmFunction,
-               "MatrixFunctionCoefficient is not symmetric");
-
-   double x[3];
-   Vector transip(x, 3);
-
-   T.Transform(ip, transip);
-
-   K.SetSize((width * (width + 1)) / 2); // 1x1: 1, 2x2: 3, 3x3: 6
-
-   if (SymmFunction)
+   else
    {
-      SymmFunction(transip, K);
+      K = mat;
    }
 
    if (Q)
@@ -832,7 +775,7 @@ void SymmetricMatrixCoefficient::Eval(DenseMatrix &K, ElementTransformation &T,
    Eval(mat, T, ip);
    for (int j = 0; j < width; ++j)
    {
-      for (int i = 0; i < height; ++ i)
+      for (int i = 0; i < height; ++i)
       {
          K(i, j) = mat(i, j);
       }
@@ -1832,3 +1775,4 @@ CoefficientVector::~CoefficientVector()
 }
 
 }
+
diff --git a/fem/coefficient.hpp b/fem/coefficient.hpp
index b98ac360b..ecc4ab7b1 100644
--- a/fem/coefficient.hpp
+++ b/fem/coefficient.hpp
@@ -106,7 +106,6 @@ private:
    Vector constants;
 
 public:
-
    /// Constructs a piecewise constant coefficient in NumOfSubD subdomains
    explicit PWConstCoefficient(int NumOfSubD = 0) : constants(NumOfSubD)
    { constants = 0.0; }
@@ -177,7 +176,6 @@ private:
                 const Array<Coefficient*> & coefs);
 
 public:
-
    /// Constructs a piecewise coefficient
    explicit PWCoefficient() {}
 
@@ -458,7 +456,6 @@ protected:
    double (*tdf)(double);
 
 public:
-
    /// Construct a unit delta function centered at (0.0,0.0,0.0)
    DeltaCoefficient()
    {
@@ -621,15 +618,16 @@ class VectorConstantCoefficient : public VectorCoefficient
 {
 private:
    Vector vec;
+
 public:
    /// Construct the coefficient with constant vector @a v.
    VectorConstantCoefficient(const Vector &v)
       : VectorCoefficient(v.Size()), vec(v) { }
-   using VectorCoefficient::Eval;
 
    ///  Evaluate the vector coefficient at @a ip.
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip) { V = vec; }
+   using VectorCoefficient::Eval;
 
    /// Return a reference to the constant vector in this class.
    const Vector& GetVec() const { return vec; }
@@ -679,7 +677,6 @@ private:
                 const Array<VectorCoefficient*> & coefs);
 
 public:
-
    /// Constructs a piecewise vector coefficient of dimension vd
    explicit PWVectorCoefficient(int vd): VectorCoefficient(vd) {}
 
@@ -763,10 +760,10 @@ public:
       : VectorCoefficient(dim), TDFunction(std::move(TDF)), Q(q)
    { }
 
-   using VectorCoefficient::Eval;
    /// Evaluate the vector coefficient at @a ip.
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    virtual ~VectorFunctionCoefficient() { }
 };
@@ -803,11 +800,11 @@ public:
    double Eval(int i, ElementTransformation &T, const IntegrationPoint &ip)
    { return Coeff[i] ? Coeff[i]->Eval(T, ip, GetTime()) : 0.0; }
 
-   using VectorCoefficient::Eval;
    /** @brief Evaluate the coefficient. Each element of vector V comes from the
        associated array of scalar coefficients. */
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    /// Destroys vector coefficient.
    virtual ~VectorArrayCoefficient();
@@ -862,7 +859,6 @@ protected:
    const GridFunction *GridFunc;
 
 public:
-
    /** @brief Construct the coefficient with a scalar grid function @a gf. The
        grid function is not owned by the coefficient. */
    GradientGridFunctionCoefficient(const GridFunction *gf);
@@ -903,10 +899,10 @@ public:
    /// Get the vector grid function.
    const GridFunction * GetGridFunction() const { return GridFunc; }
 
-   using VectorCoefficient::Eval;
    /// Evaluate the vector curl coefficient at @a ip.
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    virtual ~CurlGridFunctionCoefficient() { }
 };
@@ -995,12 +991,13 @@ public:
    virtual void EvalDelta(Vector &V, ElementTransformation &T,
                           const IntegrationPoint &ip);
 
-   using VectorCoefficient::Eval;
    /** @brief A VectorDeltaFunction cannot be evaluated. Calling this method
        will cause an MFEM error, terminating the application. */
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip)
    { mfem_error("VectorDeltaCoefficient::Eval"); }
+   using VectorCoefficient::Eval;
+
    virtual ~VectorDeltaCoefficient() { }
 };
 
@@ -1042,16 +1039,15 @@ class MatrixCoefficient
 protected:
    int height, width;
    double time;
-   bool symmetric;  // deprecated
 
 public:
    /// Construct a dim x dim matrix coefficient.
-   explicit MatrixCoefficient(int dim, bool symm=false)
-   { height = width = dim; time = 0.; symmetric = symm; }
+   explicit MatrixCoefficient(int dim)
+   { height = width = dim; time = 0.; }
 
    /// Construct a h x w matrix coefficient.
-   MatrixCoefficient(int h, int w, bool symm=false) :
-      height(h), width(w), time(0.), symmetric(symm) { }
+   MatrixCoefficient(int h, int w) :
+      height(h), width(w), time(0.) { }
 
    /// Set the time for time dependent coefficients
    virtual void SetTime(double t) { time = t; }
@@ -1068,9 +1064,6 @@ public:
    /// For backward compatibility get the width of the matrix.
    int GetVDim() const { return width; }
 
-   /** @deprecated Use SymmetricMatrixCoefficient instead */
-   bool IsSymmetric() const { return symmetric; }
-
    /** @brief Evaluate the matrix coefficient in the element described by @a T
        at the point @a ip, storing the result in @a K. */
    /** @note When this method is called, the caller must make sure that the
@@ -1087,17 +1080,6 @@ public:
    /// the width of the matrix.
    virtual void Project(QuadratureFunction &qf, bool transpose=false);
 
-   /// (DEPRECATED) Evaluate a symmetric matrix coefficient.
-   /** @brief Evaluate the upper triangular entries of the matrix coefficient
-       in the symmetric case, similarly to Eval. Matrix entry (i,j) is stored
-       in K[j - i + os_i] for 0 <= i <= j < width, os_0 = 0,
-       os_{i+1} = os_i + width - i. That is, K = {M(0,0), ..., M(0,w-1),
-       M(1,1), ..., M(1,w-1), ..., M(w-1,w-1) with w = width.
-       @deprecated Use Eval() instead. */
-   virtual void EvalSymmetric(Vector &K, ElementTransformation &T,
-                              const IntegrationPoint &ip)
-   { mfem_error("MatrixCoefficient::EvalSymmetric"); }
-
    virtual ~MatrixCoefficient() { }
 };
 
@@ -1107,14 +1089,17 @@ class MatrixConstantCoefficient : public MatrixCoefficient
 {
 private:
    DenseMatrix mat;
+
 public:
    ///Construct using matrix @a m for the constant.
    MatrixConstantCoefficient(const DenseMatrix &m)
       : MatrixCoefficient(m.Height(), m.Width()), mat(m) { }
-   using MatrixCoefficient::Eval;
+
    /// Evaluate the matrix coefficient at @a ip.
    virtual void Eval(DenseMatrix &M, ElementTransformation &T,
                      const IntegrationPoint &ip) { M = mat; }
+   using MatrixCoefficient::Eval;
+
    /// Return a reference to the constant matrix.
    const DenseMatrix& GetMatrix() { return mat; }
 };
@@ -1164,20 +1149,18 @@ private:
                 const Array<MatrixCoefficient*> & coefs);
 
 public:
-
    /// Constructs a piecewise matrix coefficient of dimension dim by dim
-   explicit PWMatrixCoefficient(int dim, bool symm = false)
-      : MatrixCoefficient(dim, symm) {}
+   explicit PWMatrixCoefficient(int dim)
+      : MatrixCoefficient(dim) {}
 
    /// Constructs a piecewise matrix coefficient of dimension h by w
-   explicit PWMatrixCoefficient(int h, int w, bool symm = false)
-      : MatrixCoefficient(h, w, symm) {}
+   explicit PWMatrixCoefficient(int h, int w)
+      : MatrixCoefficient(h, w) {}
 
    /// Construct the coefficient using arrays describing the pieces
    /** \param dim - size of the square matrix-valued result
        \param attr - an array of attribute numbers for each piece
        \param coefs - the corresponding array of MatrixCoefficient pointers
-       \param symm - true if the result will be symmetric, false otherwise
        Any missing attributes or NULL coefficient pointers will result in a
        zero matrix being returned.
 
@@ -1185,16 +1168,14 @@ public:
        transferred to this object.
    */
    PWMatrixCoefficient(int dim, const Array<int> & attr,
-                       const Array<MatrixCoefficient*> & coefs,
-                       bool symm=false)
-      : MatrixCoefficient(dim, symm) { InitMap(attr, coefs); }
+                       const Array<MatrixCoefficient*> & coefs)
+      : MatrixCoefficient(dim) { InitMap(attr, coefs); }
 
    /// Construct the coefficient using arrays describing the pieces
    /** \param h - height of the matrix-valued result
        \param w - width of the matrix-valued result
        \param attr - an array of attribute numbers for each piece
        \param coefs - the corresponding array of MatrixCoefficient pointers
-       \param symm - true if the result will be symmetric, false otherwise
        Any missing attributes or NULL coefficient pointers will result in a
        zero matrix being returned for that attribute.
 
@@ -1202,9 +1183,8 @@ public:
        transferred to this object.
    */
    PWMatrixCoefficient(int h, int w, const Array<int> & attr,
-                       const Array<MatrixCoefficient*> & coefs,
-                       bool symm=false)
-      : MatrixCoefficient(h, w, symm) { InitMap(attr, coefs); }
+                       const Array<MatrixCoefficient*> & coefs)
+      : MatrixCoefficient(h, w) { InitMap(attr, coefs); }
 
    /// Set the time for time dependent coefficients
    virtual void SetTime(double t);
@@ -1233,7 +1213,6 @@ class MatrixFunctionCoefficient : public MatrixCoefficient
 {
 private:
    std::function<void(const Vector &, DenseMatrix &)> Function;
-   std::function<void(const Vector &, Vector &)> SymmFunction;  // deprecated
    std::function<void(const Vector &, double, DenseMatrix &)> TDFunction;
 
    Coefficient *Q;
@@ -1257,28 +1236,6 @@ public:
       : MatrixCoefficient(m.Height(), m.Width()), Q(&q), mat(m)
    { }
 
-   /** @brief Define a time-independent symmetric square matrix coefficient from
-       a std function */
-   /** \param dim - the size of the matrix
-       \param SymmF - function used in EvalSymmetric
-       \param q - optional scalar Coefficient to scale the matrix coefficient
-       @deprecated Use another constructor without setting SymmFunction. */
-   MatrixFunctionCoefficient(int dim,
-                             std::function<void(const Vector &, Vector &)> SymmF,
-                             Coefficient *q = NULL)
-      : MatrixCoefficient(dim, true), SymmFunction(std::move(SymmF)), Q(q), mat(0)
-   { }
-
-   /// Define a time-dependent square matrix coefficient from a std function
-   /** \param dim - the size of the matrix
-       \param TDF - time-dependent function
-       \param q - optional scalar Coefficient to scale the matrix coefficient */
-   MatrixFunctionCoefficient(int dim,
-                             std::function<void(const Vector &, double, DenseMatrix &)> TDF,
-                             Coefficient *q = nullptr)
-      : MatrixCoefficient(dim), TDFunction(std::move(TDF)), Q(q)
-   { }
-
    /// Set the time for internally stored coefficients
    void SetTime(double t);
 
@@ -1286,11 +1243,6 @@ public:
    virtual void Eval(DenseMatrix &K, ElementTransformation &T,
                      const IntegrationPoint &ip);
 
-   /// (DEPRECATED) Evaluate the symmetric matrix coefficient at @a ip.
-   /** @deprecated Use Eval() instead. */
-   virtual void EvalSymmetric(Vector &K, ElementTransformation &T,
-                              const IntegrationPoint &ip);
-
    virtual ~MatrixFunctionCoefficient() { }
 };
 
@@ -1320,12 +1272,11 @@ public:
        can be overridden with the @a own parameter. */
    void Set(int i, int j, Coefficient * c, bool own=true);
 
-   using MatrixCoefficient::Eval;
-
    /// Evaluate coefficient located at (i,j) in the matrix using integration
    /// point @a ip.
    double Eval(int i, int j, ElementTransformation &T, const IntegrationPoint &ip)
    { return Coeff[i*width+j] ? Coeff[i*width+j] -> Eval(T, ip, GetTime()) : 0.0; }
+   using MatrixCoefficient::Eval;
 
    /// Evaluate the matrix coefficient @a ip.
    virtual void Eval(DenseMatrix &K, ElementTransformation &T,
@@ -1428,10 +1379,11 @@ class SymmetricMatrixCoefficient : public MatrixCoefficient
 protected:
    /// Internal matrix used when evaluating this coefficient as a DenseMatrix.
    DenseSymmetricMatrix mat;
+
 public:
    /// Construct a dim x dim matrix coefficient.
    explicit SymmetricMatrixCoefficient(int dimension)
-      : MatrixCoefficient(dimension, true) { }
+      : MatrixCoefficient(dimension) { }
 
    /// Get the size of the matrix.
    int GetSize() const { return height; }
@@ -1481,10 +1433,11 @@ public:
    ///Construct using matrix @a m for the constant.
    SymmetricMatrixConstantCoefficient(const DenseSymmetricMatrix &m)
       : SymmetricMatrixCoefficient(m.Height()), mat(m) { }
-   using SymmetricMatrixCoefficient::Eval;
+
    /// Evaluate the matrix coefficient at @a ip.
    virtual void Eval(DenseSymmetricMatrix &M, ElementTransformation &T,
                      const IntegrationPoint &ip) { M = mat; }
+   using SymmetricMatrixCoefficient::Eval;
 };
 
 
@@ -1532,10 +1485,10 @@ public:
    /// Set the time for internally stored coefficients
    void SetTime(double t);
 
-   using SymmetricMatrixCoefficient::Eval;
    /// Evaluate the matrix coefficient at @a ip.
    virtual void Eval(DenseSymmetricMatrix &K, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using SymmetricMatrixCoefficient::Eval;
 
    virtual ~SymmetricMatrixFunctionCoefficient() { }
 };
@@ -1682,6 +1635,7 @@ private:
 
    mutable Vector va;
    mutable Vector vb;
+
 public:
    /// Construct with the two vector coefficients.  Result is \f$ A \cdot B \f$.
    InnerProductCoefficient(VectorCoefficient &A, VectorCoefficient &B);
@@ -2254,9 +2208,9 @@ public:
 
    const QuadratureFunction& GetQuadFunction() const { return QuadF; }
 
-   using VectorCoefficient::Eval;
    virtual void Eval(Vector &V, ElementTransformation &T,
                      const IntegrationPoint &ip);
+   using VectorCoefficient::Eval;
 
    virtual void Project(QuadratureFunction &qf);
 
@@ -2320,6 +2274,7 @@ protected:
    int vdim; ///< Number of values per quadrature point.
    QuadratureSpaceBase &qs; ///< Associated QuadratureSpaceBase.
    QuadratureFunction *qf; ///< Internal QuadratureFunction (owned, may be NULL).
+
 public:
    /// Create an empty CoefficientVector.
    CoefficientVector(QuadratureSpaceBase &qs_,
@@ -2421,3 +2376,4 @@ double ComputeGlobalLpNorm(double p, VectorCoefficient &coeff, ParMesh &pmesh,
 }
 
 #endif
+
diff --git a/fem/fespace.cpp b/fem/fespace.cpp
index 29a1aa980..cb82c6008 100644
--- a/fem/fespace.cpp
+++ b/fem/fespace.cpp
@@ -428,15 +428,6 @@ void FiniteElementSpace::BuildFaceToDofTable() const
    face_dof = fc_dof;
 }
 
-void FiniteElementSpace::RebuildElementToDofTable()
-{
-   delete elem_dof;
-   delete elem_fos;
-   elem_dof = NULL;
-   elem_fos = NULL;
-   BuildElementToDofTable();
-}
-
 void FiniteElementSpace::ReorderElementToDofTable()
 {
    Array<int> dof_marker(ndofs);
@@ -1256,7 +1247,7 @@ int FiniteElementSpace::GetNConformingDofs() const
    return P ? (P->Width() / vdim) : ndofs;
 }
 
-const ElementRestrictionOperator *FiniteElementSpace::GetElementRestriction(
+const ElementRestriction *FiniteElementSpace::GetElementRestriction(
    ElementDofOrdering e_ordering) const
 {
    // Check if we have a discontinuous space using the FE collection:
@@ -1271,22 +1262,22 @@ const ElementRestrictionOperator *FiniteElementSpace::GetElementRestriction(
          // The output E-vector layout is: ND x VDIM x NE.
          L2E_nat.Reset(new L2ElementRestriction(*this));
       }
-      return L2E_nat.Is<ElementRestrictionOperator>();
+      return L2E_nat.Is<ElementRestriction>();
    }
    if (e_ordering == ElementDofOrdering::LEXICOGRAPHIC)
    {
       if (L2E_lex.Ptr() == NULL)
       {
-         L2E_lex.Reset(new ElementRestriction(*this, e_ordering));
+         L2E_lex.Reset(new ConformingElementRestriction(*this, e_ordering));
       }
-      return L2E_lex.Is<ElementRestrictionOperator>();
+      return L2E_lex.Is<ElementRestriction>();
    }
    // e_ordering == ElementDofOrdering::NATIVE
    if (L2E_nat.Ptr() == NULL)
    {
-      L2E_nat.Reset(new ElementRestriction(*this, e_ordering));
+      L2E_nat.Reset(new ConformingElementRestriction(*this, e_ordering));
    }
-   return L2E_nat.Is<ElementRestrictionOperator>();
+   return L2E_nat.Is<ElementRestriction>();
 }
 
 const FaceRestriction *FiniteElementSpace::GetFaceRestriction(
diff --git a/fem/fespace.hpp b/fem/fespace.hpp
index c30299bfe..b80c58310 100644
--- a/fem/fespace.hpp
+++ b/fem/fespace.hpp
@@ -602,18 +602,6 @@ public:
    virtual const Operator *GetProlongationMatrix() const
    { return GetConformingProlongation(); }
 
-   /// Return an operator that performs the transpose of GetRestrictionOperator
-   /** The returned operator is owned by the FiniteElementSpace. In serial this
-       is the same as GetProlongationMatrix() */
-   virtual const Operator *GetRestrictionTransposeOperator() const
-   { return GetConformingProlongation(); }
-
-   /// An abstract operator that performs the same action as GetRestrictionMatrix
-   /** In some cases this is an optimized matrix-free implementation. The
-       returned operator is owned by the FiniteElementSpace. */
-   virtual const Operator *GetRestrictionOperator() const
-   { return GetConformingRestriction(); }
-
    /// The returned SparseMatrix is owned by the FiniteElementSpace.
    virtual const SparseMatrix *GetRestrictionMatrix() const
    { return GetConformingRestriction(); }
@@ -639,7 +627,7 @@ public:
        L2ElementRestriction class.
 
        The returned Operator is owned by the FiniteElementSpace. */
-   const ElementRestrictionOperator *GetElementRestriction(
+   const ElementRestriction *GetElementRestriction(
       ElementDofOrdering e_ordering) const;
 
    /// Return an Operator that converts L-vectors to E-vectors on each face.
@@ -1060,9 +1048,6 @@ public:
    void GetEdgeInteriorVDofs(int i, Array<int> &vdofs) const;
    /// @}
 
-   /// (@deprecated) Use the Update() method if the space or mesh changed.
-   MFEM_DEPRECATED void RebuildElementToDofTable();
-
    /** @brief Reorder the scalar DOFs based on the element ordering.
 
        The new ordering is constructed as follows: 1) loop over all elements as
diff --git a/fem/integ/bilininteg_convection_ea.cpp b/fem/integ/bilininteg_convection_ea.cpp
index b2dba388a..08422ce86 100644
--- a/fem/integ/bilininteg_convection_ea.cpp
+++ b/fem/integ/bilininteg_convection_ea.cpp
@@ -22,7 +22,6 @@ static void EAConvectionAssemble1D(const int NE,
                                    const Array<double> &g,
                                    const Vector &padata,
                                    Vector &eadata,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -55,14 +54,7 @@ static void EAConvectionAssemble1D(const int NE,
             {
                val += r_Bj[k1] * D(k1, e) * r_Gi[k1];
             }
-            if (add)
-            {
-               A(i1, j1, e) += val;
-            }
-            else
-            {
-               A(i1, j1, e) = val;
-            }
+            A(i1, j1, e) += val;
          }
       }
    });
@@ -74,7 +66,6 @@ static void EAConvectionAssemble2D(const int NE,
                                    const Array<double> &g,
                                    const Vector &padata,
                                    Vector &eadata,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -130,14 +121,7 @@ static void EAConvectionAssemble2D(const int NE,
                                * r_B[k1][j1]* r_B[k2][j2];
                      }
                   }
-                  if (add)
-                  {
-                     A(i1, i2, j1, j2, e) += val;
-                  }
-                  else
-                  {
-                     A(i1, i2, j1, j2, e) = val;
-                  }
+                  A(i1, i2, j1, j2, e) += val;
                }
             }
          }
@@ -151,7 +135,6 @@ static void EAConvectionAssemble3D(const int NE,
                                    const Array<double> &g,
                                    const Vector &padata,
                                    Vector &eadata,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -208,14 +191,7 @@ static void EAConvectionAssemble3D(const int NE,
                               }
                            }
                         }
-                        if (add)
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) += val;
-                        }
-                        else
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) = val;
-                        }
+                        A(i1, i2, i3, j1, j2, j3, e) += val;
                      }
                   }
                }
@@ -226,8 +202,7 @@ static void EAConvectionAssemble3D(const int NE,
 }
 
 void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                      Vector &ea_data,
-                                      const bool add)
+                                      Vector &ea_data)
 {
    AssemblePA(fes);
    ne = fes.GetMesh()->GetNE();
@@ -237,15 +212,15 @@ void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAConvectionAssemble1D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EAConvectionAssemble1D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EAConvectionAssemble1D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EAConvectionAssemble1D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EAConvectionAssemble1D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EAConvectionAssemble1D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EAConvectionAssemble1D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EAConvectionAssemble1D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EAConvectionAssemble1D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EAConvectionAssemble1D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EAConvectionAssemble1D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EAConvectionAssemble1D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EAConvectionAssemble1D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EAConvectionAssemble1D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EAConvectionAssemble1D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EAConvectionAssemble1D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EAConvectionAssemble1D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EAConvectionAssemble1D(ne,B,G,pa_data,ea_data,
                                                      dofs1D,quad1D);
       }
    }
@@ -253,15 +228,15 @@ void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAConvectionAssemble2D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EAConvectionAssemble2D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EAConvectionAssemble2D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EAConvectionAssemble2D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EAConvectionAssemble2D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EAConvectionAssemble2D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EAConvectionAssemble2D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EAConvectionAssemble2D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EAConvectionAssemble2D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EAConvectionAssemble2D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EAConvectionAssemble2D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EAConvectionAssemble2D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EAConvectionAssemble2D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EAConvectionAssemble2D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EAConvectionAssemble2D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EAConvectionAssemble2D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EAConvectionAssemble2D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EAConvectionAssemble2D(ne,B,G,pa_data,ea_data,
                                                      dofs1D,quad1D);
       }
    }
@@ -269,14 +244,14 @@ void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EAConvectionAssemble3D<2,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x34: return EAConvectionAssemble3D<3,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x45: return EAConvectionAssemble3D<4,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x56: return EAConvectionAssemble3D<5,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x67: return EAConvectionAssemble3D<6,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x78: return EAConvectionAssemble3D<7,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x89: return EAConvectionAssemble3D<8,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EAConvectionAssemble3D(ne,B,G,pa_data,ea_data,add,
+         case 0x23: return EAConvectionAssemble3D<2,3>(ne,B,G,pa_data,ea_data);
+         case 0x34: return EAConvectionAssemble3D<3,4>(ne,B,G,pa_data,ea_data);
+         case 0x45: return EAConvectionAssemble3D<4,5>(ne,B,G,pa_data,ea_data);
+         case 0x56: return EAConvectionAssemble3D<5,6>(ne,B,G,pa_data,ea_data);
+         case 0x67: return EAConvectionAssemble3D<6,7>(ne,B,G,pa_data,ea_data);
+         case 0x78: return EAConvectionAssemble3D<7,8>(ne,B,G,pa_data,ea_data);
+         case 0x89: return EAConvectionAssemble3D<8,9>(ne,B,G,pa_data,ea_data);
+         default:   return EAConvectionAssemble3D(ne,B,G,pa_data,ea_data,
                                                      dofs1D,quad1D);
       }
    }
diff --git a/fem/integ/bilininteg_convection_pa.cpp b/fem/integ/bilininteg_convection_pa.cpp
index 7bfd65059..25928f002 100644
--- a/fem/integ/bilininteg_convection_pa.cpp
+++ b/fem/integ/bilininteg_convection_pa.cpp
@@ -112,26 +112,6 @@ static void PAConvectionSetup3D(const int NQ,
    });
 }
 
-static void PAConvectionSetup(const int dim,
-                              const int NQ,
-                              const int NE,
-                              const Array<double> &W,
-                              const Vector &J,
-                              const Vector &coeff,
-                              const double alpha,
-                              Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PAConvectionSetup"); }
-   if (dim == 2)
-   {
-      PAConvectionSetup2D(NQ, NE, W, J, coeff, alpha, op);
-   }
-   if (dim == 3)
-   {
-      PAConvectionSetup3D(NQ, NE, W, J, coeff, alpha, op);
-   }
-}
-
 void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
@@ -170,8 +150,20 @@ void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    QuadratureSpace qs(*mesh, *ir);
    CoefficientVector vel(*Q, qs, CoefficientStorage::COMPRESSED);
 
-   PAConvectionSetup(dim, nq, ne, ir->GetWeights(), geom->J,
-                     vel, alpha, pa_data);
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in ConvectionIntegrator::AssemblePA");
+   }
+   else if (dim == 2)
+   {
+      PAConvectionSetup2D(nq, ne, ir->GetWeights(), geom->J,
+                          vel, alpha, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PAConvectionSetup3D(nq, ne, ir->GetWeights(), geom->J,
+                          vel, alpha, pa_data);
+   }
 }
 
 void ConvectionIntegrator::AssembleDiagonalPA(Vector &diag)
@@ -188,17 +180,17 @@ void ConvectionIntegrator::AssembleDiagonalPA(Vector &diag)
 }
 
 // PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApply2D(const int ne,
-                         const Array<double> &b,
-                         const Array<double> &g,
-                         const Array<double> &bt,
-                         const Array<double> &gt,
-                         const Vector &op_,
-                         const Vector &x_,
-                         Vector &y_,
-                         const int d1d = 0,
-                         const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApply2D(const int ne,
+                                const Array<double> &b,
+                                const Array<double> &g,
+                                const Array<double> &bt,
+                                const Array<double> &gt,
+                                const Vector &op_,
+                                const Vector &x_,
+                                Vector &y_,
+                                const int d1d = 0,
+                                const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -307,17 +299,17 @@ void PAConvectionApply2D(const int ne,
 }
 
 // Optimized PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPAConvectionApply2D(const int ne,
-                             const Array<double> &b,
-                             const Array<double> &g,
-                             const Array<double> &bt,
-                             const Array<double> &gt,
-                             const Vector &op_,
-                             const Vector &x_,
-                             Vector &y_,
-                             const int d1d = 0,
-                             const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPAConvectionApply2D(const int ne,
+                                    const Array<double> &b,
+                                    const Array<double> &g,
+                                    const Array<double> &bt,
+                                    const Array<double> &gt,
+                                    const Vector &op_,
+                                    const Vector &x_,
+                                    Vector &y_,
+                                    const int d1d = 0,
+                                    const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -435,17 +427,17 @@ void SmemPAConvectionApply2D(const int ne,
 }
 
 // PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApply3D(const int ne,
-                         const Array<double> &b,
-                         const Array<double> &g,
-                         const Array<double> &bt,
-                         const Array<double> &gt,
-                         const Vector &op_,
-                         const Vector &x_,
-                         Vector &y_,
-                         const int d1d = 0,
-                         const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApply3D(const int ne,
+                                const Array<double> &b,
+                                const Array<double> &g,
+                                const Array<double> &bt,
+                                const Array<double> &gt,
+                                const Vector &op_,
+                                const Vector &x_,
+                                Vector &y_,
+                                const int d1d = 0,
+                                const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -616,17 +608,17 @@ void PAConvectionApply3D(const int ne,
 }
 
 // Optimized PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void SmemPAConvectionApply3D(const int ne,
-                             const Array<double> &b,
-                             const Array<double> &g,
-                             const Array<double> &bt,
-                             const Array<double> &gt,
-                             const Vector &op_,
-                             const Vector &x_,
-                             Vector &y_,
-                             const int d1d = 0,
-                             const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void SmemPAConvectionApply3D(const int ne,
+                                    const Array<double> &b,
+                                    const Array<double> &g,
+                                    const Array<double> &bt,
+                                    const Array<double> &gt,
+                                    const Vector &op_,
+                                    const Vector &x_,
+                                    Vector &y_,
+                                    const int d1d = 0,
+                                    const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -820,17 +812,17 @@ void SmemPAConvectionApply3D(const int ne,
 }
 
 // PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApplyT2D(const int ne,
-                          const Array<double> &b,
-                          const Array<double> &g,
-                          const Array<double> &bt,
-                          const Array<double> &gt,
-                          const Vector &op_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApplyT2D(const int ne,
+                                 const Array<double> &b,
+                                 const Array<double> &g,
+                                 const Array<double> &bt,
+                                 const Array<double> &gt,
+                                 const Vector &op_,
+                                 const Vector &x_,
+                                 Vector &y_,
+                                 const int d1d = 0,
+                                 const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -935,17 +927,17 @@ void PAConvectionApplyT2D(const int ne,
 }
 
 // Optimized PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPAConvectionApplyT2D(const int ne,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &op_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPAConvectionApplyT2D(const int ne,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &op_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     const int d1d = 0,
+                                     const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -1058,17 +1050,17 @@ void SmemPAConvectionApplyT2D(const int ne,
 }
 
 // PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApplyT3D(const int ne,
-                          const Array<double> &b,
-                          const Array<double> &g,
-                          const Array<double> &bt,
-                          const Array<double> &gt,
-                          const Vector &op_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApplyT3D(const int ne,
+                                 const Array<double> &b,
+                                 const Array<double> &g,
+                                 const Array<double> &bt,
+                                 const Array<double> &gt,
+                                 const Vector &op_,
+                                 const Vector &x_,
+                                 Vector &y_,
+                                 const int d1d = 0,
+                                 const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -1234,17 +1226,17 @@ void PAConvectionApplyT3D(const int ne,
 }
 
 // Optimized PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void SmemPAConvectionApplyT3D(const int ne,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &op_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void SmemPAConvectionApplyT3D(const int ne,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &op_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     const int d1d = 0,
+                                     const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -1549,7 +1541,7 @@ void ConvectionIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      MFEM_ABORT("AddMultPA not yet implemented with libCEED for"
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
                  " ConvectionIntegrator.");
    }
    else
diff --git a/fem/integ/bilininteg_dgtrace_ea.cpp b/fem/integ/bilininteg_dgtrace_ea.cpp
index 695820489..602c266ab 100644
--- a/fem/integ/bilininteg_dgtrace_ea.cpp
+++ b/fem/integ/bilininteg_dgtrace_ea.cpp
@@ -20,8 +20,7 @@ static void EADGTraceAssemble1DInt(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
                                    Vector &eadata_int,
-                                   Vector &eadata_ext,
-                                   const bool add)
+                                   Vector &eadata_ext)
 {
    auto D = Reshape(padata.Read(), 2, 2, NF);
    auto A_int = Reshape(eadata_int.ReadWrite(), 2, NF);
@@ -33,41 +32,23 @@ static void EADGTraceAssemble1DInt(const int NF,
       val_ext10 = D(1, 0, f);
       val_ext01 = D(0, 1, f);
       val_int1  = D(1, 1, f);
-      if (add)
-      {
-         A_int(0, f) += val_int0;
-         A_int(1, f) += val_int1;
-         A_ext(0, f) += val_ext01;
-         A_ext(1, f) += val_ext10;
-      }
-      else
-      {
-         A_int(0, f) = val_int0;
-         A_int(1, f) = val_int1;
-         A_ext(0, f) = val_ext01;
-         A_ext(1, f) = val_ext10;
-      }
+      A_int(0, f) += val_int0;
+      A_int(1, f) += val_int1;
+      A_ext(0, f) += val_ext01;
+      A_ext(1, f) += val_ext10;
    });
 }
 
 static void EADGTraceAssemble1DBdr(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
-                                   Vector &eadata_bdr,
-                                   const bool add)
+                                   Vector &eadata_bdr)
 {
    auto D = Reshape(padata.Read(), 2, 2, NF);
    auto A_bdr = Reshape(eadata_bdr.ReadWrite(), NF);
    mfem::forall(NF, [=] MFEM_HOST_DEVICE (int f)
    {
-      if (add)
-      {
-         A_bdr(f) += D(0, 0, f);
-      }
-      else
-      {
-         A_bdr(f) = D(0, 0, f);
-      }
+      A_bdr(f) += D(0, 0, f);
    });
 }
 
@@ -77,7 +58,6 @@ static void EADGTraceAssemble2DInt(const int NF,
                                    const Vector &padata,
                                    Vector &eadata_int,
                                    Vector &eadata_ext,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -108,20 +88,10 @@ static void EADGTraceAssemble2DInt(const int NF,
                val_ext10 += B(k1,i1) * B(k1,j1) * D(k1, 1, 0, f);
                val_int1  += B(k1,i1) * B(k1,j1) * D(k1, 1, 1, f);
             }
-            if (add)
-            {
-               A_int(i1, j1, 0, f) += val_int0;
-               A_int(i1, j1, 1, f) += val_int1;
-               A_ext(i1, j1, 0, f) += val_ext01;
-               A_ext(i1, j1, 1, f) += val_ext10;
-            }
-            else
-            {
-               A_int(i1, j1, 0, f) = val_int0;
-               A_int(i1, j1, 1, f) = val_int1;
-               A_ext(i1, j1, 0, f) = val_ext01;
-               A_ext(i1, j1, 1, f) = val_ext10;
-            }
+            A_int(i1, j1, 0, f) += val_int0;
+            A_int(i1, j1, 1, f) += val_int1;
+            A_ext(i1, j1, 0, f) += val_ext01;
+            A_ext(i1, j1, 1, f) += val_ext10;
          }
       }
    });
@@ -132,7 +102,6 @@ static void EADGTraceAssemble2DBdr(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
                                    Vector &eadata_bdr,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -156,14 +125,7 @@ static void EADGTraceAssemble2DBdr(const int NF,
             {
                val_bdr  += B(k1,i1) * B(k1,j1) * D(k1, 0, 0, f);
             }
-            if (add)
-            {
-               A_bdr(i1, j1, f) += val_bdr;
-            }
-            else
-            {
-               A_bdr(i1, j1, f) = val_bdr;
-            }
+            A_bdr(i1, j1, f) += val_bdr;
          }
       }
    });
@@ -175,7 +137,6 @@ static void EADGTraceAssemble3DInt(const int NF,
                                    const Vector &padata,
                                    Vector &eadata_int,
                                    Vector &eadata_ext,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -246,20 +207,10 @@ static void EADGTraceAssemble3DInt(const int NF,
                                     * s_D[k1][k2][1][0];
                      }
                   }
-                  if (add)
-                  {
-                     A_int(i1, i2, j1, j2, 0, f) += val_int0;
-                     A_int(i1, i2, j1, j2, 1, f) += val_int1;
-                     A_ext(i1, i2, j1, j2, 0, f) += val_ext01;
-                     A_ext(i1, i2, j1, j2, 1, f) += val_ext10;
-                  }
-                  else
-                  {
-                     A_int(i1, i2, j1, j2, 0, f) = val_int0;
-                     A_int(i1, i2, j1, j2, 1, f) = val_int1;
-                     A_ext(i1, i2, j1, j2, 0, f) = val_ext01;
-                     A_ext(i1, i2, j1, j2, 1, f) = val_ext10;
-                  }
+                  A_int(i1, i2, j1, j2, 0, f) += val_int0;
+                  A_int(i1, i2, j1, j2, 1, f) += val_int1;
+                  A_ext(i1, i2, j1, j2, 0, f) += val_ext01;
+                  A_ext(i1, i2, j1, j2, 1, f) += val_ext10;
                }
             }
          }
@@ -272,7 +223,6 @@ static void EADGTraceAssemble3DBdr(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
                                    Vector &eadata_bdr,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -330,14 +280,7 @@ static void EADGTraceAssemble3DBdr(const int NF,
                                    * s_D[k1][k2][0][0];
                      }
                   }
-                  if (add)
-                  {
-                     A_bdr(i1, i2, j1, j2, f) += val_bdr;
-                  }
-                  else
-                  {
-                     A_bdr(i1, i2, j1, j2, f) = val_bdr;
-                  }
+                  A_bdr(i1, i2, j1, j2, f) += val_bdr;
                }
             }
          }
@@ -347,8 +290,7 @@ static void EADGTraceAssemble3DBdr(const int NF,
 
 void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
                                                 Vector &ea_data_int,
-                                                Vector &ea_data_ext,
-                                                const bool add)
+                                                Vector &ea_data_ext)
 {
    SetupPA(fes, FaceType::Interior);
    nf = fes.GetNFbyType(FaceType::Interior);
@@ -356,7 +298,7 @@ void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
    const Array<double> &B = maps->B;
    if (dim == 1)
    {
-      return EADGTraceAssemble1DInt(nf,B,pa_data,ea_data_int,ea_data_ext,add);
+      return EADGTraceAssemble1DInt(nf,B,pa_data,ea_data_int,ea_data_ext);
    }
    else if (dim == 2)
    {
@@ -364,31 +306,31 @@ void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
       {
          case 0x22:
             return EADGTraceAssemble2DInt<2,2>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x33:
             return EADGTraceAssemble2DInt<3,3>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x44:
             return EADGTraceAssemble2DInt<4,4>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x55:
             return EADGTraceAssemble2DInt<5,5>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x66:
             return EADGTraceAssemble2DInt<6,6>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x77:
             return EADGTraceAssemble2DInt<7,7>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x88:
             return EADGTraceAssemble2DInt<8,8>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x99:
             return EADGTraceAssemble2DInt<9,9>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          default:
             return EADGTraceAssemble2DInt(nf,B,pa_data,ea_data_int,
-                                          ea_data_ext,add,dofs1D,quad1D);
+                                          ea_data_ext,dofs1D,quad1D);
       }
    }
    else if (dim == 3)
@@ -397,36 +339,35 @@ void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
       {
          case 0x23:
             return EADGTraceAssemble3DInt<2,3>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x34:
             return EADGTraceAssemble3DInt<3,4>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x45:
             return EADGTraceAssemble3DInt<4,5>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x56:
             return EADGTraceAssemble3DInt<5,6>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x67:
             return EADGTraceAssemble3DInt<6,7>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x78:
             return EADGTraceAssemble3DInt<7,8>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x89:
             return EADGTraceAssemble3DInt<8,9>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          default:
             return EADGTraceAssemble3DInt(nf,B,pa_data,ea_data_int,
-                                          ea_data_ext,add,dofs1D,quad1D);
+                                          ea_data_ext,dofs1D,quad1D);
       }
    }
    MFEM_ABORT("Unknown kernel.");
 }
 
 void DGTraceIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace& fes,
-                                                Vector &ea_data_bdr,
-                                                const bool add)
+                                                Vector &ea_data_bdr)
 {
    SetupPA(fes, FaceType::Boundary);
    nf = fes.GetNFbyType(FaceType::Boundary);
@@ -434,37 +375,37 @@ void DGTraceIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace& fes,
    const Array<double> &B = maps->B;
    if (dim == 1)
    {
-      return EADGTraceAssemble1DBdr(nf,B,pa_data,ea_data_bdr,add);
+      return EADGTraceAssemble1DBdr(nf,B,pa_data,ea_data_bdr);
    }
    else if (dim == 2)
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EADGTraceAssemble2DBdr<2,2>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x33: return EADGTraceAssemble2DBdr<3,3>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x44: return EADGTraceAssemble2DBdr<4,4>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x55: return EADGTraceAssemble2DBdr<5,5>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x66: return EADGTraceAssemble2DBdr<6,6>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x77: return EADGTraceAssemble2DBdr<7,7>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x88: return EADGTraceAssemble2DBdr<8,8>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x99: return EADGTraceAssemble2DBdr<9,9>(nf,B,pa_data,ea_data_bdr,add);
+         case 0x22: return EADGTraceAssemble2DBdr<2,2>(nf,B,pa_data,ea_data_bdr);
+         case 0x33: return EADGTraceAssemble2DBdr<3,3>(nf,B,pa_data,ea_data_bdr);
+         case 0x44: return EADGTraceAssemble2DBdr<4,4>(nf,B,pa_data,ea_data_bdr);
+         case 0x55: return EADGTraceAssemble2DBdr<5,5>(nf,B,pa_data,ea_data_bdr);
+         case 0x66: return EADGTraceAssemble2DBdr<6,6>(nf,B,pa_data,ea_data_bdr);
+         case 0x77: return EADGTraceAssemble2DBdr<7,7>(nf,B,pa_data,ea_data_bdr);
+         case 0x88: return EADGTraceAssemble2DBdr<8,8>(nf,B,pa_data,ea_data_bdr);
+         case 0x99: return EADGTraceAssemble2DBdr<9,9>(nf,B,pa_data,ea_data_bdr);
          default:
-            return EADGTraceAssemble2DBdr(nf,B,pa_data,ea_data_bdr,add,dofs1D,quad1D);
+            return EADGTraceAssemble2DBdr(nf,B,pa_data,ea_data_bdr,dofs1D,quad1D);
       }
    }
    else if (dim == 3)
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EADGTraceAssemble3DBdr<2,3>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x34: return EADGTraceAssemble3DBdr<3,4>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x45: return EADGTraceAssemble3DBdr<4,5>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x56: return EADGTraceAssemble3DBdr<5,6>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x67: return EADGTraceAssemble3DBdr<6,7>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x78: return EADGTraceAssemble3DBdr<7,8>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x89: return EADGTraceAssemble3DBdr<8,9>(nf,B,pa_data,ea_data_bdr,add);
+         case 0x23: return EADGTraceAssemble3DBdr<2,3>(nf,B,pa_data,ea_data_bdr);
+         case 0x34: return EADGTraceAssemble3DBdr<3,4>(nf,B,pa_data,ea_data_bdr);
+         case 0x45: return EADGTraceAssemble3DBdr<4,5>(nf,B,pa_data,ea_data_bdr);
+         case 0x56: return EADGTraceAssemble3DBdr<5,6>(nf,B,pa_data,ea_data_bdr);
+         case 0x67: return EADGTraceAssemble3DBdr<6,7>(nf,B,pa_data,ea_data_bdr);
+         case 0x78: return EADGTraceAssemble3DBdr<7,8>(nf,B,pa_data,ea_data_bdr);
+         case 0x89: return EADGTraceAssemble3DBdr<8,9>(nf,B,pa_data,ea_data_bdr);
          default:
-            return EADGTraceAssemble3DBdr(nf,B,pa_data,ea_data_bdr,add,dofs1D,quad1D);
+            return EADGTraceAssemble3DBdr(nf,B,pa_data,ea_data_bdr,dofs1D,quad1D);
       }
    }
    MFEM_ABORT("Unknown kernel.");
diff --git a/fem/integ/bilininteg_dgtrace_pa.cpp b/fem/integ/bilininteg_dgtrace_pa.cpp
index 17dbc3994..f4b8d837c 100644
--- a/fem/integ/bilininteg_dgtrace_pa.cpp
+++ b/fem/integ/bilininteg_dgtrace_pa.cpp
@@ -110,30 +110,6 @@ static void PADGTraceSetup3D(const int Q1D,
    });
 }
 
-static void PADGTraceSetup(const int dim,
-                           const int D1D,
-                           const int Q1D,
-                           const int NF,
-                           const Array<double> &W,
-                           const Vector &det,
-                           const Vector &nor,
-                           const Vector &rho,
-                           const Vector &u,
-                           const double alpha,
-                           const double beta,
-                           Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PADGTraceSetup"); }
-   if (dim == 2)
-   {
-      PADGTraceSetup2D(Q1D, NF, W, det, nor, rho, u, alpha, beta, op);
-   }
-   if (dim == 3)
-   {
-      PADGTraceSetup3D(Q1D, NF, W, det, nor, rho, u, alpha, beta, op);
-   }
-}
-
 void DGTraceIntegrator::SetupPA(const FiniteElementSpace &fes, FaceType type)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
@@ -229,9 +205,21 @@ void DGTraceIntegrator::SetupPA(const FiniteElementSpace &fes, FaceType type)
       }
       MFEM_VERIFY(f_ind==nf, "Incorrect number of faces.");
    }
-   PADGTraceSetup(dim, dofs1D, quad1D, nf, ir->GetWeights(),
-                  geom->detJ, geom->normal, r, vel,
-                  alpha, beta, pa_data);
+
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in DGTraceIntegrator::SetupPA");
+   }
+   else if (dim == 2)
+   {
+      PADGTraceSetup2D(quad1D, nf, ir->GetWeights(), geom->detJ, geom->normal,
+                       r, vel, alpha, beta, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PADGTraceSetup3D(quad1D, nf, ir->GetWeights(), geom->detJ, geom->normal,
+                       r, vel, alpha, beta, pa_data);
+   }
 }
 
 void DGTraceIntegrator::AssemblePAInteriorFaces(const FiniteElementSpace& fes)
@@ -245,15 +233,15 @@ void DGTraceIntegrator::AssemblePABoundaryFaces(const FiniteElementSpace& fes)
 }
 
 // PA DGTrace Apply 2D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApply2D(const int NF,
-                      const Array<double> &b,
-                      const Array<double> &bt,
-                      const Vector &op_,
-                      const Vector &x_,
-                      Vector &y_,
-                      const int d1d = 0,
-                      const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApply2D(const int NF,
+                             const Array<double> &b,
+                             const Array<double> &bt,
+                             const Vector &op_,
+                             const Vector &x_,
+                             Vector &y_,
+                             const int d1d = 0,
+                             const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -336,15 +324,15 @@ void PADGTraceApply2D(const int NF,
 }
 
 // PA DGTrace Apply 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApply3D(const int NF,
-                      const Array<double> &b,
-                      const Array<double> &bt,
-                      const Vector &op_,
-                      const Vector &x_,
-                      Vector &y_,
-                      const int d1d = 0,
-                      const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApply3D(const int NF,
+                             const Array<double> &b,
+                             const Array<double> &bt,
+                             const Vector &op_,
+                             const Vector &x_,
+                             Vector &y_,
+                             const int d1d = 0,
+                             const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -481,15 +469,15 @@ void PADGTraceApply3D(const int NF,
 }
 
 // Optimized PA DGTrace Apply 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPADGTraceApply3D(const int NF,
-                          const Array<double> &b,
-                          const Array<double> &bt,
-                          const Vector &op_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPADGTraceApply3D(const int NF,
+                                 const Array<double> &b,
+                                 const Array<double> &bt,
+                                 const Vector &op_,
+                                 const Vector &x_,
+                                 Vector &y_,
+                                 const int d1d = 0,
+                                 const int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -646,15 +634,15 @@ static void PADGTraceApply(const int dim,
 }
 
 // PA DGTrace Apply 2D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApplyTranspose2D(const int NF,
-                               const Array<double> &b,
-                               const Array<double> &bt,
-                               const Vector &op_,
-                               const Vector &x_,
-                               Vector &y_,
-                               const int d1d = 0,
-                               const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApplyTranspose2D(const int NF,
+                                      const Array<double> &b,
+                                      const Array<double> &bt,
+                                      const Vector &op_,
+                                      const Vector &x_,
+                                      Vector &y_,
+                                      const int d1d = 0,
+                                      const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -742,15 +730,15 @@ void PADGTraceApplyTranspose2D(const int NF,
 }
 
 // PA DGTrace Apply Transpose 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApplyTranspose3D(const int NF,
-                               const Array<double> &b,
-                               const Array<double> &bt,
-                               const Vector &op_,
-                               const Vector &x_,
-                               Vector &y_,
-                               const int d1d = 0,
-                               const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApplyTranspose3D(const int NF,
+                                      const Array<double> &b,
+                                      const Array<double> &bt,
+                                      const Vector &op_,
+                                      const Vector &x_,
+                                      Vector &y_,
+                                      const int d1d = 0,
+                                      const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -898,15 +886,15 @@ void PADGTraceApplyTranspose3D(const int NF,
 }
 
 // Optimized PA DGTrace Apply Transpose 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPADGTraceApplyTranspose3D(const int NF,
-                                   const Array<double> &b,
-                                   const Array<double> &bt,
-                                   const Vector &op_,
-                                   const Vector &x_,
-                                   Vector &y_,
-                                   const int d1d = 0,
-                                   const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPADGTraceApplyTranspose3D(const int NF,
+                                          const Array<double> &b,
+                                          const Array<double> &bt,
+                                          const Vector &op_,
+                                          const Vector &x_,
+                                          Vector &y_,
+                                          const int d1d = 0,
+                                          const int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -1075,7 +1063,6 @@ static void PADGTraceApplyTranspose(const int dim,
    MFEM_ABORT("Unknown kernel.");
 }
 
-// PA DGTraceIntegrator Apply kernel
 void DGTraceIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    PADGTraceApply(dim, dofs1D, quad1D, nf,
diff --git a/fem/integ/bilininteg_diffusion_ea.cpp b/fem/integ/bilininteg_diffusion_ea.cpp
index 0e59b33f9..aa36233c4 100644
--- a/fem/integ/bilininteg_diffusion_ea.cpp
+++ b/fem/integ/bilininteg_diffusion_ea.cpp
@@ -22,7 +22,6 @@ static void EADiffusionAssemble1D(const int NE,
                                   const Array<double> &g,
                                   const Vector &padata,
                                   Vector &eadata,
-                                  const bool add,
                                   const int d1d = 0,
                                   const int q1d = 0)
 {
@@ -54,14 +53,7 @@ static void EADiffusionAssemble1D(const int NE,
             {
                val += r_Gj[k1] * D(k1, e) * r_Gi[k1];
             }
-            if (add)
-            {
-               A(i1, j1, e) += val;
-            }
-            else
-            {
-               A(i1, j1, e) = val;
-            }
+            A(i1, j1, e) += val;
          }
       }
    });
@@ -73,7 +65,6 @@ static void EADiffusionAssemble2D(const int NE,
                                   const Array<double> &g,
                                   const Vector &padata,
                                   Vector &eadata,
-                                  const bool add,
                                   const int d1d = 0,
                                   const int q1d = 0)
 {
@@ -129,14 +120,7 @@ static void EADiffusionAssemble2D(const int NE,
                                + gbi * D11 * gbj;
                      }
                   }
-                  if (add)
-                  {
-                     A(i1, i2, j1, j2, e) += val;
-                  }
-                  else
-                  {
-                     A(i1, i2, j1, j2, e) = val;
-                  }
+                  A(i1, i2, j1, j2, e) += val;
                }
             }
          }
@@ -150,7 +134,6 @@ static void EADiffusionAssemble3D(const int NE,
                                   const Array<double> &g,
                                   const Vector &padata,
                                   Vector &eadata,
-                                  const bool add,
                                   const int d1d = 0,
                                   const int q1d = 0)
 {
@@ -225,14 +208,7 @@ static void EADiffusionAssemble3D(const int NE,
                               }
                            }
                         }
-                        if (add)
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) += val;
-                        }
-                        else
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) = val;
-                        }
+                        A(i1, i2, i3, j1, j2, j3, e) += val;
                      }
                   }
                }
@@ -243,8 +219,7 @@ static void EADiffusionAssemble3D(const int NE,
 }
 
 void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                     Vector &ea_data,
-                                     const bool add)
+                                     Vector &ea_data)
 {
    AssemblePA(fes);
    ne = fes.GetMesh()->GetNE();
@@ -254,15 +229,15 @@ void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EADiffusionAssemble1D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EADiffusionAssemble1D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EADiffusionAssemble1D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EADiffusionAssemble1D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EADiffusionAssemble1D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EADiffusionAssemble1D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EADiffusionAssemble1D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EADiffusionAssemble1D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EADiffusionAssemble1D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EADiffusionAssemble1D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EADiffusionAssemble1D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EADiffusionAssemble1D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EADiffusionAssemble1D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EADiffusionAssemble1D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EADiffusionAssemble1D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EADiffusionAssemble1D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EADiffusionAssemble1D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EADiffusionAssemble1D(ne,B,G,pa_data,ea_data,
                                                     dofs1D,quad1D);
       }
    }
@@ -270,15 +245,15 @@ void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EADiffusionAssemble2D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EADiffusionAssemble2D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EADiffusionAssemble2D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EADiffusionAssemble2D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EADiffusionAssemble2D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EADiffusionAssemble2D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EADiffusionAssemble2D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EADiffusionAssemble2D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EADiffusionAssemble2D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EADiffusionAssemble2D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EADiffusionAssemble2D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EADiffusionAssemble2D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EADiffusionAssemble2D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EADiffusionAssemble2D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EADiffusionAssemble2D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EADiffusionAssemble2D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EADiffusionAssemble2D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EADiffusionAssemble2D(ne,B,G,pa_data,ea_data,
                                                     dofs1D,quad1D);
       }
    }
@@ -286,14 +261,14 @@ void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EADiffusionAssemble3D<2,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x34: return EADiffusionAssemble3D<3,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x45: return EADiffusionAssemble3D<4,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x56: return EADiffusionAssemble3D<5,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x67: return EADiffusionAssemble3D<6,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x78: return EADiffusionAssemble3D<7,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x89: return EADiffusionAssemble3D<8,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EADiffusionAssemble3D(ne,B,G,pa_data,ea_data,add,
+         case 0x23: return EADiffusionAssemble3D<2,3>(ne,B,G,pa_data,ea_data);
+         case 0x34: return EADiffusionAssemble3D<3,4>(ne,B,G,pa_data,ea_data);
+         case 0x45: return EADiffusionAssemble3D<4,5>(ne,B,G,pa_data,ea_data);
+         case 0x56: return EADiffusionAssemble3D<5,6>(ne,B,G,pa_data,ea_data);
+         case 0x67: return EADiffusionAssemble3D<6,7>(ne,B,G,pa_data,ea_data);
+         case 0x78: return EADiffusionAssemble3D<7,8>(ne,B,G,pa_data,ea_data);
+         case 0x89: return EADiffusionAssemble3D<8,9>(ne,B,G,pa_data,ea_data);
+         default:   return EADiffusionAssemble3D(ne,B,G,pa_data,ea_data,
                                                     dofs1D,quad1D);
       }
    }
diff --git a/fem/integ/bilininteg_diffusion_mf.cpp b/fem/integ/bilininteg_diffusion_mf.cpp
index 449246a02..0896b8bf9 100644
--- a/fem/integ/bilininteg_diffusion_mf.cpp
+++ b/fem/integ/bilininteg_diffusion_mf.cpp
@@ -19,7 +19,6 @@ namespace mfem
 void DiffusionIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
diff --git a/fem/integ/bilininteg_diffusion_pa.cpp b/fem/integ/bilininteg_diffusion_pa.cpp
index f3ed5952c..a966c8520 100644
--- a/fem/integ/bilininteg_diffusion_pa.cpp
+++ b/fem/integ/bilininteg_diffusion_pa.cpp
@@ -23,7 +23,6 @@ void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
@@ -82,7 +81,6 @@ void DiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
    }
    else
    {
-      if (pa_data.Size()==0) { AssemblePA(*fespace); }
       internal::PADiffusionAssembleDiagonal(dim, dofs1D, quad1D, ne, symmetric,
                                             maps->B, maps->G, pa_data, diag);
    }
@@ -104,14 +102,22 @@ void DiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 
 void DiffusionIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
-   if (symmetric)
+   if (DeviceCanUseCeed())
    {
-      AddMultPA(x, y);
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " DiffusionIntegrator.");
    }
    else
    {
-      MFEM_ABORT("DiffusionIntegrator::AddMultTransposePA only implemented in "
-                 "the symmetric case.")
+      if (symmetric)
+      {
+         AddMultPA(x, y);
+      }
+      else
+      {
+         MFEM_ABORT("DiffusionIntegrator::AddMultTransposePA only implemented in "
+                    "the symmetric case.")
+      }
    }
 }
 
diff --git a/fem/integ/bilininteg_gradient_pa.cpp b/fem/integ/bilininteg_gradient_pa.cpp
index 7d6b8c5df..20ef4684d 100644
--- a/fem/integ/bilininteg_gradient_pa.cpp
+++ b/fem/integ/bilininteg_gradient_pa.cpp
@@ -158,27 +158,6 @@ static void PAGradientSetup3D(const int Q1D,
    });
 }
 
-static void PAGradientSetup(const int dim,
-                            const int TR_D1D,
-                            const int TE_D1D,
-                            const int Q1D,
-                            const int NE,
-                            const Array<double> &W,
-                            const Vector &J,
-                            const Vector &COEFF,
-                            Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PAGradientSetup"); }
-   if (dim == 2)
-   {
-      PAGradientSetup2D(Q1D, NE, W, J, COEFF, op);
-   }
-   if (dim == 3)
-   {
-      PAGradientSetup3D(Q1D, NE, W, J, COEFF, op);
-   }
-}
-
 void GradientIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                     const FiniteElementSpace &test_fes)
 {
@@ -209,8 +188,18 @@ void GradientIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    QuadratureSpace qs(*mesh, *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
 
-   PAGradientSetup(dim, trial_dofs1D, test_dofs1D, quad1D,
-                   ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in GradientIntegrator::AssemblePA");
+   }
+   else if (dim == 2)
+   {
+      PAGradientSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PAGradientSetup3D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
 }
 
 // PA Gradient Apply 2D kernel
@@ -787,40 +776,21 @@ static void SmemPAGradientApply3D(const int NE,
    });
 }
 
-static void PAGradientApply(const int dim,
-                            const int TR_D1D,
-                            const int TE_D1D,
-                            const int Q1D,
-                            const int NE,
-                            const Array<double> &B,
-                            const Array<double> &G,
-                            const Array<double> &Bt,
-                            const Vector &op,
-                            const Vector &x,
-                            Vector &y,
-                            bool transpose=false)
+void GradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-
    if (dim == 2)
    {
-      return PAGradientApply2D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
+      return PAGradientApply2D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                               pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    if (dim == 3)
    {
-      return PAGradientApply3D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
+      return PAGradientApply3D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                               pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    MFEM_ABORT("Unknown kernel.");
 }
 
-// PA Gradient Apply kernel
-void GradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   PAGradientApply(dim, trial_dofs1D, test_dofs1D, quad1D, ne,
-                   trial_maps->B, trial_maps->G, test_maps->Bt, pa_data, x, y,
-                   false);
-}
-
-// PA Gradient Apply kernel
 void GradientIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
    MFEM_ABORT("PA Gradient AddMultTransposePA not implemented.");
diff --git a/fem/integ/bilininteg_mass_ea.cpp b/fem/integ/bilininteg_mass_ea.cpp
index 4cafa68f3..315b9da8f 100644
--- a/fem/integ/bilininteg_mass_ea.cpp
+++ b/fem/integ/bilininteg_mass_ea.cpp
@@ -21,7 +21,6 @@ static void EAMassAssemble1D(const int NE,
                              const Array<double> &basis,
                              const Vector &padata,
                              Vector &eadata,
-                             const bool add,
                              const int d1d = 0,
                              const int q1d = 0)
 {
@@ -53,14 +52,7 @@ static void EAMassAssemble1D(const int NE,
             {
                val += r_Bi[k1] * r_Bj[k1] * D(k1, e);
             }
-            if (add)
-            {
-               M(i1, j1, e) += val;
-            }
-            else
-            {
-               M(i1, j1, e) = val;
-            }
+            M(i1, j1, e) += val;
          }
       }
    });
@@ -71,7 +63,6 @@ static void EAMassAssemble2D(const int NE,
                              const Array<double> &basis,
                              const Vector &padata,
                              Vector &eadata,
-                             const bool add,
                              const int d1d = 0,
                              const int q1d = 0)
 {
@@ -123,14 +114,7 @@ static void EAMassAssemble2D(const int NE,
                                * s_D[k1][k2];
                      }
                   }
-                  if (add)
-                  {
-                     M(i1, i2, j1, j2, e) += val;
-                  }
-                  else
-                  {
-                     M(i1, i2, j1, j2, e) = val;
-                  }
+                  M(i1, i2, j1, j2, e) += val;
                }
             }
          }
@@ -143,7 +127,6 @@ static void EAMassAssemble3D(const int NE,
                              const Array<double> &basis,
                              const Vector &padata,
                              Vector &eadata,
-                             const bool add,
                              const int d1d = 0,
                              const int q1d = 0)
 {
@@ -237,14 +220,7 @@ static void EAMassAssemble3D(const int NE,
                               }
                            }
                         }
-                        if (add)
-                        {
-                           M(i1, i2, i3, j1, j2, j3, e) += val;
-                        }
-                        else
-                        {
-                           M(i1, i2, i3, j1, j2, j3, e) = val;
-                        }
+                        M(i1, i2, i3, j1, j2, j3, e) += val;
                      }
                   }
                }
@@ -255,8 +231,7 @@ static void EAMassAssemble3D(const int NE,
 }
 
 void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                Vector &ea_data,
-                                const bool add)
+                                Vector &ea_data)
 {
    AssemblePA(fes);
    ne = fes.GetMesh()->GetNE();
@@ -265,15 +240,15 @@ void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAMassAssemble1D<2,2>(ne,B,pa_data,ea_data,add);
-         case 0x33: return EAMassAssemble1D<3,3>(ne,B,pa_data,ea_data,add);
-         case 0x44: return EAMassAssemble1D<4,4>(ne,B,pa_data,ea_data,add);
-         case 0x55: return EAMassAssemble1D<5,5>(ne,B,pa_data,ea_data,add);
-         case 0x66: return EAMassAssemble1D<6,6>(ne,B,pa_data,ea_data,add);
-         case 0x77: return EAMassAssemble1D<7,7>(ne,B,pa_data,ea_data,add);
-         case 0x88: return EAMassAssemble1D<8,8>(ne,B,pa_data,ea_data,add);
-         case 0x99: return EAMassAssemble1D<9,9>(ne,B,pa_data,ea_data,add);
-         default:   return EAMassAssemble1D(ne,B,pa_data,ea_data,add,
+         case 0x22: return EAMassAssemble1D<2,2>(ne,B,pa_data,ea_data);
+         case 0x33: return EAMassAssemble1D<3,3>(ne,B,pa_data,ea_data);
+         case 0x44: return EAMassAssemble1D<4,4>(ne,B,pa_data,ea_data);
+         case 0x55: return EAMassAssemble1D<5,5>(ne,B,pa_data,ea_data);
+         case 0x66: return EAMassAssemble1D<6,6>(ne,B,pa_data,ea_data);
+         case 0x77: return EAMassAssemble1D<7,7>(ne,B,pa_data,ea_data);
+         case 0x88: return EAMassAssemble1D<8,8>(ne,B,pa_data,ea_data);
+         case 0x99: return EAMassAssemble1D<9,9>(ne,B,pa_data,ea_data);
+         default:   return EAMassAssemble1D(ne,B,pa_data,ea_data,
                                                dofs1D,quad1D);
       }
    }
@@ -281,15 +256,15 @@ void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAMassAssemble2D<2,2>(ne,B,pa_data,ea_data,add);
-         case 0x33: return EAMassAssemble2D<3,3>(ne,B,pa_data,ea_data,add);
-         case 0x44: return EAMassAssemble2D<4,4>(ne,B,pa_data,ea_data,add);
-         case 0x55: return EAMassAssemble2D<5,5>(ne,B,pa_data,ea_data,add);
-         case 0x66: return EAMassAssemble2D<6,6>(ne,B,pa_data,ea_data,add);
-         case 0x77: return EAMassAssemble2D<7,7>(ne,B,pa_data,ea_data,add);
-         case 0x88: return EAMassAssemble2D<8,8>(ne,B,pa_data,ea_data,add);
-         case 0x99: return EAMassAssemble2D<9,9>(ne,B,pa_data,ea_data,add);
-         default:   return EAMassAssemble2D(ne,B,pa_data,ea_data,add,
+         case 0x22: return EAMassAssemble2D<2,2>(ne,B,pa_data,ea_data);
+         case 0x33: return EAMassAssemble2D<3,3>(ne,B,pa_data,ea_data);
+         case 0x44: return EAMassAssemble2D<4,4>(ne,B,pa_data,ea_data);
+         case 0x55: return EAMassAssemble2D<5,5>(ne,B,pa_data,ea_data);
+         case 0x66: return EAMassAssemble2D<6,6>(ne,B,pa_data,ea_data);
+         case 0x77: return EAMassAssemble2D<7,7>(ne,B,pa_data,ea_data);
+         case 0x88: return EAMassAssemble2D<8,8>(ne,B,pa_data,ea_data);
+         case 0x99: return EAMassAssemble2D<9,9>(ne,B,pa_data,ea_data);
+         default:   return EAMassAssemble2D(ne,B,pa_data,ea_data,
                                                dofs1D,quad1D);
       }
    }
@@ -297,14 +272,14 @@ void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EAMassAssemble3D<2,3>(ne,B,pa_data,ea_data,add);
-         case 0x34: return EAMassAssemble3D<3,4>(ne,B,pa_data,ea_data,add);
-         case 0x45: return EAMassAssemble3D<4,5>(ne,B,pa_data,ea_data,add);
-         case 0x56: return EAMassAssemble3D<5,6>(ne,B,pa_data,ea_data,add);
-         case 0x67: return EAMassAssemble3D<6,7>(ne,B,pa_data,ea_data,add);
-         case 0x78: return EAMassAssemble3D<7,8>(ne,B,pa_data,ea_data,add);
-         case 0x89: return EAMassAssemble3D<8,9>(ne,B,pa_data,ea_data,add);
-         default:   return EAMassAssemble3D(ne,B,pa_data,ea_data,add,
+         case 0x23: return EAMassAssemble3D<2,3>(ne,B,pa_data,ea_data);
+         case 0x34: return EAMassAssemble3D<3,4>(ne,B,pa_data,ea_data);
+         case 0x45: return EAMassAssemble3D<4,5>(ne,B,pa_data,ea_data);
+         case 0x56: return EAMassAssemble3D<5,6>(ne,B,pa_data,ea_data);
+         case 0x67: return EAMassAssemble3D<6,7>(ne,B,pa_data,ea_data);
+         case 0x78: return EAMassAssemble3D<7,8>(ne,B,pa_data,ea_data);
+         case 0x89: return EAMassAssemble3D<8,9>(ne,B,pa_data,ea_data);
+         default:   return EAMassAssemble3D(ne,B,pa_data,ea_data,
                                                dofs1D,quad1D);
       }
    }
diff --git a/fem/integ/bilininteg_mass_kernels.cpp b/fem/integ/bilininteg_mass_kernels.cpp
index 9d03bda3f..4f39c9ec8 100644
--- a/fem/integ/bilininteg_mass_kernels.cpp
+++ b/fem/integ/bilininteg_mass_kernels.cpp
@@ -17,13 +17,43 @@ namespace mfem
 namespace internal
 {
 
+// PA Mass Diagonal 1D kernel
+static void PAMassAssembleDiagonal1D(const int NE,
+                                     const Array<double> &b,
+                                     const Vector &d,
+                                     Vector &y,
+                                     const int D1D,
+                                     const int Q1D)
+{
+   MFEM_VERIFY(D1D <= MAX_D1D, "");
+   MFEM_VERIFY(Q1D <= MAX_Q1D, "");
+   auto B = Reshape(b.Read(), Q1D, D1D);
+   auto D = Reshape(d.Read(), Q1D, NE);
+   auto Y = Reshape(y.ReadWrite(), D1D, NE);
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      for (int dx = 0; dx < D1D; ++dx)
+      {
+         Y(dx, e) = 0.0;
+         for (int qx = 0; qx < Q1D; ++qx)
+         {
+            Y(dx, e) += B(qx, dx) * B(qx, dx) * D(qx, e);
+         }
+      }
+   });
+}
+
 void PAMassAssembleDiagonal(const int dim, const int D1D,
                             const int Q1D, const int NE,
                             const Array<double> &B,
                             const Vector &D,
                             Vector &Y)
 {
-   if (dim == 2)
+   if (dim == 1)
+   {
+      return PAMassAssembleDiagonal1D(NE,B,D,Y,D1D,Q1D);
+   }
+   else if (dim == 2)
    {
       switch ((D1D << 4 ) | Q1D)
       {
@@ -149,6 +179,74 @@ void OccaPAMassApply3D(const int D1D,
 }
 #endif // MFEM_USE_OCCA
 
+MFEM_HOST_DEVICE inline
+void PAMassApply1D_Element(const int e,
+                           const int NE,
+                           const double *b_,
+                           const double *bt_,
+                           const double *d_,
+                           const double *x_,
+                           double *y_,
+                           const int d1d = 0,
+                           const int q1d = 0)
+{
+   const int D1D = d1d;
+   const int Q1D = q1d;
+   auto B = ConstDeviceMatrix(b_, Q1D, D1D);
+   auto Bt = ConstDeviceMatrix(bt_, D1D, Q1D);
+   auto D = ConstDeviceMatrix(d_, Q1D, NE);
+   auto X = ConstDeviceMatrix(x_, D1D, NE);
+   auto Y = DeviceMatrix(y_, D1D, NE);
+
+   constexpr int max_Q1D = MAX_Q1D;
+   double XQ[max_Q1D];
+   for (int qx = 0; qx < Q1D; ++qx)
+   {
+      XQ[qx] = 0.0;
+   }
+   for (int dx = 0; dx < D1D; ++dx)
+   {
+      const double s = X(dx,e);
+      for (int qx = 0; qx < Q1D; ++qx)
+      {
+         XQ[qx] += B(qx,dx)*s;
+      }
+   }
+   for (int qx = 0; qx < Q1D; ++qx)
+   {
+      const double q = XQ[qx]*D(qx,e);
+      for (int dx = 0; dx < D1D; ++dx)
+      {
+         Y(dx,e) += Bt(dx,qx) * q;
+      }
+   }
+}
+
+// PA Mass Apply 1D kernel
+static void PAMassApply1D(const int NE,
+                          const Array<double> &b_,
+                          const Array<double> &bt_,
+                          const Vector &d_,
+                          const Vector &x_,
+                          Vector &y_,
+                          const int d1d = 0,
+                          const int q1d = 0)
+{
+   MFEM_VERIFY(d1d <= MAX_D1D, "");
+   MFEM_VERIFY(q1d <= MAX_Q1D, "");
+
+   const auto B = b_.Read();
+   const auto Bt = bt_.Read();
+   const auto D = d_.Read();
+   const auto X = x_.Read();
+   auto Y = y_.ReadWrite();
+
+   mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
+   {
+      internal::PAMassApply1D_Element(e, NE, B, Bt, D, X, Y, d1d, q1d);
+   });
+}
+
 void PAMassApply(const int dim,
                  const int D1D,
                  const int Q1D,
@@ -175,7 +273,11 @@ void PAMassApply(const int dim,
 #endif // MFEM_USE_OCCA
    const int id = (D1D << 4) | Q1D;
 
-   if (dim == 2)
+   if (dim == 1)
+   {
+      return PAMassApply1D(NE,B,Bt,D,X,Y,D1D,Q1D);
+   }
+   else if (dim == 2)
    {
       switch (id)
       {
diff --git a/fem/integ/bilininteg_mass_kernels.hpp b/fem/integ/bilininteg_mass_kernels.hpp
index 991a5ff99..488d843cb 100644
--- a/fem/integ/bilininteg_mass_kernels.hpp
+++ b/fem/integ/bilininteg_mass_kernels.hpp
@@ -468,7 +468,6 @@ void SmemPAMassApply2D_Element(const int e,
    double (*QQ)[MQ1] = (double (*)[MQ1]) (sm0 + tidz);
    double (*QD)[MD1] = (double (*)[MD1]) (sm1 + tidz);
 
-
    MFEM_FOREACH_THREAD(dy,y,D1D)
    {
       MFEM_FOREACH_THREAD(dx,x,D1D)
diff --git a/fem/integ/bilininteg_mass_mf.cpp b/fem/integ/bilininteg_mass_mf.cpp
index 18a0edfca..b1e98f682 100644
--- a/fem/integ/bilininteg_mass_mf.cpp
+++ b/fem/integ/bilininteg_mass_mf.cpp
@@ -19,7 +19,6 @@ namespace mfem
 void MassIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
diff --git a/fem/integ/bilininteg_mass_pa.cpp b/fem/integ/bilininteg_mass_pa.cpp
index c73a4c6ff..ea52b6953 100644
--- a/fem/integ/bilininteg_mass_pa.cpp
+++ b/fem/integ/bilininteg_mass_pa.cpp
@@ -25,7 +25,6 @@ void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
                          Device::GetDeviceMemoryType() : pa_mt;
 
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
@@ -79,7 +78,7 @@ void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
             {
                const double detJ = J(qx,qy,e);
                const double coeff = const_c ? C(0,0,0) : C(qx,qy,e);
-               v(qx,qy,e) =  W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
+               v(qx,qy,e) = W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
             }
          }
       });
@@ -113,6 +112,79 @@ void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
 }
 
+void MassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
+{
+   const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
+                         Device::GetDeviceMemoryType() : pa_mt;
+
+   // Assuming the same element type
+   Mesh *mesh = fes.GetMesh();
+   if (mesh->GetNBE() == 0) { return; }
+   const FiniteElement &el = *fes.GetBE(0);
+   ElementTransformation *T0 = mesh->GetBdrElementTransformation(0);
+   const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, *T0);
+
+   int map_type = el.GetMapType();
+   dim = el.GetDim(); // Dimension of the boundary element, *not* the mesh
+   ne = fes.GetMesh()->GetNBE();
+   nq = ir->GetNPoints();
+   face_geom = mesh->GetFaceGeometricFactors(*ir, GeometricFactors::DETERMINANTS,
+                                             FaceType::Boundary, mt);
+   maps = &el.GetDofToQuad(*ir, DofToQuad::TENSOR);
+   dofs1D = maps->ndof;
+   quad1D = maps->nqpt;
+   pa_data.SetSize(ne*nq, mt);
+
+   FaceQuadratureSpace qs(*mesh, *ir, FaceType::Boundary);
+   CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
+
+   const int NE = ne;
+   const int Q1D = quad1D;
+   const bool const_c = coeff.Size() == 1;
+   const bool by_val = map_type == FiniteElement::VALUE;
+   if (dim==1)
+   {
+      const auto W = Reshape(ir->GetWeights().Read(), Q1D);
+      const auto J = Reshape(face_geom->detJ.Read(), Q1D, NE);
+      const auto C = const_c ? Reshape(coeff.Read(), 1, 1) :
+                     Reshape(coeff.Read(), Q1D, NE);
+      auto v = Reshape(pa_data.Write(), Q1D, NE);
+      mfem::forall_2D(NE, Q1D, 1, [=] MFEM_HOST_DEVICE (int e)
+      {
+         MFEM_FOREACH_THREAD(qx,x,Q1D)
+         {
+            const double detJ = J(qx,e);
+            const double coeff = const_c ? C(0,0) : C(qx,e);
+            v(qx,e) = W(qx) * coeff * (by_val ? detJ : 1.0/detJ);
+         }
+      });
+   }
+   else if (dim==2)
+   {
+      const auto W = Reshape(ir->GetWeights().Read(), Q1D,Q1D);
+      const auto J = Reshape(face_geom->detJ.Read(), Q1D,Q1D,NE);
+      const auto C = const_c ? Reshape(coeff.Read(), 1,1,1) :
+                     Reshape(coeff.Read(), Q1D,Q1D,NE);
+      auto v = Reshape(pa_data.Write(), Q1D,Q1D, NE);
+      mfem::forall_2D(NE, Q1D, Q1D, [=] MFEM_HOST_DEVICE (int e)
+      {
+         MFEM_FOREACH_THREAD(qx,x,Q1D)
+         {
+            MFEM_FOREACH_THREAD(qy,y,Q1D)
+            {
+               const double detJ = J(qx,qy,e);
+               const double coeff = const_c ? C(0,0,0) : C(qx,qy,e);
+               v(qx,qy,e) = W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
+            }
+         }
+      });
+   }
+   else
+   {
+      MFEM_ABORT("Not supported.");
+   }
+}
+
 void MassIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
diff --git a/fem/integ/bilininteg_mixedcurl_pa.cpp b/fem/integ/bilininteg_mixedcurl_pa.cpp
index 8be2134dd..a3c113982 100644
--- a/fem/integ/bilininteg_mixedcurl_pa.cpp
+++ b/fem/integ/bilininteg_mixedcurl_pa.cpp
@@ -265,9 +265,9 @@ void MixedVectorCurlIntegrator::AddMultTransposePA(const Vector &x,
    }
 }
 
-void MixedVectorWeakCurlIntegrator::AssemblePA(const FiniteElementSpace
-                                               &trial_fes,
-                                               const FiniteElementSpace &test_fes)
+void MixedVectorWeakCurlIntegrator::AssemblePA(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
 {
    // Assumes tensor-product elements, with vector test and trial spaces.
    Mesh *mesh = trial_fes.GetMesh();
diff --git a/fem/integ/bilininteg_mixedvecgrad_pa.cpp b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
index 4f50dcc92..f9e6d3ee8 100644
--- a/fem/integ/bilininteg_mixedvecgrad_pa.cpp
+++ b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
@@ -656,9 +656,9 @@ static void PAHcurlH1ApplyTranspose3D(const int D1D,
    }); // end of element loop
 }
 
-void MixedVectorGradientIntegrator::AssemblePA(const FiniteElementSpace
-                                               &trial_fes,
-                                               const FiniteElementSpace &test_fes)
+void MixedVectorGradientIntegrator::AssemblePA(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
 {
    // Assumes tensor-product elements, with a vector test space and H^1 trial space.
    Mesh *mesh = trial_fes.GetMesh();
diff --git a/fem/integ/bilininteg_transpose_ea.cpp b/fem/integ/bilininteg_transpose_ea.cpp
index 4ff8be04b..e1ac154fc 100644
--- a/fem/integ/bilininteg_transpose_ea.cpp
+++ b/fem/integ/bilininteg_transpose_ea.cpp
@@ -16,171 +16,91 @@ namespace mfem
 {
 
 void TransposeIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                     Vector &ea_data, const bool add)
+                                     Vector &ea_data)
 {
-   if (add)
-   {
-      Vector ea_data_tmp(ea_data.Size());
-      bfi->AssembleEA(fes, ea_data_tmp, false);
-      const int ne = fes.GetNE();
-      if (ne == 0) { return; }
-      const int dofs = fes.GetFE(0)->GetDof();
-      auto A = Reshape(ea_data_tmp.Read(), dofs, dofs, ne);
-      auto AT = Reshape(ea_data.ReadWrite(), dofs, dofs, ne);
-      mfem::forall(ne, [=] MFEM_HOST_DEVICE (int e)
-      {
-         for (int i = 0; i < dofs; i++)
-         {
-            for (int j = 0; j < dofs; j++)
-            {
-               const double a = A(i, j, e);
-               AT(j, i, e) += a;
-            }
-         }
-      });
-   }
-   else
+   const int ne = fes.GetNE();
+   if (ne == 0) { return; }
+
+   const int dofs = fes.GetFE(0)->GetDof();
+   Vector ea_data_tmp(ea_data.Size());
+   ea_data_tmp = 0.0;
+   bfi->AssembleEA(fes, ea_data_tmp);
+   auto A = Reshape(ea_data_tmp.Read(), dofs, dofs, ne);
+   auto AT = Reshape(ea_data.ReadWrite(), dofs, dofs, ne);
+   mfem::forall(ne, [=] MFEM_HOST_DEVICE (int e)
    {
-      bfi->AssembleEA(fes, ea_data, false);
-      const int ne = fes.GetNE();
-      if (ne == 0) { return; }
-      const int dofs = fes.GetFE(0)->GetDof();
-      auto A = Reshape(ea_data.ReadWrite(), dofs, dofs, ne);
-      mfem::forall(ne, [=] MFEM_HOST_DEVICE (int e)
+      for (int i = 0; i < dofs; i++)
       {
-         for (int i = 0; i < dofs; i++)
+         for (int j = 0; j < dofs; j++)
          {
-            for (int j = i+1; j < dofs; j++)
-            {
-               const double aij = A(i, j, e);
-               const double aji = A(j, i, e);
-               A(j, i, e) = aij;
-               A(i, j, e) = aji;
-            }
+            const double a = A(i, j, e);
+            AT(j, i, e) += a;
          }
-      });
-   }
+      }
+   });
 }
 
-void TransposeIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
+void TransposeIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                                   Vector &ea_data_int,
-                                                  Vector &ea_data_ext,
-                                                  const bool add)
+                                                  Vector &ea_data_ext)
 {
    const int nf = fes.GetNFbyType(FaceType::Interior);
    if (nf == 0) { return; }
-   if (add)
-   {
-      Vector ea_data_int_tmp(ea_data_int.Size());
-      Vector ea_data_ext_tmp(ea_data_ext.Size());
-      bfi->AssembleEAInteriorFaces(fes, ea_data_int_tmp, ea_data_ext_tmp, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_int = Reshape(ea_data_int_tmp.Read(), faceDofs, faceDofs, 2, nf);
-      auto A_ext = Reshape(ea_data_ext_tmp.Read(), faceDofs, faceDofs, 2, nf);
-      auto AT_int = Reshape(ea_data_int.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      auto AT_ext = Reshape(ea_data_ext.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
-      {
-         for (int i = 0; i < faceDofs; i++)
-         {
-            for (int j = 0; j < faceDofs; j++)
-            {
-               const double a_int0 = A_int(i, j, 0, f);
-               const double a_int1 = A_int(i, j, 1, f);
-               const double a_ext0 = A_ext(i, j, 0, f);
-               const double a_ext1 = A_ext(i, j, 1, f);
-               AT_int(j, i, 0, f) += a_int0;
-               AT_int(j, i, 1, f) += a_int1;
-               AT_ext(j, i, 0, f) += a_ext1;
-               AT_ext(j, i, 1, f) += a_ext0;
-            }
-         }
-      });
-   }
-   else
+
+   const int face_dofs = fes.GetTraceElement(0,
+                                             fes.GetMesh()->GetFaceGeometry(0))->GetDof();
+   Vector ea_data_int_tmp(ea_data_int.Size());
+   Vector ea_data_ext_tmp(ea_data_ext.Size());
+   ea_data_int_tmp = 0.0;
+   ea_data_ext_tmp = 0.0;
+   bfi->AssembleEAInteriorFaces(fes, ea_data_int_tmp, ea_data_ext_tmp);
+   auto A_int = Reshape(ea_data_int_tmp.Read(), face_dofs, face_dofs, 2, nf);
+   auto A_ext = Reshape(ea_data_ext_tmp.Read(), face_dofs, face_dofs, 2, nf);
+   auto AT_int = Reshape(ea_data_int.ReadWrite(), face_dofs, face_dofs, 2, nf);
+   auto AT_ext = Reshape(ea_data_ext.ReadWrite(), face_dofs, face_dofs, 2, nf);
+   mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
    {
-      bfi->AssembleEAInteriorFaces(fes, ea_data_int, ea_data_ext, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_int = Reshape(ea_data_int.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      auto A_ext = Reshape(ea_data_ext.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
+      for (int i = 0; i < face_dofs; i++)
       {
-         for (int i = 0; i < faceDofs; i++)
-         {
-            for (int j = i+1; j < faceDofs; j++)
-            {
-               const double aij_int0 = A_int(i, j, 0, f);
-               const double aij_int1 = A_int(i, j, 1, f);
-               const double aji_int0 = A_int(j, i, 0, f);
-               const double aji_int1 = A_int(j, i, 1, f);
-               A_int(j, i, 0, f) = aij_int0;
-               A_int(j, i, 1, f) = aij_int1;
-               A_int(i, j, 0, f) = aji_int0;
-               A_int(i, j, 1, f) = aji_int1;
-            }
-         }
-         for (int i = 0; i < faceDofs; i++)
+         for (int j = 0; j < face_dofs; j++)
          {
-            for (int j = 0; j < faceDofs; j++)
-            {
-               const double aij_ext0 = A_ext(i, j, 0, f);
-               const double aji_ext1 = A_ext(j, i, 1, f);
-               A_ext(j, i, 1, f) = aij_ext0;
-               A_ext(i, j, 0, f) = aji_ext1;
-            }
+            const double a_int0 = A_int(i, j, 0, f);
+            const double a_int1 = A_int(i, j, 1, f);
+            const double a_ext0 = A_ext(i, j, 0, f);
+            const double a_ext1 = A_ext(i, j, 1, f);
+            AT_int(j, i, 0, f) += a_int0;
+            AT_int(j, i, 1, f) += a_int1;
+            AT_ext(j, i, 0, f) += a_ext1;
+            AT_ext(j, i, 1, f) += a_ext0;
          }
-      });
-   }
+      }
+   });
 }
 
-void TransposeIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace& fes,
-                                                  Vector &ea_data_bdr,
-                                                  const bool add)
+void TransposeIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace &fes,
+                                                  Vector &ea_data_bdr)
 {
    const int nf = fes.GetNFbyType(FaceType::Boundary);
    if (nf == 0) { return; }
-   if (add)
-   {
-      Vector ea_data_bdr_tmp(ea_data_bdr.Size());
-      bfi->AssembleEABoundaryFaces(fes, ea_data_bdr_tmp, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_bdr = Reshape(ea_data_bdr_tmp.Read(), faceDofs, faceDofs, nf);
-      auto AT_bdr = Reshape(ea_data_bdr.ReadWrite(), faceDofs, faceDofs, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
-      {
-         for (int i = 0; i < faceDofs; i++)
-         {
-            for (int j = 0; j < faceDofs; j++)
-            {
-               const double a_bdr = A_bdr(i, j, f);
-               AT_bdr(j, i, f) += a_bdr;
-            }
-         }
-      });
-   }
-   else
+
+   const int face_dofs = fes.GetTraceElement(0,
+                                             fes.GetMesh()->GetFaceGeometry(0))->GetDof();
+   Vector ea_data_bdr_tmp(ea_data_bdr.Size());
+   ea_data_bdr_tmp = 0.0;
+   bfi->AssembleEABoundaryFaces(fes, ea_data_bdr_tmp);
+   auto A_bdr = Reshape(ea_data_bdr_tmp.Read(), face_dofs, face_dofs, nf);
+   auto AT_bdr = Reshape(ea_data_bdr.ReadWrite(), face_dofs, face_dofs, nf);
+   mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
    {
-      bfi->AssembleEABoundaryFaces(fes, ea_data_bdr, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_bdr = Reshape(ea_data_bdr.ReadWrite(), faceDofs, faceDofs, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
+      for (int i = 0; i < face_dofs; i++)
       {
-         for (int i = 0; i < faceDofs; i++)
+         for (int j = 0; j < face_dofs; j++)
          {
-            for (int j = i+1; j < faceDofs; j++)
-            {
-               const double aij_bdr = A_bdr(i, j, f);
-               const double aji_bdr = A_bdr(j, i, f);
-               A_bdr(j, i, f) = aij_bdr;
-               A_bdr(i, j, f) = aji_bdr;
-            }
+            const double a_bdr = A_bdr(i, j, f);
+            AT_bdr(j, i, f) += a_bdr;
          }
-      });
-   }
+      }
+   });
 }
 
 }
diff --git a/fem/integ/bilininteg_vecdiffusion_pa.cpp b/fem/integ/bilininteg_vecdiffusion_pa.cpp
index 88d0b136f..84e4d5b2a 100644
--- a/fem/integ/bilininteg_vecdiffusion_pa.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_pa.cpp
@@ -36,7 +36,6 @@ static void PAVectorDiffusionSetup2D(const int Q1D,
    const auto C = const_c ? Reshape(c.Read(), 1,1) :
                   Reshape(c.Read(), NQ, NE);
 
-
    mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
       for (int q = 0; q < NQ; ++q)
@@ -72,7 +71,6 @@ static void PAVectorDiffusionSetup3D(const int Q1D,
    const auto C = const_c ? Reshape(c.Read(), 1,1) :
                   Reshape(c.Read(), NQ,NE);
 
-
    mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
       for (int q = 0; q < NQ; ++q)
@@ -114,28 +112,6 @@ static void PAVectorDiffusionSetup3D(const int Q1D,
    });
 }
 
-static void PAVectorDiffusionSetup(const int dim,
-                                   const int Q1D,
-                                   const int NE,
-                                   const Array<double> &W,
-                                   const Vector &J,
-                                   const Vector &C,
-                                   Vector &op)
-{
-   if (!(dim == 2 || dim == 3))
-   {
-      MFEM_ABORT("Dimension not supported.");
-   }
-   if (dim == 2)
-   {
-      PAVectorDiffusionSetup2D(Q1D, NE, W, J, C, op);
-   }
-   if (dim == 3)
-   {
-      PAVectorDiffusionSetup3D(Q1D, NE, W, J, C, op);
-   }
-}
-
 void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    // Assumes tensor-product elements
@@ -179,7 +155,10 @@ void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    const Array<double> &w = ir->GetWeights();
    const Vector &j = geom->J;
    Vector &d = pa_data;
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PAVectorDiffusionSetup"); }
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in VectorDiffusionIntegrator::AssemblePA");
+   }
    if (dim == 2 && sdim == 3)
    {
       constexpr int DIM = 2;
@@ -218,7 +197,15 @@ void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
    else
    {
-      PAVectorDiffusionSetup(dim, quad1D, ne, w, j, coeff, d);
+      if (dim == 2)
+      {
+         return PAVectorDiffusionSetup2D(quad1D, ne, w, j, coeff, d);
+      }
+      if (dim == 3)
+      {
+         return PAVectorDiffusionSetup3D(quad1D, ne, w, j, coeff, d);
+      }
+      MFEM_ABORT("Dimension not supported.");
    }
 }
 
@@ -391,26 +378,6 @@ static void PAVectorDiffusionDiagonal3D(const int NE,
    });
 }
 
-static void PAVectorDiffusionAssembleDiagonal(const int dim,
-                                              const int D1D,
-                                              const int Q1D,
-                                              const int NE,
-                                              const Array<double> &B,
-                                              const Array<double> &G,
-                                              const Vector &op,
-                                              Vector &y)
-{
-   if (dim == 2)
-   {
-      return PAVectorDiffusionDiagonal2D(NE, B, G, op, y, D1D, Q1D);
-   }
-   else if (dim == 3)
-   {
-      return PAVectorDiffusionDiagonal3D(NE, B, G, op, y, D1D, Q1D);
-   }
-   MFEM_ABORT("Dimension not implemented.");
-}
-
 void VectorDiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
@@ -419,25 +386,35 @@ void VectorDiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
    }
    else
    {
-      PAVectorDiffusionAssembleDiagonal(dim, dofs1D, quad1D, ne,
-                                        maps->B, maps->G,
-                                        pa_data, diag);
+      if (dim == 2)
+      {
+         return PAVectorDiffusionDiagonal2D(ne, maps->B, maps->G,
+                                            pa_data, diag,
+                                            dofs1D, quad1D);
+      }
+      else if (dim == 3)
+      {
+         return PAVectorDiffusionDiagonal3D(ne, maps->B, maps->G,
+                                            pa_data, diag,
+                                            dofs1D, quad1D);
+      }
+      MFEM_ABORT("Dimension not implemented.");
    }
 }
 
 // PA Diffusion Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0, int T_VDIM = 0> static
-void PAVectorDiffusionApply2D(const int NE,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &d_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0,
-                              const int vdim = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_VDIM = 0>
+static void PAVectorDiffusionApply2D(const int NE,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &d_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     const int d1d = 0,
+                                     const int q1d = 0,
+                                     const int vdim = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -548,17 +525,16 @@ void PAVectorDiffusionApply2D(const int NE,
 }
 
 // PA Diffusion Apply 3D kernel
-template<const int T_D1D = 0,
-         const int T_Q1D = 0> static
-void PAVectorDiffusionApply3D(const int NE,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &op_,
-                              const Vector &x_,
-                              Vector &y_,
-                              int d1d = 0, int q1d = 0)
+template<const int T_D1D = 0, const int T_Q1D = 0>
+static void PAVectorDiffusionApply3D(const int NE,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &op_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     int d1d = 0, int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -741,7 +717,6 @@ void PAVectorDiffusionApply3D(const int NE,
    });
 }
 
-// PA Diffusion Apply kernel
 void VectorDiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
@@ -771,11 +746,13 @@ void VectorDiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
          }
       }
       if (dim == 2 && sdim == 2)
-      { return PAVectorDiffusionApply2D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D,sdim); }
-
+      {
+         return PAVectorDiffusionApply2D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D,sdim);
+      }
       if (dim == 3 && sdim == 3)
-      { return PAVectorDiffusionApply3D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D); }
-
+      {
+         return PAVectorDiffusionApply3D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D);
+      }
       MFEM_ABORT("Unknown kernel.");
    }
 }
diff --git a/fem/integ/bilininteg_vecdiv_pa.cpp b/fem/integ/bilininteg_vecdiv_pa.cpp
index cc282a49a..63f7a3308 100644
--- a/fem/integ/bilininteg_vecdiv_pa.cpp
+++ b/fem/integ/bilininteg_vecdiv_pa.cpp
@@ -96,27 +96,6 @@ static void PADivergenceSetup3D(const int Q1D,
    });
 }
 
-static void PADivergenceSetup(const int dim,
-                              const int TR_D1D,
-                              const int TE_D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &W,
-                              const Vector &J,
-                              const double COEFF,
-                              Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PADivergenceSetup"); }
-   if (dim == 2)
-   {
-      PADivergenceSetup2D(Q1D, NE, W, J, COEFF, op);
-   }
-   if (dim == 3)
-   {
-      PADivergenceSetup3D(Q1D, NE, W, J, COEFF, op);
-   }
-}
-
 void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                             const FiniteElementSpace &test_fes)
 {
@@ -143,6 +122,7 @@ void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    MFEM_ASSERT(quad1D == test_maps->nqpt,
                "PA requires test and trial space to have same number of quadrature points!");
    pa_data.SetSize(nq * dimsToStore * ne, Device::GetMemoryType());
+
    double coeff = 1.0;
    if (Q)
    {
@@ -150,8 +130,19 @@ void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
       MFEM_VERIFY(cQ != NULL, "only ConstantCoefficient is supported!");
       coeff = cQ->constant;
    }
-   PADivergenceSetup(dim, trial_dofs1D, test_dofs1D, quad1D,
-                     ne, ir->GetWeights(), geom->J, coeff, pa_data);
+
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in VectorDivergenceIntegrator::AssemblePA");
+   }
+   else if (dim == 2)
+   {
+      PADivergenceSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PADivergenceSetup3D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
 }
 
 // PA Divergence Apply 2D kernel
@@ -1021,59 +1012,37 @@ static void SmemPADivergenceApply3D(const int NE,
    });
 }
 
-static void PADivergenceApply(const int dim,
-                              const int TR_D1D,
-                              const int TE_D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &B,
-                              const Array<double> &G,
-                              const Array<double> &Bt,
-                              const Vector &op,
-                              const Vector &x,
-                              Vector &y,
-                              bool transpose=false)
+void VectorDivergenceIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (dim == 2)
    {
-      if (transpose)
-      {
-         return PADivergenceApplyTranspose2D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
-      }
-      else
-      {
-         return PADivergenceApply2D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
-      }
+      return PADivergenceApply2D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                                 pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    if (dim == 3)
    {
-      if (transpose)
-      {
-         return PADivergenceApplyTranspose3D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
-      }
-      else
-      {
-         return PADivergenceApply3D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
-      }
+      return PADivergenceApply3D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                                 pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    MFEM_ABORT("Unknown kernel.");
 }
 
-// PA Divergence Apply kernel
-void VectorDivergenceIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   PADivergenceApply(dim, trial_dofs1D, test_dofs1D, quad1D, ne,
-                     trial_maps->B, trial_maps->G, test_maps->Bt, pa_data, x, y,
-                     false);
-}
-
-// PA Divergence Apply kernel
 void VectorDivergenceIntegrator::AddMultTransposePA(const Vector &x,
                                                     Vector &y) const
 {
-   PADivergenceApply(dim, trial_dofs1D, test_dofs1D, quad1D, ne,
-                     trial_maps->Bt, trial_maps->Gt, test_maps->B, pa_data, x, y,
-                     true);
+   if (dim == 2)
+   {
+      return PADivergenceApplyTranspose2D(ne, trial_maps->Bt, trial_maps->Gt,
+                                          test_maps->B, pa_data, x, y,
+                                          trial_dofs1D, test_dofs1D, quad1D);
+   }
+   if (dim == 3)
+   {
+      return PADivergenceApplyTranspose3D(ne, trial_maps->Bt, trial_maps->Gt,
+                                          test_maps->B, pa_data, x, y,
+                                          trial_dofs1D, test_dofs1D, quad1D);
+   }
+   MFEM_ABORT("Unknown kernel.");
 }
 
 } // namespace mfem
diff --git a/fem/integ/bilininteg_vecmass_pa.cpp b/fem/integ/bilininteg_vecmass_pa.cpp
index faafdf14d..b1c20b4c4 100644
--- a/fem/integ/bilininteg_vecmass_pa.cpp
+++ b/fem/integ/bilininteg_vecmass_pa.cpp
@@ -78,7 +78,7 @@ void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
             const double J21 = J(q,0,1,e);
             const double J22 = J(q,1,1,e);
             const double detJ = (J11*J22)-(J21*J12);
-            v(q,e) =  w[q] * constant * detJ;
+            v(q,e) = w[q] * constant * detJ;
          }
       });
    }
@@ -234,26 +234,6 @@ static void PAVectorMassAssembleDiagonal3D(const int NE,
    });
 }
 
-static void PAVectorMassAssembleDiagonal(const int dim,
-                                         const int D1D,
-                                         const int Q1D,
-                                         const int NE,
-                                         const Array<double> &B,
-                                         const Array<double> &Bt,
-                                         const Vector &op,
-                                         Vector &y)
-{
-   if (dim == 2)
-   {
-      return PAVectorMassAssembleDiagonal2D(NE, B, Bt, op, y, D1D, Q1D);
-   }
-   else if (dim == 3)
-   {
-      return PAVectorMassAssembleDiagonal3D(NE, B, Bt, op, y, D1D, Q1D);
-   }
-   MFEM_ABORT("Dimension not implemented.");
-}
-
 void VectorMassIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
@@ -262,9 +242,19 @@ void VectorMassIntegrator::AssembleDiagonalPA(Vector &diag)
    }
    else
    {
-      PAVectorMassAssembleDiagonal(dim, dofs1D, quad1D, ne,
-                                   maps->B, maps->Bt,
-                                   pa_data, diag);
+      if (dim == 2)
+      {
+         return PAVectorMassAssembleDiagonal2D(ne, maps->B, maps->Bt,
+                                               pa_data, diag,
+                                               dofs1D, quad1D);
+      }
+      else if (dim == 3)
+      {
+         return PAVectorMassAssembleDiagonal3D(ne, maps->B, maps->Bt,
+                                               pa_data, diag,
+                                               dofs1D, quad1D);
+      }
+      MFEM_ABORT("Dimension not implemented.");
    }
 }
 
@@ -509,27 +499,6 @@ static void PAVectorMassApply3D(const int NE,
    });
 }
 
-static void PAVectorMassApply(const int dim,
-                              const int D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &B,
-                              const Array<double> &Bt,
-                              const Vector &op,
-                              const Vector &x,
-                              Vector &y)
-{
-   if (dim == 2)
-   {
-      return PAVectorMassApply2D(NE, B, Bt, op, x, y, D1D, Q1D);
-   }
-   if (dim == 3)
-   {
-      return PAVectorMassApply3D(NE, B, Bt, op, x, y, D1D, Q1D);
-   }
-   MFEM_ABORT("Unknown kernel.");
-}
-
 void VectorMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
@@ -538,7 +507,17 @@ void VectorMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
    }
    else
    {
-      PAVectorMassApply(dim, dofs1D, quad1D, ne, maps->B, maps->Bt, pa_data, x, y);
+      if (dim == 2)
+      {
+         return PAVectorMassApply2D(ne, maps->B, maps->Bt, pa_data, x, y,
+                                    dofs1D, quad1D);
+      }
+      if (dim == 3)
+      {
+         return PAVectorMassApply3D(ne, maps->B, maps->Bt, pa_data, x, y,
+                                    dofs1D, quad1D);
+      }
+      MFEM_ABORT("Unknown kernel.");
    }
 }
 
diff --git a/fem/integ/bilininteg_vectorfemass_pa.cpp b/fem/integ/bilininteg_vectorfemass_pa.cpp
index f8d6f63d4..c07e9f816 100644
--- a/fem/integ/bilininteg_vectorfemass_pa.cpp
+++ b/fem/integ/bilininteg_vectorfemass_pa.cpp
@@ -20,11 +20,6 @@
 namespace mfem
 {
 
-void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
-{
-   AssemblePA(fes, fes);
-}
-
 void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                         const FiniteElementSpace &test_fes)
 {
diff --git a/fem/integ/lininteg_boundary_flux.cpp b/fem/integ/lininteg_boundary_flux.cpp
index 98cee62a6..b9f047817 100644
--- a/fem/integ/lininteg_boundary_flux.cpp
+++ b/fem/integ/lininteg_boundary_flux.cpp
@@ -16,10 +16,10 @@
 namespace mfem
 {
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void BFLFEvalAssemble2D(const int nbe, const int d, const int q,
-                        const int *markers, const double *b,
-                        const double *weights, const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void BFLFEvalAssemble2D(const int nbe, const int d, const int q,
+                               const int *markers, const double *b,
+                               const double *weights, const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, nbe);
@@ -50,10 +50,10 @@ void BFLFEvalAssemble2D(const int nbe, const int d, const int q,
    });
 }
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void BFLFEvalAssemble3D(const int nbe, const int d, const int q,
-                        const int *markers, const double *b,
-                        const double *weights, const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void BFLFEvalAssemble3D(const int nbe, const int d, const int q,
+                               const int *markers, const double *b,
+                               const double *weights, const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, nbe);
diff --git a/fem/integ/lininteg_domain_grad.cpp b/fem/integ/lininteg_domain_grad.cpp
index 9bf3af218..5cca01a1d 100644
--- a/fem/integ/lininteg_domain_grad.cpp
+++ b/fem/integ/lininteg_domain_grad.cpp
@@ -16,11 +16,12 @@
 namespace mfem
 {
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void DLFGradAssemble2D(const int vdim, const int ne, const int d, const int q,
-                       const int *markers, const double *b, const double *g,
-                       const double *jacobians,
-                       const double *weights, const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void DLFGradAssemble2D(const int vdim, const int ne, const int d,
+                              const int q,
+                              const int *markers, const double *b, const double *g,
+                              const double *jacobians,
+                              const double *weights, const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, ne);
@@ -108,12 +109,13 @@ void DLFGradAssemble2D(const int vdim, const int ne, const int d, const int q,
    });
 }
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void DLFGradAssemble3D(const int vdim, const int ne, const int d, const int q,
-                       const int *markers, const double *b, const double *g,
-                       const double *jacobians,
-                       const double *weights, const Vector &coeff,
-                       double *output)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void DLFGradAssemble3D(const int vdim, const int ne, const int d,
+                              const int q,
+                              const int *markers, const double *b, const double *g,
+                              const double *jacobians,
+                              const double *weights, const Vector &coeff,
+                              double *output)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, ne);
diff --git a/fem/intrules.cpp b/fem/intrules.cpp
index 67ab66320..1494043d6 100644
--- a/fem/intrules.cpp
+++ b/fem/intrules.cpp
@@ -946,22 +946,14 @@ const IntegrationRule &IntegrationRules::Get(int GeomType, int Order)
 
    if (!HaveIntRule(*ir_array, Order))
    {
-#ifdef MFEM_USE_LEGACY_OPENMP
-      #pragma omp critical
-#endif
+      IntegrationRule *ir = GenerateIntegrationRule(GeomType, Order);
+      int RealOrder = Order;
+      while (RealOrder+1 < ir_array->Size() &&
+             (*ir_array)[RealOrder+1] == ir)
       {
-         if (!HaveIntRule(*ir_array, Order))
-         {
-            IntegrationRule *ir = GenerateIntegrationRule(GeomType, Order);
-            int RealOrder = Order;
-            while (RealOrder+1 < ir_array->Size() &&
-                   (*ir_array)[RealOrder+1] == ir)
-            {
-               RealOrder++;
-            }
-            ir->SetOrder(RealOrder);
-         }
+         RealOrder++;
       }
+      ir->SetOrder(RealOrder);
    }
 
    return *(*ir_array)[Order];
diff --git a/fem/linearform.hpp b/fem/linearform.hpp
index c24118426..29f816db1 100644
--- a/fem/linearform.hpp
+++ b/fem/linearform.hpp
@@ -121,10 +121,6 @@ public:
    LinearForm &operator=(const LinearForm &rhs)
    { return operator=((const Vector &)rhs); }
 
-   /// (DEPRECATED) Return the FE space associated with the LinearForm.
-   /** @deprecated Use FESpace() instead. */
-   MFEM_DEPRECATED FiniteElementSpace *GetFES() { return fes; }
-
    /// Read+write access to the associated FiniteElementSpace.
    FiniteElementSpace *FESpace() { return fes; }
    /// Read-only access to the associated FiniteElementSpace.
diff --git a/fem/linearform_ext.cpp b/fem/linearform_ext.cpp
index f70a7b6e3..3475574fd 100644
--- a/fem/linearform_ext.cpp
+++ b/fem/linearform_ext.cpp
@@ -164,10 +164,8 @@ void LinearFormExtension::Update()
          }
       }
 
-      bdr_restrict_lex =
-         dynamic_cast<const FaceRestriction*>(
-            fes.GetFaceRestriction(ordering, FaceType::Boundary,
-                                   L2FaceValues::SingleValued));
+      bdr_restrict_lex = fes.GetFaceRestriction(ordering, FaceType::Boundary,
+                                                L2FaceValues::SingleValued);
       MFEM_VERIFY(bdr_restrict_lex, "Face restriction not available");
       bdr_b.SetSize(bdr_restrict_lex->Height(), Device::GetMemoryType());
       bdr_b.UseDevice(true);
diff --git a/fem/linearform_ext.hpp b/fem/linearform_ext.hpp
index 2cc861cea..46acf637d 100644
--- a/fem/linearform_ext.hpp
+++ b/fem/linearform_ext.hpp
@@ -34,7 +34,7 @@ class LinearFormExtension
    LinearForm *lf;
 
    /// Operator that converts FiniteElementSpace L-vectors to E-vectors.
-   const ElementRestrictionOperator *elem_restrict_lex; // Not owned
+   const ElementRestriction *elem_restrict_lex; // Not owned
 
    /// Operator that converts L-vectors to boundary E-vectors.
    const FaceRestriction *bdr_restrict_lex; // Not owned
diff --git a/fem/lor/lor_ads.cpp b/fem/lor/lor_ads.cpp
index 3ba4816ee..f962f8469 100644
--- a/fem/lor/lor_ads.cpp
+++ b/fem/lor/lor_ads.cpp
@@ -103,9 +103,9 @@ void BatchedLOR_ADS::FormCurlMatrix()
    Form3DFaceToEdge(face2edge);
 
    ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
-   const auto *R_f = dynamic_cast<const ElementRestriction*>(
+   const auto *R_f = dynamic_cast<const ConformingElementRestriction*>(
                         face_fes.GetElementRestriction(ordering));
-   const auto *R_e = dynamic_cast<const ElementRestriction*>(
+   const auto *R_e = dynamic_cast<const ConformingElementRestriction*>(
                         edge_fes.GetElementRestriction(ordering));
    MFEM_VERIFY(R_f != NULL && R_e != NULL, "");
 
diff --git a/fem/lor/lor_ams.cpp b/fem/lor/lor_ams.cpp
index 1c37f165b..0d7ac222f 100644
--- a/fem/lor/lor_ams.cpp
+++ b/fem/lor/lor_ams.cpp
@@ -163,9 +163,9 @@ void BatchedLOR_AMS::FormGradientMatrix()
    else { Form3DEdgeToVertex(edge2vertex); }
 
    ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
-   const auto *R_v = dynamic_cast<const ElementRestriction*>(
+   const auto *R_v = dynamic_cast<const ConformingElementRestriction*>(
                         vert_fes.GetElementRestriction(ordering));
-   const auto *R_e = dynamic_cast<const ElementRestriction*>(
+   const auto *R_e = dynamic_cast<const ConformingElementRestriction*>(
                         edge_fes.GetElementRestriction(ordering));
    MFEM_VERIFY(R_v != NULL && R_e != NULL, "");
 
@@ -268,7 +268,7 @@ void BatchedLOR_AMS::FormCoordinateVectors(const Vector &X_vert)
    // Create the H1 vertex space and get the element restriction
    ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
    const Operator *op = vert_fes.GetElementRestriction(ordering);
-   const auto *el_restr = dynamic_cast<const ElementRestriction*>(op);
+   const auto *el_restr = dynamic_cast<const ConformingElementRestriction*>(op);
    MFEM_VERIFY(el_restr != NULL, "");
    const SparseMatrix *R = vert_fes.GetRestrictionMatrix();
 
diff --git a/fem/lor/lor_batched.cpp b/fem/lor/lor_batched.cpp
index fe0494880..0050c3de5 100644
--- a/fem/lor/lor_batched.cpp
+++ b/fem/lor/lor_batched.cpp
@@ -145,8 +145,8 @@ int BatchedLORAssembly::FillI(SparseMatrix &A) const
 
    const ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
    const Operator *op = fes_ho.GetElementRestriction(ordering);
-   const ElementRestriction *el_restr =
-      dynamic_cast<const ElementRestriction*>(op);
+   const auto *el_restr =
+      dynamic_cast<const ConformingElementRestriction*>(op);
    MFEM_VERIFY(el_restr != nullptr, "Bad element restriction");
 
    const Array<int> &el_dof_lex_ = el_restr->GatherMap();
@@ -235,8 +235,8 @@ void BatchedLORAssembly::FillJAndData(SparseMatrix &A) const
 
    const ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
    const Operator *op = fes_ho.GetElementRestriction(ordering);
-   const ElementRestriction *el_restr =
-      dynamic_cast<const ElementRestriction*>(op);
+   const auto *el_restr =
+      dynamic_cast<const ConformingElementRestriction*>(op);
    MFEM_VERIFY(el_restr != nullptr, "Bad element restriction");
 
    const Array<int> &el_dof_lex_ = el_restr->GatherMap();
diff --git a/fem/nonlinearform.hpp b/fem/nonlinearform.hpp
index d15d09e04..60cae2055 100644
--- a/fem/nonlinearform.hpp
+++ b/fem/nonlinearform.hpp
@@ -330,7 +330,6 @@ public:
    virtual ~BlockNonlinearForm();
 };
 
-
 }
 
 #endif
diff --git a/fem/nonlininteg.cpp b/fem/nonlininteg.cpp
index e1558fda4..5ee1febea 100644
--- a/fem/nonlininteg.cpp
+++ b/fem/nonlininteg.cpp
@@ -15,68 +15,69 @@
 namespace mfem
 {
 
-double NonlinearFormIntegrator::GetLocalStateEnergyPA(const Vector &x) const
-{
-   mfem_error ("NonlinearFormIntegrator::GetLocalStateEnergyPA(...)\n"
-               "   is not implemented for this class.");
-   return 0.0;
-}
-
 void NonlinearFormIntegrator::AssemblePA(const FiniteElementSpace&)
 {
-   mfem_error ("NonlinearFormIntegrator::AssemblePA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssemblePA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssemblePA(const FiniteElementSpace &,
-                                         const FiniteElementSpace &)
+void NonlinearFormIntegrator::AssembleGradPA(const Vector &x,
+                                             const FiniteElementSpace &fes)
 {
-   mfem_error ("NonlinearFormIntegrator::AssemblePA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleGradPA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleGradPA(const Vector &x,
-                                             const FiniteElementSpace &fes)
+void NonlinearFormIntegrator::AssembleGradDiagonalPA(Vector &diag) const
 {
-   mfem_error ("NonlinearFormIntegrator::AssembleGradPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleGradDiagonalPA(...)\n"
+              "   is not implemented for this class.");
 }
 
 void NonlinearFormIntegrator::AddMultPA(const Vector &, Vector &) const
 {
-   mfem_error ("NonlinearFormIntegrator::AddMultPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AddMultPA(...)\n"
+              "   is not implemented for this class.");
 }
 
 void NonlinearFormIntegrator::AddMultGradPA(const Vector&, Vector&) const
 {
-   mfem_error ("NonlinearFormIntegrator::AddMultGradPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AddMultGradPA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleGradDiagonalPA(Vector &diag) const
+double NonlinearFormIntegrator::GetLocalStateEnergyPA(const Vector &x) const
 {
-   mfem_error ("NonlinearFormIntegrator::AssembleGradDiagonalPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::GetLocalStateEnergyPA(...)\n"
+              "   is not implemented for this class.");
+   return 0.0;
 }
 
 void NonlinearFormIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   mfem_error ("NonlinearFormIntegrator::AssembleMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleMF(...)\n"
+              "   is not implemented for this class.");
 }
 
 void NonlinearFormIntegrator::AddMultMF(const Vector &, Vector &) const
 {
-   mfem_error ("NonlinearFormIntegrator::AddMultMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AddMultMF(...)\n"
+              "   is not implemented for this class.");
+}
+
+double NonlinearFormIntegrator::GetElementEnergy(
+   const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun)
+{
+   MFEM_ABORT("NonlinearFormIntegrator::GetElementEnergy"
+              " is not overloaded!");
+   return 0.0;
 }
 
 void NonlinearFormIntegrator::AssembleElementVector(
    const FiniteElement &el, ElementTransformation &Tr,
    const Vector &elfun, Vector &elvect)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleElementVector"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementVector"
               " is not overloaded!");
 }
 
@@ -84,7 +85,7 @@ void NonlinearFormIntegrator::AssembleFaceVector(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Tr, const Vector &elfun, Vector &elvect)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleFaceVector"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceVector"
               " is not overloaded!");
 }
 
@@ -92,7 +93,7 @@ void NonlinearFormIntegrator::AssembleElementGrad(
    const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun,
    DenseMatrix &elmat)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleElementGrad"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementGrad"
               " is not overloaded!");
 }
 
@@ -101,18 +102,10 @@ void NonlinearFormIntegrator::AssembleFaceGrad(
    FaceElementTransformations &Tr, const Vector &elfun,
    DenseMatrix &elmat)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleFaceGrad"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceGrad"
               " is not overloaded!");
 }
 
-double NonlinearFormIntegrator::GetElementEnergy(
-   const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun)
-{
-   mfem_error("NonlinearFormIntegrator::GetElementEnergy"
-              " is not overloaded!");
-   return 0.0;
-}
-
 
 void BlockNonlinearFormIntegrator::AssembleElementVector(
    const Array<const FiniteElement *> &el,
@@ -120,7 +113,7 @@ void BlockNonlinearFormIntegrator::AssembleElementVector(
    const Array<const Vector *> &elfun,
    const Array<Vector *> &elvec)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleElementVector"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementVector"
               " is not overloaded!");
 }
 
@@ -131,7 +124,7 @@ void BlockNonlinearFormIntegrator::AssembleFaceVector(
    const Array<const Vector *> &elfun,
    const Array<Vector *> &elvect)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleFaceVector"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceVector"
               " is not overloaded!");
 }
 
@@ -141,7 +134,7 @@ void BlockNonlinearFormIntegrator::AssembleElementGrad(
    const Array<const Vector *> &elfun,
    const Array2D<DenseMatrix *> &elmats)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleElementGrad"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementGrad"
               " is not overloaded!");
 }
 
@@ -152,7 +145,7 @@ void BlockNonlinearFormIntegrator::AssembleFaceGrad(
    const Array<const Vector *> &elfun,
    const Array2D<DenseMatrix *> &elmats)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleFaceGrad"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceGrad"
               " is not overloaded!");
 }
 
@@ -161,7 +154,7 @@ double BlockNonlinearFormIntegrator::GetElementEnergy(
    ElementTransformation &Tr,
    const Array<const Vector *>&elfun)
 {
-   mfem_error("BlockNonlinearFormIntegrator::GetElementEnergy"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::GetElementEnergy"
               " is not overloaded!");
    return 0.0;
 }
@@ -497,6 +490,7 @@ void HyperelasticNLFIntegrator::AssembleElementGrad(const FiniteElement &el,
    }
 }
 
+
 double IncompressibleNeoHookeanIntegrator::GetElementEnergy(
    const Array<const FiniteElement *>&el,
    ElementTransformation &Tr,
@@ -504,7 +498,7 @@ double IncompressibleNeoHookeanIntegrator::GetElementEnergy(
 {
    if (el.Size() != 2)
    {
-      mfem_error("IncompressibleNeoHookeanIntegrator::GetElementEnergy"
+      MFEM_ABORT("IncompressibleNeoHookeanIntegrator::GetElementEnergy"
                  " has incorrect block finite element space size!");
    }
 
@@ -549,7 +543,7 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementVector(
 {
    if (el.Size() != 2)
    {
-      mfem_error("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
+      MFEM_ABORT("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
                  " has finite element space of incorrect block number");
    }
 
@@ -561,11 +555,10 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementVector(
 
    if (dim != spaceDim)
    {
-      mfem_error("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
+      MFEM_ABORT("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
                  " is not defined on manifold meshes");
    }
 
-
    DSh_u.SetSize(dof_u, dim);
    DS_u.SetSize(dof_u, dim);
    J0i.SetSize(dim);
@@ -731,6 +724,7 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementGrad(
 
 }
 
+
 const IntegrationRule&
 VectorConvectionNLFIntegrator::GetRule(const FiniteElement &fe,
                                        ElementTransformation &T)
diff --git a/fem/nonlininteg.hpp b/fem/nonlininteg.hpp
index 54f342b85..38b133244 100644
--- a/fem/nonlininteg.hpp
+++ b/fem/nonlininteg.hpp
@@ -29,13 +29,12 @@ class NonlinearFormIntegrator
 protected:
    const IntegrationRule *IntRule;
 
-   // CEED extension
-   ceed::Operator* ceedOp;
+   ceed::Operator *ceedOp;  // libCEED extension
 
    MemoryType pa_mt = MemoryType::DEFAULT;
 
    NonlinearFormIntegrator(const IntegrationRule *ir = NULL)
-      : IntRule(ir), ceedOp(NULL) { }
+      : IntRule(ir), ceedOp(NULL) {}
 
 public:
    /** @brief Prescribe a fixed IntegrationRule to use (when @a ir != NULL) or
@@ -52,46 +51,11 @@ public:
    /// Get the integration rule of the integrator (possibly NULL).
    const IntegrationRule *GetIntegrationRule() const { return IntRule; }
 
-   /// Perform the local action of the NonlinearFormIntegrator
-   virtual void AssembleElementVector(const FiniteElement &el,
-                                      ElementTransformation &Tr,
-                                      const Vector &elfun, Vector &elvect);
-
-   /// @brief Perform the local action of the NonlinearFormIntegrator resulting
-   /// from a face integral term.
-   virtual void AssembleFaceVector(const FiniteElement &el1,
-                                   const FiniteElement &el2,
-                                   FaceElementTransformations &Tr,
-                                   const Vector &elfun, Vector &elvect);
-
-   /// Assemble the local gradient matrix
-   virtual void AssembleElementGrad(const FiniteElement &el,
-                                    ElementTransformation &Tr,
-                                    const Vector &elfun, DenseMatrix &elmat);
-
-   /// @brief Assemble the local action of the gradient of the
-   /// NonlinearFormIntegrator resulting from a face integral term.
-   virtual void AssembleFaceGrad(const FiniteElement &el1,
-                                 const FiniteElement &el2,
-                                 FaceElementTransformations &Tr,
-                                 const Vector &elfun, DenseMatrix &elmat);
-
-   /// Compute the local energy
-   virtual double GetElementEnergy(const FiniteElement &el,
-                                   ElementTransformation &Tr,
-                                   const Vector &elfun);
-
    /// Method defining partial assembly.
    /** The result of the partial assembly is stored internally so that it can be
        used later in the methods AddMultPA(). */
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   /** The result of the partial assembly is stored internally so that it can be
-       used later in the methods AddMultPA().
-       Used with BilinearFormIntegrators that have different spaces. */
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
    /** @brief Prepare the integrator for partial assembly (PA) gradient
        evaluations on the given FE space @a fes at the state @a x. */
    /** The result of the partial assembly is stored internally so that it can be
@@ -99,10 +63,12 @@ public:
        The state Vector @a x is an E-vector. */
    virtual void AssembleGradPA(const Vector &x, const FiniteElementSpace &fes);
 
-   /// Compute the local (to the MPI rank) energy with partial assembly.
-   /** Here the state @a x is an E-vector. This method can be called only after
-       the method AssemblePA() has been called. */
-   virtual double GetLocalStateEnergyPA(const Vector &x) const;
+   /// Method for computing the diagonal of the gradient with partial assembly.
+   /** The result Vector @a diag is an E-Vector. This method can be called only
+       after the method AssembleGradPA() has been called.
+
+       @param[in,out] diag  The result Vector: @f$ diag += diag(G) @f$. */
+   virtual void AssembleGradDiagonalPA(Vector &diag) const;
 
    /// Method for partially assembled action.
    /** Perform the action of integrator on the input @a x and add the result to
@@ -121,15 +87,10 @@ public:
        @param[in,out] y  The result Vector: @f$ y += G x @f$. */
    virtual void AddMultGradPA(const Vector &x, Vector &y) const;
 
-   /// Method for computing the diagonal of the gradient with partial assembly.
-   /** The result Vector @a diag is an E-Vector. This method can be called only
-       after the method AssembleGradPA() has been called.
-
-       @param[in,out] diag  The result Vector: @f$ diag += diag(G) @f$. */
-   virtual void AssembleGradDiagonalPA(Vector &diag) const;
-
-   /// Indicates whether this integrator can use a Ceed backend.
-   virtual bool SupportsCeed() const { return false; }
+   /// Compute the local (to the MPI rank) energy with partial assembly.
+   /** Here the state @a x is an E-vector. This method can be called only after
+       the method AssemblePA() has been called. */
+   virtual double GetLocalStateEnergyPA(const Vector &x) const;
 
    /// Method defining fully unassembled operator.
    virtual void AssembleMF(const FiniteElementSpace &fes);
@@ -142,7 +103,39 @@ public:
        called. */
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   ceed::Operator& GetCeedOp() { return *ceedOp; }
+   /// Compute the local energy
+   virtual double GetElementEnergy(const FiniteElement &el,
+                                   ElementTransformation &Tr,
+                                   const Vector &elfun);
+
+   /// Perform the local action of the NonlinearFormIntegrator
+   virtual void AssembleElementVector(const FiniteElement &el,
+                                      ElementTransformation &Tr,
+                                      const Vector &elfun, Vector &elvect);
+
+   /// @brief Perform the local action of the NonlinearFormIntegrator resulting
+   /// from a face integral term.
+   virtual void AssembleFaceVector(const FiniteElement &el1,
+                                   const FiniteElement &el2,
+                                   FaceElementTransformations &Tr,
+                                   const Vector &elfun, Vector &elvect);
+
+   /// Assemble the local gradient matrix
+   virtual void AssembleElementGrad(const FiniteElement &el,
+                                    ElementTransformation &Tr,
+                                    const Vector &elfun, DenseMatrix &elmat);
+
+   /// @brief Assemble the local action of the gradient of the
+   /// NonlinearFormIntegrator resulting from a face integral term.
+   virtual void AssembleFaceGrad(const FiniteElement &el1,
+                                 const FiniteElement &el2,
+                                 FaceElementTransformations &Tr,
+                                 const Vector &elfun, DenseMatrix &elmat);
+
+   /// Indicates whether this integrator can use a Ceed backend.
+   virtual bool SupportsCeed() const { return false; }
+
+   ceed::Operator &GetCeedOp() { return *ceedOp; }
 
    virtual ~NonlinearFormIntegrator()
    {
@@ -150,6 +143,7 @@ public:
    }
 };
 
+
 /** The abstract base class BlockNonlinearFormIntegrator is
     a generalization of the NonlinearFormIntegrator class suitable
     for block state vectors. */
@@ -185,7 +179,7 @@ public:
                                  const Array<const Vector *> &elfun,
                                  const Array2D<DenseMatrix *> &elmats);
 
-   virtual ~BlockNonlinearFormIntegrator() { }
+   virtual ~BlockNonlinearFormIntegrator() {}
 };
 
 
@@ -197,8 +191,8 @@ protected:
                                     transformation. */
 
 public:
-   HyperelasticModel() : Ttr(NULL) { }
-   virtual ~HyperelasticModel() { }
+   HyperelasticModel() : Ttr(NULL) {}
+   virtual ~HyperelasticModel() {}
 
    /// A reference-element to target-element transformation that can be used to
    /// evaluate Coefficient%s.
@@ -277,7 +271,7 @@ public:
 
    NeoHookeanModel(Coefficient &mu_, Coefficient &K_, Coefficient *g_ = NULL)
       : mu(0.0), K(0.0), g(1.0), c_mu(&mu_), c_K(&K_), c_g(g_),
-        have_coeffs(true) { }
+        have_coeffs(true) {}
 
    virtual double EvalW(const DenseMatrix &J) const;
 
@@ -314,7 +308,7 @@ private:
 
 public:
    /** @param[in] m  HyperelasticModel that will be integrated. */
-   HyperelasticNLFIntegrator(HyperelasticModel *m) : model(m) { }
+   HyperelasticNLFIntegrator(HyperelasticModel *m) : model(m) {}
 
    /** @brief Computes the integral of W(Jacobian(Trt)) over a target zone
        @param[in] el     Type of FiniteElement.
@@ -333,6 +327,7 @@ public:
                                     const Vector &elfun, DenseMatrix &elmat);
 };
 
+
 /** Hyperelastic incompressible Neo-Hookean integrator with the PK1 stress
     \f$P = \mu F - p F^{-T}\f$ where \f$\mu\f$ is the shear modulus,
     \f$p\f$ is the pressure, and \f$F\f$ is the deformation gradient */
@@ -345,7 +340,7 @@ private:
    Vector Sh_p;
 
 public:
-   IncompressibleNeoHookeanIntegrator(Coefficient &mu_) : c_mu(&mu_) { }
+   IncompressibleNeoHookeanIntegrator(Coefficient &mu_) : c_mu(&mu_) {}
 
    virtual double GetElementEnergy(const Array<const FiniteElement *>&el,
                                    ElementTransformation &Tr,
@@ -371,6 +366,7 @@ private:
    Coefficient *Q{};
    DenseMatrix dshape, dshapex, EF, gradEF, ELV, elmat_comp;
    Vector shape;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;         ///< Not owned
@@ -378,7 +374,7 @@ private:
    int dim, ne, nq;
 
 public:
-   VectorConvectionNLFIntegrator(Coefficient &q): Q(&q) { }
+   VectorConvectionNLFIntegrator(Coefficient &q): Q(&q) {}
 
    VectorConvectionNLFIntegrator() = default;
 
@@ -395,14 +391,12 @@ public:
                                     const Vector &elfun,
                                     DenseMatrix &elmat);
 
-   using NonlinearFormIntegrator::AssemblePA;
-
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleMF(const FiniteElementSpace &fes);
-
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 };
 
@@ -418,7 +412,7 @@ private:
    Vector shape;
 
 public:
-   ConvectiveVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) { }
+   ConvectiveVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) {}
 
    ConvectiveVectorConvectionNLFIntegrator() = default;
 
@@ -441,7 +435,7 @@ private:
    Vector shape;
 
 public:
-   SkewSymmetricVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) { }
+   SkewSymmetricVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) {}
 
    SkewSymmetricVectorConvectionNLFIntegrator() = default;
 
diff --git a/fem/pbilinearform.cpp b/fem/pbilinearform.cpp
index ee1030c48..707473f87 100644
--- a/fem/pbilinearform.cpp
+++ b/fem/pbilinearform.cpp
@@ -19,107 +19,109 @@
 namespace mfem
 {
 
-void ParBilinearForm::pAllocMat()
-{
-   int nbr_size = pfes->GetFaceNbrVSize();
 
-   if (precompute_sparsity == 0 || fes->GetVDim() > 1)
-   {
-      if (keep_nbr_block)
-      {
-         mat = new SparseMatrix(height + nbr_size, width + nbr_size);
-      }
-      else
-      {
-         mat = new SparseMatrix(height, width + nbr_size);
-      }
-      return;
-   }
-
-   // the sparsity pattern is defined from the map: face->element->dof
-   const Table &lelem_ldof = fes->GetElementToDofTable(); // <-- dofs
-   const Table &nelem_ndof = pfes->face_nbr_element_dof; // <-- vdofs
-   Table elem_dof; // element + nbr-element <---> dof
-   if (nbr_size > 0)
-   {
-      // merge lelem_ldof and nelem_ndof into elem_dof
-      int s1 = lelem_ldof.Size(), s2 = nelem_ndof.Size();
-      const int *I1 = lelem_ldof.GetI(), *J1 = lelem_ldof.GetJ();
-      const int *I2 = nelem_ndof.GetI(), *J2 = nelem_ndof.GetJ();
-      const int nnz1 = I1[s1], nnz2 = I2[s2];
-
-      elem_dof.SetDims(s1 + s2, nnz1 + nnz2);
-
-      int *I = elem_dof.GetI(), *J = elem_dof.GetJ();
-      for (int i = 0; i <= s1; i++)
-      {
-         I[i] = I1[i];
-      }
-      for (int j = 0; j < nnz1; j++)
-      {
-         J[j] = J1[j];
-      }
-      for (int i = 0; i <= s2; i++)
-      {
-         I[s1+i] = I2[i] + nnz1;
-      }
-      for (int j = 0; j < nnz2; j++)
-      {
-         J[nnz1+j] = J2[j] + height;
-      }
-   }
-   //   dof_elem x  elem_face x face_elem x elem_dof  (keep_nbr_block = true)
-   // ldof_lelem x lelem_face x face_elem x elem_dof  (keep_nbr_block = false)
-   Table dof_dof;
-   {
-      Table face_dof; // face_elem x elem_dof
-      {
-         Table *face_elem = pfes->GetParMesh()->GetFaceToAllElementTable();
-         if (nbr_size > 0)
-         {
-            mfem::Mult(*face_elem, elem_dof, face_dof);
-         }
-         else
-         {
-            mfem::Mult(*face_elem, lelem_ldof, face_dof);
-         }
-         delete face_elem;
-         if (nbr_size > 0)
-         {
-            elem_dof.Clear();
-         }
-      }
-
-      if (keep_nbr_block)
-      {
-         Table dof_face;
-         Transpose(face_dof, dof_face, height + nbr_size);
-         mfem::Mult(dof_face, face_dof, dof_dof);
-      }
-      else
-      {
-         Table ldof_face;
-         {
-            Table face_ldof;
-            Table *face_lelem = fes->GetMesh()->GetFaceToElementTable();
-            mfem::Mult(*face_lelem, lelem_ldof, face_ldof);
-            delete face_lelem;
-            Transpose(face_ldof, ldof_face, height);
-         }
-         mfem::Mult(ldof_face, face_dof, dof_dof);
-      }
-   }
-
-   int *I = dof_dof.GetI();
-   int *J = dof_dof.GetJ();
-   int nrows = dof_dof.Size();
-   double *data = Memory<double>(I[nrows]);
-
-   mat = new SparseMatrix(I, J, data, nrows, height + nbr_size);
-   *mat = 0.0;
-
-   dof_dof.LoseData();
-}
+//XX TODO
+// void ParBilinearForm::pAllocMat()
+// {
+//    int nbr_size = pfes->GetFaceNbrVSize();
+
+//    if (precompute_sparsity == 0 || fes->GetVDim() > 1)
+//    {
+//       if (keep_nbr_block)
+//       {
+//          mat = new SparseMatrix(height + nbr_size, width + nbr_size);
+//       }
+//       else
+//       {
+//          mat = new SparseMatrix(height, width + nbr_size);
+//       }
+//       return;
+//    }
+
+//    // the sparsity pattern is defined from the map: face->element->dof
+//    const Table &lelem_ldof = fes->GetElementToDofTable(); // <-- dofs
+//    const Table &nelem_ndof = pfes->face_nbr_element_dof; // <-- vdofs
+//    Table elem_dof; // element + nbr-element <---> dof
+//    if (nbr_size > 0)
+//    {
+//       // merge lelem_ldof and nelem_ndof into elem_dof
+//       int s1 = lelem_ldof.Size(), s2 = nelem_ndof.Size();
+//       const int *I1 = lelem_ldof.GetI(), *J1 = lelem_ldof.GetJ();
+//       const int *I2 = nelem_ndof.GetI(), *J2 = nelem_ndof.GetJ();
+//       const int nnz1 = I1[s1], nnz2 = I2[s2];
+
+//       elem_dof.SetDims(s1 + s2, nnz1 + nnz2);
+
+//       int *I = elem_dof.GetI(), *J = elem_dof.GetJ();
+//       for (int i = 0; i <= s1; i++)
+//       {
+//          I[i] = I1[i];
+//       }
+//       for (int j = 0; j < nnz1; j++)
+//       {
+//          J[j] = J1[j];
+//       }
+//       for (int i = 0; i <= s2; i++)
+//       {
+//          I[s1+i] = I2[i] + nnz1;
+//       }
+//       for (int j = 0; j < nnz2; j++)
+//       {
+//          J[nnz1+j] = J2[j] + height;
+//       }
+//    }
+//    //   dof_elem x  elem_face x face_elem x elem_dof  (keep_nbr_block = true)
+//    // ldof_lelem x lelem_face x face_elem x elem_dof  (keep_nbr_block = false)
+//    Table dof_dof;
+//    {
+//       Table face_dof; // face_elem x elem_dof
+//       {
+//          Table *face_elem = pfes->GetParMesh()->GetFaceToAllElementTable();
+//          if (nbr_size > 0)
+//          {
+//             mfem::Mult(*face_elem, elem_dof, face_dof);
+//          }
+//          else
+//          {
+//             mfem::Mult(*face_elem, lelem_ldof, face_dof);
+//          }
+//          delete face_elem;
+//          if (nbr_size > 0)
+//          {
+//             elem_dof.Clear();
+//          }
+//       }
+
+//       if (keep_nbr_block)
+//       {
+//          Table dof_face;
+//          Transpose(face_dof, dof_face, height + nbr_size);
+//          mfem::Mult(dof_face, face_dof, dof_dof);
+//       }
+//       else
+//       {
+//          Table ldof_face;
+//          {
+//             Table face_ldof;
+//             Table *face_lelem = fes->GetMesh()->GetFaceToElementTable();
+//             mfem::Mult(*face_lelem, lelem_ldof, face_ldof);
+//             delete face_lelem;
+//             Transpose(face_ldof, ldof_face, height);
+//          }
+//          mfem::Mult(ldof_face, face_dof, dof_dof);
+//       }
+//    }
+
+//    int *I = dof_dof.GetI();
+//    int *J = dof_dof.GetJ();
+//    int nrows = dof_dof.Size();
+//    double *data = Memory<double>(I[nrows]);
+
+//    mat = new SparseMatrix(I, J, data, nrows, height + nbr_size);
+//    *mat = 0.0;
+
+//    dof_dof.LoseData();
+// }
 
 void ParBilinearForm::ParallelRAP(SparseMatrix &loc_A, OperatorHandle &A,
                                   bool steal_loc_A)
@@ -151,7 +153,8 @@ void ParBilinearForm::ParallelRAP(SparseMatrix &loc_A, OperatorHandle &A,
    }
 }
 
-void ParBilinearForm::ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local)
+void ParBilinearForm::ParallelAssemble(OperatorHandle &A,
+                                       SparseMatrix *A_local) const
 {
    A.Clear();
 
@@ -201,6 +204,7 @@ void ParBilinearForm::ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local)
 
    // TODO - assemble the Dof_TrueDof_Matrix directly in the required format?
    Ph.ConvertFrom(pfes->Dof_TrueDof_Matrix());
+
    // TODO: When Ph.Type() == Operator::ANY_TYPE we want to use the Operator
    // returned by pfes->GetProlongationMatrix(), however that Operator is a
    // const Operator, so we cannot store it in OperatorHandle. We need a const
@@ -209,7 +213,7 @@ void ParBilinearForm::ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local)
    A.MakePtAP(dA, Ph);
 }
 
-HypreParMatrix *ParBilinearForm::ParallelAssemble(SparseMatrix *m)
+HypreParMatrix *ParBilinearForm::ParallelAssemble(SparseMatrix *m) const
 {
    OperatorHandle Mh(Operator::Hypre_ParCSR);
    ParallelAssemble(Mh, m);
@@ -246,10 +250,9 @@ void ParBilinearForm::AssembleSharedFaces(int skip_zeros)
       vdofs_all.Append(vdofs2);
       for (int k = 0; k < interior_face_integs.Size(); k++)
       {
-         interior_face_integs[k]->
-         AssembleFaceMatrix(*pfes->GetFE(T->Elem1No),
-                            *pfes->GetFaceNbrFE(Elem2NbrNo),
-                            *T, elemmat);
+         interior_face_integs[k]->AssembleFaceMatrix(*pfes->GetFE(T->Elem1No),
+                                                     *pfes->GetFaceNbrFE(Elem2NbrNo),
+                                                     *T, elemmat);
          if (keep_nbr_block)
          {
             mat->AddSubMatrix(vdofs_all, vdofs_all, elemmat, skip_zeros);
@@ -269,7 +272,15 @@ void ParBilinearForm::Assemble(int skip_zeros)
       pfes->ExchangeFaceNbrData();
       if (!ext && mat == NULL)
       {
-         pAllocMat();
+         int nbr_size = pfes->GetFaceNbrVSize();
+         if (keep_nbr_block)
+         {
+            mat = new SparseMatrix(height + nbr_size, width + nbr_size);
+         }
+         else
+         {
+            mat = new SparseMatrix(height, width + nbr_size);
+         }
       }
    }
 
@@ -301,29 +312,23 @@ void ParBilinearForm::AssembleDiagonal(Vector &diag) const
    // Here, we have extension, ext, and parallel/conforming prolongation, P.
    Vector local_diag(P->Height());
    ext->AssembleDiagonal(local_diag);
-   if (fes->Conforming())
+   const HypreParMatrix *HP = dynamic_cast<const HypreParMatrix*>(P);
+   if (!HP)
    {
+      // This is a parallel prolongation
       P->MultTranspose(local_diag, diag);
       return;
    }
    // For an AMR mesh, a convergent diagonal is assembled with |P^T| d_l,
    // where |P^T| has the entry-wise absolute values of the conforming
    // prolongation transpose operator.
-   const HypreParMatrix *HP = dynamic_cast<const HypreParMatrix*>(P);
-   if (HP)
-   {
-      HP->AbsMultTranspose(1.0, local_diag, 0.0, diag);
-   }
-   else
-   {
-      MFEM_ABORT("unsupported prolongation matrix type.");
-   }
+   HP->AbsMultTranspose(1.0, local_diag, 0.0, diag);
 }
 
-void ParBilinearForm
-::ParallelEliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
-                               HypreParMatrix &A, const HypreParVector &X,
-                               HypreParVector &B) const
+void ParBilinearForm::ParallelEliminateEssentialBC(
+   const Array<int> &bdr_attr_is_ess,
+   HypreParMatrix &A, const HypreParVector &X,
+   HypreParVector &B) const
 {
    Array<int> dof_list;
 
@@ -333,9 +338,9 @@ void ParBilinearForm
    A.EliminateRowsCols(dof_list, X, B);
 }
 
-HypreParMatrix *ParBilinearForm::
-ParallelEliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
-                             HypreParMatrix &A) const
+HypreParMatrix *ParBilinearForm::ParallelEliminateEssentialBC(
+   const Array<int> &bdr_attr_is_ess,
+   HypreParMatrix &A) const
 {
    Array<int> dof_list;
 
@@ -374,7 +379,17 @@ void ParBilinearForm::FormLinearSystem(
 {
    if (ext)
    {
-      ext->FormLinearSystem(ess_tdof_list, x, b, A, X, B, copy_interior);
+      Operator *oper;
+      ext->FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         delete oper;
+         FormSystemMatrix(ess_tdof_list, A);
+      }
+      else
+      {
+         A.Reset(oper);
+      }
       return;
    }
 
@@ -418,18 +433,28 @@ void ParBilinearForm::FormLinearSystem(
    }
 }
 
-void ParBilinearForm::EliminateVDofsInRHS(
-   const Array<int> &vdofs, const Vector &x, Vector &b)
-{
-   p_mat.EliminateBC(p_mat_e, vdofs, x, b);
-}
-
 void ParBilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
                                        OperatorHandle &A)
 {
    if (ext)
    {
-      ext->FormSystemMatrix(ess_tdof_list, A);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         // Always does `DIAG_ONE` policy to be consistent with
+         // `Operator::FormConstrainedSystemOperator`.
+         MFEM_VERIFY(diag_policy == DiagonalPolicy::DIAG_ONE,
+                     "Only DiagonalPolicy::DIAG_ONE supported with"
+                     " FABilinearFormExtension.");
+         ParallelRAP(*mat, A);
+         A.As<HypreParMatrix>()->EliminateBC(ess_tdof_list,
+                                             DiagonalPolicy::DIAG_ONE);
+      }
+      else
+      {
+         Operator *oper;
+         ext->FormSystemOperator(ess_tdof_list, oper);
+         A.Reset(oper);
+      }
       return;
    }
 
@@ -460,6 +485,7 @@ void ParBilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
          delete mat_e;
          mat_e = NULL;
          p_mat_e.EliminateRowsCols(p_mat, ess_tdof_list);
+         A = p_mat;
       }
       if (hybridization)
       {
@@ -521,30 +547,22 @@ void ParBilinearForm::Update(FiniteElementSpace *nfes)
    p_mat_e.Clear();
 }
 
-
-HypreParMatrix *ParMixedBilinearForm::ParallelAssemble()
+void ParBilinearForm::EliminateVDofsInRHS(
+   const Array<int> &vdofs, const Vector &x, Vector &b)
 {
-   // construct the block-diagonal matrix A
-   HypreParMatrix *A =
-      new HypreParMatrix(trial_pfes->GetComm(),
-                         test_pfes->GlobalVSize(),
-                         trial_pfes->GlobalVSize(),
-                         test_pfes->GetDofOffsets(),
-                         trial_pfes->GetDofOffsets(),
-                         mat);
+   p_mat.EliminateBC(p_mat_e, vdofs, x, b);
+}
 
-   HypreParMatrix *rap = RAP(test_pfes->Dof_TrueDof_Matrix(), A,
-                             trial_pfes->Dof_TrueDof_Matrix());
+void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A) const
+{
+   A.Clear();
 
-   delete A;
+   if (mat == NULL) { return; }
+   MFEM_VERIFY(mat->Finalized(), "the local matrix must be finalized");
 
-   return rap;
-}
+   OperatorHandle dA(A.Type()), P_test(A.Type()), P_trial(A.Type());
 
-void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A)
-{
    // construct the rectangular block-diagonal matrix dA
-   OperatorHandle dA(A.Type());
    dA.MakeRectangularBlockDiag(trial_pfes->GetComm(),
                                test_pfes->GlobalVSize(),
                                trial_pfes->GlobalVSize(),
@@ -552,8 +570,6 @@ void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A)
                                trial_pfes->GetDofOffsets(),
                                mat);
 
-   OperatorHandle P_test(A.Type()), P_trial(A.Type());
-
    // TODO - construct the Dof_TrueDof_Matrix directly in the required format.
    P_test.ConvertFrom(test_pfes->Dof_TrueDof_Matrix());
    P_trial.ConvertFrom(trial_pfes->Dof_TrueDof_Matrix());
@@ -561,6 +577,14 @@ void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A)
    A.MakeRAP(P_test, dA, P_trial);
 }
 
+HypreParMatrix *ParMixedBilinearForm::ParallelAssemble() const
+{
+   OperatorHandle Mh(Operator::Hypre_ParCSR);
+   ParallelAssemble(Mh);
+   Mh.SetOperatorOwner(false);
+   return Mh.As<HypreParMatrix>();
+}
+
 /// Compute y += a (P^t A P) x, where x and y are vectors on the true dofs
 void ParMixedBilinearForm::TrueAddMult(const Vector &x, Vector &y,
                                        const double a) const
@@ -576,21 +600,55 @@ void ParMixedBilinearForm::TrueAddMult(const Vector &x, Vector &y,
    test_pfes->Dof_TrueDof_Matrix()->MultTranspose(a, Yaux, 1.0, y);
 }
 
+void ParMixedBilinearForm::FormRectangularLinearSystem(
+   const Array<int> &trial_tdof_list,
+   const Array<int> &test_tdof_list, Vector &x,
+   Vector &b, OperatorHandle &A, Vector &X,
+   Vector &B)
+{
+   if (ext)
+   {
+      Operator *oper;
+      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
+                                       x, b, oper, X, B);
+      A.Reset(oper);
+      return;
+   }
+
+   FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, A);
+
+   const Operator *test_P = test_pfes->GetProlongationMatrix();
+   const SparseMatrix *trial_R = trial_pfes->GetRestrictionMatrix();
+
+   X.SetSize(trial_pfes->TrueVSize());
+   B.SetSize(test_pfes->TrueVSize());
+   test_P->MultTranspose(b, B);
+   trial_R->Mult(x, X);
+
+   p_mat_e.As<HypreParMatrix>()->Mult(-1.0, X, 1.0, B);
+   B.SetSubVector(test_tdof_list, 0.0);
+}
+
 void ParMixedBilinearForm::FormRectangularSystemMatrix(
-   const Array<int>
-   &trial_tdof_list,
+   const Array<int> &trial_tdof_list,
    const Array<int> &test_tdof_list,
    OperatorHandle &A)
 {
    if (ext)
    {
-      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, A);
+      Operator *oper;
+      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, oper);
+      A.Reset(oper);
       return;
    }
 
    if (mat)
    {
-      Finalize();
+      const int remove_zeros = 0;
+      Finalize(remove_zeros);
+      MFEM_VERIFY(p_mat.Ptr() == NULL && p_mat_e.Ptr() == NULL,
+                  "The ParMixedBilinearFormBilinearForm must be updated "
+                  "with Update() before re-assembling the ParMixedBilinearFormBilinearForm.");
       ParallelAssemble(p_mat);
       delete mat;
       mat = NULL;
@@ -600,97 +658,89 @@ void ParMixedBilinearForm::FormRectangularSystemMatrix(
          p_mat.As<HypreParMatrix>()->EliminateCols(trial_tdof_list);
       p_mat.As<HypreParMatrix>()->EliminateRows(test_tdof_list);
       p_mat_e.Reset(temp, true);
+      A = p_mat;
    }
-
-   A = p_mat;
 }
 
-void ParMixedBilinearForm::FormRectangularLinearSystem(
-   const Array<int>
-   &trial_tdof_list,
-   const Array<int> &test_tdof_list, Vector &x,
-   Vector &b, OperatorHandle &A, Vector &X,
-   Vector &B)
+void ParDiscreteLinearOperator::ParallelAssemble(OperatorHandle &A) const
 {
-   if (ext)
+   A.Clear();
+
+   if (mat == NULL) { return; }
+   MFEM_VERIFY(mat->Finalized(), "the local matrix must be finalized");
+
+   if (A.Type() == Operator::Hypre_ParCSR)
    {
-      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
-                                       x, b, A, X, B);
-      return;
+      const SparseMatrix *R = range_fes->GetRestrictionMatrix();
+      const HypreParMatrix *P = domain_fes->Dof_TrueDof_Matrix();
+      SparseMatrix *RA = mfem::Mult(*R, *mat);
+      A.Reset(P->LeftDiagMult(*RA, range_fes->GetTrueDofOffsets()));
+      delete RA;
    }
+   else
+   {
+      OperatorHandle dA(A.Type()), P_trial(A.Type()), Rt_test(A.Type());
 
-   FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, A);
-
-   const Operator *test_P = test_pfes->GetProlongationMatrix();
-   const SparseMatrix *trial_R = trial_pfes->GetRestrictionMatrix();
+      // construct the rectangular block-diagonal matrix dA
+      dA.MakeRectangularBlockDiag(domain_fes->GetComm(),
+                                  range_fes->GlobalVSize(),
+                                  domain_fes->GlobalVSize(),
+                                  range_fes->GetDofOffsets(),
+                                  domain_fes->GetDofOffsets(),
+                                  mat);
 
-   X.SetSize(trial_pfes->TrueVSize());
-   B.SetSize(test_pfes->TrueVSize());
-   test_P->MultTranspose(b, B);
-   trial_R->Mult(x, X);
+      SparseMatrix *Rt = Transpose(*range_fes->GetRestrictionMatrix());
+      Rt_test.MakeRectangularBlockDiag(range_fes->GetComm(),
+                                       range_fes->GlobalVSize(),
+                                       range_fes->GlobalTrueVSize(),
+                                       range_fes->GetDofOffsets(),
+                                       range_fes->GetTrueDofOffsets(),
+                                       Rt);
 
-   p_mat_e.As<HypreParMatrix>()->Mult(-1.0, X, 1.0, B);
-   B.SetSubVector(test_tdof_list, 0.0);
-}
+      // TODO - construct the Dof_TrueDof_Matrix directly in the required format.
+      P_trial.ConvertFrom(domain_fes->Dof_TrueDof_Matrix());
 
-HypreParMatrix* ParDiscreteLinearOperator::ParallelAssemble() const
-{
-   MFEM_ASSERT(mat, "Matrix is not assembled");
-   MFEM_ASSERT(mat->Finalized(), "Matrix is not finalized");
-   SparseMatrix* RA = mfem::Mult(*range_fes->GetRestrictionMatrix(), *mat);
-   HypreParMatrix* P = domain_fes->Dof_TrueDof_Matrix();
-   HypreParMatrix* RAP = P->LeftDiagMult(*RA, range_fes->GetTrueDofOffsets());
-   delete RA;
-   return RAP;
+      A.MakeRAP(Rt_test, dA, P_trial);
+      delete Rt;
+   }
 }
 
-void ParDiscreteLinearOperator::ParallelAssemble(OperatorHandle &A)
+HypreParMatrix *ParDiscreteLinearOperator::ParallelAssemble() const
 {
-   // construct the rectangular block-diagonal matrix dA
-   OperatorHandle dA(A.Type());
-   dA.MakeRectangularBlockDiag(domain_fes->GetComm(),
-                               range_fes->GlobalVSize(),
-                               domain_fes->GlobalVSize(),
-                               range_fes->GetDofOffsets(),
-                               domain_fes->GetDofOffsets(),
-                               mat);
-
-   SparseMatrix *Rt = Transpose(*range_fes->GetRestrictionMatrix());
-   OperatorHandle R_test_transpose(A.Type());
-   R_test_transpose.MakeRectangularBlockDiag(range_fes->GetComm(),
-                                             range_fes->GlobalVSize(),
-                                             range_fes->GlobalTrueVSize(),
-                                             range_fes->GetDofOffsets(),
-                                             range_fes->GetTrueDofOffsets(),
-                                             Rt);
-
-   // TODO - construct the Dof_TrueDof_Matrix directly in the required format.
-   OperatorHandle P_trial(A.Type());
-   P_trial.ConvertFrom(domain_fes->Dof_TrueDof_Matrix());
-
-   A.MakeRAP(R_test_transpose, dA, P_trial);
-   delete Rt;
+   OperatorHandle Mh(Operator::Hypre_ParCSR);
+   ParallelAssemble(Mh);
+   Mh.SetOperatorOwner(false);
+   return Mh.As<HypreParMatrix>();
 }
 
-void ParDiscreteLinearOperator::FormRectangularSystemMatrix(OperatorHandle &A)
+void ParDiscreteLinearOperator::FormDiscreteOperatorMatrix(OperatorHandle &A)
 {
    if (ext)
    {
-      Array<int> empty;
-      ext->FormRectangularSystemOperator(empty, empty, A);
+      Operator *oper;
+      ext->FormDiscreteOperator(oper);
+      A.Reset(oper);
       return;
    }
 
-   mfem_error("not implemented!");
+   if (mat)
+   {
+      Finalize();
+      ParallelAssemble(A);
+      delete mat;
+      mat = NULL;
+      delete mat_e;
+      mat_e = NULL;
+   }
 }
 
-void ParDiscreteLinearOperator::GetParBlocks(Array2D<HypreParMatrix *> &blocks)
-const
+void ParDiscreteLinearOperator::GetParBlocks(
+   Array2D<HypreParMatrix *> &blocks)
 {
    MFEM_VERIFY(mat->Finalized(), "Local matrix needs to be finalized for "
                "GetParBlocks");
 
-   HypreParMatrix* RLP = ParallelAssemble();
+   HypreParMatrix *RLP = ParallelAssemble();
 
    blocks.SetSize(range_fes->GetVDim(), domain_fes->GetVDim());
 
diff --git a/fem/pbilinearform.hpp b/fem/pbilinearform.hpp
index c8fef567b..be8e50ca3 100644
--- a/fem/pbilinearform.hpp
+++ b/fem/pbilinearform.hpp
@@ -28,27 +28,31 @@ namespace mfem
 class ParBilinearForm : public BilinearForm
 {
    friend FABilinearFormExtension;
+
 protected:
-   ParFiniteElementSpace *pfes; ///< Points to the same object as #fes
+   ///< Points to the same object as #fes
+   ParFiniteElementSpace *pfes;
 
    /// Auxiliary vectors used in TrueAddMult(): L-, L-, and T-vector, resp.
    mutable Vector Xaux, Yaux, Ytmp;
 
+   /// Matrix and eliminated matrix
    OperatorHandle p_mat, p_mat_e;
 
    bool keep_nbr_block;
 
-   // Allocate mat - called when (mat == NULL && fbfi.Size() > 0)
-   void pAllocMat();
+   //XX TODO
+   // // Allocate mat - called when (mat == NULL && fbfi.Size() > 0)
+   // void pAllocMat();
 
    void AssembleSharedFaces(int skip_zeros = 1);
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   ParBilinearForm(const ParBilinearForm &);
+   /// Copy construction is not supported.
+   ParBilinearForm(const ParBilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   ParBilinearForm &operator=(const ParBilinearForm &);
+   /// Copy assignment is not supported.
+   ParBilinearForm &operator=(const ParBilinearForm &) = delete;
 
 public:
    /// Creates parallel bilinear form associated with the FE space @a *pf.
@@ -103,40 +107,40 @@ public:
 
    /// Returns the matrix assembled on the true dofs, i.e. P^t A P.
    /** The returned matrix has to be deleted by the caller. */
-   HypreParMatrix *ParallelAssemble() { return ParallelAssemble(mat); }
+   HypreParMatrix *ParallelAssemble() const { return ParallelAssemble(mat); }
 
    /// Returns the eliminated matrix assembled on the true dofs, i.e. P^t A_e P.
    /** The returned matrix has to be deleted by the caller. */
-   HypreParMatrix *ParallelAssembleElim() { return ParallelAssemble(mat_e); }
+   HypreParMatrix *ParallelAssembleElim() const { return ParallelAssemble(mat_e); }
 
    /// Return the matrix @a m assembled on the true dofs, i.e. P^t A P.
    /** The returned matrix has to be deleted by the caller. */
-   HypreParMatrix *ParallelAssemble(SparseMatrix *m);
-
-   /** @brief Compute parallel RAP operator and store it in @a A as a HypreParMatrix.
-
-       @param[in] loc_A The rank-local `SparseMatrix`.
-       @param[out] A The `OperatorHandle` containing the global `HypreParMatrix`.
-       @param[in] steal_loc_A Have the `HypreParMatrix` in @a A take ownership of
-                              the memory objects in @a loc_A.
-       */
-   void ParallelRAP(SparseMatrix &loc_A,
-                    OperatorHandle &A,
-                    bool steal_loc_A = false);
+   HypreParMatrix *ParallelAssemble(SparseMatrix *m) const;
 
    /** @brief Returns the matrix assembled on the true dofs, i.e.
        @a A = P^t A_local P, in the format (type id) specified by @a A. */
-   void ParallelAssemble(OperatorHandle &A) { ParallelAssemble(A, mat); }
+   void ParallelAssemble(OperatorHandle &A) const { ParallelAssemble(A, mat); }
 
    /** Returns the eliminated matrix assembled on the true dofs, i.e.
        @a A_elim = P^t A_elim_local P in the format (type id) specified by @a A.
     */
-   void ParallelAssembleElim(OperatorHandle &A_elim)
+   void ParallelAssembleElim(OperatorHandle &A_elim) const
    { ParallelAssemble(A_elim, mat_e); }
 
    /** Returns the matrix @a A_local assembled on the true dofs, i.e.
        @a A = P^t A_local P in the format (type id) specified by @a A. */
-   void ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local);
+   void ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local) const;
+
+   /** @brief Compute parallel RAP operator and store it in @a A as a HypreParMatrix.
+
+       @param[in] loc_A The rank-local `SparseMatrix`.
+       @param[out] A The `OperatorHandle` containing the global `HypreParMatrix`.
+       @param[in] steal_loc_A Have the `HypreParMatrix` in @a A take ownership of
+                              the memory objects in @a loc_A.
+       */
+   void ParallelRAP(SparseMatrix &loc_A,
+                    OperatorHandle &A,
+                    bool steal_loc_A = false);
 
    /// Eliminate essential boundary DOFs from a parallel assembled system.
    /** The array @a bdr_attr_is_ess marks boundary attributes that constitute
@@ -183,9 +187,7 @@ public:
    /// Get the parallel finite element space prolongation matrix
    virtual const Operator *GetProlongation() const
    { return pfes->GetProlongationMatrix(); }
-   /// Get the transpose of GetRestriction, useful for matrix-free RAP
-   virtual const Operator *GetRestrictionTranspose() const
-   { return pfes->GetRestrictionTransposeOperator(); }
+
    /// Get the parallel finite element space restriction matrix
    virtual const Operator *GetRestriction() const
    { return pfes->GetRestrictionMatrix(); }
@@ -209,7 +211,7 @@ public:
 
    void EliminateVDofsInRHS(const Array<int> &vdofs, const Vector &x, Vector &b);
 
-   virtual ~ParBilinearForm() { }
+   virtual ~ParBilinearForm() {}
 };
 
 /// Class for parallel bilinear form using different test and trial FE spaces.
@@ -220,6 +222,7 @@ protected:
    ParFiniteElementSpace *trial_pfes;
    /// Points to the same object as #test_fes
    ParFiniteElementSpace *test_pfes;
+
    /// Auxiliary objects used in TrueAddMult().
    mutable ParGridFunction Xaux, Yaux;
 
@@ -227,11 +230,11 @@ protected:
    OperatorHandle p_mat, p_mat_e;
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   ParMixedBilinearForm(const ParMixedBilinearForm &);
+   /// Copy construction is not supported.
+   ParMixedBilinearForm(const ParMixedBilinearForm &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   ParMixedBilinearForm &operator=(const ParMixedBilinearForm &);
+   /// Copy assignment is not supported.
+   ParMixedBilinearForm &operator=(const ParMixedBilinearForm &) = delete;
 
 public:
    /** @brief Construct a ParMixedBilinearForm on the given FiniteElementSpace%s
@@ -258,7 +261,7 @@ public:
        by the newly constructed ParMixedBilinearForm. */
    ParMixedBilinearForm(ParFiniteElementSpace *trial_fes,
                         ParFiniteElementSpace *test_fes,
-                        ParMixedBilinearForm * mbf)
+                        ParMixedBilinearForm *mbf)
       : MixedBilinearForm(trial_fes, test_fes, mbf),
         p_mat(Operator::Hypre_ParCSR), p_mat_e(Operator::Hypre_ParCSR)
    {
@@ -267,24 +270,16 @@ public:
    }
 
    /// Returns the matrix assembled on the true dofs, i.e. P_test^t A P_trial.
-   HypreParMatrix *ParallelAssemble();
+   HypreParMatrix *ParallelAssemble() const;
 
    /** @brief Returns the matrix assembled on the true dofs, i.e.
        @a A = P_test^t A_local P_trial, in the format (type id) specified by
        @a A. */
-   void ParallelAssemble(OperatorHandle &A);
+   void ParallelAssemble(OperatorHandle &A) const;
 
    using MixedBilinearForm::FormRectangularSystemMatrix;
    using MixedBilinearForm::FormRectangularLinearSystem;
 
-   /** @brief Return in @a A a parallel (on truedofs) version of this operator.
-
-       This returns the same operator as FormRectangularLinearSystem(), but does
-       without the transformations of the right-hand side. */
-   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
-                                            const Array<int> &test_tdof_list,
-                                            OperatorHandle &A);
-
    /** @brief Form the parallel linear system A X = B, corresponding to this mixed
        bilinear form and the linear form @a b(.).
 
@@ -296,10 +291,18 @@ public:
                                             Vector &b, OperatorHandle &A, Vector &X,
                                             Vector &B);
 
+   /** @brief Return in @a A a parallel (on truedofs) version of this operator.
+
+       This returns the same operator as FormRectangularLinearSystem(), but does
+       without the transformations of the right-hand side. */
+   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
+                                            const Array<int> &test_tdof_list,
+                                            OperatorHandle &A);
+
    /// Compute y += a (P^t A P) x, where x and y are vectors on the true dofs
    void TrueAddMult(const Vector &x, Vector &y, const double a = 1.0) const;
 
-   virtual ~ParMixedBilinearForm() { }
+   virtual ~ParMixedBilinearForm() {}
 };
 
 /** The parallel matrix representation a linear operator between parallel finite
@@ -313,11 +316,12 @@ protected:
    ParFiniteElementSpace *range_fes;
 
 private:
-   /// Copy construction is not supported; body is undefined.
-   ParDiscreteLinearOperator(const ParDiscreteLinearOperator &);
+   /// Copy construction is not supported.
+   ParDiscreteLinearOperator(const ParDiscreteLinearOperator &) = delete;
 
-   /// Copy assignment is not supported; body is undefined.
-   ParDiscreteLinearOperator &operator=(const ParDiscreteLinearOperator &);
+   /// Copy assignment is not supported.
+   ParDiscreteLinearOperator &operator=(const ParDiscreteLinearOperator &) =
+      delete;
 
 public:
    /** @brief Construct a ParDiscreteLinearOperator on the given
@@ -327,7 +331,11 @@ public:
        object. */
    ParDiscreteLinearOperator(ParFiniteElementSpace *dfes,
                              ParFiniteElementSpace *rfes)
-      : DiscreteLinearOperator(dfes, rfes) { domain_fes=dfes; range_fes=rfes; }
+      : DiscreteLinearOperator(dfes, rfes)
+   {
+      domain_fes = dfes;
+      range_fes = rfes;
+   }
 
    /// Returns the matrix "assembled" on the true dofs
    HypreParMatrix *ParallelAssemble() const;
@@ -335,18 +343,18 @@ public:
    /** @brief Returns the matrix assembled on the true dofs, i.e.
        @a A = R_test A_local P_trial, in the format (type id) specified by
        @a A. */
-   void ParallelAssemble(OperatorHandle &A);
+   void ParallelAssemble(OperatorHandle &A) const;
 
-   /** Extract the parallel blocks corresponding to the vector dimensions of the
-       domain and range parallel finite element spaces */
-   void GetParBlocks(Array2D<HypreParMatrix *> &blocks) const;
-
-   using MixedBilinearForm::FormRectangularSystemMatrix;
+   using DiscreteLinearOperator::FormDiscreteOperatorMatrix;
 
    /** @brief Return in @a A a parallel (on truedofs) version of this operator. */
-   virtual void FormRectangularSystemMatrix(OperatorHandle &A);
+   virtual void FormDiscreteOperatorMatrix(OperatorHandle &A);
+
+   /** Extract the parallel blocks corresponding to the vector dimensions of the
+       domain and range parallel finite element spaces */
+   void GetParBlocks(Array2D<HypreParMatrix *> &blocks);
 
-   virtual ~ParDiscreteLinearOperator() { }
+   virtual ~ParDiscreteLinearOperator() {}
 };
 
 }
diff --git a/fem/pfespace.cpp b/fem/pfespace.cpp
index 6f0af11c6..d74e08580 100644
--- a/fem/pfespace.cpp
+++ b/fem/pfespace.cpp
@@ -101,8 +101,6 @@ void ParFiniteElementSpace::ParInit(ParMesh *pm)
    P = NULL;
    Pconf = NULL;
    nonconf_P = false;
-   Rconf = NULL;
-   R_transpose = NULL;
    R = NULL;
 
    num_face_nbr_dofs = -1;
@@ -961,6 +959,34 @@ void ParFiniteElementSpace::Build_Dof_TrueDof_Matrix() const // matrix P
    R = Transpose(Pdiag);
 }
 
+const Operator *ParFiniteElementSpace::GetProlongationMatrix() const
+{
+   if (Conforming() && !nd_strias)
+   {
+      if (Pconf) { return Pconf; }
+      if (NRanks == 1)
+      {
+         Pconf = new IdentityOperator(GetTrueVSize());
+      }
+      else
+      {
+         if (!Device::Allows(Backend::DEVICE_MASK))
+         {
+            Pconf = new ConformingProlongationOperator(*this);
+         }
+         else
+         {
+            Pconf = new DeviceConformingProlongationOperator(*this);
+         }
+      }
+      return Pconf;
+   }
+   else
+   {
+      return Dof_TrueDof_Matrix();
+   }
+}
+
 HypreParMatrix *ParFiniteElementSpace::GetPartialConformingInterpolation()
 {
    HypreParMatrix *P_pc;
@@ -1150,76 +1176,6 @@ HYPRE_BigInt ParFiniteElementSpace::GetMyTDofOffset() const
    return HYPRE_AssumedPartitionCheck()? tdof_offsets[0] : tdof_offsets[MyRank];
 }
 
-const Operator *ParFiniteElementSpace::GetProlongationMatrix() const
-{
-   if (Conforming())
-   {
-      if (Pconf) { return Pconf; }
-
-      if (nd_strias) { return Dof_TrueDof_Matrix(); }
-
-      if (NRanks == 1)
-      {
-         Pconf = new IdentityOperator(GetTrueVSize());
-      }
-      else
-      {
-         if (!Device::Allows(Backend::DEVICE_MASK))
-         {
-            Pconf = new ConformingProlongationOperator(*this);
-         }
-         else
-         {
-            Pconf = new DeviceConformingProlongationOperator(*this);
-         }
-      }
-      return Pconf;
-   }
-   else
-   {
-      return Dof_TrueDof_Matrix();
-   }
-}
-
-const Operator *ParFiniteElementSpace::GetRestrictionOperator() const
-{
-   if (Conforming())
-   {
-      if (Rconf) { return Rconf; }
-
-      if (NRanks == 1)
-      {
-         R_transpose = new IdentityOperator(GetTrueVSize());
-      }
-      else
-      {
-         if (!Device::Allows(Backend::DEVICE_MASK))
-         {
-            R_transpose = new ConformingProlongationOperator(*this, true);
-         }
-         else
-         {
-            R_transpose =
-               new DeviceConformingProlongationOperator(*this, true);
-         }
-      }
-      Rconf = new TransposeOperator(R_transpose);
-      return Rconf;
-   }
-   else
-   {
-      Dof_TrueDof_Matrix();
-      R_transpose = new TransposeOperator(R);
-      return R;
-   }
-}
-
-const Operator *ParFiniteElementSpace::GetRestrictionTransposeOperator() const
-{
-   GetRestrictionOperator();
-   return R_transpose;
-}
-
 void ParFiniteElementSpace::ExchangeFaceNbrData()
 {
    if (num_face_nbr_dofs >= 0) { return; }
@@ -3186,8 +3142,6 @@ void ParFiniteElementSpace::Destroy()
 
    delete P; P = NULL;
    delete Pconf; Pconf = NULL;
-   delete Rconf; Rconf = NULL;
-   delete R_transpose; R_transpose = NULL;
    delete R; R = NULL;
 
    delete gcomm; gcomm = NULL;
@@ -3393,8 +3347,8 @@ void ParFiniteElementSpace::UpdateMeshPointer(Mesh *new_mesh)
 }
 
 ConformingProlongationOperator::ConformingProlongationOperator(
-   int lsize, const GroupCommunicator &gc_, bool local_)
-   : gc(gc_), local(local_)
+   int lsize, const GroupCommunicator &gc_)
+   : gc(gc_)
 {
    const Table &group_ldof = gc.GroupLDofTable();
 
@@ -3429,11 +3383,10 @@ const
 }
 
 ConformingProlongationOperator::ConformingProlongationOperator(
-   const ParFiniteElementSpace &pfes, bool local_)
+   const ParFiniteElementSpace &pfes)
    : Operator(pfes.GetVSize(), pfes.GetTrueVSize()),
      external_ldofs(),
-     gc(pfes.GroupComm()),
-     local(local_)
+     gc(pfes.GroupComm())
 {
    MFEM_VERIFY(pfes.Conforming(), "");
    const Table &group_ldof = gc.GroupLDofTable();
@@ -3482,14 +3435,7 @@ void ConformingProlongationOperator::Mult(const Vector &x, Vector &y) const
    const int m = external_ldofs.Size();
 
    const int in_layout = 2; // 2 - input is ltdofs array
-   if (local)
-   {
-      y = 0.0;
-   }
-   else
-   {
-      gc.BcastBegin(const_cast<double*>(xdata), in_layout);
-   }
+   gc.BcastBegin(const_cast<double*>(xdata), in_layout);
 
    int j = 0;
    for (int i = 0; i < m; i++)
@@ -3501,10 +3447,7 @@ void ConformingProlongationOperator::Mult(const Vector &x, Vector &y) const
    std::copy(xdata+j-m, xdata+Width(), ydata+j);
 
    const int out_layout = 0; // 0 - output is ldofs array
-   if (!local)
-   {
-      gc.BcastEnd(ydata, out_layout);
-   }
+   gc.BcastEnd(ydata, out_layout);
 }
 
 void ConformingProlongationOperator::MultTranspose(
@@ -3517,10 +3460,7 @@ void ConformingProlongationOperator::MultTranspose(
    double *ydata = y.HostWrite();
    const int m = external_ldofs.Size();
 
-   if (!local)
-   {
-      gc.ReduceBegin(xdata);
-   }
+   gc.ReduceBegin(xdata);
 
    int j = 0;
    for (int i = 0; i < m; i++)
@@ -3532,15 +3472,12 @@ void ConformingProlongationOperator::MultTranspose(
    std::copy(xdata+j, xdata+Height(), ydata+j-m);
 
    const int out_layout = 2; // 2 - output is an array on all ltdofs
-   if (!local)
-   {
-      gc.ReduceEnd<double>(ydata, out_layout, GroupCommunicator::Sum);
-   }
+   gc.ReduceEnd<double>(ydata, out_layout, GroupCommunicator::Sum);
 }
 
 DeviceConformingProlongationOperator::DeviceConformingProlongationOperator(
-   const GroupCommunicator &gc_, const SparseMatrix *R, bool local_)
-   : ConformingProlongationOperator(R->Width(), gc_, local_),
+   const GroupCommunicator &gc_, const SparseMatrix *R)
+   : ConformingProlongationOperator(R->Width(), gc_),
      mpi_gpu_aware(Device::GetGPUAwareMPI())
 {
    MFEM_ASSERT(R->Finalized(), "");
@@ -3605,10 +3542,9 @@ DeviceConformingProlongationOperator::DeviceConformingProlongationOperator(
 }
 
 DeviceConformingProlongationOperator::DeviceConformingProlongationOperator(
-   const ParFiniteElementSpace &pfes, bool local_)
+   const ParFiniteElementSpace &pfes)
    : DeviceConformingProlongationOperator(pfes.GroupComm(),
-                                          pfes.GetRestrictionMatrix(),
-                                          local_)
+                                          pfes.GetRestrictionMatrix())
 {
    MFEM_ASSERT(pfes.Conforming(), "internal error");
    MFEM_ASSERT(pfes.GetRestrictionMatrix()->Height() == pfes.GetTrueVSize(), "");
@@ -3672,48 +3608,36 @@ void DeviceConformingProlongationOperator::Mult(const Vector &x,
                                                 Vector &y) const
 {
    const GroupTopology &gtopo = gc.GetGroupTopology();
-   int req_counter = 0;
    // Make sure 'y' is marked as valid on device and for use on device.
    // This ensures that there is no unnecessary host to device copy when the
-   // input 'y' is valid on host (in 'y.SetSubVector(ext_ldof, 0.0)' when local
-   // is true) or BcastLocalCopy (when local is false).
+   // input 'y' is valid on host.
    y.Write();
-   if (local)
-   {
-      // done on device since we've marked ext_ldof for use on device:
-      y.SetSubVector(ext_ldof, 0.0);
-   }
-   else
+   BcastBeginCopy(x); // copy to 'shr_buf'
+   int req_counter = 0;
+   for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
    {
-      BcastBeginCopy(x); // copy to 'shr_buf'
-      for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
+      const int send_offset = shr_buf_offsets[nbr];
+      const int send_size = shr_buf_offsets[nbr+1] - send_offset;
+      if (send_size > 0)
       {
-         const int send_offset = shr_buf_offsets[nbr];
-         const int send_size = shr_buf_offsets[nbr+1] - send_offset;
-         if (send_size > 0)
-         {
-            auto send_buf = mpi_gpu_aware ? shr_buf.Read() : shr_buf.HostRead();
-            MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41822,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
-         const int recv_offset = ext_buf_offsets[nbr];
-         const int recv_size = ext_buf_offsets[nbr+1] - recv_offset;
-         if (recv_size > 0)
-         {
-            auto recv_buf = mpi_gpu_aware ? ext_buf.Write() : ext_buf.HostWrite();
-            MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41822,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
+         auto send_buf = mpi_gpu_aware ? shr_buf.Read() : shr_buf.HostRead();
+         MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41822,
+                   gtopo.GetComm(), &requests[req_counter++]);
+      }
+      const int recv_offset = ext_buf_offsets[nbr];
+      const int recv_size = ext_buf_offsets[nbr+1] - recv_offset;
+      if (recv_size > 0)
+      {
+         auto recv_buf = mpi_gpu_aware ? ext_buf.Write() : ext_buf.HostWrite();
+         MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41822,
+                   gtopo.GetComm(), &requests[req_counter++]);
       }
    }
    BcastLocalCopy(x, y);
-   if (!local)
-   {
-      MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
-      BcastEndCopy(y); // copy from 'ext_buf'
-   }
+   MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
+   BcastEndCopy(y); // copy from 'ext_buf'
 }
 
 DeviceConformingProlongationOperator::~DeviceConformingProlongationOperator()
@@ -3774,38 +3698,32 @@ void DeviceConformingProlongationOperator::MultTranspose(const Vector &x,
                                                          Vector &y) const
 {
    const GroupTopology &gtopo = gc.GetGroupTopology();
+   ReduceBeginCopy(x); // copy to 'ext_buf'
    int req_counter = 0;
-   if (!local)
+   for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
    {
-      ReduceBeginCopy(x); // copy to 'ext_buf'
-      for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
+      const int send_offset = ext_buf_offsets[nbr];
+      const int send_size = ext_buf_offsets[nbr+1] - send_offset;
+      if (send_size > 0)
       {
-         const int send_offset = ext_buf_offsets[nbr];
-         const int send_size = ext_buf_offsets[nbr+1] - send_offset;
-         if (send_size > 0)
-         {
-            auto send_buf = mpi_gpu_aware ? ext_buf.Read() : ext_buf.HostRead();
-            MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41823,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
-         const int recv_offset = shr_buf_offsets[nbr];
-         const int recv_size = shr_buf_offsets[nbr+1] - recv_offset;
-         if (recv_size > 0)
-         {
-            auto recv_buf = mpi_gpu_aware ? shr_buf.Write() : shr_buf.HostWrite();
-            MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41823,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
+         auto send_buf = mpi_gpu_aware ? ext_buf.Read() : ext_buf.HostRead();
+         MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41823,
+                   gtopo.GetComm(), &requests[req_counter++]);
+      }
+      const int recv_offset = shr_buf_offsets[nbr];
+      const int recv_size = shr_buf_offsets[nbr+1] - recv_offset;
+      if (recv_size > 0)
+      {
+         auto recv_buf = mpi_gpu_aware ? shr_buf.Write() : shr_buf.HostWrite();
+         MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41823,
+                   gtopo.GetComm(), &requests[req_counter++]);
       }
    }
    ReduceLocalCopy(x, y);
-   if (!local)
-   {
-      MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
-      ReduceEndAssemble(y); // assemble from 'shr_buf'
-   }
+   MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
+   ReduceEndAssemble(y); // assemble from 'shr_buf'
 }
 
 } // namespace mfem
diff --git a/fem/pfespace.hpp b/fem/pfespace.hpp
index 8f574670b..c4a95a365 100644
--- a/fem/pfespace.hpp
+++ b/fem/pfespace.hpp
@@ -70,6 +70,7 @@ private:
 
    /// The matrix P (interpolation from true dof to dof). Owned.
    mutable HypreParMatrix *P;
+
    /// Optimized action-only prolongation operator for conforming meshes. Owned.
    mutable Operator *Pconf;
 
@@ -80,12 +81,6 @@ private:
 
    /// The (block-diagonal) matrix R (restriction of dof to true dof). Owned.
    mutable SparseMatrix *R;
-   /// Optimized action-only restriction operator for conforming meshes. Owned.
-   mutable Operator *Rconf;
-   /** Transpose of R or Rconf. For conforming mesh, this is a matrix-free
-       (Device)ConformingProlongationOperator, for a non-conforming mesh
-       this is a TransposeOperator wrapping R. */
-   mutable Operator *R_transpose;
 
    /// Flag indicating the existence of shared triangles with interior ND dofs
    bool nd_strias;
@@ -321,6 +316,13 @@ public:
    HypreParMatrix *Dof_TrueDof_Matrix() const
    { if (!P) { Build_Dof_TrueDof_Matrix(); } return P; }
 
+   /// Get the P matrix which prolongates a true dof vector to local dof vector.
+   virtual const Operator *GetProlongationMatrix() const;
+
+   /// Get the R matrix which restricts a local dof vector to true dof vector.
+   virtual const SparseMatrix *GetRestrictionMatrix() const
+   { Dof_TrueDof_Matrix(); return R; }
+
    /** @brief For a non-conforming mesh, construct and return the interpolation
        matrix from the partially conforming true dofs to the local dofs. */
    /** @note The returned pointer must be deleted by the caller. */
@@ -374,21 +376,6 @@ public:
    HYPRE_BigInt GetMyDofOffset() const;
    HYPRE_BigInt GetMyTDofOffset() const;
 
-   virtual const Operator *GetProlongationMatrix() const;
-   /** @brief Return logical transpose of restriction matrix, but in
-       non-assembled optimized matrix-free form.
-
-       The implementation is like GetProlongationMatrix, but it sets local
-       DOFs to the true DOF values if owned locally, otherwise zero. */
-   virtual const Operator *GetRestrictionTransposeOperator() const;
-   /** Get an Operator that performs the action of GetRestrictionMatrix(),
-       but potentially with a non-assembled optimized matrix-free
-       implementation. */
-   virtual const Operator *GetRestrictionOperator() const;
-   /// Get the R matrix which restricts a local dof vector to true dof vector.
-   virtual const SparseMatrix *GetRestrictionMatrix() const
-   { Dof_TrueDof_Matrix(); return R; }
-
    // Face-neighbor functions
    void ExchangeFaceNbrData();
    int GetFaceNbrVSize() const { return num_face_nbr_dofs; }
@@ -434,21 +421,17 @@ public:
    int TrueVSize() const { return ltdof_size; }
 };
 
-
 /// Auxiliary class used by ParFiniteElementSpace.
 class ConformingProlongationOperator : public Operator
 {
 protected:
    Array<int> external_ldofs;
    const GroupCommunicator &gc;
-   bool local;
 
 public:
-   ConformingProlongationOperator(int lsize, const GroupCommunicator &gc_,
-                                  bool local_=false);
+   ConformingProlongationOperator(int lsize, const GroupCommunicator &gc_);
 
-   ConformingProlongationOperator(const ParFiniteElementSpace &pfes,
-                                  bool local_=false);
+   ConformingProlongationOperator(const ParFiniteElementSpace &pfes);
 
    const GroupCommunicator &GetGroupCommunicator() const;
 
@@ -458,8 +441,8 @@ public:
 };
 
 /// Auxiliary device class used by ParFiniteElementSpace.
-class DeviceConformingProlongationOperator: public
-   ConformingProlongationOperator
+class DeviceConformingProlongationOperator :
+   public ConformingProlongationOperator
 {
 protected:
    bool mpi_gpu_aware;
@@ -495,11 +478,10 @@ protected:
    void ReduceEndAssemble(Vector &dst) const;
 
 public:
-   DeviceConformingProlongationOperator(
-      const GroupCommunicator &gc_, const SparseMatrix *R, bool local_=false);
+   DeviceConformingProlongationOperator(const GroupCommunicator &gc_,
+                                        const SparseMatrix *R);
 
-   DeviceConformingProlongationOperator(const ParFiniteElementSpace &pfes,
-                                        bool local_=false);
+   DeviceConformingProlongationOperator(const ParFiniteElementSpace &pfes);
 
    virtual ~DeviceConformingProlongationOperator();
 
diff --git a/fem/prestriction.cpp b/fem/prestriction.cpp
index 37dee3c8d..89ce189db 100644
--- a/fem/prestriction.cpp
+++ b/fem/prestriction.cpp
@@ -325,7 +325,7 @@ void ParL2FaceRestriction::DoubleValuedConformingMult(
    auto d_x_shared = Reshape(x_gf.FaceNbrData().Read(),
                              t?vd:nsdofs, t?nsdofs:vd);
    auto d_y = Reshape(y.Write(), nface_dofs, vd, 2, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
    {
       const int dof = i % nface_dofs;
       const int face = i / nface_dofs;
diff --git a/fem/restriction.cpp b/fem/restriction.cpp
index 0765a61c7..9e1106d3a 100644
--- a/fem/restriction.cpp
+++ b/fem/restriction.cpp
@@ -12,27 +12,24 @@
 #include "restriction.hpp"
 #include "gridfunc.hpp"
 #include "fespace.hpp"
-#include "../general/forall.hpp"
-#include <climits>
-
 #ifdef MFEM_USE_MPI
-
 #include "pfespace.hpp"
-
 #endif
+#include "../general/forall.hpp"
+#include <climits>
 
 namespace mfem
 {
 
-ElementRestriction::ElementRestriction(const FiniteElementSpace &f,
-                                       ElementDofOrdering e_ordering)
+ConformingElementRestriction::ConformingElementRestriction(
+   const FiniteElementSpace &f,
+   ElementDofOrdering e_ordering)
    : fes(f),
      ne(fes.GetNE()),
      vdim(fes.GetVDim()),
      byvdim(fes.GetOrdering() == Ordering::byVDIM),
      ndofs(fes.GetNDofs()),
      dof(ne > 0 ? fes.GetFE(0)->GetDof() : 0),
-     nedofs(ne*dof),
      offsets(ndofs+1),
      indices(ne*dof),
      gather_map(ne*dof)
@@ -104,7 +101,7 @@ ElementRestriction::ElementRestriction(const FiniteElementSpace &f,
    offsets[0] = 0;
 }
 
-void ElementRestriction::Mult(const Vector& x, Vector& y) const
+void ConformingElementRestriction::Mult(const Vector& x, Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -126,7 +123,8 @@ void ElementRestriction::Mult(const Vector& x, Vector& y) const
    });
 }
 
-void ElementRestriction::MultUnsigned(const Vector& x, Vector& y) const
+void ConformingElementRestriction::MultUnsigned(const Vector& x,
+                                                Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -148,12 +146,13 @@ void ElementRestriction::MultUnsigned(const Vector& x, Vector& y) const
 }
 
 template <bool ADD>
-void ElementRestriction::TAddMultTranspose(const Vector& x, Vector& y) const
+static void TAddMultTranspose(const int nd, const int vd, const bool t,
+                              const int ndofs, const int ne,
+                              const Array<int>& offsets,
+                              const Array<int>& indices,
+                              const Vector& x, Vector& y)
 {
    // Assumes all elements have the same number of dofs
-   const int nd = dof;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_offsets = offsets.Read();
    auto d_indices = indices.Read();
    auto d_x = Reshape(x.Read(), nd, vd, ne);
@@ -177,21 +176,23 @@ void ElementRestriction::TAddMultTranspose(const Vector& x, Vector& y) const
    });
 }
 
-void ElementRestriction::MultTranspose(const Vector& x, Vector& y) const
+void ConformingElementRestriction::MultTranspose(const Vector& x,
+                                                 Vector& y) const
 {
    constexpr bool ADD = false;
-   TAddMultTranspose<ADD>(x, y);
+   TAddMultTranspose<ADD>(dof, vdim, byvdim, ndofs, ne, offsets, indices, x, y);
 }
 
-void ElementRestriction::AddMultTranspose(const Vector& x, Vector& y,
-                                          const double a) const
+void ConformingElementRestriction::AddMultTranspose(const Vector& x, Vector& y,
+                                                    const double a) const
 {
    MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    constexpr bool ADD = true;
-   TAddMultTranspose<ADD>(x, y);
+   TAddMultTranspose<ADD>(dof, vdim, byvdim, ndofs, ne, offsets, indices, x, y);
 }
 
-void ElementRestriction::MultTransposeUnsigned(const Vector& x, Vector& y) const
+void ConformingElementRestriction::MultTransposeUnsigned(const Vector& x,
+                                                         Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -218,32 +219,7 @@ void ElementRestriction::MultTransposeUnsigned(const Vector& x, Vector& y) const
    });
 }
 
-void ElementRestriction::MultLeftInverse(const Vector& x, Vector& y) const
-{
-   // Assumes all elements have the same number of dofs
-   const int nd = dof;
-   const int vd = vdim;
-   const bool t = byvdim;
-   auto d_offsets = offsets.Read();
-   auto d_indices = indices.Read();
-   auto d_x = Reshape(x.Read(), nd, vd, ne);
-   auto d_y = Reshape(y.Write(), t?vd:ndofs, t?ndofs:vd);
-   mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
-   {
-      const int next_offset = d_offsets[i + 1];
-      for (int c = 0; c < vd; ++c)
-      {
-         double dof_value = 0;
-         const int j = next_offset - 1;
-         const int idx_j = (d_indices[j] >= 0) ? d_indices[j] : -1 - d_indices[j];
-         dof_value = (d_indices[j] >= 0) ? d_x(idx_j % nd, c, idx_j / nd) :
-                     -d_x(idx_j % nd, c, idx_j / nd);
-         d_y(t?c:i,t?i:c) = dof_value;
-      }
-   });
-}
-
-void ElementRestriction::BooleanMask(Vector& y) const
+void ConformingElementRestriction::BooleanMask(Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -280,8 +256,8 @@ void ElementRestriction::BooleanMask(Vector& y) const
    }
 }
 
-void ElementRestriction::FillSparseMatrix(const Vector &mat_ea,
-                                          SparseMatrix &mat) const
+void ConformingElementRestriction::FillSparseMatrix(const Vector &mat_ea,
+                                                    SparseMatrix &mat) const
 {
    mat.GetMemoryI().New(mat.Height()+1, mat.GetMemoryI().GetMemoryType());
    const int nnz = FillI(mat);
@@ -319,7 +295,7 @@ static MFEM_HOST_DEVICE int GetAndIncrementNnzIndex(const int i_L, int* I)
    return ind;
 }
 
-int ElementRestriction::FillI(SparseMatrix &mat) const
+int ConformingElementRestriction::FillI(SparseMatrix &mat) const
 {
    static constexpr int Max = MaxNbNbr;
    const int all_dofs = ndofs;
@@ -396,8 +372,8 @@ int ElementRestriction::FillI(SparseMatrix &mat) const
    return h_I[nTdofs];
 }
 
-void ElementRestriction::FillJAndData(const Vector &ea_data,
-                                      SparseMatrix &mat) const
+void ConformingElementRestriction::FillJAndData(const Vector &ea_data,
+                                                SparseMatrix &mat) const
 {
    static constexpr int Max = MaxNbNbr;
    const int all_dofs = ndofs;
@@ -523,11 +499,10 @@ void L2ElementRestriction::Mult(const Vector &x, Vector &y) const
 }
 
 template <bool ADD>
-void L2ElementRestriction::TAddMultTranspose(const Vector &x, Vector &y) const
+static void L2TAddMultTranspose(const int nd, const int vd, const bool t,
+                                const int ndofs, const int ne,
+                                const Vector &x, Vector &y)
 {
-   const int nd = ndof;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_x = Reshape(x.Read(), nd, vd, ne);
    auto d_y = Reshape(ADD ? y.ReadWrite() : y.Write(), t?vd:ndofs, t?ndofs:vd);
    mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
@@ -546,7 +521,7 @@ void L2ElementRestriction::TAddMultTranspose(const Vector &x, Vector &y) const
 void L2ElementRestriction::MultTranspose(const Vector &x, Vector &y) const
 {
    constexpr bool ADD = false;
-   TAddMultTranspose<ADD>(x, y);
+   L2TAddMultTranspose<ADD>(ndof, vdim, byvdim, ndofs, ne, x, y);
 }
 
 void L2ElementRestriction::AddMultTranspose(const Vector &x, Vector &y,
@@ -554,7 +529,7 @@ void L2ElementRestriction::AddMultTranspose(const Vector &x, Vector &y,
 {
    MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    constexpr bool ADD = true;
-   TAddMultTranspose<ADD>(x, y);
+   L2TAddMultTranspose<ADD>(ndof, vdim, byvdim, ndofs, ne, x, y);
 }
 
 void L2ElementRestriction::FillI(SparseMatrix &mat) const
@@ -609,7 +584,6 @@ ConformingFaceRestriction::ConformingFaceRestriction(
      byvdim(fes.GetOrdering() == Ordering::byVDIM),
      face_dofs(nf > 0 ? fes.GetFaceElement(0)->GetDof() : 0),
      elem_dofs(fes.GetFE(0)->GetDof()),
-     nfdofs(nf*face_dofs),
      ndofs(fes.GetNDofs()),
      scatter_indices(nf*face_dofs),
      gather_offsets(ndofs+1),
@@ -651,62 +625,102 @@ ConformingFaceRestriction::ConformingFaceRestriction(
    : ConformingFaceRestriction(fes, f_ordering, type, true)
 { }
 
-void ConformingFaceRestriction::Mult(const Vector& x, Vector& y) const
+static void ConformingFaceRestriction_Mult(
+   const int ndofs,
+   const int face_dofs,
+   const int nf,
+   const int vdim,
+   const bool by_vdim,
+   const Array<int> &scatter_indices,
+   const Vector &x,
+   Vector &y,
+   bool use_signs)
 {
    if (nf==0) { return; }
    // Assumes all elements have the same number of dofs
-   const int nface_dofs = face_dofs;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_indices = scatter_indices.Read();
-   auto d_x = Reshape(x.Read(), t?vd:ndofs, t?ndofs:vd);
-   auto d_y = Reshape(y.Write(), nface_dofs, vd, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
-   {
-      const int s_idx = d_indices[i];
-      const int sgn = (s_idx >= 0) ? 1 : -1;
-      const int idx = (s_idx >= 0) ? s_idx : -1 - s_idx;
-      const int dof = i % nface_dofs;
-      const int face = i / nface_dofs;
-      for (int c = 0; c < vd; ++c)
+   auto d_x = Reshape(x.Read(), by_vdim?vdim:ndofs, by_vdim?ndofs:vdim);
+   auto d_y = Reshape(y.Write(), face_dofs, vdim, nf);
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
+   {
+      const int s_idx_j = d_indices[i];
+      const double sgn = (s_idx_j >= 0 || !use_signs) ? 1.0 : -1.0;
+      const int idx_j = (s_idx_j >= 0) ? s_idx_j : -1 - s_idx_j;
+      for (int c = 0; c < vdim; ++c)
       {
-         d_y(dof, c, face) = sgn*d_x(t?c:idx, t?idx:c);
+         d_y(i % face_dofs, c, i / face_dofs) =
+            sgn*d_x(by_vdim?c:idx_j, by_vdim?idx_j:c);
       }
    });
 }
 
-void ConformingFaceRestriction::AddMultTranspose(
-   const Vector& x, Vector& y, const double a) const
+void ConformingFaceRestriction::Mult(const Vector& x, Vector& y) const
+{
+   ConformingFaceRestriction_Mult(
+      ndofs, face_dofs, nf, vdim, byvdim, scatter_indices, x, y, true);
+}
+
+void ConformingFaceRestriction::MultUnsigned(const Vector& x, Vector& y) const
+{
+   ConformingFaceRestriction_Mult(
+      ndofs, face_dofs, nf, vdim, byvdim, scatter_indices, x, y, false);
+}
+
+static void ConformingFaceRestriction_AddMultTranspose(
+   const int ndofs,
+   const int face_dofs,
+   const int nf,
+   const int vdim,
+   const bool by_vdim,
+   const Array<int> &gather_offsets,
+   const Array<int> &gather_indices,
+   const Vector &x,
+   Vector &y,
+   bool use_signs,
+   const double a)
 {
    MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    if (nf==0) { return; }
    // Assumes all elements have the same number of dofs
-   const int nface_dofs = face_dofs;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_offsets = gather_offsets.Read();
    auto d_indices = gather_indices.Read();
-   auto d_x = Reshape(x.Read(), nface_dofs, vd, nf);
-   auto d_y = Reshape(y.ReadWrite(), t?vd:ndofs, t?ndofs:vd);
+   auto d_x = Reshape(x.Read(), face_dofs, vdim, nf);
+   auto d_y = Reshape(y.ReadWrite(), by_vdim?vdim:ndofs, by_vdim?ndofs:vdim);
    mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
    {
       const int offset = d_offsets[i];
       const int next_offset = d_offsets[i + 1];
-      for (int c = 0; c < vd; ++c)
+      for (int c = 0; c < vdim; ++c)
       {
          double dof_value = 0;
          for (int j = offset; j < next_offset; ++j)
          {
             const int s_idx_j = d_indices[j];
-            const int sgn = (s_idx_j >= 0) ? 1 : -1;
+            const double sgn = (s_idx_j >= 0 || !use_signs) ? 1.0 : -1.0;
             const int idx_j = (s_idx_j >= 0) ? s_idx_j : -1 - s_idx_j;
-            dof_value += sgn*d_x(idx_j % nface_dofs, c, idx_j / nface_dofs);
+            dof_value += sgn*d_x(idx_j % face_dofs, c, idx_j / face_dofs);
          }
-         d_y(t?c:i,t?i:c) += dof_value;
+         d_y(by_vdim?c:i,by_vdim?i:c) += dof_value;
       }
    });
 }
 
+void ConformingFaceRestriction::AddMultTranspose(
+   const Vector& x, Vector& y, const double a) const
+{
+   ConformingFaceRestriction_AddMultTranspose(
+      ndofs, face_dofs, nf, vdim, byvdim, gather_offsets, gather_indices, x, y,
+      true, a);
+}
+
+void ConformingFaceRestriction::AddMultTransposeUnsigned(
+   const Vector& x, Vector& y, const double a) const
+{
+   ConformingFaceRestriction_AddMultTranspose(
+      ndofs, face_dofs, nf, vdim, byvdim, gather_offsets, gather_indices, x, y,
+      false, a);
+}
+
 void ConformingFaceRestriction::CheckFESpace(const ElementDofOrdering
                                              f_ordering)
 {
@@ -1019,7 +1033,6 @@ L2FaceRestriction::L2FaceRestriction(const FiniteElementSpace &fes,
                fes.GetTraceElement(0, fes.GetMesh()->GetFaceGeometry(0))->GetDof()
                : 0),
      elem_dofs(fes.GetFE(0)->GetDof()),
-     nfdofs(nf*face_dofs),
      ndofs(fes.GetNDofs()),
      type(type),
      m(m),
@@ -1060,7 +1073,7 @@ void L2FaceRestriction::SingleValuedConformingMult(const Vector& x,
    auto d_indices1 = scatter_indices1.Read();
    auto d_x = Reshape(x.Read(), t?vd:ndofs, t?ndofs:vd);
    auto d_y = Reshape(y.Write(), nface_dofs, vd, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
    {
       const int dof = i % nface_dofs;
       const int face = i / nface_dofs;
@@ -1086,7 +1099,7 @@ void L2FaceRestriction::DoubleValuedConformingMult(const Vector& x,
    auto d_indices2 = scatter_indices2.Read();
    auto d_x = Reshape(x.Read(), t?vd:ndofs, t?ndofs:vd);
    auto d_y = Reshape(y.Write(), nface_dofs, vd, 2, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
    {
       const int dof = i % nface_dofs;
       const int face = i / nface_dofs;
@@ -1137,7 +1150,7 @@ void L2FaceRestriction::SingleValuedConformingAddMultTranspose(
          for (int j = offset; j < next_offset; ++j)
          {
             int idx_j = d_indices[j];
-            dof_value +=  d_x(idx_j % nface_dofs, c, idx_j / nface_dofs);
+            dof_value += d_x(idx_j % nface_dofs, c, idx_j / nface_dofs);
          }
          d_y(t?c:i,t?i:c) += dof_value;
       }
@@ -1151,7 +1164,7 @@ void L2FaceRestriction::DoubleValuedConformingAddMultTranspose(
    const int nface_dofs = face_dofs;
    const int vd = vdim;
    const bool t = byvdim;
-   const int dofs = nfdofs;
+   const int dofs = face_dofs*nf;
    auto d_offsets = gather_offsets.Read();
    auto d_indices = gather_indices.Read();
    auto d_x = Reshape(x.Read(), nface_dofs, vd, 2, nf);
@@ -1168,9 +1181,8 @@ void L2FaceRestriction::DoubleValuedConformingAddMultTranspose(
             int idx_j = d_indices[j];
             bool isE1 = idx_j < dofs;
             idx_j = isE1 ? idx_j : idx_j - dofs;
-            dof_value +=  isE1 ?
-                          d_x(idx_j % nface_dofs, c, 0, idx_j / nface_dofs)
-                          :d_x(idx_j % nface_dofs, c, 1, idx_j / nface_dofs);
+            dof_value += (isE1 ? d_x(idx_j % nface_dofs, c, 0, idx_j / nface_dofs)
+                          : d_x(idx_j % nface_dofs, c, 1, idx_j / nface_dofs));
          }
          d_y(t?c:i,t?i:c) += dof_value;
       }
@@ -1565,7 +1577,7 @@ void L2FaceRestriction::PermuteAndSetFaceDofsGatherIndices2(
       const int global_dof_elem2 = elem_map[elem_index*elem_dofs + volume_dof_elem2];
       const int restriction_dof_elem2 = face_dofs*face_index + face_dof_elem1;
       // We shift restriction_dof_elem2 to express that it's elem2 of the face
-      gather_indices[gather_offsets[global_dof_elem2]++] = nfdofs +
+      gather_indices[gather_offsets[global_dof_elem2]++] = face_dofs*nf +
                                                            restriction_dof_elem2;
    }
 }
diff --git a/fem/restriction.hpp b/fem/restriction.hpp
index 3f9ed3fbd..88902f947 100644
--- a/fem/restriction.hpp
+++ b/fem/restriction.hpp
@@ -22,19 +22,44 @@ class FiniteElementSpace;
 enum class ElementDofOrdering;
 
 /// Abstract base class that defines an interface for element restrictions.
-class ElementRestrictionOperator : public Operator
+class ElementRestriction : public Operator
 {
 public:
-   /// @brief Add the E-vector degrees of freedom @a x to the L-vector degrees
-   /// of freedom @a y.
+   /** @brief Extract the degrees of freedom from @a x into @a y. */
+   void Mult(const Vector &x, Vector &y) const override = 0;
+
+   /** @brief Set the degrees of freedom in the element degrees of freedom
+       @a y to the values given in @a x. */
+   void MultTranspose(const Vector &x, Vector &y) const override
+   {
+      y = 0.0;
+      AddMultTranspose(x, y);
+   }
+
+   /** @brief Add the degrees of freedom @a x to the element degrees of
+       freedom @a y. */
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override = 0;
+
+   /** @brief Add the degrees of freedom @a x to the element degrees of
+       freedom @a y ignoring the signs from DOF orientation. */
+   virtual void MultUnsigned(const Vector &x, Vector &y) const
+   {
+      Mult(x, y);
+   }
+
+   /** @brief Add the degrees of freedom @a x to the element degrees of
+       freedom @a y ignoring the signs from DOF orientation. */
+   virtual void MultTransposeUnsigned(const Vector &x, Vector &y) const
+   {
+      MultTranspose(x, y);
+   }
 };
 
 /// Operator that converts FiniteElementSpace L-vectors to E-vectors.
 /** Objects of this type are typically created and owned by FiniteElementSpace
     objects, see FiniteElementSpace::GetElementRestriction(). */
-class ElementRestriction : public ElementRestrictionOperator
+class ConformingElementRestriction : public ElementRestriction
 {
 private:
    /** This number defines the maximum number of elements any dof can belong to
@@ -48,26 +73,23 @@ protected:
    const bool byvdim;
    const int ndofs;
    const int dof;
-   const int nedofs;
    Array<int> offsets;
    Array<int> indices;
    Array<int> gather_map;
 
 public:
-   ElementRestriction(const FiniteElementSpace&, ElementDofOrdering);
+   ConformingElementRestriction(const FiniteElementSpace&, ElementDofOrdering);
+
    void Mult(const Vector &x, Vector &y) const override;
+
    void MultTranspose(const Vector &x, Vector &y) const override;
+
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override;
 
-   /// Compute Mult without applying signs based on DOF orientations.
-   void MultUnsigned(const Vector &x, Vector &y) const;
-   /// Compute MultTranspose without applying signs based on DOF orientations.
-   void MultTransposeUnsigned(const Vector &x, Vector &y) const;
+   void MultUnsigned(const Vector &x, Vector &y) const override;
 
-   /// Compute MultTranspose by setting (rather than adding) element
-   /// contributions; this is a left inverse of the Mult() operation
-   void MultLeftInverse(const Vector &x, Vector &y) const;
+   void MultTransposeUnsigned(const Vector &x, Vector &y) const override;
 
    /// @brief Fills the E-vector y with `boolean` values 0.0 and 1.0 such that each
    /// each entry of the L-vector is uniquely represented in `y`.
@@ -81,16 +103,13 @@ public:
    void FillSparseMatrix(const Vector &mat_ea, SparseMatrix &mat) const;
 
    /** Fill the I array of SparseMatrix corresponding to the sparsity pattern
-       given by this ElementRestriction. */
+       given by this ConformingElementRestriction. */
    int FillI(SparseMatrix &mat) const;
+
    /** Fill the J and Data arrays of SparseMatrix corresponding to the sparsity
-       pattern given by this ElementRestriction, and the values of ea_data. */
+       pattern given by this ConformingElementRestriction, and the values of
+       ea_data. */
    void FillJAndData(const Vector &ea_data, SparseMatrix &mat) const;
-   /// @private Not part of the public interface (device kernel limitation).
-   ///
-   /// Performs either MultTranspose or AddMultTranspose depending on the
-   /// boolean template parameter @a ADD.
-   template <bool ADD> void TAddMultTranspose(const Vector &x, Vector &y) const;
 
    /// @name Low-level access to the underlying element-dof mappings
    ///@{
@@ -105,37 +124,39 @@ public:
     objects, see FiniteElementSpace::GetElementRestriction(). L-vectors
     corresponding to grid functions in L2 finite element spaces differ from
     E-vectors only in the ordering of the degrees of freedom. */
-class L2ElementRestriction : public ElementRestrictionOperator
+class L2ElementRestriction : public ElementRestriction
 {
+private:
    const int ne;
    const int vdim;
    const bool byvdim;
    const int ndof;
    const int ndofs;
+
 public:
    L2ElementRestriction(const FiniteElementSpace&);
+
    void Mult(const Vector &x, Vector &y) const override;
+
    void MultTranspose(const Vector &x, Vector &y) const override;
+
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override;
+
    /** Fill the I array of SparseMatrix corresponding to the sparsity pattern
        given by this ElementRestriction. */
    void FillI(SparseMatrix &mat) const;
+
    /** Fill the J and Data arrays of SparseMatrix corresponding to the sparsity
        pattern given by this L2FaceRestriction, and the values of ea_data. */
    void FillJAndData(const Vector &ea_data, SparseMatrix &mat) const;
-   /// @private Not part of the public interface (device kernel limitation).
-   ///
-   /// Performs either MultTranspose or AddMultTranspose depending on the
-   /// boolean template parameter @a ADD.
-   template <bool ADD> void TAddMultTranspose(const Vector &x, Vector &y) const;
 };
 
 /** An enum type to specify if only e1 value is requested (SingleValued) or both
     e1 and e2 (DoubleValued). */
 enum class L2FaceValues : bool {SingleValued, DoubleValued};
 
-/** @brief Base class for operators that extracts Face degrees of freedom.
+/** @brief Abstract base class for operators that extracts Face degrees of freedom.
 
     In order to compute quantities on the faces of a mesh, it is often useful to
     extract the degrees of freedom on the faces of the elements. This class
@@ -173,6 +194,19 @@ public:
    */
    void Mult(const Vector &x, Vector &y) const override = 0;
 
+   /** @brief Set the face degrees of freedom in the element degrees of freedom
+       @a y to the values given in @a x.
+
+       @param[in]     x The face degrees of freedom on the face.
+       @param[in,out] y The L-vector of degrees of freedom to which we add the
+                        face degrees of freedom.
+   */
+   void MultTranspose(const Vector &x, Vector &y) const override
+   {
+      y = 0.0;
+      AddMultTranspose(x, y);
+   }
+
    /** @brief Add the face degrees of freedom @a x to the element degrees of
        freedom @a y.
 
@@ -181,14 +215,29 @@ public:
                         face degrees of freedom.
        @param[in]     a Scalar coefficient for addition.
    */
-   virtual void AddMultTranspose(const Vector &x, Vector &y,
-                                 const double a = 1.0) const override = 0;
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override = 0;
+
+   /** @brief Extract the face degrees of freedom from @a x into @a y ignoring
+       the signs from DOF orientation. */
+   virtual void MultUnsigned(const Vector &x, Vector &y) const
+   {
+      Mult(x, y);
+   }
+
+   /** @brief Add the face degrees of freedom @a x to the element degrees of
+       freedom @a y ignoring the signs from DOF orientation. */
+   virtual void AddMultTransposeUnsigned(const Vector &x, Vector &y,
+                                         const double a = 1.0) const
+   {
+      AddMultTranspose(x, y, a);
+   }
 
    /** @brief Add the face degrees of freedom @a x to the element degrees of
        freedom @a y. Perform the same computation as AddMultTranspose, but
        @a x is invalid after calling this method.
 
-       @param[in,out]     x The face degrees of freedom on the face.
+       @param[in,out] x The face degrees of freedom on the face.
        @param[in,out] y The L-vector of degrees of freedom to which we add the
                         face degrees of freedom.
 
@@ -199,19 +248,6 @@ public:
    {
       AddMultTranspose(x, y);
    }
-
-   /** @brief Set the face degrees of freedom in the element degrees of freedom
-       @a y to the values given in @a x.
-
-       @param[in]     x The face degrees of freedom on the face.
-       @param[in,out] y The L-vector of degrees of freedom to which we add the
-                        face degrees of freedom.
-   */
-   void MultTranspose(const Vector &x, Vector &y) const override
-   {
-      y = 0.0;
-      AddMultTranspose(x, y);
-   }
 };
 
 /// @brief Operator that extracts face degrees of freedom for H1, ND, or RT
@@ -228,7 +264,6 @@ protected:
    const bool byvdim;
    const int face_dofs; // Number of dofs on each face
    const int elem_dofs; // Number of dofs in each element
-   const int nfdofs; // Total number of face E-vector dofs
    const int ndofs; // Total number of dofs
    Array<int> scatter_indices; // Scattering indices for element 1 on each face
    Array<int> gather_offsets; // offsets for the gathering indices of each dof
@@ -248,6 +283,7 @@ protected:
                              const ElementDofOrdering f_ordering,
                              const FaceType type,
                              bool build);
+
 public:
    /** @brief Construct a ConformingFaceRestriction.
 
@@ -270,22 +306,33 @@ public:
                      ElementDofOrdering. */
    void Mult(const Vector &x, Vector &y) const override;
 
-   using FaceRestriction::AddMultTransposeInPlace;
+   /** @brief Extract the face degrees of freedom from @a x into @a y ignoring
+       the signs from DOF orientation.
+
+       @sa Mult(). */
+   void MultUnsigned(const Vector &x, Vector &y) const override;
 
    /** @brief Gather the degrees of freedom, i.e. goes from face E-Vector to
        L-Vector.
 
-       @param[in]  x The face E-Vector degrees of freedom with the given format:
-                     face_dofs x vdim x nf
-                     where nf is the number of interior or boundary faces
-                     requested by @a type in the constructor.
-                     The face_dofs should be ordered according to the given
-                     ElementDofOrdering
+       @param[in]     x The face E-Vector degrees of freedom with the given format:
+                        face_dofs x vdim x nf
+                        where nf is the number of interior or boundary faces
+                        requested by @a type in the constructor.
+                        The face_dofs should be ordered according to the given
+                        ElementDofOrdering
        @param[in,out] y The L-vector degrees of freedom.
-       @param[in]  a Scalar coefficient for addition. */
+       @param[in]     a Scalar coefficient for addition. */
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override;
 
+   /** @brief Gather the degrees of freedom, i.e. goes from face E-Vector to
+       L-Vector @b not taking into account signs from DOF orientations.
+
+       @sa AddMultTranspose(). */
+   void AddMultTransposeUnsigned(const Vector &x, Vector &y,
+                                 const double a = 1.0) const override;
+
 private:
    /** @brief Compute the scatter indices: L-vector to E-vector, and the offsets
        for the gathering: E-vector to L-vector.
@@ -356,7 +403,6 @@ protected:
    const bool byvdim;
    const int face_dofs; // Number of dofs on each face
    const int elem_dofs; // Number of dofs in each element
-   const int nfdofs; // Total number of dofs on the faces
    const int ndofs; // Total number of dofs
    const FaceType type;
    const L2FaceValues m;
@@ -408,8 +454,6 @@ public:
                      ElementDofOrdering. */
    void Mult(const Vector &x, Vector &y) const override;
 
-   using FaceRestriction::AddMultTranspose;
-
    /** @brief Gather the degrees of freedom, i.e. goes from face E-Vector to
        L-Vector.
 
@@ -806,6 +850,7 @@ protected:
                        const FaceType type,
                        const L2FaceValues m,
                        bool build);
+
 public:
    /** @brief Constructs an NCL2FaceRestriction, this is a specialization of a
        L2FaceRestriction for nonconforming meshes.
diff --git a/fem/transfer.cpp b/fem/transfer.cpp
index 68dab72d5..7f95ca9fe 100644
--- a/fem/transfer.cpp
+++ b/fem/transfer.cpp
@@ -92,9 +92,9 @@ const Operator &GridTransfer::MakeTrueOperator(
    else // Parallel() == true
    {
 #ifdef MFEM_USE_MPI
+      const SparseMatrix *out_R = fes_out.GetRestrictionMatrix();
       if (oper_type == Operator::Hypre_ParCSR)
       {
-         const SparseMatrix *out_R = fes_out.GetRestrictionMatrix();
          const ParFiniteElementSpace *pfes_in =
             dynamic_cast<const ParFiniteElementSpace *>(&fes_in);
          const ParFiniteElementSpace *pfes_out =
@@ -122,7 +122,6 @@ const Operator &GridTransfer::MakeTrueOperator(
       }
       else if (oper_type == Operator::ANY_TYPE)
       {
-         const Operator *out_R = fes_out.GetRestrictionOperator();
          t_oper.Reset(new TripleProductOperator(
                          out_R, &oper, fes_in.GetProlongationMatrix(),
                          false, false, false));
@@ -1159,12 +1158,12 @@ TensorProductPRefinementTransferOperator(
    localL.UseDevice(true);
    localH.UseDevice(true);
 
-   MFEM_VERIFY(dynamic_cast<const ElementRestriction*>(elem_restrict_lex_h),
+   const auto *elem_restrict =
+      dynamic_cast<const ConformingElementRestriction*>(elem_restrict_lex_h);
+   MFEM_VERIFY(elem_restrict,
                "High order element restriction is of unsupported type");
-
    mask.SetSize(localH.Size(), Device::GetMemoryType());
-   static_cast<const ElementRestriction*>(elem_restrict_lex_h)
-   ->BooleanMask(mask);
+   elem_restrict->BooleanMask(mask);
    mask.UseDevice(true);
 }
 
diff --git a/general/communication.hpp b/general/communication.hpp
index 474486f1b..c7d00f1e4 100644
--- a/general/communication.hpp
+++ b/general/communication.hpp
@@ -217,7 +217,6 @@ protected:
    int group_buf_size;
    mutable Array<char> group_buf;
    MPI_Request *requests;
-   // MPI_Status  *statuses;
    // comm_lock: 0 - no lock, 1 - locked for Bcast, 2 - locked for Reduce
    mutable int comm_lock;
    mutable int num_requests;
diff --git a/general/version.cpp b/general/version.cpp
index d2b05f8ed..f4c402d51 100644
--- a/general/version.cpp
+++ b/general/version.cpp
@@ -103,9 +103,6 @@ const char *GetConfigStr()
 #ifdef MFEM_USE_LAPACK
       "MFEM_USE_LAPACK\n"
 #endif
-#ifdef MFEM_USE_LEGACY_OPENMP
-      "MFEM_USE_LEGACY_OPENMP\n"
-#endif
 #ifdef MFEM_USE_LIBUNWIND
       "MFEM_USE_LIBUNWIND\n"
 #endif
diff --git a/linalg/auxiliary.cpp b/linalg/auxiliary.cpp
index 003e52695..bcb55ca3e 100644
--- a/linalg/auxiliary.cpp
+++ b/linalg/auxiliary.cpp
@@ -171,7 +171,6 @@ MatrixFreeAuxiliarySpace::MatrixFreeAuxiliarySpace(
    {
       a_lor.AddDomainIntegrator(new VectorMassIntegrator);
    }
-   a_lor.UsePrecomputedSparsity();
    a_lor.Assemble();
    a_lor.EliminateEssentialBC(ess_bdr, policy);
    a_lor.Finalize();
@@ -244,7 +243,6 @@ MatrixFreeAuxiliarySpace::MatrixFreeAuxiliarySpace(
    {
       a_lor.AddDomainIntegrator(new DiffusionIntegrator);
    }
-   a_lor.UsePrecomputedSparsity();
    a_lor.Assemble();
    if (ess_bdr.Size())
    {
@@ -460,14 +458,14 @@ MatrixFreeAMS::MatrixFreeAMS(
    pa_grad->SetAssemblyLevel(AssemblyLevel::PARTIAL);
    pa_grad->AddDomainInterpolator(new GradientInterpolator);
    pa_grad->Assemble();
-   pa_grad->FormRectangularSystemMatrix(Gradient);
+   pa_grad->FormDiscreteOperatorMatrix(Gradient);
 
    // build Pi operator
    pa_interp = new ParDiscreteLinearOperator(h1_fespace_d, &nd_fespace);
    pa_interp->SetAssemblyLevel(AssemblyLevel::PARTIAL);
    pa_interp->AddDomainInterpolator(new IdentityInterpolator);
    pa_interp->Assemble();
-   pa_interp->FormRectangularSystemMatrix(Pi);
+   pa_interp->FormDiscreteOperatorMatrix(Pi);
 
    // build LOR space
    ParMesh mesh_lor = ParMesh::MakeRefined(*mesh, order, BasisType::GaussLobatto);
diff --git a/linalg/handle.hpp b/linalg/handle.hpp
index 818294985..96f658d6a 100644
--- a/linalg/handle.hpp
+++ b/linalg/handle.hpp
@@ -207,7 +207,6 @@ public:
                     const Vector &X, Vector &B) const;
 };
 
-
 /// Add an alternative name for OperatorHandle -- OperatorPtr.
 typedef OperatorHandle OperatorPtr;
 
diff --git a/linalg/hypre.hpp b/linalg/hypre.hpp
index 913bdb2d0..3d5b4b2fe 100644
--- a/linalg/hypre.hpp
+++ b/linalg/hypre.hpp
@@ -720,7 +720,7 @@ public:
 
    /** @brief The "Boolean" analog of y = alpha * A * x + beta * y, where
        elements in the sparsity pattern of the matrix are treated as "true". */
-   void BooleanMult(int alpha, const int *x, int beta, int *y)
+   void BooleanMult(int alpha, const int *x, int beta, int *y) const
    {
       HostRead();
       internal::hypre_ParCSRMatrixBooleanMatvec(A, alpha, const_cast<int*>(x),
@@ -730,7 +730,7 @@ public:
 
    /** @brief The "Boolean" analog of y = alpha * A^T * x + beta * y, where
        elements in the sparsity pattern of the matrix are treated as "true". */
-   void BooleanMultTranspose(int alpha, const int *x, int beta, int *y)
+   void BooleanMultTranspose(int alpha, const int *x, int beta, int *y) const
    {
       HostRead();
       internal::hypre_ParCSRMatrixBooleanMatvecT(A, alpha, const_cast<int*>(x),
diff --git a/linalg/operator.cpp b/linalg/operator.cpp
index 1f214ece7..64f75c8a4 100644
--- a/linalg/operator.cpp
+++ b/linalg/operator.cpp
@@ -165,7 +165,7 @@ void Operator::RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x)
    }
 }
 
-Operator * Operator::SetupRAP(const Operator *Pi, const Operator *Po)
+Operator *Operator::SetupRAP(const Operator *Pi, const Operator *Po)
 {
    Operator *rap;
    if (!IsIdentityProlongation(Pi))
@@ -176,15 +176,15 @@ Operator * Operator::SetupRAP(const Operator *Pi, const Operator *Po)
       }
       else
       {
-         rap = new ProductOperator(this, Pi, false,false);
+         rap = new ProductOperator(this, Pi, false, false);
       }
    }
    else
    {
       if (!IsIdentityProlongation(Po))
       {
-         TransposeOperator * PoT = new TransposeOperator(Po);
-         rap = new ProductOperator(PoT, this, true,false);
+         TransposeOperator *PoT = new TransposeOperator(Po);
+         rap = new ProductOperator(PoT, this, true, false);
       }
       else
       {
@@ -245,10 +245,10 @@ void Operator::FormDiscreteOperator(Operator* &Aout)
 {
    const Operator *Pin  = this->GetProlongation();
    const Operator *Rout = this->GetOutputRestriction();
-   Aout = new TripleProductOperator(Rout, this, Pin,false, false, false);
+   Aout = new TripleProductOperator(Rout, this, Pin, false, false, false);
 }
 
-void Operator::PrintMatlab(std::ostream & os, int n, int m) const
+void Operator::PrintMatlab(std::ostream &os, int n, int m) const
 {
    using namespace std;
    if (n == 0) { n = width; }
diff --git a/linalg/operator.hpp b/linalg/operator.hpp
index baa9bf767..cdf700e17 100644
--- a/linalg/operator.hpp
+++ b/linalg/operator.hpp
@@ -29,8 +29,8 @@ protected:
 
    /// see FormSystemOperator()
    /** @note Uses DiagonalPolicy::DIAG_ONE. */
-   void FormConstrainedSystemOperator(
-      const Array<int> &ess_tdof_list, ConstrainedOperator* &Aout);
+   void FormConstrainedSystemOperator(const Array<int> &ess_tdof_list,
+                                      ConstrainedOperator* &Aout);
 
    /// see FormRectangularSystemOperator()
    void FormRectangularConstrainedSystemOperator(
@@ -38,10 +38,6 @@ protected:
       const Array<int> &test_tdof_list,
       RectangularConstrainedOperator* &Aout);
 
-   /** @brief Returns RAP Operator of this, using input/output Prolongation matrices
-       @a Pi corresponds to "P", @a Po corresponds to "Rt" */
-   Operator *SetupRAP(const Operator *Pi, const Operator *Po);
-
 public:
    /// Defines operator diagonal policy upon elimination of rows and/or columns.
    enum DiagonalPolicy
@@ -149,12 +145,6 @@ public:
       return GetProlongation(); // Assume square unless specialized
    }
 
-   /** @brief Transpose of GetOutputRestriction, directly available in this
-       form to facilitate matrix-free RAP-type operators.
-
-       `NULL` means identity. */
-   virtual const Operator *GetOutputRestrictionTranspose() const { return NULL; }
-
    /** @brief Restriction operator from output vectors for the operator to linear
        algebra (linear system) vectors. `NULL` means identity. */
    virtual const Operator *GetOutputRestriction() const
@@ -239,6 +229,10 @@ public:
        forms, though currently @a b is not used in the implementation. */
    virtual void RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x);
 
+   /** @brief Returns RAP Operator of this, using input/output Prolongation matrices
+       @a Pi corresponds to "P", @a Po corresponds to "Rt" */
+   Operator *SetupRAP(const Operator *Pi, const Operator *Po);
+
    /** @brief Return in @a A a parallel (on truedofs) version of this square
        operator.
 
@@ -270,10 +264,10 @@ public:
    void FormDiscreteOperator(Operator* &A);
 
    /// Prints operator with input size n and output size m in Matlab format.
-   void PrintMatlab(std::ostream & out, int n, int m = 0) const;
+   void PrintMatlab(std::ostream &out, int n, int m = 0) const;
 
    /// Prints operator in Matlab format.
-   virtual void PrintMatlab(std::ostream & out) const;
+   virtual void PrintMatlab(std::ostream &out) const;
 
    /// Virtual destructor.
    virtual ~Operator() { }
@@ -722,6 +716,7 @@ inline bool IsIdentityProlongation(const Operator *P)
    return !P || dynamic_cast<const IdentityOperator*>(P);
 }
 
+
 /// Scaled Operator B: x -> a A(x).
 class ScaledOperator : public Operator
 {
@@ -928,6 +923,7 @@ public:
    virtual ~ConstrainedOperator() { if (own_A) { delete A; } }
 };
 
+
 /** @brief Rectangular Operator for imposing essential boundary conditions on
     the input space using only the action, Mult(), of a given unconstrained
     Operator.
@@ -981,6 +977,7 @@ public:
    virtual ~RectangularConstrainedOperator() { if (own_A) { delete A; } }
 };
 
+
 /** @brief PowerMethod helper class to estimate the largest eigenvalue of an
            operator using the iterative power method. */
 class PowerMethod
diff --git a/linalg/sparsemat.cpp b/linalg/sparsemat.cpp
index 145379c00..e55ea47b4 100644
--- a/linalg/sparsemat.cpp
+++ b/linalg/sparsemat.cpp
@@ -764,7 +764,6 @@ void SparseMatrix::AddMult(const Vector &x, Vector &y, const double a) const
       return;
    }
 
-#ifndef MFEM_USE_LEGACY_OPENMP
    const int height = this->height;
    const int nnz = J.Capacity();
    auto d_I = Read(I, height+1);
@@ -885,24 +884,6 @@ void SparseMatrix::AddMult(const Vector &x, Vector &y, const double a) const
       });
 
    }
-
-#else // MFEM_USE_LEGACY_OPENMP
-   const double *Ap = A, *xp = x.GetData();
-   double *yp = y.GetData();
-   const int *Jp = J, *Ip = I;
-
-   #pragma omp parallel for
-   for (int i = 0; i < height; i++)
-   {
-      double d = 0.0;
-      const int end = Ip[i+1];
-      for (int j = Ip[i]; j < end; j++)
-      {
-         d += Ap[j] * xp[Jp[j]];
-      }
-      yp[i] += a * d;
-   }
-#endif // MFEM_USE_LEGACY_OPENMP
 }
 
 void SparseMatrix::MultTranspose(const Vector &x, Vector &y) const
diff --git a/linalg/vector.cpp b/linalg/vector.cpp
index 4039f87b5..4e34eb93e 100644
--- a/linalg/vector.cpp
+++ b/linalg/vector.cpp
@@ -113,9 +113,6 @@ const double &Vector::Elem(int i) const
 double Vector::operator*(const double *v) const
 {
    double dot = 0.0;
-#ifdef MFEM_USE_LEGACY_OPENMP
-   #pragma omp parallel for reduction(+:dot)
-#endif
    for (int i = 0; i < size; i++)
    {
       dot += data[i] * v[i];
@@ -326,7 +323,6 @@ void add(const Vector &v1, const Vector &v2, Vector &v)
    MFEM_ASSERT(v.size == v1.size && v.size == v2.size,
                "incompatible Vectors!");
 
-#if !defined(MFEM_USE_LEGACY_OPENMP)
    const bool use_dev = v1.UseDevice() || v2.UseDevice() || v.UseDevice();
    const int N = v.size;
    // Note: get read access first, in case v is the same as v1/v2.
@@ -334,13 +330,6 @@ void add(const Vector &v1, const Vector &v2, Vector &v)
    auto x2 = v2.Read(use_dev);
    auto y = v.Write(use_dev);
    mfem::forall_switch(use_dev, N, [=] MFEM_HOST_DEVICE (int i) { y[i] = x1[i] + x2[i]; });
-#else
-   #pragma omp parallel for
-   for (int i = 0; i < v.size; i++)
-   {
-      v.data[i] = v1.data[i] + v2.data[i];
-   }
-#endif
 }
 
 void add(const Vector &v1, double alpha, const Vector &v2, Vector &v)
@@ -358,7 +347,6 @@ void add(const Vector &v1, double alpha, const Vector &v2, Vector &v)
    }
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = v1.UseDevice() || v2.UseDevice() || v.UseDevice();
       const int N = v.size;
       // Note: get read access first, in case v is the same as v1/v2.
@@ -369,16 +357,6 @@ void add(const Vector &v1, double alpha, const Vector &v2, Vector &v)
       {
          d_z[i] = d_x[i] + alpha * d_y[i];
       });
-#else
-      const double *v1p = v1.data, *v2p = v2.data;
-      double *vp = v.data;
-      const int s = v.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         vp[i] = v1p[i] + alpha*v2p[i];
-      }
-#endif
    }
 }
 
@@ -397,7 +375,6 @@ void add(const double a, const Vector &x, const Vector &y, Vector &z)
    }
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
       const int N = x.size;
       // Note: get read access first, in case z is the same as x/y.
@@ -408,17 +385,6 @@ void add(const double a, const Vector &x, const Vector &y, Vector &z)
       {
          zd[i] = a * (xd[i] + yd[i]);
       });
-#else
-      const double *xp = x.data;
-      const double *yp = y.data;
-      double       *zp = z.data;
-      const int      s = x.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         zp[i] = a * (xp[i] + yp[i]);
-      }
-#endif
    }
 }
 
@@ -452,7 +418,6 @@ void add(const double a, const Vector &x,
 #endif
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
       const int N = x.size;
       // Note: get read access first, in case z is the same as x/y.
@@ -463,17 +428,6 @@ void add(const double a, const Vector &x,
       {
          zd[i] = a * xd[i] + b * yd[i];
       });
-#else
-      const double *xp = x.data;
-      const double *yp = y.data;
-      double       *zp = z.data;
-      const int      s = x.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         zp[i] = a * xp[i] + b * yp[i];
-      }
-#endif
    }
 }
 
@@ -482,7 +436,6 @@ void subtract(const Vector &x, const Vector &y, Vector &z)
    MFEM_ASSERT(x.size == y.size && x.size == z.size,
                "incompatible Vectors!");
 
-#if !defined(MFEM_USE_LEGACY_OPENMP)
    const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
    const int N = x.size;
    // Note: get read access first, in case z is the same as x/y.
@@ -493,17 +446,6 @@ void subtract(const Vector &x, const Vector &y, Vector &z)
    {
       zd[i] = xd[i] - yd[i];
    });
-#else
-   const double *xp = x.data;
-   const double *yp = y.data;
-   double       *zp = z.data;
-   const int     s = x.size;
-   #pragma omp parallel for
-   for (int i = 0; i < s; i++)
-   {
-      zp[i] = xp[i] - yp[i];
-   }
-#endif
 }
 
 void subtract(const double a, const Vector &x, const Vector &y, Vector &z)
@@ -521,7 +463,6 @@ void subtract(const double a, const Vector &x, const Vector &y, Vector &z)
    }
    else
    {
-#if !defined(MFEM_USE_LEGACY_OPENMP)
       const bool use_dev = x.UseDevice() || y.UseDevice() || z.UseDevice();
       const int N = x.size;
       // Note: get read access first, in case z is the same as x/y.
@@ -532,17 +473,6 @@ void subtract(const double a, const Vector &x, const Vector &y, Vector &z)
       {
          zd[i] = a * (xd[i] - yd[i]);
       });
-#else
-      const double *xp = x.data;
-      const double *yp = y.data;
-      double       *zp = z.data;
-      const int      s = x.size;
-      #pragma omp parallel for
-      for (int i = 0; i < s; i++)
-      {
-         zp[i] = a * (xp[i] - yp[i]);
-      }
-#endif
    }
 }
 
diff --git a/makefile b/makefile
index 741393470..7ac4c38ac 100644
--- a/makefile
+++ b/makefile
@@ -265,16 +265,6 @@ endif
 
 DEP_CXX ?= $(MFEM_CXX)
 
-# Check legacy OpenMP configuration
-ifeq ($(MFEM_USE_LEGACY_OPENMP),YES)
-   MFEM_THREAD_SAFE ?= YES
-   ifneq ($(MFEM_THREAD_SAFE),YES)
-      $(error Incompatible config: MFEM_USE_LEGACY_OPENMP requires MFEM_THREAD_SAFE)
-   endif
-   # NOTE: MFEM_USE_LEGACY_OPENMP cannot be combined with any of:
-   # MFEM_USE_OPENMP, MFEM_USE_CUDA, MFEM_USE_RAJA, MFEM_USE_OCCA
-endif
-
 # List of MFEM dependencies, that require the *_LIB variable to be non-empty
 MFEM_REQ_LIB_DEPS = ENZYME SUPERLU MUMPS METIS FMS CONDUIT SIDRE LAPACK SUNDIALS\
  SUITESPARSE STRUMPACK GINKGO GNUTLS NETCDF PETSC SLEPC MPFR PUMI HIOP\
@@ -339,16 +329,16 @@ endif
 MFEM_DEFINES = MFEM_VERSION MFEM_VERSION_STRING MFEM_GIT_STRING MFEM_USE_MPI\
  MFEM_USE_METIS MFEM_USE_METIS_5 MFEM_DEBUG MFEM_USE_EXCEPTIONS MFEM_USE_ZLIB\
  MFEM_USE_LIBUNWIND MFEM_USE_LAPACK MFEM_THREAD_SAFE MFEM_USE_OPENMP\
- MFEM_USE_LEGACY_OPENMP MFEM_USE_MEMALLOC MFEM_TIMER_TYPE MFEM_USE_SUNDIALS\
- MFEM_USE_SUITESPARSE MFEM_USE_GINKGO MFEM_USE_SUPERLU MFEM_USE_SUPERLU5\
- MFEM_USE_STRUMPACK MFEM_USE_GNUTLS MFEM_USE_NETCDF MFEM_USE_PETSC\
- MFEM_USE_SLEPC MFEM_USE_MPFR MFEM_USE_SIDRE MFEM_USE_FMS MFEM_USE_CONDUIT\
- MFEM_USE_PUMI MFEM_USE_HIOP MFEM_USE_GSLIB MFEM_USE_CUDA MFEM_USE_HIP\
- MFEM_USE_OCCA MFEM_USE_MOONOLITH MFEM_USE_CEED MFEM_USE_RAJA MFEM_USE_UMPIRE\
- MFEM_USE_SIMD MFEM_USE_ADIOS2 MFEM_USE_MKL_CPARDISO MFEM_USE_AMGX\
- MFEM_USE_MUMPS MFEM_USE_ADFORWARD MFEM_USE_CODIPACK MFEM_USE_CALIPER\
- MFEM_USE_BENCHMARK MFEM_USE_PARELAG MFEM_USE_ALGOIM MFEM_USE_ENZYME\
- MFEM_SOURCE_DIR MFEM_INSTALL_DIR MFEM_SHARED_BUILD
+ MFEM_USE_MEMALLOC MFEM_TIMER_TYPE MFEM_USE_SUNDIALS MFEM_USE_SUITESPARSE\
+ MFEM_USE_GINKGO MFEM_USE_SUPERLU MFEM_USE_SUPERLU5 MFEM_USE_STRUMPACK\
+ MFEM_USE_GNUTLS MFEM_USE_NETCDF MFEM_USE_PETSC MFEM_USE_SLEPC MFEM_USE_MPFR\
+ MFEM_USE_SIDRE MFEM_USE_FMS MFEM_USE_CONDUIT MFEM_USE_PUMI MFEM_USE_HIOP\
+ MFEM_USE_GSLIB MFEM_USE_CUDA MFEM_USE_HIP MFEM_USE_OCCA MFEM_USE_MOONOLITH\
+ MFEM_USE_CEED MFEM_USE_RAJA MFEM_USE_UMPIRE MFEM_USE_SIMD MFEM_USE_ADIOS2\
+ MFEM_USE_MKL_CPARDISO MFEM_USE_AMGX MFEM_USE_MUMPS MFEM_USE_ADFORWARD\
+ MFEM_USE_CODIPACK MFEM_USE_CALIPER MFEM_USE_BENCHMARK MFEM_USE_PARELAG\
+ MFEM_USE_ALGOIM MFEM_USE_ENZYME MFEM_SOURCE_DIR MFEM_INSTALL_DIR\
+ MFEM_SHARED_BUILD
 
 # List of makefile variables that will be written to config.mk:
 MFEM_CONFIG_VARS = MFEM_CXX MFEM_HOST_CXX MFEM_CPPFLAGS MFEM_CXXFLAGS\
@@ -672,7 +662,6 @@ status info:
 	$(info MFEM_USE_LAPACK        = $(MFEM_USE_LAPACK))
 	$(info MFEM_THREAD_SAFE       = $(MFEM_THREAD_SAFE))
 	$(info MFEM_USE_OPENMP        = $(MFEM_USE_OPENMP))
-	$(info MFEM_USE_LEGACY_OPENMP = $(MFEM_USE_LEGACY_OPENMP))
 	$(info MFEM_USE_MEMALLOC      = $(MFEM_USE_MEMALLOC))
 	$(info MFEM_TIMER_TYPE        = $(MFEM_TIMER_TYPE))
 	$(info MFEM_USE_SUNDIALS      = $(MFEM_USE_SUNDIALS))
@@ -756,10 +745,6 @@ deprecation-warnings:
 	@if [ -t 1 ]; then\
 	   red="\033[0;31m"; yellow="\033[0;33m"; end="\033[0m";\
 	 fi;\
-	if [ $(MFEM_USE_LEGACY_OPENMP) = YES ]; then\
-	  printf $$red"[MFEM_USE_LEGACY_OPENMP]"$$end": "$$yellow"%s"$$end"\n"\
-	  $(DEPRECATION_WARNING);\
-	fi
 
 # $(call mfem_check_command, command-to-execute, success_msg, failed_msg)
 mfem_check_command = \
diff --git a/miniapps/performance/ex1.cpp b/miniapps/performance/ex1.cpp
index e2271585c..916e7022e 100644
--- a/miniapps/performance/ex1.cpp
+++ b/miniapps/performance/ex1.cpp
@@ -317,8 +317,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ref_levels, int order, int basis,
    cout << "Assembling the bilinear form ..." << flush;
    tic_toc.Clear();
    tic_toc.Start();
-   // Pre-allocate sparsity assuming dense element matrices
-   a->UsePrecomputedSparsity();
 
    HPCBilinearForm *a_hpc = NULL;
    Operator *a_oper = NULL;
@@ -373,7 +371,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ref_levels, int order, int basis,
    {
       // TODO: assemble the LOR matrix using the performance code
       a_pc->AddDomainIntegrator(new DiffusionIntegrator(one));
-      a_pc->UsePrecomputedSparsity();
       a_pc->Assemble();
       a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
    }
@@ -385,7 +382,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ref_levels, int order, int basis,
       }
       else
       {
-         a_pc->UsePrecomputedSparsity();
          a_hpc->AssembleBilinearForm(*a_pc);
          a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
       }
diff --git a/miniapps/performance/ex1p.cpp b/miniapps/performance/ex1p.cpp
index 79735c7ff..1e80576bb 100644
--- a/miniapps/performance/ex1p.cpp
+++ b/miniapps/performance/ex1p.cpp
@@ -390,8 +390,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ser_ref_levels, int par_ref_levels,
    }
    tic_toc.Clear();
    tic_toc.Start();
-   // Pre-allocate sparsity assuming dense element matrices
-   a->UsePrecomputedSparsity();
 
    HPCBilinearForm *a_hpc = NULL;
    Operator *a_oper = NULL;
@@ -460,7 +458,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ser_ref_levels, int par_ref_levels,
    {
       // TODO: assemble the LOR matrix using the performance code
       a_pc->AddDomainIntegrator(new DiffusionIntegrator(one));
-      a_pc->UsePrecomputedSparsity();
       a_pc->Assemble();
       a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
    }
@@ -472,7 +469,6 @@ int ex1_t<dim>::run(Mesh *mesh, int ser_ref_levels, int par_ref_levels,
       }
       else
       {
-         a_pc->UsePrecomputedSparsity();
          a_hpc->AssembleBilinearForm(*a_pc);
          a_pc->FormSystemMatrix(ess_tdof_list, A_pc);
       }
diff --git a/tests/scripts/branch-history b/tests/scripts/branch-history
index 274d26d0b..f0c038df7 100755
--- a/tests/scripts/branch-history
+++ b/tests/scripts/branch-history
@@ -149,7 +149,7 @@ foreach my $sha (@commits) {
         # File was added
         $blob_size += int(`git cat-file -s $dst`); }
       elsif ($mode eq "DD") { }
-      elsif ($mode eq "MM" || $mode eq "MR") {
+      elsif ($mode eq "MM" || $mode eq "MR" || $mode eq "RM") {
         # File was modified, use the gzip'ed diff as a proxy of the required git
         # storage
         my $sz1 = int(`git diff -U0 --binary $src1 $dst | gzip -c | wc -c`);
diff --git a/tests/unit/fem/test_assemblediagonalpa.cpp b/tests/unit/fem/test_assemblediagonalpa.cpp
index ebbb8e224..050561e1d 100644
--- a/tests/unit/fem/test_assemblediagonalpa.cpp
+++ b/tests/unit/fem/test_assemblediagonalpa.cpp
@@ -17,11 +17,9 @@ using namespace mfem;
 namespace assemblediagonalpa
 {
 
-int dimension;
-
 double coeffFunction(const Vector& x)
 {
-   if (dimension == 2)
+   if (x.Size() == 2)
    {
       return sin(8.0 * M_PI * x[0]) * cos(6.0 * M_PI * x[1]) + 2.0;
    }
@@ -36,12 +34,12 @@ double coeffFunction(const Vector& x)
 void vectorCoeffFunction(const Vector & x, Vector & f)
 {
    f = 0.0;
-   if (dimension > 1)
+   if (x.Size() > 1)
    {
       f[0] = sin(M_PI * x[1]);
       f[1] = sin(2.5 * M_PI * x[0]);
    }
-   if (dimension == 3)
+   if (x.Size() == 3)
    {
       f[2] = sin(6.1 * M_PI * x[2]);
    }
@@ -50,14 +48,14 @@ void vectorCoeffFunction(const Vector & x, Vector & f)
 void asymmetricMatrixCoeffFunction(const Vector & x, DenseMatrix & f)
 {
    f = 0.0;
-   if (dimension == 2)
+   if (x.Size() == 2)
    {
       f(0,0) = 1.1 + sin(M_PI * x[1]);  // 1,1
       f(1,0) = cos(1.3 * M_PI * x[1]);  // 2,1
       f(0,1) = cos(2.5 * M_PI * x[0]);  // 1,2
       f(1,1) = 1.1 + sin(4.9 * M_PI * x[0]);  // 2,2
    }
-   else if (dimension == 3)
+   else if (x.Size() == 3)
    {
       f(0,0) = 1.1 + sin(M_PI * x[1]);  // 1,1
       f(0,1) = cos(2.5 * M_PI * x[0]);  // 1,2
@@ -74,13 +72,13 @@ void asymmetricMatrixCoeffFunction(const Vector & x, DenseMatrix & f)
 void symmetricMatrixCoeffFunction(const Vector & x, DenseSymmetricMatrix & f)
 {
    f = 0.0;
-   if (dimension == 2)
+   if (x.Size() == 2)
    {
       f(0,0) = 1.1 + sin(M_PI * x[1]);  // 1,1
       f(0,1) = cos(2.5 * M_PI * x[0]);  // 1,2
       f(1,1) = 1.1 + sin(4.9 * M_PI * x[0]);  // 2,2
    }
-   else if (dimension == 3)
+   else if (x.Size() == 3)
    {
       f(0,0) = sin(M_PI * x[1]);  // 1,1
       f(0,1) = cos(2.5 * M_PI * x[0]);  // 1,2
@@ -93,7 +91,7 @@ void symmetricMatrixCoeffFunction(const Vector & x, DenseSymmetricMatrix & f)
 
 TEST_CASE("Mass Diagonal PA", "[PartialAssembly][AssembleDiagonal]")
 {
-   for (dimension = 2; dimension < 4; ++dimension)
+   for (int dimension = 2; dimension < 4; ++dimension)
    {
       for (int ne = 1; ne < 3; ++ne)
       {
@@ -140,9 +138,45 @@ TEST_CASE("Mass Diagonal PA", "[PartialAssembly][AssembleDiagonal]")
    }
 }
 
+TEST_CASE("Mass Boundary Diagonal PA", "[PartialAssembly][AssembleDiagonal]")
+{
+   const bool all_tests = launch_all_non_regression_tests;
+
+   auto fname = GENERATE("../../data/star.mesh", "../../data/star-q3.mesh",
+                         "../../data/fichera.mesh", "../../data/fichera-q3.mesh");
+   auto order = !all_tests ? 2 : GENERATE(1, 2, 3);
+
+   CAPTURE(fname, order);
+
+   Mesh mesh(fname);
+   int dim = mesh.Dimension();
+   RT_FECollection fec(order, dim);
+   FiniteElementSpace fes(&mesh, &fec);
+
+   FunctionCoefficient coeff(coeffFunction);
+
+   Vector diag_fa(fes.GetTrueVSize()), diag_pa(fes.GetTrueVSize());
+
+   BilinearForm blf_fa(&fes);
+   blf_fa.AddBoundaryIntegrator(new MassIntegrator(coeff));
+   blf_fa.Assemble();
+   blf_fa.Finalize();
+   blf_fa.SpMat().GetDiag(diag_fa);
+
+   BilinearForm blf_pa(&fes);
+   blf_pa.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   blf_pa.AddBoundaryIntegrator(new MassIntegrator(coeff));
+   blf_pa.Assemble();
+   blf_pa.AssembleDiagonal(diag_pa);
+
+   diag_pa -= diag_fa;
+
+   REQUIRE(diag_pa.Normlinf() == MFEM_Approx(0.0));
+}
+
 TEST_CASE("Diffusion Diagonal PA", "[PartialAssembly][AssembleDiagonal]")
 {
-   for (dimension = 2; dimension < 4; ++dimension)
+   for (int dimension = 2; dimension < 4; ++dimension)
    {
       for (int ne = 1; ne < 3; ++ne)
       {
@@ -322,7 +356,7 @@ TEST_CASE("Vector Diffusion Diagonal PA",
 TEST_CASE("Hcurl/Hdiv diagonal PA",
           "[CUDA][PartialAssembly][AssembleDiagonal]")
 {
-   for (dimension = 2; dimension < 4; ++dimension)
+   for (int dimension = 2; dimension < 4; ++dimension)
    {
       for (int coeffType = 0; coeffType < 5; ++coeffType)
       {
diff --git a/tests/unit/fem/test_bilinearform.cpp b/tests/unit/fem/test_bilinearform.cpp
index 5fd00b3e1..647ae38f2 100644
--- a/tests/unit/fem/test_bilinearform.cpp
+++ b/tests/unit/fem/test_bilinearform.cpp
@@ -127,7 +127,7 @@ TEST_CASE("FormLinearSystem/SolutionScope",
    // Legacy full assembly
    {
       GridFunction sol(&fes);
-      SolvePDE(AssemblyLevel::LEGACYFULL, sol);
+      SolvePDE(AssemblyLevel::LEGACY, sol);
       // Make sure the solution is still accessible after 'X' is destroyed
       sol.HostRead();
       REQUIRE(AsConst(sol)(bdr_dof) == 0.0);
diff --git a/tests/unit/fem/test_pa_grad.cpp b/tests/unit/fem/test_pa_grad.cpp
index a42d7c83c..af0038cee 100644
--- a/tests/unit/fem/test_pa_grad.cpp
+++ b/tests/unit/fem/test_pa_grad.cpp
@@ -154,7 +154,7 @@ double par_compare_pa_assembly(int dim, int num_elements, int order,
    pa_grad.AddDomainInterpolator(new GradientInterpolator);
    pa_grad.Assemble();
    OperatorPtr pa_grad_oper;
-   pa_grad.FormRectangularSystemMatrix(pa_grad_oper);
+   pa_grad.FormDiscreteOperatorMatrix(pa_grad_oper);
 
    int insize, outsize;
    if (transpose)
diff --git a/tests/unit/fem/test_pa_kernels.cpp b/tests/unit/fem/test_pa_kernels.cpp
index ddb36cdf2..673653596 100644
--- a/tests/unit/fem/test_pa_kernels.cpp
+++ b/tests/unit/fem/test_pa_kernels.cpp
@@ -9,11 +9,6 @@
 // terms of the BSD-3 license. We welcome feedback and contributions, see file
 // CONTRIBUTING.md for details.
 
-#ifdef _WIN32
-#define _USE_MATH_DEFINES
-#include <cmath>
-#endif
-
 #include "unit_tests.hpp"
 #include "mfem.hpp"
 
@@ -549,17 +544,17 @@ static void test_pa_integrator()
    GridFunction x(&fes), y_fa(&fes), y_pa(&fes);
    x.Randomize(1);
 
-   ConstantCoefficient pi(M_PI);
+   FunctionCoefficient coeff(f1);
 
    BilinearForm blf_fa(&fes);
-   blf_fa.AddDomainIntegrator(new INTEGRATOR(pi,ir));
+   blf_fa.AddDomainIntegrator(new INTEGRATOR(coeff,ir));
    blf_fa.Assemble();
    blf_fa.Finalize();
    blf_fa.Mult(x, y_fa);
 
    BilinearForm blf_pa(&fes);
    blf_pa.SetAssemblyLevel(AssemblyLevel::PARTIAL);
-   blf_pa.AddDomainIntegrator(new INTEGRATOR(pi,ir));
+   blf_pa.AddDomainIntegrator(new INTEGRATOR(coeff,ir));
    blf_pa.Assemble();
    blf_pa.Mult(x, y_pa);
 
@@ -578,4 +573,39 @@ TEST_CASE("PA Diffusion", "[PartialAssembly], [CUDA]")
    test_pa_integrator<DiffusionIntegrator>();
 } // PA Diffusion test case
 
+TEST_CASE("PA Boundary Mass", "[PartialAssembly], [CUDA]")
+{
+   const bool all_tests = launch_all_non_regression_tests;
+
+   auto fname = GENERATE("../../data/star.mesh", "../../data/star-q3.mesh",
+                         "../../data/fichera.mesh", "../../data/fichera-q3.mesh");
+   auto order = !all_tests ? 2 : GENERATE(1, 2, 3);
+
+   Mesh mesh(fname);
+   int dim = mesh.Dimension();
+   RT_FECollection fec(order, dim);
+   FiniteElementSpace fes(&mesh, &fec);
+
+   GridFunction x(&fes), y_fa(&fes), y_pa(&fes);
+   x.Randomize(1);
+
+   FunctionCoefficient coeff(f1);
+
+   BilinearForm blf_fa(&fes);
+   blf_fa.AddBoundaryIntegrator(new MassIntegrator(coeff));
+   blf_fa.Assemble();
+   blf_fa.Finalize();
+   blf_fa.Mult(x, y_fa);
+
+   BilinearForm blf_pa(&fes);
+   blf_pa.SetAssemblyLevel(AssemblyLevel::PARTIAL);
+   blf_pa.AddBoundaryIntegrator(new MassIntegrator(coeff));
+   blf_pa.Assemble();
+   blf_pa.Mult(x, y_pa);
+
+   y_fa -= y_pa;
+
+   REQUIRE(y_fa.Normlinf() == MFEM_Approx(0.0));
+}
+
 } // namespace pa_kernels
