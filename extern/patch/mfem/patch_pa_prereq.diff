diff --git a/fem/bilinearform.cpp b/fem/bilinearform.cpp
index fad9717aa..08862ac1c 100644
--- a/fem/bilinearform.cpp
+++ b/fem/bilinearform.cpp
@@ -63,8 +63,8 @@ void BilinearForm::AllocMat()
    dof_dof.LoseData();
 }
 
-BilinearForm::BilinearForm(FiniteElementSpace * f)
-   : Matrix (f->GetVSize())
+BilinearForm::BilinearForm(FiniteElementSpace *f)
+   : Matrix(f->GetVSize())
 {
    fes = f;
    sequence = f->GetSequence();
@@ -81,8 +81,8 @@ BilinearForm::BilinearForm(FiniteElementSpace * f)
    ext = NULL;
 }
 
-BilinearForm::BilinearForm (FiniteElementSpace * f, BilinearForm * bf, int ps)
-   : Matrix (f->GetVSize())
+BilinearForm::BilinearForm(FiniteElementSpace *f, BilinearForm *bf, int ps)
+   : Matrix(f->GetVSize())
 {
    fes = f;
    sequence = f->GetSequence();
@@ -124,7 +124,7 @@ void BilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
       case AssemblyLevel::LEGACY:
          break;
       case AssemblyLevel::FULL:
-         SetDiagonalPolicy( DIAG_ONE ); // Only diagonal policy supported on device
+         SetDiagonalPolicy(DIAG_ONE); // Only diagonal policy supported on device
          ext = new FABilinearFormExtension(this);
          break;
       case AssemblyLevel::ELEMENT:
@@ -207,22 +207,71 @@ void BilinearForm::UseSparsity(SparseMatrix &A)
    UseSparsity(A.GetI(), A.GetJ(), A.ColumnsAreSorted());
 }
 
-double& BilinearForm::Elem (int i, int j)
+double &BilinearForm::Elem(int i, int j)
 {
-   return mat -> Elem(i,j);
+   return mat->Elem(i,j);
 }
 
-const double& BilinearForm::Elem (int i, int j) const
+const double &BilinearForm::Elem(int i, int j) const
 {
-   return mat -> Elem(i,j);
+   return mat->Elem(i,j);
 }
 
-MatrixInverse * BilinearForm::Inverse() const
+void BilinearForm::Mult(const Vector &x, Vector &y) const
+{
+   if (ext)
+   {
+      ext->Mult(x, y);
+   }
+   else
+   {
+      mat->Mult(x, y);
+   }
+}
+
+void BilinearForm::AddMult(const Vector &x, Vector &y, const double a) const
+{
+   if (ext)
+   {
+      ext->AddMult(x, y, a);
+   }
+   else
+   {
+      mat->AddMult(x, y, a);
+   }
+}
+
+void BilinearForm::MultTranspose(const Vector &x, Vector &y) const
+{
+   if (ext)
+   {
+      ext->MultTranspose(x, y);
+   }
+   else
+   {
+      mat->MultTranspose(x, y);
+   }
+}
+
+void BilinearForm::AddMultTranspose(const Vector &x, Vector &y,
+                                    const double a) const
+{
+   if (ext)
+   {
+      ext->AddMultTranspose(x, y, a);
+   }
+   else
+   {
+      mat->AddMultTranspose(x, y, a);
+   }
+}
+
+MatrixInverse *BilinearForm::Inverse() const
 {
-   return mat -> Inverse();
+   return mat->Inverse();
 }
 
-void BilinearForm::Finalize (int skip_zeros)
+void BilinearForm::Finalize(int skip_zeros)
 {
    if (assembly == AssemblyLevel::LEGACY)
    {
@@ -246,22 +295,22 @@ void BilinearForm::AddDomainIntegrator(BilinearFormIntegrator *bfi,
    domain_integs_marker.Append(&elem_marker);
 }
 
-void BilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi)
+void BilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(NULL); // NULL marker means apply everywhere
 }
 
-void BilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi,
-                                          Array<int> &bdr_marker)
+void BilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi,
+                                         Array<int> &bdr_marker)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(&bdr_marker);
 }
 
-void BilinearForm::AddInteriorFaceIntegrator(BilinearFormIntegrator * bfi)
+void BilinearForm::AddInteriorFaceIntegrator(BilinearFormIntegrator *bfi)
 {
-   interior_face_integs.Append (bfi);
+   interior_face_integs.Append(bfi);
 }
 
 void BilinearForm::AddBdrFaceIntegrator(BilinearFormIntegrator *bfi)
@@ -392,8 +441,8 @@ void BilinearForm::Assemble(int skip_zeros)
    }
 
    ElementTransformation *eltrans;
-   DofTransformation * doftrans;
-   Mesh *mesh = fes -> GetMesh();
+   DofTransformation *doftrans;
+   Mesh *mesh = fes->GetMesh();
    DenseMatrix elmat, *elmat_p;
 
    if (mat == NULL)
@@ -423,7 +472,7 @@ void BilinearForm::Assemble(int skip_zeros)
          }
       }
 
-      for (int i = 0; i < fes -> GetNE(); i++)
+      for (int i = 0; i < fes->GetNE(); i++)
       {
          int elem_attr = fes->GetMesh()->GetAttribute(i);
          doftrans = fes->GetElementVDofs(i, vdofs);
@@ -504,14 +553,14 @@ void BilinearForm::Assemble(int skip_zeros)
          }
       }
 
-      for (int i = 0; i < fes -> GetNBE(); i++)
+      for (int i = 0; i < fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
 
          const FiniteElement &be = *fes->GetBE(i);
-         doftrans = fes -> GetBdrElementVDofs (i, vdofs);
-         eltrans = fes -> GetBdrElementTransformation (i);
+         doftrans = fes->GetBdrElementVDofs(i, vdofs);
+         eltrans = fes->GetBdrElementTransformation(i);
          int k = 0;
          for (; k < boundary_integs.Size(); k++)
          {
@@ -558,19 +607,18 @@ void BilinearForm::Assemble(int skip_zeros)
       int nfaces = mesh->GetNumFaces();
       for (int i = 0; i < nfaces; i++)
       {
-         tr = mesh -> GetInteriorFaceTransformations (i);
+         tr = mesh->GetInteriorFaceTransformations(i);
          if (tr != NULL)
          {
-            fes -> GetElementVDofs (tr -> Elem1No, vdofs);
-            fes -> GetElementVDofs (tr -> Elem2No, vdofs2);
-            vdofs.Append (vdofs2);
+            fes->GetElementVDofs(tr->Elem1No, vdofs);
+            fes->GetElementVDofs(tr->Elem2No, vdofs2);
+            vdofs.Append(vdofs2);
             for (int k = 0; k < interior_face_integs.Size(); k++)
             {
-               interior_face_integs[k]->
-               AssembleFaceMatrix(*fes->GetFE(tr->Elem1No),
-                                  *fes->GetFE(tr->Elem2No),
-                                  *tr, elemmat);
-               mat -> AddSubMatrix (vdofs, vdofs, elemmat, skip_zeros);
+               interior_face_integs[k]->AssembleFaceMatrix(*fes->GetFE(tr->Elem1No),
+                                                           *fes->GetFE(tr->Elem2No),
+                                                           *tr, elemmat);
+               mat->AddSubMatrix(vdofs, vdofs, elemmat, skip_zeros);
             }
          }
       }
@@ -602,16 +650,16 @@ void BilinearForm::Assemble(int skip_zeros)
          }
       }
 
-      for (int i = 0; i < fes -> GetNBE(); i++)
+      for (int i = 0; i < fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
 
-         tr = mesh -> GetBdrFaceTransformations (i);
+         tr = mesh->GetBdrFaceTransformations(i);
          if (tr != NULL)
          {
-            fes -> GetElementVDofs (tr -> Elem1No, vdofs);
-            fe1 = fes -> GetFE (tr -> Elem1No);
+            fes->GetElementVDofs(tr->Elem1No, vdofs);
+            fe1 = fes->GetFE(tr->Elem1No);
             // The fe2 object is really a dummy and not used on the boundaries,
             // but we can't dereference a NULL pointer, and we don't want to
             // actually make a fake element.
@@ -622,9 +670,9 @@ void BilinearForm::Assemble(int skip_zeros)
                    (*boundary_face_integs_marker[k])[bdr_attr-1] == 0)
                { continue; }
 
-               boundary_face_integs[k] -> AssembleFaceMatrix (*fe1, *fe2, *tr,
-                                                              elemmat);
-               mat -> AddSubMatrix (vdofs, vdofs, elemmat, skip_zeros);
+               boundary_face_integs[k]->AssembleFaceMatrix(*fe1, *fe2, *tr,
+                                                           elemmat);
+               mat->AddSubMatrix(vdofs, vdofs, elemmat, skip_zeros);
             }
          }
       }
@@ -644,8 +692,9 @@ void BilinearForm::ConformingAssemble()
    // matrix which in turn will give rise to symmetric structure in the new
    // matrix. This ensures that subsequent calls to EliminateRowCol will work
    // correctly.
-   Finalize(0);
    MFEM_ASSERT(mat, "the BilinearForm is not assembled");
+   const int remove_zeros = 0;
+   Finalize(remove_zeros);
 
    const SparseMatrix *P = fes->GetConformingProlongation();
    if (!P) { return; } // conforming mesh
@@ -693,7 +742,6 @@ void BilinearForm::AssembleDiagonal(Vector &diag) const
       return;
    }
    // Here, we have extension, ext, and conforming prolongation, cP.
-
    // For an AMR mesh, a convergent diagonal is assembled with |P^T| d_l,
    // where |P^T| has the entry-wise absolute values of the conforming
    // prolongation transpose operator.
@@ -708,12 +756,26 @@ void BilinearForm::FormLinearSystem(const Array<int> &ess_tdof_list, Vector &x,
 {
    if (ext)
    {
-      ext->FormLinearSystem(ess_tdof_list, x, b, A, X, B, copy_interior);
+      Operator *oper;
+      ext->FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         delete oper;
+         FormSystemMatrix(ess_tdof_list, A);
+      }
+      else
+      {
+         A.Reset(oper);
+      }
       return;
    }
-   const SparseMatrix *P = fes->GetConformingProlongation();
+
+   // Finish the matrix assembly and perform BC elimination, storing the
+   // eliminated part of the matrix.
    FormSystemMatrix(ess_tdof_list, A);
 
+   const SparseMatrix *P = fes->GetConformingProlongation();
+
    // Transform the system and perform the elimination in B, based on the
    // essential BC values from x. Restrict the BC part of x in X, and set the
    // non-BC part to zero. Since there is no good initial guess for the Lagrange
@@ -776,7 +838,23 @@ void BilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
 {
    if (ext)
    {
-      ext->FormSystemMatrix(ess_tdof_list, A);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         // Always does `DIAG_ONE` policy to be consistent with
+         // `Operator::FormConstrainedSystemOperator`.
+         MFEM_VERIFY(diag_policy == DiagonalPolicy::DIAG_ONE,
+                     "Only DiagonalPolicy::DIAG_ONE supported with"
+                     " FABilinearFormExtension.");
+         ConformingAssemble();
+         mat->EliminateBC(ess_tdof_list, DiagonalPolicy::DIAG_ONE);
+         A.Reset(mat, false);
+      }
+      else
+      {
+         Operator *oper;
+         ext->FormSystemOperator(ess_tdof_list, oper);
+         A.Reset(oper);
+      }
       return;
    }
 
@@ -797,8 +875,7 @@ void BilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
    {
       if (!mat_e)
       {
-         const SparseMatrix *P = fes->GetConformingProlongation();
-         if (P) { ConformingAssemble(); }
+         ConformingAssemble();
          EliminateVDofs(ess_tdof_list, diag_policy);
          const int remove_zeros = 0;
          Finalize(remove_zeros);
@@ -949,8 +1026,8 @@ void BilinearForm::EliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
    }
 }
 
-void BilinearForm::EliminateEssentialBCDiag (const Array<int> &bdr_attr_is_ess,
-                                             double value)
+void BilinearForm::EliminateEssentialBCDiag(const Array<int> &bdr_attr_is_ess,
+                                            double value)
 {
    Array<int> ess_dofs, conf_ess_dofs;
    fes->GetEssentialVDofs(bdr_attr_is_ess, ess_dofs);
@@ -976,11 +1053,11 @@ void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
       int vdof = vdofs_[i];
       if ( vdof >= 0 )
       {
-         mat -> EliminateRowCol (vdof, sol(vdof), rhs, dpolicy);
+         mat->EliminateRowCol(vdof, sol(vdof), rhs, dpolicy);
       }
       else
       {
-         mat -> EliminateRowCol (-1-vdof, sol(-1-vdof), rhs, dpolicy);
+         mat->EliminateRowCol(-1-vdof, sol(-1-vdof), rhs, dpolicy);
       }
    }
 }
@@ -999,11 +1076,11 @@ void BilinearForm::EliminateVDofs(const Array<int> &vdofs_,
       int vdof = vdofs_[i];
       if ( vdof >= 0 )
       {
-         mat -> EliminateRowCol (vdof, *mat_e, dpolicy);
+         mat->EliminateRowCol(vdof, *mat_e, dpolicy);
       }
       else
       {
-         mat -> EliminateRowCol (-1-vdof, *mat_e, dpolicy);
+         mat->EliminateRowCol(-1-vdof, *mat_e, dpolicy);
       }
    }
 }
@@ -1019,31 +1096,31 @@ void BilinearForm::EliminateEssentialBCFromDofs(
    for (int i = 0; i < ess_dofs.Size(); i++)
       if (ess_dofs[i] < 0)
       {
-         mat -> EliminateRowCol (i, sol(i), rhs, dpolicy);
+         mat->EliminateRowCol(i, sol(i), rhs, dpolicy);
       }
 }
 
-void BilinearForm::EliminateEssentialBCFromDofs (const Array<int> &ess_dofs,
-                                                 DiagonalPolicy dpolicy)
+void BilinearForm::EliminateEssentialBCFromDofs(const Array<int> &ess_dofs,
+                                                DiagonalPolicy dpolicy)
 {
    MFEM_ASSERT(ess_dofs.Size() == height, "incorrect dof Array size");
 
    for (int i = 0; i < ess_dofs.Size(); i++)
       if (ess_dofs[i] < 0)
       {
-         mat -> EliminateRowCol (i, dpolicy);
+         mat->EliminateRowCol(i, dpolicy);
       }
 }
 
-void BilinearForm::EliminateEssentialBCFromDofsDiag (const Array<int> &ess_dofs,
-                                                     double value)
+void BilinearForm::EliminateEssentialBCFromDofsDiag(const Array<int> &ess_dofs,
+                                                    double value)
 {
    MFEM_ASSERT(ess_dofs.Size() == height, "incorrect dof Array size");
 
    for (int i = 0; i < ess_dofs.Size(); i++)
       if (ess_dofs[i] < 0)
       {
-         mat -> EliminateRowColDiag (i, value);
+         mat->EliminateRowColDiag(i, value);
       }
 }
 
@@ -1054,31 +1131,6 @@ void BilinearForm::EliminateVDofsInRHS(
    mat->PartMult(vdofs_, x, b);
 }
 
-void BilinearForm::Mult(const Vector &x, Vector &y) const
-{
-   if (ext)
-   {
-      ext->Mult(x, y);
-   }
-   else
-   {
-      mat->Mult(x, y);
-   }
-}
-
-void BilinearForm::MultTranspose(const Vector & x, Vector & y) const
-{
-   if (ext)
-   {
-      ext->MultTranspose(x, y);
-   }
-   else
-   {
-      y = 0.0;
-      AddMultTranspose (x, y);
-   }
-}
-
 void BilinearForm::Update(FiniteElementSpace *nfes)
 {
    bool full_update;
@@ -1121,11 +1173,6 @@ void BilinearForm::Update(FiniteElementSpace *nfes)
    if (ext) { ext->Update(); }
 }
 
-void BilinearForm::SetDiagonalPolicy(DiagonalPolicy policy)
-{
-   diag_policy = policy;
-}
-
 BilinearForm::~BilinearForm()
 {
    delete mat_e;
@@ -1149,8 +1196,8 @@ BilinearForm::~BilinearForm()
 }
 
 
-MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
-                                      FiniteElementSpace *te_fes)
+MixedBilinearForm::MixedBilinearForm(FiniteElementSpace *tr_fes,
+                                     FiniteElementSpace *te_fes)
    : Matrix(te_fes->GetVSize(), tr_fes->GetVSize())
 {
    trial_fes = tr_fes;
@@ -1162,9 +1209,9 @@ MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
    ext = NULL;
 }
 
-MixedBilinearForm::MixedBilinearForm (FiniteElementSpace *tr_fes,
-                                      FiniteElementSpace *te_fes,
-                                      MixedBilinearForm * mbf)
+MixedBilinearForm::MixedBilinearForm(FiniteElementSpace *tr_fes,
+                                     FiniteElementSpace *te_fes,
+                                     MixedBilinearForm *mbf)
    : Matrix(te_fes->GetVSize(), tr_fes->GetVSize())
 {
    trial_fes = tr_fes;
@@ -1210,31 +1257,36 @@ void MixedBilinearForm::SetAssemblyLevel(AssemblyLevel assembly_level)
          ext = new PAMixedBilinearFormExtension(this);
          break;
       case AssemblyLevel::NONE:
-         mfem_error("Matrix-free action not supported yet... stay tuned!");
-         // ext = new MFMixedBilinearFormExtension(this);
+         ext = new MFMixedBilinearFormExtension(this);
          break;
       default:
          mfem_error("Unknown assembly level");
    }
 }
 
-double & MixedBilinearForm::Elem (int i, int j)
+double &MixedBilinearForm::Elem(int i, int j)
 {
    return (*mat)(i, j);
 }
 
-const double & MixedBilinearForm::Elem (int i, int j) const
+const double &MixedBilinearForm::Elem(int i, int j) const
 {
    return (*mat)(i, j);
 }
 
-void MixedBilinearForm::Mult(const Vector & x, Vector & y) const
+void MixedBilinearForm::Mult(const Vector &x, Vector &y) const
 {
-   y = 0.0;
-   AddMult(x, y);
+   if (ext)
+   {
+      ext->Mult(x, y);
+   }
+   else
+   {
+      mat->Mult(x, y);
+   }
 }
 
-void MixedBilinearForm::AddMult(const Vector & x, Vector & y,
+void MixedBilinearForm::AddMult(const Vector &x, Vector &y,
                                 const double a) const
 {
    if (ext)
@@ -1247,13 +1299,19 @@ void MixedBilinearForm::AddMult(const Vector & x, Vector & y,
    }
 }
 
-void MixedBilinearForm::MultTranspose(const Vector & x, Vector & y) const
+void MixedBilinearForm::MultTranspose(const Vector &x, Vector &y) const
 {
-   y = 0.0;
-   AddMultTranspose(x, y);
+   if (ext)
+   {
+      ext->MultTranspose(x, y);
+   }
+   else
+   {
+      mat->MultTranspose(x, y);
+   }
 }
 
-void MixedBilinearForm::AddMultTranspose(const Vector & x, Vector & y,
+void MixedBilinearForm::AddMultTranspose(const Vector &x, Vector &y,
                                          const double a) const
 {
    if (ext)
@@ -1266,7 +1324,7 @@ void MixedBilinearForm::AddMultTranspose(const Vector & x, Vector & y,
    }
 }
 
-MatrixInverse * MixedBilinearForm::Inverse() const
+MatrixInverse *MixedBilinearForm::Inverse() const
 {
    if (assembly != AssemblyLevel::LEGACY)
    {
@@ -1276,15 +1334,15 @@ MatrixInverse * MixedBilinearForm::Inverse() const
    }
    else
    {
-      return mat -> Inverse ();
+      return mat->Inverse();
    }
 }
 
-void MixedBilinearForm::Finalize (int skip_zeros)
+void MixedBilinearForm::Finalize(int skip_zeros)
 {
    if (assembly == AssemblyLevel::LEGACY)
    {
-      mat -> Finalize (skip_zeros);
+      mat->Finalize(skip_zeros);
    }
 }
 
@@ -1300,27 +1358,27 @@ void MixedBilinearForm::GetBlocks(Array2D<SparseMatrix *> &blocks) const
    mat->GetBlocks(blocks);
 }
 
-void MixedBilinearForm::AddDomainIntegrator (BilinearFormIntegrator * bfi)
+void MixedBilinearForm::AddDomainIntegrator(BilinearFormIntegrator *bfi)
 {
-   domain_integs.Append (bfi);
+   domain_integs.Append(bfi);
 }
 
-void MixedBilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi)
+void MixedBilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(NULL); // NULL marker means apply everywhere
 }
 
-void MixedBilinearForm::AddBoundaryIntegrator (BilinearFormIntegrator * bfi,
-                                               Array<int> &bdr_marker)
+void MixedBilinearForm::AddBoundaryIntegrator(BilinearFormIntegrator *bfi,
+                                              Array<int> &bdr_marker)
 {
-   boundary_integs.Append (bfi);
+   boundary_integs.Append(bfi);
    boundary_integs_marker.Append(&bdr_marker);
 }
 
-void MixedBilinearForm::AddTraceFaceIntegrator (BilinearFormIntegrator * bfi)
+void MixedBilinearForm::AddTraceFaceIntegrator(BilinearFormIntegrator *bfi)
 {
-   trace_face_integs.Append (bfi);
+   trace_face_integs.Append(bfi);
 }
 
 void MixedBilinearForm::AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi)
@@ -1337,7 +1395,7 @@ void MixedBilinearForm::AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi,
    boundary_trace_face_integs_marker.Append(&bdr_marker);
 }
 
-void MixedBilinearForm::Assemble (int skip_zeros)
+void MixedBilinearForm::Assemble(int skip_zeros)
 {
    if (ext)
    {
@@ -1346,12 +1404,11 @@ void MixedBilinearForm::Assemble (int skip_zeros)
    }
 
    ElementTransformation *eltrans;
-   DofTransformation * dom_dof_trans;
-   DofTransformation * ran_dof_trans;
+   DofTransformation *dom_dof_trans;
+   DofTransformation *ran_dof_trans;
+   Mesh *mesh = test_fes->GetMesh();
    DenseMatrix elmat;
 
-   Mesh *mesh = test_fes -> GetMesh();
-
    if (mat == NULL)
    {
       mat = new SparseMatrix(height, width);
@@ -1359,26 +1416,26 @@ void MixedBilinearForm::Assemble (int skip_zeros)
 
    if (domain_integs.Size())
    {
-      for (int i = 0; i < test_fes -> GetNE(); i++)
+      for (int i = 0; i < test_fes->GetNE(); i++)
       {
-         dom_dof_trans = trial_fes -> GetElementVDofs (i, trial_vdofs);
-         ran_dof_trans = test_fes  -> GetElementVDofs (i, test_vdofs);
-         eltrans = test_fes -> GetElementTransformation (i);
+         dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
+         ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
+         eltrans = test_fes->GetElementTransformation(i);
 
          elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
          elmat = 0.0;
          for (int k = 0; k < domain_integs.Size(); k++)
          {
-            domain_integs[k] -> AssembleElementMatrix2 (*trial_fes -> GetFE(i),
-                                                        *test_fes  -> GetFE(i),
-                                                        *eltrans, elemmat);
+            domain_integs[k]->AssembleElementMatrix2(*trial_fes->GetFE(i),
+                                                     *test_fes->GetFE(i),
+                                                     *eltrans, elemmat);
             elmat += elemmat;
          }
          if (ran_dof_trans || dom_dof_trans)
          {
             TransformDual(ran_dof_trans, dom_dof_trans, elmat);
          }
-         mat -> AddSubMatrix (test_vdofs, trial_vdofs, elmat, skip_zeros);
+         mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 
@@ -1405,14 +1462,14 @@ void MixedBilinearForm::Assemble (int skip_zeros)
          }
       }
 
-      for (int i = 0; i < test_fes -> GetNBE(); i++)
+      for (int i = 0; i < test_fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
 
-         dom_dof_trans = trial_fes -> GetBdrElementVDofs (i, trial_vdofs);
-         ran_dof_trans = test_fes  -> GetBdrElementVDofs (i, test_vdofs);
-         eltrans = test_fes -> GetBdrElementTransformation (i);
+         dom_dof_trans = trial_fes->GetBdrElementVDofs(i, trial_vdofs);
+         ran_dof_trans = test_fes->GetBdrElementVDofs(i, test_vdofs);
+         eltrans = test_fes->GetBdrElementTransformation(i);
 
          elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
          elmat = 0.0;
@@ -1421,16 +1478,16 @@ void MixedBilinearForm::Assemble (int skip_zeros)
             if (boundary_integs_marker[k] &&
                 (*boundary_integs_marker[k])[bdr_attr-1] == 0) { continue; }
 
-            boundary_integs[k]->AssembleElementMatrix2 (*trial_fes -> GetBE(i),
-                                                        *test_fes  -> GetBE(i),
-                                                        *eltrans, elemmat);
+            boundary_integs[k]->AssembleElementMatrix2(*trial_fes->GetBE(i),
+                                                       *test_fes->GetBE(i),
+                                                       *eltrans, elemmat);
             elmat += elemmat;
          }
          if (ran_dof_trans || dom_dof_trans)
          {
             TransformDual(ran_dof_trans, dom_dof_trans, elmat);
          }
-         mat -> AddSubMatrix (test_vdofs, trial_vdofs, elmat, skip_zeros);
+         mat->AddSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 
@@ -1497,7 +1554,7 @@ void MixedBilinearForm::Assemble (int skip_zeros)
          }
       }
 
-      for (int i = 0; i < trial_fes -> GetNBE(); i++)
+      for (int i = 0; i < trial_fes->GetNBE(); i++)
       {
          const int bdr_attr = mesh->GetBdrAttribute(i);
          if (bdr_attr_marker[bdr_attr-1] == 0) { continue; }
@@ -1530,6 +1587,37 @@ void MixedBilinearForm::Assemble (int skip_zeros)
    }
 }
 
+void MixedBilinearForm::ConformingAssemble()
+{
+   if (assembly != AssemblyLevel::LEGACY)
+   {
+      MFEM_WARNING("Conforming assemble not supported for this assembly level!");
+      return;
+   }
+
+   const int remove_zeros = 0;
+   Finalize(remove_zeros);
+
+   const SparseMatrix *test_P = test_fes->GetConformingProlongation();
+   if (test_P)
+   {
+      SparseMatrix *RA = mfem::TransposeMult(*test_P, *mat);
+      delete mat;
+      mat = RA;
+   }
+
+   const SparseMatrix *trial_P = trial_fes->GetConformingProlongation();
+   if (trial_P)
+   {
+      SparseMatrix *RAP = mfem::Mult(*mat, *trial_P);
+      delete mat;
+      mat = RAP;
+   }
+
+   height = mat->Height();
+   width = mat->Width();
+}
+
 void MixedBilinearForm::AssembleDiagonal_ADAt(const Vector &D,
                                               Vector &diag) const
 {
@@ -1578,39 +1666,6 @@ void MixedBilinearForm::AssembleDiagonal_ADAt(const Vector &D,
    }
 }
 
-void MixedBilinearForm::ConformingAssemble()
-{
-   if (assembly != AssemblyLevel::LEGACY)
-   {
-      MFEM_WARNING("Conforming assemble not supported for this assembly level!");
-      return;
-   }
-
-   Finalize();
-
-   const SparseMatrix *P2 = test_fes->GetConformingProlongation();
-   if (P2)
-   {
-      SparseMatrix *R = Transpose(*P2);
-      SparseMatrix *RA = mfem::Mult(*R, *mat);
-      delete R;
-      delete mat;
-      mat = RA;
-   }
-
-   const SparseMatrix *P1 = trial_fes->GetConformingProlongation();
-   if (P1)
-   {
-      SparseMatrix *RAP = mfem::Mult(*mat, *P1);
-      delete mat;
-      mat = RAP;
-   }
-
-   height = mat->Height();
-   width = mat->Width();
-}
-
-
 void MixedBilinearForm::ComputeElementMatrix(int i, DenseMatrix &elmat)
 {
    if (domain_integs.Size())
@@ -1699,91 +1754,102 @@ void MixedBilinearForm::AssembleBdrElementMatrix(
    mat->AddSubMatrix(test_vdofs_, trial_vdofs_, elmat, skip_zeros);
 }
 
-void MixedBilinearForm::EliminateTrialDofs (
+void MixedBilinearForm::EliminateTrialDofs(
    const Array<int> &bdr_attr_is_ess, const Vector &sol, Vector &rhs )
 {
    int i, j, k;
-   Array<int> tr_vdofs, cols_marker (trial_fes -> GetVSize());
+   Array<int> tr_vdofs, cols_marker(trial_fes->GetVSize());
 
    cols_marker = 0;
-   for (i = 0; i < trial_fes -> GetNBE(); i++)
-      if (bdr_attr_is_ess[trial_fes -> GetBdrAttribute (i)-1])
+   for (i = 0; i < trial_fes->GetNBE(); i++)
+      if (bdr_attr_is_ess[trial_fes->GetBdrAttribute(i)-1])
       {
-         trial_fes -> GetBdrElementVDofs (i, tr_vdofs);
+         trial_fes->GetBdrElementVDofs(i, tr_vdofs);
          for (j = 0; j < tr_vdofs.Size(); j++)
          {
-            if ( (k = tr_vdofs[j]) < 0 )
+            if ((k = tr_vdofs[j]) < 0)
             {
                k = -1-k;
             }
             cols_marker[k] = 1;
          }
       }
-   mat -> EliminateCols (cols_marker, &sol, &rhs);
+   mat->EliminateCols(cols_marker, &sol, &rhs);
 }
 
-void MixedBilinearForm::EliminateEssentialBCFromTrialDofs (
+void MixedBilinearForm::EliminateEssentialBCFromTrialDofs(
    const Array<int> &marked_vdofs, const Vector &sol, Vector &rhs)
 {
-   mat -> EliminateCols (marked_vdofs, &sol, &rhs);
+   mat->EliminateCols(marked_vdofs, &sol, &rhs);
 }
 
-void MixedBilinearForm::EliminateTestDofs (const Array<int> &bdr_attr_is_ess)
+void MixedBilinearForm::EliminateTestDofs(const Array<int> &bdr_attr_is_ess)
 {
    int i, j, k;
    Array<int> te_vdofs;
 
-   for (i = 0; i < test_fes -> GetNBE(); i++)
-      if (bdr_attr_is_ess[test_fes -> GetBdrAttribute (i)-1])
+   for (i = 0; i < test_fes->GetNBE(); i++)
+      if (bdr_attr_is_ess[test_fes->GetBdrAttribute(i)-1])
       {
-         test_fes -> GetBdrElementVDofs (i, te_vdofs);
+         test_fes->GetBdrElementVDofs(i, te_vdofs);
          for (j = 0; j < te_vdofs.Size(); j++)
          {
-            if ( (k = te_vdofs[j]) < 0 )
+            if ((k = te_vdofs[j]) < 0)
             {
                k = -1-k;
             }
-            mat -> EliminateRow (k);
+            mat->EliminateRow(k);
          }
       }
 }
 
-void MixedBilinearForm::FormRectangularSystemMatrix(
+void MixedBilinearForm::FormRectangularLinearSystem(
    const Array<int> &trial_tdof_list,
    const Array<int> &test_tdof_list,
-   OperatorHandle &A)
-
+   Vector &x, Vector &b,
+   OperatorHandle &A,
+   Vector &X, Vector &B)
 {
    if (ext)
    {
-      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, A);
+      Operator *oper;
+      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
+                                       x, b, oper, X, B);
+      A.Reset(oper);
       return;
    }
 
-   const SparseMatrix *test_P = test_fes->GetConformingProlongation();
-   const SparseMatrix *trial_P = trial_fes->GetConformingProlongation();
-
-   mat->Finalize();
+   const Operator *Pi = this->GetProlongation();
+   const Operator *Po = this->GetOutputProlongation();
+   const Operator *Ri = this->GetRestriction();
+   InitTVectors(Po, Ri, Pi, x, b, X, B);
 
-   if (test_P && trial_P)
-   {
-      SparseMatrix *m = RAP(*test_P, *mat, *trial_P);
-      delete mat;
-      mat = m;
-   }
-   else if (test_P)
+   if (!mat_e)
    {
-      SparseMatrix *m = TransposeMult(*test_P, *mat);
-      delete mat;
-      mat = m;
+      // Set A = mat_e
+      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, A);
    }
-   else if (trial_P)
+   // Eliminate essential BCs with B -= Ab xb
+   mat_e->AddMult(X, B, -1.0);
+
+   B.SetSubVector(test_tdof_list, 0.0);
+}
+
+void MixedBilinearForm::FormRectangularSystemMatrix(
+   const Array<int> &trial_tdof_list,
+   const Array<int> &test_tdof_list,
+   OperatorHandle &A)
+{
+   if (ext)
    {
-      SparseMatrix *m = mfem::Mult(*mat, *trial_P);
-      delete mat;
-      mat = m;
+      Operator *oper;
+      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, oper);
+      A.Reset(oper);
+      return;
    }
 
+   ConformingAssemble();
+
    Array<int> ess_trial_tdof_marker, ess_test_tdof_marker;
    FiniteElementSpace::ListToMarker(trial_tdof_list, trial_fes->GetTrueVSize(),
                                     ess_trial_tdof_marker);
@@ -1793,7 +1859,7 @@ void MixedBilinearForm::FormRectangularSystemMatrix(
    mat_e = new SparseMatrix(mat->Height(), mat->Width());
    mat->EliminateCols(ess_trial_tdof_marker, *mat_e);
 
-   for (int i=0; i<test_tdof_list.Size(); ++i)
+   for (int i = 0; i < test_tdof_list.Size(); i++)
    {
       mat->EliminateRow(test_tdof_list[i]);
    }
@@ -1801,36 +1867,6 @@ void MixedBilinearForm::FormRectangularSystemMatrix(
    A.Reset(mat, false);
 }
 
-void MixedBilinearForm::FormRectangularLinearSystem(
-   const Array<int> &trial_tdof_list,
-   const Array<int> &test_tdof_list,
-   Vector &x, Vector &b,
-   OperatorHandle &A,
-   Vector &X, Vector &B)
-{
-   if (ext)
-   {
-      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
-                                       x, b, A, X, B);
-      return;
-   }
-
-   const Operator *Pi = this->GetProlongation();
-   const Operator *Po = this->GetOutputProlongation();
-   const Operator *Ri = this->GetRestriction();
-   InitTVectors(Po, Ri, Pi, x, b, X, B);
-
-   if (!mat_e)
-   {
-      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list,
-                                  A); // Set A = mat_e
-   }
-   // Eliminate essential BCs with B -= Ab xb
-   mat_e->AddMult(X, B, -1.0);
-
-   B.SetSubVector(test_tdof_list, 0.0);
-}
-
 void MixedBilinearForm::Update()
 {
    delete mat;
@@ -1895,66 +1931,97 @@ void DiscreteLinearOperator::Assemble(int skip_zeros)
       return;
    }
 
-   Array<int> dom_vdofs, ran_vdofs;
-   ElementTransformation *T;
-   DofTransformation * dom_dof_trans;
-   DofTransformation * ran_dof_trans;
-   const FiniteElement *dom_fe, *ran_fe;
-   DenseMatrix totelmat, elmat;
+   ElementTransformation *eltrans;
+   DofTransformation *dom_dof_trans;
+   DofTransformation *ran_dof_trans;
+   Mesh *mesh = test_fes->GetMesh();
+   DenseMatrix elmat;
 
    if (mat == NULL)
    {
       mat = new SparseMatrix(height, width);
    }
 
-   if (domain_integs.Size() > 0)
+   if (domain_integs.Size())
    {
       for (int i = 0; i < test_fes->GetNE(); i++)
       {
-         dom_dof_trans = trial_fes->GetElementVDofs(i, dom_vdofs);
-         ran_dof_trans = test_fes->GetElementVDofs(i, ran_vdofs);
-         T = test_fes->GetElementTransformation(i);
-         dom_fe = trial_fes->GetFE(i);
-         ran_fe = test_fes->GetFE(i);
-
-         domain_integs[0]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                  totelmat);
-         for (int j = 1; j < domain_integs.Size(); j++)
+         dom_dof_trans = trial_fes->GetElementVDofs(i, trial_vdofs);
+         ran_dof_trans = test_fes->GetElementVDofs(i, test_vdofs);
+         eltrans = test_fes->GetElementTransformation(i);
+
+         elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
+         elmat = 0.0;
+         for (int j = 0; j < domain_integs.Size(); j++)
          {
-            domain_integs[j]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                     elmat);
-            totelmat += elmat;
+            domain_integs[j]->AssembleElementMatrix2(*trial_fes->GetFE(i),
+                                                     *test_fes->GetFE(i),
+                                                     *eltrans, elemmat);
+            elmat += elemmat;
          }
          if (ran_dof_trans || dom_dof_trans)
          {
-            TransformPrimal(ran_dof_trans, dom_dof_trans, totelmat);
+            TransformPrimal(ran_dof_trans, dom_dof_trans, elmat);
          }
-         mat->SetSubMatrix(ran_vdofs, dom_vdofs, totelmat, skip_zeros);
+         mat->SetSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 
    if (trace_face_integs.Size())
    {
-      const int nfaces = test_fes->GetMesh()->GetNumFaces();
+      const int nfaces = mesh->GetNumFaces();
       for (int i = 0; i < nfaces; i++)
       {
-         trial_fes->GetFaceVDofs(i, dom_vdofs);
-         test_fes->GetFaceVDofs(i, ran_vdofs);
-         T = test_fes->GetMesh()->GetFaceTransformation(i);
-         dom_fe = trial_fes->GetFaceElement(i);
-         ran_fe = test_fes->GetFaceElement(i);
-
-         trace_face_integs[0]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                      totelmat);
-         for (int j = 1; j < trace_face_integs.Size(); j++)
+         trial_fes->GetFaceVDofs(i, trial_vdofs);
+         test_fes->GetFaceVDofs(i, test_vdofs);
+         eltrans = mesh->GetFaceTransformation(i);
+
+         elmat.SetSize(test_vdofs.Size(), trial_vdofs.Size());
+         elmat = 0.0;
+         for (int j = 0; j < trace_face_integs.Size(); j++)
          {
-            trace_face_integs[j]->AssembleElementMatrix2(*dom_fe, *ran_fe, *T,
-                                                         elmat);
-            totelmat += elmat;
+            trace_face_integs[j]->AssembleElementMatrix2(*trial_fes->GetFaceElement(i),
+                                                         *test_fes->GetFaceElement(i),
+                                                         *eltrans, elemmat);
+            elmat += elemmat;
          }
-         mat->SetSubMatrix(ran_vdofs, dom_vdofs, totelmat, skip_zeros);
+         mat->SetSubMatrix(test_vdofs, trial_vdofs, elmat, skip_zeros);
       }
    }
 }
 
+void DiscreteLinearOperator::FormDiscreteOperatorMatrix(OperatorHandle &A)
+{
+   if (ext)
+   {
+      Operator *oper;
+      ext->FormDiscreteOperator(oper);
+      A.Reset(oper);
+      return;
+   }
+
+   mat->Finalize();
+
+   const SparseMatrix *test_R = test_fes->GetConformingRestriction();
+   if (test_R)
+   {
+      SparseMatrix *RA = mfem::Mult(*test_R, *mat);
+      delete mat;
+      mat = RA;
+   }
+
+   const SparseMatrix *trial_P = trial_fes->GetConformingProlongation();
+   if (trial_P)
+   {
+      SparseMatrix *RAP = mfem::Mult(*mat, *trial_P);
+      delete mat;
+      mat = RAP;
+   }
+
+   height = mat->Height();
+   width = mat->Width();
+
+   A.Reset(mat, false);
+}
+
 }
diff --git a/fem/bilinearform.hpp b/fem/bilinearform.hpp
index b23df9280..9dc88ed97 100644
--- a/fem/bilinearform.hpp
+++ b/fem/bilinearform.hpp
@@ -127,13 +127,12 @@ protected:
    DiagonalPolicy diag_policy;
 
    int precompute_sparsity;
+
    // Allocate appropriate SparseMatrix and assign it to mat
    void AllocMat();
 
-   void ConformingAssemble();
-
    // may be used in the construction of derived classes
-   BilinearForm() : Matrix (0)
+   BilinearForm() : Matrix(0)
    {
       fes = NULL; sequence = -1;
       mat = mat_e = NULL; extern_bfs = 0; element_matrices = NULL;
@@ -184,6 +183,18 @@ public:
        If used, this method must be called before assembly. */
    void SetAssemblyLevel(AssemblyLevel assembly_level);
 
+   /// Returns the assembly level
+   AssemblyLevel GetAssemblyLevel() const { return assembly; }
+
+   /// Sets diagonal policy used upon construction of the linear system.
+   /** Policies include:
+
+       - DIAG_ZERO (Set the diagonal values to zero)
+       - DIAG_ONE  (Set the diagonal values to one)
+       - DIAG_KEEP (Keep the diagonal values)
+   */
+   void SetDiagonalPolicy(DiagonalPolicy policy) { diag_policy = policy; }
+
    /** @brief Force the sparse matrix column indices to be sorted when using
        AssemblyLevel::FULL.
 
@@ -199,8 +210,16 @@ public:
       sort_sparse_matrix = enable_it;
    }
 
-   /// Returns the assembly level
-   AssemblyLevel GetAssemblyLevel() const { return assembly; }
+   /// Indicate that integrators are not owned by the BilinearForm
+   void UseExternalIntegrators() { extern_bfs = 1; }
+
+   /// Enable hybridization.
+   /** For details see the description for class
+       Hybridization in fem/hybridization.hpp. This method should be called
+       before assembly. */
+   void EnableHybridization(FiniteElementSpace *constr_space,
+                            BilinearFormIntegrator *constr_integ,
+                            const Array<int> &ess_tdof_list);
 
    Hybridization *GetHybridization() const { return hybridization; }
 
@@ -218,14 +237,6 @@ public:
    FiniteElementSpace *SCFESpace() const
    { return static_cond ? static_cond->GetTraceFESpace() : NULL; }
 
-   /// Enable hybridization.
-   /** For details see the description for class
-       Hybridization in fem/hybridization.hpp. This method should be called
-       before assembly. */
-   void EnableHybridization(FiniteElementSpace *constr_space,
-                            BilinearFormIntegrator *constr_integ,
-                            const Array<int> &ess_tdof_list);
-
    /** @brief For scalar FE spaces, precompute the sparsity pattern of the matrix
        (assuming dense element matrices) based on the types of integrators
        present in the bilinear form. */
@@ -251,27 +262,6 @@ public:
        finalized) and the entries are initialized with zeros. */
    void AllocateMatrix() { if (mat == NULL) { AllocMat(); } }
 
-   /// Access all the integrators added with AddDomainIntegrator().
-   Array<BilinearFormIntegrator*> *GetDBFI() { return &domain_integs; }
-
-   /// Access all the integrators added with AddBoundaryIntegrator().
-   Array<BilinearFormIntegrator*> *GetBBFI() { return &boundary_integs; }
-   /** @brief Access all boundary markers added with AddBoundaryIntegrator().
-       If no marker was specified when the integrator was added, the
-       corresponding pointer (to Array<int>) will be NULL. */
-   Array<Array<int>*> *GetBBFI_Marker() { return &boundary_integs_marker; }
-
-   /// Access all integrators added with AddInteriorFaceIntegrator().
-   Array<BilinearFormIntegrator*> *GetFBFI() { return &interior_face_integs; }
-
-   /// Access all integrators added with AddBdrFaceIntegrator().
-   Array<BilinearFormIntegrator*> *GetBFBFI() { return &boundary_face_integs; }
-   /** @brief Access all boundary markers added with AddBdrFaceIntegrator().
-       If no marker was specified when the integrator was added, the
-       corresponding pointer (to Array<int>) will be NULL. */
-   Array<Array<int>*> *GetBFBFI_Marker()
-   { return &boundary_face_integs_marker; }
-
    /// Returns a reference to: \f$ M_{ij} \f$
    const double &operator()(int i, int j) { return (*mat)(i,j); }
 
@@ -284,42 +274,52 @@ public:
    /// Matrix vector multiplication:  \f$ y = M x \f$
    virtual void Mult(const Vector &x, Vector &y) const;
 
+   /// Add the matrix vector multiple to a vector:  \f$ y += a M x \f$
+   virtual void AddMult(const Vector &x, Vector &y,
+                        const double a = 1.0) const;
+
+   /// Matrix transpose vector multiplication:  \f$ y = M^T x \f$
+   virtual void MultTranspose(const Vector &x, Vector &y) const;
+
+   /// Add the matrix transpose vector multiplication:  \f$ y += a M^T x \f$
+   virtual void AddMultTranspose(const Vector &x, Vector &y,
+                                 const double a = 1.0) const;
+
    /** @brief Matrix vector multiplication with the original uneliminated
        matrix.  The original matrix is \f$ M + M_e \f$ so we have:
        \f$ y = M x + M_e x \f$ */
    void FullMult(const Vector &x, Vector &y) const
    { mat->Mult(x, y); mat_e->AddMult(x, y); }
 
-   /// Add the matrix vector multiple to a vector:  \f$ y += a M x \f$
-   virtual void AddMult(const Vector &x, Vector &y, const double a = 1.0) const
-   { mat -> AddMult (x, y, a); }
-
    /** @brief Add the original uneliminated matrix vector multiple to a vector.
        The original matrix is \f$ M + Me \f$ so we have:
        \f$ y += M x + M_e x \f$ */
    void FullAddMult(const Vector &x, Vector &y) const
    { mat->AddMult(x, y); mat_e->AddMult(x, y); }
 
-   /// Add the matrix transpose vector multiplication:  \f$ y += a M^T x \f$
-   virtual void AddMultTranspose(const Vector & x, Vector & y,
-                                 const double a = 1.0) const
-   { mat->AddMultTranspose(x, y, a); }
-
    /** @brief Add the original uneliminated matrix transpose vector
        multiple to a vector. The original matrix is \f$ M + M_e \f$
        so we have: \f$ y += M^T x + {M_e}^T x \f$ */
-   void FullAddMultTranspose(const Vector & x, Vector & y) const
+   void FullAddMultTranspose(const Vector &x, Vector &y) const
    { mat->AddMultTranspose(x, y); mat_e->AddMultTranspose(x, y); }
 
-   /// Matrix transpose vector multiplication:  \f$ y = M^T x \f$
-   virtual void MultTranspose(const Vector & x, Vector & y) const;
+   /// Compute inner product for full uneliminated matrix \f$ y^T M x + y^T M_e x \f$
+   double FullInnerProduct(const Vector &x, const Vector &y) const
+   { return mat->InnerProduct(x, y) + mat_e->InnerProduct(x, y); }
+
+   /// Returns a pointer to (approximation) of the matrix inverse:  \f$ M^{-1} \f$
+   virtual MatrixInverse *Inverse() const;
 
    /// Compute \f$ y^T M x \f$
    double InnerProduct(const Vector &x, const Vector &y) const
-   { return mat->InnerProduct (x, y); }
+   { return mat->InnerProduct(x, y); }
 
-   /// Returns a pointer to (approximation) of the matrix inverse:  \f$ M^{-1} \f$
-   virtual MatrixInverse *Inverse() const;
+   /// Sets all sparse values of \f$ M \f$ and \f$ M_e \f$ to 'a'.
+   void operator=(const double a)
+   {
+      if (mat != NULL) { *mat = a; }
+      if (mat_e != NULL) { *mat_e = a; }
+   }
 
    /// Finalizes the matrix initialization.
    virtual void Finalize(int skip_zeros = 1);
@@ -345,15 +345,7 @@ public:
    /** @brief Returns true if the sparse matrix is not null, false otherwise.
 
        @sa SpMat(). */
-   bool HasSpMat()
-   {
-      return mat != nullptr;
-   }
-
-
-   /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
-        to it.  Used for transferring ownership. */
-   SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
+   bool HasSpMat() const { return mat != nullptr; }
 
    /** @brief Returns a const reference to the sparse matrix of eliminated b.c.:
        \f$ M_e \f$
@@ -379,10 +371,11 @@ public:
         false otherwise.
 
         @sa SpMatElim(). */
-   bool HasSpMatElim()
-   {
-      return mat_e != nullptr;
-   }
+   bool HasSpMatElim() const { return mat_e != nullptr; }
+
+   /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
+        to it.  Used for transferring ownership. */
+   SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
 
    /// Adds new Domain Integrator. Assumes ownership of @a bfi.
    void AddDomainIntegrator(BilinearFormIntegrator *bfi);
@@ -416,16 +409,36 @@ public:
    void AddBdrFaceIntegrator(BilinearFormIntegrator *bfi,
                              Array<int> &bdr_marker);
 
-   /// Sets all sparse values of \f$ M \f$ and \f$ M_e \f$ to 'a'.
-   void operator=(const double a)
-   {
-      if (mat != NULL) { *mat = a; }
-      if (mat_e != NULL) { *mat_e = a; }
-   }
+   /// Access all the integrators added with AddDomainIntegrator().
+   Array<BilinearFormIntegrator*> *GetDBFI() { return &domain_integs; }
+
+   /// Access all the integrators added with AddBoundaryIntegrator().
+   Array<BilinearFormIntegrator*> *GetBBFI() { return &boundary_integs; }
+   /** @brief Access all boundary markers added with AddBoundaryIntegrator().
+       If no marker was specified when the integrator was added, the
+       corresponding pointer (to Array<int>) will be NULL. */
+   Array<Array<int>*> *GetBBFI_Marker() { return &boundary_integs_marker; }
+
+   /// Access all integrators added with AddInteriorFaceIntegrator().
+   Array<BilinearFormIntegrator*> *GetFBFI() { return &interior_face_integs; }
+
+   /// Access all integrators added with AddBdrFaceIntegrator().
+   Array<BilinearFormIntegrator*> *GetBFBFI() { return &boundary_face_integs; }
+   /** @brief Access all boundary markers added with AddBdrFaceIntegrator().
+       If no marker was specified when the integrator was added, the
+       corresponding pointer (to Array<int>) will be NULL. */
+   Array<Array<int>*> *GetBFBFI_Marker()
+   { return &boundary_face_integs_marker; }
 
    /// Assembles the form i.e. sums over all domain/bdr integrators.
    void Assemble(int skip_zeros = 1);
 
+   /** For a partially conforming FE space, complete the assembly process by
+       performing A := P^t A P where A is the internal sparse matrix; P is the
+       conforming prolongation matrices of the FE space. After this call the
+       BilinearForm becomes an operator on the conforming FE spaces. */
+   void ConformingAssemble();
+
    /** @brief Assemble the diagonal of the bilinear form into @a diag. Note that
        @a diag is a tdof Vector.
 
@@ -439,32 +452,20 @@ public:
 
    /// Get the finite element space prolongation operator.
    virtual const Operator *GetProlongation() const
-   { return fes->GetConformingProlongation(); }
+   { return fes->GetProlongationMatrix(); }
+
    /// Get the finite element space restriction operator
    virtual const Operator *GetRestriction() const
-   { return fes->GetConformingRestriction(); }
+   { return fes->GetRestrictionMatrix(); }
+
    /// Get the output finite element space prolongation matrix
    virtual const Operator *GetOutputProlongation() const
    { return GetProlongation(); }
-   /** @brief Returns the output fe space restriction matrix, transposed
 
-       Logically, this is the transpose of GetOutputRestriction, but in
-       practice it is convenient to have it in transposed form for
-       construction of RAP operators in matrix-free methods. */
-   virtual const Operator *GetOutputRestrictionTranspose() const
-   { return GetOutputProlongation(); }
    /// Get the output finite element space restriction matrix
    virtual const Operator *GetOutputRestriction() const
    { return GetRestriction(); }
 
-   /// @brief Compute serial RAP operator and store it in @a A as a SparseMatrix.
-   void SerialRAP(OperatorHandle &A)
-   {
-      MFEM_ASSERT(mat, "SerialRAP requires the SparseMatrix to be assembled.");
-      ConformingAssemble();
-      A.Reset(mat, false);
-   }
-
    /** @brief Form the linear system A X = B, corresponding to this bilinear
        form and the linear form @a b(.). */
    /** This method applies any necessary transformations to the linear system
@@ -645,34 +646,14 @@ public:
    void EliminateVDofsInRHS(const Array<int> &vdofs, const Vector &x,
                             Vector &b);
 
-   /// Compute inner product for full uneliminated matrix \f$ y^T M x + y^T M_e x \f$
-   double FullInnerProduct(const Vector &x, const Vector &y) const
-   { return mat->InnerProduct(x, y) + mat_e->InnerProduct(x, y); }
-
    /// Update the @a FiniteElementSpace and delete all data associated with the old one.
    virtual void Update(FiniteElementSpace *nfes = NULL);
 
-   /// (DEPRECATED) Return the FE space associated with the BilinearForm.
-   /** @deprecated Use FESpace() instead. */
-   MFEM_DEPRECATED FiniteElementSpace *GetFES() { return fes; }
-
    /// Return the FE space associated with the BilinearForm.
    FiniteElementSpace *FESpace() { return fes; }
    /// Read-only access to the associated FiniteElementSpace.
    const FiniteElementSpace *FESpace() const { return fes; }
 
-   /// Sets diagonal policy used upon construction of the linear system.
-   /** Policies include:
-
-       - DIAG_ZERO (Set the diagonal values to zero)
-       - DIAG_ONE  (Set the diagonal values to one)
-       - DIAG_KEEP (Keep the diagonal values)
-   */
-   void SetDiagonalPolicy(DiagonalPolicy policy);
-
-   /// Indicate that integrators are not owned by the BilinearForm
-   void UseExternalIntegrators() { extern_bfs = 1; }
-
    /// Destroys bilinear form.
    virtual ~BilinearForm();
 };
@@ -760,6 +741,13 @@ public:
                      FiniteElementSpace *te_fes,
                      MixedBilinearForm *mbf);
 
+   /// Set the desired assembly level. The default is AssemblyLevel::LEGACY.
+   /** This method must be called before assembly. */
+   void SetAssemblyLevel(AssemblyLevel assembly_level);
+
+   /// Returns the assembly level
+   AssemblyLevel GetAssemblyLevel() const { return assembly; }
+
    /// Returns a reference to: \f$ M_{ij} \f$
    virtual double &Elem(int i, int j);
 
@@ -767,17 +755,21 @@ public:
    virtual const double &Elem(int i, int j) const;
 
    /// Matrix multiplication: \f$ y = M x \f$
-   virtual void Mult(const Vector & x, Vector & y) const;
+   virtual void Mult(const Vector &x, Vector &y) const;
 
-   virtual void AddMult(const Vector & x, Vector & y,
+   virtual void AddMult(const Vector &x, Vector &y,
                         const double a = 1.0) const;
 
-   virtual void MultTranspose(const Vector & x, Vector & y) const;
-   virtual void AddMultTranspose(const Vector & x, Vector & y,
+   virtual void MultTranspose(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTranspose(const Vector &x, Vector &y,
                                  const double a = 1.0) const;
 
    virtual MatrixInverse *Inverse() const;
 
+   /// Sets all sparse values of \f$ M \f$ to @a a.
+   void operator=(const double a) { *mat = a; }
+
    /// Finalizes the matrix initialization.
    virtual void Finalize(int skip_zeros = 1);
 
@@ -792,6 +784,9 @@ public:
    /// Returns a reference to the sparse matrix:  \f$ M \f$
    SparseMatrix &SpMat() { return *mat; }
 
+   /// Returns true if the sparse matrix is not null, false otherwise.
+   bool HasSpMat() const { return mat != nullptr; }
+
    /**  @brief Nullifies the internal matrix \f$ M \f$ and returns a pointer
         to it.  Used for transferring ownership. */
    SparseMatrix *LoseMat() { SparseMatrix *tmp = mat; mat = NULL; return tmp; }
@@ -803,8 +798,8 @@ public:
    void AddBoundaryIntegrator(BilinearFormIntegrator *bfi);
 
    /// Adds a boundary integrator. Assumes ownership of @a bfi.
-   void AddBoundaryIntegrator (BilinearFormIntegrator * bfi,
-                               Array<int> &bdr_marker);
+   void AddBoundaryIntegrator(BilinearFormIntegrator *bfi,
+                              Array<int> &bdr_marker);
 
    /** @brief Add a trace face integrator. Assumes ownership of @a bfi.
 
@@ -814,11 +809,11 @@ public:
    void AddTraceFaceIntegrator(BilinearFormIntegrator *bfi);
 
    /// Adds a boundary trace face integrator. Assumes ownership of @a bfi.
-   void AddBdrTraceFaceIntegrator (BilinearFormIntegrator * bfi);
+   void AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi);
 
    /// Adds a boundary trace face integrator. Assumes ownership of @a bfi.
-   void AddBdrTraceFaceIntegrator (BilinearFormIntegrator * bfi,
-                                   Array<int> &bdr_marker);
+   void AddBdrTraceFaceIntegrator(BilinearFormIntegrator *bfi,
+                                  Array<int> &bdr_marker);
 
    /// Access all integrators added with AddDomainIntegrator().
    Array<BilinearFormIntegrator*> *GetDBFI() { return &domain_integs; }
@@ -842,15 +837,15 @@ public:
    Array<Array<int>*> *GetBTFBFI_Marker()
    { return &boundary_trace_face_integs_marker; }
 
-   /// Sets all sparse values of \f$ M \f$ to @a a.
-   void operator=(const double a) { *mat = a; }
-
-   /// Set the desired assembly level. The default is AssemblyLevel::LEGACY.
-   /** This method must be called before assembly. */
-   void SetAssemblyLevel(AssemblyLevel assembly_level);
-
    void Assemble(int skip_zeros = 1);
 
+   /** For partially conforming trial and/or test FE spaces, complete the
+       assembly process by performing A := P2^t A P1 where A is the internal
+       sparse matrix; P1 and P2 are the conforming prolongation matrices of the
+       trial and test FE spaces, respectively. After this call the
+       MixedBilinearForm becomes an operator on the conforming FE spaces. */
+   void ConformingAssemble();
+
    /** @brief Assemble the diagonal of ADA^T into diag, where A is this mixed
        bilinear form and D is a diagonal. */
    void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
@@ -871,13 +866,6 @@ public:
    virtual const Operator *GetOutputRestriction() const
    { return test_fes->GetRestrictionMatrix(); }
 
-   /** For partially conforming trial and/or test FE spaces, complete the
-       assembly process by performing A := P2^t A P1 where A is the internal
-       sparse matrix; P1 and P2 are the conforming prolongation matrices of the
-       trial and test FE spaces, respectively. After this call the
-       MixedBilinearForm becomes an operator on the conforming FE spaces. */
-   void ConformingAssemble();
-
    /// Compute the element matrix of the given element
    void ComputeElementMatrix(int i, DenseMatrix &elmat);
 
@@ -932,33 +920,6 @@ public:
 
    virtual void EliminateTestDofs(const Array<int> &bdr_attr_is_ess);
 
-   /** @brief Return in @a A that is column-constrained.
-
-      This returns the same operator as FormRectangularLinearSystem(), but does
-      without the transformations of the right-hand side. */
-   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
-                                            const Array<int> &test_tdof_list,
-                                            OperatorHandle &A);
-
-   /** @brief Form the column-constrained linear system matrix A.
-       See FormRectangularSystemMatrix() for details.
-
-       Version of the method FormRectangularSystemMatrix() where the system matrix is
-       returned in the variable @a A, of type OpType, holding a *reference* to
-       the system matrix (created with the method OpType::MakeRef()). The
-       reference will be invalidated when SetOperatorType(), Update(), or the
-       destructor is called. */
-   template <typename OpType>
-   void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
-                                    const Array<int> &test_tdof_list, OpType &A)
-   {
-      OperatorHandle Ah;
-      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, Ah);
-      OpType *A_ptr = Ah.Is<OpType>();
-      MFEM_VERIFY(A_ptr, "invalid OpType used");
-      A.MakeRef(*A_ptr);
-   }
-
    /** @brief Form the linear system A X = B, corresponding to this mixed bilinear
        form and the linear form @a b(.).
 
@@ -992,6 +953,33 @@ public:
       A.MakeRef(*A_ptr);
    }
 
+   /** @brief Return in @a A that is column-constrained.
+
+      This returns the same operator as FormRectangularLinearSystem(), but does
+      without the transformations of the right-hand side. */
+   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
+                                            const Array<int> &test_tdof_list,
+                                            OperatorHandle &A);
+
+   /** @brief Form the column-constrained linear system matrix A.
+       See FormRectangularSystemMatrix() for details.
+
+       Version of the method FormRectangularSystemMatrix() where the system matrix is
+       returned in the variable @a A, of type OpType, holding a *reference* to
+       the system matrix (created with the method OpType::MakeRef()). The
+       reference will be invalidated when SetOperatorType(), Update(), or the
+       destructor is called. */
+   template <typename OpType>
+   void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
+                                    const Array<int> &test_tdof_list, OpType &A)
+   {
+      OperatorHandle Ah;
+      FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, Ah);
+      OpType *A_ptr = Ah.Is<OpType>();
+      MFEM_VERIFY(A_ptr, "invalid OpType used");
+      A.MakeRef(*A_ptr);
+   }
+
    void Update();
 
    /// Return the trial FE space associated with the BilinearForm.
@@ -1065,7 +1053,10 @@ public:
    { AddTraceFaceIntegrator(di); }
 
    /// Access all interpolators added with AddDomainInterpolator().
-   Array<BilinearFormIntegrator*> *GetDI() { return &domain_integs; }
+   Array<BilinearFormIntegrator*> *GetDI() { return GetDBFI(); }
+
+   /// Access all interpolators added with AddTraceFaceInterpolator().
+   Array<BilinearFormIntegrator*> *GetTFI() { return GetTFBFI(); }
 
    /// Set the desired assembly level. The default is AssemblyLevel::FULL.
    /** This method must be called before assembly. */
@@ -1075,10 +1066,26 @@ public:
        linear operator. */
    virtual void Assemble(int skip_zeros = 1);
 
-   /** @brief Get the output finite element space restriction matrix in
-       transposed form. */
-   virtual const Operator *GetOutputRestrictionTranspose() const
-   { return test_fes->GetRestrictionTransposeOperator(); }
+   /** @brief Return in @a A that is column-constrained. */
+   virtual void FormDiscreteOperatorMatrix(OperatorHandle &A);
+
+   /** @brief Form the column-constrained discrete linear operator matrix A.
+       See FormDiscreteOperatorMatrix() for details.
+
+       Version of the method FormDiscreteOperatorMatrix() where the discrete
+       operator matrix is returned in the variable @a A, of type OpType,
+       holding a *reference* to the discrete operator  matrix (created with the
+       method OpType::MakeRef()). The reference will be invalidated when
+       SetOperatorType(), Update(), or the destructor is called. */
+   template <typename OpType>
+   void FormDiscreteOperatorMatrix(OpType &A)
+   {
+      OperatorHandle Ah;
+      FormDiscreteOperatorMatrix(Ah);
+      OpType *A_ptr = Ah.Is<OpType>();
+      MFEM_VERIFY(A_ptr, "invalid OpType used");
+      A.MakeRef(*A_ptr);
+   }
 };
 
 }
diff --git a/fem/bilinearform_ext.cpp b/fem/bilinearform_ext.cpp
index d21a43ccc..e0174871d 100644
--- a/fem/bilinearform_ext.cpp
+++ b/fem/bilinearform_ext.cpp
@@ -21,10 +21,10 @@
 namespace mfem
 {
 
+/// Base class for extensions to the BilinearForm class
 BilinearFormExtension::BilinearFormExtension(BilinearForm *form)
    : Operator(form->Size()), a(form)
 {
-   // empty
 }
 
 const Operator *BilinearFormExtension::GetProlongation() const
@@ -37,850 +37,1261 @@ const Operator *BilinearFormExtension::GetRestriction() const
    return a->GetRestriction();
 }
 
-// Data and methods for partially-assembled bilinear forms
+/// Data and methods for matrix-free bilinear forms
 MFBilinearFormExtension::MFBilinearFormExtension(BilinearForm *form)
-   : BilinearFormExtension(form),
-     trial_fes(a->FESpace()),
-     test_fes(a->FESpace())
+   : BilinearFormExtension(form)
 {
-   elem_restrict = NULL;
-   int_face_restrict_lex = NULL;
-   bdr_face_restrict_lex = NULL;
+   Update();
 }
 
-void MFBilinearFormExtension::Assemble()
+void MFBilinearFormExtension::SetupRestrictionOperators(const L2FaceValues m)
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
+   if (DeviceCanUseCeed()) { return; }
+   ElementDofOrdering ordering = UsesTensorBasis(*fes) ?
+                                 ElementDofOrdering::LEXICOGRAPHIC :
+                                 ElementDofOrdering::NATIVE;
+   elem_restrict = fes->GetElementRestriction(ordering);
+   if (elem_restrict)
    {
-      integrators[i]->AssembleMF(*a->FESpace());
+      local_x.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
+      local_y.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
+      local_y.UseDevice(true); // ensure 'local_y = 0.0' is done on device
    }
 
-   MFEM_VERIFY(a->GetBBFI()->Size() == 0, "AddBoundaryIntegrator is not "
-               "currently supported in MFBilinearFormExtension");
-}
-
-void MFBilinearFormExtension::AssembleDiagonal(Vector &y) const
-{
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-   if (elem_restrict && !DeviceCanUseCeed())
+   // Construct face restriction operators only if the bilinear form has
+   // interior or boundary face integrators
+   if (int_face_restrict_lex == nullptr && a->GetFBFI()->Size() > 0)
    {
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
-      {
-         integrators[i]->AssembleDiagonalMF(localY);
-      }
-      const ElementRestriction* H1elem_restrict =
-         dynamic_cast<const ElementRestriction*>(elem_restrict);
-      if (H1elem_restrict)
-      {
-         H1elem_restrict->MultTransposeUnsigned(localY, y);
-      }
-      else
-      {
-         elem_restrict->MultTranspose(localY, y);
-      }
+      int_face_restrict_lex = fes->GetFaceRestriction(
+                                 ElementDofOrdering::LEXICOGRAPHIC,
+                                 FaceType::Interior);
+      int_face_x.SetSize(int_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      int_face_y.SetSize(int_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      int_face_y.UseDevice(true);
    }
-   else
+
+   if (bdr_face_restrict_lex == nullptr &&
+       (a->GetBFBFI()->Size() > 0 || a->GetBBFI()->Size() > 0))
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
-      {
-         integrators[i]->AssembleDiagonalMF(y);
-      }
+      bdr_face_restrict_lex = fes->GetFaceRestriction(
+                                 ElementDofOrdering::LEXICOGRAPHIC,
+                                 FaceType::Boundary,
+                                 m);
+      bdr_face_x.SetSize(bdr_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      bdr_face_y.SetSize(bdr_face_restrict_lex->Height(),
+                         Device::GetDeviceMemoryType());
+      bdr_face_y.UseDevice(true);
    }
 }
 
-void MFBilinearFormExtension::Update()
+void MFBilinearFormExtension::Assemble()
 {
-   FiniteElementSpace *fes = a->FESpace();
-   height = width = fes->GetVSize();
-   trial_fes = fes;
-   test_fes = fes;
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
 
-   elem_restrict = nullptr;
-   int_face_restrict_lex = nullptr;
-   bdr_face_restrict_lex = nullptr;
-}
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
+   {
+      integ->AssembleMF(*fes);
+   }
 
-void MFBilinearFormExtension::FormSystemMatrix(const Array<int> &ess_tdof_list,
-                                               OperatorHandle &A)
-{
-   Operator *oper;
-   Operator::FormSystemOperator(ess_tdof_list, oper);
-   A.Reset(oper); // A will own oper
-}
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
+   {
+      integ->AssembleMFBoundary(*fes);
+   }
 
-void MFBilinearFormExtension::FormLinearSystem(const Array<int> &ess_tdof_list,
-                                               Vector &x, Vector &b,
-                                               OperatorHandle &A,
-                                               Vector &X, Vector &B,
-                                               int copy_interior)
-{
-   Operator *oper;
-   Operator::FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
-   A.Reset(oper); // A will own oper
+   MFEM_VERIFY(a->GetFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in MFBilinearFormExtension");
+
+   MFEM_VERIFY(a->GetBFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in MFBilinearFormExtension");
 }
 
-void MFBilinearFormExtension::Mult(const Vector &x, Vector &y) const
+void MFBilinearFormExtension::AssembleDiagonal(Vector &diag) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-   if (DeviceCanUseCeed() || !elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultMF(x, y);
+         integ->AssembleDiagonalMF(local_y);
       }
+      elem_restrict->MultTransposeUnsigned(local_y, diag);
    }
    else
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      diag.UseDevice(true); // typically this is a large vector, so store on device
+      diag = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultMF(localX, localY);
+         integ->AssembleDiagonalMF(diag);
       }
-      elem_restrict->MultTranspose(localY, y);
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      if (bdr_face_restrict_lex)
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         bdr_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            intFaceIntegrators[i]->AddMultMF(int_face_X, int_face_Y);
+            integ->AssembleDiagonalMF(bdr_face_y);
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+         bdr_face_restrict_lex->AddMultTransposeUnsigned(bdr_face_y, diag);
       }
-   }
-
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
-   {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      else
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            bdrFaceIntegrators[i]->AddMultMF(bdr_face_X, bdr_face_Y);
+            integ->AssembleDiagonalMF(diag);
          }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
       }
    }
 }
 
-void MFBilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
+void MFBilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-   if (elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultTransposeMF(localX, localY);
+         integ->AddMultMF(local_x, local_y);
       }
-      elem_restrict->MultTranspose(localY, y);
+      elem_restrict->MultTranspose(local_y, y);
    }
    else
    {
-      y.UseDevice(true);
+      y.UseDevice(true); // typically this is a large vector, so store on device
       y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultTransposeMF(x, y);
+         integ->AddMultMF(x, y);
       }
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      if (bdr_face_restrict_lex)
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
          {
-            intFaceIntegrators[i]->AddMultTransposeMF(int_face_X, int_face_Y);
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(bdr_face_x, bdr_face_y);
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
       }
-   }
-
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
-   {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      else
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            bdrFaceIntegrators[i]->AddMultTransposeMF(bdr_face_X, bdr_face_Y);
+            integ->AddMultMF(x, y);
          }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
       }
    }
 }
 
-// Data and methods for partially-assembled bilinear forms
-PABilinearFormExtension::PABilinearFormExtension(BilinearForm *form)
-   : BilinearFormExtension(form),
-     trial_fes(a->FESpace()),
-     test_fes(a->FESpace())
-{
-   elem_restrict = NULL;
-   int_face_restrict_lex = NULL;
-   bdr_face_restrict_lex = NULL;
-}
-
-void PABilinearFormExtension::SetupRestrictionOperators(const L2FaceValues m)
+void MFBilinearFormExtension::AddMult(const Vector &x, Vector &y,
+                                      const double c) const
 {
-   if ( Device::Allows(Backend::CEED_MASK) ) { return; }
-   ElementDofOrdering ordering = UsesTensorBasis(*a->FESpace())?
-                                 ElementDofOrdering::LEXICOGRAPHIC:
-                                 ElementDofOrdering::NATIVE;
-   elem_restrict = trial_fes->GetElementRestriction(ordering);
-   if (elem_restrict)
-   {
-      localX.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
-      localY.SetSize(elem_restrict->Height(), Device::GetDeviceMemoryType());
-      localY.UseDevice(true); // ensure 'localY = 0.0' is done on device
-   }
-
-   // Construct face restriction operators only if the bilinear form has
-   // interior or boundary face integrators
-   if (int_face_restrict_lex == NULL && a->GetFBFI()->Size() > 0)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      int_face_restrict_lex = trial_fes->GetFaceRestriction(
-                                 ElementDofOrdering::LEXICOGRAPHIC,
-                                 FaceType::Interior);
-      int_face_X.SetSize(int_face_restrict_lex->Height(), Device::GetMemoryType());
-      int_face_Y.SetSize(int_face_restrict_lex->Height(), Device::GetMemoryType());
-      int_face_Y.UseDevice(true); // ensure 'int_face_Y = 0.0' is done on device
+      if (elem_restrict)
+      {
+         elem_restrict->Mult(x, local_x);
+         local_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultMF(local_x, local_y);
+         }
+         if (c != 1.0)
+         {
+            local_y *= c;
+         }
+         elem_restrict->AddMultTranspose(local_y, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultMF(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultMF(x, y);
+            }
+         }
+      }
    }
 
-   const bool has_bdr_integs = (a->GetBFBFI()->Size() > 0 ||
-                                a->GetBBFI()->Size() > 0);
-   if (bdr_face_restrict_lex == NULL && has_bdr_integs)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      bdr_face_restrict_lex = trial_fes->GetFaceRestriction(
-                                 ElementDofOrdering::LEXICOGRAPHIC,
-                                 FaceType::Boundary,
-                                 m);
-      bdr_face_X.SetSize(bdr_face_restrict_lex->Height(), Device::GetMemoryType());
-      bdr_face_Y.SetSize(bdr_face_restrict_lex->Height(), Device::GetMemoryType());
-      bdr_face_Y.UseDevice(true); // ensure 'faceBoundY = 0.0' is done on device
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(bdr_face_x, bdr_face_y);
+            }
+            if (c != 1.0)
+            {
+               bdr_face_y *= c;
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(x, y);
+            }
+         }
+      }
    }
 }
 
-void PABilinearFormExtension::Assemble()
+void MFBilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 {
-   SetupRestrictionOperators(L2FaceValues::DoubleValued);
-
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   for (BilinearFormIntegrator *integ : integrators)
-   {
-      integ->AssemblePA(*a->FESpace());
-   }
-
-   Array<BilinearFormIntegrator*> &bdr_integrators = *a->GetBBFI();
-   for (BilinearFormIntegrator *integ : bdr_integrators)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      integ->AssemblePABoundary(*a->FESpace());
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposeMF(local_x, local_y);
+      }
+      elem_restrict->MultTranspose(local_y, y);
    }
-
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   for (BilinearFormIntegrator *integ : intFaceIntegrators)
+   else
    {
-      integ->AssemblePAInteriorFaces(*a->FESpace());
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposeMF(x, y);
+      }
    }
 
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   for (BilinearFormIntegrator *integ : bdrFaceIntegrators)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      integ->AssemblePABoundaryFaces(*a->FESpace());
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(bdr_face_x, bdr_face_y);
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposeMF(x, y);
+         }
+      }
    }
 }
 
-void PABilinearFormExtension::AssembleDiagonal(Vector &y) const
+void MFBilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
+                                               const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-   if (elem_restrict && !DeviceCanUseCeed())
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      if (iSz > 0)
+      if (elem_restrict)
       {
-         localY = 0.0;
-         for (int i = 0; i < iSz; ++i)
-         {
-            integrators[i]->AssembleDiagonalPA(localY);
-         }
-         const ElementRestriction* H1elem_restrict =
-            dynamic_cast<const ElementRestriction*>(elem_restrict);
-         if (H1elem_restrict)
+         elem_restrict->Mult(x, local_x);
+         local_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
          {
-            H1elem_restrict->MultTransposeUnsigned(localY, y);
+            integ->AddMultTransposeMF(local_x, local_y);
          }
-         else
+         if (c != 1.0)
          {
-            elem_restrict->MultTranspose(localY, y);
+            local_y *= c;
          }
+         elem_restrict->AddMultTranspose(local_y, y);
       }
       else
       {
-         y = 0.0;
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(x, y);
+            }
+         }
       }
    }
-   else
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      if (bdr_face_restrict_lex)
       {
-         integrators[i]->AssembleDiagonalPA(y);
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(bdr_face_x, bdr_face_y);
+            }
+            if (c != 1.0)
+            {
+               bdr_face_y *= c;
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
       }
-   }
-
-   Array<BilinearFormIntegrator*> &bdr_integs = *a->GetBBFI();
-   const int n_bdr_integs = bdr_integs.Size();
-   if (bdr_face_restrict_lex && n_bdr_integs > 0)
-   {
-      bdr_face_Y = 0.0;
-      for (int i = 0; i < n_bdr_integs; ++i)
+      else
       {
-         bdr_integs[i]->AssembleDiagonalPA(bdr_face_Y);
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(x, y);
+            }
+         }
       }
-      bdr_face_restrict_lex->AddMultTransposeUnsigned(bdr_face_Y, y);
    }
 }
 
-void PABilinearFormExtension::Update()
+void MFBilinearFormExtension::Update()
 {
-   FiniteElementSpace *fes = a->FESpace();
+   fes = a->FESpace();
    height = width = fes->GetVSize();
-   trial_fes = fes;
-   test_fes = fes;
 
    elem_restrict = nullptr;
    int_face_restrict_lex = nullptr;
    bdr_face_restrict_lex = nullptr;
 }
 
-void PABilinearFormExtension::FormSystemMatrix(const Array<int> &ess_tdof_list,
-                                               OperatorHandle &A)
+/// Data and methods for partially-assembled bilinear forms
+PABilinearFormExtension::PABilinearFormExtension(BilinearForm *form)
+   : MFBilinearFormExtension(form)
 {
-   Operator *oper;
-   Operator::FormSystemOperator(ess_tdof_list, oper);
-   A.Reset(oper); // A will own oper
 }
 
-void PABilinearFormExtension::FormLinearSystem(const Array<int> &ess_tdof_list,
-                                               Vector &x, Vector &b,
-                                               OperatorHandle &A,
-                                               Vector &X, Vector &B,
-                                               int copy_interior)
+void PABilinearFormExtension::Assemble()
 {
-   Operator *oper;
-   Operator::FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
-   A.Reset(oper); // A will own oper
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
+
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
+   {
+      integ->AssemblePA(*fes);
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
+   {
+      integ->AssemblePABoundary(*fes);
+   }
+
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   for (BilinearFormIntegrator *integ : int_face_integrators)
+   {
+      integ->AssemblePAInteriorFaces(*fes);
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   for (BilinearFormIntegrator *integ : bdr_face_integrators)
+   {
+      integ->AssemblePABoundaryFaces(*fes);
+   }
 }
 
-void PABilinearFormExtension::Mult(const Vector &x, Vector &y) const
+void PABilinearFormExtension::AssembleDiagonal(Vector &diag) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-   if (DeviceCanUseCeed() || !elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultPA(x, y);
+         integ->AssembleDiagonalPA(local_y);
       }
+      elem_restrict->MultTransposeUnsigned(local_y, diag);
    }
    else
    {
-      if (iSz)
-      {
-         elem_restrict->Mult(x, localX);
-         localY = 0.0;
-         for (int i = 0; i < iSz; ++i)
-         {
-            integrators[i]->AddMultPA(localX, localY);
-         }
-         elem_restrict->MultTranspose(localY, y);
-      }
-      else
+      diag.UseDevice(true); // typically this is a large vector, so store on device
+      diag = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         y = 0.0;
+         integ->AssembleDiagonalPA(diag);
       }
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      if (bdr_face_restrict_lex)
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         bdr_face_y = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            intFaceIntegrators[i]->AddMultPA(int_face_X, int_face_Y);
+            integ->AssembleDiagonalPA(bdr_face_y);
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+         bdr_face_restrict_lex->AddMultTransposeUnsigned(bdr_face_y, diag);
       }
-   }
-
-   Array<BilinearFormIntegrator*> &bdr_integs = *a->GetBBFI();
-   Array<BilinearFormIntegrator*> &bdr_face_integs = *a->GetBFBFI();
-   const int n_bdr_integs = bdr_integs.Size();
-   const int n_bdr_face_integs = bdr_face_integs.Size();
-   const bool has_bdr_integs = (n_bdr_face_integs > 0 || n_bdr_integs > 0);
-   if (bdr_face_restrict_lex && has_bdr_integs)
-   {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      else
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < n_bdr_integs; ++i)
-         {
-            bdr_integs[i]->AddMultPA(bdr_face_X, bdr_face_Y);
-         }
-         for (int i = 0; i < n_bdr_face_integs; ++i)
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            bdr_face_integs[i]->AddMultPA(bdr_face_X, bdr_face_Y);
+            integ->AssembleDiagonalPA(diag);
          }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
       }
    }
 }
 
-void PABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
+void PABilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-   if (elem_restrict)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultTransposePA(localX, localY);
+         integ->AddMultPA(local_x, local_y);
       }
-      elem_restrict->MultTranspose(localY, y);
+      elem_restrict->MultTranspose(local_y, y);
    }
    else
    {
-      y.UseDevice(true);
+      y.UseDevice(true); // typically this is a large vector, so store on device
       y = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      for (BilinearFormIntegrator *integ : integrators)
       {
-         integrators[i]->AddMultTransposePA(x, y);
+         integ->AddMultPA(x, y);
       }
    }
 
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
    {
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
+      if (int_face_restrict_lex)
+      {
+         int_face_restrict_lex->Mult(x, int_face_x);
+         if (int_face_x.Size() > 0)
+         {
+            int_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultPA(int_face_x, int_face_y);
+            }
+            int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+         }
+      }
+      else
       {
-         int_face_Y = 0.0;
-         for (int i = 0; i < iFISz; ++i)
+         for (BilinearFormIntegrator *integ : int_face_integrators)
          {
-            intFaceIntegrators[i]->AddMultTransposePA(int_face_X, int_face_Y);
+            integ->AddMultPA(x, y);
          }
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
       }
    }
 
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (bdr_face_restrict_lex && bFISz>0)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_integrators.Size() > 0 || bdr_face_integrators.Size() > 0)
    {
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(bdr_face_x, bdr_face_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultPA(bdr_face_x, bdr_face_y);
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
       {
-         bdr_face_Y = 0.0;
-         for (int i = 0; i < bFISz; ++i)
+         for (BilinearFormIntegrator *integ : bdr_integrators)
          {
-            bdrFaceIntegrators[i]->AddMultTransposePA(bdr_face_X, bdr_face_Y);
+            integ->AddMultPA(x, y);
+         }
+         for (BilinearFormIntegrator *integ : bdr_face_integrators)
+         {
+            integ->AddMultPA(x, y);
          }
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
       }
    }
 }
 
-// Data and methods for element-assembled bilinear forms
-EABilinearFormExtension::EABilinearFormExtension(BilinearForm *form)
-   : PABilinearFormExtension(form),
-     factorize_face_terms(false)
+void PABilinearFormExtension::AddMult(const Vector &x, Vector &y,
+                                      const double c) const
 {
-   if (form->FESpace()->IsDGSpace() && form->FESpace()->Conforming())
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      factorize_face_terms = true;
-   }
-}
-
-void EABilinearFormExtension::Assemble()
-{
-   SetupRestrictionOperators(L2FaceValues::SingleValued);
-
-   ne = trial_fes->GetMesh()->GetNE();
-   elemDofs = trial_fes->GetFE(0)->GetDof();
-
-   ea_data.SetSize(ne*elemDofs*elemDofs, Device::GetMemoryType());
-   ea_data.UseDevice(true);
+      if (elem_restrict)
+      {
+         elem_restrict->Mult(x, local_x);
+         local_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultPA(local_x, local_y);
+         }
+         if (c != 1.0)
+         {
+            local_y *= c;
+         }
+         elem_restrict->AddMultTranspose(local_y, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultPA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultPA(x, y);
+            }
+         }
+      }
+   }
 
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   if ( integratorCount == 0 )
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
    {
-      ea_data = 0.0;
+      if (int_face_restrict_lex)
+      {
+         int_face_restrict_lex->Mult(x, int_face_x);
+         if (int_face_x.Size() > 0)
+         {
+            int_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultPA(int_face_x, int_face_y);
+            }
+            if (c != 1.0)
+            {
+               int_face_y *= c;
+            }
+            int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+         }
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultPA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultPA(x, y);
+            }
+         }
+      }
    }
-   for (int i = 0; i < integratorCount; ++i)
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_integrators.Size() > 0 || bdr_face_integrators.Size() > 0)
    {
-      integrators[i]->AssembleEA(*a->FESpace(), ea_data, i);
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(bdr_face_x, bdr_face_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultPA(bdr_face_x, bdr_face_y);
+            }
+            if (c != 1.0)
+            {
+               bdr_face_y *= c;
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(x, temp_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultPA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(x, y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultPA(x, y);
+            }
+         }
+      }
    }
+}
 
-   faceDofs = trial_fes ->
-              GetTraceElement(0, trial_fes->GetMesh()->GetFaceGeometry(0)) ->
-              GetDof();
-
-   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
-               "Element assembly does not support AddBoundaryIntegrator yet.");
-
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int intFaceIntegratorCount = intFaceIntegrators.Size();
-   if (intFaceIntegratorCount>0)
+void PABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0 && elem_restrict)
    {
-      nf_int = trial_fes->GetNFbyType(FaceType::Interior);
-      ea_data_int.SetSize(2*nf_int*faceDofs*faceDofs, Device::GetMemoryType());
-      ea_data_ext.SetSize(2*nf_int*faceDofs*faceDofs, Device::GetMemoryType());
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposePA(local_x, local_y);
+      }
+      elem_restrict->MultTranspose(local_y, y);
    }
-   for (int i = 0; i < intFaceIntegratorCount; ++i)
+   else
    {
-      intFaceIntegrators[i]->AssembleEAInteriorFaces(*a->FESpace(),
-                                                     ea_data_int,
-                                                     ea_data_ext,
-                                                     i);
+      y.UseDevice(true);
+      y = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AddMultTransposePA(x, y);
+      }
    }
 
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int boundFaceIntegratorCount = bdrFaceIntegrators.Size();
-   if (boundFaceIntegratorCount>0)
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
    {
-      nf_bdr = trial_fes->GetNFbyType(FaceType::Boundary);
-      ea_data_bdr.SetSize(nf_bdr*faceDofs*faceDofs, Device::GetMemoryType());
-      ea_data_bdr = 0.0;
+      if (int_face_restrict_lex)
+      {
+         int_face_restrict_lex->Mult(x, int_face_x);
+         if (int_face_x.Size() > 0)
+         {
+            int_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultTransposePA(int_face_x, int_face_y);
+            }
+            int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+         }
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : int_face_integrators)
+         {
+            integ->AddMultTransposePA(x, y);
+         }
+      }
    }
-   for (int i = 0; i < boundFaceIntegratorCount; ++i)
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_integrators.Size() > 0 || bdr_face_integrators.Size() > 0)
    {
-      bdrFaceIntegrators[i]->AssembleEABoundaryFaces(*a->FESpace(),ea_data_bdr,i);
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
+      {
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposePA(x, y);
+         }
+         for (BilinearFormIntegrator *integ : bdr_face_integrators)
+         {
+            integ->AddMultTransposePA(x, y);
+         }
+      }
    }
+}
 
-   if (factorize_face_terms && int_face_restrict_lex)
+void PABilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
+                                               const double c) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      auto restFint = dynamic_cast<const L2FaceRestriction*>(int_face_restrict_lex);
-      restFint->AddFaceMatricesToElementMatrices(ea_data_int, ea_data);
+      if (elem_restrict)
+      {
+         elem_restrict->Mult(x, local_x);
+         local_y = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposePA(local_x, local_y);
+         }
+         if (c != 1.0)
+         {
+            local_y *= c;
+         }
+         elem_restrict->AddMultTranspose(local_y, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(x, y);
+            }
+         }
+      }
    }
-   if (factorize_face_terms && bdr_face_restrict_lex)
+
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
    {
-      auto restFbdr = dynamic_cast<const L2FaceRestriction*>(bdr_face_restrict_lex);
-      restFbdr->AddFaceMatricesToElementMatrices(ea_data_bdr, ea_data);
+      if (int_face_restrict_lex)
+      {
+         int_face_restrict_lex->Mult(x, int_face_x);
+         if (int_face_x.Size() > 0)
+         {
+            int_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultTransposePA(int_face_x, int_face_y);
+            }
+            if (c != 1.0)
+            {
+               int_face_y *= c;
+            }
+            int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
+         }
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultTransposePA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : int_face_integrators)
+            {
+               integ->AddMultTransposePA(x, y);
+            }
+         }
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_integrators.Size() > 0 || bdr_face_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex)
+      {
+         bdr_face_restrict_lex->Mult(x, bdr_face_x);
+         if (bdr_face_x.Size() > 0)
+         {
+            bdr_face_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_x, bdr_face_y);
+            }
+            if (c != 1.0)
+            {
+               bdr_face_y *= c;
+            }
+            bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
+         }
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_y.SetSize(y.Size());
+            temp_y.UseDevice(true);
+            temp_y = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(x, temp_y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultTransposePA(x, temp_y);
+            }
+            y.Add(c, temp_y);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(x, y);
+            }
+            for (BilinearFormIntegrator *integ : bdr_face_integrators)
+            {
+               integ->AddMultTransposePA(x, y);
+            }
+         }
+      }
    }
 }
 
-void EABilinearFormExtension::Mult(const Vector &x, Vector &y) const
+/// Data and methods for element-assembled bilinear forms
+EABilinearFormExtension::EABilinearFormExtension(BilinearForm *form)
+   : PABilinearFormExtension(form),
+     factorize_face_terms(fes->IsDGSpace() && fes->Conforming())
 {
-   // Apply the Element Restriction
-   const bool useRestrict = !DeviceCanUseCeed() && elem_restrict;
-   if (!useRestrict)
+}
+
+void EABilinearFormExtension::Assemble()
+{
+   SetupRestrictionOperators(L2FaceValues::SingleValued);
+
+   ne = fes->GetNE();
+   elem_dofs = fes->GetFE(0)->GetDof();
+
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
+      ea_data.SetSize(ne * elem_dofs * elem_dofs, Device::GetMemoryType());
+      ea_data.UseDevice(true);
+      ea_data = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AssembleEA(*fes, ea_data);
+      }
    }
-   else
+
+   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
+               "Element assembly does not support AddBoundaryIntegrator yet.");
+
+   nf_int = fes->GetNFbyType(FaceType::Interior);
+   nf_bdr = fes->GetNFbyType(FaceType::Boundary);
+   face_dofs = fes->GetTraceElement(0,
+                                    fes->GetMesh()->GetFaceGeometry(0))->GetDof();
+
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   if (int_face_integrators.Size() > 0)
+   {
+      ea_data_int.SetSize(2 * nf_int * face_dofs * face_dofs,
+                          Device::GetMemoryType());
+      ea_data_ext.SetSize(2 * nf_int * face_dofs * face_dofs,
+                          Device::GetMemoryType());
+      ea_data_int = 0.0;
+      ea_data_ext = 0.0;
+      for (BilinearFormIntegrator *integ : int_face_integrators)
+      {
+         integ->AssembleEAInteriorFaces(*fes, ea_data_int, ea_data_ext);
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (bdr_face_integrators.Size() > 0)
    {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
+      ea_data_bdr.SetSize(nf_bdr * face_dofs * face_dofs, Device::GetMemoryType());
+      ea_data_bdr = 0.0;
+      for (BilinearFormIntegrator *integ : bdr_face_integrators)
+      {
+         integ->AssembleEABoundaryFaces(*fes, ea_data_bdr);
+      }
    }
-   // Apply the Element Matrices
+
+   if (factorize_face_terms && int_face_restrict_lex)
+   {
+      auto l2_face_restrict = dynamic_cast<const L2FaceRestriction &>
+                              (*int_face_restrict_lex);
+      l2_face_restrict.AddFaceMatricesToElementMatrices(ea_data_int, ea_data);
+   }
+   if (factorize_face_terms && bdr_face_restrict_lex)
    {
-      const int NDOFS = elemDofs;
-      auto X = Reshape(useRestrict?localX.Read():x.Read(), NDOFS, ne);
-      auto Y = Reshape(useRestrict?localY.ReadWrite():y.ReadWrite(), NDOFS, ne);
-      auto A = Reshape(ea_data.Read(), NDOFS, NDOFS, ne);
-      mfem::forall(ne*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
+      auto l2_face_restrict = dynamic_cast<const L2FaceRestriction &>
+                              (*bdr_face_restrict_lex);
+      l2_face_restrict.AddFaceMatricesToElementMatrices(ea_data_bdr, ea_data);
+   }
+}
+
+void EABilinearFormExtension::Mult(const Vector &x, Vector &y) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   auto Apply = [](const int nelem, const int ndofs, const Vector &data,
+                   const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, nelem);
+      auto Y = Reshape(y.ReadWrite(), ndofs, nelem);
+      auto A = Reshape(data.Read(), ndofs, ndofs, nelem);
+      mfem::forall(nelem * ndofs, [=] MFEM_HOST_DEVICE (int k)
       {
-         const int e = glob_j/NDOFS;
-         const int j = glob_j%NDOFS;
+         const int e = k / ndofs;
+         const int j = k % ndofs;
          double res = 0.0;
-         for (int i = 0; i < NDOFS; i++)
+         for (int i = 0; i < ndofs; i++)
          {
-            res += A(i, j, e)*X(i, e);
+            res += A(i, j, e) * X(i, e);
          }
          Y(j, e) += res;
       });
-      // Apply the Element Restriction transposed
-      if (useRestrict)
+   };
+   if (integrators.Size() > 0 && elem_restrict)
+   {
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      Apply(ne, elem_dofs, ea_data, local_x, local_y);
+      elem_restrict->MultTranspose(local_y, y);
+   }
+   else
+   {
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      y = 0.0;
+      if (integrators.Size() > 0)
       {
-         elem_restrict->MultTranspose(localY, y);
+         Apply(ne, elem_dofs, ea_data, x, y);
       }
    }
 
    // Treatment of interior faces
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
-   {
-      // Apply the Interior Face Restriction
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
-      {
-         int_face_Y = 0.0;
-         // Apply the interior face matrices
-         const int NDOFS = faceDofs;
-         auto X = Reshape(int_face_X.Read(), NDOFS, 2, nf_int);
-         auto Y = Reshape(int_face_Y.ReadWrite(), NDOFS, 2, nf_int);
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   auto ApplyIntFace = [](const int nface, const int ndofs, const Vector &data,
+                          const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 0, f) * X(i, 0, f);
+         }
+         Y(j, 0, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 1, f) * X(i, 1, f);
+         }
+         Y(j, 1, f) += res;
+      });
+   };
+   auto ApplyExtFace = [](const int nface, const int ndofs, const Vector &data,
+                          const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 0, f) * X(i, 0, f);
+         }
+         Y(j, 1, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(i, j, 1, f) * X(i, 1, f);
+         }
+         Y(j, 0, f) += res;
+      });
+   };
+   if (int_face_restrict_lex && int_face_integrators.Size() > 0)
+   {
+      int_face_restrict_lex->Mult(x, int_face_x);
+      if (int_face_x.Size() > 0)
+      {
+         int_face_y = 0.0;
          if (!factorize_face_terms)
          {
-            auto A_int = Reshape(ea_data_int.Read(), NDOFS, NDOFS, 2, nf_int);
-            mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-            {
-               const int f = glob_j/NDOFS;
-               const int j = glob_j%NDOFS;
-               double res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(i, j, 0, f)*X(i, 0, f);
-               }
-               Y(j, 0, f) += res;
-               res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(i, j, 1, f)*X(i, 1, f);
-               }
-               Y(j, 1, f) += res;
-            });
-         }
-         auto A_ext = Reshape(ea_data_ext.Read(), NDOFS, NDOFS, 2, nf_int);
-         mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(i, j, 0, f)*X(i, 0, f);
-            }
-            Y(j, 1, f) += res;
-            res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(i, j, 1, f)*X(i, 1, f);
-            }
-            Y(j, 0, f) += res;
-         });
-         // Apply the Interior Face Restriction transposed
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+            ApplyIntFace(nf_int, face_dofs, ea_data_int, int_face_x, int_face_y);
+         }
+         ApplyExtFace(nf_int, face_dofs, ea_data_ext, int_face_x, int_face_y);
+         int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
       }
    }
 
    // Treatment of boundary faces
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (!factorize_face_terms && bdr_face_restrict_lex && bFISz>0)
-   {
-      // Apply the Boundary Face Restriction
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
-      {
-         bdr_face_Y = 0.0;
-         // Apply the boundary face matrices
-         const int NDOFS = faceDofs;
-         auto X = Reshape(bdr_face_X.Read(), NDOFS, nf_bdr);
-         auto Y = Reshape(bdr_face_Y.ReadWrite(), NDOFS, nf_bdr);
-         auto A = Reshape(ea_data_bdr.Read(), NDOFS, NDOFS, nf_bdr);
-         mfem::forall(nf_bdr*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A(i, j, f)*X(i, f);
-            }
-            Y(j, f) += res;
-         });
-         // Apply the Boundary Face Restriction transposed
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (!factorize_face_terms && bdr_face_restrict_lex &&
+       bdr_face_integrators.Size() > 0)
+   {
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
+      {
+         bdr_face_y = 0.0;
+         Apply(nf_bdr, face_dofs, ea_data_bdr, bdr_face_x, bdr_face_y);
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
       }
    }
 }
 
 void EABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 {
-   // Apply the Element Restriction
-   const bool useRestrict = !DeviceCanUseCeed() && elem_restrict;
-   if (!useRestrict)
-   {
-      y.UseDevice(true); // typically this is a large vector, so store on device
-      y = 0.0;
-   }
-   else
-   {
-      elem_restrict->Mult(x, localX);
-      localY = 0.0;
-   }
-   // Apply the Element Matrices transposed
-   {
-      const int NDOFS = elemDofs;
-      auto X = Reshape(useRestrict?localX.Read():x.Read(), NDOFS, ne);
-      auto Y = Reshape(useRestrict?localY.ReadWrite():y.ReadWrite(), NDOFS, ne);
-      auto A = Reshape(ea_data.Read(), NDOFS, NDOFS, ne);
-      mfem::forall(ne*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   auto ApplyTranspose = [](const int nelem, const int ndofs, const Vector &data,
+                            const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, nelem);
+      auto Y = Reshape(y.ReadWrite(), ndofs, nelem);
+      auto A = Reshape(data.Read(), ndofs, ndofs, nelem);
+      mfem::forall(nelem * ndofs, [=] MFEM_HOST_DEVICE (int k)
       {
-         const int e = glob_j/NDOFS;
-         const int j = glob_j%NDOFS;
+         const int e = k / ndofs;
+         const int j = k % ndofs;
          double res = 0.0;
-         for (int i = 0; i < NDOFS; i++)
+         for (int i = 0; i < ndofs; i++)
          {
-            res += A(j, i, e)*X(i, e);
+            res += A(j, i, e) * X(i, e);
          }
          Y(j, e) += res;
       });
-      // Apply the Element Restriction transposed
-      if (useRestrict)
+   };
+   if (integrators.Size() > 0 && elem_restrict)
+   {
+      elem_restrict->Mult(x, local_x);
+      local_y = 0.0;
+      ApplyTranspose(ne, elem_dofs, ea_data, local_x, local_y);
+      elem_restrict->MultTranspose(local_y, y);
+   }
+   else
+   {
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      y = 0.0;
+      if (integrators.Size() > 0)
       {
-         elem_restrict->MultTranspose(localY, y);
+         ApplyTranspose(ne, elem_dofs, ea_data, x, y);
       }
    }
 
    // Treatment of interior faces
-   Array<BilinearFormIntegrator*> &intFaceIntegrators = *a->GetFBFI();
-   const int iFISz = intFaceIntegrators.Size();
-   if (int_face_restrict_lex && iFISz>0)
-   {
-      // Apply the Interior Face Restriction
-      int_face_restrict_lex->Mult(x, int_face_X);
-      if (int_face_X.Size()>0)
-      {
-         int_face_Y = 0.0;
-         // Apply the interior face matrices transposed
-         const int NDOFS = faceDofs;
-         auto X = Reshape(int_face_X.Read(), NDOFS, 2, nf_int);
-         auto Y = Reshape(int_face_Y.ReadWrite(), NDOFS, 2, nf_int);
+   Array<BilinearFormIntegrator *> &int_face_integrators = *a->GetFBFI();
+   auto ApplyIntFaceTranspose = [](const int nface, const int ndofs,
+                                   const Vector &data, const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 0, f) * X(i, 0, f);
+         }
+         Y(j, 0, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 1, f) * X(i, 1, f);
+         }
+         Y(j, 1, f) += res;
+      });
+   };
+   auto ApplyExtFaceTranspose = [](const int nface, const int ndofs,
+                                   const Vector &data, const Vector &x, Vector &y)
+   {
+      auto X = Reshape(x.Read(), ndofs, 2, nface);
+      auto Y = Reshape(y.ReadWrite(), ndofs, 2, nface);
+      auto A = Reshape(data.Read(), ndofs, ndofs, 2, nface);
+      mfem::forall(nface * ndofs, [=] MFEM_HOST_DEVICE (int k)
+      {
+         const int f = k / ndofs;
+         const int j = k % ndofs;
+         double res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 1, f) * X(i, 0, f);
+         }
+         Y(j, 1, f) += res;
+         res = 0.0;
+         for (int i = 0; i < ndofs; i++)
+         {
+            res += A(j, i, 0, f) * X(i, 1, f);
+         }
+         Y(j, 0, f) += res;
+      });
+   };
+   if (int_face_restrict_lex && int_face_integrators.Size() > 0)
+   {
+      int_face_restrict_lex->Mult(x, int_face_x);
+      if (int_face_x.Size() > 0)
+      {
+         int_face_y = 0.0;
          if (!factorize_face_terms)
          {
-            auto A_int = Reshape(ea_data_int.Read(), NDOFS, NDOFS, 2, nf_int);
-            mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-            {
-               const int f = glob_j/NDOFS;
-               const int j = glob_j%NDOFS;
-               double res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(j, i, 0, f)*X(i, 0, f);
-               }
-               Y(j, 0, f) += res;
-               res = 0.0;
-               for (int i = 0; i < NDOFS; i++)
-               {
-                  res += A_int(j, i, 1, f)*X(i, 1, f);
-               }
-               Y(j, 1, f) += res;
-            });
-         }
-         auto A_ext = Reshape(ea_data_ext.Read(), NDOFS, NDOFS, 2, nf_int);
-         mfem::forall(nf_int*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(j, i, 1, f)*X(i, 0, f);
-            }
-            Y(j, 1, f) += res;
-            res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A_ext(j, i, 0, f)*X(i, 1, f);
-            }
-            Y(j, 0, f) += res;
-         });
-         // Apply the Interior Face Restriction transposed
-         int_face_restrict_lex->AddMultTransposeInPlace(int_face_Y, y);
+            ApplyIntFaceTranspose(nf_int, face_dofs, ea_data_int, int_face_x, int_face_y);
+         }
+         ApplyExtFaceTranspose(nf_int, face_dofs, ea_data_ext, int_face_x, int_face_y);
+         int_face_restrict_lex->AddMultTransposeInPlace(int_face_y, y);
       }
    }
 
    // Treatment of boundary faces
-   Array<BilinearFormIntegrator*> &bdrFaceIntegrators = *a->GetBFBFI();
-   const int bFISz = bdrFaceIntegrators.Size();
-   if (!factorize_face_terms && bdr_face_restrict_lex && bFISz>0)
-   {
-      // Apply the Boundary Face Restriction
-      bdr_face_restrict_lex->Mult(x, bdr_face_X);
-      if (bdr_face_X.Size()>0)
-      {
-         bdr_face_Y = 0.0;
-         // Apply the boundary face matrices transposed
-         const int NDOFS = faceDofs;
-         auto X = Reshape(bdr_face_X.Read(), NDOFS, nf_bdr);
-         auto Y = Reshape(bdr_face_Y.ReadWrite(), NDOFS, nf_bdr);
-         auto A = Reshape(ea_data_bdr.Read(), NDOFS, NDOFS, nf_bdr);
-         mfem::forall(nf_bdr*NDOFS, [=] MFEM_HOST_DEVICE (int glob_j)
-         {
-            const int f = glob_j/NDOFS;
-            const int j = glob_j%NDOFS;
-            double res = 0.0;
-            for (int i = 0; i < NDOFS; i++)
-            {
-               res += A(j, i, f)*X(i, f);
-            }
-            Y(j, f) += res;
-         });
-         // Apply the Boundary Face Restriction transposed
-         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_Y, y);
+   Array<BilinearFormIntegrator *> &bdr_face_integrators = *a->GetBFBFI();
+   if (!factorize_face_terms && bdr_face_restrict_lex &&
+       bdr_face_integrators.Size() > 0)
+   {
+      bdr_face_restrict_lex->Mult(x, bdr_face_x);
+      if (bdr_face_x.Size() > 0)
+      {
+         bdr_face_y = 0.0;
+         ApplyTranspose(nf_bdr, face_dofs, ea_data_bdr, bdr_face_x, bdr_face_y);
+         bdr_face_restrict_lex->AddMultTransposeInPlace(bdr_face_y, y);
       }
    }
 }
 
-// Data and methods for fully-assembled bilinear forms
+/// Data and methods for fully-assembled bilinear forms
 FABilinearFormExtension::FABilinearFormExtension(BilinearForm *form)
    : EABilinearFormExtension(form),
      mat(a->mat)
 {
 #ifdef MFEM_USE_MPI
-   ParFiniteElementSpace *pfes = nullptr;
-   if ( a->GetFBFI()->Size()>0 &&
-        (pfes = dynamic_cast<ParFiniteElementSpace*>(form->FESpace())) )
+   const ParFiniteElementSpace *pfes = nullptr;
+   if (a->GetFBFI()->Size() > 0 &&
+       (pfes = dynamic_cast<const ParFiniteElementSpace *>(form->FESpace())))
    {
-      pfes->ExchangeFaceNbrData();
+      const_cast<ParFiniteElementSpace *>(pfes)->ExchangeFaceNbrData();
    }
 #endif
 }
@@ -888,20 +1299,20 @@ FABilinearFormExtension::FABilinearFormExtension(BilinearForm *form)
 void FABilinearFormExtension::Assemble()
 {
    EABilinearFormExtension::Assemble();
-   FiniteElementSpace &fes = *a->FESpace();
-   int width = fes.GetVSize();
-   int height = fes.GetVSize();
+
+   int width = fes->GetVSize();
+   int height = fes->GetVSize();
    bool keep_nbr_block = false;
 #ifdef MFEM_USE_MPI
-   ParFiniteElementSpace *pfes = nullptr;
-   if ( a->GetFBFI()->Size()>0 &&
-        (pfes = dynamic_cast<ParFiniteElementSpace*>(&fes)) )
+   const ParFiniteElementSpace *pfes = nullptr;
+   if (a->GetFBFI()->Size() > 0 &&
+       (pfes = dynamic_cast<const ParFiniteElementSpace *>(fes)))
    {
-      pfes->ExchangeFaceNbrData();
+      const_cast<ParFiniteElementSpace *>(pfes)->ExchangeFaceNbrData();
       width += pfes->GetFaceNbrVSize();
       dg_x.SetSize(width);
       ParBilinearForm *pb = nullptr;
-      if ((pb = dynamic_cast<ParBilinearForm*>(a)) && (pb->keep_nbr_block))
+      if ((pb = dynamic_cast<ParBilinearForm *>(a)) && pb->keep_nbr_block)
       {
          height += pfes->GetFaceNbrVSize();
          dg_y.SetSize(height);
@@ -911,15 +1322,14 @@ void FABilinearFormExtension::Assemble()
 #endif
    if (a->mat) // We reuse the sparse matrix memory
    {
-      if (fes.IsDGSpace())
+      if (fes->IsDGSpace())
       {
-         const L2ElementRestriction *restE =
-            static_cast<const L2ElementRestriction*>(elem_restrict);
-         const L2FaceRestriction *restF =
-            static_cast<const L2FaceRestriction*>(int_face_restrict_lex);
-         MFEM_VERIFY(
-            fes.Conforming(),
-            "Full Assembly not yet supported on NCMesh.");
+         const auto *restE =
+            static_cast<const L2ElementRestriction *>(elem_restrict);
+         const auto *restF =
+            static_cast<const L2FaceRestriction *>(int_face_restrict_lex);
+         MFEM_VERIFY(fes->Conforming(),
+                     "Full Assembly not yet supported on NCMesh.");
          // 1. Fill J and Data
          // 1.1 Fill J and Data with Elem ea_data
          restE->FillJAndData(ea_data, *mat);
@@ -935,8 +1345,8 @@ void FABilinearFormExtension::Assemble()
       }
       else
       {
-         const ElementRestriction &rest =
-            static_cast<const ElementRestriction&>(*elem_restrict);
+         const auto &rest =
+            static_cast<const ConformingElementRestriction&>(*elem_restrict);
          rest.FillJAndData(ea_data, *mat);
       }
    }
@@ -944,15 +1354,14 @@ void FABilinearFormExtension::Assemble()
    {
       mat = new SparseMatrix;
       mat->OverrideSize(height, width);
-      if (fes.IsDGSpace())
-      {
-         const L2ElementRestriction *restE =
-            static_cast<const L2ElementRestriction*>(elem_restrict);
-         const L2FaceRestriction *restF =
-            static_cast<const L2FaceRestriction*>(int_face_restrict_lex);
-         MFEM_VERIFY(
-            fes.Conforming(),
-            "Full Assembly not yet supported on NCMesh.");
+      if (fes->IsDGSpace())
+      {
+         const auto *restE =
+            static_cast<const L2ElementRestriction *>(elem_restrict);
+         const auto *restF =
+            static_cast<const L2FaceRestriction *>(int_face_restrict_lex);
+         MFEM_VERIFY(fes->Conforming(),
+                     "Full Assembly not yet supported on NCMesh.");
          // 1. Fill I
          mat->GetMemoryI().New(height+1, mat->GetMemoryI().GetMemoryType());
          //  1.1 Increment with restE
@@ -985,87 +1394,32 @@ void FABilinearFormExtension::Assemble()
          }
          I[0] = 0;
       }
-      else // continuous Galerkin case
+      else
       {
-         const ElementRestriction &rest =
-            static_cast<const ElementRestriction&>(*elem_restrict);
+         const auto &rest =
+            static_cast<const ConformingElementRestriction &>(*elem_restrict);
          rest.FillSparseMatrix(ea_data, *mat);
       }
       a->mat = mat;
    }
-   if ( a->sort_sparse_matrix )
+   if (a->sort_sparse_matrix)
    {
       a->mat->SortColumnIndices();
    }
 }
 
-
-void FABilinearFormExtension::RAP(OperatorHandle &A)
-{
-#ifdef MFEM_USE_MPI
-   if ( auto pa = dynamic_cast<ParBilinearForm*>(a) )
-   {
-      pa->ParallelRAP(*pa->mat, A);
-   }
-   else
-#endif
-   {
-      a->SerialRAP(A);
-   }
-}
-
-void FABilinearFormExtension::EliminateBC(const Array<int> &ess_dofs,
-                                          OperatorHandle &A)
-{
-   MFEM_VERIFY(a->diag_policy == DiagonalPolicy::DIAG_ONE,
-               "Only DiagonalPolicy::DIAG_ONE supported with"
-               " FABilinearFormExtension.");
-#ifdef MFEM_USE_MPI
-   if ( dynamic_cast<ParBilinearForm*>(a) )
-   {
-      A.As<HypreParMatrix>()->EliminateBC(ess_dofs,
-                                          DiagonalPolicy::DIAG_ONE);
-   }
-   else
-#endif
-   {
-      A.As<SparseMatrix>()->EliminateBC(ess_dofs,
-                                        DiagonalPolicy::DIAG_ONE);
-   }
-}
-
-void FABilinearFormExtension::FormSystemMatrix(const Array<int> &ess_dofs,
-                                               OperatorHandle &A)
-{
-   RAP(A);
-   EliminateBC(ess_dofs, A);
-}
-
-void FABilinearFormExtension::FormLinearSystem(const Array<int> &ess_tdof_list,
-                                               Vector &x, Vector &b,
-                                               OperatorHandle &A,
-                                               Vector &X, Vector &B,
-                                               int copy_interior)
-{
-   Operator *A_out;
-   Operator::FormLinearSystem(ess_tdof_list, x, b, A_out, X, B, copy_interior);
-   delete A_out;
-   FormSystemMatrix(ess_tdof_list, A);
-}
-
 void FABilinearFormExtension::DGMult(const Vector &x, Vector &y) const
 {
 #ifdef MFEM_USE_MPI
-   const ParFiniteElementSpace *pfes;
-   if ( (pfes = dynamic_cast<const ParFiniteElementSpace*>(test_fes)) )
+   if (const auto pfes = dynamic_cast<const ParFiniteElementSpace *>(fes))
    {
       // DG Prolongation
       ParGridFunction x_gf;
-      x_gf.MakeRef(const_cast<ParFiniteElementSpace*>(pfes),
-                   const_cast<Vector&>(x),0);
+      x_gf.MakeRef(const_cast<ParFiniteElementSpace *>(pfes),
+                   const_cast<Vector &>(x), 0);
       x_gf.ExchangeFaceNbrData();
       Vector &shared_x = x_gf.FaceNbrData();
-      const int local_size = a->FESpace()->GetVSize();
+      const int local_size = fes->GetVSize();
       auto dg_x_ptr = dg_x.Write();
       auto x_ptr = x.Read();
       mfem::forall(local_size, [=] MFEM_HOST_DEVICE (int i)
@@ -1078,8 +1432,8 @@ void FABilinearFormExtension::DGMult(const Vector &x, Vector &y) const
       {
          dg_x_ptr[local_size+i] = shared_x_ptr[i];
       });
-      ParBilinearForm *pform = nullptr;
-      if ((pform = dynamic_cast<ParBilinearForm*>(a)) && (pform->keep_nbr_block))
+      ParBilinearForm *pb = nullptr;
+      if ((pb = dynamic_cast<ParBilinearForm *>(a)) && pb->keep_nbr_block)
       {
          mat->Mult(dg_x, dg_y);
          // DG Restriction
@@ -1104,7 +1458,7 @@ void FABilinearFormExtension::DGMult(const Vector &x, Vector &y) const
 
 void FABilinearFormExtension::Mult(const Vector &x, Vector &y) const
 {
-   if ( a->GetFBFI()->Size()>0 )
+   if (a->GetFBFI()->Size() > 0)
    {
       DGMult(x, y);
    }
@@ -1117,16 +1471,15 @@ void FABilinearFormExtension::Mult(const Vector &x, Vector &y) const
 void FABilinearFormExtension::DGMultTranspose(const Vector &x, Vector &y) const
 {
 #ifdef MFEM_USE_MPI
-   const ParFiniteElementSpace *pfes;
-   if ( (pfes = dynamic_cast<const ParFiniteElementSpace*>(test_fes)) )
+   if (const auto pfes = dynamic_cast<const ParFiniteElementSpace *>(fes))
    {
       // DG Prolongation
       ParGridFunction x_gf;
-      x_gf.MakeRef(const_cast<ParFiniteElementSpace*>(pfes),
-                   const_cast<Vector&>(x),0);
+      x_gf.MakeRef(const_cast<ParFiniteElementSpace *>(pfes),
+                   const_cast<Vector &>(x), 0);
       x_gf.ExchangeFaceNbrData();
       Vector &shared_x = x_gf.FaceNbrData();
-      const int local_size = a->FESpace()->GetVSize();
+      const int local_size = fes->GetVSize();
       auto dg_x_ptr = dg_x.Write();
       auto x_ptr = x.Read();
       mfem::forall(local_size, [=] MFEM_HOST_DEVICE (int i)
@@ -1140,7 +1493,7 @@ void FABilinearFormExtension::DGMultTranspose(const Vector &x, Vector &y) const
          dg_x_ptr[local_size+i] = shared_x_ptr[i];
       });
       ParBilinearForm *pb = nullptr;
-      if ((pb = dynamic_cast<ParBilinearForm*>(a)) && (pb->keep_nbr_block))
+      if ((pb = dynamic_cast<ParBilinearForm *>(a)) && (pb->keep_nbr_block))
       {
          mat->MultTranspose(dg_x, dg_y);
          // DG Restriction
@@ -1165,7 +1518,7 @@ void FABilinearFormExtension::DGMultTranspose(const Vector &x, Vector &y) const
 
 void FABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 {
-   if ( a->GetFBFI()->Size()>0 )
+   if (a->GetFBFI()->Size() > 0)
    {
       DGMultTranspose(x, y);
    }
@@ -1176,10 +1529,10 @@ void FABilinearFormExtension::MultTranspose(const Vector &x, Vector &y) const
 }
 
 
+/// Base class for extensions to the MixedBilinearForm class
 MixedBilinearFormExtension::MixedBilinearFormExtension(MixedBilinearForm *form)
    : Operator(form->Height(), form->Width()), a(form)
 {
-   // empty
 }
 
 const Operator *MixedBilinearFormExtension::GetProlongation() const
@@ -1187,392 +1540,725 @@ const Operator *MixedBilinearFormExtension::GetProlongation() const
    return a->GetProlongation();
 }
 
-const Operator *MixedBilinearFormExtension::GetRestriction() const
+const Operator *MixedBilinearFormExtension::GetRestriction() const
+{
+   return a->GetRestriction();
+}
+
+const Operator *MixedBilinearFormExtension::GetOutputProlongation() const
+{
+   return a->GetOutputProlongation();
+}
+
+const Operator *MixedBilinearFormExtension::GetOutputRestriction() const
+{
+   return a->GetOutputRestriction();
+}
+
+/// Data and methods for matrix-free mixed bilinear forms
+MFMixedBilinearFormExtension::MFMixedBilinearFormExtension(
+   MixedBilinearForm *form)
+   : MixedBilinearFormExtension(form)
+{
+   Update();
+}
+
+void MFMixedBilinearFormExtension::SetupRestrictionOperators(
+   const L2FaceValues m)
+{
+   if (DeviceCanUseCeed()) { return; }
+   ElementDofOrdering trial_ordering = UsesTensorBasis(*trial_fes) ?
+                                       ElementDofOrdering::LEXICOGRAPHIC :
+                                       ElementDofOrdering::NATIVE;
+   ElementDofOrdering test_ordering = UsesTensorBasis(*test_fes) ?
+                                      ElementDofOrdering::LEXICOGRAPHIC :
+                                      ElementDofOrdering::NATIVE;
+   elem_restrict_trial = trial_fes->GetElementRestriction(trial_ordering);
+   elem_restrict_test = test_fes->GetElementRestriction(test_ordering);
+   if (elem_restrict_trial)
+   {
+      local_trial.SetSize(elem_restrict_trial->Height(),
+                          Device::GetDeviceMemoryType());
+      local_trial.UseDevice(true); // ensure 'local_trial = 0.0' is done on device
+   }
+   if (elem_restrict_test)
+   {
+      local_test.SetSize(elem_restrict_test->Height(),
+                         Device::GetDeviceMemoryType());
+      local_test.UseDevice(true); // ensure 'local_test = 0.0' is done on device
+   }
+
+   // Construct face restriction operators only if the bilinear form has
+   // interior or boundary face integrators
+   if (a->GetTFBFI()->Size() > 0)
+   {
+      if (int_face_restrict_lex_trial == nullptr)
+      {
+         int_face_restrict_lex_trial = trial_fes->GetFaceRestriction(
+                                          ElementDofOrdering::LEXICOGRAPHIC,
+                                          FaceType::Interior);
+         int_face_trial.SetSize(int_face_restrict_lex_trial->Height(),
+                                Device::GetDeviceMemoryType());
+         int_face_trial.UseDevice(true);
+      }
+      if (int_face_restrict_lex_test == nullptr)
+      {
+         int_face_restrict_lex_test = test_fes->GetFaceRestriction(
+                                         ElementDofOrdering::LEXICOGRAPHIC,
+                                         FaceType::Interior);
+         int_face_test.SetSize(int_face_restrict_lex_test->Height(),
+                               Device::GetDeviceMemoryType());
+         int_face_test.UseDevice(true);
+      }
+   }
+
+   if (a->GetBTFBFI()->Size() > 0 || a->GetBBFI()->Size() > 0)
+   {
+      if (bdr_face_restrict_lex_trial == nullptr)
+      {
+         bdr_face_restrict_lex_trial = trial_fes->GetFaceRestriction(
+                                          ElementDofOrdering::LEXICOGRAPHIC,
+                                          FaceType::Boundary,
+                                          m);
+         bdr_face_trial.SetSize(bdr_face_restrict_lex_trial->Height(),
+                                Device::GetDeviceMemoryType());
+         bdr_face_trial.UseDevice(true);
+      }
+      if (bdr_face_restrict_lex_test == nullptr)
+      {
+         bdr_face_restrict_lex_test = test_fes->GetFaceRestriction(
+                                         ElementDofOrdering::LEXICOGRAPHIC,
+                                         FaceType::Boundary,
+                                         m);
+         bdr_face_test.SetSize(bdr_face_restrict_lex_test->Height(),
+                               Device::GetDeviceMemoryType());
+         bdr_face_test.UseDevice(true);
+      }
+   }
+}
+
+void MFMixedBilinearFormExtension::Assemble()
+{
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
+
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
+   {
+      integ->AssembleMF(*trial_fes, *test_fes);
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
+   {
+      integ->AssembleMFBoundary(*trial_fes, *test_fes);
+   }
+
+   MFEM_VERIFY(a->GetTFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in MFMixedBilinearFormExtension");
+
+   MFEM_VERIFY(a->GetBTFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in MFMixedBilinearFormExtension");
+}
+
+void MFMixedBilinearFormExtension::Mult(const Vector &x, Vector &y) const
+{
+   y = 0.0;
+   AddMult(x, y);
+}
+
+void MFMixedBilinearFormExtension::AddMult(const Vector &x, Vector &y,
+                                           const double c) const
+{
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
+   {
+      if (elem_restrict_trial)
+      {
+         elem_restrict_trial->Mult(x, local_trial);
+      }
+      if (elem_restrict_test)
+      {
+         local_test = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultMF(elem_restrict_trial ? local_trial : x, local_test);
+         }
+         if (c != 1.0)
+         {
+            local_test *= c;
+         }
+         elem_restrict_test->AddMultTranspose(local_test, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_test.SetSize(y.Size());
+            temp_test.UseDevice(true);
+            temp_test = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultMF(elem_restrict_trial ? local_trial : x, temp_test);
+            }
+            y.Add(c, temp_test);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultMF(elem_restrict_trial ? local_trial : x, y);
+            }
+         }
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex_trial)
+      {
+         bdr_face_restrict_lex_trial->Mult(x, bdr_face_trial);
+      }
+      if (bdr_face_restrict_lex_test)
+      {
+         bdr_face_test = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultMF(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                             bdr_face_test);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_test *= c;
+         }
+         bdr_face_restrict_lex_test->AddMultTranspose(bdr_face_test, y);
+      }
+      else
+      {
+         if (c != 1.0)
+         {
+            temp_test.SetSize(y.Size());
+            temp_test.UseDevice(true);
+            temp_test = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                                temp_test);
+            }
+            y.Add(c, temp_test);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultMF(bdr_face_restrict_lex_trial ? bdr_face_trial : x, y);
+            }
+         }
+      }
+   }
+}
+
+void MFMixedBilinearFormExtension::MultTranspose(const Vector &x,
+                                                 Vector &y) const
 {
-   return a->GetRestriction();
+   y = 0.0;
+   AddMultTranspose(x, y);
 }
 
-const Operator *MixedBilinearFormExtension::GetOutputProlongation() const
+void MFMixedBilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
+                                                    const double c) const
 {
-   return a->GetOutputProlongation();
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
+   {
+      if (elem_restrict_test)
+      {
+         elem_restrict_test->Mult(x, local_test);
+      }
+      if (elem_restrict_trial)
+      {
+         local_trial = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposeMF(elem_restrict_test ? local_test : x,
+                                      local_trial);
+         }
+         if (c != 1.0)
+         {
+            local_trial *= c;
+         }
+         elem_restrict_trial->AddMultTranspose(local_trial, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_trial.SetSize(y.Size());
+            temp_trial.UseDevice(true);
+            temp_trial = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(elem_restrict_test ? local_test : x,
+                                         temp_trial);
+            }
+            y.Add(c, temp_trial);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(elem_restrict_test ? local_test : x, y);
+            }
+         }
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex_test)
+      {
+         bdr_face_restrict_lex_test->Mult(x, bdr_face_test);
+      }
+      if (bdr_face_restrict_lex_trial)
+      {
+         bdr_face_trial = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposeMF(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                      bdr_face_trial);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_trial *= c;
+         }
+         bdr_face_restrict_lex_trial->AddMultTranspose(bdr_face_trial, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_trial.SetSize(y.Size());
+            temp_trial.UseDevice(true);
+            temp_trial = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposeMF(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                         temp_trial);
+            }
+            y.Add(c, temp_trial);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposeMF(bdr_face_restrict_lex_test ? bdr_face_test : x, y);
+            }
+         }
+      }
+   }
 }
 
-const Operator *MixedBilinearFormExtension::GetOutputRestriction() const
+void MFMixedBilinearFormExtension::Update()
 {
-   return a->GetOutputRestriction();
+   trial_fes = a->TrialFESpace();
+   test_fes  = a->TestFESpace();
+   height = test_fes->GetVSize();
+   width  = trial_fes->GetVSize();
+
+   elem_restrict_trial = nullptr;
+   elem_restrict_test = nullptr;
+   int_face_restrict_lex_trial = nullptr;
+   int_face_restrict_lex_test = nullptr;
+   bdr_face_restrict_lex_trial = nullptr;
+   bdr_face_restrict_lex_test = nullptr;
 }
 
-// Data and methods for partially-assembled bilinear forms
-
+/// Data and methods for partially-assembled mixed bilinear forms
 PAMixedBilinearFormExtension::PAMixedBilinearFormExtension(
    MixedBilinearForm *form)
-   : MixedBilinearFormExtension(form),
-     trial_fes(form->TrialFESpace()),
-     test_fes(form->TestFESpace()),
-     elem_restrict_trial(NULL),
-     elem_restrict_test(NULL)
+   : MFMixedBilinearFormExtension(form)
 {
-   Update();
 }
 
 void PAMixedBilinearFormExtension::Assemble()
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
-   {
-      integrators[i]->AssemblePA(*trial_fes, *test_fes);
-   }
-   MFEM_VERIFY(a->GetBBFI()->Size() == 0,
-               "Partial assembly does not support AddBoundaryIntegrator yet.");
-   MFEM_VERIFY(a->GetTFBFI()->Size() == 0,
-               "Partial assembly does not support AddTraceFaceIntegrator yet.");
-   MFEM_VERIFY(a->GetBTFBFI()->Size() == 0,
-               "Partial assembly does not support AddBdrTraceFaceIntegrator yet.");
-}
+   SetupRestrictionOperators(L2FaceValues::DoubleValued);
 
-void PAMixedBilinearFormExtension::Update()
-{
-   trial_fes = a->TrialFESpace();
-   test_fes  = a->TestFESpace();
-   height = test_fes->GetVSize();
-   width = trial_fes->GetVSize();
-   elem_restrict_trial = trial_fes->GetElementRestriction(
-                            ElementDofOrdering::LEXICOGRAPHIC);
-   elem_restrict_test  =  test_fes->GetElementRestriction(
-                             ElementDofOrdering::LEXICOGRAPHIC);
-   if (elem_restrict_trial)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   for (BilinearFormIntegrator *integ : integrators)
    {
-      localTrial.UseDevice(true);
-      localTrial.SetSize(elem_restrict_trial->Height(),
-                         Device::GetMemoryType());
+      integ->AssemblePA(*trial_fes, *test_fes);
    }
-   if (elem_restrict_test)
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   for (BilinearFormIntegrator *integ : bdr_integrators)
    {
-      localTest.UseDevice(true); // ensure 'localY = 0.0' is done on device
-      localTest.SetSize(elem_restrict_test->Height(), Device::GetMemoryType());
+      integ->AssemblePABoundary(*trial_fes, *test_fes);
    }
-}
 
-void PAMixedBilinearFormExtension::FormRectangularSystemOperator(
-   const Array<int> &trial_tdof_list,
-   const Array<int> &test_tdof_list,
-   OperatorHandle &A)
-{
-   Operator * oper;
-   Operator::FormRectangularSystemOperator(trial_tdof_list, test_tdof_list,
-                                           oper);
-   A.Reset(oper); // A will own oper
-}
+   MFEM_VERIFY(a->GetTFBFI()->Size() == 0, "AddInteriorFaceIntegrator is not "
+               "currently supported in PAMixedBilinearFormExtension");
 
-void PAMixedBilinearFormExtension::FormRectangularLinearSystem(
-   const Array<int> &trial_tdof_list,
-   const Array<int> &test_tdof_list,
-   Vector &x, Vector &b,
-   OperatorHandle &A,
-   Vector &X, Vector &B)
-{
-   Operator *oper;
-   Operator::FormRectangularLinearSystem(trial_tdof_list, test_tdof_list, x, b,
-                                         oper, X, B);
-   A.Reset(oper); // A will own oper
+   MFEM_VERIFY(a->GetBTFBFI()->Size() == 0, "AddBdrFaceIntegrator is not "
+               "currently supported in PAMixedBilinearFormExtension");
 }
 
-void PAMixedBilinearFormExtension::SetupMultInputs(
-   const Operator *elem_restrict_x,
-   const Vector &x,
-   Vector &localX,
-   const Operator *elem_restrict_y,
-   Vector &y,
-   Vector &localY,
-   const double c) const
+void PAMixedBilinearFormExtension::AssembleDiagonal_ADAt(const Vector &D,
+                                                         Vector &diag) const
 {
-   // * G operation: localX = c*local(x)
-   if (elem_restrict_x)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      elem_restrict_x->Mult(x, localX);
-      if (c != 1.0)
+      if (elem_restrict_trial)
+      {
+         elem_restrict_trial->MultUnsigned(D, local_trial);
+      }
+      if (elem_restrict_test)
       {
-         localX *= c;
+         local_test = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AssembleDiagonalPA_ADAt(elem_restrict_trial ? local_trial : D,
+                                           local_test);
+         }
+         elem_restrict_test->MultTransposeUnsigned(local_test, diag);
       }
    }
    else
    {
-      if (c == 1.0)
+      diag.UseDevice(true); // typically this is a large vector, so store on device
+      diag = 0.0;
+      for (BilinearFormIntegrator *integ : integrators)
+      {
+         integ->AssembleDiagonalPA_ADAt(elem_restrict_trial ? local_trial : D, diag);
+      }
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex_trial)
+      {
+         bdr_face_restrict_lex_trial->MultUnsigned(D, bdr_face_trial);
+      }
+      if (bdr_face_restrict_lex_test)
       {
-         localX.SyncAliasMemory(x);
+         bdr_face_test = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AssembleDiagonalPA_ADAt(bdr_face_restrict_lex_trial ? bdr_face_trial : D,
+                                           bdr_face_test);
+         }
+         bdr_face_restrict_lex_test->AddMultTransposeUnsigned(bdr_face_test, diag);
       }
       else
       {
-         localX.Set(c, x);
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AssembleDiagonalPA_ADAt(bdr_face_restrict_lex_trial ? bdr_face_trial : D,
+                                           diag);
+         }
       }
    }
-   if (elem_restrict_y)
-   {
-      localY = 0.0;
-   }
-   else
-   {
-      y.UseDevice(true);
-      localY.SyncAliasMemory(y);
-   }
-}
-
-void PAMixedBilinearFormExtension::Mult(const Vector &x, Vector &y) const
-{
-   y = 0.0;
-   AddMult(x, y);
 }
 
 void PAMixedBilinearFormExtension::AddMult(const Vector &x, Vector &y,
                                            const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // * G operation
-   SetupMultInputs(elem_restrict_trial, x, localTrial,
-                   elem_restrict_test, y, localTest, c);
-
-   // * B^TDB operation
-   for (int i = 0; i < iSz; ++i)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      integrators[i]->AddMultPA(localTrial, localTest);
+      if (elem_restrict_trial)
+      {
+         elem_restrict_trial->Mult(x, local_trial);
+      }
+      if (elem_restrict_test)
+      {
+         local_test = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultPA(elem_restrict_trial ? local_trial : x, local_test);
+         }
+         if (c != 1.0)
+         {
+            local_test *= c;
+         }
+         elem_restrict_test->AddMultTranspose(local_test, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_test.SetSize(y.Size());
+            temp_test.UseDevice(true);
+            temp_test = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultPA(elem_restrict_trial ? local_trial : x, temp_test);
+            }
+            y.Add(c, temp_test);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultPA(elem_restrict_trial ? local_trial : x, y);
+            }
+         }
+      }
    }
 
-   // * G^T operation
-   if (elem_restrict_test)
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
    {
-      tempY.SetSize(y.Size());
-      elem_restrict_test->MultTranspose(localTest, tempY);
-      y += tempY;
+      if (bdr_face_restrict_lex_trial)
+      {
+         bdr_face_restrict_lex_trial->Mult(x, bdr_face_trial);
+      }
+      if (bdr_face_restrict_lex_test)
+      {
+         bdr_face_test = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultPA(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                             bdr_face_test);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_test *= c;
+         }
+         bdr_face_restrict_lex_test->AddMultTranspose(bdr_face_test, y);
+      }
+      else
+      {
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
+         {
+            temp_test.SetSize(y.Size());
+            temp_test.UseDevice(true);
+            temp_test = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(bdr_face_restrict_lex_trial ? bdr_face_trial : x,
+                                temp_test);
+            }
+            y.Add(c, temp_test);
+         }
+         else
+         {
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultPA(bdr_face_restrict_lex_trial ? bdr_face_trial : x, y);
+            }
+         }
+      }
    }
 }
 
-void PAMixedBilinearFormExtension::MultTranspose(const Vector &x,
-                                                 Vector &y) const
-{
-   y = 0.0;
-   AddMultTranspose(x, y);
-}
-
 void PAMixedBilinearFormExtension::AddMultTranspose(const Vector &x, Vector &y,
                                                     const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // * G operation
-   SetupMultInputs(elem_restrict_test, x, localTest,
-                   elem_restrict_trial, y, localTrial, c);
-
-   // * B^TD^TB operation
-   for (int i = 0; i < iSz; ++i)
-   {
-      integrators[i]->AddMultTransposePA(localTest, localTrial);
-   }
-
-   // * G^T operation
-   if (elem_restrict_trial)
-   {
-      tempY.SetSize(y.Size());
-      elem_restrict_trial->MultTranspose(localTrial, tempY);
-      y += tempY;
-   }
-}
-
-void PAMixedBilinearFormExtension::AssembleDiagonal_ADAt(const Vector &D,
-                                                         Vector &diag) const
-{
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-
-   const int iSz = integrators.Size();
-
-   if (elem_restrict_trial)
+   Array<BilinearFormIntegrator *> &integrators = *a->GetDBFI();
+   if (integrators.Size() > 0)
    {
-      const ElementRestriction* H1elem_restrict_trial =
-         dynamic_cast<const ElementRestriction*>(elem_restrict_trial);
-      if (H1elem_restrict_trial)
+      if (elem_restrict_test)
       {
-         H1elem_restrict_trial->MultUnsigned(D, localTrial);
+         elem_restrict_test->Mult(x, local_test);
       }
-      else
+      if (elem_restrict_trial)
       {
-         elem_restrict_trial->Mult(D, localTrial);
+         local_trial = 0.0;
+         for (BilinearFormIntegrator *integ : integrators)
+         {
+            integ->AddMultTransposePA(elem_restrict_test ? local_test : x,
+                                      local_trial);
+         }
+         if (c != 1.0)
+         {
+            local_trial *= c;
+         }
+         elem_restrict_trial->AddMultTranspose(local_trial, y);
       }
-   }
-
-   if (elem_restrict_test)
-   {
-      localTest = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      else
       {
-         if (elem_restrict_trial)
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(localTrial, localTest);
+            temp_trial.SetSize(y.Size());
+            temp_trial.UseDevice(true);
+            temp_trial = 0.0;
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(elem_restrict_test ? local_test : x,
+                                         temp_trial);
+            }
+            y.Add(c, temp_trial);
          }
          else
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(D, localTest);
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(elem_restrict_test ? local_test : x, y);
+            }
          }
       }
-      const ElementRestriction* H1elem_restrict_test =
-         dynamic_cast<const ElementRestriction*>(elem_restrict_test);
-      if (H1elem_restrict_test)
+   }
+
+   Array<BilinearFormIntegrator *> &bdr_integrators = *a->GetBBFI();
+   if (bdr_integrators.Size() > 0)
+   {
+      if (bdr_face_restrict_lex_test)
       {
-         H1elem_restrict_test->MultTransposeUnsigned(localTest, diag);
+         bdr_face_restrict_lex_test->Mult(x, bdr_face_test);
       }
-      else
+      if (bdr_face_restrict_lex_trial)
       {
-         elem_restrict_test->MultTranspose(localTest, diag);
+         bdr_face_trial = 0.0;
+         for (BilinearFormIntegrator *integ : bdr_integrators)
+         {
+            integ->AddMultTransposePA(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                      bdr_face_trial);
+         }
+         if (c != 1.0)
+         {
+            bdr_face_trial *= c;
+         }
+         bdr_face_restrict_lex_trial->AddMultTranspose(bdr_face_trial, y);
       }
-   }
-   else
-   {
-      diag.UseDevice(true); // typically this is a large vector, so store on device
-      diag = 0.0;
-      for (int i = 0; i < iSz; ++i)
+      else
       {
-         if (elem_restrict_trial)
+         y.UseDevice(true); // typically this is a large vector, so store on device
+         if (c != 1.0)
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(localTrial, diag);
+            temp_trial.SetSize(y.Size());
+            temp_trial.UseDevice(true);
+            temp_trial = 0.0;
+            for (BilinearFormIntegrator *integ : bdr_integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_restrict_lex_test ? bdr_face_test : x,
+                                         temp_trial);
+            }
+            y.Add(c, temp_trial);
          }
          else
          {
-            integrators[i]->AssembleDiagonalPA_ADAt(D, diag);
+            for (BilinearFormIntegrator *integ : integrators)
+            {
+               integ->AddMultTransposePA(bdr_face_restrict_lex_test ? bdr_face_test : x, y);
+            }
          }
       }
    }
 }
 
+/// Data and methods for partially-assembled discrete linear operators
 PADiscreteLinearOperatorExtension::PADiscreteLinearOperatorExtension(
    DiscreteLinearOperator *linop) :
    PAMixedBilinearFormExtension(linop)
 {
 }
 
-const
-Operator *PADiscreteLinearOperatorExtension::GetOutputRestrictionTranspose()
-const
-{
-   return a->GetOutputRestrictionTranspose();
-}
-
 void PADiscreteLinearOperatorExtension::Assemble()
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int integratorCount = integrators.Size();
-   for (int i = 0; i < integratorCount; ++i)
-   {
-      integrators[i]->AssemblePA(*trial_fes, *test_fes);
-   }
+   PAMixedBilinearFormExtension::Assemble();
 
+   // Construct element vdof multiplicity (avoid use of elem_restrict_test
+   // because it might not exist for libCEED)
+   test_multiplicity.SetSize(height);
    test_multiplicity.UseDevice(true);
-   test_multiplicity.SetSize(elem_restrict_test->Width()); // l-vector
-   Vector ones(elem_restrict_test->Height()); // e-vector
-   ones = 1.0;
-
-   const ElementRestriction* elem_restrict =
-      dynamic_cast<const ElementRestriction*>(elem_restrict_test);
-   if (elem_restrict)
-   {
-      elem_restrict->MultTransposeUnsigned(ones, test_multiplicity);
-   }
-   else
-   {
-      mfem_error("A real ElementRestriction is required in this setting!");
+   test_multiplicity = 0.0;
+   Array<int> dofs;
+   for (int i = 0; i < test_fes->GetNE(); i++)
+   {
+      test_fes->GetElementVDofs(i, dofs);
+      const int ndofs = dofs.Size();
+      auto d_mult = test_multiplicity.HostReadWrite();
+      auto d_dofs = dofs.HostRead();
+      mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
+      {
+         const int j = d_dofs[i];
+         d_mult[(j >= 0) ? j : -1 - j] += 1.0;
+      });
    }
-
-   auto tm = test_multiplicity.ReadWrite();
-   mfem::forall(test_multiplicity.Size(), [=] MFEM_HOST_DEVICE (int i)
-   {
-      tm[i] = 1.0 / tm[i];
-   });
+   test_multiplicity.Reciprocal();
 }
 
-void PADiscreteLinearOperatorExtension::AddMult(
-   const Vector &x, Vector &y, const double c) const
+void PADiscreteLinearOperatorExtension::AddMult(const Vector &x, Vector &y,
+                                                const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // * G operation
-   SetupMultInputs(elem_restrict_trial, x, localTrial,
-                   elem_restrict_test, y, localTest, c);
-
-   // * B^TDB operation
-   for (int i = 0; i < iSz; ++i)
+   Array<BilinearFormIntegrator *> &interpolators = *a->GetDBFI();
+   temp_test.SetSize(y.Size());
+   temp_test.UseDevice(true);
+   if (elem_restrict_trial)
    {
-      integrators[i]->AddMultPA(localTrial, localTest);
+      elem_restrict_trial->Mult(x, local_trial);
    }
-
-   // do a kind of "set" rather than "add" in the below
-   // operation as compared to the BilinearForm case
-   // * G^T operation (kind of...)
-   const ElementRestriction* elem_restrict =
-      dynamic_cast<const ElementRestriction*>(elem_restrict_test);
-   if (elem_restrict)
+   if (elem_restrict_test)
    {
-      tempY.SetSize(y.Size());
-      elem_restrict->MultLeftInverse(localTest, tempY);
-      y += tempY;
+      local_test = 0.0;
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultPA(elem_restrict_trial ? local_trial : x, local_test);
+      }
+      elem_restrict_test->MultTranspose(local_test, temp_test);
    }
    else
    {
-      mfem_error("In this setting you need a real ElementRestriction!");
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultPA(elem_restrict_trial ? local_trial : x, temp_test);
+      }
    }
+   temp_test *= test_multiplicity;
+   y.Add(c, temp_test);
 }
 
-void PADiscreteLinearOperatorExtension::AddMultTranspose(
-   const Vector &x, Vector &y, const double c) const
+void PADiscreteLinearOperatorExtension::AddMultTranspose(const Vector &x,
+                                                         Vector &y,
+                                                         const double c) const
 {
-   Array<BilinearFormIntegrator*> &integrators = *a->GetDBFI();
-   const int iSz = integrators.Size();
-
-   // do a kind of "set" rather than "add" in the below
-   // operation as compared to the BilinearForm case
-   // * G operation (kinda)
-   Vector xscaled(x);
-   MFEM_VERIFY(x.Size() == test_multiplicity.Size(), "Input vector of wrong size");
-   auto xs = xscaled.ReadWrite();
-   auto tm = test_multiplicity.Read();
-   mfem::forall(x.Size(), [=] MFEM_HOST_DEVICE (int i)
-   {
-      xs[i] *= tm[i];
-   });
-   SetupMultInputs(elem_restrict_test, xscaled, localTest,
-                   elem_restrict_trial, y, localTrial, c);
-
-   // * B^TD^TB operation
-   for (int i = 0; i < iSz; ++i)
+   Array<BilinearFormIntegrator *> &interpolators = *a->GetDBFI();
+   temp_test = x;
+   temp_test *= test_multiplicity;
+   if (elem_restrict_test)
    {
-      integrators[i]->AddMultTransposePA(localTest, localTrial);
+      elem_restrict_test->Mult(temp_test, local_test);
    }
-
-   // * G^T operation
    if (elem_restrict_trial)
    {
-      tempY.SetSize(y.Size());
-      elem_restrict_trial->MultTranspose(localTrial, tempY);
-      y += tempY;
+      local_trial = 0.0;
+      for (BilinearFormIntegrator *interp : interpolators)
+      {
+         interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test,
+                                    local_trial);
+      }
+      if (c != 1.0)
+      {
+         local_trial *= c;
+      }
+      elem_restrict_trial->AddMultTranspose(local_trial, y);
    }
    else
    {
-      mfem_error("Trial ElementRestriction not defined");
+      y.UseDevice(true); // typically this is a large vector, so store on device
+      if (c != 1.0)
+      {
+         MFEM_ABORT("General coefficient case for PADiscreteLinearOperatorExtension::"
+                    "AddMultTranspose is not yet supported!");
+      }
+      else
+      {
+         for (BilinearFormIntegrator *interp : interpolators)
+         {
+            interp->AddMultTransposePA(elem_restrict_test ? local_test : temp_test, y);
+         }
+      }
    }
 }
 
-void PADiscreteLinearOperatorExtension::FormRectangularSystemOperator(
-   const Array<int>& ess1, const Array<int>& ess2, OperatorHandle &A)
-{
-   const Operator *Pi = this->GetProlongation();
-   const Operator *RoT = this->GetOutputRestrictionTranspose();
-   Operator *rap = SetupRAP(Pi, RoT);
-
-   RectangularConstrainedOperator *Arco
-      = new RectangularConstrainedOperator(rap, ess1, ess2, rap != this);
-
-   A.Reset(Arco);
-}
-
 } // namespace mfem
diff --git a/fem/bilinearform_ext.hpp b/fem/bilinearform_ext.hpp
index ef54dc71c..db26eb801 100644
--- a/fem/bilinearform_ext.hpp
+++ b/fem/bilinearform_ext.hpp
@@ -25,8 +25,8 @@ class DiscreteLinearOperator;
 
 /// Class extending the BilinearForm class to support different AssemblyLevels.
 /**  FA - Full Assembly
-     PA - Partial Assembly
      EA - Element Assembly
+     PA - Partial Assembly
      MF - Matrix Free
 */
 class BilinearFormExtension : public Operator
@@ -54,57 +54,59 @@ public:
       MFEM_ABORT("AssembleDiagonal not implemented for this assembly level!");
    }
 
-   virtual void FormSystemMatrix(const Array<int> &ess_tdof_list,
-                                 OperatorHandle &A) = 0;
-   virtual void FormLinearSystem(const Array<int> &ess_tdof_list,
-                                 Vector &x, Vector &b,
-                                 OperatorHandle &A, Vector &X, Vector &B,
-                                 int copy_interior = 0) = 0;
    virtual void Update() = 0;
 };
 
-/// Data and methods for partially-assembled bilinear forms
-class PABilinearFormExtension : public BilinearFormExtension
+/// Data and methods for matrix-free bilinear forms
+class MFBilinearFormExtension : public BilinearFormExtension
 {
 protected:
-   const FiniteElementSpace *trial_fes, *test_fes; // Not owned
-   mutable Vector localX, localY;
-   mutable Vector int_face_X, int_face_Y;
-   mutable Vector bdr_face_X, bdr_face_Y;
-   const Operator *elem_restrict; // Not owned
+   const FiniteElementSpace *fes; // Not owned
+   mutable Vector local_x, local_y, temp_y;
+   mutable Vector int_face_x, int_face_y;
+   mutable Vector bdr_face_x, bdr_face_y;
+   const ElementRestriction *elem_restrict; // Not owned
    const FaceRestriction *int_face_restrict_lex; // Not owned
    const FaceRestriction *bdr_face_restrict_lex; // Not owned
 
 public:
-   PABilinearFormExtension(BilinearForm*);
+   MFBilinearFormExtension(BilinearForm *form);
 
    void Assemble();
    void AssembleDiagonal(Vector &diag) const;
-   void FormSystemMatrix(const Array<int> &ess_tdof_list, OperatorHandle &A);
-   void FormLinearSystem(const Array<int> &ess_tdof_list,
-                         Vector &x, Vector &b,
-                         OperatorHandle &A, Vector &X, Vector &B,
-                         int copy_interior = 0);
    void Mult(const Vector &x, Vector &y) const;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
    void MultTranspose(const Vector &x, Vector &y) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
    void Update();
 
 protected:
    void SetupRestrictionOperators(const L2FaceValues m);
 };
 
+/// Data and methods for partially-assembled bilinear forms
+class PABilinearFormExtension : public MFBilinearFormExtension
+{
+public:
+   PABilinearFormExtension(BilinearForm *form);
+
+   void Assemble();
+   void AssembleDiagonal(Vector &diag) const;
+   void Mult(const Vector &x, Vector &y) const;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
+   void MultTranspose(const Vector &x, Vector &y) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
+};
+
 /// Data and methods for element-assembled bilinear forms
 class EABilinearFormExtension : public PABilinearFormExtension
 {
 protected:
-   int ne;
-   int elemDofs;
-   // The element matrices are stored row major
-   Vector ea_data;
-   int nf_int, nf_bdr;
-   int faceDofs;
+   const bool factorize_face_terms;
+   int ne, elem_dofs;
+   Vector ea_data;  // The element matrices are stored row major
+   int nf_int, nf_bdr, face_dofs;
    Vector ea_data_int, ea_data_ext, ea_data_bdr;
-   bool factorize_face_terms;
 
 public:
    EABilinearFormExtension(BilinearForm *form);
@@ -125,15 +127,6 @@ public:
    FABilinearFormExtension(BilinearForm *form);
 
    void Assemble();
-   void RAP(OperatorHandle &A);
-   /** @note Always does `DIAG_ONE` policy to be consistent with
-       `Operator::FormConstrainedSystemOperator`. */
-   void EliminateBC(const Array<int> &ess_dofs, OperatorHandle &A);
-   void FormSystemMatrix(const Array<int> &ess_tdof_list, OperatorHandle &A);
-   void FormLinearSystem(const Array<int> &ess_tdof_list,
-                         Vector &x, Vector &b,
-                         OperatorHandle &A, Vector &X, Vector &B,
-                         int copy_interior = 0);
    void Mult(const Vector &x, Vector &y) const;
    void MultTranspose(const Vector &x, Vector &y) const;
 
@@ -143,37 +136,10 @@ public:
    void DGMultTranspose(const Vector &x, Vector &y) const;
 };
 
-/// Data and methods for matrix-free bilinear forms
-class MFBilinearFormExtension : public BilinearFormExtension
-{
-protected:
-   const FiniteElementSpace *trial_fes, *test_fes; // Not owned
-   mutable Vector localX, localY;
-   mutable Vector int_face_X, int_face_Y;
-   mutable Vector bdr_face_X, bdr_face_Y;
-   const Operator *elem_restrict; // Not owned
-   const FaceRestriction *int_face_restrict_lex; // Not owned
-   const FaceRestriction *bdr_face_restrict_lex; // Not owned
-
-public:
-   MFBilinearFormExtension(BilinearForm *form);
-
-   void Assemble();
-   void AssembleDiagonal(Vector &diag) const;
-   void FormSystemMatrix(const Array<int> &ess_tdof_list, OperatorHandle &A);
-   void FormLinearSystem(const Array<int> &ess_tdof_list,
-                         Vector &x, Vector &b,
-                         OperatorHandle &A, Vector &X, Vector &B,
-                         int copy_interior = 0);
-   void Mult(const Vector &x, Vector &y) const;
-   void MultTranspose(const Vector &x, Vector &y) const;
-   void Update();
-};
-
 /// Class extending the MixedBilinearForm class to support different AssemblyLevels.
 /**  FA - Full Assembly
-     PA - Partial Assembly
      EA - Element Assembly
+     PA - Partial Assembly
      MF - Matrix Free
 */
 class MixedBilinearFormExtension : public Operator
@@ -185,7 +151,7 @@ public:
    MixedBilinearFormExtension(MixedBilinearForm *form);
 
    virtual MemoryClass GetMemoryClass() const
-   { return Device::GetMemoryClass(); }
+   { return Device::GetDeviceMemoryClass(); }
 
    /// Get the finite element space prolongation matrix
    virtual const Operator *GetProlongation() const;
@@ -199,101 +165,70 @@ public:
    /// Get the output finite element space restriction matrix
    virtual const Operator *GetOutputRestriction() const;
 
+   /// Assemble at the level given for the BilinearFormExtension subclass
    virtual void Assemble() = 0;
-   virtual void FormRectangularSystemOperator(const Array<int> &trial_tdof_list,
-                                              const Array<int> &test_tdof_list,
-                                              OperatorHandle &A) = 0;
-   virtual void FormRectangularLinearSystem(const Array<int> &trial_tdof_list,
-                                            const Array<int> &test_tdof_list,
-                                            Vector &x, Vector &b,
-                                            OperatorHandle &A, Vector &X, Vector &B) = 0;
 
-   virtual void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const = 0;
+   virtual void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const
+   {
+      MFEM_ABORT("AssembleDiagonal_ADAt not implemented for this assembly level!");
+   }
 
    virtual void Update() = 0;
 };
 
-/// Data and methods for partially-assembled mixed bilinear forms
-class PAMixedBilinearFormExtension : public MixedBilinearFormExtension
+/// Data and methods for matrix-free mixed bilinear forms
+class MFMixedBilinearFormExtension : public MixedBilinearFormExtension
 {
 protected:
    const FiniteElementSpace *trial_fes, *test_fes; // Not owned
-   mutable Vector localTrial, localTest, tempY;
-   const Operator *elem_restrict_trial; // Not owned
-   const Operator *elem_restrict_test;  // Not owned
-
-   /// Helper function to set up inputs/outputs for Mult or MultTranspose
-   void SetupMultInputs(const Operator *elem_restrict_x,
-                        const Vector &x, Vector &localX,
-                        const Operator *elem_restrict_y,
-                        Vector &y, Vector &localY, const double c) const;
+   mutable Vector local_trial, local_test, temp_trial, temp_test;
+   mutable Vector int_face_trial, int_face_test, int_face_y;
+   mutable Vector bdr_face_trial, bdr_face_test, bdr_face_y;
+   const ElementRestriction *elem_restrict_trial; // Not owned
+   const ElementRestriction *elem_restrict_test;  // Not owned
+   const FaceRestriction *int_face_restrict_lex_trial; // Not owned
+   const FaceRestriction *int_face_restrict_lex_test;  // Not owned
+   const FaceRestriction *bdr_face_restrict_lex_trial; // Not owned
+   const FaceRestriction *bdr_face_restrict_lex_test;  // Not owned
 
 public:
-   PAMixedBilinearFormExtension(MixedBilinearForm *form);
+   MFMixedBilinearFormExtension(MixedBilinearForm *form);
 
-   /// Partial assembly of all internal integrators
    void Assemble();
-   /**
-      @brief Setup OperatorHandle A to contain constrained linear operator
-
-      OperatorHandle A contains matrix-free constrained operator formed for RAP
-      system where ess_tdof_list are in trial space and eliminated from
-      "columns" of A.
-   */
-   void FormRectangularSystemOperator(const Array<int> &trial_tdof_list,
-                                      const Array<int> &test_tdof_list,
-                                      OperatorHandle &A);
-   /**
-      Setup OperatorHandle A to contain constrained linear operator and
-      eliminate columns corresponding to essential dofs from system,
-      updating RHS B vector with the results.
-   */
-   void FormRectangularLinearSystem(const Array<int> &trial_tdof_list,
-                                    const Array<int> &test_tdof_list,
-                                    Vector &x, Vector &b,
-                                    OperatorHandle &A, Vector &X, Vector &B);
-   /// y = A*x
    void Mult(const Vector &x, Vector &y) const;
-   /// y += c*A*x
-   void AddMult(const Vector &x, Vector &y, const double c=1.0) const;
-   /// y = A^T*x
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
    void MultTranspose(const Vector &x, Vector &y) const;
-   /// y += c*A^T*x
-   void AddMultTranspose(const Vector &x, Vector &y, const double c=1.0) const;
-   /// Assemble the diagonal of ADA^T for a diagonal vector D.
-   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
-
-   /// Update internals for when a new MixedBilinearForm is given to this class
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
    void Update();
+
+protected:
+   void SetupRestrictionOperators(const L2FaceValues m);
 };
 
+/// Data and methods for partially-assembled mixed bilinear forms
+class PAMixedBilinearFormExtension : public MFMixedBilinearFormExtension
+{
+public:
+   PAMixedBilinearFormExtension(MixedBilinearForm *form);
 
-/**
-   @brief Partial assembly extension for DiscreteLinearOperator
+   void Assemble();
+   void AssembleDiagonal_ADAt(const Vector &D, Vector &diag) const;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
+};
 
-   This acts very much like PAMixedBilinearFormExtension, but its
-   FormRectangularSystemOperator implementation emulates 'Set' rather than
-   'Add' in the assembly case.
-*/
+/// Data and methods for partially-assembled discrete linear operators
 class PADiscreteLinearOperatorExtension : public PAMixedBilinearFormExtension
 {
+private:
+   Vector test_multiplicity;
+
 public:
    PADiscreteLinearOperatorExtension(DiscreteLinearOperator *linop);
 
-   /// Partial assembly of all internal integrators
    void Assemble();
-
-   void AddMult(const Vector &x, Vector &y, const double c=1.0) const;
-
-   void AddMultTranspose(const Vector &x, Vector &y, const double c=1.0) const;
-
-   void FormRectangularSystemOperator(const Array<int>&, const Array<int>&,
-                                      OperatorHandle& A);
-
-   const Operator * GetOutputRestrictionTranspose() const;
-
-private:
-   Vector test_multiplicity;
+   void AddMult(const Vector &x, Vector &y, const double c = 1.0) const;
+   void AddMultTranspose(const Vector &x, Vector &y, const double c = 1.0) const;
 };
 
 }
diff --git a/fem/bilininteg.cpp b/fem/bilininteg.cpp
index cd7570c69..e6fc2a6ee 100644
--- a/fem/bilininteg.cpp
+++ b/fem/bilininteg.cpp
@@ -39,110 +39,140 @@ void BilinearFormIntegrator::AssemblePABoundary(const FiniteElementSpace&)
               "   is not implemented for this class.");
 }
 
+void BilinearFormIntegrator::AssemblePABoundary(const FiniteElementSpace&,
+                                                const FiniteElementSpace&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePABoundary(fes, fes)\n"
+              "   is not implemented for this class.");
+}
+
 void BilinearFormIntegrator::AssemblePAInteriorFaces(const FiniteElementSpace&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssemblePAInteriorFaces(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePAInteriorFaces(fes)\n"
               "   is not implemented for this class.");
 }
 
 void BilinearFormIntegrator::AssemblePABoundaryFaces(const FiniteElementSpace&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssemblePABoundaryFaces(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssemblePABoundaryFaces(fes)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleDiagonalPA(Vector &)
+void BilinearFormIntegrator::AssembleDiagonalPA(Vector&)
 {
    MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalPA(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                        Vector &emat,
-                                        const bool add)
+void BilinearFormIntegrator::AssembleDiagonalPA_ADAt(const Vector&, Vector&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssembleEA(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalPA_ADAt(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace
-                                                     &fes,
-                                                     Vector &ea_data_int,
-                                                     Vector &ea_data_ext,
-                                                     const bool add)
+void BilinearFormIntegrator::AddMultPA(const Vector&, Vector&) const
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssembleEAInteriorFaces(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::MultAssembled(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace
-                                                     &fes,
-                                                     Vector &ea_data_bdr,
-                                                     const bool add)
+void BilinearFormIntegrator::AddMultTransposePA(const Vector&, Vector&) const
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssembleEABoundaryFaces(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AddMultTransposePA(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleDiagonalPA_ADAt(const Vector &, Vector &)
+void BilinearFormIntegrator::AssembleMF(const FiniteElementSpace&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalPA_ADAt(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMF(fes)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultPA(const Vector &, Vector &) const
+void BilinearFormIntegrator::AssembleMF(const FiniteElementSpace&,
+                                        const FiniteElementSpace&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::MultAssembled(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMF(fes, fes)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultTransposePA(const Vector &, Vector &) const
+void BilinearFormIntegrator::AssembleMFBoundary(const FiniteElementSpace&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AddMultTransposePA(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMFBoundary(fes)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssembleMFBoundary(const FiniteElementSpace&,
+                                                const FiniteElementSpace&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssembleMFBoundary(fes, fes)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleMF(const FiniteElementSpace &fes)
+void BilinearFormIntegrator::AssembleDiagonalMF(Vector&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssembleMF(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalMF(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultMF(const Vector &, Vector &) const
+void BilinearFormIntegrator::AddMultMF(const Vector&, Vector&) const
 {
    MFEM_ABORT("BilinearFormIntegrator::AddMultMF(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AddMultTransposeMF(const Vector &, Vector &) const
+void BilinearFormIntegrator::AddMultTransposeMF(const Vector&, Vector&) const
 {
    MFEM_ABORT("BilinearFormIntegrator::AddMultTransposeMF(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleDiagonalMF(Vector &)
+void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace&,
+                                        Vector&)
 {
-   MFEM_ABORT("BilinearFormIntegrator::AssembleDiagonalMF(...)\n"
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEA(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleElementMatrix (
+void BilinearFormIntegrator::AssembleEA(const FiniteElementSpace&,
+                                        const FiniteElementSpace&,
+                                        Vector&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEA(...)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &,
+                                                     Vector&,
+                                                     Vector&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEAInteriorFaces(...)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace&,
+                                                     Vector&)
+{
+   MFEM_ABORT("BilinearFormIntegrator::AssembleEABoundaryFaces(...)\n"
+              "   is not implemented for this class.");
+}
+
+void BilinearFormIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans,
-   DenseMatrix &elmat )
+   DenseMatrix &elmat)
 {
    MFEM_ABORT("BilinearFormIntegrator::AssembleElementMatrix(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleElementMatrix2 (
+void BilinearFormIntegrator::AssembleElementMatrix2(
    const FiniteElement &el1, const FiniteElement &el2,
-   ElementTransformation &Trans, DenseMatrix &elmat )
+   ElementTransformation &Trans, DenseMatrix &elmat)
 {
    MFEM_ABORT("BilinearFormIntegrator::AssembleElementMatrix2(...)\n"
               "   is not implemented for this class.");
 }
 
-void BilinearFormIntegrator::AssembleFaceMatrix (
+void BilinearFormIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
 {
@@ -197,30 +227,30 @@ void TransposeIntegrator::SetIntRule(const IntegrationRule *ir)
    bfi->SetIntRule(ir);
 }
 
-void TransposeIntegrator::AssembleElementMatrix (
+void TransposeIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleElementMatrix (el, Trans, bfi_elmat);
+   bfi->AssembleElementMatrix(el, Trans, bfi_elmat);
    // elmat = bfi_elmat^t
-   elmat.Transpose (bfi_elmat);
+   elmat.Transpose(bfi_elmat);
 }
 
-void TransposeIntegrator::AssembleElementMatrix2 (
+void TransposeIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleElementMatrix2 (test_fe, trial_fe, Trans, bfi_elmat);
+   bfi->AssembleElementMatrix2(test_fe, trial_fe, Trans, bfi_elmat);
    // elmat = bfi_elmat^t
-   elmat.Transpose (bfi_elmat);
+   elmat.Transpose(bfi_elmat);
 }
 
-void TransposeIntegrator::AssembleFaceMatrix (
+void TransposeIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleFaceMatrix (el1, el2, Trans, bfi_elmat);
+   bfi->AssembleFaceMatrix(el1, el2, Trans, bfi_elmat);
    // elmat = bfi_elmat^t
-   elmat.Transpose (bfi_elmat);
+   elmat.Transpose(bfi_elmat);
 }
 
 void LumpedIntegrator::SetIntRule(const IntegrationRule *ir)
@@ -229,10 +259,10 @@ void LumpedIntegrator::SetIntRule(const IntegrationRule *ir)
    bfi->SetIntRule(ir);
 }
 
-void LumpedIntegrator::AssembleElementMatrix (
+void LumpedIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
-   bfi -> AssembleElementMatrix (el, Trans, elmat);
+   bfi->AssembleElementMatrix(el, Trans, elmat);
    elmat.Lump();
 }
 
@@ -322,6 +352,15 @@ void SumIntegrator::AssemblePA(const FiniteElementSpace& fes)
    }
 }
 
+void SumIntegrator::AssemblePA(const FiniteElementSpace& trial_fes,
+                               const FiniteElementSpace& test_fes)
+{
+   for (int i = 0; i < integrators.Size(); i++)
+   {
+      integrators[i]->AssemblePA(trial_fes, test_fes);
+   }
+}
+
 void SumIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    for (int i = 0; i < integrators.Size(); i++)
@@ -370,57 +409,63 @@ void SumIntegrator::AssembleMF(const FiniteElementSpace &fes)
    }
 }
 
-void SumIntegrator::AddMultMF(const Vector& x, Vector& y) const
+void SumIntegrator::AssembleMF(const FiniteElementSpace& trial_fes,
+                               const FiniteElementSpace& test_fes)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AddMultTransposeMF(x, y);
+      integrators[i]->AssembleMF(trial_fes, test_fes);
    }
 }
 
-void SumIntegrator::AddMultTransposeMF(const Vector &x, Vector &y) const
+void SumIntegrator::AssembleDiagonalMF(Vector &diag)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AddMultMF(x, y);
+      integrators[i]->AssembleDiagonalMF(diag);
    }
 }
 
-void SumIntegrator::AssembleDiagonalMF(Vector &diag)
+void SumIntegrator::AddMultMF(const Vector& x, Vector& y) const
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleDiagonalMF(diag);
+      integrators[i]->AddMultTransposeMF(x, y);
+   }
+}
+
+void SumIntegrator::AddMultTransposeMF(const Vector &x, Vector &y) const
+{
+   for (int i = 0; i < integrators.Size(); i++)
+   {
+      integrators[i]->AddMultMF(x, y);
    }
 }
 
-void SumIntegrator::AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                               const bool add)
+void SumIntegrator::AssembleEA(const FiniteElementSpace &fes, Vector &emat)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleEA(fes, emat, add);
+      integrators[i]->AssembleEA(fes, emat);
    }
 }
 
 void SumIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                             Vector &ea_data_int,
-                                            Vector &ea_data_ext,
-                                            const bool add)
+                                            Vector &ea_data_ext)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleEAInteriorFaces(fes,ea_data_int,ea_data_ext,add);
+      integrators[i]->AssembleEAInteriorFaces(fes, ea_data_int, ea_data_ext);
    }
 }
 
 void SumIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                            Vector &ea_data_bdr,
-                                            const bool add)
+                                            Vector &ea_data_bdr)
 {
    for (int i = 0; i < integrators.Size(); i++)
    {
-      integrators[i]->AssembleEABoundaryFaces(fes, ea_data_bdr, add);
+      integrators[i]->AssembleEABoundaryFaces(fes, ea_data_bdr);
    }
 }
 
@@ -648,15 +693,15 @@ void MixedVectorIntegrator::AssembleElementMatrix2(
       {
          if (Q)
          {
-            w *= Q -> Eval (Trans, ip);
+            w *= Q->Eval(Trans, ip);
          }
          if (same_shapes)
          {
-            AddMult_a_AAt (w, test_shape, elmat);
+            AddMult_a_AAt(w, test_shape, elmat);
          }
          else
          {
-            AddMult_a_ABt (w, test_shape, trial_shape, elmat);
+            AddMult_a_ABt(w, test_shape, trial_shape, elmat);
          }
       }
    }
@@ -730,7 +775,7 @@ void MixedScalarVectorIntegrator::AssembleElementMatrix2(
       VQ->Eval(V, Trans, ip);
       V *= w;
 
-      if ( vdim == 2 && cross_2d )
+      if (vdim == 2 && cross_2d)
       {
          vtmp = V[0];
          V[0] = -V[1];
@@ -742,7 +787,6 @@ void MixedScalarVectorIntegrator::AssembleElementMatrix2(
    }
 }
 
-
 void GradientIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe, const FiniteElement &test_fe,
    ElementTransformation &Trans,  DenseMatrix &elmat)
@@ -799,19 +843,18 @@ void GradientIntegrator::AssembleElementMatrix2(
    }
 }
 
-const IntegrationRule &GradientIntegrator::GetRule(const FiniteElement
-                                                   &trial_fe,
-                                                   const FiniteElement &test_fe,
-                                                   ElementTransformation &Trans)
+const IntegrationRule &GradientIntegrator::GetRule(
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe,
+   ElementTransformation &Trans)
 {
    int order = Trans.OrderGrad(&trial_fe) + test_fe.GetOrder() + Trans.OrderJ();
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
-void DiffusionIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void DiffusionIntegrator::AssembleElementMatrix(
+   const FiniteElement &el, ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    dim = el.GetDim();
@@ -1050,10 +1093,14 @@ void DiffusionIntegrator::AssembleElementVector(
    }
 }
 
-void DiffusionIntegrator::ComputeElementFlux
-( const FiniteElement &el, ElementTransformation &Trans,
-  Vector &u, const FiniteElement &fluxelem, Vector &flux, bool with_coef,
-  const IntegrationRule *ir)
+void DiffusionIntegrator::ComputeElementFlux(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   Vector &u,
+   const FiniteElement &fluxelem,
+   Vector &flux,
+   bool with_coef,
+   const IntegrationRule *ir)
 {
    int nd, spaceDim, fnd;
 
@@ -1093,7 +1140,7 @@ void DiffusionIntegrator::ComputeElementFlux
       ir = &fluxelem.GetNodes();
    }
    fnd = ir->GetNPoints();
-   flux.SetSize( fnd * spaceDim );
+   flux.SetSize(fnd * spaceDim);
 
    for (int i = 0; i < fnd; i++)
    {
@@ -1101,7 +1148,7 @@ void DiffusionIntegrator::ComputeElementFlux
       el.CalcDShape(ip, dshape);
       dshape.MultTranspose(u, vec);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       CalcInverse(Trans.Jacobian(), invdfdx);
       invdfdx.MultTranspose(vec, vecdxt);
 
@@ -1149,9 +1196,11 @@ void DiffusionIntegrator::ComputeElementFlux
    }
 }
 
-double DiffusionIntegrator::ComputeFluxEnergy
-( const FiniteElement &fluxelem, ElementTransformation &Trans,
-  Vector &flux, Vector* d_energy)
+double DiffusionIntegrator::ComputeFluxEnergy(
+   const FiniteElement &fluxelem,
+   ElementTransformation &Trans,
+   Vector &flux,
+   Vector* d_energy)
 {
    int nd = fluxelem.GetDof();
    dim = fluxelem.GetDim();
@@ -1226,7 +1275,8 @@ double DiffusionIntegrator::ComputeFluxEnergy
 }
 
 const IntegrationRule &DiffusionIntegrator::GetRule(
-   const FiniteElement &trial_fe, const FiniteElement &test_fe)
+   const FiniteElement &trial_fe,
+   const FiniteElement &test_fe)
 {
    int order;
    if (trial_fe.Space() == FunctionSpace::Pk)
@@ -1238,7 +1288,6 @@ const IntegrationRule &DiffusionIntegrator::GetRule(
       // order = 2*el.GetOrder() - 2;  // <-- this seems to work fine too
       order = trial_fe.GetOrder() + test_fe.GetOrder() + trial_fe.GetDim() - 1;
    }
-
    if (trial_fe.Space() == FunctionSpace::rQk)
    {
       return RefinedIntRules.Get(trial_fe.GetGeomType(), order);
@@ -1246,10 +1295,10 @@ const IntegrationRule &DiffusionIntegrator::GetRule(
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
-void MassIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void MassIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    // int dim = el.GetDim();
@@ -1258,8 +1307,8 @@ void MassIntegrator::AssembleElementMatrix
 #ifdef MFEM_THREAD_SAFE
    Vector shape;
 #endif
-   elmat.SetSize(nd);
    shape.SetSize(nd);
+   elmat.SetSize(nd);
 
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(el, el, Trans);
 
@@ -1267,14 +1316,14 @@ void MassIntegrator::AssembleElementMatrix
    for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
 
       el.CalcPhysShape(Trans, shape);
 
       w = Trans.Weight() * ip.weight;
       if (Q)
       {
-         w *= Q -> Eval(Trans, ip);
+         w *= Q->Eval(Trans, ip);
       }
 
       AddMult_a_VVt(w, shape, elmat);
@@ -1306,11 +1355,11 @@ void MassIntegrator::AssembleElementMatrix2(
       trial_fe.CalcShape(ip, shape);
       test_fe.CalcShape(ip, te_shape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       w = Trans.Weight() * ip.weight;
       if (Q)
       {
-         w *= Q -> Eval(Trans, ip);
+         w *= Q->Eval(Trans, ip);
       }
 
       te_shape *= w;
@@ -1332,7 +1381,6 @@ const IntegrationRule &MassIntegrator::GetRule(const FiniteElement &trial_fe,
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
 void BoundaryMassIntegrator::AssembleFaceMatrix(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Trans, DenseMatrix &elmat)
@@ -1372,7 +1420,7 @@ void BoundaryMassIntegrator::AssembleFaceMatrix(
       w = Trans.Weight() * ip.weight;
       if (Q)
       {
-         w *= Q -> Eval(Trans, ip);
+         w *= Q->Eval(Trans, ip);
       }
 
       AddMult_a_VVt(w, shape, elmat);
@@ -1426,9 +1474,18 @@ void ConvectionIntegrator::AssembleElementMatrix(
    }
 }
 
+const IntegrationRule &ConvectionIntegrator::GetRule(
+   const FiniteElement &fe,
+   ElementTransformation &Trans)
+{
+   int order = Trans.OrderGrad(&fe) + Trans.Order() + fe.GetOrder();
+   return IntRules.Get(fe.GetGeomType(), order);
+}
 
 void GroupConvectionIntegrator::AssembleElementMatrix(
-   const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    int dim = el.GetDim();
@@ -1479,24 +1536,10 @@ void GroupConvectionIntegrator::AssembleElementMatrix(
    }
 }
 
-const IntegrationRule &ConvectionIntegrator::GetRule(
-   const FiniteElement &trial_fe, const FiniteElement &test_fe,
-   ElementTransformation &Trans)
-{
-   int order = Trans.OrderGrad(&trial_fe) + Trans.Order() + test_fe.GetOrder();
-
-   return IntRules.Get(trial_fe.GetGeomType(), order);
-}
-
-const IntegrationRule &ConvectionIntegrator::GetRule(
-   const FiniteElement &el, ElementTransformation &Trans)
-{
-   return GetRule(el,el,Trans);
-}
-
-void VectorMassIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void VectorMassIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    int spaceDim = Trans.GetSpaceDim();
@@ -1539,7 +1582,7 @@ void VectorMassIntegrator::AssembleElementMatrix
       const IntegrationPoint &ip = ir->IntPoint(s);
       el.CalcShape(ip, shape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       norm = ip.weight * Trans.Weight();
 
       MultVVt(shape, partelmat);
@@ -1796,7 +1839,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
                "At least one of the finite elements must be in H(Curl)");
 
    int curl_nd, vec_nd;
-   if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+   if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
    {
       curl_nd = trial_nd;
       vec_nd  = test_nd;
@@ -1835,7 +1878,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
       Trans.SetIntPoint(&ip);
       if (dim == 3)
       {
-         if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+         if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
          {
             trial_fe.CalcCurlShape(ip, curlshapeTrial);
             test_fe.CalcVShape(Trans, vshapeTest);
@@ -1849,7 +1892,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
       }
       else
       {
-         if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+         if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
          {
             trial_fe.CalcCurlShape(ip, curlshapeTrial_dFT);
             test_fe.CalcShape(ip, shapeTest);
@@ -1869,7 +1912,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
       }
       // Note: shapeTest points to the same data as vshapeTest
       vshapeTest *= w;
-      if ( trial_fe.GetMapType() == mfem::FiniteElement::H_CURL )
+      if (trial_fe.GetMapType() == mfem::FiniteElement::H_CURL)
       {
          AddMultABt(vshapeTest, curlshapeTrial_dFT, elmat);
       }
@@ -1880,7 +1923,7 @@ void VectorFECurlIntegrator::AssembleElementMatrix2(
    }
 }
 
-void DerivativeIntegrator::AssembleElementMatrix2 (
+void DerivativeIntegrator::AssembleElementMatrix2(
    const FiniteElement &trial_fe,
    const FiniteElement &test_fe,
    ElementTransformation &Trans,
@@ -1894,12 +1937,12 @@ void DerivativeIntegrator::AssembleElementMatrix2 (
    int i, l;
    double det;
 
-   elmat.SetSize (test_nd,trial_nd);
-   dshape.SetSize (trial_nd,dim);
+   elmat.SetSize(test_nd,trial_nd);
+   dshape.SetSize(trial_nd,dim);
    dshapedxt.SetSize(trial_nd, spaceDim);
    dshapedxi.SetSize(trial_nd);
    invdfdx.SetSize(dim, spaceDim);
-   shape.SetSize (test_nd);
+   shape.SetSize(test_nd);
 
    const IntegrationRule *ir = IntRule;
    if (ir == NULL)
@@ -1931,10 +1974,10 @@ void DerivativeIntegrator::AssembleElementMatrix2 (
 
       trial_fe.CalcDShape(ip, dshape);
 
-      Trans.SetIntPoint (&ip);
-      CalcInverse (Trans.Jacobian(), invdfdx);
+      Trans.SetIntPoint(&ip);
+      CalcInverse(Trans.Jacobian(), invdfdx);
       det = Trans.Weight();
-      Mult (dshape, invdfdx, dshapedxt);
+      Mult(dshape, invdfdx, dshapedxt);
 
       test_fe.CalcShape(ip, shape);
 
@@ -1944,13 +1987,14 @@ void DerivativeIntegrator::AssembleElementMatrix2 (
       }
 
       shape *= Q->Eval(Trans,ip) * det * ip.weight;
-      AddMultVWt (shape, dshapedxi, elmat);
+      AddMultVWt(shape, dshapedxi, elmat);
    }
 }
 
-void CurlCurlIntegrator::AssembleElementMatrix
-( const FiniteElement &el, ElementTransformation &Trans,
-  DenseMatrix &elmat )
+void CurlCurlIntegrator::AssembleElementMatrix(
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int nd = el.GetDof();
    dim = el.GetDim();
@@ -1965,6 +2009,7 @@ void CurlCurlIntegrator::AssembleElementMatrix
    curlshape_dFt.SetSize(nd,dimc);
 #endif
    elmat.SetSize(nd);
+
    if (MQ) { M.SetSize(dimc); }
    if (DQ) { D.SetSize(dimc); }
 
@@ -1989,7 +2034,7 @@ void CurlCurlIntegrator::AssembleElementMatrix
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
 
       w = ip.weight * Trans.Weight();
       el.CalcPhysCurlShape(Trans, curlshape_dFt);
@@ -2096,10 +2141,10 @@ void CurlCurlIntegrator::AssembleElementMatrix2(const FiniteElement &trial_fe,
    }
 }
 
-void CurlCurlIntegrator
-::ComputeElementFlux(const FiniteElement &el, ElementTransformation &Trans,
-                     Vector &u, const FiniteElement &fluxelem, Vector &flux,
-                     bool with_coef, const IntegrationRule *ir)
+void CurlCurlIntegrator::ComputeElementFlux(
+   const FiniteElement &el, ElementTransformation &Trans,
+   Vector &u, const FiniteElement &fluxelem, Vector &flux,
+   bool with_coef, const IntegrationRule *ir)
 {
 #ifdef MFEM_THREAD_SAFE
    DenseMatrix projcurl;
@@ -2221,7 +2266,9 @@ double CurlCurlIntegrator::ComputeFluxEnergy(const FiniteElement &fluxelem,
 }
 
 void VectorCurlCurlIntegrator::AssembleElementMatrix(
-   const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
+   const FiniteElement &el,
+   ElementTransformation &Trans,
+   DenseMatrix &elmat)
 {
    int dim = el.GetDim();
    int dof = el.GetDof();
@@ -2411,7 +2458,6 @@ void MixedCurlIntegrator::AssembleElementMatrix2(
    }
 }
 
-
 void VectorFEMassIntegrator::AssembleElementMatrix(
    const FiniteElement &el,
    ElementTransformation &Trans,
@@ -2449,7 +2495,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix(
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
 
       el.CalcVShape(Trans, trial_vshape);
 
@@ -2471,9 +2517,9 @@ void VectorFEMassIntegrator::AssembleElementMatrix(
       {
          if (Q)
          {
-            w *= Q -> Eval (Trans, ip);
+            w *= Q->Eval (Trans, ip);
          }
-         AddMult_a_AAt (w, trial_vshape, elmat);
+         AddMult_a_AAt(w, trial_vshape, elmat);
       }
    }
 }
@@ -2518,7 +2564,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
       {
          const IntegrationPoint &ip = ir->IntPoint(i);
 
-         Trans.SetIntPoint (&ip);
+         Trans.SetIntPoint(&ip);
 
          trial_fe.CalcVShape(Trans, trial_vshape);
          test_fe.CalcShape(ip, shape);
@@ -2604,7 +2650,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
 #endif
       DenseMatrix tmp(test_vshape.Height(), K.Width());
 
-      elmat.SetSize (test_dof, trial_dof);
+      elmat.SetSize(test_dof, trial_dof);
 
       const IntegrationRule *ir = IntRule;
       if (ir == NULL)
@@ -2618,7 +2664,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
       {
          const IntegrationPoint &ip = ir->IntPoint(i);
 
-         Trans.SetIntPoint (&ip);
+         Trans.SetIntPoint(&ip);
 
          trial_fe.CalcVShape(Trans, trial_vshape);
          test_fe.CalcVShape(Trans, test_vshape);
@@ -2641,7 +2687,7 @@ void VectorFEMassIntegrator::AssembleElementMatrix2(
          {
             if (Q)
             {
-               w *= Q -> Eval (Trans, ip);
+               w *= Q->Eval (Trans, ip);
             }
             AddMult_a_ABt(w,test_vshape,trial_vshape,elmat);
          }
@@ -2665,42 +2711,42 @@ void VectorDivergenceIntegrator::AssembleElementMatrix2(
    int test_dof = test_fe.GetDof();
    double c;
 
-   dshape.SetSize (trial_dof, dim);
-   gshape.SetSize (trial_dof, dim);
-   Jadj.SetSize (dim);
-   divshape.SetSize (dim*trial_dof);
-   shape.SetSize (test_dof);
+   dshape.SetSize(trial_dof, dim);
+   gshape.SetSize(trial_dof, dim);
+   Jadj.SetSize(dim);
+   divshape.SetSize(dim*trial_dof);
+   shape.SetSize(test_dof);
 
-   elmat.SetSize (test_dof, dim*trial_dof);
+   elmat.SetSize(test_dof, dim*trial_dof);
 
    const IntegrationRule *ir = IntRule ? IntRule : &GetRule(trial_fe, test_fe,
                                                             Trans);
 
    elmat = 0.0;
 
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      trial_fe.CalcDShape (ip, dshape);
-      test_fe.CalcShape (ip, shape);
+      trial_fe.CalcDShape(ip, dshape);
+      test_fe.CalcShape(ip, shape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       CalcAdjugate(Trans.Jacobian(), Jadj);
 
-      Mult (dshape, Jadj, gshape);
+      Mult(dshape, Jadj, gshape);
 
       gshape.GradToDiv (divshape);
 
       c = ip.weight;
       if (Q)
       {
-         c *= Q -> Eval (Trans, ip);
+         c *= Q->Eval (Trans, ip);
       }
 
       // elmat += c * shape * divshape ^ t
       shape *= c;
-      AddMultVWt (shape, divshape, elmat);
+      AddMultVWt(shape, divshape, elmat);
    }
 }
 
@@ -2713,7 +2759,6 @@ const IntegrationRule &VectorDivergenceIntegrator::GetRule(
    return IntRules.Get(trial_fe.GetGeomType(), order);
 }
 
-
 void DivDivIntegrator::AssembleElementMatrix(
    const FiniteElement &el,
    ElementTransformation &Trans,
@@ -2737,23 +2782,22 @@ void DivDivIntegrator::AssembleElementMatrix(
    }
 
    elmat = 0.0;
-
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
-      el.CalcDivShape (ip, divshape);
+      el.CalcDivShape(ip, divshape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       c = ip.weight / Trans.Weight();
 
       if (Q)
       {
-         c *= Q -> Eval (Trans, ip);
+         c *= Q->Eval (Trans, ip);
       }
 
       // elmat += c * divshape * divshape ^ t
-      AddMult_a_VVt (c, divshape, elmat);
+      AddMult_a_VVt(c, divshape, elmat);
    }
 }
 
@@ -2785,20 +2829,19 @@ void DivDivIntegrator::AssembleElementMatrix2(
    }
 
    elmat = 0.0;
-
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
       trial_fe.CalcDivShape(ip,divshape);
       test_fe.CalcDivShape(ip,te_divshape);
 
-      Trans.SetIntPoint (&ip);
+      Trans.SetIntPoint(&ip);
       c = ip.weight / Trans.Weight();
 
       if (Q)
       {
-         c *= Q -> Eval (Trans, ip);
+         c *= Q->Eval (Trans, ip);
       }
 
       te_divshape *= c;
@@ -2842,7 +2885,7 @@ void VectorDiffusionIntegrator::AssembleElementMatrix(
 
    elmat = 0.0;
 
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
 
       const IntegrationPoint &ip = ir->IntPoint(i);
@@ -2978,7 +3021,6 @@ void VectorDiffusionIntegrator::AssembleElementVector(
    }
 }
 
-
 void ElasticityIntegrator::AssembleElementMatrix(
    const FiniteElement &el, ElementTransformation &Trans, DenseMatrix &elmat)
 {
@@ -3009,7 +3051,7 @@ void ElasticityIntegrator::AssembleElementMatrix(
 
    elmat = 0.0;
 
-   for (int i = 0; i < ir -> GetNPoints(); i++)
+   for (int i = 0; i < ir->GetNPoints(); i++)
    {
       const IntegrationPoint &ip = ir->IntPoint(i);
 
@@ -3044,7 +3086,7 @@ void ElasticityIntegrator::AssembleElementMatrix(
             for (int k = 0; k < dof; k++)
                for (int l = 0; l < dof; l++)
                {
-                  elmat (dof*d+k, dof*d+l) += (M * w) * pelmat(k, l);
+                  elmat(dof*d+k, dof*d+l) += (M * w) * pelmat(k, l);
                }
          }
          for (int ii = 0; ii < dim; ii++)
@@ -3366,7 +3408,6 @@ void DGTraceIntegrator::AssembleFaceMatrix(const FiniteElement &el1,
    }
 }
 
-
 const IntegrationRule &DGTraceIntegrator::GetRule(
    Geometry::Type geom, int order, FaceElementTransformations &T)
 {
@@ -3609,8 +3650,6 @@ void DGDiffusionIntegrator::AssembleFaceMatrix(
    }
 }
 
-
-// static method
 void DGElasticityIntegrator::AssembleBlock(
    const int dim, const int row_ndofs, const int col_ndofs,
    const int row_offset, const int col_offset,
@@ -3833,7 +3872,6 @@ void DGElasticityIntegrator::AssembleFaceMatrix(
    }
 }
 
-
 void TraceJumpIntegrator::AssembleFaceMatrix(
    const FiniteElement &trial_face_fe, const FiniteElement &test_fe1,
    const FiniteElement &test_fe2, FaceElementTransformations &Trans,
@@ -4249,7 +4287,6 @@ void NormalInterpolator::AssembleElementMatrix2(
    }
 }
 
-
 namespace internal
 {
 
@@ -4290,7 +4327,6 @@ ScalarProductInterpolator::AssembleElementMatrix2(const FiniteElement &dom_fe,
    ran_fe.Project(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 void
 ScalarVectorProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
@@ -4325,7 +4361,6 @@ ScalarVectorProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 void
 VectorScalarProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
@@ -4363,7 +4398,6 @@ VectorScalarProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 void
 ScalarCrossProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
@@ -4459,7 +4493,6 @@ VectorCrossProductInterpolator::AssembleElementMatrix2(
    ran_fe.ProjectMatrixCoefficient(dom_shape_coeff, Trans, elmat_as_vec);
 }
 
-
 namespace internal
 {
 
@@ -4489,8 +4522,7 @@ struct VDotVShapeCoefficient : public VectorCoefficient
 
 }
 
-void
-VectorInnerProductInterpolator::AssembleElementMatrix2(
+void VectorInnerProductInterpolator::AssembleElementMatrix2(
    const FiniteElement &dom_fe,
    const FiniteElement &ran_fe,
    ElementTransformation &Trans,
diff --git a/fem/bilininteg.hpp b/fem/bilininteg.hpp
index 62a16935a..209898714 100644
--- a/fem/bilininteg.hpp
+++ b/fem/bilininteg.hpp
@@ -27,7 +27,6 @@ constexpr int HCURL_MAX_Q1D = 5;
 #else
 constexpr int HCURL_MAX_Q1D = 6;
 #endif
-
 constexpr int HDIV_MAX_D1D = 5;
 constexpr int HDIV_MAX_Q1D = 6;
 
@@ -36,7 +35,7 @@ class BilinearFormIntegrator : public NonlinearFormIntegrator
 {
 protected:
    BilinearFormIntegrator(const IntegrationRule *ir = NULL)
-      : NonlinearFormIntegrator(ir) { }
+      : NonlinearFormIntegrator(ir) {}
 
 public:
    // TODO: add support for other assembly levels (in addition to PA) and their
@@ -51,8 +50,6 @@ public:
    // make sense for the action of the nonlinear operator (but they all make
    // sense for its Jacobian).
 
-   using NonlinearFormIntegrator::AssemblePA;
-
    /// Method defining partial assembly.
    /** The result of the partial assembly is stored internally so that it can be
        used later in the methods AddMultPA() and AddMultTransposePA(). */
@@ -62,6 +59,9 @@ public:
                            const FiniteElementSpace &test_fes);
 
    virtual void AssemblePABoundary(const FiniteElementSpace &fes);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssemblePABoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
 
    virtual void AssemblePAInteriorFaces(const FiniteElementSpace &fes);
 
@@ -91,20 +91,21 @@ public:
        called. */
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   /// Method defining element assembly.
-   /** The result of the element assembly is added to the @a emat Vector if
-       @a add is true. Otherwise, if @a add is false, we set @a emat. */
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add = true);
-   /** Used with BilinearFormIntegrators that have different spaces. */
-   // virtual void AssembleEA(const FiniteElementSpace &trial_fes,
-   //                         const FiniteElementSpace &test_fes,
-   //                         Vector &emat);
-
    /// Method defining matrix-free assembly.
    /** The result of fully matrix-free assembly is stored internally so that it
        can be used later in the methods AddMultMF() and AddMultTransposeMF(). */
    virtual void AssembleMF(const FiniteElementSpace &fes);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AssembleMFBoundary(const FiniteElementSpace &fes);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssembleMFBoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes);
+
+   /// Assemble diagonal and add it to Vector @a diag.
+   virtual void AssembleDiagonalMF(Vector &diag);
 
    /** Perform the action of integrator on the input @a x and add the result to
        the output @a y. Both @a x and @a y are E-vectors, i.e. they represent
@@ -122,17 +123,20 @@ public:
        called. */
    virtual void AddMultTransposeMF(const Vector &x, Vector &y) const;
 
-   /// Assemble diagonal and add it to Vector @a diag.
-   virtual void AssembleDiagonalMF(Vector &diag);
+   /// Method defining element assembly.
+   /** The result of the element assembly is added to the @a emat Vector. */
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
+   /** Used with BilinearFormIntegrators that have different spaces. */
+   virtual void AssembleEA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes,
+                           Vector &emat);
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add = true);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add = true);
+                                        Vector &ea_data_bdr);
 
    /// Given a particular Finite Element computes the element matrix elmat.
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -236,7 +240,7 @@ public:
                                    Vector &u,
                                    const FiniteElement &fluxelem,
                                    Vector &flux, bool with_coef = true,
-                                   const IntegrationRule *ir = NULL) { }
+                                   const IntegrationRule *ir = NULL) {}
 
    /** @brief Virtual method required for Zienkiewicz-Zhu type error estimators.
 
@@ -262,7 +266,7 @@ public:
                                     Vector &flux, Vector *d_energy = NULL)
    { return 0.0; }
 
-   virtual ~BilinearFormIntegrator() { }
+   virtual ~BilinearFormIntegrator() {}
 };
 
 /** Wraps a given @a BilinearFormIntegrator and transposes the resulting element
@@ -270,13 +274,12 @@ public:
 class TransposeIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_bfi;
+   bool own_bfi;
    BilinearFormIntegrator *bfi;
-
    DenseMatrix bfi_elmat;
 
 public:
-   TransposeIntegrator (BilinearFormIntegrator *bfi_, int own_bfi_ = 1)
+   TransposeIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
    { bfi = bfi_; own_bfi = own_bfi_; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
@@ -296,17 +299,24 @@ public:
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-
-   virtual void AssemblePA(const FiniteElementSpace& fes)
+   virtual void AssemblePA(const FiniteElementSpace &fes)
    {
       bfi->AssemblePA(fes);
    }
-
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes)
    {
-      bfi->AssemblePA(test_fes, trial_fes); // Reverse test and trial
+      bfi->AssemblePA(trial_fes, test_fes);
+   }
+
+   virtual void AssemblePABoundary(const FiniteElementSpace &fes)
+   {
+      bfi->AssemblePABoundary(fes);
+   }
+   virtual void AssemblePABoundary(const FiniteElementSpace &trial_fes,
+                                   const FiniteElementSpace &test_fes)
+   {
+      bfi->AssemblePABoundary(trial_fes, test_fes);
    }
 
    virtual void AssemblePAInteriorFaces(const FiniteElementSpace &fes)
@@ -324,22 +334,20 @@ public:
       bfi->AddMultPA(x, y);
    }
 
-   virtual void AddMultPA(const Vector& x, Vector& y) const
+   virtual void AddMultPA(const Vector &x, Vector &y) const
    {
       bfi->AddMultTransposePA(x, y);
    }
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add);
+                                        Vector &ea_data_bdr);
 
    virtual ~TransposeIntegrator() { if (own_bfi) { delete bfi; } }
 };
@@ -347,11 +355,11 @@ public:
 class LumpedIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_bfi;
+   bool own_bfi;
    BilinearFormIntegrator *bfi;
 
 public:
-   LumpedIntegrator (BilinearFormIntegrator *bfi_, int own_bfi_ = 1)
+   LumpedIntegrator(BilinearFormIntegrator *bfi_, bool own_bfi_ = true)
    { bfi = bfi_; own_bfi = own_bfi_; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
@@ -367,11 +375,11 @@ public:
 class InverseIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_integrator;
+   bool own_integrator;
    BilinearFormIntegrator *integrator;
 
 public:
-   InverseIntegrator(BilinearFormIntegrator *integ, int own_integ = 1)
+   InverseIntegrator(BilinearFormIntegrator *integ, bool own_integ = 1)
    { integrator = integ; own_integrator = own_integ; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
@@ -387,12 +395,12 @@ public:
 class SumIntegrator : public BilinearFormIntegrator
 {
 private:
-   int own_integrators;
+   bool own_integrators;
    mutable DenseMatrix elem_mat;
    Array<BilinearFormIntegrator*> integrators;
 
 public:
-   SumIntegrator(int own_integs = 1) { own_integrators = own_integs; }
+   SumIntegrator(bool own_integs = true) { own_integrators = own_integs; }
 
    virtual void SetIntRule(const IntegrationRule *ir);
 
@@ -419,8 +427,9 @@ public:
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace& fes);
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
 
    virtual void AssembleDiagonalPA(Vector &diag);
 
@@ -430,27 +439,27 @@ public:
 
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   virtual void AddMultPA(const Vector& x, Vector& y) const;
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
    virtual void AssembleMF(const FiniteElementSpace &fes);
+   virtual void AssembleMF(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
 
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 
    virtual void AddMultTransposeMF(const Vector &x, Vector &y) const;
 
-   virtual void AssembleDiagonalMF(Vector &diag);
-
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace &fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add);
+                                        Vector &ea_data_bdr);
 
    virtual ~SumIntegrator();
 };
@@ -460,7 +469,6 @@ public:
 class MixedScalarIntegrator: public BilinearFormIntegrator
 {
 public:
-
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -482,44 +490,39 @@ protected:
    MixedScalarIntegrator(Coefficient &q) : same_calc_shape(false), Q(&q) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe, const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarIntegrator:  "
              "Trial and test spaces must both be scalar fields.";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     Vector & shape)
+                                     Vector &shape)
    { test_fe.CalcPhysShape(Trans, shape); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    { trial_fe.CalcPhysShape(Trans, shape); }
 
    Coefficient *Q;
 
 private:
-
 #ifndef MFEM_THREAD_SAFE
-   Vector test_shape;
-   Vector trial_shape;
+   Vector test_shape, trial_shape;
 #endif
-
 };
 
 /** An abstract class for integrating the inner product of two vector basis
@@ -527,7 +530,6 @@ private:
 class MixedVectorIntegrator: public BilinearFormIntegrator
 {
 public:
-
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -556,39 +558,38 @@ protected:
       : same_calc_shape(false), Q(NULL), VQ(NULL), DQ(NULL), MQ(&mq) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorIntegrator:  "
              "Trial and test spaces must both be vector fields";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return std::max(space_dim, test_fe.GetVDim()); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcVShape(Trans, shape); }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return std::max(space_dim, trial_fe.GetVDim()); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcVShape(Trans, shape); }
 
    int space_dim;
@@ -598,16 +599,10 @@ protected:
    MatrixCoefficient *MQ;
 
 private:
-
 #ifndef MFEM_THREAD_SAFE
-   Vector V;
-   Vector D;
-   DenseMatrix M;
-   DenseMatrix test_shape;
-   DenseMatrix trial_shape;
-   DenseMatrix shape_tmp;
+   Vector V, D;
+   DenseMatrix M, test_shape, trial_shape, shape_tmp;
 #endif
-
 };
 
 /** An abstract class for integrating the product of a scalar basis function and
@@ -616,7 +611,6 @@ private:
 class MixedScalarVectorIntegrator: public BilinearFormIntegrator
 {
 public:
-
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -633,14 +627,13 @@ public:
    { AssembleElementMatrix2(fe, fe, Trans, elmat); }
 
 protected:
-
    MixedScalarVectorIntegrator(VectorCoefficient &vq, bool transpose_ = false,
                                bool cross_2d_ = false)
       : VQ(&vq), transpose(transpose_), cross_2d(cross_2d_) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return ((transpose &&
                trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -651,9 +644,9 @@ protected:
              );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
-      if ( transpose )
+      if (transpose)
       {
          return "MixedScalarVectorIntegrator:  "
                 "Trial space must be a vector field "
@@ -667,23 +660,22 @@ protected:
       }
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW(); }
 
-
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return std::max(space_dim, vector_fe.GetVDim()); }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape_)
+                                  DenseMatrix &shape_)
    { vector_fe.CalcVShape(Trans, shape_); }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape_)
+                                 Vector &shape_)
    { scalar_fe.CalcPhysShape(Trans, shape_); }
 
    VectorCoefficient *VQ;
@@ -692,14 +684,12 @@ protected:
    bool cross_2d;  // In 2D use a cross product rather than a dot product
 
 private:
-
 #ifndef MFEM_THREAD_SAFE
    Vector V;
    DenseMatrix vshape;
    Vector      shape;
    Vector      vshape_tmp;
 #endif
-
 };
 
 /** Class for integrating the bilinear form a(u,v) := (Q u, v) in either 1D, 2D,
@@ -734,24 +724,24 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 1 && test_fe.GetDim() == 1 &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarDerivativeIntegrator:  "
              "Trial and test spaces must both be scalar fields in 1D "
              "and the trial space must implement CalcDShape.";
    }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       trial_fe.CalcPhysDShape(Trans, dshape);
@@ -769,15 +759,15 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 1 && test_fe.GetDim() == 1 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakDerivativeIntegrator:  "
              "Trial and test spaces must both be scalar fields in 1D "
@@ -785,9 +775,9 @@ protected:
              "map type \"VALUE\".";
    }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     Vector & shape)
+                                     Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       test_fe.CalcPhysDShape(Trans, dshape);
@@ -807,28 +797,28 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarDivergenceIntegrator:  "
              "Trial must be H(Div) and the test space must be a "
              "scalar field";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    { trial_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -843,14 +833,14 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::DIV  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorDivergenceIntegrator:  "
              "Trial must be H(Div) and the test space must be a "
@@ -859,14 +849,14 @@ protected:
 
    // Subtract one due to the divergence and add one for the coefficient
    // which is assumed to be at least linear.
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1 + 1; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -882,28 +872,28 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::DIV );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakGradientIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be H(Div)";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   virtual void CalcTestShape(const FiniteElement & test_fe,
+   virtual void CalcTestShape(const FiniteElement &test_fe,
                               ElementTransformation &Trans,
-                              Vector & shape)
+                              Vector &shape)
    {
       test_fe.CalcPhysDivShape(Trans, shape);
       shape *= -1.0;
@@ -922,29 +912,29 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR);
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCurlIntegrator:  "
              "Trial must be H(Curl) and the test space must be a "
              "scalar field";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      Vector & shape)
+                                      Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       trial_fe.CalcPhysCurlShape(Trans, dshape);
@@ -954,7 +944,8 @@ protected:
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    // PA extension
@@ -978,24 +969,24 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCurlIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be H(Curl)";
    }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     Vector & shape)
+                                     Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       test_fe.CalcPhysCurlShape(Trans, dshape);
@@ -1036,14 +1027,14 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDotProductIntegrator:  "
              "Trial space must be a vector field "
@@ -1061,15 +1052,15 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::DIV );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakGradDotIntegrator:  "
              "Trial space must be a vector field "
@@ -1078,14 +1069,14 @@ public:
 
    // Subtract one due to the gradient and add one for the coefficient
    // which is assumed to be at least linear.
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    { return trial_fe.GetOrder() + test_fe.GetOrder() + Trans.OrderW() - 1 + 1; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1098,8 +1089,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1107,19 +1098,19 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakDivCrossIntegrator:  "
              "Trial space must be a vector field in 3D "
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1138,8 +1129,8 @@ public:
       : MixedVectorIntegrator(mq) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
@@ -1147,15 +1138,15 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedGradGradIntegrator:  "
              "Trial and test spaces must both be scalar fields "
              "with a gradient operator.";
    }
 
-   inline virtual int GetIntegrationOrder(const FiniteElement & trial_fe,
-                                          const FiniteElement & test_fe,
+   inline virtual int GetIntegrationOrder(const FiniteElement &trial_fe,
+                                          const FiniteElement &test_fe,
                                           ElementTransformation &Trans)
    {
       // Same as DiffusionIntegrator
@@ -1164,20 +1155,20 @@ public:
              trial_fe.GetOrder() + test_fe.GetOrder() + test_fe.GetDim() - 1;
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1190,8 +1181,8 @@ public:
       : MixedVectorIntegrator(vq, false) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
@@ -1199,27 +1190,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradGradIntegrator:  "
              "Trial and test spaces must both be scalar fields "
              "with a gradient operator.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1238,8 +1229,8 @@ public:
       : MixedVectorIntegrator(mq) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1248,27 +1239,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCurlCurlIntegrator"
              "Trial and test spaces must both be vector fields in 3D "
              "with a curl.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1281,8 +1272,8 @@ public:
       : MixedVectorIntegrator(vq, false) { same_calc_shape = true; }
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && trial_fe.GetVDim() == 3 &&
               test_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
@@ -1292,27 +1283,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlCurlIntegrator:  "
              "Trial and test spaces must both be vector fields in 3D "
              "with a curl.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1325,8 +1316,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1335,27 +1326,27 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlGradIntegrator"
              "Trial space must be a vector field in 3D with a curl"
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1368,8 +1359,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
@@ -1378,27 +1369,27 @@ public:
               test_fe.GetDerivType() == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradCurlIntegrator"
              "Trial space must be a scalar field in 3D with a gradient"
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1412,8 +1403,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1421,19 +1412,19 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedWeakCurlCrossIntegrator:  "
              "Trial space must be a vector field in 3D "
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1447,8 +1438,8 @@ public:
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1456,16 +1447,16 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCurlCrossIntegrator:  "
              "Trial space must be a vector field in 2D "
              "and the test space must be a vector field with a curl";
    }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       scalar_fe.CalcPhysCurlShape(Trans, dshape);
@@ -1482,8 +1473,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (test_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
@@ -1491,24 +1482,24 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossGradIntegrator:  "
              "Trial space must be a scalar field with a gradient operator"
              " and the test space must be a vector field both in 3D.";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysDShape(Trans, shape); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    { test_fe.CalcVShape(Trans, shape); }
 };
 
@@ -1522,8 +1513,8 @@ public:
       : MixedVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1531,19 +1522,19 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlIntegrator:  "
              "Trial space must be a vector field in 3D with a curl "
              "and the test space must be a vector field";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    { trial_fe.CalcPhysCurlShape(Trans, shape); }
 };
 
@@ -1557,8 +1548,8 @@ public:
       : MixedScalarVectorIntegrator(vq, false, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
@@ -1566,16 +1557,16 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedCrossCurlIntegrator:  "
              "Trial space must be a vector field in 2D with a curl "
              "and the test space must be a vector field";
    }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    {
       DenseMatrix dshape(shape.GetData(), shape.Size(), 1);
       scalar_fe.CalcPhysCurlShape(Trans, dshape); shape *= -1.0;
@@ -1591,8 +1582,8 @@ public:
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
@@ -1600,19 +1591,19 @@ public:
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCrossGradIntegrator:  "
              "Trial space must be a scalar field in 2D with a gradient "
              "and the test space must be a scalar field";
    }
 
-   inline int GetVDim(const FiniteElement & vector_fe)
+   inline int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1625,15 +1616,15 @@ public:
       : MixedScalarVectorIntegrator(vq, true, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarCrossProductIntegrator:  "
              "Trial space must be a vector field in 2D "
@@ -1650,24 +1641,24 @@ public:
       : MixedScalarVectorIntegrator(vq, false, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDim() == 2 && test_fe.GetDim() == 2 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakCrossProductIntegrator:  "
              "Trial space must be a scalar field in 2D "
              "and the test space must be a vector field";
    }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1680,27 +1671,27 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDirectionalDerivativeIntegrator:  "
              "Trial space must be a scalar field with a gradient "
              "and the test space must be a scalar field";
    }
 
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); }
 };
 
@@ -1713,8 +1704,8 @@ public:
       : MixedScalarVectorIntegrator(vq, true) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::GRAD   &&
@@ -1722,24 +1713,24 @@ public:
               test_fe.GetDerivType()  == mfem::FiniteElement::DIV   );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedGradDivIntegrator:  "
              "Trial space must be a scalar field with a gradient"
              "and the test space must be a vector field with a divergence";
    }
 
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -1752,8 +1743,8 @@ public:
       : MixedScalarVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               trial_fe.GetDerivType() == mfem::FiniteElement::DIV    &&
@@ -1762,24 +1753,24 @@ public:
              );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedDivGradIntegrator:  "
              "Trial space must be a vector field with a divergence"
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline virtual int GetVDim(const FiniteElement & vector_fe)
+   inline virtual int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 
-   inline virtual void CalcShape(const FiniteElement & scalar_fe,
+   inline virtual void CalcShape(const FiniteElement &scalar_fe,
                                  ElementTransformation &Trans,
-                                 Vector & shape)
+                                 Vector &shape)
    { scalar_fe.CalcPhysDivShape(Trans, shape); }
 };
 
@@ -1792,27 +1783,27 @@ public:
       : MixedScalarVectorIntegrator(vq, false) {}
 
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::SCALAR &&
               test_fe.GetRangeType()  == mfem::FiniteElement::SCALAR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD   );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedScalarWeakDivergenceIntegrator:  "
              "Trial space must be a scalar field "
              "and the test space must be a scalar field with a gradient";
    }
 
-   inline int GetVDim(const FiniteElement & vector_fe)
+   inline int GetVDim(const FiniteElement &vector_fe)
    { return space_dim; }
 
-   inline virtual void CalcVShape(const FiniteElement & vector_fe,
+   inline virtual void CalcVShape(const FiniteElement &vector_fe,
                                   ElementTransformation &Trans,
-                                  DenseMatrix & shape)
+                                  DenseMatrix &shape)
    { vector_fe.CalcPhysDShape(Trans, shape); shape *= -1.0; }
 };
 
@@ -1833,40 +1824,40 @@ public:
    MixedVectorGradientIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetDerivType() == mfem::FiniteElement::GRAD &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorGradientIntegrator:  "
              "Trial spaces must be H1 and the test space must be a "
              "vector field in 2D or 3D";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return space_dim; }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    {
       trial_fe.CalcPhysDShape(Trans, shape);
    }
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
-private:
    DenseMatrix Jinv;
 
    // PA extension
@@ -1891,40 +1882,41 @@ public:
    MixedVectorCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetCurlDim() == 3 && test_fe.GetVDim() == 3 &&
               trial_fe.GetDerivType() == mfem::FiniteElement::CURL  &&
               test_fe.GetRangeType()  == mfem::FiniteElement::VECTOR );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorCurlIntegrator:  "
              "Trial space must be H(Curl) and the test space must be a "
              "vector field in 3D";
    }
 
-   inline virtual int GetTrialVDim(const FiniteElement & trial_fe)
+   inline virtual int GetTrialVDim(const FiniteElement &trial_fe)
    { return trial_fe.GetCurlDim(); }
 
-   inline virtual void CalcTrialShape(const FiniteElement & trial_fe,
+   inline virtual void CalcTrialShape(const FiniteElement &trial_fe,
                                       ElementTransformation &Trans,
-                                      DenseMatrix & shape)
+                                      DenseMatrix &shape)
    {
       trial_fe.CalcPhysCurlShape(Trans, shape);
    }
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
 private:
    // PA extension
    Vector pa_data;
@@ -1950,40 +1942,41 @@ public:
    MixedVectorWeakCurlIntegrator(MatrixCoefficient &mq)
       : MixedVectorIntegrator(mq) {}
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetVDim() == 3 && test_fe.GetCurlDim() == 3 &&
               trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::CURL );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorWeakCurlIntegrator:  "
              "Trial space must be vector field in 3D and the "
              "test space must be H(Curl)";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return test_fe.GetCurlDim(); }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    {
       test_fe.CalcPhysCurlShape(Trans, shape);
    }
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
 private:
    // PA extension
    Vector pa_data;
@@ -2009,26 +2002,26 @@ public:
 
 protected:
    inline virtual bool VerifyFiniteElementTypes(
-      const FiniteElement & trial_fe,
-      const FiniteElement & test_fe) const
+      const FiniteElement &trial_fe,
+      const FiniteElement &test_fe) const
    {
       return (trial_fe.GetRangeType() == mfem::FiniteElement::VECTOR &&
               test_fe.GetDerivType()  == mfem::FiniteElement::GRAD );
    }
 
-   inline virtual const char * FiniteElementTypeFailureMessage() const
+   inline virtual const char *FiniteElementTypeFailureMessage() const
    {
       return "MixedVectorWeakDivergenceIntegrator:  "
              "Trial space must be vector field and the "
              "test space must be H1";
    }
 
-   inline virtual int GetTestVDim(const FiniteElement & test_fe)
+   inline virtual int GetTestVDim(const FiniteElement &test_fe)
    { return space_dim; }
 
-   inline virtual void CalcTestShape(const FiniteElement & test_fe,
+   inline virtual void CalcTestShape(const FiniteElement &test_fe,
                                      ElementTransformation &Trans,
-                                     DenseMatrix & shape)
+                                     DenseMatrix &shape)
    {
       test_fe.CalcPhysDShape(Trans, shape);
       shape *= -1.0;
@@ -2051,6 +2044,7 @@ private:
    DenseMatrix gshape;
    DenseMatrix Jadj;
    DenseMatrix elmat_comp;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *trial_maps, *test_maps; ///< Not owned
@@ -2061,13 +2055,13 @@ private:
 public:
    GradientIntegrator() :
       Q{NULL}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
-   { }
+   {}
    GradientIntegrator(Coefficient *q_) :
       Q{q_}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
-   { }
+   {}
    GradientIntegrator(Coefficient &q) :
       Q{&q}, trial_maps{NULL}, test_maps{NULL}, geom{NULL}
-   { }
+   {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2079,6 +2073,7 @@ public:
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
@@ -2104,7 +2099,6 @@ private:
 #endif
 
    // PA extension
-   const FiniteElementSpace *fespace;
    const DofToQuad *maps;         ///< Not owned
    const GeometricFactors *geom;  ///< Not owned
    int dim, ne, dofs1D, quad1D;
@@ -2115,30 +2109,31 @@ public:
    /// Construct a diffusion integrator with coefficient Q = 1
    DiffusionIntegrator(const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(NULL), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) { }
+        Q(NULL), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a diffusion integrator with a scalar coefficient q
    DiffusionIntegrator(Coefficient &q, const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(&q), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) { }
+        Q(&q), VQ(NULL), MQ(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a diffusion integrator with a vector coefficient q
    DiffusionIntegrator(VectorCoefficient &q,
                        const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(NULL), VQ(&q), MQ(NULL), maps(NULL), geom(NULL) { }
+        Q(NULL), VQ(&q), MQ(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a diffusion integrator with a matrix coefficient q
    DiffusionIntegrator(MatrixCoefficient &q,
                        const IntegrationRule *ir = nullptr)
       : BilinearFormIntegrator(ir),
-        Q(NULL), VQ(NULL), MQ(&q), maps(NULL), geom(NULL) { }
+        Q(NULL), VQ(NULL), MQ(&q), maps(NULL), geom(NULL) {}
 
    /** Given a particular Finite Element computes the element stiffness matrix
        elmat. */
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    /** Given a trial and test Finite Element computes the element stiffness
        matrix elmat. */
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
@@ -2162,23 +2157,23 @@ public:
                                     Vector &flux, Vector *d_energy = NULL);
 
    using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+   virtual void AssembleDiagonalPA(Vector &diag);
 
-   virtual void AssemblePA(const FiniteElementSpace &fes);
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   virtual void AssembleDiagonalPA(Vector &diag);
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
 
    virtual void AssembleDiagonalMF(Vector &diag);
 
-   virtual void AddMultMF(const Vector&, Vector&) const;
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
                                          const FiniteElement &test_fe);
@@ -2191,14 +2186,16 @@ public:
 /** Class for local mass matrix assembling a(u,v) := (Q u, v) */
 class MassIntegrator: public BilinearFormIntegrator
 {
+private:
    friend class DGMassInverse;
+
 protected:
 #ifndef MFEM_THREAD_SAFE
    Vector shape, te_shape;
 #endif
    Coefficient *Q;
+
    // PA extension
-   const FiniteElementSpace *fespace;
    Vector pa_data;
    const DofToQuad *maps;                 ///< Not owned
    const GeometricFactors *geom;          ///< Not owned
@@ -2207,42 +2204,44 @@ protected:
 
 public:
    MassIntegrator(const IntegrationRule *ir = NULL)
-      : BilinearFormIntegrator(ir), Q(NULL), maps(NULL), geom(NULL) { }
+      : BilinearFormIntegrator(ir), Q(NULL), maps(NULL), geom(NULL) {}
 
    /// Construct a mass integrator with coefficient q
    MassIntegrator(Coefficient &q, const IntegrationRule *ir = NULL)
-      : BilinearFormIntegrator(ir), Q(&q), maps(NULL), geom(NULL) { }
+      : BilinearFormIntegrator(ir), Q(&q), maps(NULL), geom(NULL) {}
 
    /** Given a particular Finite Element computes the element mass matrix
        elmat. */
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
    using BilinearFormIntegrator::AssemblePA;
-
-   virtual void AssembleMF(const FiniteElementSpace &fes);
-
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
+   using BilinearFormIntegrator::AssemblePABoundary;
    virtual void AssemblePABoundary(const FiniteElementSpace &fes);
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
-
    virtual void AssembleDiagonalPA(Vector &diag);
 
-   virtual void AssembleDiagonalMF(Vector &diag);
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
 
-   virtual void AddMultMF(const Vector&, Vector&) const;
+   virtual void AssembleDiagonalMF(Vector &diag);
 
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
                                          const FiniteElement &test_fe,
@@ -2257,7 +2256,7 @@ public:
 class BoundaryMassIntegrator : public MassIntegrator
 {
 public:
-   BoundaryMassIntegrator(Coefficient &q) : MassIntegrator(q) { }
+   BoundaryMassIntegrator(Coefficient &q) : MassIntegrator(q) {}
 
    using BilinearFormIntegrator::AssembleFaceMatrix;
 
@@ -2273,6 +2272,7 @@ class ConvectionIntegrator : public BilinearFormIntegrator
 protected:
    VectorCoefficient *Q;
    double alpha;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;         ///< Not owned
@@ -2289,34 +2289,30 @@ public:
    ConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
       : Q(&q) { alpha = a; }
 
-   virtual void AssembleElementMatrix(const FiniteElement &,
-                                      ElementTransformation &,
-                                      DenseMatrix &);
+   virtual void AssembleElementMatrix(const FiniteElement &fes,
+                                      ElementTransformation &Trans,
+                                      DenseMatrix &elmat);
 
    using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+   virtual void AssembleDiagonalPA(Vector &diag);
 
-   virtual void AssemblePA(const FiniteElementSpace&);
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat,
-                           const bool add);
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
-   virtual void AssembleDiagonalPA(Vector &diag);
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
 
    virtual void AssembleDiagonalMF(Vector &diag);
 
-   virtual void AddMultMF(const Vector&, Vector&) const;
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-
-   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+   virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   static const IntegrationRule &GetRule(const FiniteElement &el,
-                                         ElementTransformation &Trans);
+   using BilinearFormIntegrator::AssembleEA;
+   virtual void AssembleEA(const FiniteElementSpace &fes, Vector &emat);
 
-   static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
-                                         const FiniteElement &test_fe,
+   static const IntegrationRule &GetRule(const FiniteElement &fe,
                                          ElementTransformation &Trans);
 
    bool SupportsCeed() const { return DeviceCanUseCeed(); }
@@ -2330,7 +2326,7 @@ class ConservativeConvectionIntegrator : public TransposeIntegrator
 {
 public:
    ConservativeConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
-      : TransposeIntegrator(new ConvectionIntegrator(q, -a)) { }
+      : TransposeIntegrator(new ConvectionIntegrator(q, -a)) {}
 };
 
 /// alpha (q . grad u, v) using the "group" FE discretization
@@ -2347,6 +2343,7 @@ private:
 public:
    GroupConvectionIntegrator(VectorCoefficient &q, double a = 1.0)
       : Q(&q) { alpha = a; }
+
    virtual void AssembleElementMatrix(const FiniteElement &,
                                       ElementTransformation &,
                                       DenseMatrix &);
@@ -2368,6 +2365,7 @@ protected:
    Coefficient *Q;
    VectorCoefficient *VQ;
    MatrixCoefficient *MQ;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;         ///< Not owned
@@ -2377,21 +2375,21 @@ protected:
 public:
    /// Construct an integrator with coefficient 1.0
    VectorMassIntegrator()
-      : vdim(-1), Q_order(0), Q(NULL), VQ(NULL), MQ(NULL) { }
+      : vdim(-1), Q_order(0), Q(NULL), VQ(NULL), MQ(NULL) {}
    /** Construct an integrator with scalar coefficient q.  If possible, save
        memory by using a scalar integrator since the resulting matrix is block
        diagonal with the same diagonal block repeated. */
    VectorMassIntegrator(Coefficient &q, int qo = 0)
-      : vdim(-1), Q_order(qo), Q(&q), VQ(NULL), MQ(NULL) { }
+      : vdim(-1), Q_order(qo), Q(&q), VQ(NULL), MQ(NULL) {}
    VectorMassIntegrator(Coefficient &q, const IntegrationRule *ir)
       : BilinearFormIntegrator(ir), vdim(-1), Q_order(0), Q(&q), VQ(NULL),
-        MQ(NULL) { }
+        MQ(NULL) {}
    /// Construct an integrator with diagonal coefficient q
    VectorMassIntegrator(VectorCoefficient &q, int qo = 0)
-      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(&q), MQ(NULL) { }
+      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(&q), MQ(NULL) {}
    /// Construct an integrator with matrix coefficient q
    VectorMassIntegrator(MatrixCoefficient &q, int qo = 0)
-      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(NULL), MQ(&q) { }
+      : vdim(q.GetVDim()), Q_order(qo), Q(NULL), VQ(NULL), MQ(&q) {}
 
    int GetVDim() const { return vdim; }
    void SetVDim(int vdim_) { vdim = vdim_; }
@@ -2399,21 +2397,29 @@ public:
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
-   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    bool SupportsCeed() const { return DeviceCanUseCeed(); }
 };
 
-
 /** Class for integrating (div u, p) where u is a vector field given by
     VectorFiniteElement through Piola transformation (for RT elements); p is
     scalar function given by FiniteElement through standard transformation.
@@ -2427,13 +2433,6 @@ class VectorFEDivergenceIntegrator : public BilinearFormIntegrator
 protected:
    Coefficient *Q;
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
-   virtual void AddMultPA(const Vector&, Vector&) const;
-   virtual void AddMultTransposePA(const Vector&, Vector&) const;
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector divshape, shape;
@@ -2449,17 +2448,26 @@ private:
 public:
    VectorFEDivergenceIntegrator() { Q = NULL; }
    VectorFEDivergenceIntegrator(Coefficient &q) { Q = &q; }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
-                                      DenseMatrix &elmat) { }
+                                      DenseMatrix &elmat) {}
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
+                           const FiniteElementSpace &test_fes);
+
    virtual void AssembleDiagonalPA_ADAt(const Vector &D, Vector &diag);
-};
 
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+};
 
 /** Integrator for `(-Q u, grad v)` for Nedelec (`u`) and H1 (`v`) elements.
     This is equivalent to a weak divergence of the Nedelec basis functions. */
@@ -2479,9 +2487,11 @@ private:
 public:
    VectorFEWeakDivergenceIntegrator() { Q = NULL; }
    VectorFEWeakDivergenceIntegrator(Coefficient &q) { Q = &q; }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
-                                      DenseMatrix &elmat) { }
+                                      DenseMatrix &elmat) {}
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2505,9 +2515,11 @@ private:
 public:
    VectorFECurlIntegrator() { Q = NULL; }
    VectorFECurlIntegrator(Coefficient &q) { Q = &q; }
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
-                                      DenseMatrix &elmat) { }
+                                      DenseMatrix &elmat) {}
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2526,11 +2538,13 @@ private:
    Vector shape, dshapedxi;
 
 public:
-   DerivativeIntegrator(Coefficient &q, int i) : Q(&q), xi(i) { }
+   DerivativeIntegrator(Coefficient &q, int i) : Q(&q), xi(i) {}
+
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat)
    { AssembleElementMatrix2(el,el,Trans,elmat); }
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
@@ -2566,12 +2580,12 @@ public:
    CurlCurlIntegrator() { Q = NULL; DQ = NULL; MQ = NULL; }
    /// Construct a bilinear form integrator for Nedelec elements
    CurlCurlIntegrator(Coefficient &q, const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(&q), DQ(NULL), MQ(NULL) { }
+      BilinearFormIntegrator(ir), Q(&q), DQ(NULL), MQ(NULL) {}
    CurlCurlIntegrator(DiagonalMatrixCoefficient &dq,
                       const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(NULL), DQ(&dq), MQ(NULL) { }
+      BilinearFormIntegrator(ir), Q(NULL), DQ(&dq), MQ(NULL) {}
    CurlCurlIntegrator(MatrixCoefficient &mq, const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(NULL), DQ(NULL), MQ(&mq) { }
+      BilinearFormIntegrator(ir), Q(NULL), DQ(NULL), MQ(&mq) {}
 
    /* Given a particular Finite Element, compute the
       element curl-curl matrix elmat */
@@ -2596,8 +2610,10 @@ public:
 
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
-   virtual void AssembleDiagonalPA(Vector& diag);
 
    const Coefficient *GetCoefficient() const { return Q; }
 };
@@ -2617,7 +2633,7 @@ protected:
 public:
    VectorCurlCurlIntegrator() { Q = NULL; }
 
-   VectorCurlCurlIntegrator(Coefficient &q) : Q(&q) { }
+   VectorCurlCurlIntegrator(Coefficient &q) : Q(&q) {}
 
    /// Assemble an element matrix
    virtual void AssembleElementMatrix(const FiniteElement &el,
@@ -2648,9 +2664,9 @@ private:
    DenseMatrix curlshape;
    DenseMatrix elmat_comp;
 public:
-   MixedCurlIntegrator() : Q{NULL} { }
-   MixedCurlIntegrator(Coefficient *q_) :  Q{q_} { }
-   MixedCurlIntegrator(Coefficient &q) :  Q{&q} { }
+   MixedCurlIntegrator() : Q{NULL} {}
+   MixedCurlIntegrator(Coefficient *q_) :  Q{q_} {}
+   MixedCurlIntegrator(Coefficient &q) :  Q{&q} {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2704,18 +2720,21 @@ public:
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &fes);
+   virtual void AssemblePA(const FiniteElementSpace &fes) { AssemblePA(fes, fes); }
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
-   virtual void AssembleDiagonalPA(Vector& diag);
 
    const Coefficient *GetCoefficient() const { return Q; }
 };
@@ -2733,6 +2752,7 @@ private:
    DenseMatrix dshape;
    DenseMatrix gshape;
    DenseMatrix Jadj;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *trial_maps, *test_maps; ///< Not owned
@@ -2746,10 +2766,10 @@ public:
    {  }
    VectorDivergenceIntegrator(Coefficient *q_) :
       Q(q_), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   { }
+   {}
    VectorDivergenceIntegrator(Coefficient &q) :
       Q(&q), trial_maps(NULL), test_maps(NULL), geom(NULL)
-   { }
+   {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &trial_fe,
                                        const FiniteElement &test_fe,
@@ -2761,6 +2781,7 @@ public:
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    static const IntegrationRule &GetRule(const FiniteElement &trial_fe,
@@ -2774,11 +2795,6 @@ class DivDivIntegrator: public BilinearFormIntegrator
 protected:
    Coefficient *Q;
 
-   using BilinearFormIntegrator::AssemblePA;
-   virtual void AssemblePA(const FiniteElementSpace &fes);
-   virtual void AddMultPA(const Vector &x, Vector &y) const;
-   virtual void AssembleDiagonalPA(Vector& diag);
-
 private:
 #ifndef MFEM_THREAD_SAFE
    Vector divshape, te_divshape;
@@ -2794,7 +2810,7 @@ private:
 public:
    DivDivIntegrator() { Q = NULL; }
    DivDivIntegrator(Coefficient &q, const IntegrationRule *ir = NULL) :
-      BilinearFormIntegrator(ir), Q(&q) { }
+      BilinearFormIntegrator(ir), Q(&q) {}
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
@@ -2805,6 +2821,13 @@ public:
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
 
+   using BilinearFormIntegrator::AssemblePA;
+   virtual void AssemblePA(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalPA(Vector &diag);
+
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    const Coefficient *GetCoefficient() const { return Q; }
 };
 
@@ -2841,7 +2864,7 @@ private:
    Vector vcoeff;
 
 public:
-   VectorDiffusionIntegrator() { }
+   VectorDiffusionIntegrator() {}
 
    /** \brief Integrator with unit coefficient for caller-specified vector
        dimension.
@@ -2849,13 +2872,13 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(int vector_dimension)
-      : vdim(vector_dimension) { }
+      : vdim(vector_dimension) {}
 
    VectorDiffusionIntegrator(Coefficient &q)
-      : Q(&q) { }
+      : Q(&q) {}
 
    VectorDiffusionIntegrator(Coefficient &q, const IntegrationRule *ir)
-      : BilinearFormIntegrator(ir), Q(&q) { }
+      : BilinearFormIntegrator(ir), Q(&q) {}
 
    /** \brief Integrator with scalar coefficient for caller-specified vector
        dimension.
@@ -2866,7 +2889,7 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(Coefficient &q, int vector_dimension)
-      : Q(&q), vdim(vector_dimension) { }
+      : Q(&q), vdim(vector_dimension) {}
 
    /** \brief Integrator with \c VectorCoefficient. The vector dimension of the
        \c FiniteElementSpace is assumed to be the same as the dimension of the
@@ -2878,7 +2901,7 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(VectorCoefficient &vq)
-      : VQ(&vq), vdim(vq.GetVDim()) { }
+      : VQ(&vq), vdim(vq.GetVDim()) {}
 
    /** \brief Integrator with \c MatrixCoefficient. The vector dimension of the
        \c FiniteElementSpace is assumed to be the same as the dimension of the
@@ -2890,21 +2913,30 @@ public:
        If the vector dimension does not match the true dimension of the space,
        the resulting element matrix will be mathematically invalid. */
    VectorDiffusionIntegrator(MatrixCoefficient& mq)
-      : MQ(&mq), vdim(mq.GetVDim()) { }
+      : MQ(&mq), vdim(mq.GetVDim()) {}
 
    virtual void AssembleElementMatrix(const FiniteElement &el,
                                       ElementTransformation &Trans,
                                       DenseMatrix &elmat);
+
    virtual void AssembleElementVector(const FiniteElement &el,
                                       ElementTransformation &Tr,
                                       const Vector &elfun, Vector &elvect);
+
    using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &fes);
-   virtual void AssembleMF(const FiniteElementSpace &fes);
+
    virtual void AssembleDiagonalPA(Vector &diag);
-   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
+   using BilinearFormIntegrator::AssembleMF;
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
+   virtual void AssembleDiagonalMF(Vector &diag);
+
    virtual void AddMultMF(const Vector &x, Vector &y) const;
+
    bool SupportsCeed() const { return DeviceCanUseCeed(); }
 };
 
@@ -2999,6 +3031,7 @@ protected:
    Coefficient *rho;
    VectorCoefficient *u;
    double alpha, beta;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;             ///< Not owned
@@ -3027,24 +3060,20 @@ public:
                                    FaceElementTransformations &Trans,
                                    DenseMatrix &elmat);
 
-   using BilinearFormIntegrator::AssemblePA;
-
    virtual void AssemblePAInteriorFaces(const FiniteElementSpace &fes);
 
    virtual void AssemblePABoundaryFaces(const FiniteElementSpace &fes);
 
-   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
+   virtual void AddMultPA(const Vector &x, Vector &y) const;
 
-   virtual void AddMultPA(const Vector&, Vector&) const;
+   virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    virtual void AssembleEAInteriorFaces(const FiniteElementSpace& fes,
                                         Vector &ea_data_int,
-                                        Vector &ea_data_ext,
-                                        const bool add);
+                                        Vector &ea_data_ext);
 
    virtual void AssembleEABoundaryFaces(const FiniteElementSpace& fes,
-                                        Vector &ea_data_bdr,
-                                        const bool add);
+                                        Vector &ea_data_bdr);
 
    static const IntegrationRule &GetRule(Geometry::Type geom, int order,
                                          FaceElementTransformations &T);
@@ -3067,14 +3096,14 @@ class NonconservativeDGTraceIntegrator : public TransposeIntegrator
 {
 public:
    NonconservativeDGTraceIntegrator(VectorCoefficient &u, double a)
-      : TransposeIntegrator(new DGTraceIntegrator(u, -a, 0.5*a)) { }
+      : TransposeIntegrator(new DGTraceIntegrator(u, -a, 0.5*a)) {}
 
    NonconservativeDGTraceIntegrator(VectorCoefficient &u, double a, double b)
-      : TransposeIntegrator(new DGTraceIntegrator(u, -a, b)) { }
+      : TransposeIntegrator(new DGTraceIntegrator(u, -a, b)) {}
 
    NonconservativeDGTraceIntegrator(Coefficient &rho, VectorCoefficient &u,
                                     double a, double b)
-      : TransposeIntegrator(new DGTraceIntegrator(rho, u, -a, b)) { }
+      : TransposeIntegrator(new DGTraceIntegrator(rho, u, -a, b)) {}
 };
 
 /** Integrator for the DG form:
@@ -3102,11 +3131,12 @@ protected:
 
 public:
    DGDiffusionIntegrator(const double s, const double k)
-      : Q(NULL), MQ(NULL), sigma(s), kappa(k) { }
+      : Q(NULL), MQ(NULL), sigma(s), kappa(k) {}
    DGDiffusionIntegrator(Coefficient &q, const double s, const double k)
-      : Q(&q), MQ(NULL), sigma(s), kappa(k) { }
+      : Q(&q), MQ(NULL), sigma(s), kappa(k) {}
    DGDiffusionIntegrator(MatrixCoefficient &q, const double s, const double k)
-      : Q(NULL), MQ(&q), sigma(s), kappa(k) { }
+      : Q(NULL), MQ(&q), sigma(s), kappa(k) {}
+
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
                                    const FiniteElement &el2,
@@ -3238,11 +3268,11 @@ class DGElasticityIntegrator : public BilinearFormIntegrator
 {
 public:
    DGElasticityIntegrator(double alpha_, double kappa_)
-      : lambda(NULL), mu(NULL), alpha(alpha_), kappa(kappa_) { }
+      : lambda(NULL), mu(NULL), alpha(alpha_), kappa(kappa_) {}
 
    DGElasticityIntegrator(Coefficient &lambda_, Coefficient &mu_,
                           double alpha_, double kappa_)
-      : lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) { }
+      : lambda(&lambda_), mu(&mu_), alpha(alpha_), kappa(kappa_) {}
 
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &el1,
@@ -3293,7 +3323,8 @@ private:
    Vector face_shape, shape1, shape2;
 
 public:
-   TraceJumpIntegrator() { }
+   TraceJumpIntegrator() {}
+
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
                                    const FiniteElement &test_fe1,
@@ -3312,7 +3343,8 @@ private:
    DenseMatrix shape1, shape2;
 
 public:
-   NormalTraceJumpIntegrator() { }
+   NormalTraceJumpIntegrator() {}
+
    using BilinearFormIntegrator::AssembleFaceMatrix;
    virtual void AssembleFaceMatrix(const FiniteElement &trial_face_fe,
                                    const FiniteElement &test_fe1,
@@ -3404,8 +3436,7 @@ public:
 
 /** Abstract class to serve as a base for local interpolators to be used in the
     DiscreteLinearOperator class. */
-class DiscreteInterpolator : public BilinearFormIntegrator { };
-
+class DiscreteInterpolator : public BilinearFormIntegrator {};
 
 /** Class for constructing the gradient as a DiscreteLinearOperator from an
     H1-conforming space to an H(curl)-conforming space. The range space can be
@@ -3413,7 +3444,7 @@ class DiscreteInterpolator : public BilinearFormIntegrator { };
 class GradientInterpolator : public DiscreteInterpolator
 {
 public:
-   GradientInterpolator() : dofquad_fe(NULL) { }
+   GradientInterpolator() : dofquad_fe(NULL) {}
    virtual ~GradientInterpolator() { delete dofquad_fe; }
 
    virtual void AssembleElementMatrix2(const FiniteElement &h1_fe,
@@ -3422,17 +3453,17 @@ public:
                                        DenseMatrix &elmat)
    { nd_fe.ProjectGrad(h1_fe, Trans, elmat); }
 
-   using BilinearFormIntegrator::AssemblePA;
-
    /** @brief Setup method for PA data.
 
        @param[in] trial_fes   H1 Lagrange space
        @param[in] test_fes    H(curl) Nedelec space
     */
+   using BilinearFormIntegrator::AssemblePA;
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
 private:
@@ -3445,7 +3476,6 @@ private:
    int dim, ne, o_dofs1D, c_dofs1D;
 };
 
-
 /** Class for constructing the identity map as a DiscreteLinearOperator. This
     is the discrete embedding matrix when the domain space is a subspace of
     the range space. Otherwise, a dof projection matrix is constructed. */
@@ -3461,11 +3491,11 @@ public:
    { ran_fe.Project(dom_fe, Trans, elmat); }
 
    using BilinearFormIntegrator::AssemblePA;
-
    virtual void AssemblePA(const FiniteElementSpace &trial_fes,
                            const FiniteElementSpace &test_fes);
 
    virtual void AddMultPA(const Vector &x, Vector &y) const;
+
    virtual void AddMultTransposePA(const Vector &x, Vector &y) const;
 
    virtual ~IdentityInterpolator() { delete dofquad_fe; }
@@ -3481,7 +3511,6 @@ private:
    Vector pa_data;
 };
 
-
 /** Class for constructing the (local) discrete curl matrix which can be used
     as an integrator in a DiscreteLinearOperator object to assemble the global
     discrete curl matrix. */
@@ -3495,7 +3524,6 @@ public:
    { ran_fe.ProjectCurl(dom_fe, Trans, elmat); }
 };
 
-
 /** Class for constructing the (local) discrete divergence matrix which can
     be used as an integrator in a DiscreteLinearOperator object to assemble
     the global discrete divergence matrix.
@@ -3514,7 +3542,6 @@ public:
    { ran_fe.ProjectDiv(dom_fe, Trans, elmat); }
 };
 
-
 /** A trace face interpolator class for interpolating the normal component of
     the domain space, e.g. vector H1, into the range space, e.g. the trace of
     RT which uses FiniteElement::INTEGRAL map type. */
@@ -3533,7 +3560,7 @@ public:
 class ScalarProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarProductInterpolator(Coefficient & sc) : Q(&sc) { }
+   ScalarProductInterpolator(Coefficient &sc) : Q(&sc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
@@ -3550,13 +3577,14 @@ protected:
 class ScalarVectorProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarVectorProductInterpolator(Coefficient & sc)
-      : Q(&sc) { }
+   ScalarVectorProductInterpolator(Coefficient &sc)
+      : Q(&sc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    Coefficient *Q;
 };
@@ -3567,13 +3595,14 @@ protected:
 class VectorScalarProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorScalarProductInterpolator(VectorCoefficient & vc)
-      : VQ(&vc) { }
+   VectorScalarProductInterpolator(VectorCoefficient &vc)
+      : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &dom_fe,
                                        const FiniteElement &ran_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
@@ -3583,13 +3612,14 @@ protected:
 class ScalarCrossProductInterpolator : public DiscreteInterpolator
 {
 public:
-   ScalarCrossProductInterpolator(VectorCoefficient & vc)
-      : VQ(&vc) { }
+   ScalarCrossProductInterpolator(VectorCoefficient &vc)
+      : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &nd_fe,
                                        const FiniteElement &l2_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
@@ -3600,13 +3630,14 @@ protected:
 class VectorCrossProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorCrossProductInterpolator(VectorCoefficient & vc)
-      : VQ(&vc) { }
+   VectorCrossProductInterpolator(VectorCoefficient &vc)
+      : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &nd_fe,
                                        const FiniteElement &rt_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
@@ -3617,12 +3648,13 @@ protected:
 class VectorInnerProductInterpolator : public DiscreteInterpolator
 {
 public:
-   VectorInnerProductInterpolator(VectorCoefficient & vc) : VQ(&vc) { }
+   VectorInnerProductInterpolator(VectorCoefficient &vc) : VQ(&vc) {}
 
    virtual void AssembleElementMatrix2(const FiniteElement &rt_fe,
                                        const FiniteElement &l2_fe,
                                        ElementTransformation &Trans,
                                        DenseMatrix &elmat);
+
 protected:
    VectorCoefficient *VQ;
 };
diff --git a/fem/ceed/interface/util.cpp b/fem/ceed/interface/util.cpp
index d122c2ab5..b65fd2197 100644
--- a/fem/ceed/interface/util.cpp
+++ b/fem/ceed/interface/util.cpp
@@ -217,7 +217,7 @@ const IntegrationRule & GetRule<ConvectionIntegrator>(
    const FiniteElement &test_fe,
    ElementTransformation &trans)
 {
-   return ConvectionIntegrator::GetRule(trial_fe, test_fe, trans);
+   return ConvectionIntegrator::GetRule(trial_fe, trans);
 }
 
 template <>
diff --git a/fem/fespace.cpp b/fem/fespace.cpp
index 2a1804eff..3934a5fe8 100644
--- a/fem/fespace.cpp
+++ b/fem/fespace.cpp
@@ -445,15 +445,6 @@ void FiniteElementSpace::BuildFaceToDofTable() const
    face_dof = fc_dof;
 }
 
-void FiniteElementSpace::RebuildElementToDofTable()
-{
-   delete elem_dof;
-   delete elem_fos;
-   elem_dof = NULL;
-   elem_fos = NULL;
-   BuildElementToDofTable();
-}
-
 void FiniteElementSpace::ReorderElementToDofTable()
 {
    Array<int> dof_marker(ndofs);
@@ -1273,7 +1264,7 @@ int FiniteElementSpace::GetNConformingDofs() const
    return P ? (P->Width() / vdim) : ndofs;
 }
 
-const ElementRestrictionOperator *FiniteElementSpace::GetElementRestriction(
+const ElementRestriction *FiniteElementSpace::GetElementRestriction(
    ElementDofOrdering e_ordering) const
 {
    // Check if we have a discontinuous space using the FE collection:
@@ -1288,22 +1279,22 @@ const ElementRestrictionOperator *FiniteElementSpace::GetElementRestriction(
          // The output E-vector layout is: ND x VDIM x NE.
          L2E_nat.Reset(new L2ElementRestriction(*this));
       }
-      return L2E_nat.Is<ElementRestrictionOperator>();
+      return L2E_nat.Is<ElementRestriction>();
    }
    if (e_ordering == ElementDofOrdering::LEXICOGRAPHIC)
    {
       if (L2E_lex.Ptr() == NULL)
       {
-         L2E_lex.Reset(new ElementRestriction(*this, e_ordering));
+         L2E_lex.Reset(new ConformingElementRestriction(*this, e_ordering));
       }
-      return L2E_lex.Is<ElementRestrictionOperator>();
+      return L2E_lex.Is<ElementRestriction>();
    }
    // e_ordering == ElementDofOrdering::NATIVE
    if (L2E_nat.Ptr() == NULL)
    {
-      L2E_nat.Reset(new ElementRestriction(*this, e_ordering));
+      L2E_nat.Reset(new ConformingElementRestriction(*this, e_ordering));
    }
-   return L2E_nat.Is<ElementRestrictionOperator>();
+   return L2E_nat.Is<ElementRestriction>();
 }
 
 const FaceRestriction *FiniteElementSpace::GetFaceRestriction(
diff --git a/fem/fespace.hpp b/fem/fespace.hpp
index e2c495506..9b3d2e70f 100644
--- a/fem/fespace.hpp
+++ b/fem/fespace.hpp
@@ -591,18 +591,6 @@ public:
    virtual const Operator *GetProlongationMatrix() const
    { return GetConformingProlongation(); }
 
-   /// Return an operator that performs the transpose of GetRestrictionOperator
-   /** The returned operator is owned by the FiniteElementSpace. In serial this
-       is the same as GetProlongationMatrix() */
-   virtual const Operator *GetRestrictionTransposeOperator() const
-   { return GetConformingProlongation(); }
-
-   /// An abstract operator that performs the same action as GetRestrictionMatrix
-   /** In some cases this is an optimized matrix-free implementation. The
-       returned operator is owned by the FiniteElementSpace. */
-   virtual const Operator *GetRestrictionOperator() const
-   { return GetConformingRestriction(); }
-
    /// The returned SparseMatrix is owned by the FiniteElementSpace.
    virtual const SparseMatrix *GetRestrictionMatrix() const
    { return GetConformingRestriction(); }
@@ -628,7 +616,7 @@ public:
        L2ElementRestriction class.
 
        The returned Operator is owned by the FiniteElementSpace. */
-   const ElementRestrictionOperator *GetElementRestriction(
+   const ElementRestriction *GetElementRestriction(
       ElementDofOrdering e_ordering) const;
 
    /// Return an Operator that converts L-vectors to E-vectors on each face.
@@ -1061,9 +1049,6 @@ public:
    void GetEdgeInteriorVDofs(int i, Array<int> &vdofs) const;
    /// @}
 
-   /// (@deprecated) Use the Update() method if the space or mesh changed.
-   MFEM_DEPRECATED void RebuildElementToDofTable();
-
    /** @brief Reorder the scalar DOFs based on the element ordering.
 
        The new ordering is constructed as follows: 1) loop over all elements as
diff --git a/fem/integ/bilininteg_convection_ea.cpp b/fem/integ/bilininteg_convection_ea.cpp
index b2dba388a..08422ce86 100644
--- a/fem/integ/bilininteg_convection_ea.cpp
+++ b/fem/integ/bilininteg_convection_ea.cpp
@@ -22,7 +22,6 @@ static void EAConvectionAssemble1D(const int NE,
                                    const Array<double> &g,
                                    const Vector &padata,
                                    Vector &eadata,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -55,14 +54,7 @@ static void EAConvectionAssemble1D(const int NE,
             {
                val += r_Bj[k1] * D(k1, e) * r_Gi[k1];
             }
-            if (add)
-            {
-               A(i1, j1, e) += val;
-            }
-            else
-            {
-               A(i1, j1, e) = val;
-            }
+            A(i1, j1, e) += val;
          }
       }
    });
@@ -74,7 +66,6 @@ static void EAConvectionAssemble2D(const int NE,
                                    const Array<double> &g,
                                    const Vector &padata,
                                    Vector &eadata,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -130,14 +121,7 @@ static void EAConvectionAssemble2D(const int NE,
                                * r_B[k1][j1]* r_B[k2][j2];
                      }
                   }
-                  if (add)
-                  {
-                     A(i1, i2, j1, j2, e) += val;
-                  }
-                  else
-                  {
-                     A(i1, i2, j1, j2, e) = val;
-                  }
+                  A(i1, i2, j1, j2, e) += val;
                }
             }
          }
@@ -151,7 +135,6 @@ static void EAConvectionAssemble3D(const int NE,
                                    const Array<double> &g,
                                    const Vector &padata,
                                    Vector &eadata,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -208,14 +191,7 @@ static void EAConvectionAssemble3D(const int NE,
                               }
                            }
                         }
-                        if (add)
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) += val;
-                        }
-                        else
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) = val;
-                        }
+                        A(i1, i2, i3, j1, j2, j3, e) += val;
                      }
                   }
                }
@@ -226,8 +202,7 @@ static void EAConvectionAssemble3D(const int NE,
 }
 
 void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                      Vector &ea_data,
-                                      const bool add)
+                                      Vector &ea_data)
 {
    AssemblePA(fes);
    ne = fes.GetMesh()->GetNE();
@@ -237,15 +212,15 @@ void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAConvectionAssemble1D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EAConvectionAssemble1D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EAConvectionAssemble1D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EAConvectionAssemble1D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EAConvectionAssemble1D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EAConvectionAssemble1D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EAConvectionAssemble1D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EAConvectionAssemble1D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EAConvectionAssemble1D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EAConvectionAssemble1D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EAConvectionAssemble1D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EAConvectionAssemble1D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EAConvectionAssemble1D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EAConvectionAssemble1D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EAConvectionAssemble1D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EAConvectionAssemble1D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EAConvectionAssemble1D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EAConvectionAssemble1D(ne,B,G,pa_data,ea_data,
                                                      dofs1D,quad1D);
       }
    }
@@ -253,15 +228,15 @@ void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAConvectionAssemble2D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EAConvectionAssemble2D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EAConvectionAssemble2D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EAConvectionAssemble2D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EAConvectionAssemble2D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EAConvectionAssemble2D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EAConvectionAssemble2D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EAConvectionAssemble2D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EAConvectionAssemble2D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EAConvectionAssemble2D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EAConvectionAssemble2D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EAConvectionAssemble2D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EAConvectionAssemble2D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EAConvectionAssemble2D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EAConvectionAssemble2D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EAConvectionAssemble2D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EAConvectionAssemble2D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EAConvectionAssemble2D(ne,B,G,pa_data,ea_data,
                                                      dofs1D,quad1D);
       }
    }
@@ -269,14 +244,14 @@ void ConvectionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EAConvectionAssemble3D<2,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x34: return EAConvectionAssemble3D<3,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x45: return EAConvectionAssemble3D<4,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x56: return EAConvectionAssemble3D<5,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x67: return EAConvectionAssemble3D<6,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x78: return EAConvectionAssemble3D<7,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x89: return EAConvectionAssemble3D<8,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EAConvectionAssemble3D(ne,B,G,pa_data,ea_data,add,
+         case 0x23: return EAConvectionAssemble3D<2,3>(ne,B,G,pa_data,ea_data);
+         case 0x34: return EAConvectionAssemble3D<3,4>(ne,B,G,pa_data,ea_data);
+         case 0x45: return EAConvectionAssemble3D<4,5>(ne,B,G,pa_data,ea_data);
+         case 0x56: return EAConvectionAssemble3D<5,6>(ne,B,G,pa_data,ea_data);
+         case 0x67: return EAConvectionAssemble3D<6,7>(ne,B,G,pa_data,ea_data);
+         case 0x78: return EAConvectionAssemble3D<7,8>(ne,B,G,pa_data,ea_data);
+         case 0x89: return EAConvectionAssemble3D<8,9>(ne,B,G,pa_data,ea_data);
+         default:   return EAConvectionAssemble3D(ne,B,G,pa_data,ea_data,
                                                      dofs1D,quad1D);
       }
    }
diff --git a/fem/integ/bilininteg_convection_pa.cpp b/fem/integ/bilininteg_convection_pa.cpp
index 7bfd65059..25928f002 100644
--- a/fem/integ/bilininteg_convection_pa.cpp
+++ b/fem/integ/bilininteg_convection_pa.cpp
@@ -112,26 +112,6 @@ static void PAConvectionSetup3D(const int NQ,
    });
 }
 
-static void PAConvectionSetup(const int dim,
-                              const int NQ,
-                              const int NE,
-                              const Array<double> &W,
-                              const Vector &J,
-                              const Vector &coeff,
-                              const double alpha,
-                              Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PAConvectionSetup"); }
-   if (dim == 2)
-   {
-      PAConvectionSetup2D(NQ, NE, W, J, coeff, alpha, op);
-   }
-   if (dim == 3)
-   {
-      PAConvectionSetup3D(NQ, NE, W, J, coeff, alpha, op);
-   }
-}
-
 void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
@@ -170,8 +150,20 @@ void ConvectionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    QuadratureSpace qs(*mesh, *ir);
    CoefficientVector vel(*Q, qs, CoefficientStorage::COMPRESSED);
 
-   PAConvectionSetup(dim, nq, ne, ir->GetWeights(), geom->J,
-                     vel, alpha, pa_data);
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in ConvectionIntegrator::AssemblePA");
+   }
+   else if (dim == 2)
+   {
+      PAConvectionSetup2D(nq, ne, ir->GetWeights(), geom->J,
+                          vel, alpha, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PAConvectionSetup3D(nq, ne, ir->GetWeights(), geom->J,
+                          vel, alpha, pa_data);
+   }
 }
 
 void ConvectionIntegrator::AssembleDiagonalPA(Vector &diag)
@@ -188,17 +180,17 @@ void ConvectionIntegrator::AssembleDiagonalPA(Vector &diag)
 }
 
 // PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApply2D(const int ne,
-                         const Array<double> &b,
-                         const Array<double> &g,
-                         const Array<double> &bt,
-                         const Array<double> &gt,
-                         const Vector &op_,
-                         const Vector &x_,
-                         Vector &y_,
-                         const int d1d = 0,
-                         const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApply2D(const int ne,
+                                const Array<double> &b,
+                                const Array<double> &g,
+                                const Array<double> &bt,
+                                const Array<double> &gt,
+                                const Vector &op_,
+                                const Vector &x_,
+                                Vector &y_,
+                                const int d1d = 0,
+                                const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -307,17 +299,17 @@ void PAConvectionApply2D(const int ne,
 }
 
 // Optimized PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPAConvectionApply2D(const int ne,
-                             const Array<double> &b,
-                             const Array<double> &g,
-                             const Array<double> &bt,
-                             const Array<double> &gt,
-                             const Vector &op_,
-                             const Vector &x_,
-                             Vector &y_,
-                             const int d1d = 0,
-                             const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPAConvectionApply2D(const int ne,
+                                    const Array<double> &b,
+                                    const Array<double> &g,
+                                    const Array<double> &bt,
+                                    const Array<double> &gt,
+                                    const Vector &op_,
+                                    const Vector &x_,
+                                    Vector &y_,
+                                    const int d1d = 0,
+                                    const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -435,17 +427,17 @@ void SmemPAConvectionApply2D(const int ne,
 }
 
 // PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApply3D(const int ne,
-                         const Array<double> &b,
-                         const Array<double> &g,
-                         const Array<double> &bt,
-                         const Array<double> &gt,
-                         const Vector &op_,
-                         const Vector &x_,
-                         Vector &y_,
-                         const int d1d = 0,
-                         const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApply3D(const int ne,
+                                const Array<double> &b,
+                                const Array<double> &g,
+                                const Array<double> &bt,
+                                const Array<double> &gt,
+                                const Vector &op_,
+                                const Vector &x_,
+                                Vector &y_,
+                                const int d1d = 0,
+                                const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -616,17 +608,17 @@ void PAConvectionApply3D(const int ne,
 }
 
 // Optimized PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void SmemPAConvectionApply3D(const int ne,
-                             const Array<double> &b,
-                             const Array<double> &g,
-                             const Array<double> &bt,
-                             const Array<double> &gt,
-                             const Vector &op_,
-                             const Vector &x_,
-                             Vector &y_,
-                             const int d1d = 0,
-                             const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void SmemPAConvectionApply3D(const int ne,
+                                    const Array<double> &b,
+                                    const Array<double> &g,
+                                    const Array<double> &bt,
+                                    const Array<double> &gt,
+                                    const Vector &op_,
+                                    const Vector &x_,
+                                    Vector &y_,
+                                    const int d1d = 0,
+                                    const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -820,17 +812,17 @@ void SmemPAConvectionApply3D(const int ne,
 }
 
 // PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApplyT2D(const int ne,
-                          const Array<double> &b,
-                          const Array<double> &g,
-                          const Array<double> &bt,
-                          const Array<double> &gt,
-                          const Vector &op_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApplyT2D(const int ne,
+                                 const Array<double> &b,
+                                 const Array<double> &g,
+                                 const Array<double> &bt,
+                                 const Array<double> &gt,
+                                 const Vector &op_,
+                                 const Vector &x_,
+                                 Vector &y_,
+                                 const int d1d = 0,
+                                 const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -935,17 +927,17 @@ void PAConvectionApplyT2D(const int ne,
 }
 
 // Optimized PA Convection Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPAConvectionApplyT2D(const int ne,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &op_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPAConvectionApplyT2D(const int ne,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &op_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     const int d1d = 0,
+                                     const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -1058,17 +1050,17 @@ void SmemPAConvectionApplyT2D(const int ne,
 }
 
 // PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PAConvectionApplyT3D(const int ne,
-                          const Array<double> &b,
-                          const Array<double> &g,
-                          const Array<double> &bt,
-                          const Array<double> &gt,
-                          const Vector &op_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PAConvectionApplyT3D(const int ne,
+                                 const Array<double> &b,
+                                 const Array<double> &g,
+                                 const Array<double> &bt,
+                                 const Array<double> &gt,
+                                 const Vector &op_,
+                                 const Vector &x_,
+                                 Vector &y_,
+                                 const int d1d = 0,
+                                 const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -1234,17 +1226,17 @@ void PAConvectionApplyT3D(const int ne,
 }
 
 // Optimized PA Convection Apply 3D kernel
-template<int T_D1D = 0, int T_Q1D = 0> static
-void SmemPAConvectionApplyT3D(const int ne,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &op_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void SmemPAConvectionApplyT3D(const int ne,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &op_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     const int d1d = 0,
+                                     const int q1d = 0)
 {
    const int NE = ne;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -1549,7 +1541,7 @@ void ConvectionIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
    {
-      MFEM_ABORT("AddMultPA not yet implemented with libCEED for"
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
                  " ConvectionIntegrator.");
    }
    else
diff --git a/fem/integ/bilininteg_dgtrace_ea.cpp b/fem/integ/bilininteg_dgtrace_ea.cpp
index 695820489..602c266ab 100644
--- a/fem/integ/bilininteg_dgtrace_ea.cpp
+++ b/fem/integ/bilininteg_dgtrace_ea.cpp
@@ -20,8 +20,7 @@ static void EADGTraceAssemble1DInt(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
                                    Vector &eadata_int,
-                                   Vector &eadata_ext,
-                                   const bool add)
+                                   Vector &eadata_ext)
 {
    auto D = Reshape(padata.Read(), 2, 2, NF);
    auto A_int = Reshape(eadata_int.ReadWrite(), 2, NF);
@@ -33,41 +32,23 @@ static void EADGTraceAssemble1DInt(const int NF,
       val_ext10 = D(1, 0, f);
       val_ext01 = D(0, 1, f);
       val_int1  = D(1, 1, f);
-      if (add)
-      {
-         A_int(0, f) += val_int0;
-         A_int(1, f) += val_int1;
-         A_ext(0, f) += val_ext01;
-         A_ext(1, f) += val_ext10;
-      }
-      else
-      {
-         A_int(0, f) = val_int0;
-         A_int(1, f) = val_int1;
-         A_ext(0, f) = val_ext01;
-         A_ext(1, f) = val_ext10;
-      }
+      A_int(0, f) += val_int0;
+      A_int(1, f) += val_int1;
+      A_ext(0, f) += val_ext01;
+      A_ext(1, f) += val_ext10;
    });
 }
 
 static void EADGTraceAssemble1DBdr(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
-                                   Vector &eadata_bdr,
-                                   const bool add)
+                                   Vector &eadata_bdr)
 {
    auto D = Reshape(padata.Read(), 2, 2, NF);
    auto A_bdr = Reshape(eadata_bdr.ReadWrite(), NF);
    mfem::forall(NF, [=] MFEM_HOST_DEVICE (int f)
    {
-      if (add)
-      {
-         A_bdr(f) += D(0, 0, f);
-      }
-      else
-      {
-         A_bdr(f) = D(0, 0, f);
-      }
+      A_bdr(f) += D(0, 0, f);
    });
 }
 
@@ -77,7 +58,6 @@ static void EADGTraceAssemble2DInt(const int NF,
                                    const Vector &padata,
                                    Vector &eadata_int,
                                    Vector &eadata_ext,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -108,20 +88,10 @@ static void EADGTraceAssemble2DInt(const int NF,
                val_ext10 += B(k1,i1) * B(k1,j1) * D(k1, 1, 0, f);
                val_int1  += B(k1,i1) * B(k1,j1) * D(k1, 1, 1, f);
             }
-            if (add)
-            {
-               A_int(i1, j1, 0, f) += val_int0;
-               A_int(i1, j1, 1, f) += val_int1;
-               A_ext(i1, j1, 0, f) += val_ext01;
-               A_ext(i1, j1, 1, f) += val_ext10;
-            }
-            else
-            {
-               A_int(i1, j1, 0, f) = val_int0;
-               A_int(i1, j1, 1, f) = val_int1;
-               A_ext(i1, j1, 0, f) = val_ext01;
-               A_ext(i1, j1, 1, f) = val_ext10;
-            }
+            A_int(i1, j1, 0, f) += val_int0;
+            A_int(i1, j1, 1, f) += val_int1;
+            A_ext(i1, j1, 0, f) += val_ext01;
+            A_ext(i1, j1, 1, f) += val_ext10;
          }
       }
    });
@@ -132,7 +102,6 @@ static void EADGTraceAssemble2DBdr(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
                                    Vector &eadata_bdr,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -156,14 +125,7 @@ static void EADGTraceAssemble2DBdr(const int NF,
             {
                val_bdr  += B(k1,i1) * B(k1,j1) * D(k1, 0, 0, f);
             }
-            if (add)
-            {
-               A_bdr(i1, j1, f) += val_bdr;
-            }
-            else
-            {
-               A_bdr(i1, j1, f) = val_bdr;
-            }
+            A_bdr(i1, j1, f) += val_bdr;
          }
       }
    });
@@ -175,7 +137,6 @@ static void EADGTraceAssemble3DInt(const int NF,
                                    const Vector &padata,
                                    Vector &eadata_int,
                                    Vector &eadata_ext,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -246,20 +207,10 @@ static void EADGTraceAssemble3DInt(const int NF,
                                     * s_D[k1][k2][1][0];
                      }
                   }
-                  if (add)
-                  {
-                     A_int(i1, i2, j1, j2, 0, f) += val_int0;
-                     A_int(i1, i2, j1, j2, 1, f) += val_int1;
-                     A_ext(i1, i2, j1, j2, 0, f) += val_ext01;
-                     A_ext(i1, i2, j1, j2, 1, f) += val_ext10;
-                  }
-                  else
-                  {
-                     A_int(i1, i2, j1, j2, 0, f) = val_int0;
-                     A_int(i1, i2, j1, j2, 1, f) = val_int1;
-                     A_ext(i1, i2, j1, j2, 0, f) = val_ext01;
-                     A_ext(i1, i2, j1, j2, 1, f) = val_ext10;
-                  }
+                  A_int(i1, i2, j1, j2, 0, f) += val_int0;
+                  A_int(i1, i2, j1, j2, 1, f) += val_int1;
+                  A_ext(i1, i2, j1, j2, 0, f) += val_ext01;
+                  A_ext(i1, i2, j1, j2, 1, f) += val_ext10;
                }
             }
          }
@@ -272,7 +223,6 @@ static void EADGTraceAssemble3DBdr(const int NF,
                                    const Array<double> &basis,
                                    const Vector &padata,
                                    Vector &eadata_bdr,
-                                   const bool add,
                                    const int d1d = 0,
                                    const int q1d = 0)
 {
@@ -330,14 +280,7 @@ static void EADGTraceAssemble3DBdr(const int NF,
                                    * s_D[k1][k2][0][0];
                      }
                   }
-                  if (add)
-                  {
-                     A_bdr(i1, i2, j1, j2, f) += val_bdr;
-                  }
-                  else
-                  {
-                     A_bdr(i1, i2, j1, j2, f) = val_bdr;
-                  }
+                  A_bdr(i1, i2, j1, j2, f) += val_bdr;
                }
             }
          }
@@ -347,8 +290,7 @@ static void EADGTraceAssemble3DBdr(const int NF,
 
 void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
                                                 Vector &ea_data_int,
-                                                Vector &ea_data_ext,
-                                                const bool add)
+                                                Vector &ea_data_ext)
 {
    SetupPA(fes, FaceType::Interior);
    nf = fes.GetNFbyType(FaceType::Interior);
@@ -356,7 +298,7 @@ void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
    const Array<double> &B = maps->B;
    if (dim == 1)
    {
-      return EADGTraceAssemble1DInt(nf,B,pa_data,ea_data_int,ea_data_ext,add);
+      return EADGTraceAssemble1DInt(nf,B,pa_data,ea_data_int,ea_data_ext);
    }
    else if (dim == 2)
    {
@@ -364,31 +306,31 @@ void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
       {
          case 0x22:
             return EADGTraceAssemble2DInt<2,2>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x33:
             return EADGTraceAssemble2DInt<3,3>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x44:
             return EADGTraceAssemble2DInt<4,4>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x55:
             return EADGTraceAssemble2DInt<5,5>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x66:
             return EADGTraceAssemble2DInt<6,6>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x77:
             return EADGTraceAssemble2DInt<7,7>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x88:
             return EADGTraceAssemble2DInt<8,8>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x99:
             return EADGTraceAssemble2DInt<9,9>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          default:
             return EADGTraceAssemble2DInt(nf,B,pa_data,ea_data_int,
-                                          ea_data_ext,add,dofs1D,quad1D);
+                                          ea_data_ext,dofs1D,quad1D);
       }
    }
    else if (dim == 3)
@@ -397,36 +339,35 @@ void DGTraceIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
       {
          case 0x23:
             return EADGTraceAssemble3DInt<2,3>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x34:
             return EADGTraceAssemble3DInt<3,4>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x45:
             return EADGTraceAssemble3DInt<4,5>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x56:
             return EADGTraceAssemble3DInt<5,6>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x67:
             return EADGTraceAssemble3DInt<6,7>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x78:
             return EADGTraceAssemble3DInt<7,8>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          case 0x89:
             return EADGTraceAssemble3DInt<8,9>(nf,B,pa_data,ea_data_int,
-                                               ea_data_ext,add);
+                                               ea_data_ext);
          default:
             return EADGTraceAssemble3DInt(nf,B,pa_data,ea_data_int,
-                                          ea_data_ext,add,dofs1D,quad1D);
+                                          ea_data_ext,dofs1D,quad1D);
       }
    }
    MFEM_ABORT("Unknown kernel.");
 }
 
 void DGTraceIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace& fes,
-                                                Vector &ea_data_bdr,
-                                                const bool add)
+                                                Vector &ea_data_bdr)
 {
    SetupPA(fes, FaceType::Boundary);
    nf = fes.GetNFbyType(FaceType::Boundary);
@@ -434,37 +375,37 @@ void DGTraceIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace& fes,
    const Array<double> &B = maps->B;
    if (dim == 1)
    {
-      return EADGTraceAssemble1DBdr(nf,B,pa_data,ea_data_bdr,add);
+      return EADGTraceAssemble1DBdr(nf,B,pa_data,ea_data_bdr);
    }
    else if (dim == 2)
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EADGTraceAssemble2DBdr<2,2>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x33: return EADGTraceAssemble2DBdr<3,3>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x44: return EADGTraceAssemble2DBdr<4,4>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x55: return EADGTraceAssemble2DBdr<5,5>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x66: return EADGTraceAssemble2DBdr<6,6>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x77: return EADGTraceAssemble2DBdr<7,7>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x88: return EADGTraceAssemble2DBdr<8,8>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x99: return EADGTraceAssemble2DBdr<9,9>(nf,B,pa_data,ea_data_bdr,add);
+         case 0x22: return EADGTraceAssemble2DBdr<2,2>(nf,B,pa_data,ea_data_bdr);
+         case 0x33: return EADGTraceAssemble2DBdr<3,3>(nf,B,pa_data,ea_data_bdr);
+         case 0x44: return EADGTraceAssemble2DBdr<4,4>(nf,B,pa_data,ea_data_bdr);
+         case 0x55: return EADGTraceAssemble2DBdr<5,5>(nf,B,pa_data,ea_data_bdr);
+         case 0x66: return EADGTraceAssemble2DBdr<6,6>(nf,B,pa_data,ea_data_bdr);
+         case 0x77: return EADGTraceAssemble2DBdr<7,7>(nf,B,pa_data,ea_data_bdr);
+         case 0x88: return EADGTraceAssemble2DBdr<8,8>(nf,B,pa_data,ea_data_bdr);
+         case 0x99: return EADGTraceAssemble2DBdr<9,9>(nf,B,pa_data,ea_data_bdr);
          default:
-            return EADGTraceAssemble2DBdr(nf,B,pa_data,ea_data_bdr,add,dofs1D,quad1D);
+            return EADGTraceAssemble2DBdr(nf,B,pa_data,ea_data_bdr,dofs1D,quad1D);
       }
    }
    else if (dim == 3)
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EADGTraceAssemble3DBdr<2,3>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x34: return EADGTraceAssemble3DBdr<3,4>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x45: return EADGTraceAssemble3DBdr<4,5>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x56: return EADGTraceAssemble3DBdr<5,6>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x67: return EADGTraceAssemble3DBdr<6,7>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x78: return EADGTraceAssemble3DBdr<7,8>(nf,B,pa_data,ea_data_bdr,add);
-         case 0x89: return EADGTraceAssemble3DBdr<8,9>(nf,B,pa_data,ea_data_bdr,add);
+         case 0x23: return EADGTraceAssemble3DBdr<2,3>(nf,B,pa_data,ea_data_bdr);
+         case 0x34: return EADGTraceAssemble3DBdr<3,4>(nf,B,pa_data,ea_data_bdr);
+         case 0x45: return EADGTraceAssemble3DBdr<4,5>(nf,B,pa_data,ea_data_bdr);
+         case 0x56: return EADGTraceAssemble3DBdr<5,6>(nf,B,pa_data,ea_data_bdr);
+         case 0x67: return EADGTraceAssemble3DBdr<6,7>(nf,B,pa_data,ea_data_bdr);
+         case 0x78: return EADGTraceAssemble3DBdr<7,8>(nf,B,pa_data,ea_data_bdr);
+         case 0x89: return EADGTraceAssemble3DBdr<8,9>(nf,B,pa_data,ea_data_bdr);
          default:
-            return EADGTraceAssemble3DBdr(nf,B,pa_data,ea_data_bdr,add,dofs1D,quad1D);
+            return EADGTraceAssemble3DBdr(nf,B,pa_data,ea_data_bdr,dofs1D,quad1D);
       }
    }
    MFEM_ABORT("Unknown kernel.");
diff --git a/fem/integ/bilininteg_dgtrace_pa.cpp b/fem/integ/bilininteg_dgtrace_pa.cpp
index 17dbc3994..f4b8d837c 100644
--- a/fem/integ/bilininteg_dgtrace_pa.cpp
+++ b/fem/integ/bilininteg_dgtrace_pa.cpp
@@ -110,30 +110,6 @@ static void PADGTraceSetup3D(const int Q1D,
    });
 }
 
-static void PADGTraceSetup(const int dim,
-                           const int D1D,
-                           const int Q1D,
-                           const int NF,
-                           const Array<double> &W,
-                           const Vector &det,
-                           const Vector &nor,
-                           const Vector &rho,
-                           const Vector &u,
-                           const double alpha,
-                           const double beta,
-                           Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PADGTraceSetup"); }
-   if (dim == 2)
-   {
-      PADGTraceSetup2D(Q1D, NF, W, det, nor, rho, u, alpha, beta, op);
-   }
-   if (dim == 3)
-   {
-      PADGTraceSetup3D(Q1D, NF, W, det, nor, rho, u, alpha, beta, op);
-   }
-}
-
 void DGTraceIntegrator::SetupPA(const FiniteElementSpace &fes, FaceType type)
 {
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
@@ -229,9 +205,21 @@ void DGTraceIntegrator::SetupPA(const FiniteElementSpace &fes, FaceType type)
       }
       MFEM_VERIFY(f_ind==nf, "Incorrect number of faces.");
    }
-   PADGTraceSetup(dim, dofs1D, quad1D, nf, ir->GetWeights(),
-                  geom->detJ, geom->normal, r, vel,
-                  alpha, beta, pa_data);
+
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in DGTraceIntegrator::SetupPA");
+   }
+   else if (dim == 2)
+   {
+      PADGTraceSetup2D(quad1D, nf, ir->GetWeights(), geom->detJ, geom->normal,
+                       r, vel, alpha, beta, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PADGTraceSetup3D(quad1D, nf, ir->GetWeights(), geom->detJ, geom->normal,
+                       r, vel, alpha, beta, pa_data);
+   }
 }
 
 void DGTraceIntegrator::AssemblePAInteriorFaces(const FiniteElementSpace& fes)
@@ -245,15 +233,15 @@ void DGTraceIntegrator::AssemblePABoundaryFaces(const FiniteElementSpace& fes)
 }
 
 // PA DGTrace Apply 2D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApply2D(const int NF,
-                      const Array<double> &b,
-                      const Array<double> &bt,
-                      const Vector &op_,
-                      const Vector &x_,
-                      Vector &y_,
-                      const int d1d = 0,
-                      const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApply2D(const int NF,
+                             const Array<double> &b,
+                             const Array<double> &bt,
+                             const Vector &op_,
+                             const Vector &x_,
+                             Vector &y_,
+                             const int d1d = 0,
+                             const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -336,15 +324,15 @@ void PADGTraceApply2D(const int NF,
 }
 
 // PA DGTrace Apply 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApply3D(const int NF,
-                      const Array<double> &b,
-                      const Array<double> &bt,
-                      const Vector &op_,
-                      const Vector &x_,
-                      Vector &y_,
-                      const int d1d = 0,
-                      const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApply3D(const int NF,
+                             const Array<double> &b,
+                             const Array<double> &bt,
+                             const Vector &op_,
+                             const Vector &x_,
+                             Vector &y_,
+                             const int d1d = 0,
+                             const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -481,15 +469,15 @@ void PADGTraceApply3D(const int NF,
 }
 
 // Optimized PA DGTrace Apply 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPADGTraceApply3D(const int NF,
-                          const Array<double> &b,
-                          const Array<double> &bt,
-                          const Vector &op_,
-                          const Vector &x_,
-                          Vector &y_,
-                          const int d1d = 0,
-                          const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPADGTraceApply3D(const int NF,
+                                 const Array<double> &b,
+                                 const Array<double> &bt,
+                                 const Vector &op_,
+                                 const Vector &x_,
+                                 Vector &y_,
+                                 const int d1d = 0,
+                                 const int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -646,15 +634,15 @@ static void PADGTraceApply(const int dim,
 }
 
 // PA DGTrace Apply 2D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApplyTranspose2D(const int NF,
-                               const Array<double> &b,
-                               const Array<double> &bt,
-                               const Vector &op_,
-                               const Vector &x_,
-                               Vector &y_,
-                               const int d1d = 0,
-                               const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApplyTranspose2D(const int NF,
+                                      const Array<double> &b,
+                                      const Array<double> &bt,
+                                      const Vector &op_,
+                                      const Vector &x_,
+                                      Vector &y_,
+                                      const int d1d = 0,
+                                      const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -742,15 +730,15 @@ void PADGTraceApplyTranspose2D(const int NF,
 }
 
 // PA DGTrace Apply Transpose 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0> static
-void PADGTraceApplyTranspose3D(const int NF,
-                               const Array<double> &b,
-                               const Array<double> &bt,
-                               const Vector &op_,
-                               const Vector &x_,
-                               Vector &y_,
-                               const int d1d = 0,
-                               const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void PADGTraceApplyTranspose3D(const int NF,
+                                      const Array<double> &b,
+                                      const Array<double> &bt,
+                                      const Vector &op_,
+                                      const Vector &x_,
+                                      Vector &y_,
+                                      const int d1d = 0,
+                                      const int q1d = 0)
 {
    const int VDIM = 1;
    const int D1D = T_D1D ? T_D1D : d1d;
@@ -898,15 +886,15 @@ void PADGTraceApplyTranspose3D(const int NF,
 }
 
 // Optimized PA DGTrace Apply Transpose 3D kernel for Gauss-Lobatto/Bernstein
-template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0> static
-void SmemPADGTraceApplyTranspose3D(const int NF,
-                                   const Array<double> &b,
-                                   const Array<double> &bt,
-                                   const Vector &op_,
-                                   const Vector &x_,
-                                   Vector &y_,
-                                   const int d1d = 0,
-                                   const int q1d = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_NBZ = 0>
+static void SmemPADGTraceApplyTranspose3D(const int NF,
+                                          const Array<double> &b,
+                                          const Array<double> &bt,
+                                          const Vector &op_,
+                                          const Vector &x_,
+                                          Vector &y_,
+                                          const int d1d = 0,
+                                          const int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -1075,7 +1063,6 @@ static void PADGTraceApplyTranspose(const int dim,
    MFEM_ABORT("Unknown kernel.");
 }
 
-// PA DGTraceIntegrator Apply kernel
 void DGTraceIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    PADGTraceApply(dim, dofs1D, quad1D, nf,
diff --git a/fem/integ/bilininteg_diffusion_ea.cpp b/fem/integ/bilininteg_diffusion_ea.cpp
index 0e59b33f9..aa36233c4 100644
--- a/fem/integ/bilininteg_diffusion_ea.cpp
+++ b/fem/integ/bilininteg_diffusion_ea.cpp
@@ -22,7 +22,6 @@ static void EADiffusionAssemble1D(const int NE,
                                   const Array<double> &g,
                                   const Vector &padata,
                                   Vector &eadata,
-                                  const bool add,
                                   const int d1d = 0,
                                   const int q1d = 0)
 {
@@ -54,14 +53,7 @@ static void EADiffusionAssemble1D(const int NE,
             {
                val += r_Gj[k1] * D(k1, e) * r_Gi[k1];
             }
-            if (add)
-            {
-               A(i1, j1, e) += val;
-            }
-            else
-            {
-               A(i1, j1, e) = val;
-            }
+            A(i1, j1, e) += val;
          }
       }
    });
@@ -73,7 +65,6 @@ static void EADiffusionAssemble2D(const int NE,
                                   const Array<double> &g,
                                   const Vector &padata,
                                   Vector &eadata,
-                                  const bool add,
                                   const int d1d = 0,
                                   const int q1d = 0)
 {
@@ -129,14 +120,7 @@ static void EADiffusionAssemble2D(const int NE,
                                + gbi * D11 * gbj;
                      }
                   }
-                  if (add)
-                  {
-                     A(i1, i2, j1, j2, e) += val;
-                  }
-                  else
-                  {
-                     A(i1, i2, j1, j2, e) = val;
-                  }
+                  A(i1, i2, j1, j2, e) += val;
                }
             }
          }
@@ -150,7 +134,6 @@ static void EADiffusionAssemble3D(const int NE,
                                   const Array<double> &g,
                                   const Vector &padata,
                                   Vector &eadata,
-                                  const bool add,
                                   const int d1d = 0,
                                   const int q1d = 0)
 {
@@ -225,14 +208,7 @@ static void EADiffusionAssemble3D(const int NE,
                               }
                            }
                         }
-                        if (add)
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) += val;
-                        }
-                        else
-                        {
-                           A(i1, i2, i3, j1, j2, j3, e) = val;
-                        }
+                        A(i1, i2, i3, j1, j2, j3, e) += val;
                      }
                   }
                }
@@ -243,8 +219,7 @@ static void EADiffusionAssemble3D(const int NE,
 }
 
 void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                     Vector &ea_data,
-                                     const bool add)
+                                     Vector &ea_data)
 {
    AssemblePA(fes);
    ne = fes.GetMesh()->GetNE();
@@ -254,15 +229,15 @@ void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EADiffusionAssemble1D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EADiffusionAssemble1D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EADiffusionAssemble1D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EADiffusionAssemble1D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EADiffusionAssemble1D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EADiffusionAssemble1D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EADiffusionAssemble1D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EADiffusionAssemble1D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EADiffusionAssemble1D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EADiffusionAssemble1D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EADiffusionAssemble1D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EADiffusionAssemble1D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EADiffusionAssemble1D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EADiffusionAssemble1D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EADiffusionAssemble1D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EADiffusionAssemble1D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EADiffusionAssemble1D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EADiffusionAssemble1D(ne,B,G,pa_data,ea_data,
                                                     dofs1D,quad1D);
       }
    }
@@ -270,15 +245,15 @@ void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EADiffusionAssemble2D<2,2>(ne,B,G,pa_data,ea_data,add);
-         case 0x33: return EADiffusionAssemble2D<3,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x44: return EADiffusionAssemble2D<4,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x55: return EADiffusionAssemble2D<5,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x66: return EADiffusionAssemble2D<6,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x77: return EADiffusionAssemble2D<7,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x88: return EADiffusionAssemble2D<8,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x99: return EADiffusionAssemble2D<9,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EADiffusionAssemble2D(ne,B,G,pa_data,ea_data,add,
+         case 0x22: return EADiffusionAssemble2D<2,2>(ne,B,G,pa_data,ea_data);
+         case 0x33: return EADiffusionAssemble2D<3,3>(ne,B,G,pa_data,ea_data);
+         case 0x44: return EADiffusionAssemble2D<4,4>(ne,B,G,pa_data,ea_data);
+         case 0x55: return EADiffusionAssemble2D<5,5>(ne,B,G,pa_data,ea_data);
+         case 0x66: return EADiffusionAssemble2D<6,6>(ne,B,G,pa_data,ea_data);
+         case 0x77: return EADiffusionAssemble2D<7,7>(ne,B,G,pa_data,ea_data);
+         case 0x88: return EADiffusionAssemble2D<8,8>(ne,B,G,pa_data,ea_data);
+         case 0x99: return EADiffusionAssemble2D<9,9>(ne,B,G,pa_data,ea_data);
+         default:   return EADiffusionAssemble2D(ne,B,G,pa_data,ea_data,
                                                     dofs1D,quad1D);
       }
    }
@@ -286,14 +261,14 @@ void DiffusionIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EADiffusionAssemble3D<2,3>(ne,B,G,pa_data,ea_data,add);
-         case 0x34: return EADiffusionAssemble3D<3,4>(ne,B,G,pa_data,ea_data,add);
-         case 0x45: return EADiffusionAssemble3D<4,5>(ne,B,G,pa_data,ea_data,add);
-         case 0x56: return EADiffusionAssemble3D<5,6>(ne,B,G,pa_data,ea_data,add);
-         case 0x67: return EADiffusionAssemble3D<6,7>(ne,B,G,pa_data,ea_data,add);
-         case 0x78: return EADiffusionAssemble3D<7,8>(ne,B,G,pa_data,ea_data,add);
-         case 0x89: return EADiffusionAssemble3D<8,9>(ne,B,G,pa_data,ea_data,add);
-         default:   return EADiffusionAssemble3D(ne,B,G,pa_data,ea_data,add,
+         case 0x23: return EADiffusionAssemble3D<2,3>(ne,B,G,pa_data,ea_data);
+         case 0x34: return EADiffusionAssemble3D<3,4>(ne,B,G,pa_data,ea_data);
+         case 0x45: return EADiffusionAssemble3D<4,5>(ne,B,G,pa_data,ea_data);
+         case 0x56: return EADiffusionAssemble3D<5,6>(ne,B,G,pa_data,ea_data);
+         case 0x67: return EADiffusionAssemble3D<6,7>(ne,B,G,pa_data,ea_data);
+         case 0x78: return EADiffusionAssemble3D<7,8>(ne,B,G,pa_data,ea_data);
+         case 0x89: return EADiffusionAssemble3D<8,9>(ne,B,G,pa_data,ea_data);
+         default:   return EADiffusionAssemble3D(ne,B,G,pa_data,ea_data,
                                                     dofs1D,quad1D);
       }
    }
diff --git a/fem/integ/bilininteg_diffusion_mf.cpp b/fem/integ/bilininteg_diffusion_mf.cpp
index 449246a02..0896b8bf9 100644
--- a/fem/integ/bilininteg_diffusion_mf.cpp
+++ b/fem/integ/bilininteg_diffusion_mf.cpp
@@ -19,7 +19,6 @@ namespace mfem
 void DiffusionIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
diff --git a/fem/integ/bilininteg_diffusion_pa.cpp b/fem/integ/bilininteg_diffusion_pa.cpp
index f3ed5952c..a966c8520 100644
--- a/fem/integ/bilininteg_diffusion_pa.cpp
+++ b/fem/integ/bilininteg_diffusion_pa.cpp
@@ -23,7 +23,6 @@ void DiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    const MemoryType mt = (pa_mt == MemoryType::DEFAULT) ?
                          Device::GetDeviceMemoryType() : pa_mt;
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
@@ -82,7 +81,6 @@ void DiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
    }
    else
    {
-      if (pa_data.Size()==0) { AssemblePA(*fespace); }
       internal::PADiffusionAssembleDiagonal(dim, dofs1D, quad1D, ne, symmetric,
                                             maps->B, maps->G, pa_data, diag);
    }
@@ -104,14 +102,22 @@ void DiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 
 void DiffusionIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
-   if (symmetric)
+   if (DeviceCanUseCeed())
    {
-      AddMultPA(x, y);
+      MFEM_ABORT("AddMultTransposePA not yet implemented with libCEED for"
+                 " DiffusionIntegrator.");
    }
    else
    {
-      MFEM_ABORT("DiffusionIntegrator::AddMultTransposePA only implemented in "
-                 "the symmetric case.")
+      if (symmetric)
+      {
+         AddMultPA(x, y);
+      }
+      else
+      {
+         MFEM_ABORT("DiffusionIntegrator::AddMultTransposePA only implemented in "
+                    "the symmetric case.")
+      }
    }
 }
 
diff --git a/fem/integ/bilininteg_gradient_pa.cpp b/fem/integ/bilininteg_gradient_pa.cpp
index 7d6b8c5df..20ef4684d 100644
--- a/fem/integ/bilininteg_gradient_pa.cpp
+++ b/fem/integ/bilininteg_gradient_pa.cpp
@@ -158,27 +158,6 @@ static void PAGradientSetup3D(const int Q1D,
    });
 }
 
-static void PAGradientSetup(const int dim,
-                            const int TR_D1D,
-                            const int TE_D1D,
-                            const int Q1D,
-                            const int NE,
-                            const Array<double> &W,
-                            const Vector &J,
-                            const Vector &COEFF,
-                            Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PAGradientSetup"); }
-   if (dim == 2)
-   {
-      PAGradientSetup2D(Q1D, NE, W, J, COEFF, op);
-   }
-   if (dim == 3)
-   {
-      PAGradientSetup3D(Q1D, NE, W, J, COEFF, op);
-   }
-}
-
 void GradientIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                     const FiniteElementSpace &test_fes)
 {
@@ -209,8 +188,18 @@ void GradientIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    QuadratureSpace qs(*mesh, *ir);
    CoefficientVector coeff(Q, qs, CoefficientStorage::COMPRESSED);
 
-   PAGradientSetup(dim, trial_dofs1D, test_dofs1D, quad1D,
-                   ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in GradientIntegrator::AssemblePA");
+   }
+   else if (dim == 2)
+   {
+      PAGradientSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PAGradientSetup3D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
 }
 
 // PA Gradient Apply 2D kernel
@@ -787,40 +776,21 @@ static void SmemPAGradientApply3D(const int NE,
    });
 }
 
-static void PAGradientApply(const int dim,
-                            const int TR_D1D,
-                            const int TE_D1D,
-                            const int Q1D,
-                            const int NE,
-                            const Array<double> &B,
-                            const Array<double> &G,
-                            const Array<double> &Bt,
-                            const Vector &op,
-                            const Vector &x,
-                            Vector &y,
-                            bool transpose=false)
+void GradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
-
    if (dim == 2)
    {
-      return PAGradientApply2D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
+      return PAGradientApply2D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                               pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    if (dim == 3)
    {
-      return PAGradientApply3D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
+      return PAGradientApply3D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                               pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    MFEM_ABORT("Unknown kernel.");
 }
 
-// PA Gradient Apply kernel
-void GradientIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   PAGradientApply(dim, trial_dofs1D, test_dofs1D, quad1D, ne,
-                   trial_maps->B, trial_maps->G, test_maps->Bt, pa_data, x, y,
-                   false);
-}
-
-// PA Gradient Apply kernel
 void GradientIntegrator::AddMultTransposePA(const Vector &x, Vector &y) const
 {
    MFEM_ABORT("PA Gradient AddMultTransposePA not implemented.");
diff --git a/fem/integ/bilininteg_mass_ea.cpp b/fem/integ/bilininteg_mass_ea.cpp
index 4cafa68f3..315b9da8f 100644
--- a/fem/integ/bilininteg_mass_ea.cpp
+++ b/fem/integ/bilininteg_mass_ea.cpp
@@ -21,7 +21,6 @@ static void EAMassAssemble1D(const int NE,
                              const Array<double> &basis,
                              const Vector &padata,
                              Vector &eadata,
-                             const bool add,
                              const int d1d = 0,
                              const int q1d = 0)
 {
@@ -53,14 +52,7 @@ static void EAMassAssemble1D(const int NE,
             {
                val += r_Bi[k1] * r_Bj[k1] * D(k1, e);
             }
-            if (add)
-            {
-               M(i1, j1, e) += val;
-            }
-            else
-            {
-               M(i1, j1, e) = val;
-            }
+            M(i1, j1, e) += val;
          }
       }
    });
@@ -71,7 +63,6 @@ static void EAMassAssemble2D(const int NE,
                              const Array<double> &basis,
                              const Vector &padata,
                              Vector &eadata,
-                             const bool add,
                              const int d1d = 0,
                              const int q1d = 0)
 {
@@ -123,14 +114,7 @@ static void EAMassAssemble2D(const int NE,
                                * s_D[k1][k2];
                      }
                   }
-                  if (add)
-                  {
-                     M(i1, i2, j1, j2, e) += val;
-                  }
-                  else
-                  {
-                     M(i1, i2, j1, j2, e) = val;
-                  }
+                  M(i1, i2, j1, j2, e) += val;
                }
             }
          }
@@ -143,7 +127,6 @@ static void EAMassAssemble3D(const int NE,
                              const Array<double> &basis,
                              const Vector &padata,
                              Vector &eadata,
-                             const bool add,
                              const int d1d = 0,
                              const int q1d = 0)
 {
@@ -237,14 +220,7 @@ static void EAMassAssemble3D(const int NE,
                               }
                            }
                         }
-                        if (add)
-                        {
-                           M(i1, i2, i3, j1, j2, j3, e) += val;
-                        }
-                        else
-                        {
-                           M(i1, i2, i3, j1, j2, j3, e) = val;
-                        }
+                        M(i1, i2, i3, j1, j2, j3, e) += val;
                      }
                   }
                }
@@ -255,8 +231,7 @@ static void EAMassAssemble3D(const int NE,
 }
 
 void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                Vector &ea_data,
-                                const bool add)
+                                Vector &ea_data)
 {
    AssemblePA(fes);
    ne = fes.GetMesh()->GetNE();
@@ -265,15 +240,15 @@ void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAMassAssemble1D<2,2>(ne,B,pa_data,ea_data,add);
-         case 0x33: return EAMassAssemble1D<3,3>(ne,B,pa_data,ea_data,add);
-         case 0x44: return EAMassAssemble1D<4,4>(ne,B,pa_data,ea_data,add);
-         case 0x55: return EAMassAssemble1D<5,5>(ne,B,pa_data,ea_data,add);
-         case 0x66: return EAMassAssemble1D<6,6>(ne,B,pa_data,ea_data,add);
-         case 0x77: return EAMassAssemble1D<7,7>(ne,B,pa_data,ea_data,add);
-         case 0x88: return EAMassAssemble1D<8,8>(ne,B,pa_data,ea_data,add);
-         case 0x99: return EAMassAssemble1D<9,9>(ne,B,pa_data,ea_data,add);
-         default:   return EAMassAssemble1D(ne,B,pa_data,ea_data,add,
+         case 0x22: return EAMassAssemble1D<2,2>(ne,B,pa_data,ea_data);
+         case 0x33: return EAMassAssemble1D<3,3>(ne,B,pa_data,ea_data);
+         case 0x44: return EAMassAssemble1D<4,4>(ne,B,pa_data,ea_data);
+         case 0x55: return EAMassAssemble1D<5,5>(ne,B,pa_data,ea_data);
+         case 0x66: return EAMassAssemble1D<6,6>(ne,B,pa_data,ea_data);
+         case 0x77: return EAMassAssemble1D<7,7>(ne,B,pa_data,ea_data);
+         case 0x88: return EAMassAssemble1D<8,8>(ne,B,pa_data,ea_data);
+         case 0x99: return EAMassAssemble1D<9,9>(ne,B,pa_data,ea_data);
+         default:   return EAMassAssemble1D(ne,B,pa_data,ea_data,
                                                dofs1D,quad1D);
       }
    }
@@ -281,15 +256,15 @@ void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x22: return EAMassAssemble2D<2,2>(ne,B,pa_data,ea_data,add);
-         case 0x33: return EAMassAssemble2D<3,3>(ne,B,pa_data,ea_data,add);
-         case 0x44: return EAMassAssemble2D<4,4>(ne,B,pa_data,ea_data,add);
-         case 0x55: return EAMassAssemble2D<5,5>(ne,B,pa_data,ea_data,add);
-         case 0x66: return EAMassAssemble2D<6,6>(ne,B,pa_data,ea_data,add);
-         case 0x77: return EAMassAssemble2D<7,7>(ne,B,pa_data,ea_data,add);
-         case 0x88: return EAMassAssemble2D<8,8>(ne,B,pa_data,ea_data,add);
-         case 0x99: return EAMassAssemble2D<9,9>(ne,B,pa_data,ea_data,add);
-         default:   return EAMassAssemble2D(ne,B,pa_data,ea_data,add,
+         case 0x22: return EAMassAssemble2D<2,2>(ne,B,pa_data,ea_data);
+         case 0x33: return EAMassAssemble2D<3,3>(ne,B,pa_data,ea_data);
+         case 0x44: return EAMassAssemble2D<4,4>(ne,B,pa_data,ea_data);
+         case 0x55: return EAMassAssemble2D<5,5>(ne,B,pa_data,ea_data);
+         case 0x66: return EAMassAssemble2D<6,6>(ne,B,pa_data,ea_data);
+         case 0x77: return EAMassAssemble2D<7,7>(ne,B,pa_data,ea_data);
+         case 0x88: return EAMassAssemble2D<8,8>(ne,B,pa_data,ea_data);
+         case 0x99: return EAMassAssemble2D<9,9>(ne,B,pa_data,ea_data);
+         default:   return EAMassAssemble2D(ne,B,pa_data,ea_data,
                                                dofs1D,quad1D);
       }
    }
@@ -297,14 +272,14 @@ void MassIntegrator::AssembleEA(const FiniteElementSpace &fes,
    {
       switch ((dofs1D << 4 ) | quad1D)
       {
-         case 0x23: return EAMassAssemble3D<2,3>(ne,B,pa_data,ea_data,add);
-         case 0x34: return EAMassAssemble3D<3,4>(ne,B,pa_data,ea_data,add);
-         case 0x45: return EAMassAssemble3D<4,5>(ne,B,pa_data,ea_data,add);
-         case 0x56: return EAMassAssemble3D<5,6>(ne,B,pa_data,ea_data,add);
-         case 0x67: return EAMassAssemble3D<6,7>(ne,B,pa_data,ea_data,add);
-         case 0x78: return EAMassAssemble3D<7,8>(ne,B,pa_data,ea_data,add);
-         case 0x89: return EAMassAssemble3D<8,9>(ne,B,pa_data,ea_data,add);
-         default:   return EAMassAssemble3D(ne,B,pa_data,ea_data,add,
+         case 0x23: return EAMassAssemble3D<2,3>(ne,B,pa_data,ea_data);
+         case 0x34: return EAMassAssemble3D<3,4>(ne,B,pa_data,ea_data);
+         case 0x45: return EAMassAssemble3D<4,5>(ne,B,pa_data,ea_data);
+         case 0x56: return EAMassAssemble3D<5,6>(ne,B,pa_data,ea_data);
+         case 0x67: return EAMassAssemble3D<6,7>(ne,B,pa_data,ea_data);
+         case 0x78: return EAMassAssemble3D<7,8>(ne,B,pa_data,ea_data);
+         case 0x89: return EAMassAssemble3D<8,9>(ne,B,pa_data,ea_data);
+         default:   return EAMassAssemble3D(ne,B,pa_data,ea_data,
                                                dofs1D,quad1D);
       }
    }
diff --git a/fem/integ/bilininteg_mass_kernels.hpp b/fem/integ/bilininteg_mass_kernels.hpp
index 991a5ff99..488d843cb 100644
--- a/fem/integ/bilininteg_mass_kernels.hpp
+++ b/fem/integ/bilininteg_mass_kernels.hpp
@@ -468,7 +468,6 @@ void SmemPAMassApply2D_Element(const int e,
    double (*QQ)[MQ1] = (double (*)[MQ1]) (sm0 + tidz);
    double (*QD)[MD1] = (double (*)[MD1]) (sm1 + tidz);
 
-
    MFEM_FOREACH_THREAD(dy,y,D1D)
    {
       MFEM_FOREACH_THREAD(dx,x,D1D)
diff --git a/fem/integ/bilininteg_mass_mf.cpp b/fem/integ/bilininteg_mass_mf.cpp
index 18a0edfca..b1e98f682 100644
--- a/fem/integ/bilininteg_mass_mf.cpp
+++ b/fem/integ/bilininteg_mass_mf.cpp
@@ -19,7 +19,6 @@ namespace mfem
 void MassIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
diff --git a/fem/integ/bilininteg_mass_pa.cpp b/fem/integ/bilininteg_mass_pa.cpp
index 7695403e7..ea52b6953 100644
--- a/fem/integ/bilininteg_mass_pa.cpp
+++ b/fem/integ/bilininteg_mass_pa.cpp
@@ -25,7 +25,6 @@ void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
                          Device::GetDeviceMemoryType() : pa_mt;
 
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNE() == 0) { return; }
    const FiniteElement &el = *fes.GetFE(0);
@@ -79,7 +78,7 @@ void MassIntegrator::AssemblePA(const FiniteElementSpace &fes)
             {
                const double detJ = J(qx,qy,e);
                const double coeff = const_c ? C(0,0,0) : C(qx,qy,e);
-               v(qx,qy,e) =  W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
+               v(qx,qy,e) = W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
             }
          }
       });
@@ -119,7 +118,6 @@ void MassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
                          Device::GetDeviceMemoryType() : pa_mt;
 
    // Assuming the same element type
-   fespace = &fes;
    Mesh *mesh = fes.GetMesh();
    if (mesh->GetNBE() == 0) { return; }
    const FiniteElement &el = *fes.GetBE(0);
@@ -157,7 +155,7 @@ void MassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
          {
             const double detJ = J(qx,e);
             const double coeff = const_c ? C(0,0) : C(qx,e);
-            v(qx,e) =  W(qx) * coeff * (by_val ? detJ : 1.0/detJ);
+            v(qx,e) = W(qx) * coeff * (by_val ? detJ : 1.0/detJ);
          }
       });
    }
@@ -176,7 +174,7 @@ void MassIntegrator::AssemblePABoundary(const FiniteElementSpace &fes)
             {
                const double detJ = J(qx,qy,e);
                const double coeff = const_c ? C(0,0,0) : C(qx,qy,e);
-               v(qx,qy,e) =  W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
+               v(qx,qy,e) = W(qx,qy) * coeff * (by_val ? detJ : 1.0/detJ);
             }
          }
       });
diff --git a/fem/integ/bilininteg_mixedcurl_pa.cpp b/fem/integ/bilininteg_mixedcurl_pa.cpp
index 8be2134dd..a3c113982 100644
--- a/fem/integ/bilininteg_mixedcurl_pa.cpp
+++ b/fem/integ/bilininteg_mixedcurl_pa.cpp
@@ -265,9 +265,9 @@ void MixedVectorCurlIntegrator::AddMultTransposePA(const Vector &x,
    }
 }
 
-void MixedVectorWeakCurlIntegrator::AssemblePA(const FiniteElementSpace
-                                               &trial_fes,
-                                               const FiniteElementSpace &test_fes)
+void MixedVectorWeakCurlIntegrator::AssemblePA(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
 {
    // Assumes tensor-product elements, with vector test and trial spaces.
    Mesh *mesh = trial_fes.GetMesh();
diff --git a/fem/integ/bilininteg_mixedvecgrad_pa.cpp b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
index 4f50dcc92..f9e6d3ee8 100644
--- a/fem/integ/bilininteg_mixedvecgrad_pa.cpp
+++ b/fem/integ/bilininteg_mixedvecgrad_pa.cpp
@@ -656,9 +656,9 @@ static void PAHcurlH1ApplyTranspose3D(const int D1D,
    }); // end of element loop
 }
 
-void MixedVectorGradientIntegrator::AssemblePA(const FiniteElementSpace
-                                               &trial_fes,
-                                               const FiniteElementSpace &test_fes)
+void MixedVectorGradientIntegrator::AssemblePA(
+   const FiniteElementSpace &trial_fes,
+   const FiniteElementSpace &test_fes)
 {
    // Assumes tensor-product elements, with a vector test space and H^1 trial space.
    Mesh *mesh = trial_fes.GetMesh();
diff --git a/fem/integ/bilininteg_transpose_ea.cpp b/fem/integ/bilininteg_transpose_ea.cpp
index 4ff8be04b..e1ac154fc 100644
--- a/fem/integ/bilininteg_transpose_ea.cpp
+++ b/fem/integ/bilininteg_transpose_ea.cpp
@@ -16,171 +16,91 @@ namespace mfem
 {
 
 void TransposeIntegrator::AssembleEA(const FiniteElementSpace &fes,
-                                     Vector &ea_data, const bool add)
+                                     Vector &ea_data)
 {
-   if (add)
-   {
-      Vector ea_data_tmp(ea_data.Size());
-      bfi->AssembleEA(fes, ea_data_tmp, false);
-      const int ne = fes.GetNE();
-      if (ne == 0) { return; }
-      const int dofs = fes.GetFE(0)->GetDof();
-      auto A = Reshape(ea_data_tmp.Read(), dofs, dofs, ne);
-      auto AT = Reshape(ea_data.ReadWrite(), dofs, dofs, ne);
-      mfem::forall(ne, [=] MFEM_HOST_DEVICE (int e)
-      {
-         for (int i = 0; i < dofs; i++)
-         {
-            for (int j = 0; j < dofs; j++)
-            {
-               const double a = A(i, j, e);
-               AT(j, i, e) += a;
-            }
-         }
-      });
-   }
-   else
+   const int ne = fes.GetNE();
+   if (ne == 0) { return; }
+
+   const int dofs = fes.GetFE(0)->GetDof();
+   Vector ea_data_tmp(ea_data.Size());
+   ea_data_tmp = 0.0;
+   bfi->AssembleEA(fes, ea_data_tmp);
+   auto A = Reshape(ea_data_tmp.Read(), dofs, dofs, ne);
+   auto AT = Reshape(ea_data.ReadWrite(), dofs, dofs, ne);
+   mfem::forall(ne, [=] MFEM_HOST_DEVICE (int e)
    {
-      bfi->AssembleEA(fes, ea_data, false);
-      const int ne = fes.GetNE();
-      if (ne == 0) { return; }
-      const int dofs = fes.GetFE(0)->GetDof();
-      auto A = Reshape(ea_data.ReadWrite(), dofs, dofs, ne);
-      mfem::forall(ne, [=] MFEM_HOST_DEVICE (int e)
+      for (int i = 0; i < dofs; i++)
       {
-         for (int i = 0; i < dofs; i++)
+         for (int j = 0; j < dofs; j++)
          {
-            for (int j = i+1; j < dofs; j++)
-            {
-               const double aij = A(i, j, e);
-               const double aji = A(j, i, e);
-               A(j, i, e) = aij;
-               A(i, j, e) = aji;
-            }
+            const double a = A(i, j, e);
+            AT(j, i, e) += a;
          }
-      });
-   }
+      }
+   });
 }
 
-void TransposeIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace& fes,
+void TransposeIntegrator::AssembleEAInteriorFaces(const FiniteElementSpace &fes,
                                                   Vector &ea_data_int,
-                                                  Vector &ea_data_ext,
-                                                  const bool add)
+                                                  Vector &ea_data_ext)
 {
    const int nf = fes.GetNFbyType(FaceType::Interior);
    if (nf == 0) { return; }
-   if (add)
-   {
-      Vector ea_data_int_tmp(ea_data_int.Size());
-      Vector ea_data_ext_tmp(ea_data_ext.Size());
-      bfi->AssembleEAInteriorFaces(fes, ea_data_int_tmp, ea_data_ext_tmp, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_int = Reshape(ea_data_int_tmp.Read(), faceDofs, faceDofs, 2, nf);
-      auto A_ext = Reshape(ea_data_ext_tmp.Read(), faceDofs, faceDofs, 2, nf);
-      auto AT_int = Reshape(ea_data_int.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      auto AT_ext = Reshape(ea_data_ext.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
-      {
-         for (int i = 0; i < faceDofs; i++)
-         {
-            for (int j = 0; j < faceDofs; j++)
-            {
-               const double a_int0 = A_int(i, j, 0, f);
-               const double a_int1 = A_int(i, j, 1, f);
-               const double a_ext0 = A_ext(i, j, 0, f);
-               const double a_ext1 = A_ext(i, j, 1, f);
-               AT_int(j, i, 0, f) += a_int0;
-               AT_int(j, i, 1, f) += a_int1;
-               AT_ext(j, i, 0, f) += a_ext1;
-               AT_ext(j, i, 1, f) += a_ext0;
-            }
-         }
-      });
-   }
-   else
+
+   const int face_dofs = fes.GetTraceElement(0,
+                                             fes.GetMesh()->GetFaceGeometry(0))->GetDof();
+   Vector ea_data_int_tmp(ea_data_int.Size());
+   Vector ea_data_ext_tmp(ea_data_ext.Size());
+   ea_data_int_tmp = 0.0;
+   ea_data_ext_tmp = 0.0;
+   bfi->AssembleEAInteriorFaces(fes, ea_data_int_tmp, ea_data_ext_tmp);
+   auto A_int = Reshape(ea_data_int_tmp.Read(), face_dofs, face_dofs, 2, nf);
+   auto A_ext = Reshape(ea_data_ext_tmp.Read(), face_dofs, face_dofs, 2, nf);
+   auto AT_int = Reshape(ea_data_int.ReadWrite(), face_dofs, face_dofs, 2, nf);
+   auto AT_ext = Reshape(ea_data_ext.ReadWrite(), face_dofs, face_dofs, 2, nf);
+   mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
    {
-      bfi->AssembleEAInteriorFaces(fes, ea_data_int, ea_data_ext, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_int = Reshape(ea_data_int.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      auto A_ext = Reshape(ea_data_ext.ReadWrite(), faceDofs, faceDofs, 2, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
+      for (int i = 0; i < face_dofs; i++)
       {
-         for (int i = 0; i < faceDofs; i++)
-         {
-            for (int j = i+1; j < faceDofs; j++)
-            {
-               const double aij_int0 = A_int(i, j, 0, f);
-               const double aij_int1 = A_int(i, j, 1, f);
-               const double aji_int0 = A_int(j, i, 0, f);
-               const double aji_int1 = A_int(j, i, 1, f);
-               A_int(j, i, 0, f) = aij_int0;
-               A_int(j, i, 1, f) = aij_int1;
-               A_int(i, j, 0, f) = aji_int0;
-               A_int(i, j, 1, f) = aji_int1;
-            }
-         }
-         for (int i = 0; i < faceDofs; i++)
+         for (int j = 0; j < face_dofs; j++)
          {
-            for (int j = 0; j < faceDofs; j++)
-            {
-               const double aij_ext0 = A_ext(i, j, 0, f);
-               const double aji_ext1 = A_ext(j, i, 1, f);
-               A_ext(j, i, 1, f) = aij_ext0;
-               A_ext(i, j, 0, f) = aji_ext1;
-            }
+            const double a_int0 = A_int(i, j, 0, f);
+            const double a_int1 = A_int(i, j, 1, f);
+            const double a_ext0 = A_ext(i, j, 0, f);
+            const double a_ext1 = A_ext(i, j, 1, f);
+            AT_int(j, i, 0, f) += a_int0;
+            AT_int(j, i, 1, f) += a_int1;
+            AT_ext(j, i, 0, f) += a_ext1;
+            AT_ext(j, i, 1, f) += a_ext0;
          }
-      });
-   }
+      }
+   });
 }
 
-void TransposeIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace& fes,
-                                                  Vector &ea_data_bdr,
-                                                  const bool add)
+void TransposeIntegrator::AssembleEABoundaryFaces(const FiniteElementSpace &fes,
+                                                  Vector &ea_data_bdr)
 {
    const int nf = fes.GetNFbyType(FaceType::Boundary);
    if (nf == 0) { return; }
-   if (add)
-   {
-      Vector ea_data_bdr_tmp(ea_data_bdr.Size());
-      bfi->AssembleEABoundaryFaces(fes, ea_data_bdr_tmp, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_bdr = Reshape(ea_data_bdr_tmp.Read(), faceDofs, faceDofs, nf);
-      auto AT_bdr = Reshape(ea_data_bdr.ReadWrite(), faceDofs, faceDofs, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
-      {
-         for (int i = 0; i < faceDofs; i++)
-         {
-            for (int j = 0; j < faceDofs; j++)
-            {
-               const double a_bdr = A_bdr(i, j, f);
-               AT_bdr(j, i, f) += a_bdr;
-            }
-         }
-      });
-   }
-   else
+
+   const int face_dofs = fes.GetTraceElement(0,
+                                             fes.GetMesh()->GetFaceGeometry(0))->GetDof();
+   Vector ea_data_bdr_tmp(ea_data_bdr.Size());
+   ea_data_bdr_tmp = 0.0;
+   bfi->AssembleEABoundaryFaces(fes, ea_data_bdr_tmp);
+   auto A_bdr = Reshape(ea_data_bdr_tmp.Read(), face_dofs, face_dofs, nf);
+   auto AT_bdr = Reshape(ea_data_bdr.ReadWrite(), face_dofs, face_dofs, nf);
+   mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
    {
-      bfi->AssembleEABoundaryFaces(fes, ea_data_bdr, false);
-      const int faceDofs = fes.GetTraceElement(0,
-                                               fes.GetMesh()->GetFaceGeometry(0))->GetDof();
-      auto A_bdr = Reshape(ea_data_bdr.ReadWrite(), faceDofs, faceDofs, nf);
-      mfem::forall(nf, [=] MFEM_HOST_DEVICE (int f)
+      for (int i = 0; i < face_dofs; i++)
       {
-         for (int i = 0; i < faceDofs; i++)
+         for (int j = 0; j < face_dofs; j++)
          {
-            for (int j = i+1; j < faceDofs; j++)
-            {
-               const double aij_bdr = A_bdr(i, j, f);
-               const double aji_bdr = A_bdr(j, i, f);
-               A_bdr(j, i, f) = aij_bdr;
-               A_bdr(i, j, f) = aji_bdr;
-            }
+            const double a_bdr = A_bdr(i, j, f);
+            AT_bdr(j, i, f) += a_bdr;
          }
-      });
-   }
+      }
+   });
 }
 
 }
diff --git a/fem/integ/bilininteg_vecdiffusion_pa.cpp b/fem/integ/bilininteg_vecdiffusion_pa.cpp
index 88d0b136f..84e4d5b2a 100644
--- a/fem/integ/bilininteg_vecdiffusion_pa.cpp
+++ b/fem/integ/bilininteg_vecdiffusion_pa.cpp
@@ -36,7 +36,6 @@ static void PAVectorDiffusionSetup2D(const int Q1D,
    const auto C = const_c ? Reshape(c.Read(), 1,1) :
                   Reshape(c.Read(), NQ, NE);
 
-
    mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
       for (int q = 0; q < NQ; ++q)
@@ -72,7 +71,6 @@ static void PAVectorDiffusionSetup3D(const int Q1D,
    const auto C = const_c ? Reshape(c.Read(), 1,1) :
                   Reshape(c.Read(), NQ,NE);
 
-
    mfem::forall(NE, [=] MFEM_HOST_DEVICE (int e)
    {
       for (int q = 0; q < NQ; ++q)
@@ -114,28 +112,6 @@ static void PAVectorDiffusionSetup3D(const int Q1D,
    });
 }
 
-static void PAVectorDiffusionSetup(const int dim,
-                                   const int Q1D,
-                                   const int NE,
-                                   const Array<double> &W,
-                                   const Vector &J,
-                                   const Vector &C,
-                                   Vector &op)
-{
-   if (!(dim == 2 || dim == 3))
-   {
-      MFEM_ABORT("Dimension not supported.");
-   }
-   if (dim == 2)
-   {
-      PAVectorDiffusionSetup2D(Q1D, NE, W, J, C, op);
-   }
-   if (dim == 3)
-   {
-      PAVectorDiffusionSetup3D(Q1D, NE, W, J, C, op);
-   }
-}
-
 void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
 {
    // Assumes tensor-product elements
@@ -179,7 +155,10 @@ void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    const Array<double> &w = ir->GetWeights();
    const Vector &j = geom->J;
    Vector &d = pa_data;
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PAVectorDiffusionSetup"); }
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in VectorDiffusionIntegrator::AssemblePA");
+   }
    if (dim == 2 && sdim == 3)
    {
       constexpr int DIM = 2;
@@ -218,7 +197,15 @@ void VectorDiffusionIntegrator::AssemblePA(const FiniteElementSpace &fes)
    }
    else
    {
-      PAVectorDiffusionSetup(dim, quad1D, ne, w, j, coeff, d);
+      if (dim == 2)
+      {
+         return PAVectorDiffusionSetup2D(quad1D, ne, w, j, coeff, d);
+      }
+      if (dim == 3)
+      {
+         return PAVectorDiffusionSetup3D(quad1D, ne, w, j, coeff, d);
+      }
+      MFEM_ABORT("Dimension not supported.");
    }
 }
 
@@ -391,26 +378,6 @@ static void PAVectorDiffusionDiagonal3D(const int NE,
    });
 }
 
-static void PAVectorDiffusionAssembleDiagonal(const int dim,
-                                              const int D1D,
-                                              const int Q1D,
-                                              const int NE,
-                                              const Array<double> &B,
-                                              const Array<double> &G,
-                                              const Vector &op,
-                                              Vector &y)
-{
-   if (dim == 2)
-   {
-      return PAVectorDiffusionDiagonal2D(NE, B, G, op, y, D1D, Q1D);
-   }
-   else if (dim == 3)
-   {
-      return PAVectorDiffusionDiagonal3D(NE, B, G, op, y, D1D, Q1D);
-   }
-   MFEM_ABORT("Dimension not implemented.");
-}
-
 void VectorDiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
@@ -419,25 +386,35 @@ void VectorDiffusionIntegrator::AssembleDiagonalPA(Vector &diag)
    }
    else
    {
-      PAVectorDiffusionAssembleDiagonal(dim, dofs1D, quad1D, ne,
-                                        maps->B, maps->G,
-                                        pa_data, diag);
+      if (dim == 2)
+      {
+         return PAVectorDiffusionDiagonal2D(ne, maps->B, maps->G,
+                                            pa_data, diag,
+                                            dofs1D, quad1D);
+      }
+      else if (dim == 3)
+      {
+         return PAVectorDiffusionDiagonal3D(ne, maps->B, maps->G,
+                                            pa_data, diag,
+                                            dofs1D, quad1D);
+      }
+      MFEM_ABORT("Dimension not implemented.");
    }
 }
 
 // PA Diffusion Apply 2D kernel
-template<int T_D1D = 0, int T_Q1D = 0, int T_VDIM = 0> static
-void PAVectorDiffusionApply2D(const int NE,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &d_,
-                              const Vector &x_,
-                              Vector &y_,
-                              const int d1d = 0,
-                              const int q1d = 0,
-                              const int vdim = 0)
+template<int T_D1D = 0, int T_Q1D = 0, int T_VDIM = 0>
+static void PAVectorDiffusionApply2D(const int NE,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &d_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     const int d1d = 0,
+                                     const int q1d = 0,
+                                     const int vdim = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -548,17 +525,16 @@ void PAVectorDiffusionApply2D(const int NE,
 }
 
 // PA Diffusion Apply 3D kernel
-template<const int T_D1D = 0,
-         const int T_Q1D = 0> static
-void PAVectorDiffusionApply3D(const int NE,
-                              const Array<double> &b,
-                              const Array<double> &g,
-                              const Array<double> &bt,
-                              const Array<double> &gt,
-                              const Vector &op_,
-                              const Vector &x_,
-                              Vector &y_,
-                              int d1d = 0, int q1d = 0)
+template<const int T_D1D = 0, const int T_Q1D = 0>
+static void PAVectorDiffusionApply3D(const int NE,
+                                     const Array<double> &b,
+                                     const Array<double> &g,
+                                     const Array<double> &bt,
+                                     const Array<double> &gt,
+                                     const Vector &op_,
+                                     const Vector &x_,
+                                     Vector &y_,
+                                     int d1d = 0, int q1d = 0)
 {
    const int D1D = T_D1D ? T_D1D : d1d;
    const int Q1D = T_Q1D ? T_Q1D : q1d;
@@ -741,7 +717,6 @@ void PAVectorDiffusionApply3D(const int NE,
    });
 }
 
-// PA Diffusion Apply kernel
 void VectorDiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
@@ -771,11 +746,13 @@ void VectorDiffusionIntegrator::AddMultPA(const Vector &x, Vector &y) const
          }
       }
       if (dim == 2 && sdim == 2)
-      { return PAVectorDiffusionApply2D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D,sdim); }
-
+      {
+         return PAVectorDiffusionApply2D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D,sdim);
+      }
       if (dim == 3 && sdim == 3)
-      { return PAVectorDiffusionApply3D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D); }
-
+      {
+         return PAVectorDiffusionApply3D(ne,B,G,Bt,Gt,D,x,y,D1D,Q1D);
+      }
       MFEM_ABORT("Unknown kernel.");
    }
 }
diff --git a/fem/integ/bilininteg_vecdiv_pa.cpp b/fem/integ/bilininteg_vecdiv_pa.cpp
index cc282a49a..63f7a3308 100644
--- a/fem/integ/bilininteg_vecdiv_pa.cpp
+++ b/fem/integ/bilininteg_vecdiv_pa.cpp
@@ -96,27 +96,6 @@ static void PADivergenceSetup3D(const int Q1D,
    });
 }
 
-static void PADivergenceSetup(const int dim,
-                              const int TR_D1D,
-                              const int TE_D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &W,
-                              const Vector &J,
-                              const double COEFF,
-                              Vector &op)
-{
-   if (dim == 1) { MFEM_ABORT("dim==1 not supported in PADivergenceSetup"); }
-   if (dim == 2)
-   {
-      PADivergenceSetup2D(Q1D, NE, W, J, COEFF, op);
-   }
-   if (dim == 3)
-   {
-      PADivergenceSetup3D(Q1D, NE, W, J, COEFF, op);
-   }
-}
-
 void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                             const FiniteElementSpace &test_fes)
 {
@@ -143,6 +122,7 @@ void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
    MFEM_ASSERT(quad1D == test_maps->nqpt,
                "PA requires test and trial space to have same number of quadrature points!");
    pa_data.SetSize(nq * dimsToStore * ne, Device::GetMemoryType());
+
    double coeff = 1.0;
    if (Q)
    {
@@ -150,8 +130,19 @@ void VectorDivergenceIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
       MFEM_VERIFY(cQ != NULL, "only ConstantCoefficient is supported!");
       coeff = cQ->constant;
    }
-   PADivergenceSetup(dim, trial_dofs1D, test_dofs1D, quad1D,
-                     ne, ir->GetWeights(), geom->J, coeff, pa_data);
+
+   if (dim == 1)
+   {
+      MFEM_ABORT("dim==1 not supported in VectorDivergenceIntegrator::AssemblePA");
+   }
+   else if (dim == 2)
+   {
+      PADivergenceSetup2D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
+   else if (dim == 3)
+   {
+      PADivergenceSetup3D(quad1D, ne, ir->GetWeights(), geom->J, coeff, pa_data);
+   }
 }
 
 // PA Divergence Apply 2D kernel
@@ -1021,59 +1012,37 @@ static void SmemPADivergenceApply3D(const int NE,
    });
 }
 
-static void PADivergenceApply(const int dim,
-                              const int TR_D1D,
-                              const int TE_D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &B,
-                              const Array<double> &G,
-                              const Array<double> &Bt,
-                              const Vector &op,
-                              const Vector &x,
-                              Vector &y,
-                              bool transpose=false)
+void VectorDivergenceIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (dim == 2)
    {
-      if (transpose)
-      {
-         return PADivergenceApplyTranspose2D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
-      }
-      else
-      {
-         return PADivergenceApply2D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
-      }
+      return PADivergenceApply2D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                                 pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    if (dim == 3)
    {
-      if (transpose)
-      {
-         return PADivergenceApplyTranspose3D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
-      }
-      else
-      {
-         return PADivergenceApply3D(NE,B,G,Bt,op,x,y,TR_D1D,TE_D1D,Q1D);
-      }
+      return PADivergenceApply3D(ne, trial_maps->B, trial_maps->G, test_maps->Bt,
+                                 pa_data, x, y, trial_dofs1D, test_dofs1D, quad1D);
    }
    MFEM_ABORT("Unknown kernel.");
 }
 
-// PA Divergence Apply kernel
-void VectorDivergenceIntegrator::AddMultPA(const Vector &x, Vector &y) const
-{
-   PADivergenceApply(dim, trial_dofs1D, test_dofs1D, quad1D, ne,
-                     trial_maps->B, trial_maps->G, test_maps->Bt, pa_data, x, y,
-                     false);
-}
-
-// PA Divergence Apply kernel
 void VectorDivergenceIntegrator::AddMultTransposePA(const Vector &x,
                                                     Vector &y) const
 {
-   PADivergenceApply(dim, trial_dofs1D, test_dofs1D, quad1D, ne,
-                     trial_maps->Bt, trial_maps->Gt, test_maps->B, pa_data, x, y,
-                     true);
+   if (dim == 2)
+   {
+      return PADivergenceApplyTranspose2D(ne, trial_maps->Bt, trial_maps->Gt,
+                                          test_maps->B, pa_data, x, y,
+                                          trial_dofs1D, test_dofs1D, quad1D);
+   }
+   if (dim == 3)
+   {
+      return PADivergenceApplyTranspose3D(ne, trial_maps->Bt, trial_maps->Gt,
+                                          test_maps->B, pa_data, x, y,
+                                          trial_dofs1D, test_dofs1D, quad1D);
+   }
+   MFEM_ABORT("Unknown kernel.");
 }
 
 } // namespace mfem
diff --git a/fem/integ/bilininteg_vecmass_pa.cpp b/fem/integ/bilininteg_vecmass_pa.cpp
index faafdf14d..b1c20b4c4 100644
--- a/fem/integ/bilininteg_vecmass_pa.cpp
+++ b/fem/integ/bilininteg_vecmass_pa.cpp
@@ -78,7 +78,7 @@ void VectorMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
             const double J21 = J(q,0,1,e);
             const double J22 = J(q,1,1,e);
             const double detJ = (J11*J22)-(J21*J12);
-            v(q,e) =  w[q] * constant * detJ;
+            v(q,e) = w[q] * constant * detJ;
          }
       });
    }
@@ -234,26 +234,6 @@ static void PAVectorMassAssembleDiagonal3D(const int NE,
    });
 }
 
-static void PAVectorMassAssembleDiagonal(const int dim,
-                                         const int D1D,
-                                         const int Q1D,
-                                         const int NE,
-                                         const Array<double> &B,
-                                         const Array<double> &Bt,
-                                         const Vector &op,
-                                         Vector &y)
-{
-   if (dim == 2)
-   {
-      return PAVectorMassAssembleDiagonal2D(NE, B, Bt, op, y, D1D, Q1D);
-   }
-   else if (dim == 3)
-   {
-      return PAVectorMassAssembleDiagonal3D(NE, B, Bt, op, y, D1D, Q1D);
-   }
-   MFEM_ABORT("Dimension not implemented.");
-}
-
 void VectorMassIntegrator::AssembleDiagonalPA(Vector &diag)
 {
    if (DeviceCanUseCeed())
@@ -262,9 +242,19 @@ void VectorMassIntegrator::AssembleDiagonalPA(Vector &diag)
    }
    else
    {
-      PAVectorMassAssembleDiagonal(dim, dofs1D, quad1D, ne,
-                                   maps->B, maps->Bt,
-                                   pa_data, diag);
+      if (dim == 2)
+      {
+         return PAVectorMassAssembleDiagonal2D(ne, maps->B, maps->Bt,
+                                               pa_data, diag,
+                                               dofs1D, quad1D);
+      }
+      else if (dim == 3)
+      {
+         return PAVectorMassAssembleDiagonal3D(ne, maps->B, maps->Bt,
+                                               pa_data, diag,
+                                               dofs1D, quad1D);
+      }
+      MFEM_ABORT("Dimension not implemented.");
    }
 }
 
@@ -509,27 +499,6 @@ static void PAVectorMassApply3D(const int NE,
    });
 }
 
-static void PAVectorMassApply(const int dim,
-                              const int D1D,
-                              const int Q1D,
-                              const int NE,
-                              const Array<double> &B,
-                              const Array<double> &Bt,
-                              const Vector &op,
-                              const Vector &x,
-                              Vector &y)
-{
-   if (dim == 2)
-   {
-      return PAVectorMassApply2D(NE, B, Bt, op, x, y, D1D, Q1D);
-   }
-   if (dim == 3)
-   {
-      return PAVectorMassApply3D(NE, B, Bt, op, x, y, D1D, Q1D);
-   }
-   MFEM_ABORT("Unknown kernel.");
-}
-
 void VectorMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
 {
    if (DeviceCanUseCeed())
@@ -538,7 +507,17 @@ void VectorMassIntegrator::AddMultPA(const Vector &x, Vector &y) const
    }
    else
    {
-      PAVectorMassApply(dim, dofs1D, quad1D, ne, maps->B, maps->Bt, pa_data, x, y);
+      if (dim == 2)
+      {
+         return PAVectorMassApply2D(ne, maps->B, maps->Bt, pa_data, x, y,
+                                    dofs1D, quad1D);
+      }
+      if (dim == 3)
+      {
+         return PAVectorMassApply3D(ne, maps->B, maps->Bt, pa_data, x, y,
+                                    dofs1D, quad1D);
+      }
+      MFEM_ABORT("Unknown kernel.");
    }
 }
 
diff --git a/fem/integ/bilininteg_vectorfemass_pa.cpp b/fem/integ/bilininteg_vectorfemass_pa.cpp
index f8d6f63d4..c07e9f816 100644
--- a/fem/integ/bilininteg_vectorfemass_pa.cpp
+++ b/fem/integ/bilininteg_vectorfemass_pa.cpp
@@ -20,11 +20,6 @@
 namespace mfem
 {
 
-void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &fes)
-{
-   AssemblePA(fes, fes);
-}
-
 void VectorFEMassIntegrator::AssemblePA(const FiniteElementSpace &trial_fes,
                                         const FiniteElementSpace &test_fes)
 {
diff --git a/fem/integ/lininteg_boundary_flux.cpp b/fem/integ/lininteg_boundary_flux.cpp
index 98cee62a6..b9f047817 100644
--- a/fem/integ/lininteg_boundary_flux.cpp
+++ b/fem/integ/lininteg_boundary_flux.cpp
@@ -16,10 +16,10 @@
 namespace mfem
 {
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void BFLFEvalAssemble2D(const int nbe, const int d, const int q,
-                        const int *markers, const double *b,
-                        const double *weights, const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void BFLFEvalAssemble2D(const int nbe, const int d, const int q,
+                               const int *markers, const double *b,
+                               const double *weights, const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, nbe);
@@ -50,10 +50,10 @@ void BFLFEvalAssemble2D(const int nbe, const int d, const int q,
    });
 }
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void BFLFEvalAssemble3D(const int nbe, const int d, const int q,
-                        const int *markers, const double *b,
-                        const double *weights, const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void BFLFEvalAssemble3D(const int nbe, const int d, const int q,
+                               const int *markers, const double *b,
+                               const double *weights, const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, nbe);
diff --git a/fem/integ/lininteg_domain_grad.cpp b/fem/integ/lininteg_domain_grad.cpp
index 9bf3af218..5cca01a1d 100644
--- a/fem/integ/lininteg_domain_grad.cpp
+++ b/fem/integ/lininteg_domain_grad.cpp
@@ -16,11 +16,12 @@
 namespace mfem
 {
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void DLFGradAssemble2D(const int vdim, const int ne, const int d, const int q,
-                       const int *markers, const double *b, const double *g,
-                       const double *jacobians,
-                       const double *weights, const Vector &coeff, double *y)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void DLFGradAssemble2D(const int vdim, const int ne, const int d,
+                              const int q,
+                              const int *markers, const double *b, const double *g,
+                              const double *jacobians,
+                              const double *weights, const Vector &coeff, double *y)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, ne);
@@ -108,12 +109,13 @@ void DLFGradAssemble2D(const int vdim, const int ne, const int d, const int q,
    });
 }
 
-template<int T_D1D = 0, int T_Q1D = 0> static
-void DLFGradAssemble3D(const int vdim, const int ne, const int d, const int q,
-                       const int *markers, const double *b, const double *g,
-                       const double *jacobians,
-                       const double *weights, const Vector &coeff,
-                       double *output)
+template<int T_D1D = 0, int T_Q1D = 0>
+static void DLFGradAssemble3D(const int vdim, const int ne, const int d,
+                              const int q,
+                              const int *markers, const double *b, const double *g,
+                              const double *jacobians,
+                              const double *weights, const Vector &coeff,
+                              double *output)
 {
    const auto F = coeff.Read();
    const auto M = Reshape(markers, ne);
diff --git a/fem/linearform.hpp b/fem/linearform.hpp
index c24118426..29f816db1 100644
--- a/fem/linearform.hpp
+++ b/fem/linearform.hpp
@@ -121,10 +121,6 @@ public:
    LinearForm &operator=(const LinearForm &rhs)
    { return operator=((const Vector &)rhs); }
 
-   /// (DEPRECATED) Return the FE space associated with the LinearForm.
-   /** @deprecated Use FESpace() instead. */
-   MFEM_DEPRECATED FiniteElementSpace *GetFES() { return fes; }
-
    /// Read+write access to the associated FiniteElementSpace.
    FiniteElementSpace *FESpace() { return fes; }
    /// Read-only access to the associated FiniteElementSpace.
diff --git a/fem/linearform_ext.cpp b/fem/linearform_ext.cpp
index f70a7b6e3..3475574fd 100644
--- a/fem/linearform_ext.cpp
+++ b/fem/linearform_ext.cpp
@@ -164,10 +164,8 @@ void LinearFormExtension::Update()
          }
       }
 
-      bdr_restrict_lex =
-         dynamic_cast<const FaceRestriction*>(
-            fes.GetFaceRestriction(ordering, FaceType::Boundary,
-                                   L2FaceValues::SingleValued));
+      bdr_restrict_lex = fes.GetFaceRestriction(ordering, FaceType::Boundary,
+                                                L2FaceValues::SingleValued);
       MFEM_VERIFY(bdr_restrict_lex, "Face restriction not available");
       bdr_b.SetSize(bdr_restrict_lex->Height(), Device::GetMemoryType());
       bdr_b.UseDevice(true);
diff --git a/fem/linearform_ext.hpp b/fem/linearform_ext.hpp
index 2cc861cea..46acf637d 100644
--- a/fem/linearform_ext.hpp
+++ b/fem/linearform_ext.hpp
@@ -34,7 +34,7 @@ class LinearFormExtension
    LinearForm *lf;
 
    /// Operator that converts FiniteElementSpace L-vectors to E-vectors.
-   const ElementRestrictionOperator *elem_restrict_lex; // Not owned
+   const ElementRestriction *elem_restrict_lex; // Not owned
 
    /// Operator that converts L-vectors to boundary E-vectors.
    const FaceRestriction *bdr_restrict_lex; // Not owned
diff --git a/fem/lor/lor_ads.cpp b/fem/lor/lor_ads.cpp
index 3ba4816ee..f962f8469 100644
--- a/fem/lor/lor_ads.cpp
+++ b/fem/lor/lor_ads.cpp
@@ -103,9 +103,9 @@ void BatchedLOR_ADS::FormCurlMatrix()
    Form3DFaceToEdge(face2edge);
 
    ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
-   const auto *R_f = dynamic_cast<const ElementRestriction*>(
+   const auto *R_f = dynamic_cast<const ConformingElementRestriction*>(
                         face_fes.GetElementRestriction(ordering));
-   const auto *R_e = dynamic_cast<const ElementRestriction*>(
+   const auto *R_e = dynamic_cast<const ConformingElementRestriction*>(
                         edge_fes.GetElementRestriction(ordering));
    MFEM_VERIFY(R_f != NULL && R_e != NULL, "");
 
diff --git a/fem/lor/lor_ams.cpp b/fem/lor/lor_ams.cpp
index 1c37f165b..0d7ac222f 100644
--- a/fem/lor/lor_ams.cpp
+++ b/fem/lor/lor_ams.cpp
@@ -163,9 +163,9 @@ void BatchedLOR_AMS::FormGradientMatrix()
    else { Form3DEdgeToVertex(edge2vertex); }
 
    ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
-   const auto *R_v = dynamic_cast<const ElementRestriction*>(
+   const auto *R_v = dynamic_cast<const ConformingElementRestriction*>(
                         vert_fes.GetElementRestriction(ordering));
-   const auto *R_e = dynamic_cast<const ElementRestriction*>(
+   const auto *R_e = dynamic_cast<const ConformingElementRestriction*>(
                         edge_fes.GetElementRestriction(ordering));
    MFEM_VERIFY(R_v != NULL && R_e != NULL, "");
 
@@ -268,7 +268,7 @@ void BatchedLOR_AMS::FormCoordinateVectors(const Vector &X_vert)
    // Create the H1 vertex space and get the element restriction
    ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
    const Operator *op = vert_fes.GetElementRestriction(ordering);
-   const auto *el_restr = dynamic_cast<const ElementRestriction*>(op);
+   const auto *el_restr = dynamic_cast<const ConformingElementRestriction*>(op);
    MFEM_VERIFY(el_restr != NULL, "");
    const SparseMatrix *R = vert_fes.GetRestrictionMatrix();
 
diff --git a/fem/lor/lor_batched.cpp b/fem/lor/lor_batched.cpp
index fe0494880..0050c3de5 100644
--- a/fem/lor/lor_batched.cpp
+++ b/fem/lor/lor_batched.cpp
@@ -145,8 +145,8 @@ int BatchedLORAssembly::FillI(SparseMatrix &A) const
 
    const ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
    const Operator *op = fes_ho.GetElementRestriction(ordering);
-   const ElementRestriction *el_restr =
-      dynamic_cast<const ElementRestriction*>(op);
+   const auto *el_restr =
+      dynamic_cast<const ConformingElementRestriction*>(op);
    MFEM_VERIFY(el_restr != nullptr, "Bad element restriction");
 
    const Array<int> &el_dof_lex_ = el_restr->GatherMap();
@@ -235,8 +235,8 @@ void BatchedLORAssembly::FillJAndData(SparseMatrix &A) const
 
    const ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
    const Operator *op = fes_ho.GetElementRestriction(ordering);
-   const ElementRestriction *el_restr =
-      dynamic_cast<const ElementRestriction*>(op);
+   const auto *el_restr =
+      dynamic_cast<const ConformingElementRestriction*>(op);
    MFEM_VERIFY(el_restr != nullptr, "Bad element restriction");
 
    const Array<int> &el_dof_lex_ = el_restr->GatherMap();
diff --git a/fem/nonlinearform.hpp b/fem/nonlinearform.hpp
index d15d09e04..60cae2055 100644
--- a/fem/nonlinearform.hpp
+++ b/fem/nonlinearform.hpp
@@ -330,7 +330,6 @@ public:
    virtual ~BlockNonlinearForm();
 };
 
-
 }
 
 #endif
diff --git a/fem/nonlininteg.cpp b/fem/nonlininteg.cpp
index e1558fda4..5ee1febea 100644
--- a/fem/nonlininteg.cpp
+++ b/fem/nonlininteg.cpp
@@ -15,68 +15,69 @@
 namespace mfem
 {
 
-double NonlinearFormIntegrator::GetLocalStateEnergyPA(const Vector &x) const
-{
-   mfem_error ("NonlinearFormIntegrator::GetLocalStateEnergyPA(...)\n"
-               "   is not implemented for this class.");
-   return 0.0;
-}
-
 void NonlinearFormIntegrator::AssemblePA(const FiniteElementSpace&)
 {
-   mfem_error ("NonlinearFormIntegrator::AssemblePA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssemblePA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssemblePA(const FiniteElementSpace &,
-                                         const FiniteElementSpace &)
+void NonlinearFormIntegrator::AssembleGradPA(const Vector &x,
+                                             const FiniteElementSpace &fes)
 {
-   mfem_error ("NonlinearFormIntegrator::AssemblePA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleGradPA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleGradPA(const Vector &x,
-                                             const FiniteElementSpace &fes)
+void NonlinearFormIntegrator::AssembleGradDiagonalPA(Vector &diag) const
 {
-   mfem_error ("NonlinearFormIntegrator::AssembleGradPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleGradDiagonalPA(...)\n"
+              "   is not implemented for this class.");
 }
 
 void NonlinearFormIntegrator::AddMultPA(const Vector &, Vector &) const
 {
-   mfem_error ("NonlinearFormIntegrator::AddMultPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AddMultPA(...)\n"
+              "   is not implemented for this class.");
 }
 
 void NonlinearFormIntegrator::AddMultGradPA(const Vector&, Vector&) const
 {
-   mfem_error ("NonlinearFormIntegrator::AddMultGradPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AddMultGradPA(...)\n"
+              "   is not implemented for this class.");
 }
 
-void NonlinearFormIntegrator::AssembleGradDiagonalPA(Vector &diag) const
+double NonlinearFormIntegrator::GetLocalStateEnergyPA(const Vector &x) const
 {
-   mfem_error ("NonlinearFormIntegrator::AssembleGradDiagonalPA(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::GetLocalStateEnergyPA(...)\n"
+              "   is not implemented for this class.");
+   return 0.0;
 }
 
 void NonlinearFormIntegrator::AssembleMF(const FiniteElementSpace &fes)
 {
-   mfem_error ("NonlinearFormIntegrator::AssembleMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleMF(...)\n"
+              "   is not implemented for this class.");
 }
 
 void NonlinearFormIntegrator::AddMultMF(const Vector &, Vector &) const
 {
-   mfem_error ("NonlinearFormIntegrator::AddMultMF(...)\n"
-               "   is not implemented for this class.");
+   MFEM_ABORT("NonlinearFormIntegrator::AddMultMF(...)\n"
+              "   is not implemented for this class.");
+}
+
+double NonlinearFormIntegrator::GetElementEnergy(
+   const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun)
+{
+   MFEM_ABORT("NonlinearFormIntegrator::GetElementEnergy"
+              " is not overloaded!");
+   return 0.0;
 }
 
 void NonlinearFormIntegrator::AssembleElementVector(
    const FiniteElement &el, ElementTransformation &Tr,
    const Vector &elfun, Vector &elvect)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleElementVector"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementVector"
               " is not overloaded!");
 }
 
@@ -84,7 +85,7 @@ void NonlinearFormIntegrator::AssembleFaceVector(
    const FiniteElement &el1, const FiniteElement &el2,
    FaceElementTransformations &Tr, const Vector &elfun, Vector &elvect)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleFaceVector"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceVector"
               " is not overloaded!");
 }
 
@@ -92,7 +93,7 @@ void NonlinearFormIntegrator::AssembleElementGrad(
    const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun,
    DenseMatrix &elmat)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleElementGrad"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleElementGrad"
               " is not overloaded!");
 }
 
@@ -101,18 +102,10 @@ void NonlinearFormIntegrator::AssembleFaceGrad(
    FaceElementTransformations &Tr, const Vector &elfun,
    DenseMatrix &elmat)
 {
-   mfem_error("NonlinearFormIntegrator::AssembleFaceGrad"
+   MFEM_ABORT("NonlinearFormIntegrator::AssembleFaceGrad"
               " is not overloaded!");
 }
 
-double NonlinearFormIntegrator::GetElementEnergy(
-   const FiniteElement &el, ElementTransformation &Tr, const Vector &elfun)
-{
-   mfem_error("NonlinearFormIntegrator::GetElementEnergy"
-              " is not overloaded!");
-   return 0.0;
-}
-
 
 void BlockNonlinearFormIntegrator::AssembleElementVector(
    const Array<const FiniteElement *> &el,
@@ -120,7 +113,7 @@ void BlockNonlinearFormIntegrator::AssembleElementVector(
    const Array<const Vector *> &elfun,
    const Array<Vector *> &elvec)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleElementVector"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementVector"
               " is not overloaded!");
 }
 
@@ -131,7 +124,7 @@ void BlockNonlinearFormIntegrator::AssembleFaceVector(
    const Array<const Vector *> &elfun,
    const Array<Vector *> &elvect)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleFaceVector"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceVector"
               " is not overloaded!");
 }
 
@@ -141,7 +134,7 @@ void BlockNonlinearFormIntegrator::AssembleElementGrad(
    const Array<const Vector *> &elfun,
    const Array2D<DenseMatrix *> &elmats)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleElementGrad"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleElementGrad"
               " is not overloaded!");
 }
 
@@ -152,7 +145,7 @@ void BlockNonlinearFormIntegrator::AssembleFaceGrad(
    const Array<const Vector *> &elfun,
    const Array2D<DenseMatrix *> &elmats)
 {
-   mfem_error("BlockNonlinearFormIntegrator::AssembleFaceGrad"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::AssembleFaceGrad"
               " is not overloaded!");
 }
 
@@ -161,7 +154,7 @@ double BlockNonlinearFormIntegrator::GetElementEnergy(
    ElementTransformation &Tr,
    const Array<const Vector *>&elfun)
 {
-   mfem_error("BlockNonlinearFormIntegrator::GetElementEnergy"
+   MFEM_ABORT("BlockNonlinearFormIntegrator::GetElementEnergy"
               " is not overloaded!");
    return 0.0;
 }
@@ -497,6 +490,7 @@ void HyperelasticNLFIntegrator::AssembleElementGrad(const FiniteElement &el,
    }
 }
 
+
 double IncompressibleNeoHookeanIntegrator::GetElementEnergy(
    const Array<const FiniteElement *>&el,
    ElementTransformation &Tr,
@@ -504,7 +498,7 @@ double IncompressibleNeoHookeanIntegrator::GetElementEnergy(
 {
    if (el.Size() != 2)
    {
-      mfem_error("IncompressibleNeoHookeanIntegrator::GetElementEnergy"
+      MFEM_ABORT("IncompressibleNeoHookeanIntegrator::GetElementEnergy"
                  " has incorrect block finite element space size!");
    }
 
@@ -549,7 +543,7 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementVector(
 {
    if (el.Size() != 2)
    {
-      mfem_error("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
+      MFEM_ABORT("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
                  " has finite element space of incorrect block number");
    }
 
@@ -561,11 +555,10 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementVector(
 
    if (dim != spaceDim)
    {
-      mfem_error("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
+      MFEM_ABORT("IncompressibleNeoHookeanIntegrator::AssembleElementVector"
                  " is not defined on manifold meshes");
    }
 
-
    DSh_u.SetSize(dof_u, dim);
    DS_u.SetSize(dof_u, dim);
    J0i.SetSize(dim);
@@ -731,6 +724,7 @@ void IncompressibleNeoHookeanIntegrator::AssembleElementGrad(
 
 }
 
+
 const IntegrationRule&
 VectorConvectionNLFIntegrator::GetRule(const FiniteElement &fe,
                                        ElementTransformation &T)
diff --git a/fem/nonlininteg.hpp b/fem/nonlininteg.hpp
index 54f342b85..38b133244 100644
--- a/fem/nonlininteg.hpp
+++ b/fem/nonlininteg.hpp
@@ -29,13 +29,12 @@ class NonlinearFormIntegrator
 protected:
    const IntegrationRule *IntRule;
 
-   // CEED extension
-   ceed::Operator* ceedOp;
+   ceed::Operator *ceedOp;  // libCEED extension
 
    MemoryType pa_mt = MemoryType::DEFAULT;
 
    NonlinearFormIntegrator(const IntegrationRule *ir = NULL)
-      : IntRule(ir), ceedOp(NULL) { }
+      : IntRule(ir), ceedOp(NULL) {}
 
 public:
    /** @brief Prescribe a fixed IntegrationRule to use (when @a ir != NULL) or
@@ -52,46 +51,11 @@ public:
    /// Get the integration rule of the integrator (possibly NULL).
    const IntegrationRule *GetIntegrationRule() const { return IntRule; }
 
-   /// Perform the local action of the NonlinearFormIntegrator
-   virtual void AssembleElementVector(const FiniteElement &el,
-                                      ElementTransformation &Tr,
-                                      const Vector &elfun, Vector &elvect);
-
-   /// @brief Perform the local action of the NonlinearFormIntegrator resulting
-   /// from a face integral term.
-   virtual void AssembleFaceVector(const FiniteElement &el1,
-                                   const FiniteElement &el2,
-                                   FaceElementTransformations &Tr,
-                                   const Vector &elfun, Vector &elvect);
-
-   /// Assemble the local gradient matrix
-   virtual void AssembleElementGrad(const FiniteElement &el,
-                                    ElementTransformation &Tr,
-                                    const Vector &elfun, DenseMatrix &elmat);
-
-   /// @brief Assemble the local action of the gradient of the
-   /// NonlinearFormIntegrator resulting from a face integral term.
-   virtual void AssembleFaceGrad(const FiniteElement &el1,
-                                 const FiniteElement &el2,
-                                 FaceElementTransformations &Tr,
-                                 const Vector &elfun, DenseMatrix &elmat);
-
-   /// Compute the local energy
-   virtual double GetElementEnergy(const FiniteElement &el,
-                                   ElementTransformation &Tr,
-                                   const Vector &elfun);
-
    /// Method defining partial assembly.
    /** The result of the partial assembly is stored internally so that it can be
        used later in the methods AddMultPA(). */
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   /** The result of the partial assembly is stored internally so that it can be
-       used later in the methods AddMultPA().
-       Used with BilinearFormIntegrators that have different spaces. */
-   virtual void AssemblePA(const FiniteElementSpace &trial_fes,
-                           const FiniteElementSpace &test_fes);
-
    /** @brief Prepare the integrator for partial assembly (PA) gradient
        evaluations on the given FE space @a fes at the state @a x. */
    /** The result of the partial assembly is stored internally so that it can be
@@ -99,10 +63,12 @@ public:
        The state Vector @a x is an E-vector. */
    virtual void AssembleGradPA(const Vector &x, const FiniteElementSpace &fes);
 
-   /// Compute the local (to the MPI rank) energy with partial assembly.
-   /** Here the state @a x is an E-vector. This method can be called only after
-       the method AssemblePA() has been called. */
-   virtual double GetLocalStateEnergyPA(const Vector &x) const;
+   /// Method for computing the diagonal of the gradient with partial assembly.
+   /** The result Vector @a diag is an E-Vector. This method can be called only
+       after the method AssembleGradPA() has been called.
+
+       @param[in,out] diag  The result Vector: @f$ diag += diag(G) @f$. */
+   virtual void AssembleGradDiagonalPA(Vector &diag) const;
 
    /// Method for partially assembled action.
    /** Perform the action of integrator on the input @a x and add the result to
@@ -121,15 +87,10 @@ public:
        @param[in,out] y  The result Vector: @f$ y += G x @f$. */
    virtual void AddMultGradPA(const Vector &x, Vector &y) const;
 
-   /// Method for computing the diagonal of the gradient with partial assembly.
-   /** The result Vector @a diag is an E-Vector. This method can be called only
-       after the method AssembleGradPA() has been called.
-
-       @param[in,out] diag  The result Vector: @f$ diag += diag(G) @f$. */
-   virtual void AssembleGradDiagonalPA(Vector &diag) const;
-
-   /// Indicates whether this integrator can use a Ceed backend.
-   virtual bool SupportsCeed() const { return false; }
+   /// Compute the local (to the MPI rank) energy with partial assembly.
+   /** Here the state @a x is an E-vector. This method can be called only after
+       the method AssemblePA() has been called. */
+   virtual double GetLocalStateEnergyPA(const Vector &x) const;
 
    /// Method defining fully unassembled operator.
    virtual void AssembleMF(const FiniteElementSpace &fes);
@@ -142,7 +103,39 @@ public:
        called. */
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 
-   ceed::Operator& GetCeedOp() { return *ceedOp; }
+   /// Compute the local energy
+   virtual double GetElementEnergy(const FiniteElement &el,
+                                   ElementTransformation &Tr,
+                                   const Vector &elfun);
+
+   /// Perform the local action of the NonlinearFormIntegrator
+   virtual void AssembleElementVector(const FiniteElement &el,
+                                      ElementTransformation &Tr,
+                                      const Vector &elfun, Vector &elvect);
+
+   /// @brief Perform the local action of the NonlinearFormIntegrator resulting
+   /// from a face integral term.
+   virtual void AssembleFaceVector(const FiniteElement &el1,
+                                   const FiniteElement &el2,
+                                   FaceElementTransformations &Tr,
+                                   const Vector &elfun, Vector &elvect);
+
+   /// Assemble the local gradient matrix
+   virtual void AssembleElementGrad(const FiniteElement &el,
+                                    ElementTransformation &Tr,
+                                    const Vector &elfun, DenseMatrix &elmat);
+
+   /// @brief Assemble the local action of the gradient of the
+   /// NonlinearFormIntegrator resulting from a face integral term.
+   virtual void AssembleFaceGrad(const FiniteElement &el1,
+                                 const FiniteElement &el2,
+                                 FaceElementTransformations &Tr,
+                                 const Vector &elfun, DenseMatrix &elmat);
+
+   /// Indicates whether this integrator can use a Ceed backend.
+   virtual bool SupportsCeed() const { return false; }
+
+   ceed::Operator &GetCeedOp() { return *ceedOp; }
 
    virtual ~NonlinearFormIntegrator()
    {
@@ -150,6 +143,7 @@ public:
    }
 };
 
+
 /** The abstract base class BlockNonlinearFormIntegrator is
     a generalization of the NonlinearFormIntegrator class suitable
     for block state vectors. */
@@ -185,7 +179,7 @@ public:
                                  const Array<const Vector *> &elfun,
                                  const Array2D<DenseMatrix *> &elmats);
 
-   virtual ~BlockNonlinearFormIntegrator() { }
+   virtual ~BlockNonlinearFormIntegrator() {}
 };
 
 
@@ -197,8 +191,8 @@ protected:
                                     transformation. */
 
 public:
-   HyperelasticModel() : Ttr(NULL) { }
-   virtual ~HyperelasticModel() { }
+   HyperelasticModel() : Ttr(NULL) {}
+   virtual ~HyperelasticModel() {}
 
    /// A reference-element to target-element transformation that can be used to
    /// evaluate Coefficient%s.
@@ -277,7 +271,7 @@ public:
 
    NeoHookeanModel(Coefficient &mu_, Coefficient &K_, Coefficient *g_ = NULL)
       : mu(0.0), K(0.0), g(1.0), c_mu(&mu_), c_K(&K_), c_g(g_),
-        have_coeffs(true) { }
+        have_coeffs(true) {}
 
    virtual double EvalW(const DenseMatrix &J) const;
 
@@ -314,7 +308,7 @@ private:
 
 public:
    /** @param[in] m  HyperelasticModel that will be integrated. */
-   HyperelasticNLFIntegrator(HyperelasticModel *m) : model(m) { }
+   HyperelasticNLFIntegrator(HyperelasticModel *m) : model(m) {}
 
    /** @brief Computes the integral of W(Jacobian(Trt)) over a target zone
        @param[in] el     Type of FiniteElement.
@@ -333,6 +327,7 @@ public:
                                     const Vector &elfun, DenseMatrix &elmat);
 };
 
+
 /** Hyperelastic incompressible Neo-Hookean integrator with the PK1 stress
     \f$P = \mu F - p F^{-T}\f$ where \f$\mu\f$ is the shear modulus,
     \f$p\f$ is the pressure, and \f$F\f$ is the deformation gradient */
@@ -345,7 +340,7 @@ private:
    Vector Sh_p;
 
 public:
-   IncompressibleNeoHookeanIntegrator(Coefficient &mu_) : c_mu(&mu_) { }
+   IncompressibleNeoHookeanIntegrator(Coefficient &mu_) : c_mu(&mu_) {}
 
    virtual double GetElementEnergy(const Array<const FiniteElement *>&el,
                                    ElementTransformation &Tr,
@@ -371,6 +366,7 @@ private:
    Coefficient *Q{};
    DenseMatrix dshape, dshapex, EF, gradEF, ELV, elmat_comp;
    Vector shape;
+
    // PA extension
    Vector pa_data;
    const DofToQuad *maps;         ///< Not owned
@@ -378,7 +374,7 @@ private:
    int dim, ne, nq;
 
 public:
-   VectorConvectionNLFIntegrator(Coefficient &q): Q(&q) { }
+   VectorConvectionNLFIntegrator(Coefficient &q): Q(&q) {}
 
    VectorConvectionNLFIntegrator() = default;
 
@@ -395,14 +391,12 @@ public:
                                     const Vector &elfun,
                                     DenseMatrix &elmat);
 
-   using NonlinearFormIntegrator::AssemblePA;
-
    virtual void AssemblePA(const FiniteElementSpace &fes);
 
-   virtual void AssembleMF(const FiniteElementSpace &fes);
-
    virtual void AddMultPA(const Vector &x, Vector &y) const;
 
+   virtual void AssembleMF(const FiniteElementSpace &fes);
+
    virtual void AddMultMF(const Vector &x, Vector &y) const;
 };
 
@@ -418,7 +412,7 @@ private:
    Vector shape;
 
 public:
-   ConvectiveVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) { }
+   ConvectiveVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) {}
 
    ConvectiveVectorConvectionNLFIntegrator() = default;
 
@@ -441,7 +435,7 @@ private:
    Vector shape;
 
 public:
-   SkewSymmetricVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) { }
+   SkewSymmetricVectorConvectionNLFIntegrator(Coefficient &q): Q(&q) {}
 
    SkewSymmetricVectorConvectionNLFIntegrator() = default;
 
diff --git a/fem/pbilinearform.cpp b/fem/pbilinearform.cpp
index ee1030c48..ee2dc79b2 100644
--- a/fem/pbilinearform.cpp
+++ b/fem/pbilinearform.cpp
@@ -151,7 +151,8 @@ void ParBilinearForm::ParallelRAP(SparseMatrix &loc_A, OperatorHandle &A,
    }
 }
 
-void ParBilinearForm::ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local)
+void ParBilinearForm::ParallelAssemble(OperatorHandle &A,
+                                       SparseMatrix *A_local) const
 {
    A.Clear();
 
@@ -201,6 +202,7 @@ void ParBilinearForm::ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local)
 
    // TODO - assemble the Dof_TrueDof_Matrix directly in the required format?
    Ph.ConvertFrom(pfes->Dof_TrueDof_Matrix());
+
    // TODO: When Ph.Type() == Operator::ANY_TYPE we want to use the Operator
    // returned by pfes->GetProlongationMatrix(), however that Operator is a
    // const Operator, so we cannot store it in OperatorHandle. We need a const
@@ -209,7 +211,7 @@ void ParBilinearForm::ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local)
    A.MakePtAP(dA, Ph);
 }
 
-HypreParMatrix *ParBilinearForm::ParallelAssemble(SparseMatrix *m)
+HypreParMatrix *ParBilinearForm::ParallelAssemble(SparseMatrix *m) const
 {
    OperatorHandle Mh(Operator::Hypre_ParCSR);
    ParallelAssemble(Mh, m);
@@ -246,10 +248,9 @@ void ParBilinearForm::AssembleSharedFaces(int skip_zeros)
       vdofs_all.Append(vdofs2);
       for (int k = 0; k < interior_face_integs.Size(); k++)
       {
-         interior_face_integs[k]->
-         AssembleFaceMatrix(*pfes->GetFE(T->Elem1No),
-                            *pfes->GetFaceNbrFE(Elem2NbrNo),
-                            *T, elemmat);
+         interior_face_integs[k]->AssembleFaceMatrix(*pfes->GetFE(T->Elem1No),
+                                                     *pfes->GetFaceNbrFE(Elem2NbrNo),
+                                                     *T, elemmat);
          if (keep_nbr_block)
          {
             mat->AddSubMatrix(vdofs_all, vdofs_all, elemmat, skip_zeros);
@@ -301,29 +302,23 @@ void ParBilinearForm::AssembleDiagonal(Vector &diag) const
    // Here, we have extension, ext, and parallel/conforming prolongation, P.
    Vector local_diag(P->Height());
    ext->AssembleDiagonal(local_diag);
-   if (fes->Conforming())
+   const HypreParMatrix *HP = dynamic_cast<const HypreParMatrix*>(P);
+   if (!HP)
    {
+      // This is a parallel prolongation
       P->MultTranspose(local_diag, diag);
       return;
    }
    // For an AMR mesh, a convergent diagonal is assembled with |P^T| d_l,
    // where |P^T| has the entry-wise absolute values of the conforming
    // prolongation transpose operator.
-   const HypreParMatrix *HP = dynamic_cast<const HypreParMatrix*>(P);
-   if (HP)
-   {
-      HP->AbsMultTranspose(1.0, local_diag, 0.0, diag);
-   }
-   else
-   {
-      MFEM_ABORT("unsupported prolongation matrix type.");
-   }
+   HP->AbsMultTranspose(1.0, local_diag, 0.0, diag);
 }
 
-void ParBilinearForm
-::ParallelEliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
-                               HypreParMatrix &A, const HypreParVector &X,
-                               HypreParVector &B) const
+void ParBilinearForm::ParallelEliminateEssentialBC(
+   const Array<int> &bdr_attr_is_ess,
+   HypreParMatrix &A, const HypreParVector &X,
+   HypreParVector &B) const
 {
    Array<int> dof_list;
 
@@ -333,9 +328,9 @@ void ParBilinearForm
    A.EliminateRowsCols(dof_list, X, B);
 }
 
-HypreParMatrix *ParBilinearForm::
-ParallelEliminateEssentialBC(const Array<int> &bdr_attr_is_ess,
-                             HypreParMatrix &A) const
+HypreParMatrix *ParBilinearForm::ParallelEliminateEssentialBC(
+   const Array<int> &bdr_attr_is_ess,
+   HypreParMatrix &A) const
 {
    Array<int> dof_list;
 
@@ -374,7 +369,17 @@ void ParBilinearForm::FormLinearSystem(
 {
    if (ext)
    {
-      ext->FormLinearSystem(ess_tdof_list, x, b, A, X, B, copy_interior);
+      Operator *oper;
+      ext->FormLinearSystem(ess_tdof_list, x, b, oper, X, B, copy_interior);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         delete oper;
+         FormSystemMatrix(ess_tdof_list, A);
+      }
+      else
+      {
+         A.Reset(oper);
+      }
       return;
    }
 
@@ -418,18 +423,28 @@ void ParBilinearForm::FormLinearSystem(
    }
 }
 
-void ParBilinearForm::EliminateVDofsInRHS(
-   const Array<int> &vdofs, const Vector &x, Vector &b)
-{
-   p_mat.EliminateBC(p_mat_e, vdofs, x, b);
-}
-
 void ParBilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
                                        OperatorHandle &A)
 {
    if (ext)
    {
-      ext->FormSystemMatrix(ess_tdof_list, A);
+      if (assembly == AssemblyLevel::FULL)
+      {
+         // Always does `DIAG_ONE` policy to be consistent with
+         // `Operator::FormConstrainedSystemOperator`.
+         MFEM_VERIFY(diag_policy == DiagonalPolicy::DIAG_ONE,
+                     "Only DiagonalPolicy::DIAG_ONE supported with"
+                     " FABilinearFormExtension.");
+         ParallelRAP(*mat, A);
+         A.As<HypreParMatrix>()->EliminateBC(ess_tdof_list,
+                                             DiagonalPolicy::DIAG_ONE);
+      }
+      else
+      {
+         Operator *oper;
+         ext->FormSystemOperator(ess_tdof_list, oper);
+         A.Reset(oper);
+      }
       return;
    }
 
@@ -460,6 +475,7 @@ void ParBilinearForm::FormSystemMatrix(const Array<int> &ess_tdof_list,
          delete mat_e;
          mat_e = NULL;
          p_mat_e.EliminateRowsCols(p_mat, ess_tdof_list);
+         A = p_mat;
       }
       if (hybridization)
       {
@@ -521,30 +537,22 @@ void ParBilinearForm::Update(FiniteElementSpace *nfes)
    p_mat_e.Clear();
 }
 
-
-HypreParMatrix *ParMixedBilinearForm::ParallelAssemble()
+void ParBilinearForm::EliminateVDofsInRHS(
+   const Array<int> &vdofs, const Vector &x, Vector &b)
 {
-   // construct the block-diagonal matrix A
-   HypreParMatrix *A =
-      new HypreParMatrix(trial_pfes->GetComm(),
-                         test_pfes->GlobalVSize(),
-                         trial_pfes->GlobalVSize(),
-                         test_pfes->GetDofOffsets(),
-                         trial_pfes->GetDofOffsets(),
-                         mat);
+   p_mat.EliminateBC(p_mat_e, vdofs, x, b);
+}
 
-   HypreParMatrix *rap = RAP(test_pfes->Dof_TrueDof_Matrix(), A,
-                             trial_pfes->Dof_TrueDof_Matrix());
+void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A) const
+{
+   A.Clear();
 
-   delete A;
+   if (mat == NULL) { return; }
+   MFEM_VERIFY(mat->Finalized(), "the local matrix must be finalized");
 
-   return rap;
-}
+   OperatorHandle dA(A.Type()), P_test(A.Type()), P_trial(A.Type());
 
-void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A)
-{
    // construct the rectangular block-diagonal matrix dA
-   OperatorHandle dA(A.Type());
    dA.MakeRectangularBlockDiag(trial_pfes->GetComm(),
                                test_pfes->GlobalVSize(),
                                trial_pfes->GlobalVSize(),
@@ -552,8 +560,6 @@ void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A)
                                trial_pfes->GetDofOffsets(),
                                mat);
 
-   OperatorHandle P_test(A.Type()), P_trial(A.Type());
-
    // TODO - construct the Dof_TrueDof_Matrix directly in the required format.
    P_test.ConvertFrom(test_pfes->Dof_TrueDof_Matrix());
    P_trial.ConvertFrom(trial_pfes->Dof_TrueDof_Matrix());
@@ -561,6 +567,14 @@ void ParMixedBilinearForm::ParallelAssemble(OperatorHandle &A)
    A.MakeRAP(P_test, dA, P_trial);
 }
 
+HypreParMatrix *ParMixedBilinearForm::ParallelAssemble() const
+{
+   OperatorHandle Mh(Operator::Hypre_ParCSR);
+   ParallelAssemble(Mh);
+   Mh.SetOperatorOwner(false);
+   return Mh.As<HypreParMatrix>();
+}
+
 /// Compute y += a (P^t A P) x, where x and y are vectors on the true dofs
 void ParMixedBilinearForm::TrueAddMult(const Vector &x, Vector &y,
                                        const double a) const
@@ -576,21 +590,55 @@ void ParMixedBilinearForm::TrueAddMult(const Vector &x, Vector &y,
    test_pfes->Dof_TrueDof_Matrix()->MultTranspose(a, Yaux, 1.0, y);
 }
 
+void ParMixedBilinearForm::FormRectangularLinearSystem(
+   const Array<int> &trial_tdof_list,
+   const Array<int> &test_tdof_list, Vector &x,
+   Vector &b, OperatorHandle &A, Vector &X,
+   Vector &B)
+{
+   if (ext)
+   {
+      Operator *oper;
+      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
+                                       x, b, oper, X, B);
+      A.Reset(oper);
+      return;
+   }
+
+   FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, A);
+
+   const Operator *test_P = test_pfes->GetProlongationMatrix();
+   const SparseMatrix *trial_R = trial_pfes->GetRestrictionMatrix();
+
+   X.SetSize(trial_pfes->TrueVSize());
+   B.SetSize(test_pfes->TrueVSize());
+   test_P->MultTranspose(b, B);
+   trial_R->Mult(x, X);
+
+   p_mat_e.As<HypreParMatrix>()->Mult(-1.0, X, 1.0, B);
+   B.SetSubVector(test_tdof_list, 0.0);
+}
+
 void ParMixedBilinearForm::FormRectangularSystemMatrix(
-   const Array<int>
-   &trial_tdof_list,
+   const Array<int> &trial_tdof_list,
    const Array<int> &test_tdof_list,
    OperatorHandle &A)
 {
    if (ext)
    {
-      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, A);
+      Operator *oper;
+      ext->FormRectangularSystemOperator(trial_tdof_list, test_tdof_list, oper);
+      A.Reset(oper);
       return;
    }
 
    if (mat)
    {
-      Finalize();
+      const int remove_zeros = 0;
+      Finalize(remove_zeros);
+      MFEM_VERIFY(p_mat.Ptr() == NULL && p_mat_e.Ptr() == NULL,
+                  "The ParMixedBilinearFormBilinearForm must be updated "
+                  "with Update() before re-assembling the ParMixedBilinearFormBilinearForm.");
       ParallelAssemble(p_mat);
       delete mat;
       mat = NULL;
@@ -600,97 +648,89 @@ void ParMixedBilinearForm::FormRectangularSystemMatrix(
          p_mat.As<HypreParMatrix>()->EliminateCols(trial_tdof_list);
       p_mat.As<HypreParMatrix>()->EliminateRows(test_tdof_list);
       p_mat_e.Reset(temp, true);
+      A = p_mat;
    }
-
-   A = p_mat;
 }
 
-void ParMixedBilinearForm::FormRectangularLinearSystem(
-   const Array<int>
-   &trial_tdof_list,
-   const Array<int> &test_tdof_list, Vector &x,
-   Vector &b, OperatorHandle &A, Vector &X,
-   Vector &B)
+void ParDiscreteLinearOperator::ParallelAssemble(OperatorHandle &A) const
 {
-   if (ext)
+   A.Clear();
+
+   if (mat == NULL) { return; }
+   MFEM_VERIFY(mat->Finalized(), "the local matrix must be finalized");
+
+   if (A.Type() == Operator::Hypre_ParCSR)
    {
-      ext->FormRectangularLinearSystem(trial_tdof_list, test_tdof_list,
-                                       x, b, A, X, B);
-      return;
+      const SparseMatrix *R = range_fes->GetRestrictionMatrix();
+      const HypreParMatrix *P = domain_fes->Dof_TrueDof_Matrix();
+      SparseMatrix *RA = mfem::Mult(*R, *mat);
+      A.Reset(P->LeftDiagMult(*RA, range_fes->GetTrueDofOffsets()));
+      delete RA;
    }
+   else
+   {
+      OperatorHandle dA(A.Type()), P_trial(A.Type()), Rt_test(A.Type());
 
-   FormRectangularSystemMatrix(trial_tdof_list, test_tdof_list, A);
+      // construct the rectangular block-diagonal matrix dA
+      dA.MakeRectangularBlockDiag(domain_fes->GetComm(),
+                                  range_fes->GlobalVSize(),
+                                  domain_fes->GlobalVSize(),
+                                  range_fes->GetDofOffsets(),
+                                  domain_fes->GetDofOffsets(),
+                                  mat);
 
-   const Operator *test_P = test_pfes->GetProlongationMatrix();
-   const SparseMatrix *trial_R = trial_pfes->GetRestrictionMatrix();
+      SparseMatrix *Rt = Transpose(*range_fes->GetRestrictionMatrix());
+      Rt_test.MakeRectangularBlockDiag(range_fes->GetComm(),
+                                       range_fes->GlobalVSize(),
+                                       range_fes->GlobalTrueVSize(),
+                                       range_fes->GetDofOffsets(),
+                                       range_fes->GetTrueDofOffsets(),
+                                       Rt);
 
-   X.SetSize(trial_pfes->TrueVSize());
-   B.SetSize(test_pfes->TrueVSize());
-   test_P->MultTranspose(b, B);
-   trial_R->Mult(x, X);
-
-   p_mat_e.As<HypreParMatrix>()->Mult(-1.0, X, 1.0, B);
-   B.SetSubVector(test_tdof_list, 0.0);
-}
+      // TODO - construct the Dof_TrueDof_Matrix directly in the required format.
+      P_trial.ConvertFrom(domain_fes->Dof_TrueDof_Matrix());
 
-HypreParMatrix* ParDiscreteLinearOperator::ParallelAssemble() const
-{
-   MFEM_ASSERT(mat, "Matrix is not assembled");
-   MFEM_ASSERT(mat->Finalized(), "Matrix is not finalized");
-   SparseMatrix* RA = mfem::Mult(*range_fes->GetRestrictionMatrix(), *mat);
-   HypreParMatrix* P = domain_fes->Dof_TrueDof_Matrix();
-   HypreParMatrix* RAP = P->LeftDiagMult(*RA, range_fes->GetTrueDofOffsets());
-   delete RA;
-   return RAP;
+      A.MakeRAP(Rt_test, dA, P_trial);
+      delete Rt;
+   }
 }
 
-void ParDiscreteLinearOperator::ParallelAssemble(OperatorHandle &A)
+HypreParMatrix *ParDiscreteLinearOperator::ParallelAssemble() const
 {
-   // construct the rectangular block-diagonal matrix dA
-   OperatorHandle dA(A.Type());
-   dA.MakeRectangularBlockDiag(domain_fes->GetComm(),
-                               range_fes->GlobalVSize(),
-                               domain_fes->GlobalVSize(),
-                               range_fes->GetDofOffsets(),
-                               domain_fes->GetDofOffsets(),
-                               mat);
-
-   SparseMatrix *Rt = Transpose(*range_fes->GetRestrictionMatrix());
-   OperatorHandle R_test_transpose(A.Type());
-   R_test_transpose.MakeRectangularBlockDiag(range_fes->GetComm(),
-                                             range_fes->GlobalVSize(),
-                                             range_fes->GlobalTrueVSize(),
-                                             range_fes->GetDofOffsets(),
-                                             range_fes->GetTrueDofOffsets(),
-                                             Rt);
-
-   // TODO - construct the Dof_TrueDof_Matrix directly in the required format.
-   OperatorHandle P_trial(A.Type());
-   P_trial.ConvertFrom(domain_fes->Dof_TrueDof_Matrix());
-
-   A.MakeRAP(R_test_transpose, dA, P_trial);
-   delete Rt;
+   OperatorHandle Mh(Operator::Hypre_ParCSR);
+   ParallelAssemble(Mh);
+   Mh.SetOperatorOwner(false);
+   return Mh.As<HypreParMatrix>();
 }
 
-void ParDiscreteLinearOperator::FormRectangularSystemMatrix(OperatorHandle &A)
+void ParDiscreteLinearOperator::FormDiscreteOperatorMatrix(OperatorHandle &A)
 {
    if (ext)
    {
-      Array<int> empty;
-      ext->FormRectangularSystemOperator(empty, empty, A);
+      Operator *oper;
+      ext->FormDiscreteOperator(oper);
+      A.Reset(oper);
       return;
    }
 
-   mfem_error("not implemented!");
+   if (mat)
+   {
+      Finalize();
+      ParallelAssemble(A);
+      delete mat;
+      mat = NULL;
+      delete mat_e;
+      mat_e = NULL;
+   }
 }
 
-void ParDiscreteLinearOperator::GetParBlocks(Array2D<HypreParMatrix *> &blocks)
-const
+void ParDiscreteLinearOperator::GetParBlocks(
+   Array2D<HypreParMatrix *> &blocks)
 {
    MFEM_VERIFY(mat->Finalized(), "Local matrix needs to be finalized for "
                "GetParBlocks");
 
-   HypreParMatrix* RLP = ParallelAssemble();
+   HypreParMatrix *RLP = ParallelAssemble();
 
    blocks.SetSize(range_fes->GetVDim(), domain_fes->GetVDim());
 
diff --git a/fem/pbilinearform.hpp b/fem/pbilinearform.hpp
index c8fef567b..ffb0e9c6b 100644
--- a/fem/pbilinearform.hpp
+++ b/fem/pbilinearform.hpp
@@ -28,6 +28,7 @@ namespace mfem
 class ParBilinearForm : public BilinearForm
 {
    friend FABilinearFormExtension;
+
 protected:
    ParFiniteElementSpace *pfes; ///< Points to the same object as #fes
 
@@ -103,40 +104,40 @@ public:
 
    /// Returns the matrix assembled on the true dofs, i.e. P^t A P.
    /** The returned matrix has to be deleted by the caller. */
-   HypreParMatrix *ParallelAssemble() { return ParallelAssemble(mat); }
+   HypreParMatrix *ParallelAssemble() const { return ParallelAssemble(mat); }
 
    /// Returns the eliminated matrix assembled on the true dofs, i.e. P^t A_e P.
    /** The returned matrix has to be deleted by the caller. */
-   HypreParMatrix *ParallelAssembleElim() { return ParallelAssemble(mat_e); }
+   HypreParMatrix *ParallelAssembleElim() const { return ParallelAssemble(mat_e); }
 
    /// Return the matrix @a m assembled on the true dofs, i.e. P^t A P.
    /** The returned matrix has to be deleted by the caller. */
-   HypreParMatrix *ParallelAssemble(SparseMatrix *m);
-
-   /** @brief Compute parallel RAP operator and store it in @a A as a HypreParMatrix.
-
-       @param[in] loc_A The rank-local `SparseMatrix`.
-       @param[out] A The `OperatorHandle` containing the global `HypreParMatrix`.
-       @param[in] steal_loc_A Have the `HypreParMatrix` in @a A take ownership of
-                              the memory objects in @a loc_A.
-       */
-   void ParallelRAP(SparseMatrix &loc_A,
-                    OperatorHandle &A,
-                    bool steal_loc_A = false);
+   HypreParMatrix *ParallelAssemble(SparseMatrix *m) const;
 
    /** @brief Returns the matrix assembled on the true dofs, i.e.
        @a A = P^t A_local P, in the format (type id) specified by @a A. */
-   void ParallelAssemble(OperatorHandle &A) { ParallelAssemble(A, mat); }
+   void ParallelAssemble(OperatorHandle &A) const { ParallelAssemble(A, mat); }
 
    /** Returns the eliminated matrix assembled on the true dofs, i.e.
        @a A_elim = P^t A_elim_local P in the format (type id) specified by @a A.
     */
-   void ParallelAssembleElim(OperatorHandle &A_elim)
+   void ParallelAssembleElim(OperatorHandle &A_elim) const
    { ParallelAssemble(A_elim, mat_e); }
 
    /** Returns the matrix @a A_local assembled on the true dofs, i.e.
        @a A = P^t A_local P in the format (type id) specified by @a A. */
-   void ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local);
+   void ParallelAssemble(OperatorHandle &A, SparseMatrix *A_local) const;
+
+   /** @brief Compute parallel RAP operator and store it in @a A as a HypreParMatrix.
+
+       @param[in] loc_A The rank-local `SparseMatrix`.
+       @param[out] A The `OperatorHandle` containing the global `HypreParMatrix`.
+       @param[in] steal_loc_A Have the `HypreParMatrix` in @a A take ownership of
+                              the memory objects in @a loc_A.
+       */
+   void ParallelRAP(SparseMatrix &loc_A,
+                    OperatorHandle &A,
+                    bool steal_loc_A = false);
 
    /// Eliminate essential boundary DOFs from a parallel assembled system.
    /** The array @a bdr_attr_is_ess marks boundary attributes that constitute
@@ -183,9 +184,7 @@ public:
    /// Get the parallel finite element space prolongation matrix
    virtual const Operator *GetProlongation() const
    { return pfes->GetProlongationMatrix(); }
-   /// Get the transpose of GetRestriction, useful for matrix-free RAP
-   virtual const Operator *GetRestrictionTranspose() const
-   { return pfes->GetRestrictionTransposeOperator(); }
+
    /// Get the parallel finite element space restriction matrix
    virtual const Operator *GetRestriction() const
    { return pfes->GetRestrictionMatrix(); }
@@ -209,7 +208,7 @@ public:
 
    void EliminateVDofsInRHS(const Array<int> &vdofs, const Vector &x, Vector &b);
 
-   virtual ~ParBilinearForm() { }
+   virtual ~ParBilinearForm() {}
 };
 
 /// Class for parallel bilinear form using different test and trial FE spaces.
@@ -258,7 +257,7 @@ public:
        by the newly constructed ParMixedBilinearForm. */
    ParMixedBilinearForm(ParFiniteElementSpace *trial_fes,
                         ParFiniteElementSpace *test_fes,
-                        ParMixedBilinearForm * mbf)
+                        ParMixedBilinearForm *mbf)
       : MixedBilinearForm(trial_fes, test_fes, mbf),
         p_mat(Operator::Hypre_ParCSR), p_mat_e(Operator::Hypre_ParCSR)
    {
@@ -267,24 +266,16 @@ public:
    }
 
    /// Returns the matrix assembled on the true dofs, i.e. P_test^t A P_trial.
-   HypreParMatrix *ParallelAssemble();
+   HypreParMatrix *ParallelAssemble() const;
 
    /** @brief Returns the matrix assembled on the true dofs, i.e.
        @a A = P_test^t A_local P_trial, in the format (type id) specified by
        @a A. */
-   void ParallelAssemble(OperatorHandle &A);
+   void ParallelAssemble(OperatorHandle &A) const;
 
    using MixedBilinearForm::FormRectangularSystemMatrix;
    using MixedBilinearForm::FormRectangularLinearSystem;
 
-   /** @brief Return in @a A a parallel (on truedofs) version of this operator.
-
-       This returns the same operator as FormRectangularLinearSystem(), but does
-       without the transformations of the right-hand side. */
-   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
-                                            const Array<int> &test_tdof_list,
-                                            OperatorHandle &A);
-
    /** @brief Form the parallel linear system A X = B, corresponding to this mixed
        bilinear form and the linear form @a b(.).
 
@@ -296,10 +287,18 @@ public:
                                             Vector &b, OperatorHandle &A, Vector &X,
                                             Vector &B);
 
+   /** @brief Return in @a A a parallel (on truedofs) version of this operator.
+
+       This returns the same operator as FormRectangularLinearSystem(), but does
+       without the transformations of the right-hand side. */
+   virtual void FormRectangularSystemMatrix(const Array<int> &trial_tdof_list,
+                                            const Array<int> &test_tdof_list,
+                                            OperatorHandle &A);
+
    /// Compute y += a (P^t A P) x, where x and y are vectors on the true dofs
    void TrueAddMult(const Vector &x, Vector &y, const double a = 1.0) const;
 
-   virtual ~ParMixedBilinearForm() { }
+   virtual ~ParMixedBilinearForm() {}
 };
 
 /** The parallel matrix representation a linear operator between parallel finite
@@ -335,18 +334,18 @@ public:
    /** @brief Returns the matrix assembled on the true dofs, i.e.
        @a A = R_test A_local P_trial, in the format (type id) specified by
        @a A. */
-   void ParallelAssemble(OperatorHandle &A);
-
-   /** Extract the parallel blocks corresponding to the vector dimensions of the
-       domain and range parallel finite element spaces */
-   void GetParBlocks(Array2D<HypreParMatrix *> &blocks) const;
+   void ParallelAssemble(OperatorHandle &A) const;
 
-   using MixedBilinearForm::FormRectangularSystemMatrix;
+   using DiscreteLinearOperator::FormDiscreteOperatorMatrix;
 
    /** @brief Return in @a A a parallel (on truedofs) version of this operator. */
-   virtual void FormRectangularSystemMatrix(OperatorHandle &A);
+   virtual void FormDiscreteOperatorMatrix(OperatorHandle &A);
+
+   /** Extract the parallel blocks corresponding to the vector dimensions of the
+       domain and range parallel finite element spaces */
+   void GetParBlocks(Array2D<HypreParMatrix *> &blocks);
 
-   virtual ~ParDiscreteLinearOperator() { }
+   virtual ~ParDiscreteLinearOperator() {}
 };
 
 }
diff --git a/fem/pfespace.cpp b/fem/pfespace.cpp
index 51f0df2f6..6beb97c72 100644
--- a/fem/pfespace.cpp
+++ b/fem/pfespace.cpp
@@ -101,8 +101,6 @@ void ParFiniteElementSpace::ParInit(ParMesh *pm)
    P = NULL;
    Pconf = NULL;
    nonconf_P = false;
-   Rconf = NULL;
-   R_transpose = NULL;
    R = NULL;
 
    num_face_nbr_dofs = -1;
@@ -961,6 +959,34 @@ void ParFiniteElementSpace::Build_Dof_TrueDof_Matrix() const // matrix P
    R = Transpose(Pdiag);
 }
 
+const Operator *ParFiniteElementSpace::GetProlongationMatrix() const
+{
+   if (Conforming() && !nd_strias)
+   {
+      if (Pconf) { return Pconf; }
+      if (NRanks == 1)
+      {
+         Pconf = new IdentityOperator(GetTrueVSize());
+      }
+      else
+      {
+         if (!Device::Allows(Backend::DEVICE_MASK))
+         {
+            Pconf = new ConformingProlongationOperator(*this);
+         }
+         else
+         {
+            Pconf = new DeviceConformingProlongationOperator(*this);
+         }
+      }
+      return Pconf;
+   }
+   else
+   {
+      return Dof_TrueDof_Matrix();
+   }
+}
+
 HypreParMatrix *ParFiniteElementSpace::GetPartialConformingInterpolation()
 {
    HypreParMatrix *P_pc;
@@ -1150,76 +1176,6 @@ HYPRE_BigInt ParFiniteElementSpace::GetMyTDofOffset() const
    return HYPRE_AssumedPartitionCheck()? tdof_offsets[0] : tdof_offsets[MyRank];
 }
 
-const Operator *ParFiniteElementSpace::GetProlongationMatrix() const
-{
-   if (Conforming())
-   {
-      if (Pconf) { return Pconf; }
-
-      if (nd_strias) { return Dof_TrueDof_Matrix(); }
-
-      if (NRanks == 1)
-      {
-         Pconf = new IdentityOperator(GetTrueVSize());
-      }
-      else
-      {
-         if (!Device::Allows(Backend::DEVICE_MASK))
-         {
-            Pconf = new ConformingProlongationOperator(*this);
-         }
-         else
-         {
-            Pconf = new DeviceConformingProlongationOperator(*this);
-         }
-      }
-      return Pconf;
-   }
-   else
-   {
-      return Dof_TrueDof_Matrix();
-   }
-}
-
-const Operator *ParFiniteElementSpace::GetRestrictionOperator() const
-{
-   if (Conforming())
-   {
-      if (Rconf) { return Rconf; }
-
-      if (NRanks == 1)
-      {
-         R_transpose = new IdentityOperator(GetTrueVSize());
-      }
-      else
-      {
-         if (!Device::Allows(Backend::DEVICE_MASK))
-         {
-            R_transpose = new ConformingProlongationOperator(*this, true);
-         }
-         else
-         {
-            R_transpose =
-               new DeviceConformingProlongationOperator(*this, true);
-         }
-      }
-      Rconf = new TransposeOperator(R_transpose);
-      return Rconf;
-   }
-   else
-   {
-      Dof_TrueDof_Matrix();
-      R_transpose = new TransposeOperator(R);
-      return R;
-   }
-}
-
-const Operator *ParFiniteElementSpace::GetRestrictionTransposeOperator() const
-{
-   GetRestrictionOperator();
-   return R_transpose;
-}
-
 void ParFiniteElementSpace::ExchangeFaceNbrData()
 {
    if (num_face_nbr_dofs >= 0) { return; }
@@ -3186,8 +3142,6 @@ void ParFiniteElementSpace::Destroy()
 
    delete P; P = NULL;
    delete Pconf; Pconf = NULL;
-   delete Rconf; Rconf = NULL;
-   delete R_transpose; R_transpose = NULL;
    delete R; R = NULL;
 
    delete gcomm; gcomm = NULL;
@@ -3393,8 +3347,8 @@ void ParFiniteElementSpace::UpdateMeshPointer(Mesh *new_mesh)
 }
 
 ConformingProlongationOperator::ConformingProlongationOperator(
-   int lsize, const GroupCommunicator &gc_, bool local_)
-   : gc(gc_), local(local_)
+   int lsize, const GroupCommunicator &gc_)
+   : gc(gc_)
 {
    const Table &group_ldof = gc.GroupLDofTable();
 
@@ -3429,11 +3383,10 @@ const
 }
 
 ConformingProlongationOperator::ConformingProlongationOperator(
-   const ParFiniteElementSpace &pfes, bool local_)
+   const ParFiniteElementSpace &pfes)
    : Operator(pfes.GetVSize(), pfes.GetTrueVSize()),
      external_ldofs(),
-     gc(pfes.GroupComm()),
-     local(local_)
+     gc(pfes.GroupComm())
 {
    MFEM_VERIFY(pfes.Conforming(), "");
    const Table &group_ldof = gc.GroupLDofTable();
@@ -3482,14 +3435,7 @@ void ConformingProlongationOperator::Mult(const Vector &x, Vector &y) const
    const int m = external_ldofs.Size();
 
    const int in_layout = 2; // 2 - input is ltdofs array
-   if (local)
-   {
-      y = 0.0;
-   }
-   else
-   {
-      gc.BcastBegin(const_cast<double*>(xdata), in_layout);
-   }
+   gc.BcastBegin(const_cast<double*>(xdata), in_layout);
 
    int j = 0;
    for (int i = 0; i < m; i++)
@@ -3501,10 +3447,7 @@ void ConformingProlongationOperator::Mult(const Vector &x, Vector &y) const
    std::copy(xdata+j-m, xdata+Width(), ydata+j);
 
    const int out_layout = 0; // 0 - output is ldofs array
-   if (!local)
-   {
-      gc.BcastEnd(ydata, out_layout);
-   }
+   gc.BcastEnd(ydata, out_layout);
 }
 
 void ConformingProlongationOperator::MultTranspose(
@@ -3517,10 +3460,7 @@ void ConformingProlongationOperator::MultTranspose(
    double *ydata = y.HostWrite();
    const int m = external_ldofs.Size();
 
-   if (!local)
-   {
-      gc.ReduceBegin(xdata);
-   }
+   gc.ReduceBegin(xdata);
 
    int j = 0;
    for (int i = 0; i < m; i++)
@@ -3532,15 +3472,12 @@ void ConformingProlongationOperator::MultTranspose(
    std::copy(xdata+j, xdata+Height(), ydata+j-m);
 
    const int out_layout = 2; // 2 - output is an array on all ltdofs
-   if (!local)
-   {
-      gc.ReduceEnd<double>(ydata, out_layout, GroupCommunicator::Sum);
-   }
+   gc.ReduceEnd<double>(ydata, out_layout, GroupCommunicator::Sum);
 }
 
 DeviceConformingProlongationOperator::DeviceConformingProlongationOperator(
-   const GroupCommunicator &gc_, const SparseMatrix *R, bool local_)
-   : ConformingProlongationOperator(R->Width(), gc_, local_),
+   const GroupCommunicator &gc_, const SparseMatrix *R)
+   : ConformingProlongationOperator(R->Width(), gc_),
      mpi_gpu_aware(Device::GetGPUAwareMPI())
 {
    MFEM_ASSERT(R->Finalized(), "");
@@ -3605,10 +3542,9 @@ DeviceConformingProlongationOperator::DeviceConformingProlongationOperator(
 }
 
 DeviceConformingProlongationOperator::DeviceConformingProlongationOperator(
-   const ParFiniteElementSpace &pfes, bool local_)
+   const ParFiniteElementSpace &pfes)
    : DeviceConformingProlongationOperator(pfes.GroupComm(),
-                                          pfes.GetRestrictionMatrix(),
-                                          local_)
+                                          pfes.GetRestrictionMatrix())
 {
    MFEM_ASSERT(pfes.Conforming(), "internal error");
    MFEM_ASSERT(pfes.GetRestrictionMatrix()->Height() == pfes.GetTrueVSize(), "");
@@ -3672,48 +3608,36 @@ void DeviceConformingProlongationOperator::Mult(const Vector &x,
                                                 Vector &y) const
 {
    const GroupTopology &gtopo = gc.GetGroupTopology();
-   int req_counter = 0;
    // Make sure 'y' is marked as valid on device and for use on device.
    // This ensures that there is no unnecessary host to device copy when the
-   // input 'y' is valid on host (in 'y.SetSubVector(ext_ldof, 0.0)' when local
-   // is true) or BcastLocalCopy (when local is false).
+   // input 'y' is valid on host.
    y.Write();
-   if (local)
-   {
-      // done on device since we've marked ext_ldof for use on device:
-      y.SetSubVector(ext_ldof, 0.0);
-   }
-   else
+   BcastBeginCopy(x); // copy to 'shr_buf'
+   int req_counter = 0;
+   for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
    {
-      BcastBeginCopy(x); // copy to 'shr_buf'
-      for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
+      const int send_offset = shr_buf_offsets[nbr];
+      const int send_size = shr_buf_offsets[nbr+1] - send_offset;
+      if (send_size > 0)
       {
-         const int send_offset = shr_buf_offsets[nbr];
-         const int send_size = shr_buf_offsets[nbr+1] - send_offset;
-         if (send_size > 0)
-         {
-            auto send_buf = mpi_gpu_aware ? shr_buf.Read() : shr_buf.HostRead();
-            MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41822,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
-         const int recv_offset = ext_buf_offsets[nbr];
-         const int recv_size = ext_buf_offsets[nbr+1] - recv_offset;
-         if (recv_size > 0)
-         {
-            auto recv_buf = mpi_gpu_aware ? ext_buf.Write() : ext_buf.HostWrite();
-            MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41822,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
+         auto send_buf = mpi_gpu_aware ? shr_buf.Read() : shr_buf.HostRead();
+         MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41822,
+                   gtopo.GetComm(), &requests[req_counter++]);
+      }
+      const int recv_offset = ext_buf_offsets[nbr];
+      const int recv_size = ext_buf_offsets[nbr+1] - recv_offset;
+      if (recv_size > 0)
+      {
+         auto recv_buf = mpi_gpu_aware ? ext_buf.Write() : ext_buf.HostWrite();
+         MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41822,
+                   gtopo.GetComm(), &requests[req_counter++]);
       }
    }
    BcastLocalCopy(x, y);
-   if (!local)
-   {
-      MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
-      BcastEndCopy(y); // copy from 'ext_buf'
-   }
+   MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
+   BcastEndCopy(y); // copy from 'ext_buf'
 }
 
 DeviceConformingProlongationOperator::~DeviceConformingProlongationOperator()
@@ -3774,38 +3698,32 @@ void DeviceConformingProlongationOperator::MultTranspose(const Vector &x,
                                                          Vector &y) const
 {
    const GroupTopology &gtopo = gc.GetGroupTopology();
+   ReduceBeginCopy(x); // copy to 'ext_buf'
    int req_counter = 0;
-   if (!local)
+   for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
    {
-      ReduceBeginCopy(x); // copy to 'ext_buf'
-      for (int nbr = 1; nbr < gtopo.GetNumNeighbors(); nbr++)
+      const int send_offset = ext_buf_offsets[nbr];
+      const int send_size = ext_buf_offsets[nbr+1] - send_offset;
+      if (send_size > 0)
       {
-         const int send_offset = ext_buf_offsets[nbr];
-         const int send_size = ext_buf_offsets[nbr+1] - send_offset;
-         if (send_size > 0)
-         {
-            auto send_buf = mpi_gpu_aware ? ext_buf.Read() : ext_buf.HostRead();
-            MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41823,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
-         const int recv_offset = shr_buf_offsets[nbr];
-         const int recv_size = shr_buf_offsets[nbr+1] - recv_offset;
-         if (recv_size > 0)
-         {
-            auto recv_buf = mpi_gpu_aware ? shr_buf.Write() : shr_buf.HostWrite();
-            MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
-                      gtopo.GetNeighborRank(nbr), 41823,
-                      gtopo.GetComm(), &requests[req_counter++]);
-         }
+         auto send_buf = mpi_gpu_aware ? ext_buf.Read() : ext_buf.HostRead();
+         MPI_Isend(send_buf + send_offset, send_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41823,
+                   gtopo.GetComm(), &requests[req_counter++]);
+      }
+      const int recv_offset = shr_buf_offsets[nbr];
+      const int recv_size = shr_buf_offsets[nbr+1] - recv_offset;
+      if (recv_size > 0)
+      {
+         auto recv_buf = mpi_gpu_aware ? shr_buf.Write() : shr_buf.HostWrite();
+         MPI_Irecv(recv_buf + recv_offset, recv_size, MPI_DOUBLE,
+                   gtopo.GetNeighborRank(nbr), 41823,
+                   gtopo.GetComm(), &requests[req_counter++]);
       }
    }
    ReduceLocalCopy(x, y);
-   if (!local)
-   {
-      MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
-      ReduceEndAssemble(y); // assemble from 'shr_buf'
-   }
+   MPI_Waitall(req_counter, requests, MPI_STATUSES_IGNORE);
+   ReduceEndAssemble(y); // assemble from 'shr_buf'
 }
 
 } // namespace mfem
diff --git a/fem/pfespace.hpp b/fem/pfespace.hpp
index 8f574670b..c4a95a365 100644
--- a/fem/pfespace.hpp
+++ b/fem/pfespace.hpp
@@ -70,6 +70,7 @@ private:
 
    /// The matrix P (interpolation from true dof to dof). Owned.
    mutable HypreParMatrix *P;
+
    /// Optimized action-only prolongation operator for conforming meshes. Owned.
    mutable Operator *Pconf;
 
@@ -80,12 +81,6 @@ private:
 
    /// The (block-diagonal) matrix R (restriction of dof to true dof). Owned.
    mutable SparseMatrix *R;
-   /// Optimized action-only restriction operator for conforming meshes. Owned.
-   mutable Operator *Rconf;
-   /** Transpose of R or Rconf. For conforming mesh, this is a matrix-free
-       (Device)ConformingProlongationOperator, for a non-conforming mesh
-       this is a TransposeOperator wrapping R. */
-   mutable Operator *R_transpose;
 
    /// Flag indicating the existence of shared triangles with interior ND dofs
    bool nd_strias;
@@ -321,6 +316,13 @@ public:
    HypreParMatrix *Dof_TrueDof_Matrix() const
    { if (!P) { Build_Dof_TrueDof_Matrix(); } return P; }
 
+   /// Get the P matrix which prolongates a true dof vector to local dof vector.
+   virtual const Operator *GetProlongationMatrix() const;
+
+   /// Get the R matrix which restricts a local dof vector to true dof vector.
+   virtual const SparseMatrix *GetRestrictionMatrix() const
+   { Dof_TrueDof_Matrix(); return R; }
+
    /** @brief For a non-conforming mesh, construct and return the interpolation
        matrix from the partially conforming true dofs to the local dofs. */
    /** @note The returned pointer must be deleted by the caller. */
@@ -374,21 +376,6 @@ public:
    HYPRE_BigInt GetMyDofOffset() const;
    HYPRE_BigInt GetMyTDofOffset() const;
 
-   virtual const Operator *GetProlongationMatrix() const;
-   /** @brief Return logical transpose of restriction matrix, but in
-       non-assembled optimized matrix-free form.
-
-       The implementation is like GetProlongationMatrix, but it sets local
-       DOFs to the true DOF values if owned locally, otherwise zero. */
-   virtual const Operator *GetRestrictionTransposeOperator() const;
-   /** Get an Operator that performs the action of GetRestrictionMatrix(),
-       but potentially with a non-assembled optimized matrix-free
-       implementation. */
-   virtual const Operator *GetRestrictionOperator() const;
-   /// Get the R matrix which restricts a local dof vector to true dof vector.
-   virtual const SparseMatrix *GetRestrictionMatrix() const
-   { Dof_TrueDof_Matrix(); return R; }
-
    // Face-neighbor functions
    void ExchangeFaceNbrData();
    int GetFaceNbrVSize() const { return num_face_nbr_dofs; }
@@ -434,21 +421,17 @@ public:
    int TrueVSize() const { return ltdof_size; }
 };
 
-
 /// Auxiliary class used by ParFiniteElementSpace.
 class ConformingProlongationOperator : public Operator
 {
 protected:
    Array<int> external_ldofs;
    const GroupCommunicator &gc;
-   bool local;
 
 public:
-   ConformingProlongationOperator(int lsize, const GroupCommunicator &gc_,
-                                  bool local_=false);
+   ConformingProlongationOperator(int lsize, const GroupCommunicator &gc_);
 
-   ConformingProlongationOperator(const ParFiniteElementSpace &pfes,
-                                  bool local_=false);
+   ConformingProlongationOperator(const ParFiniteElementSpace &pfes);
 
    const GroupCommunicator &GetGroupCommunicator() const;
 
@@ -458,8 +441,8 @@ public:
 };
 
 /// Auxiliary device class used by ParFiniteElementSpace.
-class DeviceConformingProlongationOperator: public
-   ConformingProlongationOperator
+class DeviceConformingProlongationOperator :
+   public ConformingProlongationOperator
 {
 protected:
    bool mpi_gpu_aware;
@@ -495,11 +478,10 @@ protected:
    void ReduceEndAssemble(Vector &dst) const;
 
 public:
-   DeviceConformingProlongationOperator(
-      const GroupCommunicator &gc_, const SparseMatrix *R, bool local_=false);
+   DeviceConformingProlongationOperator(const GroupCommunicator &gc_,
+                                        const SparseMatrix *R);
 
-   DeviceConformingProlongationOperator(const ParFiniteElementSpace &pfes,
-                                        bool local_=false);
+   DeviceConformingProlongationOperator(const ParFiniteElementSpace &pfes);
 
    virtual ~DeviceConformingProlongationOperator();
 
diff --git a/fem/prestriction.cpp b/fem/prestriction.cpp
index b383af103..0b90c85d0 100644
--- a/fem/prestriction.cpp
+++ b/fem/prestriction.cpp
@@ -331,7 +331,7 @@ void ParL2FaceRestriction::DoubleValuedConformingMult(
    auto d_x_shared = Reshape(x_gf.FaceNbrData().Read(),
                              t?vd:nsdofs, t?nsdofs:vd);
    auto d_y = Reshape(y.Write(), nface_dofs, vd, 2, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
    {
       const int dof = i % nface_dofs;
       const int face = i / nface_dofs;
diff --git a/fem/restriction.cpp b/fem/restriction.cpp
index da4eab5fa..15f4e8089 100644
--- a/fem/restriction.cpp
+++ b/fem/restriction.cpp
@@ -12,27 +12,24 @@
 #include "restriction.hpp"
 #include "gridfunc.hpp"
 #include "fespace.hpp"
-#include "../general/forall.hpp"
-#include <climits>
-
 #ifdef MFEM_USE_MPI
-
 #include "pfespace.hpp"
-
 #endif
+#include "../general/forall.hpp"
+#include <climits>
 
 namespace mfem
 {
 
-ElementRestriction::ElementRestriction(const FiniteElementSpace &f,
-                                       ElementDofOrdering e_ordering)
+ConformingElementRestriction::ConformingElementRestriction(
+   const FiniteElementSpace &f,
+   ElementDofOrdering e_ordering)
    : fes(f),
      ne(fes.GetNE()),
      vdim(fes.GetVDim()),
      byvdim(fes.GetOrdering() == Ordering::byVDIM),
      ndofs(fes.GetNDofs()),
      dof(ne > 0 ? fes.GetFE(0)->GetDof() : 0),
-     nedofs(ne*dof),
      offsets(ndofs+1),
      indices(ne*dof),
      gather_map(ne*dof)
@@ -104,7 +101,7 @@ ElementRestriction::ElementRestriction(const FiniteElementSpace &f,
    offsets[0] = 0;
 }
 
-void ElementRestriction::Mult(const Vector& x, Vector& y) const
+void ConformingElementRestriction::Mult(const Vector& x, Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -126,7 +123,8 @@ void ElementRestriction::Mult(const Vector& x, Vector& y) const
    });
 }
 
-void ElementRestriction::MultUnsigned(const Vector& x, Vector& y) const
+void ConformingElementRestriction::MultUnsigned(const Vector& x,
+                                                Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -135,7 +133,6 @@ void ElementRestriction::MultUnsigned(const Vector& x, Vector& y) const
    auto d_x = Reshape(x.Read(), t?vd:ndofs, t?ndofs:vd);
    auto d_y = Reshape(y.Write(), nd, vd, ne);
    auto d_gather_map = gather_map.Read();
-
    mfem::forall(dof*ne, [=] MFEM_HOST_DEVICE (int i)
    {
       const int gid = d_gather_map[i];
@@ -148,12 +145,13 @@ void ElementRestriction::MultUnsigned(const Vector& x, Vector& y) const
 }
 
 template <bool ADD>
-void ElementRestriction::TAddMultTranspose(const Vector& x, Vector& y) const
+static inline void TAddMultTranspose(const int nd, const int vd, const bool t,
+                                     const int ndofs, const int ne,
+                                     const Array<int>& offsets,
+                                     const Array<int>& indices,
+                                     const Vector& x, Vector& y)
 {
    // Assumes all elements have the same number of dofs
-   const int nd = dof;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_offsets = offsets.Read();
    auto d_indices = indices.Read();
    auto d_x = Reshape(x.Read(), nd, vd, ne);
@@ -177,21 +175,23 @@ void ElementRestriction::TAddMultTranspose(const Vector& x, Vector& y) const
    });
 }
 
-void ElementRestriction::MultTranspose(const Vector& x, Vector& y) const
+void ConformingElementRestriction::MultTranspose(const Vector& x,
+                                                 Vector& y) const
 {
    constexpr bool ADD = false;
-   TAddMultTranspose<ADD>(x, y);
+   TAddMultTranspose<ADD>(dof, vdim, byvdim, ndofs, ne, offsets, indices, x, y);
 }
 
-void ElementRestriction::AddMultTranspose(const Vector& x, Vector& y,
-                                          const double a) const
+void ConformingElementRestriction::AddMultTranspose(const Vector& x, Vector& y,
+                                                    const double a) const
 {
    MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    constexpr bool ADD = true;
-   TAddMultTranspose<ADD>(x, y);
+   TAddMultTranspose<ADD>(dof, vdim, byvdim, ndofs, ne, offsets, indices, x, y);
 }
 
-void ElementRestriction::MultTransposeUnsigned(const Vector& x, Vector& y) const
+void ConformingElementRestriction::MultLeftInverse(const Vector& x,
+                                                   Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -203,22 +203,21 @@ void ElementRestriction::MultTransposeUnsigned(const Vector& x, Vector& y) const
    auto d_y = Reshape(y.Write(), t?vd:ndofs, t?ndofs:vd);
    mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
    {
-      const int offset = d_offsets[i];
       const int next_offset = d_offsets[i + 1];
       for (int c = 0; c < vd; ++c)
       {
          double dof_value = 0;
-         for (int j = offset; j < next_offset; ++j)
-         {
-            const int idx_j = (d_indices[j] >= 0) ? d_indices[j] : -1 - d_indices[j];
-            dof_value += d_x(idx_j % nd, c, idx_j / nd);
-         }
+         const int j = next_offset - 1;
+         const int idx_j = (d_indices[j] >= 0) ? d_indices[j] : -1 - d_indices[j];
+         dof_value = (d_indices[j] >= 0) ? d_x(idx_j % nd, c, idx_j / nd) :
+                     -d_x(idx_j % nd, c, idx_j / nd);
          d_y(t?c:i,t?i:c) = dof_value;
       }
    });
 }
 
-void ElementRestriction::MultLeftInverse(const Vector& x, Vector& y) const
+void ConformingElementRestriction::MultTransposeUnsigned(const Vector& x,
+                                                         Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
@@ -230,29 +229,29 @@ void ElementRestriction::MultLeftInverse(const Vector& x, Vector& y) const
    auto d_y = Reshape(y.Write(), t?vd:ndofs, t?ndofs:vd);
    mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
    {
+      const int offset = d_offsets[i];
       const int next_offset = d_offsets[i + 1];
       for (int c = 0; c < vd; ++c)
       {
          double dof_value = 0;
-         const int j = next_offset - 1;
-         const int idx_j = (d_indices[j] >= 0) ? d_indices[j] : -1 - d_indices[j];
-         dof_value = (d_indices[j] >= 0) ? d_x(idx_j % nd, c, idx_j / nd) :
-                     -d_x(idx_j % nd, c, idx_j / nd);
+         for (int j = offset; j < next_offset; ++j)
+         {
+            const int idx_j = (d_indices[j] >= 0) ? d_indices[j] : -1 - d_indices[j];
+            dof_value += d_x(idx_j % nd, c, idx_j / nd);
+         }
          d_y(t?c:i,t?i:c) = dof_value;
       }
    });
 }
 
-void ElementRestriction::BooleanMask(Vector& y) const
+void ConformingElementRestriction::BooleanMask(Vector& y) const
 {
    // Assumes all elements have the same number of dofs
    const int nd = dof;
    const int vd = vdim;
    const bool t = byvdim;
-
    Array<char> processed(vd * ndofs);
    processed = 0;
-
    auto d_offsets = offsets.HostRead();
    auto d_indices = indices.HostRead();
    auto d_x = Reshape(processed.HostReadWrite(), t?vd:ndofs, t?ndofs:vd);
@@ -280,8 +279,8 @@ void ElementRestriction::BooleanMask(Vector& y) const
    }
 }
 
-void ElementRestriction::FillSparseMatrix(const Vector &mat_ea,
-                                          SparseMatrix &mat) const
+void ConformingElementRestriction::FillSparseMatrix(const Vector &mat_ea,
+                                                    SparseMatrix &mat) const
 {
    mat.GetMemoryI().New(mat.Height()+1, mat.GetMemoryI().GetMemoryType());
    const int nnz = FillI(mat);
@@ -319,7 +318,7 @@ static MFEM_HOST_DEVICE int GetAndIncrementNnzIndex(const int i_L, int* I)
    return ind;
 }
 
-int ElementRestriction::FillI(SparseMatrix &mat) const
+int ConformingElementRestriction::FillI(SparseMatrix &mat) const
 {
    static constexpr int Max = MaxNbNbr;
    const int all_dofs = ndofs;
@@ -396,8 +395,8 @@ int ElementRestriction::FillI(SparseMatrix &mat) const
    return h_I[nTdofs];
 }
 
-void ElementRestriction::FillJAndData(const Vector &ea_data,
-                                      SparseMatrix &mat) const
+void ConformingElementRestriction::FillJAndData(const Vector &ea_data,
+                                                SparseMatrix &mat) const
 {
    static constexpr int Max = MaxNbNbr;
    const int all_dofs = ndofs;
@@ -523,11 +522,10 @@ void L2ElementRestriction::Mult(const Vector &x, Vector &y) const
 }
 
 template <bool ADD>
-void L2ElementRestriction::TAddMultTranspose(const Vector &x, Vector &y) const
+static void L2TAddMultTranspose(const int nd, const int vd, const bool t,
+                                const int ndofs, const int ne,
+                                const Vector &x, Vector &y)
 {
-   const int nd = ndof;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_x = Reshape(x.Read(), nd, vd, ne);
    auto d_y = Reshape(ADD ? y.ReadWrite() : y.Write(), t?vd:ndofs, t?ndofs:vd);
    mfem::forall(ndofs, [=] MFEM_HOST_DEVICE (int i)
@@ -546,7 +544,7 @@ void L2ElementRestriction::TAddMultTranspose(const Vector &x, Vector &y) const
 void L2ElementRestriction::MultTranspose(const Vector &x, Vector &y) const
 {
    constexpr bool ADD = false;
-   TAddMultTranspose<ADD>(x, y);
+   L2TAddMultTranspose<ADD>(ndof, vdim, byvdim, ndofs, ne, x, y);
 }
 
 void L2ElementRestriction::AddMultTranspose(const Vector &x, Vector &y,
@@ -554,7 +552,7 @@ void L2ElementRestriction::AddMultTranspose(const Vector &x, Vector &y,
 {
    MFEM_VERIFY(a == 1.0, "General coefficient case is not yet supported!");
    constexpr bool ADD = true;
-   TAddMultTranspose<ADD>(x, y);
+   L2TAddMultTranspose<ADD>(ndof, vdim, byvdim, ndofs, ne, x, y);
 }
 
 void L2ElementRestriction::FillI(SparseMatrix &mat) const
@@ -609,7 +607,6 @@ ConformingFaceRestriction::ConformingFaceRestriction(
      byvdim(fes.GetOrdering() == Ordering::byVDIM),
      face_dofs(nf > 0 ? fes.GetFaceElement(0)->GetDof() : 0),
      elem_dofs(fes.GetFE(0)->GetDof()),
-     nfdofs(nf*face_dofs),
      ndofs(fes.GetNDofs()),
      scatter_indices(nf*face_dofs),
      gather_offsets(ndofs+1),
@@ -651,30 +648,47 @@ ConformingFaceRestriction::ConformingFaceRestriction(
    : ConformingFaceRestriction(fes, f_ordering, type, true)
 { }
 
-void ConformingFaceRestriction::Mult(const Vector& x, Vector& y) const
+static void ConformingFaceRestriction_Mult(
+   const int ndofs,
+   const int face_dofs,
+   const int nf,
+   const int vdim,
+   const bool by_vdim,
+   const Array<int> &scatter_indices,
+   const Vector &x,
+   Vector &y,
+   bool use_signs)
 {
    if (nf==0) { return; }
    // Assumes all elements have the same number of dofs
-   const int nface_dofs = face_dofs;
-   const int vd = vdim;
-   const bool t = byvdim;
    auto d_indices = scatter_indices.Read();
-   auto d_x = Reshape(x.Read(), t?vd:ndofs, t?ndofs:vd);
-   auto d_y = Reshape(y.Write(), nface_dofs, vd, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
+   auto d_x = Reshape(x.Read(), by_vdim?vdim:ndofs, by_vdim?ndofs:vdim);
+   auto d_y = Reshape(y.Write(), face_dofs, vdim, nf);
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
    {
-      const int s_idx = d_indices[i];
-      const int sgn = (s_idx >= 0) ? 1 : -1;
-      const int idx = (s_idx >= 0) ? s_idx : -1 - s_idx;
-      const int dof = i % nface_dofs;
-      const int face = i / nface_dofs;
-      for (int c = 0; c < vd; ++c)
+      const int s_idx_j = d_indices[i];
+      const double sgn = (s_idx_j >= 0 || !use_signs) ? 1.0 : -1.0;
+      const int idx_j = (s_idx_j >= 0) ? s_idx_j : -1 - s_idx_j;
+      for (int c = 0; c < vdim; ++c)
       {
-         d_y(dof, c, face) = sgn*d_x(t?c:idx, t?idx:c);
+         d_y(i % face_dofs, c, i / face_dofs) =
+            sgn*d_x(by_vdim?c:idx_j, by_vdim?idx_j:c);
       }
    });
 }
 
+void ConformingFaceRestriction::Mult(const Vector& x, Vector& y) const
+{
+   ConformingFaceRestriction_Mult(
+      ndofs, face_dofs, nf, vdim, byvdim, scatter_indices, x, y, true);
+}
+
+void ConformingFaceRestriction::MultUnsigned(const Vector& x, Vector& y) const
+{
+   ConformingFaceRestriction_Mult(
+      ndofs, face_dofs, nf, vdim, byvdim, scatter_indices, x, y, false);
+}
+
 static void ConformingFaceRestriction_AddMultTranspose(
    const int ndofs,
    const int face_dofs,
@@ -1042,7 +1056,6 @@ L2FaceRestriction::L2FaceRestriction(const FiniteElementSpace &fes,
                fes.GetTraceElement(0, fes.GetMesh()->GetFaceGeometry(0))->GetDof()
                : 0),
      elem_dofs(fes.GetFE(0)->GetDof()),
-     nfdofs(nf*face_dofs),
      ndofs(fes.GetNDofs()),
      type(type),
      m(m),
@@ -1084,7 +1097,7 @@ void L2FaceRestriction::SingleValuedConformingMult(const Vector& x,
    auto d_indices1 = scatter_indices1.Read();
    auto d_x = Reshape(x.Read(), t?vd:ndofs, t?ndofs:vd);
    auto d_y = Reshape(y.Write(), nface_dofs, vd, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
    {
       const int dof = i % nface_dofs;
       const int face = i / nface_dofs;
@@ -1110,7 +1123,7 @@ void L2FaceRestriction::DoubleValuedConformingMult(const Vector& x,
    auto d_indices2 = scatter_indices2.Read();
    auto d_x = Reshape(x.Read(), t?vd:ndofs, t?ndofs:vd);
    auto d_y = Reshape(y.Write(), nface_dofs, vd, 2, nf);
-   mfem::forall(nfdofs, [=] MFEM_HOST_DEVICE (int i)
+   mfem::forall(face_dofs*nf, [=] MFEM_HOST_DEVICE (int i)
    {
       const int dof = i % nface_dofs;
       const int face = i / nface_dofs;
@@ -1161,7 +1174,7 @@ void L2FaceRestriction::SingleValuedConformingAddMultTranspose(
          for (int j = offset; j < next_offset; ++j)
          {
             int idx_j = d_indices[j];
-            dof_value +=  d_x(idx_j % nface_dofs, c, idx_j / nface_dofs);
+            dof_value += d_x(idx_j % nface_dofs, c, idx_j / nface_dofs);
          }
          d_y(t?c:i,t?i:c) += dof_value;
       }
@@ -1175,7 +1188,7 @@ void L2FaceRestriction::DoubleValuedConformingAddMultTranspose(
    const int nface_dofs = face_dofs;
    const int vd = vdim;
    const bool t = byvdim;
-   const int dofs = nfdofs;
+   const int dofs = face_dofs*nf;
    auto d_offsets = gather_offsets.Read();
    auto d_indices = gather_indices.Read();
    auto d_x = Reshape(x.Read(), nface_dofs, vd, 2, nf);
@@ -1192,9 +1205,8 @@ void L2FaceRestriction::DoubleValuedConformingAddMultTranspose(
             int idx_j = d_indices[j];
             bool isE1 = idx_j < dofs;
             idx_j = isE1 ? idx_j : idx_j - dofs;
-            dof_value +=  isE1 ?
-                          d_x(idx_j % nface_dofs, c, 0, idx_j / nface_dofs)
-                          :d_x(idx_j % nface_dofs, c, 1, idx_j / nface_dofs);
+            dof_value += (isE1 ? d_x(idx_j % nface_dofs, c, 0, idx_j / nface_dofs)
+                          : d_x(idx_j % nface_dofs, c, 1, idx_j / nface_dofs));
          }
          d_y(t?c:i,t?i:c) += dof_value;
       }
@@ -1589,7 +1601,7 @@ void L2FaceRestriction::PermuteAndSetFaceDofsGatherIndices2(
       const int global_dof_elem2 = elem_map[elem_index*elem_dofs + volume_dof_elem2];
       const int restriction_dof_elem2 = face_dofs*face_index + face_dof_elem1;
       // We shift restriction_dof_elem2 to express that it's elem2 of the face
-      gather_indices[gather_offsets[global_dof_elem2]++] = nfdofs +
+      gather_indices[gather_offsets[global_dof_elem2]++] = face_dofs*nf +
                                                            restriction_dof_elem2;
    }
 }
diff --git a/fem/restriction.hpp b/fem/restriction.hpp
index 6ee367cde..405ee30b8 100644
--- a/fem/restriction.hpp
+++ b/fem/restriction.hpp
@@ -22,19 +22,51 @@ class FiniteElementSpace;
 enum class ElementDofOrdering;
 
 /// Abstract base class that defines an interface for element restrictions.
-class ElementRestrictionOperator : public Operator
+class ElementRestriction : public Operator
 {
 public:
-   /// @brief Add the E-vector degrees of freedom @a x to the L-vector degrees
-   /// of freedom @a y.
+   /** @brief Extract the degrees of freedom from @a x into @a y. */
+   void Mult(const Vector &x, Vector &y) const override = 0;
+
+   /** @brief Set the degrees of freedom in the element degrees of freedom
+       @a y to the values given in @a x. */
+   void MultTranspose(const Vector &x, Vector &y) const override
+   {
+      y = 0.0;
+      AddMultTranspose(x, y);
+   }
+
+   /** @brief Add the degrees of freedom @a x to the element degrees of
+       freedom @a y. */
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override = 0;
+
+   /** @brief Compute MultTranspose by setting (rather than adding) element
+       contributions, the left inverse of the Mult() operation. */
+   virtual void MultLeftInverse(const Vector &x, Vector &y) const
+   {
+      MultTranspose(x, y);
+   }
+
+   /** @brief Add the degrees of freedom @a x to the element degrees of
+       freedom @a y ignoring the signs from DOF orientation. */
+   virtual void MultUnsigned(const Vector &x, Vector &y) const
+   {
+      Mult(x, y);
+   }
+
+   /** @brief Add the degrees of freedom @a x to the element degrees of
+       freedom @a y ignoring the signs from DOF orientation. */
+   virtual void MultTransposeUnsigned(const Vector &x, Vector &y) const
+   {
+      MultTranspose(x, y);
+   }
 };
 
 /// Operator that converts FiniteElementSpace L-vectors to E-vectors.
 /** Objects of this type are typically created and owned by FiniteElementSpace
     objects, see FiniteElementSpace::GetElementRestriction(). */
-class ElementRestriction : public ElementRestrictionOperator
+class ConformingElementRestriction : public ElementRestriction
 {
 private:
    /** This number defines the maximum number of elements any dof can belong to
@@ -48,26 +80,25 @@ protected:
    const bool byvdim;
    const int ndofs;
    const int dof;
-   const int nedofs;
    Array<int> offsets;
    Array<int> indices;
    Array<int> gather_map;
 
 public:
-   ElementRestriction(const FiniteElementSpace&, ElementDofOrdering);
+   ConformingElementRestriction(const FiniteElementSpace&, ElementDofOrdering);
+
    void Mult(const Vector &x, Vector &y) const override;
+
    void MultTranspose(const Vector &x, Vector &y) const override;
+
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override;
 
-   /// Compute Mult without applying signs based on DOF orientations.
-   void MultUnsigned(const Vector &x, Vector &y) const;
-   /// Compute MultTranspose without applying signs based on DOF orientations.
-   void MultTransposeUnsigned(const Vector &x, Vector &y) const;
+   void MultLeftInverse(const Vector &x, Vector &y) const override;
 
-   /// Compute MultTranspose by setting (rather than adding) element
-   /// contributions; this is a left inverse of the Mult() operation
-   void MultLeftInverse(const Vector &x, Vector &y) const;
+   void MultUnsigned(const Vector &x, Vector &y) const override;
+
+   void MultTransposeUnsigned(const Vector &x, Vector &y) const override;
 
    /// @brief Fills the E-vector y with `boolean` values 0.0 and 1.0 such that each
    /// each entry of the L-vector is uniquely represented in `y`.
@@ -81,16 +112,13 @@ public:
    void FillSparseMatrix(const Vector &mat_ea, SparseMatrix &mat) const;
 
    /** Fill the I array of SparseMatrix corresponding to the sparsity pattern
-       given by this ElementRestriction. */
+       given by this ConformingElementRestriction. */
    int FillI(SparseMatrix &mat) const;
+
    /** Fill the J and Data arrays of SparseMatrix corresponding to the sparsity
-       pattern given by this ElementRestriction, and the values of ea_data. */
+       pattern given by this ConformingElementRestriction, and the values of
+       ea_data. */
    void FillJAndData(const Vector &ea_data, SparseMatrix &mat) const;
-   /// @private Not part of the public interface (device kernel limitation).
-   ///
-   /// Performs either MultTranspose or AddMultTranspose depending on the
-   /// boolean template parameter @a ADD.
-   template <bool ADD> void TAddMultTranspose(const Vector &x, Vector &y) const;
 
    /// @name Low-level access to the underlying element-dof mappings
    ///@{
@@ -105,37 +133,39 @@ public:
     objects, see FiniteElementSpace::GetElementRestriction(). L-vectors
     corresponding to grid functions in L2 finite element spaces differ from
     E-vectors only in the ordering of the degrees of freedom. */
-class L2ElementRestriction : public ElementRestrictionOperator
+class L2ElementRestriction : public ElementRestriction
 {
+private:
    const int ne;
    const int vdim;
    const bool byvdim;
    const int ndof;
    const int ndofs;
+
 public:
    L2ElementRestriction(const FiniteElementSpace&);
+
    void Mult(const Vector &x, Vector &y) const override;
+
    void MultTranspose(const Vector &x, Vector &y) const override;
+
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override;
+
    /** Fill the I array of SparseMatrix corresponding to the sparsity pattern
        given by this ElementRestriction. */
    void FillI(SparseMatrix &mat) const;
+
    /** Fill the J and Data arrays of SparseMatrix corresponding to the sparsity
        pattern given by this L2FaceRestriction, and the values of ea_data. */
    void FillJAndData(const Vector &ea_data, SparseMatrix &mat) const;
-   /// @private Not part of the public interface (device kernel limitation).
-   ///
-   /// Performs either MultTranspose or AddMultTranspose depending on the
-   /// boolean template parameter @a ADD.
-   template <bool ADD> void TAddMultTranspose(const Vector &x, Vector &y) const;
 };
 
 /** An enum type to specify if only e1 value is requested (SingleValued) or both
     e1 and e2 (DoubleValued). */
 enum class L2FaceValues : bool {SingleValued, DoubleValued};
 
-/** @brief Base class for operators that extracts Face degrees of freedom.
+/** @brief Abstract base class for operators that extracts Face degrees of freedom.
 
     In order to compute quantities on the faces of a mesh, it is often useful to
     extract the degrees of freedom on the faces of the elements. This class
@@ -173,6 +203,19 @@ public:
    */
    void Mult(const Vector &x, Vector &y) const override = 0;
 
+   /** @brief Set the face degrees of freedom in the element degrees of freedom
+       @a y to the values given in @a x.
+
+       @param[in]     x The face degrees of freedom on the face.
+       @param[in,out] y The L-vector of degrees of freedom to which we add the
+                        face degrees of freedom.
+   */
+   void MultTranspose(const Vector &x, Vector &y) const override
+   {
+      y = 0.0;
+      AddMultTranspose(x, y);
+   }
+
    /** @brief Add the face degrees of freedom @a x to the element degrees of
        freedom @a y.
 
@@ -181,8 +224,15 @@ public:
                         face degrees of freedom.
        @param[in]     a Scalar coefficient for addition.
    */
-   virtual void AddMultTranspose(const Vector &x, Vector &y,
-                                 const double a = 1.0) const override = 0;
+   void AddMultTranspose(const Vector &x, Vector &y,
+                         const double a = 1.0) const override = 0;
+
+   /** @brief Extract the face degrees of freedom from @a x into @a y ignoring
+       the signs from DOF orientation. */
+   virtual void MultUnsigned(const Vector &x, Vector &y) const
+   {
+      Mult(x, y);
+   }
 
    /** @brief Add the face degrees of freedom @a x to the element degrees of
        freedom @a y ignoring the signs from DOF orientation. */
@@ -196,7 +246,7 @@ public:
        freedom @a y. Perform the same computation as AddMultTranspose, but
        @a x is invalid after calling this method.
 
-       @param[in,out]     x The face degrees of freedom on the face.
+       @param[in,out] x The face degrees of freedom on the face.
        @param[in,out] y The L-vector of degrees of freedom to which we add the
                         face degrees of freedom.
 
@@ -207,19 +257,6 @@ public:
    {
       AddMultTranspose(x, y);
    }
-
-   /** @brief Set the face degrees of freedom in the element degrees of freedom
-       @a y to the values given in @a x.
-
-       @param[in]     x The face degrees of freedom on the face.
-       @param[in,out] y The L-vector of degrees of freedom to which we add the
-                        face degrees of freedom.
-   */
-   void MultTranspose(const Vector &x, Vector &y) const override
-   {
-      y = 0.0;
-      AddMultTranspose(x, y);
-   }
 };
 
 /// @brief Operator that extracts face degrees of freedom for H1, ND, or RT
@@ -236,7 +273,6 @@ protected:
    const bool byvdim;
    const int face_dofs; // Number of dofs on each face
    const int elem_dofs; // Number of dofs in each element
-   const int nfdofs; // Total number of face E-vector dofs
    const int ndofs; // Total number of dofs
    Array<int> scatter_indices; // Scattering indices for element 1 on each face
    Array<int> gather_offsets; // offsets for the gathering indices of each dof
@@ -256,6 +292,7 @@ protected:
                              const ElementDofOrdering f_ordering,
                              const FaceType type,
                              bool build);
+
 public:
    /** @brief Construct a ConformingFaceRestriction.
 
@@ -278,19 +315,23 @@ public:
                      ElementDofOrdering. */
    void Mult(const Vector &x, Vector &y) const override;
 
-   using FaceRestriction::AddMultTransposeInPlace;
+   /** @brief Extract the face degrees of freedom from @a x into @a y ignoring
+       the signs from DOF orientation.
+
+       @sa Mult(). */
+   void MultUnsigned(const Vector &x, Vector &y) const override;
 
    /** @brief Gather the degrees of freedom, i.e. goes from face E-Vector to
        L-Vector.
 
-       @param[in]  x The face E-Vector degrees of freedom with the given format:
-                     face_dofs x vdim x nf
-                     where nf is the number of interior or boundary faces
-                     requested by @a type in the constructor.
-                     The face_dofs should be ordered according to the given
-                     ElementDofOrdering
+       @param[in]     x The face E-Vector degrees of freedom with the given format:
+                        face_dofs x vdim x nf
+                        where nf is the number of interior or boundary faces
+                        requested by @a type in the constructor.
+                        The face_dofs should be ordered according to the given
+                        ElementDofOrdering
        @param[in,out] y The L-vector degrees of freedom.
-       @param[in]  a Scalar coefficient for addition. */
+       @param[in]     a Scalar coefficient for addition. */
    void AddMultTranspose(const Vector &x, Vector &y,
                          const double a = 1.0) const override;
 
@@ -371,7 +412,6 @@ protected:
    const bool byvdim;
    const int face_dofs; // Number of dofs on each face
    const int elem_dofs; // Number of dofs in each element
-   const int nfdofs; // Total number of dofs on the faces
    const int ndofs; // Total number of dofs
    const FaceType type;
    const L2FaceValues m;
@@ -423,8 +463,6 @@ public:
                      ElementDofOrdering. */
    void Mult(const Vector &x, Vector &y) const override;
 
-   using FaceRestriction::AddMultTranspose;
-
    /** @brief Gather the degrees of freedom, i.e. goes from face E-Vector to
        L-Vector.
 
@@ -821,6 +859,7 @@ protected:
                        const FaceType type,
                        const L2FaceValues m,
                        bool build);
+
 public:
    /** @brief Constructs an NCL2FaceRestriction, this is a specialization of a
        L2FaceRestriction for nonconforming meshes.
diff --git a/fem/transfer.cpp b/fem/transfer.cpp
index 68dab72d5..7f95ca9fe 100644
--- a/fem/transfer.cpp
+++ b/fem/transfer.cpp
@@ -92,9 +92,9 @@ const Operator &GridTransfer::MakeTrueOperator(
    else // Parallel() == true
    {
 #ifdef MFEM_USE_MPI
+      const SparseMatrix *out_R = fes_out.GetRestrictionMatrix();
       if (oper_type == Operator::Hypre_ParCSR)
       {
-         const SparseMatrix *out_R = fes_out.GetRestrictionMatrix();
          const ParFiniteElementSpace *pfes_in =
             dynamic_cast<const ParFiniteElementSpace *>(&fes_in);
          const ParFiniteElementSpace *pfes_out =
@@ -122,7 +122,6 @@ const Operator &GridTransfer::MakeTrueOperator(
       }
       else if (oper_type == Operator::ANY_TYPE)
       {
-         const Operator *out_R = fes_out.GetRestrictionOperator();
          t_oper.Reset(new TripleProductOperator(
                          out_R, &oper, fes_in.GetProlongationMatrix(),
                          false, false, false));
@@ -1159,12 +1158,12 @@ TensorProductPRefinementTransferOperator(
    localL.UseDevice(true);
    localH.UseDevice(true);
 
-   MFEM_VERIFY(dynamic_cast<const ElementRestriction*>(elem_restrict_lex_h),
+   const auto *elem_restrict =
+      dynamic_cast<const ConformingElementRestriction*>(elem_restrict_lex_h);
+   MFEM_VERIFY(elem_restrict,
                "High order element restriction is of unsupported type");
-
    mask.SetSize(localH.Size(), Device::GetMemoryType());
-   static_cast<const ElementRestriction*>(elem_restrict_lex_h)
-   ->BooleanMask(mask);
+   elem_restrict->BooleanMask(mask);
    mask.UseDevice(true);
 }
 
diff --git a/general/communication.hpp b/general/communication.hpp
index 474486f1b..c7d00f1e4 100644
--- a/general/communication.hpp
+++ b/general/communication.hpp
@@ -217,7 +217,6 @@ protected:
    int group_buf_size;
    mutable Array<char> group_buf;
    MPI_Request *requests;
-   // MPI_Status  *statuses;
    // comm_lock: 0 - no lock, 1 - locked for Bcast, 2 - locked for Reduce
    mutable int comm_lock;
    mutable int num_requests;
diff --git a/linalg/auxiliary.cpp b/linalg/auxiliary.cpp
index 003e52695..22c2aa8e0 100644
--- a/linalg/auxiliary.cpp
+++ b/linalg/auxiliary.cpp
@@ -460,14 +460,14 @@ MatrixFreeAMS::MatrixFreeAMS(
    pa_grad->SetAssemblyLevel(AssemblyLevel::PARTIAL);
    pa_grad->AddDomainInterpolator(new GradientInterpolator);
    pa_grad->Assemble();
-   pa_grad->FormRectangularSystemMatrix(Gradient);
+   pa_grad->FormDiscreteOperatorMatrix(Gradient);
 
    // build Pi operator
    pa_interp = new ParDiscreteLinearOperator(h1_fespace_d, &nd_fespace);
    pa_interp->SetAssemblyLevel(AssemblyLevel::PARTIAL);
    pa_interp->AddDomainInterpolator(new IdentityInterpolator);
    pa_interp->Assemble();
-   pa_interp->FormRectangularSystemMatrix(Pi);
+   pa_interp->FormDiscreteOperatorMatrix(Pi);
 
    // build LOR space
    ParMesh mesh_lor = ParMesh::MakeRefined(*mesh, order, BasisType::GaussLobatto);
diff --git a/linalg/handle.hpp b/linalg/handle.hpp
index 818294985..96f658d6a 100644
--- a/linalg/handle.hpp
+++ b/linalg/handle.hpp
@@ -207,7 +207,6 @@ public:
                     const Vector &X, Vector &B) const;
 };
 
-
 /// Add an alternative name for OperatorHandle -- OperatorPtr.
 typedef OperatorHandle OperatorPtr;
 
diff --git a/linalg/hypre.hpp b/linalg/hypre.hpp
index 913bdb2d0..3d5b4b2fe 100644
--- a/linalg/hypre.hpp
+++ b/linalg/hypre.hpp
@@ -720,7 +720,7 @@ public:
 
    /** @brief The "Boolean" analog of y = alpha * A * x + beta * y, where
        elements in the sparsity pattern of the matrix are treated as "true". */
-   void BooleanMult(int alpha, const int *x, int beta, int *y)
+   void BooleanMult(int alpha, const int *x, int beta, int *y) const
    {
       HostRead();
       internal::hypre_ParCSRMatrixBooleanMatvec(A, alpha, const_cast<int*>(x),
@@ -730,7 +730,7 @@ public:
 
    /** @brief The "Boolean" analog of y = alpha * A^T * x + beta * y, where
        elements in the sparsity pattern of the matrix are treated as "true". */
-   void BooleanMultTranspose(int alpha, const int *x, int beta, int *y)
+   void BooleanMultTranspose(int alpha, const int *x, int beta, int *y) const
    {
       HostRead();
       internal::hypre_ParCSRMatrixBooleanMatvecT(A, alpha, const_cast<int*>(x),
diff --git a/linalg/operator.cpp b/linalg/operator.cpp
index 1f214ece7..64f75c8a4 100644
--- a/linalg/operator.cpp
+++ b/linalg/operator.cpp
@@ -165,7 +165,7 @@ void Operator::RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x)
    }
 }
 
-Operator * Operator::SetupRAP(const Operator *Pi, const Operator *Po)
+Operator *Operator::SetupRAP(const Operator *Pi, const Operator *Po)
 {
    Operator *rap;
    if (!IsIdentityProlongation(Pi))
@@ -176,15 +176,15 @@ Operator * Operator::SetupRAP(const Operator *Pi, const Operator *Po)
       }
       else
       {
-         rap = new ProductOperator(this, Pi, false,false);
+         rap = new ProductOperator(this, Pi, false, false);
       }
    }
    else
    {
       if (!IsIdentityProlongation(Po))
       {
-         TransposeOperator * PoT = new TransposeOperator(Po);
-         rap = new ProductOperator(PoT, this, true,false);
+         TransposeOperator *PoT = new TransposeOperator(Po);
+         rap = new ProductOperator(PoT, this, true, false);
       }
       else
       {
@@ -245,10 +245,10 @@ void Operator::FormDiscreteOperator(Operator* &Aout)
 {
    const Operator *Pin  = this->GetProlongation();
    const Operator *Rout = this->GetOutputRestriction();
-   Aout = new TripleProductOperator(Rout, this, Pin,false, false, false);
+   Aout = new TripleProductOperator(Rout, this, Pin, false, false, false);
 }
 
-void Operator::PrintMatlab(std::ostream & os, int n, int m) const
+void Operator::PrintMatlab(std::ostream &os, int n, int m) const
 {
    using namespace std;
    if (n == 0) { n = width; }
diff --git a/linalg/operator.hpp b/linalg/operator.hpp
index baa9bf767..cdf700e17 100644
--- a/linalg/operator.hpp
+++ b/linalg/operator.hpp
@@ -29,8 +29,8 @@ protected:
 
    /// see FormSystemOperator()
    /** @note Uses DiagonalPolicy::DIAG_ONE. */
-   void FormConstrainedSystemOperator(
-      const Array<int> &ess_tdof_list, ConstrainedOperator* &Aout);
+   void FormConstrainedSystemOperator(const Array<int> &ess_tdof_list,
+                                      ConstrainedOperator* &Aout);
 
    /// see FormRectangularSystemOperator()
    void FormRectangularConstrainedSystemOperator(
@@ -38,10 +38,6 @@ protected:
       const Array<int> &test_tdof_list,
       RectangularConstrainedOperator* &Aout);
 
-   /** @brief Returns RAP Operator of this, using input/output Prolongation matrices
-       @a Pi corresponds to "P", @a Po corresponds to "Rt" */
-   Operator *SetupRAP(const Operator *Pi, const Operator *Po);
-
 public:
    /// Defines operator diagonal policy upon elimination of rows and/or columns.
    enum DiagonalPolicy
@@ -149,12 +145,6 @@ public:
       return GetProlongation(); // Assume square unless specialized
    }
 
-   /** @brief Transpose of GetOutputRestriction, directly available in this
-       form to facilitate matrix-free RAP-type operators.
-
-       `NULL` means identity. */
-   virtual const Operator *GetOutputRestrictionTranspose() const { return NULL; }
-
    /** @brief Restriction operator from output vectors for the operator to linear
        algebra (linear system) vectors. `NULL` means identity. */
    virtual const Operator *GetOutputRestriction() const
@@ -239,6 +229,10 @@ public:
        forms, though currently @a b is not used in the implementation. */
    virtual void RecoverFEMSolution(const Vector &X, const Vector &b, Vector &x);
 
+   /** @brief Returns RAP Operator of this, using input/output Prolongation matrices
+       @a Pi corresponds to "P", @a Po corresponds to "Rt" */
+   Operator *SetupRAP(const Operator *Pi, const Operator *Po);
+
    /** @brief Return in @a A a parallel (on truedofs) version of this square
        operator.
 
@@ -270,10 +264,10 @@ public:
    void FormDiscreteOperator(Operator* &A);
 
    /// Prints operator with input size n and output size m in Matlab format.
-   void PrintMatlab(std::ostream & out, int n, int m = 0) const;
+   void PrintMatlab(std::ostream &out, int n, int m = 0) const;
 
    /// Prints operator in Matlab format.
-   virtual void PrintMatlab(std::ostream & out) const;
+   virtual void PrintMatlab(std::ostream &out) const;
 
    /// Virtual destructor.
    virtual ~Operator() { }
@@ -722,6 +716,7 @@ inline bool IsIdentityProlongation(const Operator *P)
    return !P || dynamic_cast<const IdentityOperator*>(P);
 }
 
+
 /// Scaled Operator B: x -> a A(x).
 class ScaledOperator : public Operator
 {
@@ -928,6 +923,7 @@ public:
    virtual ~ConstrainedOperator() { if (own_A) { delete A; } }
 };
 
+
 /** @brief Rectangular Operator for imposing essential boundary conditions on
     the input space using only the action, Mult(), of a given unconstrained
     Operator.
@@ -981,6 +977,7 @@ public:
    virtual ~RectangularConstrainedOperator() { if (own_A) { delete A; } }
 };
 
+
 /** @brief PowerMethod helper class to estimate the largest eigenvalue of an
            operator using the iterative power method. */
 class PowerMethod
diff --git a/miniapps/hdiv-linear-solver/change_basis.cpp b/miniapps/hdiv-linear-solver/change_basis.cpp
index 702c57e4f..e0c34384d 100644
--- a/miniapps/hdiv-linear-solver/change_basis.cpp
+++ b/miniapps/hdiv-linear-solver/change_basis.cpp
@@ -336,7 +336,7 @@ void ChangeOfBasis_RT::Mult(const Vector &x, Vector &y, Mode mode) const
 
    elem_restr->MultLeftInverse(y_e, y_l);
 
-   const Operator *R = fes.GetRestrictionOperator();
+   const Operator *R = fes.GetRestrictionMatrix();
    if (R) { R->Mult(y_l, y); }
    else { MFEM_VERIFY(P == NULL, "Invalid state."); }
 }
diff --git a/miniapps/hdiv-linear-solver/discrete_divergence.cpp b/miniapps/hdiv-linear-solver/discrete_divergence.cpp
index 7ca7eca4c..2c522dad0 100644
--- a/miniapps/hdiv-linear-solver/discrete_divergence.cpp
+++ b/miniapps/hdiv-linear-solver/discrete_divergence.cpp
@@ -201,7 +201,7 @@ HypreParMatrix *FormDiscreteDivergenceMatrix(ParFiniteElementSpace &fes_rt,
    else { MFEM_ABORT("Unsupported dimension.") }
 
    const ElementDofOrdering ordering = ElementDofOrdering::LEXICOGRAPHIC;
-   const auto *R_rt = dynamic_cast<const ElementRestriction*>(
+   const auto *R_rt = dynamic_cast<const ConformingElementRestriction*>(
                          fes_rt.GetElementRestriction(ordering));
    const auto gather_rt = Reshape(R_rt->GatherMap().Read(), nface_per_el, nel_ho);
    const auto e2f = Reshape(element2face.Read(), 2*dim, nvol_per_el);
diff --git a/tests/unit/fem/test_pa_grad.cpp b/tests/unit/fem/test_pa_grad.cpp
index a42d7c83c..af0038cee 100644
--- a/tests/unit/fem/test_pa_grad.cpp
+++ b/tests/unit/fem/test_pa_grad.cpp
@@ -154,7 +154,7 @@ double par_compare_pa_assembly(int dim, int num_elements, int order,
    pa_grad.AddDomainInterpolator(new GradientInterpolator);
    pa_grad.Assemble();
    OperatorPtr pa_grad_oper;
-   pa_grad.FormRectangularSystemMatrix(pa_grad_oper);
+   pa_grad.FormDiscreteOperatorMatrix(pa_grad_oper);
 
    int insize, outsize;
    if (transpose)
