diff --git a/fem/pfespace.cpp b/fem/pfespace.cpp
index fa6a31a9e..4d64559c6 100644
--- a/fem/pfespace.cpp
+++ b/fem/pfespace.cpp
@@ -43,7 +43,7 @@ ParFiniteElementSpace::ParFiniteElementSpace(
 }
 
 ParFiniteElementSpace::ParFiniteElementSpace(
-   ParMesh *pm, const FiniteElementSpace *global_fes, const int *partitioning,
+   ParMesh *pm, const FiniteElementSpace *global_fes,
    const FiniteElementCollection *f)
    : FiniteElementSpace(pm, MakeLocalNURBSext(global_fes->GetNURBSext(),
                                               pm->NURBSext),
diff --git a/fem/pfespace.hpp b/fem/pfespace.hpp
index 1fbc7ccd1..ee82b0891 100644
--- a/fem/pfespace.hpp
+++ b/fem/pfespace.hpp
@@ -247,14 +247,11 @@ public:
    /** @brief Construct the *local* ParFiniteElementSpace corresponding to the
        global FE space, @a global_fes. */
    /** The parameter @a pm is the *local* ParMesh obtained by decomposing the
-       global Mesh used by @a global_fes. The array @a partitioning represents
-       the parallel decomposition - it maps global element ids to MPI ranks.
-       If the FiniteElementCollection, @a f, is NULL (default), the FE
-       collection used by @a global_fes will be reused. If @a f is not NULL, it
-       must be the same as, or a copy of, the FE collection used by
-       @a global_fes. */
+       global Mesh used by @a global_fes. If the FiniteElementCollection, @a f,
+       is NULL (default), the FE collection used by @a global_fes will be
+       reused. If @a f is not NULL, it must be the same as, or a copy of, the FE
+       collection used by @a global_fes. */
    ParFiniteElementSpace(ParMesh *pm, const FiniteElementSpace *global_fes,
-                         const int *partitioning,
                          const FiniteElementCollection *f = NULL);
 
    ParFiniteElementSpace(ParMesh *pm, const FiniteElementCollection *f,
diff --git a/fem/pgridfunc.cpp b/fem/pgridfunc.cpp
index d49187457..0a58530c1 100644
--- a/fem/pgridfunc.cpp
+++ b/fem/pgridfunc.cpp
@@ -41,7 +41,7 @@ ParGridFunction::ParGridFunction(ParMesh *pmesh, const GridFunction *gf,
    // duplicate the FiniteElementCollection from 'gf'
    fec = FiniteElementCollection::New(glob_fes->FEColl()->Name());
    // create a local ParFiniteElementSpace from the global one:
-   fes = pfes = new ParFiniteElementSpace(pmesh, glob_fes, partitioning, fec);
+   fes = pfes = new ParFiniteElementSpace(pmesh, glob_fes, fec);
    SetSize(pfes->GetVSize());
 
    if (partitioning)
diff --git a/mesh/mesh.cpp b/mesh/mesh.cpp
index 45871a66e..18e6bf1a7 100644
--- a/mesh/mesh.cpp
+++ b/mesh/mesh.cpp
@@ -2451,12 +2451,38 @@ void Mesh::MarkTriMeshForRefinement()
    }
 }
 
-void Mesh::GetEdgeOrdering(DSTable &v_to_v, Array<int> &order)
+void Mesh::GetEdgeOrdering(const DSTable &v_to_v, Array<int> &order)
 {
    NumOfEdges = v_to_v.NumberOfEntries();
    order.SetSize(NumOfEdges);
    Array<Pair<double, int> > length_idx(NumOfEdges);
 
+   auto GetLength = [this](int i, int j)
+   {
+      double length = 0.;
+      if (Nodes == NULL)
+      {
+         const double *vi = vertices[i]();
+         const double *vj = vertices[j]();
+         for (int k = 0; k < spaceDim; k++)
+         {
+            length += (vi[k]-vj[k])*(vi[k]-vj[k]);
+         }
+      }
+      else
+      {
+         Array<int> ivdofs, jvdofs;
+         Nodes->FESpace()->GetVertexVDofs(i, ivdofs);
+         Nodes->FESpace()->GetVertexVDofs(j, jvdofs);
+         for (int k = 0; k < ivdofs.Size(); k++)
+         {
+            length += ((*Nodes)(ivdofs[k])-(*Nodes)(jvdofs[k]))*
+                      ((*Nodes)(ivdofs[k])-(*Nodes)(jvdofs[k]));
+         }
+      }
+      return length;
+   };
+
    for (int i = 0; i < NumOfVertices; i++)
    {
       for (DSTable::RowIterator it(v_to_v, i); !it; ++it)
@@ -2472,11 +2498,13 @@ void Mesh::GetEdgeOrdering(DSTable &v_to_v, Array<int> &order)
 
    for (int i = 0; i < NumOfEdges; i++)
    {
-      order[length_idx[i].two] = i;
+      int j = i;
+      while (j > 0 && length_idx[j-1].one == length_idx[i].one) { j--; }
+      order[length_idx[i].two] = j;
    }
 }
 
-void Mesh::MarkTetMeshForRefinement(DSTable &v_to_v)
+void Mesh::MarkTetMeshForRefinement(const DSTable &v_to_v)
 {
    // Mark the longest tetrahedral edge by rotating the indices so that
    // vertex 0 - vertex 1 is the longest edge in the element.
@@ -5718,37 +5746,21 @@ static const char *fixed_or_not[] = { "fixed", "NOT FIXED" };
 
 int Mesh::CheckElementOrientation(bool fix_it)
 {
-   int i, j, k, wo = 0, fo = 0;
-   double *v[4];
+   int wo = 0, fo = 0;
 
    if (Dim == 2 && spaceDim == 2)
    {
       DenseMatrix J(2, 2);
 
-      for (i = 0; i < NumOfElements; i++)
+      for (int i = 0; i < NumOfElements; i++)
       {
-         int *vi = elements[i]->GetVertices();
-         if (Nodes == NULL)
-         {
-            for (j = 0; j < 3; j++)
-            {
-               v[j] = vertices[vi[j]]();
-            }
-            for (j = 0; j < 2; j++)
-               for (k = 0; k < 2; k++)
-               {
-                  J(j, k) = v[j+1][k] - v[0][k];
-               }
-         }
-         else
-         {
-            // only check the Jacobian at the center of the element
-            GetElementJacobian(i, J);
-         }
+         // only check the Jacobian at the center of the element
+         GetElementJacobian(i, J);
          if (J.Det() < 0.0)
          {
             if (fix_it)
             {
+               int *vi = elements[i]->GetVertices();
                switch (GetElementType(i))
                {
                   case Element::TRIANGLE:
@@ -5773,29 +5785,14 @@ int Mesh::CheckElementOrientation(bool fix_it)
    {
       DenseMatrix J(3, 3);
 
-      for (i = 0; i < NumOfElements; i++)
+      for (int i = 0; i < NumOfElements; i++)
       {
          int *vi = elements[i]->GetVertices();
          switch (GetElementType(i))
          {
             case Element::TETRAHEDRON:
-               if (Nodes == NULL)
-               {
-                  for (j = 0; j < 4; j++)
-                  {
-                     v[j] = vertices[vi[j]]();
-                  }
-                  for (j = 0; j < 3; j++)
-                     for (k = 0; k < 3; k++)
-                     {
-                        J(j, k) = v[j+1][k] - v[0][k];
-                     }
-               }
-               else
-               {
-                  // only check the Jacobian at the center of the element
-                  GetElementJacobian(i, J);
-               }
+               // only check the Jacobian at the center of the element
+               GetElementJacobian(i, J);
                if (J.Det() < 0.0)
                {
                   wo++;
@@ -6686,24 +6683,12 @@ void Mesh::GetBdrPointMatrix(int i,DenseMatrix &pointmat) const
 
    pointmat.SetSize(spaceDim, nv);
    for (k = 0; k < spaceDim; k++)
+   {
       for (j = 0; j < nv; j++)
       {
          pointmat(k, j) = vertices[v[j]](k);
       }
-}
-
-double Mesh::GetLength(int i, int j) const
-{
-   const double *vi = vertices[i]();
-   const double *vj = vertices[j]();
-   double length = 0.;
-
-   for (int k = 0; k < spaceDim; k++)
-   {
-      length += (vi[k]-vj[k])*(vi[k]-vj[k]);
    }
-
-   return sqrt(length);
 }
 
 // static method
diff --git a/mesh/mesh.hpp b/mesh/mesh.hpp
index 419745f1b..d148358c2 100644
--- a/mesh/mesh.hpp
+++ b/mesh/mesh.hpp
@@ -32,8 +32,6 @@
 namespace mfem
 {
 
-// Data type mesh
-
 class GeometricFactors;
 class FaceGeometricFactors;
 class KnotVector;
@@ -50,15 +48,15 @@ class ParMesh;
 class ParNCMesh;
 #endif
 
+/// Mesh data type
 class Mesh
 {
+   friend class NCMesh;
+   friend class NURBSExtension;
 #ifdef MFEM_USE_MPI
    friend class ParMesh;
    friend class ParNCMesh;
 #endif
-   friend class NCMesh;
-   friend class NURBSExtension;
-
 #ifdef MFEM_USE_ADIOS2
    friend class adios2stream;
 #endif
@@ -334,13 +332,10 @@ protected:
    /** Also, initializes #mesh_geoms. */
    void SetMeshGen();
 
-   /// Return the length of the segment from node i to node j.
-   double GetLength(int i, int j) const;
-
    void MarkForRefinement();
    void MarkTriMeshForRefinement();
-   void GetEdgeOrdering(DSTable &v_to_v, Array<int> &order);
-   virtual void MarkTetMeshForRefinement(DSTable &v_to_v);
+   void GetEdgeOrdering(const DSTable &v_to_v, Array<int> &order);
+   virtual void MarkTetMeshForRefinement(const DSTable &v_to_v);
 
    // Methods used to prepare and apply permutation of the mesh nodes assuming
    // that the mesh elements may be rotated (e.g. to mark triangle or tet edges
diff --git a/mesh/pmesh.cpp b/mesh/pmesh.cpp
index 4d08285e9..356a13666 100644
--- a/mesh/pmesh.cpp
+++ b/mesh/pmesh.cpp
@@ -923,22 +923,21 @@ void ParMesh::FinalizeParTopo()
    }
 }
 
-ParMesh::ParMesh(MPI_Comm comm, istream &input, bool refine)
+ParMesh::ParMesh(MPI_Comm comm, istream &input, int generate_edges,
+                 int refine, bool fix_orientation)
    : face_nbr_el_to_face(NULL)
    , glob_elem_offset(-1)
    , glob_offset_sequence(-1)
    , gtopo(comm)
+   , pncmesh(NULL)
 {
    MyComm = comm;
    MPI_Comm_size(MyComm, &NRanks);
    MPI_Comm_rank(MyComm, &MyRank);
 
-   have_face_nbr_data = false;
-   pncmesh = NULL;
-
-   const int gen_edges = 1;
+   Load(input, generate_edges, refine, fix_orientation);
 
-   Load(input, gen_edges, refine, true);
+   have_face_nbr_data = false;
 }
 
 void ParMesh::Load(istream &input, int generate_edges, int refine,
@@ -1733,14 +1732,14 @@ void ParMesh::GetSharedTriCommunicator(int ordering,
    stria_comm.Finalize();
 }
 
-void ParMesh::MarkTetMeshForRefinement(DSTable &v_to_v)
+void ParMesh::MarkTetMeshForRefinement(const DSTable &v_to_v)
 {
    Array<int> order;
    GetEdgeOrdering(v_to_v, order); // local edge ordering
 
    // create a GroupCommunicator on the shared edges
    GroupCommunicator sedge_comm(gtopo);
-   GetSharedEdgeCommunicator(sedge_comm);
+   GetSharedEdgeCommunicator(0, sedge_comm);
 
    Array<int> sedge_ord(shared_edges.Size());
    Array<Pair<int,int> > sedge_ord_map(shared_edges.Size());
@@ -1785,6 +1784,32 @@ void ParMesh::MarkTetMeshForRefinement(DSTable &v_to_v)
    {
       Array<Pair<int, double> > ilen_len(order.Size());
 
+      auto GetLength = [this](int i, int j)
+      {
+         double length = 0.;
+         if (Nodes == NULL)
+         {
+            const double *vi = vertices[i]();
+            const double *vj = vertices[j]();
+            for (int k = 0; k < spaceDim; k++)
+            {
+               length += (vi[k]-vj[k])*(vi[k]-vj[k]);
+            }
+         }
+         else
+         {
+            Array<int> ivdofs, jvdofs;
+            Nodes->FESpace()->GetVertexVDofs(i, ivdofs);
+            Nodes->FESpace()->GetVertexVDofs(j, jvdofs);
+            for (int k = 0; k < ivdofs.Size(); k++)
+            {
+               length += ((*Nodes)(ivdofs[k])-(*Nodes)(jvdofs[k]))*
+                         ((*Nodes)(ivdofs[k])-(*Nodes)(jvdofs[k]));
+            }
+         }
+         return length;
+      };
+
       for (int i = 0; i < NumOfVertices; i++)
       {
          for (DSTable::RowIterator it(v_to_v, i); !it; ++it)
@@ -1797,23 +1822,26 @@ void ParMesh::MarkTetMeshForRefinement(DSTable &v_to_v)
 
       SortPairs<int, double>(ilen_len, order.Size());
 
-      double d_max = 0.;
+      double d_max = 0., d_min = infinity();
       for (int i = 1; i < order.Size(); i++)
       {
-         d_max = std::max(d_max, ilen_len[i-1].two-ilen_len[i].two);
+         d_max = std::max(d_max, ilen_len[i].two-ilen_len[i-1].two);
+         d_min = std::min(d_min, ilen_len[i].two-ilen_len[i-1].two);
       }
 
 #if 0
       // Debug message from every MPI rank.
       mfem::out << "proc. " << MyRank << '/' << NRanks << ": d_max = " << d_max
-                << endl;
+                << ", d_min = " << d_min << endl;
 #else
       // Debug message just from rank 0.
-      double glob_d_max;
+      double glob_d_max, glob_d_min;
       MPI_Reduce(&d_max, &glob_d_max, 1, MPI_DOUBLE, MPI_MAX, 0, MyComm);
+      MPI_Reduce(&d_min, &glob_d_min, 1, MPI_DOUBLE, MPI_MIN, 0, MyComm);
       if (MyRank == 0)
       {
-         mfem::out << "glob_d_max = " << glob_d_max << endl;
+         mfem::out << "glob_d_max = " << glob_d_max
+                   << ", glob_d_min = " << glob_d_min << endl;
       }
 #endif
    }
@@ -2102,16 +2130,13 @@ void ParMesh::EnsureParNodes()
       ParFiniteElementSpace *pfes =
          new ParFiniteElementSpace(*Nodes->FESpace(), *this);
       ParGridFunction *new_nodes = new ParGridFunction(pfes);
-
       *new_nodes = *Nodes;
-
       if (Nodes->OwnFEC())
       {
          new_nodes->MakeOwner(Nodes->OwnFEC());
          Nodes->MakeOwner(NULL); // takes away ownership of 'fec' and 'fes'
          delete Nodes->FESpace();
       }
-
       delete Nodes;
       Nodes = new_nodes;
    }
@@ -3288,23 +3313,21 @@ void ParMesh::ReorientTetMesh()
 
    // create a GroupCommunicator over shared vertices
    GroupCommunicator svert_comm(gtopo);
-   GetSharedVertexCommunicator(svert_comm);
+   GetSharedVertexCommunicator(0, svert_comm);
 
    // communicate the local index of each shared vertex from the group master to
    // other ranks in the group
    Array<int> svert_master_rank(svert_lvert.Size());
    Array<int> svert_master_index(svert_lvert);
+   for (int i = 0; i < group_svert.Size(); i++)
    {
-      for (int i = 0; i < group_svert.Size(); i++)
+      int rank = gtopo.GetGroupMasterRank(i+1);
+      for (int j = 0; j < group_svert.RowSize(i); j++)
       {
-         int rank = gtopo.GetGroupMasterRank(i+1);
-         for (int j = 0; j < group_svert.RowSize(i); j++)
-         {
-            svert_master_rank[group_svert.GetRow(i)[j]] = rank;
-         }
+         svert_master_rank[group_svert.GetRow(i)[j]] = rank;
       }
-      svert_comm.Bcast(svert_master_index);
    }
+   svert_comm.Bcast(svert_master_index);
 
    // the pairs (master rank, master local index) define a globally consistent
    // vertex ordering
@@ -3370,22 +3393,8 @@ void ParMesh::ReorientTetMesh()
    {
       // create a GroupCommunicator on the shared triangles
       GroupCommunicator stria_comm(gtopo);
-      {
-         // initialize stria_comm
-         Table &gr_stria = stria_comm.GroupLDofTable();
-         // gr_stria differs from group_stria - the latter does not store gr. 0
-         gr_stria.SetDims(GetNGroups(), shared_trias.Size());
-         gr_stria.GetI()[0] = 0;
-         for (int gr = 1; gr <= GetNGroups(); gr++)
-         {
-            gr_stria.GetI()[gr] = group_stria.GetI()[gr-1];
-         }
-         for (int k = 0; k < shared_trias.Size(); k++)
-         {
-            gr_stria.GetJ()[k] = group_stria.GetJ()[k];
-         }
-         stria_comm.Finalize();
-      }
+      GetSharedTriCommunicator(0, stria_comm);
+
       Array<int> stria_flag(shared_trias.Size());
       for (int i = 0; i < stria_flag.Size(); i++)
       {
diff --git a/mesh/pmesh.hpp b/mesh/pmesh.hpp
index 0aab7982e..2ed8b00ec 100644
--- a/mesh/pmesh.hpp
+++ b/mesh/pmesh.hpp
@@ -24,6 +24,7 @@
 
 namespace mfem
 {
+
 #ifdef MFEM_USE_PUMI
 class ParPumiMesh;
 #endif
@@ -31,9 +32,16 @@ class ParPumiMesh;
 /// Class for parallel meshes
 class ParMesh : public Mesh
 {
-protected:
+   friend class ParNCMesh;
    friend class ParSubMesh;
+#ifdef MFEM_USE_PUMI
+   friend class ParPumiMesh;
+#endif
+#ifdef MFEM_USE_ADIOS2
+   friend class adios2stream;
+#endif
 
+protected:
    MPI_Comm MyComm;
    int NRanks, MyRank;
 
@@ -104,7 +112,7 @@ protected:
 
    // Mark all tets to ensure consistency across MPI tasks; also mark the
    // shared and boundary triangle faces using the consistently marked tets.
-   void MarkTetMeshForRefinement(DSTable &v_to_v) override;
+   void MarkTetMeshForRefinement(const DSTable &v_to_v) override;
 
    /// Return a number(0-1) identifying how the given edge has been split
    int GetEdgeSplittings(Element *edge, const DSTable &v_to_v, int *middle);
@@ -311,7 +319,8 @@ public:
 
    /// Read a parallel mesh, each MPI rank from its own file/stream.
    /** The @a refine parameter is passed to the method Mesh::Finalize(). */
-   ParMesh(MPI_Comm comm, std::istream &input, bool refine = true);
+   ParMesh(MPI_Comm comm, std::istream &input, int generate_edges = 0,
+           int refine = 1, bool fix_orientation = true);
 
    /// Deprecated: see @a ParMesh::MakeRefined
    MFEM_DEPRECATED
@@ -668,14 +677,6 @@ public:
    void PrintSharedEntities(const std::string &fname_prefix) const;
 
    virtual ~ParMesh();
-
-   friend class ParNCMesh;
-#ifdef MFEM_USE_PUMI
-   friend class ParPumiMesh;
-#endif
-#ifdef MFEM_USE_ADIOS2
-   friend class adios2stream;
-#endif
 };
 
 }
