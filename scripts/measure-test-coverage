#!/bin/bash
set -eu

# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

help()
{
    echo "Usage: measure-test-coverage COMMAND [OPTIONS]

Measure test coverage for Palace and generate HTML report, optionally supporting
multiple builds.

Commands:
  generate [UNIT_TEST_EXEC]        Run tests and generate coverage_filtered.info
                                   (default: ../build/palace-build/test/unit/unit-tests)
  merge COVERAGE_FILE ...          Merge multiple coverage files into coverage_filtered.info
  report [COVERAGE_FILE|UNIT_TEST_EXEC]
                                   Generate HTML report from coverage file or by running tests
                                   (default: ../build/palace-build/test/unit/unit-tests)

Options:
  -j NUM_PROC                      Maximum number of processes for running tests (default: $(nproc))
                                   Note: MPI tests run with 2 processes each, so -j8 allows
                                   up to 4 MPI tests to run simultaneously
  -h, --help                       Show this help message and exit

Examples:
  # Generate coverage and HTML report in one step
  measure-test-coverage report

  # Generate coverage with 8 processes (allowing 4 MPI tests simultaneously)
  measure-test-coverage report -j8

  # Generate coverage from multiple builds, merge, and create report
  measure-test-coverage generate /path/to/build1/unit-tests
  measure-test-coverage generate /path/to/build2/unit-tests
  measure-test-coverage merge build1/coverage_filtered.info build2/coverage_filtered.info
  measure-test-coverage report coverage_filtered.info
"
}

# Parse arguments.
NUM_PROC_TEST="$(nproc)"

if [[ $# -eq 0 ]] || [[ "$1" == "-h" || "$1" == "--help" ]]; then
    help
    exit 0
fi

COMMAND="$1"
shift

# Parse options
while [[ $# -gt 0 ]]; do
    case "$1" in
        -j)
            if [[ -n "${2:-}" ]] && [[ "$2" =~ ^[0-9]+$ ]]; then
                NUM_PROC_TEST="$2"
                shift 2
            else
                error "Option -j requires a numeric argument"
            fi
            ;;
        -h|--help)
            help
            exit 0
            ;;
        -*)
            error "Unknown option: $1. Use -h for help."
            ;;
        *)
            # This is a positional argument, break to handle it
            break
            ;;
    esac
done

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PALACE_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

case "$COMMAND" in
    generate)
        UNIT_TEST_EXEC="${1:-$PALACE_ROOT/build/palace-build/test/unit/unit-tests}"
        BUILD_DIR="$(dirname "$(dirname "$(dirname "$UNIT_TEST_EXEC")")")"
        ;;
    merge)
        if [[ $# -eq 0 ]]; then
            error "No coverage files specified for merge"
        fi
        COVERAGE_FILES=("$@")
        BUILD_DIR="$(pwd)"
        ;;
    report)
        # Will be determined in main based on whether arg is executable or file.
        BUILD_DIR="$(pwd)"
        ;;
    *)
        error "Unknown command: $COMMAND. Use -h for help."
        ;;
esac

# Colors for output.
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

log() { echo -e "${GREEN}[INFO]${NC} $*"; }
warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
error() { echo -e "${RED}[ERROR]${NC} $*"; exit 1; }

# Check prerequisites.
check_prerequisites() {
    log "Checking prerequisites..."
    
    [[ -f "$UNIT_TEST_EXEC" ]] || error "Unit tests not found at $UNIT_TEST_EXEC. Build Palace first."
    command -v lcov >/dev/null || error "lcov not found."
    command -v mpirun >/dev/null || error "mpirun not found."
    
    # Check if Palace was built with coverage.
    if ! strings "$UNIT_TEST_EXEC" 2>/dev/null | grep -q "__llvm_profile\|__gcov"; then
        error "Palace not built with coverage. Rebuild with -DPALACE_BUILD_WITH_COVERAGE=YES"
    fi
    
    log "Prerequisites OK"
}

# Detect compiler type from build artifacts.
detect_compiler() {
    if strings "$UNIT_TEST_EXEC" 2>/dev/null | grep -q "clang version\|LLVM"; then
        echo "llvm"
    elif strings "$UNIT_TEST_EXEC" 2>/dev/null | grep -q "GCC:"; then
        echo "gcc"
    else
        error "Cannot detect compiler type from unit test executable"
    fi
}

# Clean previous coverage data.
clean_coverage() {
    log "Cleaning previous coverage data..."
    cd "$BUILD_DIR"
    rm -f coverage*.info coverage*.profraw coverage*.profdata coverage_llvm.json
    find . -name "*.gcda" -delete 2>/dev/null || true
}

# Run tests and collect coverage.
run_tests() {
    log "Running tests via ctest with max $NUM_PROC_TEST processes..."
    cd "$BUILD_DIR/test/unit"
    ctest -j "$NUM_PROC_TEST" --output-on-failure
    cd "$BUILD_DIR"
}

# Generate coverage for GCC.
generate_gcc_coverage() {
    # GCC embeds coverage information in two groups of files:
    # - *.gcda: run-time coverage information
    # - *.gcno: compile-time annotations
    # Then, gcov requires each gcda to have a corresponding gcno.

    # This introduces problems in running tests in parallel, because we save
    # each gcda in a different file (to avoid race conditions). For this reason,
    # we need to merge all the gcdas and do some name de-mangling to put them
    # next to the corresponding gcno. To accomplish this, we use gcov-tool,
    # which comes with gcc. Unfortunately, gcov-tool can only process two files
    # at the time, so we have to iterate over all the generated reports.

    # This solution is inspired by https://stackoverflow.com/a/70566435

    log "Merging GCC coverage from coverage.* directories..."
    cd "$BUILD_DIR"
    
    # Iteratively merge coverage.* profiles (gcov-tool only merges two at a time).
    local dirs=(coverage.*)
    if [[ ${#dirs[@]} -eq 0 ]]; then
        error "No coverage.* directories found"
    fi
    
    local merged="${dirs[0]}"
    for ((i=1; i<${#dirs[@]}; i++)); do
        local tmp="coverage_tmp_$i"
        local prev="$merged"
        gcov-tool merge -o "$tmp" "$merged" "${dirs[$i]}"
        merged="$tmp"
        [[ "$prev" != "${dirs[0]}" && -d "$prev" ]] && rm -rf "$prev"
    done
    
    mv "$merged" coverage_merged
    rm -rf coverage.*
    
    # Unmangle filenames (convert #home#user#file.gcda to /home/user/file.gcda).
    log "Unmangling coverage filenames..."
    cd coverage_merged
    find . -name '#*.gc[dn][ao]' | while read f; do
        local target="/$(basename "$f" | tr '#' '/' | sed 's|^/||')"
        mkdir -p "$(dirname "$target")"
        mv "$f" "$target"
    done
    cd "$BUILD_DIR"
    
    # Palace is a complex codebase that involves inlined and just-in-time
    # compiled functions. This can lead to minor inconsistencies in the coverage
    # files. These are not fatal, and ignoring them still produces good reports.
    # For this reason, most `lcov` commands have the `--ignore-errors
    # inconsistent` flag.

    lcov --capture --directory . --ignore-errors inconsistent --output-file coverage.info
}

# Generate coverage for LLVM.
generate_llvm_coverage() {
    log "Generating LLVM coverage..."
    cd "$BUILD_DIR"
    
    if ! ls coverage/*/*.profraw >/dev/null 2>&1; then
        error "No LLVM coverage files found"
    fi
    
    # Merge raw coverage files.
    llvm-profdata merge -output=coverage.profdata coverage/*/*.profraw
    
    # Export to JSON. We go through JSON because it is more robust than
    # converting to lcov directly from llvm.
    llvm-cov export -format text -instr-profile coverage.profdata "$UNIT_TEST_EXEC" > coverage_llvm.json
    
    # Convert to LCOV format.
    llvm2lcov --ignore-errors inconsistent --output coverage.info coverage_llvm.json
}

# Filter coverage to Palace source only.
filter_coverage() {
    log "Filtering coverage to Palace source code..."
    cd "$BUILD_DIR"
    
    local input_file="${1:-coverage.info}"
    
    if [[ ! -s "$input_file" ]]; then
        warn "No coverage data found in $input_file"
        return
    fi
    
    lcov --extract "$input_file" \
        '*/palace/drivers/*' \
        '*/palace/fem/*' \
        '*/palace/linalg/*' \
        '*/palace/models/*' \
        '*/palace/utils/*' \
        '*/test/unit/*' \
        --ignore-errors inconsistent \
        --output-file coverage_filtered.info
}

# Generate HTML report.
generate_html_report() {
    log "Generating HTML coverage report..."
    cd "$BUILD_DIR"
    
    if [[ ! -s coverage_filtered.info ]]; then
        warn "No filtered coverage data available"
        mkdir -p coverage_html
        cat > coverage_html/index.html << 'EOF'
<!DOCTYPE html>
<html><head><title>Palace Coverage Report</title></head>
<body><h1>No coverage data available</h1>
<p>Make sure Palace was built with -DPALACE_BUILD_WITH_COVERAGE=YES</p>
</body></html>
EOF
        return
    fi
    
    genhtml coverage_filtered.info \
        --output-directory coverage_html \
        --title "Palace Coverage Report" \
        --show-details \
        --legend \
        --ignore-errors inconsistent
    
    # Print summary.
    log "Coverage Summary:"
    lcov --summary coverage_filtered.info
    
    log "HTML report generated at: $BUILD_DIR/coverage_html/index.html"
}

# Main execution.
main() {
    case "$COMMAND" in
        generate)
            log "Starting Palace coverage measurement..."
            log "Unit test executable: $UNIT_TEST_EXEC"
            log "Build directory: $BUILD_DIR"
            
            check_prerequisites
            
            local compiler_type
            compiler_type=$(detect_compiler)
            log "Detected compiler type: $compiler_type"
            
            clean_coverage
            run_tests
            
            case "$compiler_type" in
                gcc)
                    generate_gcc_coverage
                    ;;
                llvm)
                    generate_llvm_coverage
                    ;;
                *)
                    error "Unsupported compiler type: $compiler_type"
                    ;;
            esac
            
            filter_coverage
            log "Coverage data generated: $BUILD_DIR/coverage_filtered.info"
            ;;
        
        merge)
            log "Merging coverage files..."
            cd "$BUILD_DIR"
            
            local add_args=""
            for f in "${COVERAGE_FILES[@]}"; do
                [[ -f "$f" ]] || error "Coverage file not found: $f"
                add_args="$add_args --add-tracefile $f"
            done
            
            lcov $add_args --ignore-errors inconsistent --output-file coverage_filtered.info
            log "Merged coverage data: $BUILD_DIR/coverage_filtered.info"
            ;;
        
        report)
            ARG="${1:-$PALACE_ROOT/build/palace-build/test/unit/unit-tests}"
            
            # Check if argument is an executable
            if [[ -x "$ARG" ]]; then
                log "Detected executable, running generate first..."
                UNIT_TEST_EXEC="$ARG"
                BUILD_DIR="$(dirname "$(dirname "$(dirname "$UNIT_TEST_EXEC")")")"
                
                check_prerequisites
                
                local compiler_type
                compiler_type=$(detect_compiler)
                log "Detected compiler type: $compiler_type"
                
                clean_coverage
                run_tests
                
                case "$compiler_type" in
                    gcc)
                        generate_gcc_coverage
                        ;;
                    llvm)
                        generate_llvm_coverage
                        ;;
                    *)
                        error "Unsupported compiler type: $compiler_type"
                        ;;
                esac
                
                filter_coverage
            else
                COVERAGE_FILE="$ARG"
                BUILD_DIR="$(pwd)"
                
                [[ -f "$COVERAGE_FILE" ]] || error "Coverage file not found: $COVERAGE_FILE"
                
                # Copy to coverage_filtered.info if different file
                if [[ "$COVERAGE_FILE" != "coverage_filtered.info" ]]; then
                    cp "$COVERAGE_FILE" coverage_filtered.info
                fi
            fi
            
            log "Generating HTML report..."
            cd "$BUILD_DIR"
            generate_html_report
            ;;
    esac
    
    log "Complete!"
}

main "$@"
