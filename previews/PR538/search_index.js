var documenterSearchIndex = {"docs":
[{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"features/farfield/#Extracting-Fields-in-the-Radiation-Zone","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"","category":"section"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"When run in the Driven or Eigenmode modes, Palace can extrapolate fields from the near-field region (being simulated) to the far-field zone. This capability can be used to study the radiative properties of a system.","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"The mathematical details on how this is accomplished are available in the reference. The key points are as follows:","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"Computing fields requires evaluation of surface integrals, so users must specify a surface of integration (more on this later).\nFor the result to be physically accurate, it is important to properly model the propagation of waves to infinity. This can be accomplished by enclosing the system inside a sphere or box and applying config[\"Boundaries\"][\"Absorbing\"] boundary conditions.\nThe result is provided as complex vectors r mathbfE(theta phi), where (theta phi) identify a point on sphere at infinite distance and the result is defined up to a global phase.","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"Palace outputs rmathbfE because this is a well-defined, finite quantity (mathbfE itself goes to zero at infinity as 1/r). You can also think of this as the electric field measured at a distance of one unit of length. With this output, you can immediately compute various quantities of interest. For instance, rmathbfE^2 gives the relative radiative power.","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"warning: Limitations\nPalace only supports propagation of fields to infinity when the integration surfaceis an external boundary\ndoes not cross anisotropic materials","category":"page"},{"location":"features/farfield/#Setup","page":"Extracting Fields in the Radiation Zone","title":"Setup","text":"","category":"section"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"A typical setup consists of starting from the system under consideration and enclosing the system inside an outer boundary (typically a sphere or a box), if it is not already. Then, we set \"Absorbing\" boundary conditions on this surface and choose it as the surface for the integration. For best accuracy, it is a good idea to make sure that this outer boundary is meshed finely enough to resolve the expected wavelength.","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"Turning on far-field extraction requires activating the feature in the configuration JSON file. To do so, we look at the \"FarField\" section under \"Postprocessing\" in \"Boundaries\". Here, we need to specify the identifier of the integration surface in \"Attributes\" and specify how we want to sample the sphere at infinity. As in many other parts of Palace, \"Attributes\" expects a vector, as it can happen the boundary is split in multiple pieces.","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"Once we define the surface of integration, we need to specify where we want to evaluate target far-field points. The simplest way to do this is by setting \"NSample\", so that the far-field sphere is uniformly sampled with NSample points. (Note that uniform on a sphere means that the polar angle theta of the sampled points is not uniformly distributed, to avoid bunching of points on the poles.)","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"Often, uniform sampling on the far-field sphere might be a good first step, but not the best way to accurately capture the radiative properties (e.g., when the radiation is highly directional). In this case, you can specify at what angles theta phi you want to evaluate the fields. This is done by passing 2-vectors to the \"ThetaPhis\" array with the angular coordinates of your choosing (in degrees).","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"This can be combined with scripts to target specific regions. For instance, the following Python code produces the required \"ThetaPhis\" section to sample over the xy plane:","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"import json\ndphi = 1  # degree\nprint(json.dumps({\"ThetaPhis\": [[90.0, p] for p in range(0, 361, dphi)]}))","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"Both \"NSample\" and \"ThetaPhis\" can be specified simultaneously and the results will be combined and duplicates removed.","category":"page"},{"location":"features/farfield/#Output","page":"Extracting Fields in the Radiation Zone","title":"Output","text":"","category":"section"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"Once a simulation is run, Palace generates a CSV file named farfield-rE.csv in the folder specified by the config[\"Problem\"][\"Output\"] configuration.","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"The CSV contains a header line that describes the columns, and one row for each (theta phi) pair. The columns are:","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"f (GHz) : Frequency\ntheta (deg.) : Polar angle in degrees\nphi (deg.) : Azimuthal angle in degrees\nr*Re{E_x} (V), r*Im{E_x} (V) : Real and imaginary parts of r E_x component\nr*Re{E_y} (V), r*Im{E_y} (V) : Real and imaginary parts of r E_y component\nr*Re{E_z} (V), r*Im{E_z} (V) : Real and imaginary parts of r E_z component","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"All field values are in SI units.","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"To obtain the magnetic fields, you can assume that propagation occurs in free space, so that","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"r mathbfH_p(mathbfr_0) = fracmathbfr_0 times r mathbfE_p(mathbfr_0)Z_0","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"with Z_0 impedance of free space.","category":"page"},{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"This type of output can be processed by several different packages and languages. For instance, see the antenna example for an example of a Julia script that plots antenna patterns.","category":"page"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"examples/coaxial/#Signal-Propagation-in-a-Coaxial-Cable","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"","category":"section"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"note: Note\nThe files for this example can be found in the examples/coaxial/ directory of the Palace source code.","category":"page"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"Palace can perform transient electromagnetic modeling, acting as a so-called finite element time domain (FETD) solver. To demonstrate this feature, we consider here the propagation of an electromagnetic pulse through a section of coaxial cable. The model is constructed based on a 50text Omega RG-401/U coaxial cable [1], with outer and inner conductor diameters of 0215text in and 00645text in, respectively. The section length is roughly 15text in. The Teflon dielectric material has varepsilon_r = 208, and we consider tandelta = 4times 10^-2, a factor of 100 above the actual value in order to exaggerate losses in the transmission line.","category":"page"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"In this example we consider three different configurations of the model, all with a coaxial lumped port excitation at one end of the line: an open termination at the opposite end (coaxial_open.json), a shorted termination (coaxial_short.json), and a matched 50text Omega lumped port termination (coaxial_matched.json).","category":"page"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"The mesh is generated using the Julia code in mesh/mesh.jl and consists of quadratically-curved hexahedral elements, as depicted below. Third-order shape functions are used to approximate the solution.","category":"page"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/coaxial-1.png\" width=\"60%\" />\n</p><br/>","category":"page"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"Each configuration file sets the simulation \"Type\" to \"Transient\". The different termination configurations are specified by using a \"LumpedPort\" with matched impedance for the matched termination, a \"PEC\" boundary for the shorted termination, leaving no boundary condition specified for the open termination. This last case applies the natural boundary condition for the finite element formulation which is a perfect magnetic conductor boundary condition, enforcing zero tangential magnetic field and thus zero surface current density.","category":"page"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"The excitation pulse is configured under config[\"Solver\"][\"Transient\"]. Here, we use a modulated Gaussian pulse shape, with time dependence given by the expression","category":"page"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"g(t) = sinleftomega(t-t_0)right e^-frac(t-t_0)^22tau^2 ","category":"page"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"For this simulation, we use a center frequency f = omega2pi = 10text GHz and pulse width tau = 005text ns. The offset t_0 is automatically chosen by Palace in order to smoothly ramp up the excitation from the rest initial condition. Time integration uses the second-order implicit Generalized-alpha scheme with a uniform time step Delta t = 5times 10^-3text ns, and the solution is computed for the interval tin0010text ns. The electric and magnetic field solutions are sampled every 10 time steps for visualization.","category":"page"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"Below, we plot the time histories of the port voltage at the excited coaxial lumped port for the three simulation cases.","category":"page"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/coaxial-2.png\" width=\"70%\" />\n</p><br/>","category":"page"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"We can observe that as expected, the matched termination absorbs the incident waveform nearly perfectly, while it is reflected with the same polarity for the shorted termination and opposite polarity for the open termination (phase shifted by pi). Furthermore, the reflected wave is noticably attenuated due to the material loss of the transmission line dielectric.","category":"page"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"Lastly, an animation of the signal propagation for the matched (left) and shorted (right) simulations, constructed using the saved fields, is shown below.","category":"page"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/coaxial-3.gif\" width=\"90%\" />\n</p>","category":"page"},{"location":"examples/coaxial/#References","page":"Signal Propagation in a Coaxial Cable","title":"References","text":"","category":"section"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"[1] D. M. Pozar, Microwave Engineering, Wiley, Hoboken, NJ, 2012.","category":"page"},{"location":"config/config/","page":"Overview","title":"Overview","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"config/config/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"config/config/","page":"Overview","title":"Overview","text":"A configuration file written in the JSON format is used specify the runtime options for a Palace simulation. The following sections give a detailed overview of the file format and available settings.","category":"page"},{"location":"config/config/","page":"Overview","title":"Overview","text":"Parameters are specified in the form of keyword/value pairs where the key is a string and the value may be a string, boolean, integer or floating point number, or array. Parameters are grouped into a hierarchy of objects. We support relaxed JSON formatting with C++-style comments (//, /* */). Integer arrays can be specified as comma-separated lists of integers or integer ranges, for example [1,3-5,6] is parsed as [1,3,4,5,6].","category":"page"},{"location":"config/config/","page":"Overview","title":"Overview","text":"In the following sections, default values for the parameters are specified alongside the description of each keyword in square brackets. Keywords for which there is no default value listed ([None]) are required in general if specifying values for other keywords under the same top-level object.","category":"page"},{"location":"config/config/","page":"Overview","title":"Overview","text":"The top-level JSON object of the configuration file has the following structure:","category":"page"},{"location":"config/config/","page":"Overview","title":"Overview","text":"{\n    \"Problem\":\n    {\n        ...\n    },\n    \"Model\":\n    {\n        ...\n    },\n    \"Domains\":\n    {\n        ...\n    },\n    \"Boundaries\":\n    {\n        ...\n    },\n    \"Solver\":\n    {\n        ...\n    }\n}","category":"page"},{"location":"config/config/","page":"Overview","title":"Overview","text":"Each property of the top-level config JSON object is detailed in its corresponding section of the documentation.","category":"page"},{"location":"config/config/#Contents","page":"Overview","title":"Contents","text":"","category":"section"},{"location":"config/config/","page":"Overview","title":"Overview","text":"config[\"Problem\"]\nconfig[\"Model\"]\nconfig[\"Domains\"]\nconfig[\"Boundaries\"]\nconfig[\"Solver\"]","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"config/solver/#config[\"Solver\"]","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"","category":"section"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Solver\":\n{\n    \"Order\": <int>,\n    \"PartialAssemblyOrder\": <int>,\n    \"Device\": <string>,\n    \"Backend\": <string>,\n    \"Eigenmode\":\n    {\n        ...\n    },\n    \"Driven\":\n    {\n        ...\n    },\n    \"Transient\":\n    {\n        ...\n    },\n    \"Electrostatic\":\n    {\n        ...\n    },\n    \"Magnetostatic\":\n    {\n        ...\n    },\n    \"Linear\":\n    {\n        ...\n    }\n}","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"with","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Order\" [1] :  Finite element order (degree). Arbitrary high-order spaces are supported.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"PartialAssemblyOrder\" [1] :  Order at which to switch from full assembly of finite element operators to partial assembly. Setting this parameter equal to 1 will fully activate operator partial assembly on all levels, while setting it to some large number (greater than the finite element order) will result in fully assembled operators as sparse matrices.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Device\" [\"CPU\"] :  The runtime device configuration passed to MFEM in order to activate different options specified during configuration. The available options are:","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"CPU\"\n\"GPU\"\n\"Debug\"","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"The \"GPU\" option will automatically activate the cuda or hip device based on whether MFEM is built with CUDA (MFEM_USE_CUDA=ON) or HIP (MFEM_USE_HIP=ON) support. When Palace is built with OpenMP support (PALACE_WITH_OPENMP=ON), omp is automatically added to the list of activated MFEM devices. The \"Debug\" option for MFEM's debug device is useful for debugging issues associated with GPU-based runs of Palace.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Backend\" [\"\"] :  Specifies the libCEED backend to use for the simulation. If no backend is specified, a suitable default backend is selected based on the given config[\"Solver\"][\"Device\"].","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Eigenmode\" :  Top-level object for configuring the eigenvalue solver for the eigenmode simulation type. Thus, this object is only relevant for config[\"Problem\"][\"Type\"]: \"Eigenmode\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Driven\" :  Top-level object for configuring the frequency domain driven simulation type. Thus, this object is only relevant for config[\"Problem\"][\"Type\"]: \"Driven\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Transient\" :  Top-level object for configuring the time domain driven simulation type. Thus, this object is only relevant for config[\"Problem\"][\"Type\"]: \"Transient\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Electrostatic\" :  Top-level object for configuring the electrostatic simulation type. Thus, this object is only relevant for config[\"Problem\"][\"Type\"]: \"Electrostatic\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Magnetostatic\" :  Top-level object for configuring the magnetostatic simulation type. Thus, this object is only relevant for config[\"Problem\"][\"Type\"]: \"Magnetostatic\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Linear\" :  Top-level object for configuring the linear solver employed by all simulation types.","category":"page"},{"location":"config/solver/#Advanced-solver-options","page":"config[\"Solver\"]","title":"Advanced solver options","text":"","category":"section"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"QuadratureOrderJacobian\" [false]\n\"ExtraQuadratureOrder\" [0]","category":"page"},{"location":"config/solver/#solver[\"Eigenmode\"]","page":"config[\"Solver\"]","title":"solver[\"Eigenmode\"]","text":"","category":"section"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Eigenmode\":\n{\n    \"Target\": <float>,\n    \"Tol\": <float>,\n    \"MaxIts\": <int>,\n    \"MaxSize\": <int>,\n    \"N\": <int>,\n    \"Save\": <int>,\n    \"Type\": <string>,\n    \"NonlinearType\" : <string>,\n}","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"with","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Target\" [None] :  (Nonzero) frequency target above which to search for eigenvalues, GHz.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Tol\" [1.0e-6] :  Relative convergence tolerance for the eigenvalue solver.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MaxIts\" [0] :  Maximum number of iterations for the iterative eigenvalue solver. A value less than 1 uses the solver default.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MaxSize\" [0] :  Maximum subspace dimension for eigenvalue solver. A value less than 1 uses the solver default.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"N\" [1] :  Number of eigenvalues to compute.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Save\" [0] :  Number of computed field modes to save to disk for visualization with ParaView. Files are saved in the paraview/ (and/or gridfunction/) directory under the directory specified by config[\"Problem\"][\"Output\"].","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Type\" [\"Default\"] :  Specifies the eigenvalue solver to be used in computing the given number of eigenmodes of the problem. The available options are:","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"SLEPc\"\n\"ARPACK\"\n\"Default\" :  Use the default eigensolver. Currently, this is the Krylov-Schur eigenvalue solver from \"SLEPc\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"NonlinearType\" [\"Hybrid\"] : Specifies the nonlinear eigenvalue solver to be used for nonlinear problems (e.g. frequency-dependent boundary conditions). The available options are:","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Hybrid\" : Hybrid algorithm where a (quadratic) polynomial approximation of the nonlinear problem is first solved and the eigenmodes are then refined with a quasi-Newton nonlinear eigensolver.\n\"SLP\" : SLEPc's Successive Linear Problem nonlinear eigensolver.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"TargetUpper\" [3 * Target] : Upper end of the frequency target range in which to search for eigenvalues, GHz. Only used in nonlinear problems. Using an inaccurate upper bound (significantly smaller or greater than the largest eigenvalue sought) can negatively affect the convergence of the nonlinear eigensolver.","category":"page"},{"location":"config/solver/#Advanced-eigenmode-solver-options","page":"config[\"Solver\"]","title":"Advanced eigenmode solver options","text":"","category":"section"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"PEPLinear\" [true]\n\"Scaling\" [true]\n\"StartVector\" [true]\n\"StartVectorConstant\" [false]\n\"MassOrthogonal\" [false]\n\"RefineNonlinear\" [true]\n\"LinearTol\" [1e-3]\n\"PreconditionerLag\" [10]\n\"PreconditionerLagTol\" [1e-4]\n\"MaxRestart\" [2]","category":"page"},{"location":"config/solver/#solver[\"Driven\"]","page":"config[\"Solver\"]","title":"solver[\"Driven\"]","text":"","category":"section"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Driven\":\n{\n    \"MinFreq\": <float>,\n    \"MaxFreq\": <float>,\n    \"FreqStep\": <float>,\n    \"SaveStep\": <int>,\n    \"Samples\": [ ... ],\n    \"Save\": [<float array>],\n    \"Restart\": <int>,\n    \"AdaptiveTol\": <float>,\n    \"AdaptiveMaxSamples\": <int>,\n    \"AdaptiveConvergenceMemory\": <int>\n}","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"with","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MinFreq\" [None] :  Lower bound of frequency sweep interval, GHz.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MaxFreq\" [None] :  Upper bound of frequency sweep interval, GHz.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"FreqStep\" [None] :  Frequency step size for frequency sweep, GHz.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"SaveStep\" [0] :  Controls how often, in number of frequency steps, to save computed fields to disk for visualization with ParaView. Files are saved in the paraview/ (and/or gridfunction/) directory under the directory specified by config[\"Problem\"][\"Output\"].","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Samples\" [None] : Array of sample specifications that specify how to construct frequency samples. These are all combined to form a sorted and unique collection of samples. These samples can be instead of, or in addition to, the interface provided by \"MinFreq\", \"MaxFreq\", \"FreqStep\" and \"SaveStep\". See solver[\"Driven\"][\"Samples\"] for the construction of each of these structs.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Save\" [None] : Array of frequencies to save computed fields to disk for visualization with ParaView, in addition to those specified by \"SaveStep\" in any sample specification. Files are saved in the paraview/ (and/or gridfunction/) directory under the directory specified by config[\"Problem\"][\"Output\"].","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Restart\" [1] :  Iteration (1-based) from which to restart for a partial frequency sweep simulation. That is \"Restart\": x will start the frequency sweep from the x-th sample rather than the first sample. This indexing is from the combined set of frequency samples. Not valid for an adaptive fast frequency sweep.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"AdaptiveTol\" [0.0] :  Relative error convergence tolerance for adaptive frequency sweep. If zero, adaptive frequency sweep is disabled and the full-order model is solved at each frequency step in the specified interval. If positive, this tolerance is used to ensure the reliability of the reduced-order model relative to the full-order one in the frequency band of interest.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"AdaptiveMaxSamples\" [20] :  Maximum number of frequency samples used to construct the reduced-order model for adaptive fast frequency sweep, if the specified tolerance (\"AdaptiveTol\") is not met first. In simulations with multiple excitations, this is the maximum number of samples per excitation.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"AdaptiveConvergenceMemory\" [2] :  Memory used for assessing convergence of the adaptive sampling algorithm for constructing the reduced-order model for adaptive fast frequency sweep. For example, a memory of \"2\" requires two consecutive samples which satisfy the error tolerance.","category":"page"},{"location":"config/solver/#solver[\"Driven\"][\"Samples\"]","page":"config[\"Solver\"]","title":"solver[\"Driven\"][\"Samples\"]","text":"","category":"section"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Samples\":\n{\n    \"Type\": <string>,\n    \"MinFreq\": <float>,\n    \"MaxFreq\": <float>,\n    \"FreqStep\": <float>,\n    \"NSample\": <float>,\n    \"Freq\": [<float array>],\n    \"SaveStep\": <int>,\n    \"AddToPROM\": <bool>\n}","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Type\" [None] : The type of range being specified. The list of valid options are \"Linear\", \"Point\", \"Log\". For non-ambiguous combinations of other fields, this can be inferred for convenience.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MinFreq\" [None] :  Lower bound of frequency sweep interval, GHz. Valid for \"Linear\" and \"Log\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MaxFreq\" [None] :  Upper bound of frequency sweep interval, GHz. Valid for \"Linear\" and \"Log\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"FreqStep\" [None] :  Frequency step size for frequency sweep, GHz. Valid for \"Linear\" only. Mutually exclusive with \"NSample\"","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"NSample\" [None] : Number of frequency samples over the specified range. Valid for \"Linear\" and \"Log\". Mutually exclusive with \"FreqStep\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Freq\" [None] : Explicit frequencies to be sample, GHz. Valid for \"Point\" only.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"SaveStep\" [0] :  Controls how often, in number of frequency steps, to save computed fields to disk for visualization with ParaView. Files are saved in the paraview/ (and/or gridfunction/) directory under the directory specified by config[\"Problem\"][\"Output\"].","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"AddToPROM\" [false] : Advanced option to force the inclusion of this sample into the PROM when performing an adaptive sweep. This is primarily a debugging tool as the error estimation procedure will in general make more efficient selections of sampling points, and using this mechanism can result in a significantly larger and less efficient PROM.","category":"page"},{"location":"config/solver/#solver[\"Transient\"]","page":"config[\"Solver\"]","title":"solver[\"Transient\"]","text":"","category":"section"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Transient\":\n{\n    \"Type\": <string>,\n    \"Excitation\": <string>,\n    \"ExcitationFreq\": <float>,\n    \"ExcitationWidth\": <float>,\n    \"MaxTime\": <float>,\n    \"TimeStep\": <float>,\n    \"SaveStep\": <int>,\n    \"Order\": <int>,\n    \"RelTol\": <float>,\n    \"AbsTol\": <float>\n}","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"with","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Type\" [\"Default\"] :  Specifies the time integration scheme used for the discretization of the second-order system of differential equations. The available options are:","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"GeneralizedAlpha\" :  The second-order implicit generalized-alpha method with rho_inf = 10. This scheme is unconditionally stable.\n\"ARKODE\" :  SUNDIALS ARKode implicit Runge-Kutta scheme applied to the first-order ODE system for the electric field with adaptive time-stepping. This option is only available when Palace has been built with SUNDIALS support.\n\"CVODE\" :  SUNDIALS CVODE implicit multistep method scheme applied to the first-order ODE system for the electric field with adaptive time-stepping. This option is only available when Palace has been built with SUNDIALS support.\n\"RungeKutta\" : Two stage, singly diagonal implicit Runge-Kutta (SDIRK) method. Second order and L-stable.\n\"Default\" :  Use the default \"GeneralizedAlpha\" time integration scheme.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Excitation\" [None] :  Controls the time dependence of the source excitation. The available options are:","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Sinusoidal\" :  A sinusoidal excitation at a user specified frequency.\n\"Gaussian\" :  A Gaussian pulse with a user specified width which defines the bandwidth.\n\"DifferentiatedGaussian\" :  A differentiated Gaussian pulse with a user specified width which defines the bandwidth.\n\"ModulatedGaussian\" :  A modulated Gaussian pulse at a user specified center frequency and width used to excite the system without any DC component.\n\"Ramp\" :  A differentiable unit step function to model the ramp up to a DC signal.\n\"SmoothStep\" :  A smoother many-times differentiable unit step function to model the ramp up to a DC signal over a specified width of time.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"ExcitationFreq\" [None] :  Center frequency used for harmonic source excitations, GHz. Only relevant when \"Excitation\" is one of \"Sinusoidal\", \"Gaussian\", \"DifferentiatedGaussian\", or \"ModulatedGaussian\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"ExcitationWidth\" [None] :  Pulse width for Gaussian-type source excitations, ns. Only relevant when \"Excitation\" is one of \"Gaussian\", \"DifferentiatedGaussian\", \"ModulatedGaussian\", or \"SmoothStep\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MaxTime\" [None] :  End of simulation time interval, ns. Transient simulations always start from rest at t = 00.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"TimeStep\" [None] :  Uniform time step size for time integration, ns.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"SaveStep\" [0] :  Controls how often, in number of time steps, to save computed fields to disk for visualization with ParaView. Files are saved in the paraview/ (and/or gridfunction/) directory under the directory specified by config[\"Problem\"][\"Output\"].","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Order\" [2] :  Order of the adaptive Runge-Kutta integrators or maximum order of the multistep method, must be within [2,5]. Should only be specified if \"Type\" is \"ARKODE\" or \"CVODE\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"RelTol\" [1e-4] :  Relative tolerance used in adaptive time-stepping schemes. Should only be specified if \"Type\" is \"ARKODE\" or \"CVODE\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"AbsTol\" [1e-9] :  Absolute tolerance used in adaptive time-stepping schemes. Should only be specified if \"Type\" is \"ARKODE\" or \"CVODE\".","category":"page"},{"location":"config/solver/#solver[\"Electrostatic\"]","page":"config[\"Solver\"]","title":"solver[\"Electrostatic\"]","text":"","category":"section"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Electrostatic\":\n{\n    \"Save\": <int>\n}","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"with","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Save\" [0] :  Number of computed electric field solutions to save to disk for visualization with ParaView, ordered by the entries in the computed capacitance matrix. Files are saved in the paraview/ (and/or gridfunction/) directory under the directory specified by config[\"Problem\"][\"Output\"].","category":"page"},{"location":"config/solver/#solver[\"Magnetostatic\"]","page":"config[\"Solver\"]","title":"solver[\"Magnetostatic\"]","text":"","category":"section"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Magnetostatic\":\n{\n    \"Save\": <int>\n}","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"with","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Save\" [0] :  Number of computed magnetic field solutions to save to disk for visualization with ParaView), ordered by the entries in the computed inductance matrix. Files are saved in the paraview/ (and/or gridfunction/) directory under the directory specified by config[\"Problem\"][\"Output\"].","category":"page"},{"location":"config/solver/#solver[\"Linear\"]","page":"config[\"Solver\"]","title":"solver[\"Linear\"]","text":"","category":"section"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Linear\":\n{\n    \"Type\": <string>,\n    \"KSPType\": <string>,\n    \"Tol\": <float>,\n    \"MaxIts\": <int>,\n    \"MaxSize\": <int>,\n    \"MGMaxLevels\": <int>,\n    \"MGCoarsenType\": <string>,\n    \"MGCycleIts\": <int>,\n    \"MGSmoothIts\": <int>,\n    \"MGSmoothOrder\": <int>,\n    \"PCMatReal\": <bool>,\n    \"PCMatShifted\": <bool>,\n    \"ComplexCoarseSolve\": <bool>,\n    \"PCSide\": <string>,\n    \"DivFreeTol\": <float>,\n    \"DivFreeMaxIts\": <float>,\n    \"EstimatorTol\": <float>,\n    \"EstimatorMaxIts\": <float>,\n    \"EstimatorMG\": <bool>,\n    \"GSOrthogonalization\": <string>\n}","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"with","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Type\" [\"Default\"] :  Specifies the solver used for preconditioning the linear system of equations to be solved for each simulation type. The available options are:","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"SuperLU\" :  The SuperLU_DIST sparse direct solver in real double precision is used to factorize the system matrix. For frequency domain problems this uses a real approximation to the true complex linear system matrix. This option is only available when Palace has been built with SuperLU_DIST support.\n\"STRUMPACK\" :  The STRUMPACK sparse direct solver in real double precision is used to factorize the system matrix. For frequency domain problems this uses a real approximation to the true complex linear system matrix. This option is only available when Palace has been built with STRUMPACK support.\n\"MUMPS\" :  The MUMPS sparse direct solver in real double precision is used to factorize the system matrix. For frequency domain problems this uses a real approximation to the true complex linear system matrix. This option is only available when Palace has been built with MUMPS support.\n\"AMS\" :  Hypre's Auxiliary-space Maxwell Solver (AMS), an algebraic multigrid (AMG)-based preconditioner.\n\"BoomerAMG\" :  The BoomerAMG AMG solver from Hypre.\n\"Jacobi\" :  Diagonal scaling with a simple Jacobi preconditioner (not recommended in general).\n\"Default\" :  Use the default \"AMS\" solver for simulation types involving definite or semi-definite curl-curl operators (time domain problems as well as magnetostatics). For frequency domain problems, use a sparse direct solver if available, otherwise uses \"AMS\". For electrostatic problems, uses \"BoomerAMG\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"KSPType\" [\"Default\"] :  Specifies the iterative Krylov subspace solver type for solving linear systems of equations arising for each simulation type. The available options are:","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"CG\"\n\"GMRES\"\n\"FGMRES\"\n\"Default\" :  Use the default \"GMRES\" Krylov subspace solver for frequency domain problems, that is when config[\"Problem\"][\"Type\"] is \"Eigenmode\" or \"Driven\". For the other simulation types, the linear system matrix is always real and symmetric positive definite (SPD) and the preconditioned conjugate gradient method (\"CG\") is used as the Krylov solver.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Tol\" [1.0e-6] :  Relative residual convergence tolerance for the iterative linear solver.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MaxIts\" [100] :  Maximum number of iterations for the iterative linear solver.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MaxSize\" [0] :  Maximum Krylov space size for the GMRES and FGMRES solvers. A value less than 1 defaults to the value specified by \"MaxIts\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MGMaxLevels\" [100] : When greater than 1, enable the geometric multigrid preconditioning, which uses p- and h-multigrid coarsening as available to construct the multigrid hierarchy. The solver specified by \"Type\" is used on the coarsest level. Relaxation on the fine levels is performed with Chebyshev smoothing.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MGCoarsenType\" [\"Logarithmic\"] :  Coarsening to create p-multigrid levels.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Logarithmic\"\n\"Linear\"","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MGCycleIts\" [1] : Number of V-cycle iterations per preconditioner application for multigrid preconditioners (when the geometric multigrid preconditioner is enabled, i.e. when MGMaxLevels > 1, or when \"Type\" is \"AMS\" or \"BoomerAMG\").","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MGSmoothIts\" [1] : Number of pre- and post-smooth iterations used for multigrid preconditioners (when the geometric multigrid preconditioner is enabled, i.e. when MGMaxLevels > 1, or when \"Type\" is \"AMS\" or \"BoomerAMG\").","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MGSmoothOrder\" [0] :  Order of polynomial smoothing for geometric multigrid preconditioning. A value less than 1 defaults to twice the solution order given in config[\"Solver\"][\"Order\"] or 4, whichever is larger.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"PCMatReal\" [false] :  When set to true, constructs the preconditioner for frequency domain problems using a real-valued approximation of the system matrix. This is always performed for the coarsest multigrid level regardless of the setting of \"PCMatReal\".","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"PCMatShifted\" [false] :  When set to true, constructs the preconditioner for frequency domain problems using a positive definite approximation of the system matrix by flipping the sign for the mass matrix contribution, which can help performance at high frequencies (relative to the lowest nonzero eigenfrequencies of the model).","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"ComplexCoarseSolve\" [false] : When set to true, the coarse-level solver uses the true complex-valued system matrix. When set to false, the real-valued approximation is used.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"PCSide\" [\"Default\"] :  Side for preconditioning. Not all options are available for all iterative solver choices, and the default choice depends on the iterative solver used.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Left\"\n\"Right\"\n\"Default\"","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"DivFreeTol\" [1.0e-12] :  Relative tolerance for divergence-free cleaning used in the eigenmode simulation type. Ignored if non-zero Floquet wave vector is specified in config[\"Boundaries\"][\"Periodic\"][\"FloquetWaveVector\"] or config[\"Boundaries\"][\"FloquetWaveVector\"], or non-zero config[\"Domains\"][\"Materials\"][\"LondonDepth\"] is specified.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"DivFreeMaxIts\" [1000] :  Maximum number of iterations for divergence-free cleaning use in the eigenmode simulation type. Ignored if non-zero Floquet wave vector is specified in config[\"Boundaries\"][\"Periodic\"][\"FloquetWaveVector\"] or config[\"Boundaries\"][\"FloquetWaveVector\"], or non-zero config[\"Domains\"][\"Materials\"][\"LondonDepth\"] is specified.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"EstimatorTol\" [1.0e-6] :  Relative tolerance for flux projection used in the error estimate calculation.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"EstimatorMaxIts\" [10000] :  Maximum number of iterations for flux projection use in the error estimate calculation.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"EstimatorMG\" [false] :  Set to true in order to enable multigrid preconditioner with AMG coarse solve for the error estimate linear solver, instead of just Jacobi.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"GSOrthogonalization\" [\"MGS\"] :  Gram-Schmidt variant used to explicitly orthogonalize vectors in Krylov subspace methods or other parts of the code.","category":"page"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"MGS\" :  Modified Gram-Schmidt\n\"CGS\" :  Classical Gram-Schmidt\n\"CGS2\" :  Two-step classical Gram-Schmidt with reorthogonalization","category":"page"},{"location":"config/solver/#Advanced-linear-solver-options","page":"config[\"Solver\"]","title":"Advanced linear solver options","text":"","category":"section"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"InitialGuess\" [true]\n\"MGUseMesh\" [true]\n\"MGAuxiliarySmoother\" [true]\n\"MGSmoothEigScaleMax\" [1.0]\n\"MGSmoothEigScaleMin\" [0.0]\n\"MGSmoothChebyshev4th\" [true]\n\"ColumnOrdering\" [\"Default\"] :  \"METIS\", \"ParMETIS\",\"Scotch\", \"PTScotch\", \"PORD\", \"AMD\", \"RCM\", \"Default\"\n\"STRUMPACKCompressionType\" [\"None\"] :  \"None\", \"BLR\", \"HSS\", \"HODLR\", \"ZFP\", \"BLR-HODLR\", \"ZFP-BLR-HODLR\"\n\"STRUMPACKCompressionTol\" [1.0e-3]\n\"STRUMPACKLossyPrecision\" [16]\n\"STRUMPACKButterflyLevels\" [1]\n\"SuperLU3DCommunicator\" [false]\n\"AMSVectorInterpolation\" [false]\n\"AMSSingularOperator\" [false]\n\"AMGAggressiveCoarsening\" [false]","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"config/domains/#config[\"Domains\"]","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"","category":"section"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Domains\":\n{\n    \"Materials\":\n    [\n        ...\n    ],\n    \"Postprocessing\":\n    {\n        \"Energy\":\n        [\n            ...\n        ],\n        \"Probe\":\n        [\n            ...\n        ]\n    }\n}","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"with","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Materials\" :  Array of material properties objects.","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Postprocessing\" :  Top-level object for configuring domain postprocessing.","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Energy\" :  Array of objects for postprocessing domain energies.","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Probe\" :  Array of objects for postprocessing solution field values evaluated at a probe location in space.","category":"page"},{"location":"config/domains/#domains[\"Materials\"]","page":"config[\"Domains\"]","title":"domains[\"Materials\"]","text":"","category":"section"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Materials\":\n[\n    // Material 1\n    {\n        \"Attributes\": [<int array>],\n        \"Permeability\": <float> or [<float array>],\n        \"Permittivity\": <float> or [<float array>],\n        \"LossTan\": <float> or [<float array>],\n        \"Conductivity\": <float> or [<float array>],\n        \"LondonDepth\": <float>,\n        \"MaterialAxes\": [[<array of float array>]]\n    },\n    // Material 2, 3, ...\n    ...\n]","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"with","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Attributes\" [None] :  Integer array of mesh domain attributes for this material.","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Permeability\" [1.0] :  Relative permeability for this material. Scalar or vector of 3 coefficients corresponding to each of \"MaterialAxes\".","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Permittivity\" [1.0] : Relative permittivity for this material. Scalar or vector of 3 coefficients corresponding to each of \"MaterialAxes\".","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"LossTan\" [0.0] :  Loss tangent for this material. Scalar or vector of 3 coefficients corresponding to each of \"MaterialAxes\".","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Conductivity\" [0.0] :  Electrical conductivity for this material, S/m. Activates Ohmic loss model in the material domain. Scalar or vector of 3 coefficients corresponding to each of \"MaterialAxes\".","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"LondonDepth\" [0.0] :  London penetration depth for this material, specified in mesh length units. Activates London equations-based model relating superconducting current and electromagnetic fields in the material domain.","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"MaterialAxes\" [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]] : Axes directions for specification of anisotropic material properties. Required to be unit length and orthogonal.","category":"page"},{"location":"config/domains/#domains[\"Postprocessing\"][\"Energy\"]","page":"config[\"Domains\"]","title":"domains[\"Postprocessing\"][\"Energy\"]","text":"","category":"section"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Postprocessing\":\n{\n    \"Energy\":\n    [\n        {\n            \"Index\": <int>,\n            \"Attributes\": [<int array>]\n        },\n        ...\n    ]\n}","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"with","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Index\" [None] :  Index of this energy postprocessing domain, used in postprocessing output files.","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Attributes\" [None] :  Integer array of mesh domain attributes for this energy postprocessing domain.","category":"page"},{"location":"config/domains/#domains[\"Postprocessing\"][\"Probe\"]","page":"config[\"Domains\"]","title":"domains[\"Postprocessing\"][\"Probe\"]","text":"","category":"section"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Postprocessing\":\n{\n    \"Probe\":\n    [\n        {\n            \"Index\": <int>,\n            \"Center\": [<float array>]\n        },\n        ...\n    ]\n}","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"with","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Index\" [None] :  Index of this probe, used in postprocessing output files.","category":"page"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Center\" [None] :  Floating point array of length equal to the model spatial dimension specifying the coordinates of this probe in mesh length units.","category":"page"},{"location":"examples/examples/","page":"Overview","title":"Overview","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"examples/examples/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"examples/examples/","page":"Overview","title":"Overview","text":"Some examples of using Palace, including configuration and mesh files, can be found in the examples/ directory of the source code. The following sections provide complete tutorials for each of the available example applications.","category":"page"},{"location":"examples/examples/","page":"Overview","title":"Overview","text":"These examples are also used by Palace's regression testing suite. See the test/examples/ directory for more details.","category":"page"},{"location":"examples/examples/#Contents","page":"Overview","title":"Contents","text":"","category":"section"},{"location":"examples/examples/","page":"Overview","title":"Overview","text":"Capacitance Matrix for Two Spheres\nInductance Matrix for a Pair of Concentric Rings\nDipole Antenna and Radiation Fields\nEigenmodes of a Cylinder\nSignal Propagation in a Coaxial Cable\nCrosstalk Between Coplanar Waveguides","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"examples/cylinder/#Eigenmodes-of-a-Cylinder","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"","category":"section"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"note: Note\nThe files for this example can be found in the examples/cylinder/ directory of the Palace source code.","category":"page"},{"location":"examples/cylinder/#Cavity","page":"Eigenmodes of a Cylinder","title":"Cavity","text":"","category":"section"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"This example demonstrates Palace's eigenmode simulation type to solve for the lowest frequency modes of a cylindrical cavity resonator. In particular, we consider a cylindrical cavity filled with Teflon (varepsilon_r = 208, tandelta = 4times 10^-4), with radius a = 274text cm and height d = 2a. From [1], the frequencies of the textTE_nml and textTM_nml modes are given by","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"beginaligned\nf_textTEnml = frac12pisqrtmuvarepsilon\n    sqrtleft(fracp_nmaright)^2 +\n    left(fraclpidright)^2 \nf_textTMnml = frac12pisqrtmuvarepsilon\n    sqrtleft(fracp_nmaright)^2 +\n    left(fraclpidright)^2 \nendaligned","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"where  p_nm and p_nm denote the m-th root (mgeq 1) of the n-th order Bessel function (ngeq 0) of the first kind, J_n, and its derivative, J_n, respectively.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"In addition, we have analytic expressions for the unloaded quality factors due to dielectric loss, Q_d, and imperfectly conducting walls, Q_c. In particular,","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"Q_d = frac1tandelta","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"and, for a surface resistance R_s,","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"Q_c = frac(ka)^3eta ad4(p_nm)^2 R_s\n    left1-left(fracnp_nmright)^2right\n    leftfracad2\n        left1+left(fracbeta an(p_nm)^2right)^2right +\n        left(fracbeta a^2p_nmright)^2\n        left(1-fracn^2(p_nm)^2right)right^-1","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"where k=omegasqrtmuvarepsilon, eta=sqrtmuvarepsilon, and beta=lpid.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"The initial Gmsh mesh for this problem, from mesh/cavity_prism.msh, is shown below. We use quadratic triangular prism elements. There are also two other included mesh files, mesh/cavity_tet.msh and mesh/cavity_hex.msh, which use curved tetrahedral and hexahedral elements, respectively.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/cavity-1.png\" width=\"60%\" />\n</p><br/>","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"There are two configuration files for this problem, cavity_pec.json and cavity_impedance.json.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"In both, the config[\"Problem\"][\"Type\"] field is set to \"Eigenmode\", and we use the mesh shown above. The material properties for Teflon are entered under config[\"Domains\"][\"Materials\"]. The config[\"Domains\"][\"Postprocessing\"][\"Energy]\" object is used to extract the quality factor due to bulk dielectric loss; in this problem since there is only one domain this is trivial, but in problems with multiple material domains this feature can be used to isolate the energy-participation ratio (EPR) and associated quality factor due to different domains in the model.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"The only difference between the two configuration files is in the \"Boundaries\" object: cavity_pec.json prescribes a perfect electric conductor (\"PEC\") boundary condition to the cavity boundary surfaces, while cavity_impedance.json prescribes a surface impedance condition with the surface resistance R_s = 00184text Omegatextsq, for copper at 5text GHz.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"In both cases, we configure the eigenvalue solver to solve for the 15 lowest frequency modes above 20text GHz (the dominant mode frequencies for both the textTE and textTM cases fall around 29text GHz frequency for this problem). A sparse direct solver is used for the solutions of the linear system resulting from the spatial discretization of the governing equations, using in this case a fourth-order finite element space.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"The frequencies for the lowest-order textTE and textTM modes computed using the above formula for this problem are listed in the table below.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"(nml) f_textTE f_textTM\n(010) –– 2903605text GHz\n(110) –– 4626474text GHz\n(210) –– 6200829text GHz\n(011) 5000140text GHz 3468149text GHz\n(111) 2922212text GHz 5000140text GHz\n(211) 4146842text GHz 6484398text GHz\n(012) 5982709text GHz 4776973text GHz\n(112) 4396673text GHz 5982709text GHz\n(212) 5290341text GHz 7269033text GHz","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"First, we examine the output of the cavity_pec.json simulation. The file postpro/cavity_pec/eig.csv contains information about the computed eigenfrequencies and associated quality factors:","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"include_example_file(\"cylinder/cavity_pec\", \"eig.csv\") # hide","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"Indeed we can find a correspondence between the analytic modes predicted and the solutions obtained by Palace. Since the only source of loss in the simulation is the nonzero dielectric loss tangent, we have Q = Q_d = 100004 = 250times 10^3 in all cases.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"Next, we run cavity_impedance.json, which  adds the surface impedance boundary condition. Examining postpro/cavity_impedance/eig.csv we see that the mode frequencies are roughly unchanged but the quality factors have fallen due to the addition of imperfectly conducting walls to the model:","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"include_example_file(\"cylinder/cavity_impedance\", \"eig.csv\") # hide","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"However, the bulk dielectric loss postprocessing results, computed from the energies written to postpro/cavity_impedance/domain-E.csv, still give Q_d = 10004 = 250times 10^3 for every mode as expected.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"Focusing on the textTE_011 mode with f_textTE010 = 500text GHz, we can read the mode quality factor Q = 230times 10^3. Subtracting out the contribution of dielectric losses, we have","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"Q_c = left(frac1Q-frac1Q_dright)^-1 = 294times 10^4","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"which is the same as the analytical result given in Example 6.4 from [1] for this geometry.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"Finally, a clipped view of the electric field (left) and magnetic flux density magnitudes for the textTE_011 mode is shown below.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/cavity-2a.png\" width=\"45%\" />\n  <img src=\"../../assets/examples/cavity-2b.png\" width=\"45%\" />\n</p>","category":"page"},{"location":"examples/cylinder/#Mesh-convergence","page":"Eigenmodes of a Cylinder","title":"Mesh convergence","text":"","category":"section"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"The effect of mesh size can be investigated for the cylindrical cavity resonator using convergence_study.jl. For a polynomial order of solution and refinement level, a mesh is generated using Gmsh using polynomials of the same order to resolve the boundary geometry. The eigenvalue problem is then solved for f_textTM010 and f_textTE111, and the relative error, fracf-f_texttruef_texttrue, of each mode plotted against textDOF^-frac13, a notional mesh size. Three different element types are considered: tetrahedra, prisms and hexahedra, and the results are plotted below. The x-axis is a notional measure of the overall cost of the solve, accounting for polynomial order.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/cavity-3a.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cavity-3b.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cavity-3c.png\" width=\"70%\" />\n</p><br/>","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"The observed rate of convergence for the eigenvalues are p+1 for odd polynomials and p+2 for even polynomials. Given the eigenmodes are analytic functions, the theoretical maximum convergence rate is 2p [2]. The figures demonstrate that increasing the polynomial order of the solution will give reduced error, however the effect may only become significant on sufficiently refined meshes.","category":"page"},{"location":"examples/cylinder/#Waveguide","page":"Eigenmodes of a Cylinder","title":"Waveguide","text":"","category":"section"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"This example demonstrates the eigenmode simulation type in  Palace to solve for the cutoff-frequencies of a circular waveguide. As with the cavity the interior material to be Silicon (varepsilon_r = 208, tandelta = 4times 10^-4), with cylindrical domain radius a = 274text cm, and length d=2a = 548text cm, however now periodic boundary conditions are applied in the z-direction. According to [1], the cutoff frequencies for the transverse electric and magnetic modes are given by the formulae:","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"beginaligned\nf_textTEnm = frac12pisqrtmuvarepsilon fracp_nma\nf_textTMnm = frac12pisqrtmuvarepsilon fracp_nma\nendaligned","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"which are identical to those for the cavity modes, in the special case of l=0.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"In addition to these pure waveguide modes, there are aliasing cavity modes corresponding to a full wavelength in the computational domain (l=2). In a practical problem these can be suppressed by choosing a smaller value of d which shifts such modes to higher frequencies. The relevant modes are tabulated as","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"(nml) f_textTE f_textTM\n(010) 4626481text GHz 2903636text GHz\n(110) 2223083text GHz 4626481text GHz\n(210) 3687749text GHz 6200856text GHz\n(310) 5072602text GHz 7703539text GHz\n(012) 5982715text GHz 4776992text GHz\n(112) 4396663text GHz 5982715text GHz\n(212) 5290372text GHz 7269056text GHz\n(312) 6334023text GHz 8586796text GHz","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"For this problem, we use curved tetrahedral elements from the mesh file mesh/cavity_tet.msh, and the configuration files waveguide.json and floquet.json.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"The main difference between these configuration files and those used in the cavity example is in the \"Boundaries\" object: waveguide.json specifies a perfect electric conductor (\"PEC\") boundary condition for the exterior surface and a periodic boundary condition (\"Periodic\") on the cross-sections of the cylinder (in the z- direction). The periodic attribute pairs are defined by \"DonorAttributes\" and \"ReceiverAttributes\", and the distance between them is given by the \"Translation\" vector in mesh units. In floquet.json, an additional \"FloquetWaveVector\" specifies the phase delay between the donor and receiver boundaries in the X/Y/Z directions.","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"The file postpro/waveguide/eig.csv contains information about the computed eigenfrequencies and associated quality factors:","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"include_example_file(\"cylinder/waveguide\", \"eig.csv\") # hide","category":"page"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"In common with the PEC cavity Q = Q_d = 100004 = 250times 10^3 in all cases, and all the anticipated waveguide modes are recovered with textTE_11 having the lowest cutoff frequency followed by textTM_01 and textTE_21, while the aliasing mode textTE_112 has marginally lower frequency than the waveguide modes textTE_01 and textTM_11 (4397text GHz compared to 4627text GHz) and is thus found first.","category":"page"},{"location":"examples/cylinder/#References","page":"Eigenmodes of a Cylinder","title":"References","text":"","category":"section"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"[1] D. M. Pozar, Microwave Engineering, Wiley, Hoboken, NJ, 2012.\n[2] A. Buffa, P. Houston, I. Perugia, Discontinuous Galerkin computation of the Maxwell eigenvalues on simplicial meshes, Journal of Computational and Applied Mathematics 204 (2007) 317-333.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Palace can be built and installed using the Spack HPC package manager, following the instructions in the Build using Spack section. Containerized builds are possible with Singularity/Apptainer, described in Build using Singularity/Apptainer. Alternatively, compiling from source using CMake is described in Build from source.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you are a user, we recommend you install Palace with Spack. If you intend to develop Palace, build from source instead.","category":"page"},{"location":"install/#Build-using-Spack","page":"Installation","title":"Build using Spack","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Palace is a registered package in the built-in Spack package repository. To install the solver, follow the instructions for setting up Spack on your system and run:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"spack install palace","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"More information about the available configuration options and dependencies can be found using spack info palace.","category":"page"},{"location":"install/#Build-using-Singularity/Apptainer","page":"Installation","title":"Build using Singularity/Apptainer","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Palace can be built in a Singularity/Apptainer container for HPC environments supporting the Singularity/Apptainer container system. To build the container using the provided definition file in the singularity/ directory, first set up Singularity/Apptainer on your system and subsequently run:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"singularity build palace.sif <SOURCE_DIR>/singularity/singularity.def","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"where the repository source code has been cloned to <SOURCE_DIR>. For more information about Singularity/Apptainer, see the Quick Start guide in the Singularity/Apptainer documentation.","category":"page"},{"location":"install/#Build-from-source","page":"Installation","title":"Build from source","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"A build from source requires the following prerequisites installed on your system:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"CMake version 3.21 or later\nC++17 compatible C++ compiler\nC and Fortran (optional) compilers for dependency builds\nMPI distribution\nBLAS, LAPACK libraries (described below in Math libraries)\nCUDA Toolkit or ROCm installation (optional, for GPU support only)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"In addition, builds from source require the following system packages which are typically already installed and are available from most package managers (apt, dnf, brew, etc.):","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Python 3\npkg-config\nlibunwind (optional)\nzlib (optional)","category":"page"},{"location":"install/#Quick-start","page":"Installation","title":"Quick start","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"To start, clone the code using","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"git clone https://github.com/awslabs/palace.git","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Then, a build using the default options can be performed by running the following from within the directory where the repository was cloned:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"mkdir build && cd build\ncmake ..\nmake -j","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"This installs the binary executable in build/bin/.","category":"page"},{"location":"install/#Configuration-options","page":"Installation","title":"Configuration options","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"To configure a Palace build in <BUILD_DIR> using the source code in <SOURCE_DIR>, run:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"mkdir <BUILD_DIR> && cd <BUILD_DIR>\ncmake [OPTIONS] <SOURCE_DIR>","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Here, [OPTIONS] is a list of options passed to cmake of the form -D<VARIABLE>=<VALUE>. The Palace build respects standard CMake variables, including:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"CMAKE_CXX_COMPILER, CMAKE_C_COMPILER, and CMAKE_Fortran_COMPILER which define the desired compilers.\nCMAKE_CXX_FLAGS, CMAKE_C_FLAGS, and CMAKE_Fortran_FLAGS which define the corresponding compiler flags.\nCMAKE_CUDA_COMPILER, CMAKE_CUDA_FLAGS, CMAKE_CUDA_ARCHITECTURES, and the corresponding CMAKE_HIP_COMPILER, CMAKE_HIP_FLAGS, and CMAKE_HIP_ARCHITECTURES for GPU-accelerated builds with CUDA or HIP.\nCMAKE_INSTALL_PREFIX which specifies the path for installation (if none is provided, defaults to <BUILD_DIR>).\nCMAKE_BUILD_TYPE which defines the build type such as Release, Debug, RelWithDebInfo, and MinSizeRel (Release if not otherwise specified).\nBUILD_SHARED_LIBS which is a flag to create shared libraries for dependency library builds instead of static libraries (OFF by default).\nCMAKE_PREFIX_PATH which lists directories specifying installation prefixes to be searched for dependencies.\nCMAKE_INSTALL_RPATH and CMAKE_INSTALL_RPATH_USE_LINK_PATH which configure the rpath for installed library and executable targets.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Additional build options are (with default values in brackets):","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"PALACE_WITH_64BIT_INT [OFF] :  Build with 64-bit integer support\nPALACE_WITH_OPENMP [OFF] :  Use OpenMP for shared-memory parallelism\nPALACE_WITH_CUDA [OFF] :  Use CUDA for NVIDIA GPU support\nPALACE_WITH_HIP [OFF] :  Use HIP for AMD or NVIDIA GPU support\nPALACE_WITH_GPU_AWARE_MPI [OFF] :  Option to set if MPI distribution is GPU aware\nPALACE_WITH_SUPERLU [ON] :  Build with SuperLU_DIST sparse direct solver\nPALACE_WITH_STRUMPACK [OFF] :  Build with STRUMPACK sparse direct solver\nPALACE_WITH_MUMPS [OFF] :  Build with MUMPS sparse direct solver\nPALACE_WITH_SLEPC [ON] :  Build with SLEPc eigenvalue solver\nPALACE_WITH_ARPACK [OFF] :  Build with ARPACK eigenvalue solver\nPALACE_WITH_LIBXSMM [ON] :  Build with LIBXSMM backend for libCEED\nPALACE_WITH_MAGMA [ON] :  Build with MAGMA backend for libCEED\nPALACE_WITH_GSLIB [ON] :  Build with GSLIB library for high-order field interpolation\nPALACE_WITH_SUNDIALS [ON] : Build with SUNDIALS ODE solver library","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"The build step is invoked by running (for example with 4 make threads)","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"make -j 4","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"or","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"cmake --build . -- -j 4","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"which installs the binary executable in ${CMAKE_INSTALL_PREFIX}/bin/.","category":"page"},{"location":"install/#Math-libraries","page":"Installation","title":"Math libraries","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"During the configure step, the build system will try to detect system installations of BLAS and LAPACK libraries depending on the system architecture according to the following procedure:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"For x86_64 systems:\nIf the MKLROOT environment variable is set, looks for an Intel MKL installation.\nIf the AOCL_DIR or AOCLROOT environment variables are set, looks for an AMD Optimizing CPU Libraries (AOCL) installation of BLIS and libFLAME.\nOtherwise, tries to locate an installation of OpenBLAS which is permissively licensed and available from most package managers.\nFor aarch64/arm64 systems:\nIf the ARMPL_DIR environment variable is set, looks for an Arm Performance Libraries (PL) installation.\nOtherwise, tries to locate an installation of OpenBLAS.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If the installation path of OpenBLAS is non-standard or is not found by default, it can be set using the OPENBLAS_DIR or OPENBLASROOT environment variables, or added to CMAKE_PREFIX_PATH when calling CMake.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"It is recommended in most cases to use serial BLAS and LAPACK builds (not multithreaded), as the standard parallelization approach in Palace is to use pure MPI parallelism.","category":"page"},{"location":"install/#Dependencies","page":"Installation","title":"Dependencies","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Palace leverages the MFEM finite element discretization library. It always configures and builds its own installation of MFEM internally in order to support the most up to date features and patches. Likewise, Palace will always build its own installation of libCEED, and GSLIB, when PALACE_WITH_GSLIB=ON.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"As part of the Build from source, the CMake build will automatically build and install a small number of third-party dependencies before building Palace. The source code for these dependencies is downloaded during the build process:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"METIS and ParMETIS\nHypre\nSuperLU_DIST (optional, when PALACE_WITH_SUPERLU=ON)\nSTRUMPACK (optional, when PALACE_WITH_STRUMPACK=ON), including ButterflyPACK and zfp support\nMUMPS (optional, when PALACE_WITH_MUMPS=ON)\nSLEPc (optional, when PALACE_WITH_SLEPC=ON), including PETSc\nARPACK-NG (optional, when PALACE_WITH_ARPACK=ON)\nLIBXSMM (optional, when PALACE_WITH_LIBXSMM=ON)\nMAGMA (optional, when PALACE_WITH_MAGMA=ON)\nSUNDIALS (optional, when PALACE_WITH_SUNDIALS=ON)\nnlohmann/json\nfmt\nEigen","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"For solving eigenvalue problems, at least one of SLEPc or ARPACK-NG must be specified. Typically only one of the SuperLU_DIST, STRUMPACK, and MUMPS dependencies is required but all can be built so the user can decide at runtime which solver to use.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"For unit testing, Palace relies on the Catch2 library, which is automatically downloaded and built when building the unit-tests target. See the Developer Notes for more information.","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"developer/tutorial_add_new_unit_test/#Tutorial:-Adding-a-New-Unit-Test","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"","category":"section"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"This tutorial demonstrates how to add unit tests to the Palace test suite. Prerequisites: familiarity with compiling and running unit tests (see Running unit tests).","category":"page"},{"location":"developer/tutorial_add_new_unit_test/#Overview","page":"Tutorial: Adding a New Unit Test","title":"Overview","text":"","category":"section"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"As a motivating example, we'll test the Sum(MPI_Comm comm, Vector& vec) function. This function has certain characteristics that make it interesting to test:","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"Vectors may have different sizes across MPI processes\nVector data may be stored on CPU or GPU\nThe function performs MPI communication to compute global sums","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"These characteristics require testing across multiple configurations to ensure correctness.","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"Create a new file test-vector-sum.cpp in test/unit/:","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"#include <catch2/matchers/catch_matchers_floating_point.hpp>\n#include <catch2/catch_test_macros.hpp>\n\n#include \"linalg/vector.hpp\"\n#include \"utils/communication.hpp\"\n\nnamespace palace\n{\nusing namespace Catch;\n\nTEST_CASE(\"Vector Sum - Basic\", \"[myvector][Serial]\")\n{\n  Vector v(2);\n  v(0) = 1.0;\n  v(1) = 2.0;\n\n  double sum = linalg::Sum(Mpi::World(), v);\n  REQUIRE_THAT(sum, Catch::Matchers::WithinRel(3.0));\n}\n\n}  // namespace palace","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"This defines a new Catch2 test case. The key components are:","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"Test name (Vector Sum - Basic): Must be unique across the test suite\nTags: [myvector] (arbitrary, used for filtering) and [Serial] (special tag, more on this later)\nWithinRel(): Handles floating-point comparison tolerances","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"To compile our test, we need to add it to the list of sources in the CMakeLists.txt in test/unit:","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"add_executable(unit-tests\n  # ... existing files ...\n  ${CMAKE_CURRENT_SOURCE_DIR}/test-vector-sum.cpp\n)","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"Then, build and run:","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"# Build tests in the build directory\nmake palace-tests\n\n# Run this specific test\npalace-build/test/unit/unit-tests \"[myvector]\"","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"We should see that All tests passed.","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"The test that we wrote is a reasonable first test, but it does not check that the feature works with GPUs or with multiple processes.","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"In particular, the test fails with multiple MPI processes because each process has a copy of v and contributes to the sum. Similarly, if we were to run this on a GPU we would find that the test passes, but we would also observe no activity on the device.","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"Let us extend this case so that we can write a more comprehensive test that is also meaningful on GPU and with MPI:","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"TEST_CASE(\"MyTest Vector Sum\", \"[myvector][Serial][Parallel][GPU]\")\n{\n  Vector v(2);\n  v.UseDevice(true);\n  auto d_v = v.Write();\n\n  mfem::forall(v.Size(), [=] MFEM_HOST_DEVICE (int i){\n    d_v[i] = rank + 1.0;\n  });\n\n  double sum = linalg::Sum(Mpi::World(), v);\n  double expected = Mpi::Size(Mpi::World()) * 3.0;\n  REQUIRE_THAT(value, Catch::Matchers::WithinRel(expected))\n}","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"We added GPU compatibility by (see, MFEM documentation):","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"Adding v.UseDevice(true);, which defines our intent to use v for computations on the device.\nDefining auto d_v = v.Write();, a pointer to area of memory on the device.\nUsing forall to execute the execute the function on the device.","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"When we add GPU code, we need to make sure that the file is compiled with the correct compiler. To do so, we add the file to TARGET_SOURCES_DEVICE in the CMakeLists.txt file, it is not already there.","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"set(TARGET_SOURCES_DEVICE\n  # ... existing files ...\n  ${CMAKE_CURRENT_SOURCE_DIR}/test-vector-sum.cpp\n)","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"Note that this code still works for CPU, when the device is not a GPU, allowing us to test both devices with the same code. Note also that here we are working with a vector with only two elements and this is highly inefficient on GPUs (but we are not concerned with performance here, only correctness).","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"To add MPI compatibility, we changed the expected value to account for how many copies of the vector v there are.","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"With these additions, this test case is a meaningful and interesting test in all the possible configurations, so we we added the [Parallel] and [GPU] tags.","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"Palace uses three special tags for execution control:","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"[Serial]: Runs only with single MPI process\n[Parallel]: Runs only with multiple MPI processes\n[GPU]: Runs only when GPU devices are available","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"To understand why we need this, let us add a test that checks that the sum is correct when vectors have different lengths on different MPI processes (for simplicity let us ignore GPU compatibility):","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"TEST_CASE(\"MyTest Vector Sum - Different Lengths\", \"[myvector][Parallel]\")\n{\n  Vector v;\n  \n  if (Mpi::Root(Mpi::World())){\n    v.SetSize(2);\n    v(0) = 10;\n    v(1) = 20;\n  } else {\n    v.SetSize(1);\n    v(0) = 3;\n  }\n  \n  double sum = linalg::Sum(Mpi::World(), v);\n  double expected = 3 * (Mpi::Size(Mpi::World()) - 1) + 30;\n  REQUIRE_THAT(value, Catch::Matchers::WithinRel(expected))\n}","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"This test is useful because it checks that Sum is not implemented making assumptions on the length of the vector. This test is also meaningless when run with less than 2 MPI processes, so we removed the [Serial] tag.","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"There is a final important tag that is supported by Palace, NoConcurrent. Consider the following (contrived) tests:","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"TEST_CASE(\"MyTest Print 1\", \"[myvector][Serial]\")\n{\n  Vector v;\n  v = 1;\n  {\n     std::ofstream file(\"vector.txt\");\n     vec.Print(file);\n  }\n  CHECK(std::filesystem::exists(\"vector.txt\"));\n}\n\nTEST_CASE(\"MyTest Print 2\", \"[myvector][Serial]\")\n{\n  Vector v;\n  v = 2;\n  {\n     std::ofstream file(\"vector.txt\");\n     vec.Print(file);\n  }\n  CHECK(std::filesystem::exists(\"vector.txt\"));\n}","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"These tests are problematic because:","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"They do not clean up the artifacts they produce, so the CHECK might pass because a vector.txt was already there.\nThey both write to the same file.","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"Even if we fixed 1., writing to the same file is still an issue because it could lead to race conditions if the tests were run at the same time.","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"We recommend writing tests in such a way that no race conditions can occur (see below), but if that is not feasible, you can use the NoConcurrent tag to indicate that the test should run in isolation. NoConcurrent can also be used to when it is important to have accurate timings and you want to ensure no other tests are being run.","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"tip: Think about concurrency\nThe most important lesson to take away from NoConcurrent is that you should assume that your tests are being run concurrently. Think about what resources they are accessing and modifying and remove potential race conditions.","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"In this particular case, you can use fixtures to create and tear down temporary working directories:","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"#include \"test-fixtures.hpp\"\n\nTEST_CASE_METHOD(palace::test::TempDirFixture<>, \"MyTest Print 1\", \"[myvector][Serial]\") {\n  // temp_dir is available and will be cleaned up automatically.\n  auto file_path = temp_dir / \"vector.txt\";\n  Vector v;\n  v = 1;\n  {\n     std::ofstream file(file_path);\n     vec.Print(file);\n  }\n  CHECK(std::filesystem::exists(file_path));\n}\n\nTEST_CASE_METHOD(palace::test::TempDirFixture<>, \"MyTest Print 2\", \"[myvector][Serial]\") {\n  // temp_dir is available and will be cleaned up automatically.\n  auto file_path = temp_dir / \"vector.txt\";\n  Vector v;\n  v = 2;\n  {\n     std::ofstream file(file_path);\n     vec.Print(file);\n  }\n  CHECK(std::filesystem::exists(file_path));\n}","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"By default, each MPI rank gets its own directory. For tests where all ranks need to share the same directory, use:","category":"page"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"TEST_CASE_METHOD(palace::test::TempDirFixture<palace::test::TempDirMode::Shared>,\n                 \"MyTest Shared\", \"[myvector][Parallel]\") {\n  // All ranks share temp_dir\n}","category":"page"},{"location":"guide/model/","page":"Simulation Models","title":"Simulation Models","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"guide/model/#Simulation-Models","page":"Simulation Models","title":"Simulation Models","text":"","category":"section"},{"location":"guide/model/#Supported-mesh-formats","page":"Simulation Models","title":"Supported mesh formats","text":"","category":"section"},{"location":"guide/model/","page":"Simulation Models","title":"Simulation Models","text":"The config[\"Model\"] object is used to specify the mesh for the discretized computational domain. In general, inputs are expected to be dimensional nondimensionalized internally. A length scale, specified under config[\"Model\"][\"L0\"], describes the length units of the mesh relative to 1 meter (i.e. config[\"Model\"][\"L0\"]: 1.0e-6 if the mesh coordinates are in mum, this is the default value). All other entries in the configuration file which have units of length should be specified in units of config[\"Model\"][\"L0\"] m.","category":"page"},{"location":"guide/model/","page":"Simulation Models","title":"Simulation Models","text":"MFEM supports a wide variety of mesh formats. In addition, Palace has built-in support for Nastran (.nas, .bdf) and COMSOL (.mphtxt, .mphbin) format mesh files, for both linear and high-order curved elements.","category":"page"},{"location":"guide/model/","page":"Simulation Models","title":"Simulation Models","text":"Geometric attributes for domains and boundaries in the mesh are used to define material properties and boundary conditions on the desired model regions and surfaces (see config[\"Domains\"] and config[\"Boundaries\"]). These attribute integers correspond to tags for the domain and boundary elements in the mesh, and should be non-negative and start at 1. They do not need to be contiguous in the mesh file. Throughout the configuration file, the \"Attributes\" keyword is used to indicate which domain or boundary attributes are relevant to the material properties or boundary conditions being specified.","category":"page"},{"location":"guide/model/#Mesh-refinement","page":"Simulation Models","title":"Mesh refinement","text":"","category":"section"},{"location":"guide/model/","page":"Simulation Models","title":"Simulation Models","text":"Refinement of the input mesh file can be performed using levels of global uniform refinement or region-based refinement, specified using the config[\"Model\"][\"Refinement\"] object. The user can specify any combination of uniform refinement levels as well as local refinement regions which refines the elements inside of a certain box or sphere-shaped region. For simplex meshes, the refinement maintains a conforming mesh but meshes containing hexahedra, prism, or pyramid elements will be nonconforming after local refinement (this is not supported at this time).","category":"page"},{"location":"guide/model/","page":"Simulation Models","title":"Simulation Models","text":"Adaptive mesh refinement (AMR) according to error estimates calculated from the computed solution can also be specified using the config[\"Model\"][\"Refinement\"] object. Nonconformal refinement is supported for all mesh types, and additionally conformal refinement is supported for simplex meshes. AMR is available for all problem types apart from driven problems in the time domain.","category":"page"},{"location":"guide/model/#Material-models","page":"Simulation Models","title":"Material models","text":"","category":"section"},{"location":"guide/model/","page":"Simulation Models","title":"Simulation Models","text":"Material properties are handled by the config[\"Domains\"][\"Materials\"] object. Palace supports linear, frequency independent constitutive laws for material modeling.","category":"page"},{"location":"guide/model/","page":"Simulation Models","title":"Simulation Models","text":"Materials with scalar or symmetric matrix-valued material properties are supported. For most simulation types, each material in the model requires a specified relative permittivity and relative permeability (for electrostatic simulations, only the permittivity is required, while for magnetostatics, only the permeability is required). For dielectric domains, a loss tangent may be specified. Alternatively, for normal conducting domains, an electrical conductivity may be specified which is used to relate the current density and electric field via Ohm's law.","category":"page"},{"location":"guide/model/","page":"Simulation Models","title":"Simulation Models","text":"Modeling of superconducting domains is performed using the current-field constitutive relations given by the London equations. The user can specify a London penetration depth to activate this model. It can also be used in conjunction with a material conductivity when wishing to model both superconducting and normal currents.","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"examples/cpw/#Crosstalk-Between-Coplanar-Waveguides","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"","category":"section"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"note: Note\nThe files for this example can be found in the examples/cpw/ directory of the Palace source code.","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"In this example, we construct a frequency domain model to analyze the wave transmission, reflection, near-end crosstalk, and far-end crosstalk for a four-port system comprised of two side-by-side coplanar waveguides (CPW). Each CPW is characterized by a trace width w = 30text μm and gap width s = 18text μm. The metal is modeled as an infinitely thin, perfectly conducting boundary surface on top of a sapphire dielectric substrate (parallel to C-axis: varepsilon_r = 115, tandelta = 86times 10^-5, perpendicular to C-axis: varepsilon_r = 93, tandelta = 30times 10^-5) of 500text μm thickness with the C-axis in the z-direction. This yields a characteristic impedance Z_0 = 5602text Omega for each of the lines [1]. The center-to-center separating distance between the transmission lines on the substrate is 266text μm, which means there is exactly 200text μm of ground plane between them.","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"A visualization of the computational domain is shown below.","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/cpw-1.png\" width=\"60%\" />\n</p><br/>","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"There are two different options for modeling the termination at the ends of the CPW:","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"Lumped port: A multielement uniform lumped port can be used to terminate the CPW by connecting the center conductor to the ground plane on each side with impedance Z = 2Z_0.\nWave port: We can solve a 2D boundary eigenvalue problem for the mode shape and propagation constants for the characteristic CPW mode, and use this to terminate the transmission line.","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"Views of the mesh boundaries for these two configurations are shown below. In both cases the computational domain is discretized using an unstructured tetrahedral mesh. The mesh files are mesh/cpw_wave_0.msh and mesh/cpw_lumped_0.msh, respectively. In addition, this example includes two mesh files which include the thickness of the metal trace: mesh/cpw_wave.msh and mesh/cpw_lumped.msh.","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/cpw-2.png\" width=\"45%\" />\n  <img src=\"../../assets/examples/cpw-3.png\" width=\"45%\" />\n</p><br/>","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"Likewise, there are two different options for how the system response is calculated over the desired frequency band:","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"Uniform: Sample the frequency band with the full-fidelity model at equally spaced frequencies over the desired range.\nAdaptive: Use the full-fidelity model to sample the solution at a few adaptively selected frequency points in the desired band, and then construct a low-cost surrogate model which is used to compute the response over the entire band.","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"This leads to four possible configurations, for which there are four configuration files in the example directory: cpw_lumped_uniform.json, cpw_lumped_adaptive.json, cpw_wave_uniform.json, and cpw_wave_adaptive.json.","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"The frequency response is computed for the band fin20320text GHz. For the uniform sweep, a step size of Delta f=60text GHz is used, while the adaptive sweep employs a much finer step size Delta f=01text GHz. Additionally both sweeps have an explicit sample placed at 170text GHz. The adaptive fast frequency sweep algorithm is given a tolerance of 1times10^-3 for choosing the sampling points; the simulation with uniform ports uses 9 frequency samples and that with wave ports uses 10. Despite the much finer frequency resolution, the adaptive frequency sweep simulations take roughly the same amount of time as the uniform ones where the resulting resolution is worse by a factor of 20. Lastly, for all simulations, a second-order finite element approximation for the solution is used.","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"The results from the four different simulations are presented in the plots below. Note that here, textdB means 20log_10(S_ij):","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/cpw-p2-11.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cpw-p2-21.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cpw-p2-31.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cpw-p2-41.png\" width=\"70%\" />\n</p><br/>","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"The first remark is that in both the lumped port and wave port cases, the adaptive fast frequency sweep results are very close to the true solutions sampled by the uniform sweeps.","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"Second, there is a discrepancy between the results using lumped ports and those with wave ports, namely the lumped port excitation exhibits much higher reflection than for wave ports. This is expected when using a lumped port to approximate the termination of a CPW, and refining the mesh or increasing the order of the solution approximation leads to less reflection. See below for the results with again p = 4 for the order of the solution space, effectively doubling the spatial resolution from p = 2. For the adaptive solver in these plots, we have also reduced the adaptive tolerance to 1times10^-5 due to the small value of S_41.","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/cpw-p4-11.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cpw-p4-21.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cpw-p4-31.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cpw-p4-41.png\" width=\"70%\" />\n</p><br/>","category":"page"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"note: Note\nThe examples files for uniform sampling in examples/cpw actually specify excitations on two ports (\"multi-excitation\"). The two excitation are run in sequence during a single palace simulation.","category":"page"},{"location":"examples/cpw/#References","page":"Crosstalk Between Coplanar Waveguides","title":"References","text":"","category":"section"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"[1] H. J. Visser, Antenna Theory and Applications, Wiley, Hoboken, NJ, 2012.","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"guide/postprocessing/#Postprocessing-and-Visualization","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"","category":"section"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"As described in the section Problem Types, each simulation type writes relevant postprocessed scalar quantities to disk in the directory specified by config[\"Problem\"][\"Output\"], including but not limited to computed values like eigenfrequencies, scattering parameters, or lumped element parameters. In addition, each simulation type will write a file called domain-E.csv, which includes information about the electric and magnetic field energies, as well as lumped element energies, for each step of the simulation (eigenmode, frequency, or time step, for examples).","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"Models containing lumped or wave port boundaries or surface current excitations will automatically postprocess quantities related to those boundaries. This is described in Ports and surface currents.","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"The participation ratios for bulk dielectrics and interface dielectric layers can be computed for simulations involving the electric field. For model boundaries, the integrated surface charge or magnetic flux can also be postprocessed. These features are described in Domain postprocessing and in Boundary postprocessing.","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"Additionally, the computed fields can be automatically probed for their vector values at one or more points in space. This probe functionality is also described in Domain postprocessing.","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"Finally, as described further in Visualization, various field quantities on the 3D computational domain as well as 2D domain boundaries and material interfaces are written to disk when requested using the relevant parameters under config[\"Solver\"]. These fields are meant to be visualized with ParaView or GLVis.","category":"page"},{"location":"guide/postprocessing/#Ports-and-surface-currents","page":"Postprocessing and Visualization","title":"Ports and surface currents","text":"","category":"section"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"When lumped ports are present in a model, the lumped port voltages and currents computed for each step of the simulation (eigenmode, frequency, or time step) are written to ASCII files named port-V.csv and port-I.csv, respectively. These files also include the excitation voltage and current corresponding to the incident wave on excited port boundaries.","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"Additionally, when surface current excitations are present, the excitations are written to surface-I.csv.","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"For frequency domain problems, the values output are the complex-valued peak voltages and currents, computed from the field phasors.","category":"page"},{"location":"guide/postprocessing/#Domain-postprocessing","page":"Postprocessing and Visualization","title":"Domain postprocessing","text":"","category":"section"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"Domain postprocessing capabilities are enabled by including objects under config[\"Domains\"][\"Postprocessing\"] in the configuration file. These include:","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"config[\"Domains\"][\"Postprocessing\"][\"Energy\"] : Postprocessess the electric and magnetic field energy inside of a given domain (associated with the specified domain attributes and indexed by the specified integer \"Index\"). These are from the electric and magnetic field solutions and written to the same domain-E.csv file in the specified postprocessing output directory used for the global energies (described above).\nconfig[\"Domains\"][\"Postprocessing\"][\"Probe\"] : Probe the values of the computed electric field and magnetic flux density solutions at specified locations in the computational domain. The availability of the bmE and bmB fields depends on the problem type (for example, for magnetostatic problems, only bmB is output and bmE is not computed, whereas the inverse is true for electrostatics). For each computed field, the postprocessed values are written to probe-E.csv and probe-B.csv in the specified output directory.","category":"page"},{"location":"guide/postprocessing/#Boundary-postprocessing","page":"Postprocessing and Visualization","title":"Boundary postprocessing","text":"","category":"section"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"Boundary postprocessing capabilities are enabled by including objects under config[\"Boundaries\"][\"Postprocessing\"] in the configuration file. These include:","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"config[\"Boundaries\"][\"Postprocessing\"][\"SurfaceFlux\"] : Postprocess the integrated flux through a surface defined by a list of boundary attributes. Electric, magnetic, and power flux are all supported. Surface capacitance can be computed by dividing the computed electric flux by the excitation voltage, while inductance can be computed by dividing the computed magnetic flux by the excitation current. The resulting fluxes are written to surface-F.csv in the specified output directory.\nconfig[\"Boundaries\"][\"Postprocessing\"][\"Dielectric\"] : Postprocesses interface dielectric loss at surfaces of the model by specifying the interface thickness, permittivity, and loss tangent. See the Bulk and interface dielectric loss section of the reference, or https://arxiv.org/pdf/1509.01854.pdf or https://aip.scitation.org/doi/10.1063/1.3637047 for more information. The participation ratios and associated quality factors are written to the file surface-Q.csv in the specified output directory.","category":"page"},{"location":"guide/postprocessing/#Visualization","page":"Postprocessing and Visualization","title":"Visualization","text":"","category":"section"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"When specified in the configuration file, the electric field and magnetic flux density solutions are written to disk for 3D visualization with ParaView or GLVis. Various other postprocessed fields are also written to the ParaView or grid function (GLVis) database as available, including electric and magnetic energy density, surface currents, and charge density. These files are found in the paraview/ or gridfunction/ directories located in the output directory specified under config[\"Problem\"][\"Output\"]. The output formats are specified in config[\"Problem\"][\"OutputFormats\"].","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"ParaView is recommended to visualize large simulations in parallel. The grid function (GLVis) format can be useful to embed visualizations in webpages with its Javascript version.","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"All fields are written out as nondimensionalized quantities. The specific quantities available varies by simulation type, but the variable names for various possible postprocessed scalar and vector are:","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"Electric field: E, E_real, and E_imag\nMagnetic flux density: B, B_real, and B_imag\nElectric potential: V\nMagnetic vector potential : A, A_real, and A_imag\nElectric energy density : U_e\nMagnetic energy density : U_m\nPoynting vector: S","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"Also, at the final step of the simulation the following element-wise quantities are written for visualization:","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"Mesh partitioning (1-based): Rank\nError indicator: Indicator","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"When saving fields in the grid function (GLVis) format, the file names have the format Field_xxxxxx.gf.yyyyyy where Field is the variable name of the postprocessed scalar or vector field, xxxxxx is the six-digit index of the terminal index (electrostatic or magnetostatic), time step index (transient), or frequency index (driven or eigenmode), and yyyyyy is the six-digit index of the rank of the corresponding MPI process.","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"In addition to the full 3D fields, a ParaView data collection for the boundary mesh and fields is also written to disk. The boundary mesh includes all surfaces with prescribed boundary conditions as well as any material interfaces in the computational domain. It is located in the same paraview/ directory, with suffix _boundary. The boundary data collection is only available for the ParaView output format.","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"The boundary data collection includes the 3D field values sampled on the boundary mesh as well as:","category":"page"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"Surface charge density: Q_s, Q_s_real, Q_s_imag\nSurface current density: J_s, J_s_real, J_s_imag","category":"page"},{"location":"guide/postprocessing/#Adaptive-mesh-refinement","page":"Postprocessing and Visualization","title":"Adaptive mesh refinement","text":"","category":"section"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"At the start of an adaptive mesh refinement (AMR) iteration, if config[\"Model\"][\"Refinement\"][\"SaveAdaptIterations\"] is enabled, the postprocessing results from the solve on the previous mesh will be saved off within a subdirectory denoted iterationX, where X is the (1-based) iteration number. The results in the top level directory will always be those from the most recent successful solve.","category":"page"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"run/#Running-*Palace*","page":"Running Palace","title":"Running Palace","text":"","category":"section"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"Once installed into a directory <INSTALL_DIR>, a parallel simulation using Palace can be started with the following command:","category":"page"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"<INSTALL_DIR>/bin/palace -np <NUM_PROCS> config.json","category":"page"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"where","category":"page"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"The installed palace script wraps a call to the desired MPI launcher (mpirun by default).\n<NUM_PROCS> is the number of MPI processes to use for the simulation.\nconfig.json is the JSON format configuration file used to specify the simulation parameters. The structure of this configuration file is outlined in detail in the section Configuration File.","category":"page"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"A full list of available script options is available using the -h or --help flag.","category":"page"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"During the course of a simulation, the solver will write a number of useful statistics and logging information to standard output. It is often helpful to save this information to a file, for example with:","category":"page"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"<INSTALL_DIR>/bin/palace ... | tee log.out","category":"page"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"Of course, the interested user can explicitly run the Palace binary in parallel, supplying options directly to their MPI launcher of choice, as:","category":"page"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"<MPI_RUN> [OPTIONS] <INSTALL_DIR>/bin/palace-<ARCH>.bin config.json","category":"page"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"where <MPI_RUN> is the MPI launcher command, [OPTIONS] is a list of command line options passed to the MPI launcher, and <ARCH> is the machine architecture (x86_64 or arm64).","category":"page"},{"location":"run/#Singularity/Apptainer","page":"Running Palace","title":"Singularity/Apptainer","text":"","category":"section"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"Assuming Palace was built using Singularity/Apptainer to palace.sif, running:","category":"page"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"singularity run palace.sif <ARGS...>","category":"page"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"corresponds to running a Palace simulation with command line arguments <ARGS...> using:","category":"page"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"<INSTALL_DIR>/bin/palace <ARGS...>","category":"page"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"as described above.","category":"page"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"guide/problem/#Problem-Types","page":"Problem Types","title":"Problem Types","text":"","category":"section"},{"location":"guide/problem/#Eigenmode-problems","page":"Problem Types","title":"Eigenmode problems","text":"","category":"section"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"For eigenmode simulations, config[\"Problem\"][\"Type\"]: \"Eigenmode\", the user should specify a nonzero (but arbitrarily small) frequency above which to search for eigenmodes. The computed eigenvalues are written to an ASCII file named eig.csv, in the directory specified by config[\"Problem\"][\"Output\"]. Also in this file are the mode quality factors and errors (absolute and backward) computed for each eigenpair.","category":"page"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"Calculations related to energy-participation ratio (EPR) quantization can be performed with Palace when the user specifies lumped ports corresponding to the linearized lumped circuit elements in the model. In this case, the participation matrix for inductive elements is automatically generated for the specified number of modes and number of inductive lumped ports. The participation matrix is output in an ASCII file named port-EPR.csv.","category":"page"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"The EPR framework can be used to characterize the dissipative elements in the model as well. In particular, lumped ports with nonzero resistance in the model will trigger coupling rate and quality factor calculations based on input-output (I-O) line coupling loss: By specifying resistive lumped ports in the model, the mode coupling quality factors will be computed as Q_ml = omega_mkappa_ml. The output file port-Q.csv will be created in the output directory containing these mode quality factor contributions. For bulk and interface dielectric loss calculations, which are not unique to the eigenmode simulation type, see the sections Domain postprocessing and Boundary postprocessing of this guide.","category":"page"},{"location":"guide/problem/#Driven-problems-in-the-frequency-domain","page":"Problem Types","title":"Driven problems in the frequency domain","text":"","category":"section"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"For frequency domain driven simulations, config[\"Problem\"][\"Type\"]: \"Driven\", the model is excited by a time harmonic incident field (port boundary) or surface current. The user can specify a port excitation using lumped ports or numeric wave ports.","category":"page"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"The default frequency sweep behavior for frequency domain driven simulations is to perform a uniform sampling from the minimum to the maximum specified frequency of interest, using the user specified step size. An adaptive fast frequency sweep strategy can also be used, activated by specifying a nonzero value for \"AdaptiveTol\" under the config[\"Solver\"][\"Driven\"] object. In this case, using the high-dimensional model solution computed at a few automatically selected frequency samples, a low-cost model is constructed and used to compute the frequency response over the entire frequency range of interest. The specified error tolerance ensures that the approximate low-cost model is reliably accurate relative to the high-dimensional model within the frequency band of interest. This is particularly useful for fine-resolution sweeps containing many sample points, where it can yield a significant speedup over the default strategy.","category":"page"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"Port scattering parameters, or S-parameters, are postprocessed for the column of the scattering matrix corresponding to the driven port index automatically for this simulation type and stored in an ASCII file named port-S.csv, in the directory specified by config[\"Problem\"][\"Output\"]. Both the textdB magnitude (20log_10(S_ij)) and the phase angle(S_ij) (in degrees) are written to the file. In the case that more than a single lumped or wave port is excited or surface current excitations are used, scattering parameter output will be disabled for the simulation (though other quantities of interest are still postprocessed). When lumped ports are present, the peak complex lumped port voltages and currents computed for each excitation frequency are written to ASCII files named port-V.csv and port-I.csv, respectively, Additionally, the surface current excitations are written to surface-I.csv.","category":"page"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"It is often the case that a user wants to compute the entire scattering matrix rather than just a single column. In this case, each column can be computed in parallel by running Palace multiple times. For example, consider the following short Python code which modifies a base configuration file config.json to generate a complete 4x4 scattering matrix by running 4 Palace simulations, each with 2 MPI processes:","category":"page"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"import json\nimport os\nimport subprocess\n\n# Base configuration file\nconfig_path = \"config.json\"\n\nfor i in range(4):\n    # Prepare configuration file for simulation\n    with open(config_path, \"r\") as f:\n        config_json = json.loads(f.read())\n    for port in config_json[\"Boundaries\"][\"LumpedPort\"]:\n        port[\"Excitation\"] = (1+i == port[\"Index\"])\n\n    # Write new config file\n    config_path_i = os.path.splitext(config_path)[0] + f\"-{1+i}.json\"\n    with open(config_path_i, \"w\") as f:\n        f.write(json.dumps(config_json))\n\n    # Run Palace simulation (alternatively, use Popen and wait)\n    subprocess.run([\"palace\", \"-np\", 2, config_path_i])","category":"page"},{"location":"guide/problem/#Driven-problems-in-the-time-domain","page":"Problem Types","title":"Driven problems in the time domain","text":"","category":"section"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"The previous simulation types describe simulations based on frequency domain formulations of Maxwell's equations. Time domain simulations are also possible through the transient simulation type: config[\"Problem\"][\"Type\"]: \"Transient\".","category":"page"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"Similar to the driven simulation type in the frequency domain, transient simulations involve simulating the response of the system to a time-dependent excitation field specified at lumped ports or surface current excitations in the model. The system is always started from rest with zero initial conditions and time-integrated for a user specified duration, given in nanoseconds. There are several available excitation types which define the time dependence of the pulse or excitation waveform. These are specified under the config[\"Solver\"][\"Transient\"] object using the \"Excitation\" keyword.","category":"page"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"The time histories of the lumped port voltages and currents are postprocessed and automatically written to ASCII files named port-V.csv and port-I.csv, respectively, in the directory specified by config[\"Problem\"][\"Output\"]. Additionally, surface current excitation time histories are written to surface-I.csv.","category":"page"},{"location":"guide/problem/#Electrostatic-problems","page":"Problem Types","title":"Electrostatic problems","text":"","category":"section"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"For electrostatic simulations, (config[\"Problem\"][\"Type\"]: \"Electrostatic\", the user should specify a number of terminal boundaries (config[\"Boundaries\"][\"Terminal\"]) as well as boundaries which are grounded (config[\"Boundaries\"][\"Ground\"]). For each terminal, an electrostatic field is computed by assigning the terminal of interest a positive unit voltage and all other terminals and grounded boundaries a zero voltage. The resulting fields are then used to compute the Maxwell capacitance matrix and its inverse, which are written to an ASCII file named terminal-C.csv and terminal-Cinv.csv, respectively, in the directory specified by config[\"Problem\"][\"Output\"]. The mutual capacitance matrix is also computed and written to terminal-Cm.csv in the same directory.","category":"page"},{"location":"guide/problem/#Magnetostatic-problems","page":"Problem Types","title":"Magnetostatic problems","text":"","category":"section"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"For magnetostatic simulations, (config[\"Problem\"][\"Type\"]: \"Magnetostatic\", the user should specify a number of source current boundaries. For each current source, a magnetostatic field is computed by applying a unit current to the source index of interest, leaving all other sources open with no excitation. Surfaces which are expected to carry current should be labeled as perfectly conducting, which prescibes a zero magnetic flux, or magnetic insulation, boundary condition. The resulting fields are used to compute the inductance matrix and its inverse, which are written to an ASCII file named terminal-M.csv and terminal-Minv.csv, respectively, in the directory specified by config[\"Problem\"][\"Output\"]. A \"mutual\" inductance matrix which has the same form as the mutual capacitance matrix (its entries are based on current differences between ports rather than absolute currents) is computed and written to terminal-Mm.csv in the same directory.","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"developer/notes/#Developer-Notes","page":"Developer Notes","title":"Developer Notes","text":"","category":"section"},{"location":"developer/notes/#Style-guide","page":"Developer Notes","title":"Style guide","text":"","category":"section"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"Automated source code formatting is performed using clang-format. Run:","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"./scripts/format_source","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"in the repository root directory to automatically use clang-format to format C++ source as well as JuliaFormatter.jl for Julia and Markdown files. The script can be viewed in the repository.","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"The following conventions also apply:","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"PascalCase for classes and function names.\nFollow 'include what you use' (IWYU), with the include order dictated by the Google C++ Style Guide. This order should be automatically enforced by the clang-format style file.\nCode comments should be full sentences, with punctuation. At this time, no Doxygen API reference is generated and so comments generally do not need to conform to Doxygen syntax.","category":"page"},{"location":"developer/notes/#Static-analysis","page":"Developer Notes","title":"Static analysis","text":"","category":"section"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"During the cmake configuration step, defining the variables ANALYZE_SOURCES_CLANG_TIDY and ANALYZE_SOURCES_CPPCHECK to ON will turn on static analysis using clang-tidy and cppcheck, respectively, during the build step. This requires the executables to be installed and findable by CMake on your system.","category":"page"},{"location":"developer/notes/#Extending-GPU-code-in-*Palace*","page":"Developer Notes","title":"Extending GPU code in Palace","text":"","category":"section"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"Palace supports GPU parallelization, but not all the files in Palace are compiled with a GPU-compatible compiler (e.g., nvcc). The reason for this is that such compilers might not support all the features Palace needs (e.g., support for constexpr std::sqrt), and also because they tend to be slower. The list of files that contains code that has to run on the device is defined by the TARGET_SOURCES_DEVICE CMake variable.","category":"page"},{"location":"developer/notes/#JSON-Schema-for-configuration-files","page":"Developer Notes","title":"JSON Schema for configuration files","text":"","category":"section"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"A JSON format configuration file, for example named config.json, can be validated against the provided Schema using:","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"./scripts/validate_config config.json","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"This script uses Julia's JSONSchema.jl and the Schema provided in scripts/schema/ to parse the configuration file and check that the fields are correctly specified. This script and the associated Schema are also installed and can be accessed in <INSTALL_DIR>/bin.","category":"page"},{"location":"developer/notes/#Timing","page":"Developer Notes","title":"Timing","text":"","category":"section"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"Timing facilities are provided by the Timer and BlockTimer classes.","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"Creating a block as BlockTimer b(idx) where idx is a category like CONSTRUCT, SOLVE, etc. will record time so long as b is in scope; however, timing may be interrupted by creation of another BlockTimer object. It will resume whenever the new block is destroyed. Only one category is timed at once. This enables functions to declare how calls within them are timed without needing to know how timing may be done by the calling function.","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"The BlockTimer implementation relies upon a static member object of the Timer class, which behaves as a stopwatch with some memory functions. It is the responsibility of this BlockTimer::timer object to record time spent in each recorded category. Other Timer objects may be created for local timing purposes, but these will not count toward time reported at the end of a log file or in the metadata JSON.","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"For each Palace simulation, a table of timing statistics is printed out before the program terminates. The minimum, maximum, and average times across all MPI processes are included in the table. Timer categories are exclusive, they do not overlap. The categories for breaking down the total simulation time are:","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"Initialization                  // < Time spent parsing the configuration file,\n                                //   preprocessing and partitioning the mesh\nOperator Construction           // < Time spent constructing finite element spaces and\n                                //   setting up linear and bilinear forms on those spaces\n  Wave Ports                    // < Time spent configuring and computing the modes\n                                //   associated with wave port boundaries\nLinear Solve                    // < Linear solver time\n  Setup                         // < Setup time for linear solver and preconditioner\n  Preconditioner                // < Preconditioner application time for linear solve\n  Coarse Solve                  // < Coarse solve time for geometric multigrid\n                                //   preconditioners\nTime Stepping                   // < Time spent in the time integrator for transient\n                                //   simulation types\nEigenvalue Solve                // < Time spent in the eigenvalue solver (not including\n                                //   linear solves for the spectral transformation, or\n                                //   divergence-free projection)\nDiv.-Free Projection            // < Time spent performing divergence-free projection (used\n                                //   for eigenmode simulations)\nPROM Construction               // < Offline PROM construction time for adaptive fast\n                                //   frequency sweep\nPROM Solve                      // < Online PROM solve and solution prolongation time for\n                                //   adaptive fast frequency sweep\nEstimation                      // < Time spent computing element-wise error estimates\n  Construction                  // < Construction time for error estimation global linear\n                                //   solve\n  Solve                         // < Solve time for error estimation global linear solve\nAdaptation                      // < Time spent performing adaptive mesh refinement (AMR)\n  Rebalancing                   // < Rebalancing time for AMR simulations with rebalancing\nPostprocessing                  // < Time spent in postprocessing once the field solution\n                                //   has been computed\n  Far Fields                    // < Time spent computing surface integrals to extrapolate\n                                //   near fields to far fields\n  Paraview                      // < Processing and writing Paraview fields for visualization\n  Grid function                 // < Processing and writing grid function fields for visualization\nDisk IO                         // < Disk read/write time for loading the mesh file and\n                                //   writing CSV fields\n-----------------------\nTotal                           // < Total simulation time","category":"page"},{"location":"developer/notes/#Profiling-*Palace*-on-CPUs","page":"Developer Notes","title":"Profiling Palace on CPUs","text":"","category":"section"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"A typical Palace simulation spends most of its time in libCEED kernels, which, in turn, executed libsxmm code on CPUs. Libsxmm generates code just-in-time to ensure it is the most performant on the given architecture and for the given problem. This code generation confuses most profilers. Luckily, libsxmm can integrate with the VTune APIs to enable profiling of jitted functions as well.","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"note: Using a different libCEED backend?\nThe following notes assume that you are using the libxsmm backend for libCEED. If this is not the case and you have a preference for other profilers, such as perf or HPCToolkit, you can consider using them as well.","category":"page"},{"location":"developer/notes/#Requirements","page":"Developer Notes","title":"Requirements","text":"","category":"section"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"Verify your system meets the VTune system requirements\nInstall VTune Profiler\nSet VTune's root directory during Palace build (see below)\nUse RelWithDebInfo build type for optimal profiling results","category":"page"},{"location":"developer/notes/#Building-*Palace*-with-VTune-Support","page":"Developer Notes","title":"Building Palace with VTune Support","text":"","category":"section"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"From the Palace root directory:","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"$ source /path/to/vtune-vars.sh # Replace with your VTune installation path\n$ mkdir build && cd build\n$ cmake .. -DCMAKE_BUILD_TYPE=RelWithDebInfo\n$ make -j $(nproc)","category":"page"},{"location":"developer/notes/#Running-a-Basic-Profile","page":"Developer Notes","title":"Running a Basic Profile","text":"","category":"section"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"A flamegraph can be created using either:","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"The VTune graphical user interface\nThe command line interface","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"Follow Intel's official instructions for detailed usage information.","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"Below is a sample flamegraph resulted from profiling the rings example located at /examples/rings/rings.json with polynomial order P=6 (Solver[\"Order\"]: 6).","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/profiling/vtune-flamegraph.png\" width=\"100%\" />\n</p><br/>","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"Note: Set Verbose: 0 in the JSON file to reduce terminal output. For profiling, use the binary executable (build/bin/palace-*.bin) rather than the build/bin/palace wrapper script.","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"For MPI profiling with multiple processes:","category":"page"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"# Run with 10 MPI processes\n$ cd /path/to/palace/examples/rings\n$ mpirun -n 10 -gtool \"vtune -collect hpc-performance --app-working-dir=$(pwd) -result-dir $(pwd)/vtune-mpi:0-9\" /path/to/palace/build/bin/palace-x86_64.bin rings.json\n\n# Open the results from VTune GUI\n$ vtune-gui vtune-mpi.*","category":"page"},{"location":"developer/notes/#Changelog","page":"Developer Notes","title":"Changelog","text":"","category":"section"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"Code contributions should generally be accompanied by an entry in the changelog.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"examples/antenna/#Dipole-Antenna-and-Radiation-Fields","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"","category":"section"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"note: Note\nThe files for this example can be found in the examples/antenna/ directory of the Palace source code. In this example, we increased the number of sampling points from 100 to 86400.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"In this example, we study a half-wave dipole antenna and analyze its radiation characteristics. The dipole antenna is one of the most fundamental antenna types, consisting of two conducting elements of length L fed at the center by a sinusoidal excitation.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"For an infinitely thin half-wave dipole, the problem can be solved analytically and the solution serves as our reference for validation [1]. In the wave-zone, the operating wavelength in free space lambda is twice the total length of the antenna (lambda = 2 times 2L = 4L). The normalized field pattern on the E-plane (xz-plane) is given by","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"E(theta) = leftfraccosleft(fracpi2costhetaright)sinthetaright","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"while the pattern is isotropic on the H-plane (xy-plane).","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"We will model a dipole antenna with arm length L and finite radius a, solve a driven problem at the resonant frequency lambda = 4L and extract the radiation pattern P(theta) with Palace's far-field extraction capabilities).","category":"page"},{"location":"examples/antenna/#Problem-Setup","page":"Dipole Antenna and Radiation Fields","title":"Problem Setup","text":"","category":"section"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"The dipole is modeled as two thin infinitely conductive cylindrical wires with length L = 1text m and radius a = L20 = 5text cm, separated by a thin cylindrical gap of height h = L100 = 1text cm. Given these geometrical characteristics, the operating wavelength is approximately lambda = 4text m, corresponding to a frequency of nu = c  lambda = 00749text GHz.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"The gap serves as the excitation point for the antenna. Rather than explicitly modeling the feeding circuit, we place a flat rectangular strip on the xz-plane that connects the two arms of the antenna. This strip functions as a lumped port to excite the system.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"The surrounding medium is free space. In reality, electromagnetic waves would propagate freely to infinity. We model this by enclosing the antenna in a sphere of radius r_max = 15lambda = 6text m centered at the origin and applying appropriate boundary conditions to simulate the infinite domain.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"The mesh is generated using Gmsh and consists of tetrahedral elements with appropriate refinement near the antenna structure. The element size increases with distance from the antenna, but is capped to ensure the wavelength is resolved by at least a few elements per wavelength. The mesh file is mesh/antenna.msh and is generated using the Julia script mesh/mesh.jl.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"A visualization of the model and the resulting mesh is shown below.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/antenna-1.png\" width=\"45%\" />\n  <img src=\"../../assets/examples/antenna-2.png\" width=\"45%\" />\n</p><br/>","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"The left image shows the outer domain and the inner antenna structure. The right image provides a close-up view of the gap region, where the rectangular port is aligned on the xz-plane and spans the diameter of the cylindrical conductors.","category":"page"},{"location":"examples/antenna/#Configuration-File","page":"Dipole Antenna and Radiation Fields","title":"Configuration File","text":"","category":"section"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"The configuration file for the Palace simulation is found in antenna.json. The simulation is performed in the frequency domain using the \"Driven\" solver type, operating at a single frequency of 00749text GHz.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"Since we assume the metallic rods are perfect conductors, we impose perfect electric conductor (PEC) boundary conditions on their surfaces. To prevent reflections of electromagnetic waves back into the computational domain, we apply \"Absorbing\" boundary conditions on the outer spherical boundary.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"The antenna is driven using the rectangular strip as a lumped port. This port lies entirely in the xz-plane, and by setting \"Direction\": \"+Z\" and \"Excitation\": true, we impose an electric field aligned in the z-direction across the gap.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"We use the far-field extraction feature in Palace to extract electric fields at infinity. To do so, we add a \"PostProcessing\" section under \"Boundaries\" with the same Attributes as the surface with \"Absorbing\" boundary conditions and we choose a positive value for \"NSample\". A NSample of 64800 means that the far-field sphere is uniformly discretized with resolution of one degree on the equator (to preserve the uniform distribution, the resolution changes as one moves towards the poles).","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"tip: ComplexCoarseSolve solver optimization\nThis simulation benefits from the \"ComplexCoarseSolve\" option. This setting uses a complex preconditioner of the form P = [Ar, -Ai; Ai, Ar] rather than the default P = Ar + Ai, where A is the true system matrix with real and imaginary  parts Ar and Ai. While the resulting system is four times larger, it preserves the coupling between real and imaginary parts which can be significant for problems with strong imaginary components. For this particular problem, this approach accelerates convergence by several factors, though at the cost of increased memory usage.","category":"page"},{"location":"examples/antenna/#Analysis-and-Results","page":"Dipole Antenna and Radiation Fields","title":"Analysis and Results","text":"","category":"section"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"The simulation requires approximately 6 GBs of RAM and completes in a few minutes (depending on the hardware). The simulation produces a 160 MB postpro folder, which contains the electromagnetic fields that we will use to extract radiation patterns.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"First, let us look at the far-field output. The postpro folder contains a file, farfield-rE.csv, with the far-field electric fields for the all the target frequencies (in this case, only 7.49000000e-02 GHz). The first few lines of this file are:","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"include_example_file(\"antenna\", \"farfield-rE.csv\") #hide","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"The plot_farfield.jl Julia script processes this file and produces plots polar for the E- and H- planes (xz/xy-planes) and in the 3D.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"julia --project plot_radiation_pattern.jl postpro/farfield-rE.csv","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"The results for the polar plot are shown below.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/antenna-3.png\" width=\"100%\" />\n</p><br/>","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"On the H-plane, we see the expected isotropic emission pattern for any of the extracted radii. On the E-plane, we see agreement with the characteristic figure-eight pattern of a dipole antenna, with maximum radiation perpendicular to the antenna axis and nulls approximately along the antenna axis.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"note: Do your results look different?\nIf you are trying to reproduce this plot, but find that your plots are not as nice as the one above, you might have a missed a note at the top of this page: the example was run with 64800 sampling points instead of the 100 that the JSON file specifies. Change NSample to 64800 and run your simulation again.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"We can see the same pattern rendered in 3D as well","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/antenna-4.png\" width=\"80%\" />\n</p><br/>","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"This plot shows the 3D relative antenna pattern representing the normalized strength of the electric field as function of the distance from the origin. Once again, we see the expected donut shape, with maximal electric field strength on the equator, and minimum along the z axis.","category":"page"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"note: Running the Julia script\nThe plot_radiation_pattern.jl requires a number of Julia packages (including the plotting library). The simplest way to ensure that you have all the required packages is to use the Project.toml included with the examples. To install this enviroment, navigate to the examples folder and runjulia --project -e 'using Pkg; Pkg.instantiate();'All the subsequent times, just make sure to start Julia with --project from the examplesfolder or one of its subfolders.","category":"page"},{"location":"examples/antenna/#References","page":"Dipole Antenna and Radiation Fields","title":"References","text":"","category":"section"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"[1] Stutzman, W. L., & Thiele, G. A., Antenna Theory and Design (3rd ed.), John Wiley & Sons, 2012.","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"config/model/#config[\"Model\"]","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"","category":"section"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"Model\":\n{\n    \"Mesh\": <string>\n    \"L0\": <float>,\n    \"Lc\": <float>,\n    \"Refinement\":\n    {\n        ...\n    }\n}","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"with","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"Mesh\" [None] :  Input mesh file path, an absolute path is recommended. If the provided mesh is nonconformal, it is assumed that it comes from a previous Palace solve using AMR, and all mesh preprocessing checks and modifications (for example model[\"Refinement\"][\"CrackInternalBoundaryElements\"]), are skipped .","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"L0\" [1.0e-6] :  Unit, relative to m, for mesh vertex coordinates. For example, a value of 1.0e-6 implies the mesh coordinates are in μm.","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"Lc\" [0.0] :  Characteristic length scale used for nondimensionalization, specified in mesh length units. This keyword should typically not be specified by the user. A value less than or equal to zero uses an internally calculated length scale based on the bounding box of the computational domain. A value of 1.0 will disable nondimensionalization of lengths in the model and all computations will take place in the same units as the mesh.","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"Refinement\" : Top-level object for configuring mesh refinement.","category":"page"},{"location":"config/model/#model[\"Refinement\"]","page":"config[\"Model\"]","title":"model[\"Refinement\"]","text":"","category":"section"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"Refinement\":\n{\n    \"Tol\": <float>,\n    \"MaxIts\": <int>,\n    \"MaxSize\": <int>,\n    \"Nonconformal\": <bool>,\n    \"UpdateFraction\": <float>,\n    \"UniformLevels\": <int>,\n    \"Boxes\":\n    [\n        {\n            \"Levels\": <int>,\n            \"BoundingBoxMin\": [<float array>],\n            \"BoundingBoxMax\": [<float array>]\n        },\n        ...\n    ],\n    \"Spheres\":\n    [\n        {\n            \"Levels\": <int>,\n            \"Center\": [<float array>],\n            \"Radius\": <float>\n        },\n        ...\n    ]\n}","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"with","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"Tol\" [1.0e-2] : Relative error convergence tolerance for adaptive mesh refinement (AMR).","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"MaxIts\" [0] : Maximum number of iterations of AMR to perform.","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"MaxSize\" [0] : The maximum allowable number of degrees of freedom for AMR. If an adapted mesh exceeds this value no further adaptation will occur. A value less than 1 means that no maximum size constraint will be imposed.","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"Nonconformal\" [true] : Chose whether the adaptation should use nonconformal refinement. Nonconformal refinement is required for non-simplex meshes.","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"UpdateFraction\" [0.7] : Dörfler marking fraction used to specify which elements to refine. This marking strategy will mark the smallest number of elements that make up \"UpdateFraction\" of the total error in the mesh. A larger value will refine more elements per iteration, at the cost of the final mesh being less efficient.","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"UniformLevels\" [0] :  Levels of uniform parallel mesh refinement to be performed on the input mesh. If not performing AMR, these may be used as levels within a geometric multigrid scheme. If performing AMR the most refined mesh is used as the initial mesh and the coarser meshes cannot be used in a geometric multigrid scheme.","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"Boxes\" :  Array of box region refinement objects. All elements with a node inside the box region will be marked for refinement.","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"Spheres\" :  Array of sphere region refinement objects. All elements with a node inside the sphere region will be marked for refinement.","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"Levels\" [0] : Levels of parallel mesh refinement inside the specified refinement region.","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"BoundingBoxMin\" [None] : Floating point array of length equal to the model spatial dimension specfiying the minimum coordinates of the axis-aligned bounding box for this refinement region. Specified in mesh length units.","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"BoundingBoxMax\" [None] : Floating point array of length equal to the model spatial dimension specfiying the maximum coordinates of the axis-aligned bounding box for this refinement region. Specified in mesh length units.","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"Center\" [None] : Floating point array of length equal to the model spatial dimension specfiying the center coordinates of the sphere for this sphere refinement region. Specified in mesh length units.","category":"page"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"Radius\" [None] : The radius of the sphere for this sphere refinement region, specified in mesh length units.","category":"page"},{"location":"config/model/#Advanced-model-options","page":"config[\"Model\"]","title":"Advanced model options","text":"","category":"section"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"RemoveCurvature\" [false]\n\"MakeSimplex\" [false]\n\"MakeHexahedral\" [false]\n\"ReorderElements\" [false]\n\"CleanUnusedElements\" [true]\n\"CrackInternalBoundaryElements\" [true]\n\"RefineCrackElements\" [true]\n\"CrackDisplacementFactor\" [1.0e-12]\n\"AddInterfaceBoundaryElements\" [true]\n\"ExportPrerefinedMesh\" [false]\n\"ReorientTetMesh\" [false]\n\"Partitioning\" [\"\"]\n\"MaxNCLevels\" [1]\n\"MaximumImbalance\" [1.1]\n\"SaveAdaptIterations\" [true]\n\"SaveAdaptMesh\" [false]\n\"SerialUniformLevels\" [0]","category":"page"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"guide/boundaries/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"guide/boundaries/#Perfect-electric-conductor-(PEC)-boundary","page":"Boundary Conditions","title":"Perfect electric conductor (PEC) boundary","text":"","category":"section"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"The perfect electric conductor (PEC) boundary condition (zero tangential electric field) is specified using the \"PEC\" boundary keyword under config[\"Boundaries\"]. It is a homogeneous Dirichlet boundary condition for the frequency or time domain finite element formulation, as well as the magnetostatic formulation.","category":"page"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"For electrostatic simulations, the homogeneous Dirichlet boundary condition is prescribed using the \"Ground\" boundary keyword which prescribes zero voltage at the boundary.","category":"page"},{"location":"guide/boundaries/#Perfect-magnetic-conductor-(PMC)-boundary","page":"Boundary Conditions","title":"Perfect magnetic conductor (PMC) boundary","text":"","category":"section"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"The perfect magnetic conductor (PMC) boundary condition (zero tangential magnetic field) is a homogeneous Neumann boundary condition for the frequency or time domain finite element formulation, as well as the magnetostatic formulation. It is the natural boundary condition and thus it has the same effect as not specifying any additional boundary condition on external boundary surfaces. It can also be explicitly specified using the \"PMC\" boundary keyword under config[\"Boundaries\"].","category":"page"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Likewise, for electrostatic simulations, the homogeneous Neumann boundary condition implies a zero-charge boundary, and thus zero gradient of the voltage in the direction normal to the boundary. This is specified using the \"ZeroCharge\" boundary keyword under config[\"Boundaries\"].","category":"page"},{"location":"guide/boundaries/#Impedance-boundary","page":"Boundary Conditions","title":"Impedance boundary","text":"","category":"section"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"The impedance boundary condition is a mixed (Robin) boundary condition and is available for the frequency or time domain finite element formulations and thus for eigenmode or frequency or time domain driven simulation types. It is specified using the \"Impedance\" boundary keyword. The surface impedance relating the tangential electric and magnetic fields on the boundary is computed from the parallel impedances due to the specified resistance, inductance, and capacitance per square.","category":"page"},{"location":"guide/boundaries/#Absorbing-(scattering)-boundary","page":"Boundary Conditions","title":"Absorbing (scattering) boundary","text":"","category":"section"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Absorbing boundary conditions at farfield boundaries, also referred to as scattering boundary conditions, can be applied using the \"Absorbing\" boundary keyword under config[\"Boundaries\"]. The first-order absorbing boundary condition is a special case of the above impedance boundary and is available for eigenmode or frequency or time domain driven simulation types. The second-order absorbing boundary condition is only available for frequency domain driven and eigenmode simulations.","category":"page"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Perfectly matched layer (PML) boundaries for frequency and time domain electromagnetic formulations are not yet implemented, but are common in solvers for computational electromagnetics and will be a useful addition.","category":"page"},{"location":"guide/boundaries/#Finite-conductivity-boundary","page":"Boundary Conditions","title":"Finite conductivity boundary","text":"","category":"section"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"A finite conductivity boundary condition can be specified using the \"Conductivity\" boundary keyword. This boundary condition models the effect of a boundary with non-infinite conductivity (an imperfect conductor) for conductors with thickness much larger than the skin depth. It is available only for frequency domain driven and eigenmode simulations. For more information see the Other boundary conditions section of the reference.","category":"page"},{"location":"guide/boundaries/#Periodic-boundary","page":"Boundary Conditions","title":"Periodic boundary","text":"","category":"section"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Periodic boundary conditions on an existing mesh can be specified using the \"Periodic\" boundary keyword. This boundary condition enforces that the solution on the specified boundaries be exactly equal, and requires that the surface meshes on the donor and receiver boundaries be identical up to translation or rotation. Periodicity in Palace is also supported through meshes generated incorporating periodicity as part of the meshing process.","category":"page"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Palace also supports Floquet periodic boundary conditions, where a phase shift is imposed between the fields on the donor and receiver boundaries. The phase shift is e^-i bmk_p cdot (bmx_textrmreceiver-bmx_textrmdonor), where bmk_p is the Floquet wave vector and bmx is the position vector. See Floquet periodic boundary conditions for implementation details.","category":"page"},{"location":"guide/boundaries/#Lumped-and-wave-port-excitation","page":"Boundary Conditions","title":"Lumped and wave port excitation","text":"","category":"section"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"config[\"Boundaries\"][\"LumpedPort\"] : A lumped port applies a similar boundary condition to a surface impedance boundary, but takes on a special meaning for each simulation type.\nFor frequency domain driven simulations, ports are used to provide a lumped port excitation and postprocess voltages, currents, and scattering parameters. Likewise, for transient simulations, they perform a similar purpose but for time domain computed quantities.\nFor eigenmode simulations where there is no excitation, lumped ports are used to specify properties and postprocess energy-participation ratios (EPRs) corresponding to linearized circuit elements.\nNote that a single lumped port (given by a single integer \"Index\") can be made up of multiple boundary attributes in the mesh in order to model, for example, a multielement lumped port. To use this functionality, use the \"Elements\" object under \"LumpedPort\".\nconfig[\"Boundaries\"][\"WavePort\"] : Numeric wave ports are available for frequency domain driven and eigenmode simulations. In this case, a port boundary condition is applied with an optional excitation using a modal field shape which is computed by solving a 2D boundary mode eigenproblem on each wave port boundary. This allows for more accurate scattering parameter calculations when modeling waveguides or transmission lines with arbitrary cross sections.\nThe 2D wave port eigenproblem only supports PEC and PMC boundary conditions. Boundaries that are specified as \"PEC\" or \"Conductivity\" in the full 3D model and intersect the wave port boundary will be considered as PEC in the 2D boundary mode analysis, as well as any additional boundary attributes given under \"WavePortPEC\". [config[\"Boundaries\"][\"WavePortPEC\"](../config/boundaries.md#boundaries%5B%22WavePortPEC%22%5D) allows to assign non-PEC attributes from the 3D model (e.g. impedance or absorbing boundary conditions) as a PEC boundary condition for the 2D wave port solve. In addition, boundaries of wave ports other than the wave port currently being considered, in the case wave ports are touching and share one or more edges, are also considered as PEC for the wave port boundary mode analysis. Boundaries of the wave port not labeled with a \"PEC\", \"Conductivity\", \"WavePortPEC\", or \"WavePort\" condition have the natural boundary condition of zero tangential magnetic field (PMC) prescribed for the purpose of port mode calculation.\nUnlike lumped ports, wave port boundaries cannot be defined internal to the computational domain and instead must exist only on the outer boundary of the domain (they are to be \"one-sided\" in the sense that mesh elements only exist on one side of the boundary).","category":"page"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"For each port, the excitation is normalized to have unit incident power over the port boundary surface.","category":"page"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"The presence of an incident excitation at a port is controlled by the settings config[\"Boundaries\"][\"LumpedPort\"][][\"Excitation\"] and config[\"WavePort\"][][\"Excitation\"]. The Excitation settings can either be specified as non-negative integers or booleans.","category":"page"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"Boolean setting: true/false indicates the presence / absence of an incident excitation. Usually, only a single port will be marked as excited. In that case, the \"Excitation\" will promoted to the port \"Index\". If there are multiple excited ports, the \"Excitation\" is 1.\nInteger setting: Here the user manually assigns excitation indices to ports. The value 0 corresponds to no excitation. A positive integer i means that port is excited during excitation i. If multiple ports share an excitation index i, they will be excited at the same time. In the special, but common, case that each excitation consists of only a single port, the port index and excitation index must be equal. This avoids ambiguity in the scattering matrix.","category":"page"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"For frequency domain driven simulations only, it is possible to specify multiple excitations in the same simulation using different positive integers (\"multi-excitation\"). These excitations are simulated consecutively during the Palace run. The results are printed to shared csv files. When there are multiple excitations, the columns of the csv files are post-indexed by the excitation index (e.g. Φ_elec[1][5] (C) denoting the flux through surface 1 of excitation 5). Note that a port can only be part of one excitation.","category":"page"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"warning: Indexing\nAny \"Index\" of \"LumpedPort\", \"WavePort\", \"SurfaceCurrent\", or \"Terminal\" must be unique, including between different boundary conditions types (e.g. you can not have an lumped port and wave port both with Index: 5).","category":"page"},{"location":"guide/boundaries/#Surface-current-excitation","page":"Boundary Conditions","title":"Surface current excitation","text":"","category":"section"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"An alternative source excitation to lumped or wave ports for frequency and time domain driven simulations is a surface current excitation, specified under config[\"Boundaries\"][\"SurfaceCurrent\"]. This is the excitation used for magnetostatic simulation types as well. This option prescribes a unit source surface current excitation on the given boundary in order to excite the model. It does does not prescribe any boundary condition to the model and only affects the source term on the right hand side.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"developer/testing/#Testing","page":"Testing","title":"Testing","text":"","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Palace comes with two types of tests:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Unit tests in test/unit/ test individual components in isolation\nRegression tests in test/examples/ compare code output against saved references","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Both types of tests are run automatically as part of the project's continuous integration (CI) workflows.","category":"page"},{"location":"developer/testing/#Building-and-running-unit-tests","page":"Testing","title":"Building and running unit tests","text":"","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"The simplest way to build unit tests is using CMake.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"First, follow the quick start to build Palace with CMake. From the Palace root directory:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"mkdir build && cd build\ncmake -DPALACE_MFEM_USE_EXCEPTIONS=yes ..\nmake -j $(nproc) palace-tests","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"The PALACE_MFEM_USE_EXCEPTIONS option is necessary to properly capture and test assertions. If you want to also measure test coverage, turn PALACE_BUILD_WITH_COVERAGE on. See Unit test coverage for more details on this.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Once the build completes, you can run tests in two ways:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Using CTest (recommended for running all tests): Automatically runs all test categories in parallel with proper environment setup\nUsing the test executable directly: Provides fine-grained control over which tests run using Catch2's filtering syntax","category":"page"},{"location":"developer/testing/#Running-tests-with-CTest","page":"Testing","title":"Running tests with CTest","text":"","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"CTest provides automated test execution with parallel support and proper categorization:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"cd palace-build\nctest","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"This discovers and runs all registered tests. CTest automatically:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Runs serial tests with a single process\nRuns MPI tests with 2 processes\nRuns GPU tests with proper device configuration\nPrevents concurrent execution of tests that require exclusive resources","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"To see all the tests available, call:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"ctest -N","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"This will print something like:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Test project palace/build\n  Test  #1: serial-Config Boundary Ports\n  Test  #2: serial-Config Driven Solver\n  Test  #3: serial-FarField\n  Test  #4: serial-EM Constant Check\n  ....","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"If you want to run all tests in parallel (e.g., with 8 processes):","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"ctest -j8 --output-on-failure","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"CTest will schedule execution of tests trying to use all the 8 processes. In this, CTest handles MPI processes correctly, and ensures that only one GPU test is being run at the time. If you compiled Palace, the total number of processes that could end up used in this example is 8 * OMP_NUM_THREADS.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"If you run specific tests categories, you can use regex matching, for example","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"ctest -R mpi-            # Run only MPI tests\nctest -R postoperator    # Run tests with postoperator in the name","category":"page"},{"location":"developer/testing/#Running-tests-directly-with-the-executable","page":"Testing","title":"Running tests directly with the executable","text":"","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"CTest is powerful, but sometimes we want to have more direct control of how the tests are being run. When this happens, we can use directly the unit-tests executable.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"To run all the Serial tests (including the benchmarks):","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"palace-build/test/unit/unit-tests","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"This runs all Serial tests. For Parallel tests:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"mpirun -np 2 palace-build/test/unit/unit-tests","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"For GPU tests:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"palace-build/test/unit/unit-tests --device cuda","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"You can use Catch2 filters to run specific subsets:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"palace-build/test/unit/unit-tests [vector]              # Tests tagged [vector]\npalace-build/test/unit/unit-tests \"Vector Sum - Real\"   # Specific test by name\npalace-build/test/unit/unit-tests [^postoperator]       # Tests not tagged with [postoperator]","category":"page"},{"location":"developer/testing/#Benchmarks","page":"Testing","title":"Benchmarks","text":"","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"The unit test application also includes a small number of benchmarks to compare performance between MFEM's legacy assembly backend, MFEM's partial assembly backend, and the specified libCEED backend (specified with the --backend option, use -h/--help to list all command line options for the unit-tests executable). These can be run using, for example:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"palace-build/test/unit/unit-tests \"[Benchmark]\" --benchmark-samples 10","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"These benchmarks can be accelerated using MPI and/or OpenMP parallelism (when configured with PALACE_WITH_OPENMP=ON), but in all cases they are only testing the local operator assembly on each process.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"CTest skips all the benchmarks.","category":"page"},{"location":"developer/testing/#Adding-unit-tests","page":"Testing","title":"Adding unit tests","text":"","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Palace uses Catch2 for unit testing. Refer to the Catch2 documentation for detailed usage information. If you have never added a test to Palace, start by reading our tutorial on adding a new unit test.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"The most important Catch2 feature  in the Palace test suite is tags. When creating a test, you provide a name and a series of tags","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"TEST_CASE(\"My name\", \"[MyFirstTag][MyOtherTag][Serial]\"){ ... }","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Catch2 tags are typically used for filtering tests. Palace defines four special tags that control when tests execute based on the runtime environment:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"[Serial] tests run only with a single MPI process. Use this for tests that verify single-process behavior.\n[Parallel] tests run only when multiple MPI processes are available. Use this for tests that verify MPI operations, distributed computations, or inter-process communication.\n[GPU] tests run only when GPU devices are available. Use this for tests that are meaningful and interesting on GPU hardware.\n[NoConcurrent] tests run serially without any other tests executing simultaneously. Use this for tests that modify shared resources or have timing-sensitive behavior that could be affected by concurrent execution.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"These tags are inclusive, meaning that a test can be marked with multiple special tags, if the test is meaningful in different contexts (e.g., if a test supports CPU and GPU implementation at the same time). For example, [Serial][Parallel][GPU] indicates a test that should run in every case.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"warning: Warning\nTests without any of our special tags will never execute. Make sure to add at least one.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"note: Tests should use tags for which the test is meaningful\nConsider testing this code:int a = 1, b = 2;\nAssert(a + b == 3);This test will pass if run with MPI, but this is uninteresting since every MPI process executes the same code that the Serial test would run (same with GPUs). Therefore, this test should only be marked as [Serial].","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"note: Try improving your test instead of relying on `[NoConcurrent]`\n[NoConcurrent] serializes tests to ensure that shared resources are not being used/modified at the same time. Sometimes, this is needed (e.g., you have tests that require large amounts of memory, or that talk through a socket to a GLVis server). Often times, howoever, it is possible to modify the test to remove potential race conditions and ensure isolation. A common case where you might be using shared resources is file-system operations. For that, you can create and destory temporary directories. TempDirFixture in test-fixtures.hpp helps you with that.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"For the other tags, we recommend grouping related tests using descriptive tag names like [vector] or [materialoperator] (typically named after files or classes). This enables effective filtering, as described in Building and running unit tests.","category":"page"},{"location":"developer/testing/#Test-configuration","page":"Testing","title":"Test configuration","text":"","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"The CMakeLists.txt in test/unit/ contains important settings:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"The list of files compiled as part of the tests\nThe list of files that need to be compiled with a GPU compiler (TARGET_SOURCES_DEVICE)\nPath variables used in tests, such as MFEM_DATA_PATH MFEM_DATA_PATH contains 2D and 3D sample meshes for testing (these meshes come from the MFEM repository).","category":"page"},{"location":"developer/testing/#Unit-test-coverage","page":"Testing","title":"Unit test coverage","text":"","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"When Palace is built with PALACE_BUILD_WITH_COVERAGE, running the unit tests generates coverage information that tracks which parts of the codebase are exercised by the tests. The scripts/measure-test-coverage script automates the entire coverage measurement process, handling compiler detection, test execution, and report generation.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"warning: Before continuing\nMake sure you have lcov installed. To check that it works, runlcov --versionYou need a version newer than 1.15. For LLVM, you will also need llvm-profdata and llvm-cov. For GCC, you will need gcov-tool (which comes with GCC).Also make sure that Palace was build with PALACE_BUILD_WITH_COVERAGE. If not, compile it withcmake -DPALACE_MFEM_USE_EXCEPTIONS=yes -DPALACE_BUILD_WITH_COVERAGE=yes ..","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Assuming you correctly built Palace in the build folder, the simplest approach runs tests and generates an HTML report in one command:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"cd scripts\n./measure-test-coverage report","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"This automatically:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Detects your compiler type (GCC or LLVM)\nRuns all tests via CTest (serial, MPI, GPU if available)\nCollects and merges coverage data\nFilters to Palace source code only\nGenerates an HTML report at ../build/coverage_html/index.html","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"You can control test parallelism with the -j flag:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"./measure-test-coverage report -j8","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Note that MPI tests run with 2 processes each, so -j8 allows up to 4 MPI tests simultaneously.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"The measure-test-coverage allows for more control, for example:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"# Generate coverage data only\n./measure-test-coverage generate /path/to/unit-test\n\n# Generate HTML report from existing coverage data\n./measure-test-coverage report coverage_filtered.info\n\n# Merge coverage from multiple builds\n./measure-test-coverage generate /path/to/build1/unit-tests\n./measure-test-coverage generate /path/to/build2/unit-tests\n./measure-test-coverage merge build1/coverage_filtered.info build2/coverage_filtered.info\n./measure-test-coverage report coverage_filtered.info","category":"page"},{"location":"developer/testing/#Understanding-the-coverage-system","page":"Testing","title":"Understanding the coverage system","text":"","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Palace supports two coverage implementations:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"LLVM source-based coverage (Clang, AppleClang, IntelLLVM): Provides accurate instrumentation through compiler integration. Coverage data is written to .profraw files during test execution, then merged and converted to LCOV format.\nGCC gcov coverage: Uses compile-time annotations (.gcno) and runtime data (.gcda). The measure-test-coverage script handles the complexity of merging parallel test runs and unmangling filenames.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Both produce LCOV-compatible output for standardized processing and HTML visualization.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Note that measure-test-coverage runs all the tests and produces only one coverage report, merging the results from the serial, parallel, gpu, and noconcurrent tests.","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"note: Why two different coverage systems?\nLLVM's source-based coverage provides more accurate instrumentation than the gcov-compatible mode, which attempts to emulate gcov behavior but has known reliability issues. The source-based approach offers better precision for complex codebases.","category":"page"},{"location":"developer/testing/#Regression-tests","page":"Testing","title":"Regression tests","text":"","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"In addition to unit tests, Palace comes with a series of regression tests. Regression tests based on the provided example applications in the examples/ directory and verify that the code reproduces results in reference files stored in test/examples/.","category":"page"},{"location":"developer/testing/#Building-and-running-example-tests","page":"Testing","title":"Building and running example tests","text":"","category":"section"},{"location":"developer/testing/#Prerequisites","page":"Testing","title":"Prerequisites","text":"","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Julia\nPalace executable in PATH or specified via environment variable","category":"page"},{"location":"developer/testing/#Setup","page":"Testing","title":"Setup","text":"","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"First, instantiate the Julia environment:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"julia --project -e \"using Pkg; Pkg.instantiate()\"","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"You need to do this step only the very first time.","category":"page"},{"location":"developer/testing/#Environment-Variables","page":"Testing","title":"Environment Variables","text":"","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"PALACE_TEST: Path to Palace executable and optional arguments (default: \"palace\")\nNUM_PROC_TEST: Number of MPI processes (default: number of physical cores)\nOMP_NUM_THREADS: Number of OpenMP threads (default: 1)\nTEST_CASES: Space-separated list of test cases to run (default: all examples)","category":"page"},{"location":"developer/testing/#Execution","page":"Testing","title":"Execution","text":"","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Run all tests:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"julia --project runtests.jl","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Run specific test cases:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"TEST_CASES=\"spheres rings\" julia --project runtests.jl","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Run with custom Palace executable:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"PALACE_TEST=\"../../build/bin/palace\" julia --project runtests.jl","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Run with custom Palace executable and custom MPI launcher:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"PALACE_TEST=\"../../build/bin/palace --launcher mpiexec\" julia --project runtests.jl","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"Each test case runs Palace simulations and compares generated CSV files against reference data using configurable tolerances. When Palace behavior changes legitimately (e.g., algorithm improvements), reference data can be updated using the baseline script:","category":"page"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"./baseline                    # Update all reference data\n./baseline -e spheres         # Update specific example\n./baseline --dry-run          # Test without updating files\n./baseline -np 4              # Use 4 MPI processes","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"developer/tutorial_gpu_profiling/#Tutorial:-GPU-Profiling-with-NVIDIA-Nsight-Systems-and-NVTX","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"","category":"section"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"This tutorial demonstrates how to profile Palace GPU execution using NVIDIA Nsight Systems with NVTX ranges for better code traceability.","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"NVIDIA Nsight Systems is a system-wide performance analysis tool that provides timeline profiling of CPU and GPU activity, including CUDA kernels, memory transfers, and API calls. NVIDIA Nsight Compute is a kernel-level profiler for detailed analysis of individual CUDA kernels. NVTX (NVIDIA Tools Extension) provides a C-based API for annotating events and ranges in your application, making profiles much easier to interpret.","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"GPU profiling is more complex than CPU profiling because GPU execution is asynchronous. GPU kernels launch asynchronously, so CPU timers don't capture actual GPU execution time. Performance depends heavily on memory access patterns and how well threads utilize GPU resources.","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"This tutorial assumes familiarity with compiling and running unit tests (see Running unit tests). You'll need Palace compiled with CUDA support (-DPALACE_WITH_CUDA=yes) and NVIDIA Nsight Systems installed.","category":"page"},{"location":"developer/tutorial_gpu_profiling/#Basic-Profiling","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Basic Profiling","text":"","category":"section"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"In this tutorial, we will profile the Vector Sum - Complex unit test.","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"First, let us make the test more interesting for profiling by increasing the vector size. Find the Vector Sum - Complex test in test/unit/test-vector.cpp, and increase the size of the vector:","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"-ComplexVector cv(2);\n+ComplexVector cv(20000);","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"Make sure that we have a working and compiled version of Palace:","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"cmake -DPALACE_MFEM_USE_EXCEPTIONS=yes -DPALACE_WITH_CUDA=yes ..\nmake -j $(nproc)\npalace-build/test/unit/unit-tests \"Vector Sum - Complex\" --device gpu --backend /gpu/cuda/magma","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"This will show something along the lines of","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"Device configuration: cuda,cpu\nMemory configuration: host-umpire,cuda-umpire\nUse GPU-aware MPI:    no\nlibCEED backend: /gpu/cuda/magma\nFilters: \"Vector Sum - Complex\" [GPU] [Serial]\nRandomness seeded to: 2674903133\n===============================================================================\nAll tests passed (2 assertions in 1 test case)","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"Now, run this under nsys:","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"nsys profile --trace=cuda,cublas --force-overwrite=true -o myprofile.nsys-rep \\\n  palace-build/test/unit/unit-tests \"Vector Sum - Complex\" --device gpu --backend /gpu/cuda/magma","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"You can open the report with nsys-ui myprofile.nsys-rep. You should be greeted with a window like this:","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/profiling/nsys2.png\" alt=\"NVIDIA Nsight Systems timeline\" style=\"max-width: 100%; cursor: pointer;\" onclick=\"window.open(this.src, '_blank')\" />\n  <br/><em>Click image to view full size - NVIDIA Nsight Systems timeline</em>\n</p><br/>","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"There's a lot to unpack here. What you are looking at is the timeline of execution of the test as seen by different components. We have the CPUs on top, the GPU on the second row, and other components below. Consult the documentation to learn more about how to read this.","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"The key problem here is that this timeline has no clear connection to the source code. How do we know what is really happening?","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"We can get some clues by moving the mouse around and zooming. In particular, we can zoom into the region around 200 milliseconds. Here, we can see that there are some CUDA memory operations (under CUDA APIs), and we can see that there's some activity on the GPU (the little bars in the CUDA HW line). We can possibly guess that this is where the test is allocating the vectors and doing the sum operations.","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/profiling/nsys2.png\" alt=\"NVIDIA Nsight Systems zoomed view around 200ms showing CUDA memory operations\" style=\"max-width: 100%; cursor: pointer;\" onclick=\"window.open(this.src, '_blank')\" />\n  <br/><em>Click image to view full size - Zoomed view showing CUDA memory operations around 200ms</em>\n</p><br/>","category":"page"},{"location":"developer/tutorial_gpu_profiling/#Adding-NVTX-Ranges","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Adding NVTX Ranges","text":"","category":"section"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"With a little bit more effort, we could probably get insight directly from this report. However, it is often more convenient to use NVTX ranges to orient ourselves around the code. NVTX provides a way to mark the source code and see the markings in the Nsight report.","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"The most common NVTX marking is the range. As the name suggests, a range is a way to identify a block of code and give it a name.","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"To use NVTX, we need to include its header:","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"#include \"nvtx3/nvtx3.hpp\"","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"Then, we can define ranges with:","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"nvtxRangePush(\"My first range\");\nmycode1();\nmycode2();\nmycode3();\nnvtxRangePop();","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"Alternatively, NVTX3 provides nvtx3::scoped_range which uses RAII to automatically define a range in a given scope. The example above would become:","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"{\n    nvtx3::scoped_range range(\"My first range\");\n    mycode1();\n    mycode2();\n    mycode3();\n}","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"The advantage of this approach is that it's easy to forget to close the range manually, and RAII does it automatically when the scope ends. Consult to NVTX documentation for more details.","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"Let us follow this method and change the test to:","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"{\n    nvtx3::scoped_range range(\"Initialize\");\n    mfem::forall(cv.Size(),\n               [=] MFEM_HOST_DEVICE(int i)\n               {\n                 // Rank 0: [(0, 1), (0, 2), ...], Rank 1: [(1, 2), (1, 3), ...], etc.\n                 d_real[i] = rank;\n                 d_imag[i] = rank + i;\n               });\n}\n\nstd::complex<double> sum;\n{\n    nvtx3::scoped_range range(\"Sum\");\n    sum = linalg::Sum(Mpi::World(), cv);\n}","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"We recompile Palace and run the profiler again. When we have ranges, we need to ask nsys to keep track of them, so the invocation changes slightly. We also add other useful components to track:","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"nsys profile --trace=nvtx,cuda,cublas,mpi --nvtx-capture=range \\\n  --force-overwrite=true -o myprofile.nsys-rep \\\n  palace-build/test/unit/unit-tests \"Vector Sum - Complex\" --device gpu --backend /gpu/cuda/magma","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"Now, if we open the new profile, we will see some differences:","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/profiling/nsys3.png\" alt=\"NVIDIA Nsight Systems with NVTX ranges showing MPI initialization and custom ranges\" style=\"max-width: 100%; cursor: pointer;\" onclick=\"window.open(this.src, '_blank')\" />\n  <br/><em>Click image to view full size - Timeline with NVTX ranges and MPI initialization visible</em>\n</p><br/>","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"First, we now learn that the large idle block was due to MPI initialization. Second, we see that there's now a new NVTX line. If we zoom in where it has activity, we find our Initialize and Sum blocks:","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/profiling/nsys4.png\" alt=\"NVIDIA Nsight Systems zoomed view of Initialize and Sum NVTX blocks\" style=\"max-width: 100%; cursor: pointer;\" onclick=\"window.open(this.src, '_blank')\" />\n  <br/><em>Click image to view full size - Detailed view of Initialize and Sum NVTX ranges</em>\n</p><br/>","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"We can now right-click on the Initialize block and select \"Fit to screen\", then expand some sections to learn more about what is happening:","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/profiling/nsys5.png\" alt=\"NVIDIA Nsight Systems detailed view of Initialize block showing CUDA APIs and GPU kernel execution\" style=\"max-width: 100%; cursor: pointer;\" onclick=\"window.open(this.src, '_blank')\" />\n  <br/><em>Click image to view full size - Expanded view showing CUDA APIs and GPU kernel timing details</em>\n</p><br/>","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"What we see is that Initialize takes 200 microseconds, but most of it is due to one-time costs (as we see under CUDA APIs). The actual kernel that runs on the GPU is highlighted and takes less than 2 microseconds.","category":"page"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"Something worth noting is that the actual kernel executed on the GPU starts only after the CPU has completed (the CuKernel1D block). This demonstrates why CPU timers cannot accurately profile GPU code unless they force synchronization (i.e., make the CPU wait for the GPU kernel to complete).","category":"page"},{"location":"developer/tutorial_gpu_profiling/#Key-Takeaways","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Key Takeaways","text":"","category":"section"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"NVTX ranges provide essential context for understanding GPU profiles by connecting timeline events to source code. The asynchronous nature of GPU execution means that CPU and GPU work can overlap, making traditional CPU timing inadequate for GPU performance analysis. From here, you should be equipped to start exploring Nsight System on your own.","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"examples/spheres/#Capacitance-Matrix-for-Two-Spheres","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"","category":"section"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"note: Note\nThe files for this example can be found in the examples/spheres/ directory of the Palace source code.","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"In this example, we consider two conducting spheres of radii a and b, with centers separated by a distance c  a + b. The surrounding medium is vacuum. An analytic solution for the capacitance matrix of this configuration exists and is given in [1]. The Maxwell capacitance matrix entries are given by the infinite series","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"beginaligned\nC_aa = 4pivarepsilon_0 ab sinhusum_n=0^infty frac1asinhnu+bsinh(n+1)u \nC_bb = 4pivarepsilon_0 ab sinhusum_n=0^infty frac1bsinhnu+asinh(n+1)u \nC_ab = -4pivarepsilon_0 fracabc sinhusum_n=1^infty frac1sinhnu\nendaligned","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"where the subscript a refers to the sphere with radius a and likewise for b. The parameter u is given by","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"coshu = fracc^2-a^2-b^22ab ","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"Here we take the values a = 1text cm, b = 2text cm, and c = 5text cm. A mesh is generated with Gmsh using the mesh.jl Julia script found in the mesh/ directory, which writes the mesh to mesh/spheres.msh. The resulting high-order mesh uses cubically-curved tetrahedral elements, and is pictured below.","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/spheres-1.png\" width=\"45%\" />\n  <img src=\"../../assets/examples/spheres-2.png\" width=\"45%\" />\n</p><br/>","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"The configuration file for the Palace simulation is found in spheres.json. We set the simulation \"Type\" to \"Electrostatic\", and add \"Terminal\" entries for the surface boundary of each sphere, corresponding to the entries of the capacitance matrix we wish to compute. The outer boundary of the computational domain, which is sufficiently far from the spheres, is prescribed a \"Ground\" boundary condition. We set the \"Order\" of the finite element approximation to 3.","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"The resulting extracted Maxwell capacitance matrix is saved to disk in the CSV file postpro/terminal-C.csv:","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"include_example_file(\"spheres\", \"terminal-C.csv\") # hide","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"In this case, the analytic solution yields","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"beginaligned\nC_aa = +1230518text pF \nC_bb = +2431543text pF \nC_ab = -04945668text pF\nendaligned","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"which is computed using the first n=12 terms in the series after which convergence to a relative tolerance of 10^-12 is reached. Thus, the errors in the capacitance coefficients by Palace are 057, 19, and 35, respectively.","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"The mutual capacitance matrix can be computed from its Maxwell counterpart, and is saved in postpro/terminal-Cm.csv:","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"include_example_file(\"spheres\", \"terminal-Cm.csv\") # hide","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"Additionally, while the typical approach used by Palace for lumped parameter extraction uses the computed field energies, the capacitance can also be calculated by directly integrating the charge on a boundary surface and dividing by the excitation voltage. The configuration file for this example contains this information under config[\"Boundaries\"][\"Postprocessing\"][\"SurfaceFlux\"]. The resulting capacitances are written to postpro/terminal-C.csv:","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"include_example_file(\"spheres\", \"terminal-C.csv\") # hide","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"Finally, the postpro/paraview directory contains files for visualizing the computed field solutions with ParaView. Below we present the electrostatic potential fields for each terminal solution.","category":"page"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/spheres-3.png\" width=\"45%\" />\n  <img src=\"../../assets/examples/spheres-4.png\" width=\"45%\" />\n</p>","category":"page"},{"location":"examples/spheres/#References","page":"Capacitance Matrix for Two Spheres","title":"References","text":"","category":"section"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"[1] J. Lekner, Capacitance coefficients of two spheres, Journal of Electrostatics 69 (2011) 11-14.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Mathematical-background","page":"Reference","title":"Mathematical background","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The solver computes a finite element approximation to the three-dimensional, time-harmonic Maxwell's equations in second-order form. The nondimensionalized, source-free, boundary value problem for bmE(bmx)inmathbbC^3, bmxinOmega, partialOmega = Gamma, where bmmathscrE(bmxt) = textRebmE(bmx)e^iomega t denotes the electric field, is written as","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"beginaligned\nnablatimesmu_r^-1nablatimesbmE + iomegasigmabmE\n    - omega^2varepsilon_rbmE = 0  bmxinOmega \nbmntimesbmE = 0  bmxinGamma_PEC \nbmntimes(mu_r^-1nablatimesbmE) = 0  bmxinGamma_PMC \nbmntimes(mu_r^-1nablatimesbmE)\n    + gammabmntimes(bmntimesbmE) = bmU^inc  bmxinGamma_Z\nendaligned","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where the nondimensionalization has been performed with respect to a characteristic length L_0, time L_0c_0, magnetic field strength H_0, and electric field strength Z_0 H_0. Here, c_0 and Z_0 are the speed of light and impedance of free space, respectively. This nondimensionalization will be used throughout this entire reference. For more details, see [1] and [2].","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Given the electric field solution, the time-harmonic magnetic flux density can be calculated as","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"bmB = -frac1iomeganablatimesbmE ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The flux density is related to the magnetic field, bmH, by the standard linear constitutive relationship bmH = mu_r^-1bmB.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"In general, the material property coefficients may be scalar- or matrix-valued. In the matrix-valued (anisotropic) case, the material property coefficients should still always be symmetric.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"For a general isotropic lossy dielectric, the relative permittivity varepsilon_r is a complex-valued quantity:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"varepsilon_r = varepsilon_r (1-itandelta)","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where varepsilon_r is the real relative permittivity and tandelta is the loss tangent. Alternatively, conductor loss is modeled by Ohm's law bmJ = sigmabmE with electrical conductivity sigma  00. For a superconducting domain, the constitive current-field relationship given by Ohm's law is replaced by that given by the London equations:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"fracpartial bmJpartial t = frac1mu_rlambda_L^2bmE","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where lambda_L = sqrtmmu n_s e^2L_0 is the nondimensionalized London penetration depth. In this case, the term +iomegasigma bmE arising for a normal conductor in the time-harmonic Maxwell's equations becomes +(mu_r lambda_L^2)^-1bmE.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The domain boundary Gamma = Gamma_PECcupGamma_PMCcupGamma_Z, is separated into perfect electric conductor (PEC), perfect magnetic conductor (PMC), and impedance boundaries, respectively. The PEC boundary condition is a homogeneous Dirichlet condition, while the PMC boundary condition is the natural boundary condition for the problem and is satisfied at all exterior boundaries by the finite element formulation. Impedance boundaries are modeled using a Robin boundary condition with gamma = iomegaZ_s, in which Z_s the surface impedance of the boundary, with units of impedance per square.","category":"page"},{"location":"reference/#Floquet-periodic-boundary-conditions","page":"Reference","title":"Floquet periodic boundary conditions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"When applying Floquet periodic boundary conditions, the phase delay is incorporated into the time-harmonic Maxwell equations and exact periodic boundary conditions are applied. The modified Maxwell equations are obtained by substituting bmE(bmx) = bmE_p(bmx)e^-i bmk_p cdot bmx, where bmE_p is the periodic electric field and  bmk_p is the user-specified Bloch wavevector. The resulting equation is","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"beginaligned\nnablatimesmu_r^-1nablatimesbmE_p\n- ibmk_ptimesmu_r^-1nablatimesbmE_p\n- inablatimes(mu_r^-1bmk_ptimesbmE_p)  \n- bmk_ptimesmu_r^-1bmk_ptimesbmE_p\n+ iomegasigmabmE_p\n- omega^2varepsilon_rbmE_p = 0  bmxinOmega\nendaligned","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"and given the electric field solution, the time-harmonic magnetic flux density can be calculated as","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"bmB_p = -frac1iomeganablatimesbmE_p + frac1omega bmk_p times bmE_p ","category":"page"},{"location":"reference/#Time-domain-formulation","page":"Reference","title":"Time domain formulation","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"A time-dependent formulation is also available to compute the electric field response bmE(bmxt) for a given time-dependent source excitation bmU^inc(bmxt). The governing equations in this case are","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"nablatimesmu_r^-1nablatimesbmE + sigmafracpartialbmEpartial t\n    + varepsilon_rfracpartial^2bmEpartial t^2 = 0  bmxinOmega","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"subject to the same boundary conditions as the frequency-dependent case except for the Robin boundary condition which is written for a lumped resistive port boundary, for example, as","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"bmntimes(mu_r^-1nablatimesbmE)\n    + Z_s^-1bmntimesleft(bmntimesfracpartialbmEpartial tright)\n    = bmU^inc  bmxinGamma_Z ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The second-order electric field differential equation is transformed into a first-order ODE system which is solved along with the equation for the magnetic flux density","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"left(beginmatrix varepsilon_r  0  0  0  I  0  0  0  Iendmatrixright)\n  left(beginmatrix ddotbmE  dotbmE  dotbmBendmatrix right)\n  = left(beginmatrix -sigma  -nablatimesmu_r^-1nablatimes  0 I  0  0  0  -nablatimes  0endmatrixright)\n    left(beginmatrixdotbmE bmE  bmB endmatrixright) ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The first-order ODE system formulation is chosen to take advantage of implicit adaptive time-stepping integration schemes. The 3 times 3 system can be block-eliminated to avoid an expensive coupled block system solve. It offers the additional benefit of sharing many similarities in the spatial discretization as the frequency domain formulation outlined above.","category":"page"},{"location":"reference/#Eigenmode-calculations","page":"Reference","title":"Eigenmode calculations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"For eigenmode problems, the source term is zero and a quadratic eigenvalue problem for the eigenvalues omega is solved:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"(bmK+iomegabmC-omega^2bmM)bmx = 0","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where the matrix bmK represents the discretized curl-curl operator, bmM the mass term, and bmC the port impedance boundary conditions. The damped frequency omega_d and quality factor Q are postprocessed from each of the resulting eigenvalues as","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"omega_d = textReomega  qquad Q = fracomega2textImomega ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"When wave port, surface conductivity, or second-order absorbing boundary conditions are used, a nonlinear eigenvalue problem is solved:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"(bmK+iomegabmC-omega^2bmM+bmA_2(omega))bmx = 0","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where the matrix bmA_2 represents the nonlinear frequency-dependent boundary conditions.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The eigenmodes are normalized such that they have unit norm and their mean phase is a positive real number.","category":"page"},{"location":"reference/#Lumped-ports-and-wave-ports","page":"Reference","title":"Lumped ports and wave ports","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"For lumped port boundaries, the surface impedance can be related to an equivalent circuit impedance, Z. There are two common cases:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Rectangular ports: Z = Z_s l  w, where l and w are the length and width of the port, respectively (length here is defined as the distance between the two conductors).\nCoaxial ports: Z = Z_s ln(ba)  2pi, where a and b denote the inner and outer radii of the port, respectively.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"A lumped parallel RLC circuit boundary has a circuit impedance","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"frac1Z = frac1R+frac1iomega L+iomega C ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Thus, the relationships between the circuit and surface element parameters for the user to specify are given by R_s = alpha R, L_s = alpha L, and C_s = Calpha, where alpha = wl for a rectangular port or alpha = 2pi  ln(ba) for a coaxial port.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"For multielement lumped ports, the effective circuit impedance is given by","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"frac1Z = sum_k frac1Z_k ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"That is, the circuit impedances of each port contributing to the multielement port add in parallel. For the specific case of a two element multielement port with two identical lumped elements, we have Z = (1Z_1 + 1Z_2)^-1 = Z_k  2, where Z_k is the circuit impedance of a single port element.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The source term bmU^inc in a driven frequency-response problem is related to the incident field at an excited port boundary by","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"bmU^inc = -2gamma(bmntimesbmE^inc)timesbmn","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where (bmntimesbmE^inc)timesbmn is just the projection of the excitation field onto the port surface. The incident fields for lumped ports depend on the port shape:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Rectangular ports: bmE^inc = E_0  hatbml, where E_0 is a uniform constant field strength and hatbml a unit vector defining the direction of polarization on the port (typically should be the direction between the two conductors).\nCoaxial ports: bmE^inc = fracE_0 r_0r  hatbmr, where E_0 is again a uniform constant field strength, r_0 is a characteristic length for the port, r is the distance from the port center, and hatbmr a unit vector specifying the port radial direction.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"In the time domain formulation, the source term bmU^inc appears as","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"bmU^inc = -2 Z_s^-1left(bmntimesfracpartialbmE^incpartial tright)\n    timesbmn ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The incident field bmE^inc(bmxt) is","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"bmE^inc(bmxt) = p(t)bmE^inc(bmx)","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where bmE^inc(bmx) is identical to the spatial excitation in the frequency domain formulation, and p(t) describes the temporal shape of the excitation. Possible options include a sinusoidal, Gaussian, modulated Gaussian, or step excitation.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"In the frequency domain, the scattering parameters can be postprocessed from the computed electric field for each lumped port with boundary Gamma_i as","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"S_ij = fracdisplaystyleint_Gamma_ibmEcdotbmE^inc_idS\n    displaystyleint_Gamma_ibmE^inc_icdotbmE^inc_idS - delta_ij ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"In the time domain, the time histories of the port voltages can be Fourier-transformed to get their frequency domain representation for scattering parameter calculation.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Numeric wave ports assume a field with known normal-direction dependence bmE(bmx) = bme(bmx_t)e^ik_n x_n where k_n is the propagation constant. For each operating frequency omega, a two-dimensional eigenvalue problem is solved on the port yielding the mode shapes bme_m and associated propagation constants k_nm. These are used in the full 3D model where the Robin port boundary condition has coefficient gamma = itextRek_nmmu_r and the computed mode is used to compute the incident field in the source term bmU^inc at excited ports. Scattering parameter postprocessing takes the same form as the lumped port counterpart using the computed modal solutions. Since the propagation constants are known for each wave port, scattering parameter de-embedding can be performed by specifying an offset distance d for each port:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"tildeS_ij = S_ije^ik_nid_ie^ik_njd_j ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"For more information on the implementation of numeric wave ports, see [3].","category":"page"},{"location":"reference/#Other-boundary-conditions","page":"Reference","title":"Other boundary conditions","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The first-order absorbing boundary condition, also referred to as a scattering boundary condition, is a special case of the general impedance boundary condition described above:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"bmntimes(mu_r^-1nablatimesbmE)\n    + iomegasqrtmu_r^-1varepsilon_rbmntimes(bmntimesbmE) = 0 ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"This is also known as the Sommerfeld radiation condition, and one can recognize the dependence on the impedance of free space Z_0^-1 = sqrtmu_r^-1varepsilon_r. The second-order absorbing boundary condition is","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"bmntimes(mu_r^-1nablatimesbmE)\n    + iomegasqrtmu_r^-1varepsilon_rbmntimes(bmntimesbmE)\n    - betanablatimes(nablatimesbmE)_nbmn = 0","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where assuming an infinite radius of curvature beta = mu_r^-1c_0(2iomega), and the contribution depending on (nablacdotbmE_t) has been neglected.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Additionally, while metals with finite conductivity can be modeled using an impedance boundary condition with constant impedance Z_s, a more accurate model taking into account the frequency dependence of the skin depth is","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Z_s = frac1+ideltasigma","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where delta = sqrt2mu_rsigmaomega is the skin depth and sigma is the conductivity of the metal. Another model, which takes into account finite thickness effects, is given by","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Z_s = frac1deltasigmaleft(fracsinhnu+sinnucoshnu+cosnu\n    + ifracsinhnu-sinnucoshnu+cosnuright)","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where nu = hdelta and h is the layer thickness. This model correctly produces the DC limit when hlldelta.","category":"page"},{"location":"reference/#Energy-participation-ratios","page":"Reference","title":"Energy-participation ratios","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The energy-participation ratio (EPR) for lumped inductive elements is computed from the electric and magnetic fields corresponding to eigenmode m, bmE_m and bmH_m, using the formula","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"p_mj = frac1mathcalE^elec_m  frac12  L_j I_mj^2","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where p_mjin-11 denotes the signed participation ratio for junction j in mode m, L_j is the provided junction circuit inductance, I_ mj is the peak junction current for mode m, and mathcalE^elec_m is the electric energy in mode m. The junction current is computed using the mean voltage across the port, overlineV_mj, as I_mj = overlineV_mjZ_mj, where Z_mj = 1(iomega_m L_j) is the impedance of the inductive branch of the lumped circuit. The mean port voltage depends on the computed electric field mode and the shape of the port:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Rectangular ports: overlineV_mj = frac1w_jint_Gamma_jbmE_mcdothatbml_jdS.\nCoaxial ports: overlineV_mj = frac12piint_Gamma_jfracbmE_mrcdothatbmr_jdS.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Finally, the total electric energy in mode m is","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"mathcalE^elec_m\n    = frac12  textReleftint_OmegabmD_m^*cdotbmE_mdVright\n    + sum_j frac12  C_jV_mj^2","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where bmD_m = varepsilon_rbmE_m is the electric flux density for mode m and the second term on the right-hand side accounts for any lumped capacitive boundaries with nonzero circuit capacitance C_j.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The EPR can also be used to estimate mode quality factors due to input-output (I-O) line coupling. The mode coupling quality factor due to the j-th I-O port is given by","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Q_mj = fracomega_mkappa_mj","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where the port coupling rate kappa_mj is calculated as","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"kappa_mj = frac1mathcalE^elec_m  frac12R_j I_mj^2 ","category":"page"},{"location":"reference/#Bulk-and-interface-dielectric-loss","page":"Reference","title":"Bulk and interface dielectric loss","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"The quality factor due to bulk dielectric loss resulting from an electric field bmE present in domain j with associated loss tangent tandelta_j is given by","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"frac1Q_j = p_j tandelta_j =\n    frac1mathcalE^elec  frac12  tandelta_j \n    textReleftint_Omega_jbmD^*cdotbmEdVright","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where, as above, mathcalE^elec is the total electric field energy in the domain, including the contributions due to capacitive lumped elements.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Likewise, the quality factor due to surface interface dielectric loss for interface j is given by","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"frac1Q_j = p_j tandelta_j =\n    frac1mathcalE^elec  frac12  t_jtandelta_j \n    textReleftint_Gamma_jbmD^*cdotbmEdSright","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where t_j is the thickness of the layer and bmD = varepsilon_rjbmE is the electric displacement field in the layer evaluated using the relative permittivity of the interface varepsilon_rj. For an internal boundary, this integral is evaluated on a single side to resolve abiguity due to the discontinuity of bmE across the boundary.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The above formula for interface dielectric loss can be specialized for the case of a metal-air, metal-substrate, or substrate-air interface [4]. In each case, the quality factor for interface j is given by","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Metal-air:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"frac1Q^MA_j =\n    frac1mathcalE^elec  frac12 \n    fract_jtandelta_jvarepsilon_rj^MA \n    textReleftint_Gamma_jbmE_n^*cdotbmE_ndSright","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Metal-substrate:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"frac1Q^MS_j =\n    frac1mathcalE^elec  frac12 \n    fract_jtandelta_j(varepsilon_rj^S)^2varepsilon_rj^MS \n    textReleftint_Gamma_jbmE_n^*cdotbmE_ndSright","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Substrate-air:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"frac1Q^SA_j =\n    frac1mathcalE^elec  frac12 \n    t_jtandelta_jleft(varepsilon_rj^SA \n    textReleftint_Gamma_jbmE_t^*cdotbmE_tdSright\n    + frac1varepsilon_rj^SA \n    textReleftint_Gamma_jbmE_n^*cdotbmE_ndSrightright)","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where bmE_n denotes the normal field to the interface and bmE_t = bmE-bmE_n denotes the tangential field.","category":"page"},{"location":"reference/#Lumped-parameter-extraction","page":"Reference","title":"Lumped parameter extraction","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"For electrostatic simulations, the Maxwell capacitance matrix is computed in the following manner. First, the Laplace equation subject to Dirichlet boundary conditions is solved for each terminal with boundary Gamma_i in the model, yielding an associated voltage field V_i(bmx):","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"beginaligned\nnablacdot(varepsilon_rnabla V_i) = 0  bmxinOmega \nV_i = 1  bmxinGamma_i \nV_i = 0  bmxinGamma_j  jneq i \nendaligned","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The energy of the electric field associated with any solution is","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"mathcalE(V_i) = frac12int_Omegavarepsilon_rbmE_icdotbmE_idV","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where bmE_i=-nabla V_i is the electric field. Then, the entries of the Maxwell capacitance matrix, bmC, are given by","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"bmC_ij = mathcalE(V_i+V_j)-frac12(bmC_ii+bmC_jj) ","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Magnetostatic problems for inductance matrix extraction are based on the magnetic vector potential formulation:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"beginaligned\nnablatimes(mu_r^-1nablatimesbmA_i) = 0  bmxinOmega \nbmntimes(mu_r^-1nablatimesbmA_i) =\n    bmntimesbmH_i = bmJ_s^inc  bmxinGamma_i \nbmntimes(mu_r^-1nablatimesbmA_i) = 0  bmxinGamma_j  jneq i \nendaligned","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"For each port with boundary Gamma_i, a unit source surface current bmJ_s^inc is applied, yielding an associated vector potential solution bmA_i(bmx). Homogeneous Dirichlet boundary conditions bmntimesbmA_i=0 are also imposed on specified surfaces of the model. The magnetic field energy associated with any solution is","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"mathcalE(bmA_i) = frac12int_Omegamu_r^-1bmB_icdotbmB_idV","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where bmB_i = nablatimesbmA_i is the magnetic flux density. Then, the entries of the inductance matrix, bmM, are given by","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"bmM_ij = frac1I_i I_jmathcalE(bmA_i+bmA_j)\n    - frac12left(fracI_iI_jbmM_ii+fracI_jI_ibmM_jjright)","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where I_i is the excitation current for port i, computed by integrating the source surface current bmJ_s^inc over the surface of the port.","category":"page"},{"location":"reference/#Error-estimation-and-adaptive-mesh-refinement-(AMR)","page":"Reference","title":"Error estimation and adaptive mesh refinement (AMR)","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Error estimation is used to provide element-wise error estimates for AMR, as well as a global error indicator used to terminate AMR iterations or provide an estimate for solution accuracy. A Zienkiewicz–Zhu (ZZ) error estimator based on [5] is implemented, which measures the error in the recovered magnetic field and electric flux density. On element K, we have","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"eta^2_K = eta_m2^2+eta_eK^2 =\n    mu_r^12bmR_ND(mu^-1bmB)\n    - (mu_r^-12bmB)_L^2(Omega_K)^2\n    + varepsilon_r^-12bmR_RT(varepsilon_rbmE)\n    - (varepsilon_r^12bmE)_L^2(Omega_K)^2","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where bmR_ND and bmR_RT are the smooth-space recovery operators which orthogonally project their argument onto H(textcurl) and H(textdiv), discretized by Nédélec and Raviart-Thomas elements, respectively.","category":"page"},{"location":"reference/#Far-field-extraction","page":"Reference","title":"Far-field extraction","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"This feature is based upon Stratton-Chu's transformations [6] in the limit of kr gg 1 (with k wave number and r observation distance). One can show (see below) that, in this limit,","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"r mathbfE_p(mathbfr_0) = fracik4pi mathbfr_0 times int_S mathbfn times mathbfE - Z mathbfr_0 times (mathbfn times mathbfH) exp(ikmathbfr cdot mathbfr_0) dS","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"E_p is the electric field at the observation point\nk is the wave number\nr₀ is the unit vector from source to observation point, parameterized by (theta phi)\nn is the surface normal (to S)\nE H are the tangential fields on the surface\nZ is the impedance","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The integral is over the exterior surface S.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Note, we obtain r mathbfE_p because the electric field decays with exp(ikr)r, so multiplying it by r ensures that the quantity is finite. Note also that the solution is defined up to a global phase factor.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"This equation relies on an analytic form for Green's function and is only valid in 3D and if S only crosses isotropic materials.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"From r mathbfE_p, one can obtain the magnetic field assuming that the waves are propagating in free space,","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"r mathbfH_p = fracr_0 times r mathbfE_pZ_0","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"with Z_0 impedance of free space.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"With this, one can immediately compute the far-field relative radiation pattern as r mathbfE_p.","category":"page"},{"location":"reference/#How-to-obtain-the-equation-above-from-Stratton-Chu's-original-equations","page":"Reference","title":"How to obtain the equation above from Stratton-Chu's original equations","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"Let us start from Stratton-Chu's transformation for the electric field (we will get the magnetic field from E):","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"mathbfE(mathbfr_0) = int_S left i omega mu (mathbfn times mathbfH) g(mathbfr mathbfr_0) +\n(mathbfn times mathbfE) times nabla g(mathbfr mathbfr_0) + (mathbfn cdot mathbfE) nabla g(mathbfr mathbfr_0) right dS","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"with Green's function (here is where the assumption of isotropicity comes in):","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"g(mathbfr mathbfr_0) = frace^-i k mathbfr - mathbfr_04 pi mathbfr - mathbfr_0","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"Let us take the limit for r to infty and define R = mathbfr - mathbfr_0 (R to infty when r to infty). For r gg r_0 (far-field approximation):","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"R approx r - mathbfrcdotmathbfr_0","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where mathbfr_0 = mathbfrr is the unit vector in the direction of mathbfr.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"The far-field approximation for Green's function becomes:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"g(mathbfr mathbfr_0) approx frace^-i k r4 pi r e^i k mathbfr_0cdotmathbfr","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"For the gradient of g, we start with the exact expression and expand phase and magnitude to reach:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"nabla g(mathbfr mathbfr_0) = -frace^-i k R4 pi Rleft(frac1R + i kright)hatR","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where hatR = (mathbfr - mathbfr_0)R is the unit vector pointing from mathbfr_0 to mathbfr.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"In the far-field limit, R approx r and hatR approx mathbfr_0, so:","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"nabla g(mathbfr mathbfr_0) approx -i k mathbfr_0 g(mathbfr mathbfr_0)","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"where we've neglected the 1R term since k R gg 1 in the far-field.","category":"page"},{"location":"reference/","page":"Reference","title":"Reference","text":"With these ingredients, one then uses the triple vector product rule and drops the radial terms (i.e., those proportional to mathbfr_0, in the wave zone there are only transverse fields) to arrive at the equation presented in the previous section and implemented in Palace.","category":"page"},{"location":"reference/#References","page":"Reference","title":"References","text":"","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"[1] J.-M. Jin, The Finite Element Method in Electromagnetics, Wiley-IEEE Press, Hoboken, NJ, Third edition, 2014.\n[2] P. Monk, Finite Element Methods for Maxwell's Equations, Oxford University Press, Oxford, 2003.\n[3] L. Vardapetyan and L. Demkowicz, Full-wave analysis of dielectric waveguides at a given frequency, Mathematics of Computation 72 (2003) 105-129.\n[4] J. Wenner, R. Barends, R. C. Bialczak, et al., Surface loss of superconducting coplanar waveguide resonators, Applied Physics Letters 99, 113513 (2011).\n[5] S. Nicaise, On Zienkiewicz-Zhu error estimators for Maxwell’s equations, Comptes Rendus Mathematique 340 (2005) 697-702.\n[6] J. A, Stratton and L. J. Chu, Diffraction theory of Electromagnetic Waves, Physical Review, 56, 1, (1939), 99-107.","category":"page"},{"location":"config/problem/","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"config/problem/#config[\"Problem\"]","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"","category":"section"},{"location":"config/problem/","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"\"Problem\":\n{\n    \"Type\": <string>,\n    \"Verbose\": <int>,\n    \"Output\": <string>,\n    \"OutputFormats\":\n    {\n      ...\n    }\n}","category":"page"},{"location":"config/problem/","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"with","category":"page"},{"location":"config/problem/","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"\"Type\" [None] :  Controls the simulation type. The available options are:","category":"page"},{"location":"config/problem/","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"\"Eigenmode\" :  Perform a undamped or damped eigenfrequency analysis.\n\"Driven\" :  Perform a frequency response simulation.\n\"Transient\" :  Perform a time domain excitation response simulation.\n\"Electrostatic\" :  Perform an electrostatic analysis to compute the capacitance matrix for a set of voltage terminals.\n\"Magnetostatic\" :  Perform a magnetostatic analysis to compute the inductance matrix for a set of current sources.","category":"page"},{"location":"config/problem/","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"\"Verbose\" [1] :  Controls the level of log file printing.","category":"page"},{"location":"config/problem/","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"\"Output\" [None] :  Directory path for saving postprocessing outputs.","category":"page"},{"location":"config/problem/","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"\"OutputFormats\" :  Top-level object for configuring the field output formats.","category":"page"},{"location":"config/problem/#problem[\"OutputFormats\"]","page":"config[\"Problem\"]","title":"problem[\"OutputFormats\"]","text":"","category":"section"},{"location":"config/problem/","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"\"OutputFormats\":\n{\n    \"Paraview\": <bool>,\n    \"GridFunction\": <bool>\n}","category":"page"},{"location":"config/problem/","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"with","category":"page"},{"location":"config/problem/","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"\"Paraview\" [true] :  Set to true to output fields in Paraview format.","category":"page"},{"location":"config/problem/","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"\"GridFunction\" [false] :  Set to true to output fields in MFEM grid function format to visualize with GLVis.","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"examples/rings/#Inductance-Matrix-for-a-Pair-of-Concentric-Rings","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"","category":"section"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"note: Note\nThe files for this example can be found in the examples/rings/ directory of the Palace source code.","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"This example seeks to compute the inductance matrix for a system of two concentric current-carrying rings of radii r_a and r_b, each with width w. As with the previous example, the permeability of the surrounding medium is assumed to be the permeability of free space. The mutual inductance, M_ab, can be easily computed for the case where r_all r_b and w = 0 using the Biot-Savart law as","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"M_ab = fracmu_0pi r_b^22 r_a ","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"Analytic expressions for the self inductance of this configuration can also be derived, for example from [1] we have","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"beginaligned\nM_aa = mu_0 r_a left(logfrac16 r_aw-175right) \nM_bb = mu_0 r_b left(logfrac16 r_bw-175right) \nendaligned","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"We take in this case r_a = 10 text μm, r_b = 100 text μm, and w = 1 text μm. The mesh.jl script in the mesh/ directory is used to generate an unstructured tetrahedral mesh with Gmsh, saved to mesh/rings.msh, and a depiction is shown below.","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/rings-1.png\" width=\"60%\" />\n</p><br/>","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"The configuration file for the Palace simulation is rings.json. The simulation \"Type\" is \"Magnetostatic\", and we add \"SurfaceCurrent\" boundaries for applying a surface current to drive the inner or outer ring. The rest of the ring boundaries are labeled as \"PEC\" boundaries, which prescribes a zero magnetic flux, or magnetic insulation, boundary condition. The farfield is also prescribed the \"PEC\" boundary condition. We seek a second-order solution and use the geometric multigrid AMS solver.","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"The computed inductance matrix is saved to disk as postpro/terminal-M.csv, and below we show its contents:","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"include_example_file(\"rings\", \"terminal-M.csv\") # hide","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"According to the analytic expressions above, for this geometry we should have","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"M_ab = 1973921text pH","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"for the mutual inductance, and","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"beginaligned\nM_aa = 4178537text pH\nM_bb = 7072050text pH\nendaligned","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"for the self inductances. Thus, the Palace solution has percent-level errors in the self inductances versus the analytic solutions.","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"The typical approach used by Palace for lumped parameter extraction uses the computed field energies, but one can also compute the inductance by explicitly integrating the magnetic flux through a surface and dividing by the excitation current. This is configured under config[\"Boundaries\"][\"Postprocessing\"][\"Inductance\"] in the configuration file. The postprocessed magnetic flux values are written to postpro/surface-F.csv:","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"include_example_file(\"rings\", \"surface-F.csv\") # hide","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"Combining with the values in postpro/terminal-I.csv we can compute the inductance matrix in this alternative fashion,","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"include_example_file(\"rings\", \"terminal-I.csv\") # hide","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"we arrive at","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"using DelimitedFiles: readdlm #hide\nusing Printf #hide\npath = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"test\", \"examples\", \"ref\", \"rings\") #hide\nsurface_F = readdlm(joinpath(path, \"surface-F.csv\"), ',', Float64, skipstart=1) #hide\nterminal_I = readdlm(joinpath(path, \"terminal-I.csv\"), ',', Float64, skipstart=1) #hide\nresult = copy(surface_F) #hide\nresult[:, 2] ./= terminal_I[:, 2] #hide\nresult[:, 3] ./= terminal_I[:, 2] #hide\nprintln(\"        i,                M[i][1] (H),                M[i][2] (H)\") #hide\nfor i = 1:size(result, 1) #hide\n    @printf(\n        \" %.2e,        %+.12e,        %+.12e\\n\",\n        result[i, 1],\n        result[i, 2],\n        result[i, 3]\n    ) #hide\nend #hide","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"The values computed using the flux integral method are in close agreement to those above, as expected. This method of calculating the inductance matrix directly from flux values is in general less accurate than using the energy method, due to convergence properties of finite element functional outputs, but serves as a validation of the energy calculation.","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"Lastly, we visualize the magnitude of the magnetic flux density field for the excitations of the inner and outer rings. The files for this visualization are again saved to the postpro/paraview directory.","category":"page"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"<br/><p align=\"center\">\n  <img src=\"../../assets/examples/rings-2.png\" width=\"45%\" />\n  <img src=\"../../assets/examples/rings-3.png\" width=\"45%\" />\n</p>","category":"page"},{"location":"examples/rings/#References","page":"Inductance Matrix for a Pair of Concentric Rings","title":"References","text":"","category":"section"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"[1] M. R. Alizadeh Pahlavani and H. A. Mohammadpour, Inductance comparison of the solenoidal coil of modular toroidal coils using the analytical and finite element method, Progress in Electromagnetics Research 20 (2010) 337-352.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"quick/#Run-your-first-simulation-with-Palace","page":"Quick Start","title":"Run your first simulation with Palace","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Welcome to your first tutorial with Palace!","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"In this tutorial, we will:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Install Palace using Spack\nSet up a simulation using a provided mesh\nRun the simulation and visualize results","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"By the end of this page, you'll understand the basic workflow of electromagnetic simulations with Palace. You will be able to follow the examples and start experimenting with setting up and running your own simulations.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"As a motivating example, we'll solve for the electrostatic potential and capacitance matrix of two conducting spheres inside a larger grounded sphere. Our system consists of:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Two inner spherical conductors\nA larger outer sphere at zero potential\nVacuum in between","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"This is one of the examples included with Palace. For more details on the physics and comparisons against analytical results, see the full example page.","category":"page"},{"location":"quick/#A-bird's-eye-view-of-*Palace*","page":"Quick Start","title":"A bird's-eye view of Palace","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Palace is a finite-element code for PArallel LArge-scale Computational Electromagnetics. It is a command-line executable that runs on single or multiple nodes, supporting both CPUs and GPUs.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"A Palace simulation requires two main inputs:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Mesh file: The mesh file describes the target geometry. Palace does not construct meshes, so you must supply one. A large number of formats are supported, allowing you to use your preferred CAD or meshing software. See the supported mesh formats for more details.\nConfig file: A JSON file that defines what problem to solve and how. It specifies material properties, boundary conditions, problem type, solver parameters, and output settings. See the configuration documentation for complete details.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Palace can solve Maxwell's equations under a few different set of assumptions, leading to different electromagnetic problem types:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Electrostatic: Computes static electric fields and capacitance matrices (used in this tutorial)\nMagnetostatic: Computes static magnetic fields and inductance matrices\nEigenmode: Computes eigenmodes and eigenvalues in the frequency domain\nDriven: Computes frequency-domain response to harmonic excitations\nTransient: Computes time-domain response to boundary excitations","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Palace produces two types of primary output:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"CSV files with post-processed quantities (capacitance matrices, field values at probe points, etc.)\nPVD files for visualizing fields with ParaView or compatible software\nGrid function files for visualizing fields with GLVis","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"The full list of problem types and their outputs is available in the problem configuration guide.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"In this tutorial, we'll use a mesh generated with Gmsh, create a configuration file for an Electrostatic problem, and visualize the resulting electric field with ParaView and GLVis.","category":"page"},{"location":"quick/#Installing-Palace","page":"Quick Start","title":"Installing Palace","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"As a user, the simplest way to install Palace is with Spack, a package manager designed for high-performance computing applications.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Follow the instructions on the official website to install Spack. This involves cloning a repository and sourcing a setup-env shell script. Come back here once you are done with that.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Let's check that Spack is correctly installed on your system. This can be accomplished by running:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"spack --version","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"You should see your Spack version (yours may differ, that's okay):","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"logrun(`spack --version`); # hide\nnothing # hide","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"note: spack command not found\nIf you get a command not found error, revisit the Spack instructions and ensure you've completed all steps, including sourcing the setup script (the command starting with .). Consider adding this to your shell initialization file (typically, .bashrc or .zshrc).","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"With Spack installed, we can now move to Palace:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"spack install palace","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"This will download and compile the latest release of Palace and its dependencies. This step may take tens of minutes depending on your system.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Once installed, load Palace and verify it works:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"spack load palace\npalace --help","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"You should see:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"logrun(`palace --help`); # hide\nnothing # hide","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"tip: Loading Palace\nYou need to load Palace with spack load palace in each new shell session. For convenience, add this command to your shell initialization file if you are a frequent Palace user.","category":"page"},{"location":"quick/#(Optional)-Install-ParaView-and-GLVis","page":"Quick Start","title":"(Optional) Install ParaView and GLVis","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Palace optionally saves electromagnetic field data in the PVD format, which is immediately accessible by ParaView or ParaView-compatible software, and as MFEM grid functions, which can be visualized with GLVis. You can download ParaView from the official website or using your package manager (dnf, apt, brew, ...). GLVis can be downloaded from the official website. ParaView and GLVis are not required for running simulations, but we will use it in this tutorial to visualize our simulated fields.","category":"page"},{"location":"quick/#The-mesh","page":"Quick Start","title":"The mesh","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"The mesh describes the geometry over which we want to solve the problem. Constructing a mesh is not Palace's responsibility and we'll use a pre-made mesh from the Palace examples for this tutorial.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Create a mesh directory and download the mesh file:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"mkdir -p mesh\ncurl -o mesh/spheres.msh https://raw.githubusercontent.com/awslabs/palace/refs/heads/main/examples/spheres/mesh/spheres.msh","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"This mesh was created using the Julia interface for Gmsh. If you're interested in how it was created, see the mesh.jl file.","category":"page"},{"location":"quick/#Understanding-mesh-attributes","page":"Quick Start","title":"Understanding mesh attributes","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"To set up a simulation, you need to identify regions in the mesh (collections of volumes or surfaces) to assign material properties and boundary conditions. The mesh formats used within Palace all support this via a notion of Attributes. An attribute is a 1-based index within a mesh that indicates a subset of elements. The particulars of how these attributes are identified are specific to each mesh format.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Our mesh follows the msh2 format and contains four distinct regions:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"domain (3D volume, attribute: 1) - the vacuum region between spheres\nfarfield (2D surface, attribute: 2) - the outer boundary surface\nsphere_a (2D surface, attribute: 3) - the first conductor surface\nsphere_b (2D surface, attribute: 4) - the second conductor surface","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"We'll reference these attributes in our configuration file to specify boundary conditions and material properties.","category":"page"},{"location":"quick/#The-config-file","page":"Quick Start","title":"The config file","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"The configuration file defines the electromagnetic problem: what to solve for, material properties and boundary conditions, the details of the algorithm to be employed, and so on.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Palace config files contain five sections:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Problem: Defines the physics type and output settings\nModel: Specifies the mesh file and geometric parameters\nDomains: Defines material properties for 3D regions and related postprocessing operations\nBoundaries: Sets boundary conditions for 2D surfaces and related postprocessing operations\nSolver: Controls numerical parameters and solution methods","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Here's a complete configuration for our electrostatic problem:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"<div style=\"max-height: 300px; overflow-y: auto;\">","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"println(fix_attributes_format(JSON.json(spheres_json, 4))) # hide","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"</div>","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"You can save this as spheres.json or download it directly:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"curl -O https://raw.githubusercontent.com/awslabs/palace/refs/heads/main/examples/spheres/spheres.json","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Let's examine each section in detail. For complete documentation on all available options, see the configuration reference.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"If you wish to skip the explanation and jump directly to running your simulations, go to Running the simulation and inspecting the output.","category":"page"},{"location":"quick/#Section-1:-Problem-definition","page":"Quick Start","title":"Section 1: Problem definition","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"The Problem section identifies the problem type and the output directory. In this case, we choose Electrostatic. This means that Palace solves Poisson's equation for electric potential sequentially activating all the Terminals on the mesh while setting the non-activated terminals to ground. All simulation types in Palace have some form of iteration (over frequencies, times, mode numbers, or terminals). The output is saved to the \"Output\" folder specified in the \"Problem\" section in the JSON file, postpro in this example. If the output already exists, it will be overwritten. See config[\"Problem\"] for details on all available problem types and their outputs.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"print_section(spheres_json, \"Problem\") # hide","category":"page"},{"location":"quick/#Section-2:-Model-specification","page":"Quick Start","title":"Section 2: Model specification","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"The Model section specifies the desired geometry. In addition to defining the mesh, it specifies how to convert mesh units to physical units using the L0 parameter. For example, L0 of 1e-2 means that one mesh unit corresponds to one centimeter. The Model section can also include settings for adaptive mesh refinement. See config[\"Model\"] for more information.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"print_section(spheres_json, \"Model\") # hide","category":"page"},{"location":"quick/#Section-3:-Domain-properties","page":"Quick Start","title":"Section 3: Domain properties","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"The Domains section defines properties for the 3D regions in the geometry.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Each 3D region (identified by its Attribute) must have a Material definition specifying its physical properties. In our mesh, we have just one 3D region (the vacuum between the spheres and outer boundary) identified by attribute 1. While vacuum properties are applied by default, you can specify various material characteristics as detailed in config[\"Domains\"][\"Materials\"].","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"The Domains section also includes a Postprocessing subsection for calculating specific quantities. In this example, we add:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Energy, which activates integrated energy calculations in the 3D domain\nProbe, which requests field values at specific coordinates defined by a Center (in mesh units)","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"When configuring Postprocessing, you must specify an Index that determines the suffix for column headers in the output CSV files. For example, with Index: 1, the probe output will show headers like E_x[1].","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"note: What is the difference between `Attributes` and `Index`?\nAttributes identify mesh regions and come from the mesh file. In our example, attributes 1-4 identify the vacuum region, outer boundary, and two spheres.Index is used only for postprocessing and defines a notation used in the output CSV files. It has no relation to mesh attributes and can be any positive integer.Note how Attributes is an array and Index an integer: multiple attributes might be needed to specify a given region in the mesh that corresponds to a single output.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"print_section(spheres_json, \"Domains\") # hide","category":"page"},{"location":"quick/#Section-4:-Boundary-conditions","page":"Quick Start","title":"Section 4: Boundary conditions","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"The Boundaries section maps 2D surfaces in your mesh to their physical boundary conditions. Palace offers numerous boundary condition types, all documented in config[\"Boundaries\"].","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Unlike 3D regions, which all require Material specifications, 2D surfaces have default behavior: any external surface without an explicit boundary condition is treated as a Perfect Magnetic Conductor (PMC), where the tangential component of the magnetic field is zero, and no conditions are imposed on internal surfaces (since terms from either sides cancel out on such boundaries).","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"For our electrostatic problem, we define:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"The outer boundary as Ground (zero potential)\nTwo Terminal surfaces (one for each sphere)","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Terminals are particularly important for Electrostatic simulations. Palace activates each terminal sequentially (applying a unit of potential and grounding all the other ones) and solves Maxwell's equations. Each of these steps adds a new row to the output CSV files.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Like the Domains section, Boundaries also includes a Postprocessing subsection for calculating quantities such as surface fluxes across 2D regions. Here, we compute the fluxes of electric fields across the spherical conductors. See config[\"Boundaries\"] for all available postprocessing options.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"print_section(spheres_json, \"Boundaries\") # hide","category":"page"},{"location":"quick/#Section-5:-Solver-settings","page":"Quick Start","title":"Section 5: Solver settings","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Finally, the Solver section prescribes properties of the problem and the numerical algorithm, what device to use for the solution, and how much to save as PVD files. For this problem, we run on CPU, specify third-order finite elements, and save the fields for both terminal activations. The details of the linear solver parameters in \"Linear\" are not essential for this tutorial.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Other problem types typically have more extensive Solver configurations, including excitation parameters and frequency sweep settings. For complete details on all solver options, see config[\"Solver\"].","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"print_section(spheres_json, \"Solver\") # hide","category":"page"},{"location":"quick/#Running-the-simulation-and-inspecting-the-output","page":"Quick Start","title":"Running the simulation and inspecting the output","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"If you've followed along, you should now have two files:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"├── mesh\n│   └── spheres.msh\n└── spheres.json","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"note: Do not have the files?\nIf you need to download the files, run:mkdir -p mesh\ncurl -o mesh/spheres.msh https://raw.githubusercontent.com/awslabs/palace/refs/heads/main/examples/spheres/mesh/spheres.msh\ncurl -O https://raw.githubusercontent.com/awslabs/palace/refs/heads/main/examples/spheres/spheres.json","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Before running your simulation, it's a good idea to validate the configuration:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"palace --dry-run spheres.json","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"This checks for syntax errors and basic configuration issues. The validator should return:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"logrun(`palace --dry-run spheres.json`); # hide\nnothing # hide","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Finally, we are ready to run the simulation:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"palace -np 1 spheres.json","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"-np 1 instruct Palace to run with a single MPI process.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"You'll see output including mesh details, solver progress, and timing information. The amount of information can be controlled with the Verbose configuration option in the JSON file.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"<div style=\"max-height: 300px; overflow-y: auto;\">","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"logrun(`palace -np 1 spheres.json`); # hide\nnothing # hide","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"</div>","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Notice that Palace ran two iterations, one for each Terminal. Different problem types will have different iteration patterns (e.g., Driven iterating over frequencies or Transient over time steps) and many of the output CSV files are organized along these iterations.","category":"page"},{"location":"quick/#Understanding-the-output","page":"Quick Start","title":"Understanding the output","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Once the simulation is completed, you'll find a postpro directory containing:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"logrun(`ls -R postpro`); # hide\nnothing # hide","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"In addition to the palace.json, which contains metadata about the simulation (including timing information and counts), the output consists of CSV, PVD, and grid function files. You can safely ignore all the Cycle directories as their content is accessed through the corresponding PVD file. For more details on output files and formats, see the output documentation.","category":"page"},{"location":"quick/#CSV-files","page":"Quick Start","title":"CSV files","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"CSV files contain post-processed quantities and depend on the specific problem type chosen. Let's look at two examples:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"probe-E.csv shows electric field values at the probe point we defined in the Postprocessing section in \"Domains\":","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"logrun(`cat postpro/probe-E.csv`); # hide\nnothing # hide","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"The first column i indicates the iteration and corresponds to the Index associated to each Terminal, whereas the [1] in column headers corresponds to the Index we specified in the Probe section.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"One of the key outputs of the Electrostatics problem type is the capacitance matrix, saved in terminal-C.csv:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"logrun(`cat postpro/terminal-C.csv`); # hide\nnothing # hide","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Here, both rows and columns correspond to Terminal indices. As expected, the matrix is symmetric.","category":"page"},{"location":"quick/#Visualizing-with-ParaView","page":"Quick Start","title":"Visualizing with ParaView","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"In this step, we'll create a visualization of our simulation results using ParaView. We'll work with both the volume field data (electrostatic.pvd) and the boundary surface data (electrostatic_boundaries.pvd) to reproduce the figures in the example page.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Launch ParaView and navigate to your postpro/paraview directory\nOpen the volume data:\nClick File → Open → Navigate to postpro/paraview/electrostatic/electrostatic.pvd, nothing should be rendered so far\nClick the Apply button in the Properties panel (left side), a sphere should appear\nIn the Coloring section, select V, the sphere should now be colored according to the potential values\nCreate a slice to see inside:\nFrom the menu bar, select Filters → Common → Slice\nIn the Properties panel (left side), set the Origin to (0, 0, 0)\nSet the Normal to (0, 1, 0) for a vertical slice along the Y-axis\nClick Apply\nUse the mouse to rotate and zoom until you can see the outlines of both inner spheres\nAdd the boundary surfaces:\nClick File → Open → Navigate to postpro/paraview/electrostatic_boundaries/electrostatic_boundaries.pvd\nClick Apply in the Properties panel\nIn the Coloring section, select V\nThe two inner spheres should now appear with their surface potentials displayed","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Notice the time slider at the top of the ParaView window:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Frame 0: First terminal activated (first sphere at unit potential)\nFrame 1: Second terminal activated (second sphere at unit potential)\nFrame 99: Error estimates","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"You can save the visualization as an image with File → Save Screenshot, or save the entire ParaView state with File → Save State (allows reopening your complete setup later). The result should look more or less like the images below:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"<br/><p align=\"center\">\n  <img src=\"../assets/examples/spheres-3.png\" width=\"45%\" />\n  <img src=\"../assets/examples/spheres-4.png\" width=\"45%\" />\n</p>","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"ParaView offers many more advanced features for data analysis and visualization. For more details, refer to the official ParaView documentation.","category":"page"},{"location":"quick/#Visualizing-with-GLVis","page":"Quick Start","title":"Visualizing with GLVis","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"In this optional step, we'll create a visualization of our simulation results using GLVis.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"The potential field V with the first terminal activated can be visualized with","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"glvis -m postpro/gridfunction/electrostatic/mesh -g postpro/gridfunction/electrostatic/V_000001.gf -np 1","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Note that -np 1 instructs GLVis that the data was generated with a single MPI process. The number must match the number of MPI processes used in Palace.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"To visualize the potential field along the middle x-z plane:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Press c to display the colorbar.\nPress a to display the axes.\nPress i to cut the domain.\nPress y or Y repeatedly to rotate the cutting plane until it is aligned with the x-z plane.\nPress R to cycle through 2D projections until you are viewing the x-z plane.\nPress S to take a screenshot.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"The result should look more or less like what we have below, where we embed a Javascript version of GLVis (GLVis-js) that can be interacted with in almost the same way as the native GLVis. See Documentation for full list of keys.","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"<div id=\"glvis-container\" style=\"width: 100%; height: 500px;\">\n  <div id=\"glvis-div\" style=\"width: 100%; height: 100%;\" tabindex=\"0\"></div>\n</div>\n\n<!-- Note, the snippet below only works with one MPI process because we are\n    manually composing a stream file. -->\n<script type=\"text/javascript\">\n  var div = document.getElementById(\"glvis-div\");\n  require([\"../assets/js/glvis/index.js\"], function (glvis) {\n    var glv = new glvis.State(div);\n\n    Promise.all([\n      fetch('../postpro/gridfunction/electrostatic/mesh.000000').then(r => r.text()),\n      fetch('../postpro/gridfunction/electrostatic/V_000001.gf.000000').then(r => r.text())\n    ]).then(function(results) {\n      var stream = \"solution\\n\" + results[0] + results[1] + \"keys OOOOOOOOOyyyyyyyyyyyyyyyyyyRRRRcai\\n\";\n      var originalTitle = document.title;\n      glv.display(stream).then(function() {\n        document.title = originalTitle;\n        div.focus();\n      });\n    }).catch(function(e) {\n      console.error('Failed to load GLVis data:', e);\n    });\n  });\n</script>","category":"page"},{"location":"quick/#Where-to-go-next","page":"Quick Start","title":"Where to go next","text":"","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Congratulations! You've completed your first Palace simulation. To continue learning:","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"Try looking at the other output files in this simulation\nTry modifying this example with different materials or boundary conditions\nExplore the examples to see different problem types and more complex geometries\nRead the configuration reference to understand all available options","category":"page"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"If you encounter any issues or have questions, please report them to our GitHub issue tracker.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"config/boundaries/#config[\"Boundaries\"]","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Boundaries\":\n{\n    \"PEC\":\n    {\n        ...\n    },\n    \"PMC\":\n    {\n        ...\n    },\n    \"Impedance\":\n    [\n        ...\n    ],\n    \"Absorbing\":\n    {\n        ...\n    },\n    \"Conductivity\":\n    [\n        ...\n    ],\n    \"LumpedPort\":\n    [\n        ...\n    ],\n    \"WavePort\":\n    [\n        ...\n    ],\n    \"WavePortPEC\":\n    {\n        ...\n    },\n    \"SurfaceCurrent\":\n    [\n        ...\n    ],\n    \"Ground\":\n    {\n        ...\n    },\n    \"ZeroCharge\":\n    {\n        ...\n    },\n    \"Terminal\":\n    [\n        ...\n    ],\n    \"Periodic\":\n    {\n        ...\n    },\n    \"Postprocessing\":\n    {\n        \"SurfaceFlux\":\n        [\n            ...\n        ],\n        \"Dielectric\":\n        [\n            ...\n        ]\n        \"FarField\":\n        {\n            ...\n        }\n    }\n}","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"PEC\" :  Top-level object for configuring perfect electric conductor (PEC) boundary conditions (zero tangential electric field).","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"PMC\" :  Top-level object for configuring perfect magnetic conductor (PMC) boundary conditions (zero tangential magnetic field). Also imposes symmetry of the electric field across the boundary surface.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Impedance\" :  Array of objects for configuring surface impedance boundary conditions. A surface impedance boundary relates the tangential electric and magnetic fields on the boundary using a user specified surface impedance.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Absorbing\" : Top-level object for configuring absorbing boundary conditions. These are artificial scattering boundary conditions at farfield boundaries.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Conductivity\" :  Array of objects for configuring finite conductivity surface impedance boundary conditions. Finite conductivity boundaries are only available for frequency domain driven and eigenmode simulation types.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"LumpedPort\" :  Array of objects for configuring lumped port boundary conditions. Lumped ports can be specified on boundaries which are internal to the computational domain.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"WavePort\" :  Array of objects for configuring numeric wave port boundary conditions. Wave ports can only be specified on boundaries which are on the true boundary of the computational domain. Additionally, wave port boundaries are only available for frequency domain driven and eigenmode simulation types.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"WavePortPEC\" :  Top-level object for configuring additional PEC boundary conditions for boundary mode analysis performed on the wave port boundaries. Thus, this object is only relevant when wave port boundaries are specified under config[\"Boundaries\"][\"WavePort\"].","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"SurfaceCurrent\" :  Array of objects for configuring surface current boundary conditions. This boundary prescribes a unit source surface current excitation on the given boundary in order to excite a frequency or time domain driven simulation or magnetostatic simulation. For the magnetostatic simulation type, entries of the inductance matrix are extracted corresponding to each surface current boundary.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Ground\" :  Top-level object for specifying ground, or zero voltage, boundary conditions for for electrostatic simulations.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"ZeroCharge\" :  Top-level object for specifying zero charge boundary conditions for for electrostatic simulations. Also imposes symmetry of the electric field across the boundary surface.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Terminal\" :  Array of objects for configuring terminal boundary conditions for electrostatic simulations. Entries of the capacitance matrix are extracted corresponding to each terminal boundary.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Periodic\" :  Top-level object for configuring periodic boundary conditions for surfaces with meshes that are identical after translation and/or rotation.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Postprocessing\" :  Top-level object for configuring boundary postprocessing.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"SurfaceFlux\" :  Array of objects for postprocessing surface flux.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Dielectric\" :  Array of objects for postprocessing surface interface dielectric loss.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"FarField\" :  Top-level object for extracting electric fields in the far-field region.","category":"page"},{"location":"config/boundaries/#boundaries[\"PEC\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"PEC\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"PEC\":\n{\n    \"Attributes\": [<int array>]\n}","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] :  Integer array of mesh boundary attributes at which to apply the PEC boundary condition.","category":"page"},{"location":"config/boundaries/#boundaries[\"PMC\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"PMC\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"PMC\":\n{\n    \"Attributes\": [<int array>]\n}","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] :  Integer array of mesh boundary attributes at which to apply the PMC boundary condition.","category":"page"},{"location":"config/boundaries/#boundaries[\"Impedance\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Impedance\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Impedance\":\n[\n    {\n        \"Attributes\": [<int array>],\n        \"Rs\": <float>,\n        \"Ls\": <float>,\n        \"Cs\": <float>\n    },\n    ...\n]","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] :  Integer array of mesh boundary attributes for this surface impedance boundary.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Rs\" [0.0] :  Surface resistance used for computing this surface impedance boundary's impedance per square, Omega/sq.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Ls\" [0.0] :  Surface inductance used for computing this surface impedance boundary's impedance per square, H/sq.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Cs\" [0.0] :  Surface capacitance used computing this surface impedance boundary's impedance per square, F/sq.","category":"page"},{"location":"config/boundaries/#boundaries[\"Absorbing\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Absorbing\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Absorbing\":\n{\n    \"Attributes\": [<int array>],\n    \"Order\": <int>\n}","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] :  Integer array of mesh boundary attributes at which to apply farfield absorbing boundary conditions.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Order\" [1] :  Specify a first- or second-order approximation for the farfield absorbing boundary condition. Second-order absorbing boundary conditions are only available for the frequency domain driven simulation type.","category":"page"},{"location":"config/boundaries/#boundaries[\"Conductivity\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Conductivity\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Conductivity\":\n[\n    {\n        \"Attributes\": [<int array>],\n        \"Conductivity\": <float>,\n        \"Permeability\": <float>,\n        \"Thickness\": <float>\n    },\n    ...\n]","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] :  Integer array of mesh boundary attributes for this finite conductivity boundary.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Conductivity\" [None] :  Electrical conductivity for this finite conductivity boundary, S/m.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Permeability\" [1.0] :  Relative permeability for this finite conductivity boundary.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Thickness\" [None] :  Optional conductor thickness for this finite conductivity boundary specified in mesh length units. Activates a finite conductivity boundary condition which accounts for nonzero metal thickness.","category":"page"},{"location":"config/boundaries/#boundaries[\"LumpedPort\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"LumpedPort\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"LumpedPort\":\n[\n    {\n        \"Index\": <int>,\n        \"Attributes\": [<int array>],\n        \"Direction\": <string> or [<float array>],\n        \"CoordinateSystem\": <string>,\n        \"Excitation\": <bool>,\n        \"Active\": <bool>,\n        \"R\": <float>,\n        \"L\": <float>,\n        \"C\": <float>,\n        \"Rs\": <float>,\n        \"Ls\": <float>,\n        \"Cs\": <float>,\n        \"Elements\":\n        [\n            {\n                \"Attributes\": <string>,\n                \"Direction\": <string> or [<float array>],\n                \"CoordinateSystem\": <string>\n            },\n            ...\n        ]\n    },\n    ...\n]","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Index\" [None] :  Index of this lumped port, used in postprocessing output files.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] :  Integer array of mesh boundary attributes for this lumped port boundary. If this port is to be a multielement lumped port with more than a single lumped element, use the \"Elements\" array described below.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Direction\" [None] :  Direction to define the polarization direction of the port field mode on this lumped port boundary. Axis aligned lumped ports can be specified using keywords: \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\", while coaxial lumped ports can be specified using \"+R\", \"-R\". The direction can alternatively be specified as a normalized array of three values, for example [0.0, 1.0, 0.0]. If a vector direction is specified, the \"CoordinateSystem\" value specifies the coordinate system it is expressed in. If this port is to be a multielement lumped port with more than a single lumped element, use the \"Elements\" array described below.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"CoordinateSystem\" [\"Cartesian\"] : Coordinate system used to express the \"Direction\" vector, the options are \"Cartesian\" and \"Cylindrical\". If a keyword argument is used for \"Direction\" this value is ignored, and the appropriate coordinate system is used instead.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Excitation\" [false/0] :  Turns on or off port excitation for this lumped port boundary for driven or transient simulation types. Can be specified either as a bool or as a non-negative integer — see Boundary Conditions.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Active\" [true] :  Turns on or off damping boundary condition for this lumped port boundary for driven or transient simulation types.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"R\" [0.0] :  Circuit resistance used for computing this lumped port boundary's impedance, Omega. This option should only be used along with the corresponding \"L\" and \"C\" parameters, and not with any of the surface parameters \"Rs\", \"Ls\", or \"Cs\".","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"L\" [0.0] :  Circuit inductance used for computing this lumped port boundary's impedance, H. This option should only be used along with the corresponding \"R\" and \"C\" parameters, and not with any of the surface parameters \"Rs\", \"Ls\", or \"Cs\".","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"C\" [0.0] :  Circuit capacitance used for computing this lumped port boundary's impedance, F. This option should only be used along with the corresponding \"R\" and \"L\" parameters, and not with any of the surface parameters \"Rs\", \"Ls\", or \"Cs\".","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Rs\" [0.0] :  Surface resistance used for computing this lumped port boundary's impedance, Omega/sq. This option should only be used along with the corresponding \"Ls\" and \"Cs\" parameters, and not with any of the circuit parameters \"R\", \"L\", or \"C\".","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Ls\" [0.0] :  Surface inductance used for computing this lumped port boundary's impedance, H/sq. This option should only be used along with the corresponding \"Rs\" and \"Cs\" parameters, and not with any of the circuit parameters \"R\", \"L\", or \"C\".","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Cs\" [0.0] :  Surface capacitance used for computing this lumped port boundary's impedance, F/sq. This option should only be used along with the corresponding \"Rs\" and \"Ls\" parameters, and not with any of the circuit parameters \"R\", \"L\", or \"C\".","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Elements\"[][\"Attributes\"] [None] :  This option is for multielement lumped ports and should not be combined with the \"Attributes\" field described above. Each element of a multielement lumped port can be described by its own unique integer array of mesh boundary attributes, which are specified here. The elements of a multielement port add in parallel.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Elements\"[][\"Direction\"] [None] :  This option is for multielement lumped ports and should not be combined with the \"Direction\" field described above. Each element of a multielement lumped port can be described by its own unique direction, which is specified here. The elements of a multielement port add in parallel.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Elements\"[][\"CoordinateSystem\"] [\"Cartesian\"] :  This option is for multielement lumped ports and should not be combined with the \"CoordinateSystem\" field described above. Each element of a multielement lumped port can be described by its own unique direction, and corresponding coordinate system.","category":"page"},{"location":"config/boundaries/#boundaries[\"WavePort\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"WavePort\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"WavePort\":\n[\n    {\n        \"Index\": <int>,\n        \"Attributes\": [<int array>],\n        \"Excitation\": <bool>,\n        \"Active\": <bool>,\n        \"Mode\": <int>,\n        \"Offset\": <float>,\n        \"SolverType\": <string>,\n        \"MaxIts\": <int>,\n        \"KSPTol\": <float>,\n        \"EigenTol\": <float>,\n        \"Verbose\": <int>\n    },\n    ...\n]","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Index\" [None] :  Index of this wave port boundary, used in postprocessing output files.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] :  Integer array of mesh boundary attributes for this wave port boundary.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Excitation\" [false/0] :  Turns on or off port excitation for this wave port boundary for driven simulation types. Can be specified either as a bool or as a non-negative integer — see Boundary Conditions.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Active\" [true] :  Turns on or off damping boundary condition for this wave port boundary for driven simulation types.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Mode\" [1] :  Mode index (1-based) for the characteristic port mode of this wave port boundary. Ranked in order of decreasing wave number.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Offset\" [0.0] :  Offset distance used for scattering parameter de-embedding for this wave port boundary, specified in mesh length units.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"SolverType\" [\"Default\"] :  Specifies the eigenvalue solver to be used in computing the boundary mode for this wave port. See config[\"Solver\"][\"Eigenmode\"][\"Type\"].","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"MaxIts\" [30] :  Specifies the maximum number of iterations to be used in the GMRES solver.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"KSPTol\" [1e-8] :  Specifies the tolerance to be used in the linear solver.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"EigenTol\" [1e-6] :  Specifies the tolerance to be used in the eigenvalue solver.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Verbose\" [0] :  Specifies the verbosity level to be used in the linear and eigensolver for the wave port problem.","category":"page"},{"location":"config/boundaries/#boundaries[\"WavePortPEC\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"WavePortPEC\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"WavePortPEC\":\n{\n    \"Attributes\": [<int array>]\n}","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] :  Integer array of mesh boundary attributes to consider as PEC when solving the 2D eigenproblem for the wave port boundary mode analysis, along with those specified under config[\"Boundaries\"][\"PEC\"][\"Attributes\"] and config[\"Boundaries\"][\"Conductivity\"][\"Attributes\"].","category":"page"},{"location":"config/boundaries/#boundaries[\"SurfaceCurrent\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"SurfaceCurrent\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"SurfaceCurrent\":\n[\n    {\n        \"Index\": <int>,\n        \"Attributes\": [<int array>],\n        \"Direction\": <string> or [<float array>],\n        \"CoordinateSystem\": <string>,\n        \"Elements\":\n        [\n            {\n                \"Attributes\": [<int array>],\n                \"Direction\": <string> or [<float array>],\n                \"CoordinateSystem\": <string>,\n            },\n            ...\n        ]\n    },\n    ...\n]","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Index\" [None] :  Index of this surface current boundary, used in postprocessing output files.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] :  Integer array of mesh boundary attributes for this surface current boundary. If this source is to be a multielement source which distributes the source across more than a single lumped element, use the \"Elements\" array described below.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Direction\" [None] :  Defines the source current direction for this surface current boundary. The available options are the same as under config[\"Boundaries\"][\"LumpedPort\"][\"Direction\"]. If this source is to be a multielement source which distributes the source across more than a single lumped element, use the \"Elements\" array described below.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"CoordinateSystem\" [\"Cartesian\"] :  Defines the coordinate system for the source current direction for this surface current boundary. The available options are the same as under config[\"Boundaries\"][\"LumpedPort\"][\"CoordinateSystem\"]. If this source is to be a multielement source which distributes the source across more than a single lumped element, use the \"Elements\" array described below.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Elements\"[][\"Attributes\"] [None] :  This option is for multielement surface current boundaries should not be combined with the \"Attributes\" field described above. Each element of a multielement current source can be described by its own unique integer array of mesh boundary attributes, which are specified here. The elements of a multielement source add in parallel to give the same total current as a single-element source.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Elements\"[][\"Direction\"] [None] :  This option is for multielement surface current boundaries and should not be combined with the \"Direction\" field described above. Each element of a multielement current source can be described by its own unique direction, which is specified here. The elements of a multielement source add in parallel to give the same total current as a single-element source.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Elements\"[][\"CoordinateSystem\"] [\"Cartesian\"] :  This option is for multielement surface current boundaries and should not be combined with the \"CoordinateSystem\" field described above. Each element of a multielement current source can be described by its own unique direction, and corresponding coordinate system.","category":"page"},{"location":"config/boundaries/#boundaries[\"Ground\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Ground\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Ground\":\n{\n    \"Attributes\": [<int array>]\n}","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] :  Integer array of mesh boundary attributes at which to apply the ground boundary condition.","category":"page"},{"location":"config/boundaries/#boundaries[\"ZeroCharge\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"ZeroCharge\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"ZeroCharge\":\n{\n    \"Attributes\": [<int array>]\n}","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] :  Integer array of mesh boundary attributes at which to apply the zero-charge boundary condition.","category":"page"},{"location":"config/boundaries/#boundaries[\"Terminal\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Terminal\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Terminal\":\n[\n    {\n        \"Index\": <int>,\n        \"Attributes\": [<int array>],\n    },\n    ...\n]","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Index\" [None] :  Index of this terminal boundary, used in postprocessing output files and to index the computed capacitance matrix.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] :  Integer array of mesh boundary attributes for this terminal boundary.","category":"page"},{"location":"config/boundaries/#boundaries[\"Periodic\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Periodic\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Periodic\":\n{\n    \"FloquetWaveVector\": [<float array>],\n    \"BoundaryPairs\":\n    [\n        {\n            \"DonorAttributes\": [<int array>],\n            \"ReceiverAttributes\": [<int array>],\n            \"Translation\": [<float array>],\n            \"AffineTransformation\": [<float array>],\n        },\n        ...\n    ]\n}","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"DonorAttributes\" [None] :  Integer array of the donor attributes of the mesh boundary attributes for this periodic boundary.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"ReceiverAttributes\" [None] :  Integer array of the receiver attributes of the mesh boundary attributes for this periodic boundary.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Translation\" [None] :  Optional floating point array defining the distance from the donor attribute to the receiver attribute in mesh units. If neither \"Translation\" nor \"AffineTransformation\" are specified, the transformation between donor and receiver boundaries is automatically detected.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"AffineTransformation\" [None] :  Optional floating point array of size 16 defining the three-dimensional (4 x 4) affine transformation matrix (in row major format) from the donor attribute to the receiver attribute in mesh units. If neither \"Translation\" or \"AffineTransformation\" are specified, the transformation between donor and receiver boundaries is automatically detected.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"FloquetWaveVector\" [None] :  Optional floating point array defining the phase delay between the periodic boundaries in the X/Y/Z directions in radians per mesh unit.","category":"page"},{"location":"config/boundaries/#boundaries[\"Postprocessing\"][\"SurfaceFlux\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Postprocessing\"][\"SurfaceFlux\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Postprocessing\":\n{\n    \"SurfaceFlux\":\n    [\n        {\n            \"Index\": <int>,\n            \"Attributes\": [<int array>],\n            \"Type\": <string>,\n            \"TwoSided\": <bool>,\n            \"Center\": [<float array>]\n        },\n        ...\n    ]\n}","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Index\" [None] :  Index of this surface flux postprocessing boundary, used in postprocessing output files.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] :  Integer array of mesh boundary attributes for this surface flux postprocessing boundary.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Type\" [None] :  Specifies the type of surface flux to calculate for this postprocessing boundary. The available options are:","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Electric\" :  Integrate the electric flux density over the boundary surface.\n\"Magnetic\" :  Integrate the magnetic flux density over the boundary surface.\n\"Power\" :  Integrate the energy flux density, given by the Poynting vector, over the boundary surface.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"TwoSided\" [false] :  Specifies how to account for internal boundary surfaces with a possible discontinuous field on either side. When set to false, the flux on either side of an internal boundary surface is averaged. When true, it is summed with an opposite normal direction.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Center\" [None] :  Floating point array of length equal to the model spatial dimension specifying the coordinates of a central point used to compute the outward flux. The true surface normal is used in the calculation, and this point is only used to ensure the correct orientation of the normal. Specified in mesh length units, and only relevant when \"TwoSided\" is false. If not specified, the point will be computed as the centroid of the axis-aligned bounding box for all elements making up the postprocessing boundary.","category":"page"},{"location":"config/boundaries/#boundaries[\"Postprocessing\"][\"Dielectric\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Postprocessing\"][\"Dielectric\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Postprocessing\":\n{\n    \"Dielectric\":\n    [\n        {\n            \"Index\": <int>,\n            \"Attributes\": [<int array>],\n            \"Type\": <string>,\n            \"Thickness\": <float>,\n            \"Permittivity\": <float>,\n            \"LossTan\": <float>\n        },\n        ...\n    ]\n}","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Index\" [None] :  Index of this dielectric interface, used in postprocessing output files.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] :  Integer array of mesh boundary attributes for this dielectric interface.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Type\" [None] :  Specifies the type of dielectric interface for this postprocessing boundary. See also this page. Available options are:","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Default\" :  Use the full electric field evaluated at the boundary to compute the energy participation ratio (EPR) of this dielectric interface and estimate loss.\n\"MA\" :  Use the boundary conditions assuming a metal-air interface to compute the EPR of this dielectric interface.\n\"MS\" :  Use the boundary conditions assuming a metal-substrate interface to compute the EPR of this dielectric interface.\n\"SA\" :  Use the boundary conditions assuming a substrate-air interface to compute the EPR of this dielectric interface.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Thickness\" [None] :  Thickness of this dielectric interface, specified in mesh length units.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Permittivity\" [None] :  Relative permittivity for this dielectric interface. This should be the interface layer permittivity for the specific \"Type\" of interface specified.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"LossTan\" [0.0] :  Loss tangent for this lossy dielectric interface.","category":"page"},{"location":"config/boundaries/#boundaries[\"Postprocessing\"][\"FarField\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Postprocessing\"][\"FarField\"]","text":"","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Postprocessing\":\n{\n    \"FarField\":\n    {\n        \"Attributes\": [<int array>],\n        \"NSample\": <int>,\n        \"ThetaPhis\": [<array of pairs of floats>]\n    }\n}","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"with","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Attributes\" [None] : Integer array of mesh boundary attributes to be used to compute the far fields. It has to be an external boundary and enclose the system.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"NSample\" [0] : Number of uniformly-spaced points to use to discretize the far-field sphere.","category":"page"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"ThetaPhi\" [None] : Evaluate the far-field electric field at these specific angles too (in degrees). theta in 0 180 is the polar angle and phi in 0 360 is the azimuthal angle.","category":"page"},{"location":"guide/parallelism/","page":"Parallelism and GPU Support","title":"Parallelism and GPU Support","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"guide/parallelism/#Parallelism-and-GPU-Support","page":"Parallelism and GPU Support","title":"Parallelism and GPU Support","text":"","category":"section"},{"location":"guide/parallelism/","page":"Parallelism and GPU Support","title":"Parallelism and GPU Support","text":"Palace employs multiple types of parallelism in an attempt to maximize performance across a wide range of deployment possibilities. The first is MPI-based distributed-memory parallelism. This is controlled using the -np command line flag as outlined in Running Palace.","category":"page"},{"location":"guide/parallelism/","page":"Parallelism and GPU Support","title":"Parallelism and GPU Support","text":"Shared-memory parallelism using OpenMP is also available. To enable this, the -DPALACE_WITH_OPENMP=ON option should be specified at configure time. At runtime, the number of threads is configured with the -nt argument to the palace executable, or by setting the OMP_NUM_THREADS environment variable.","category":"page"},{"location":"guide/parallelism/","page":"Parallelism and GPU Support","title":"Parallelism and GPU Support","text":"Lastly, Palace supports GPU-acceleration using NVIDIA and AMD GPUs, activated with the build options -DPALACE_WITH_CUDA=ON and -DPALACE_WITH_HIP=ON, respectively. At runtime, the config[\"Solver\"][\"Device\"] parameter in the configuration file can be set to \"CPU\" (the default) or \"GPU\" in order to configure Palace and MFEM to use the available GPU device or devices. The config[\"Solver\"][\"Backend\"] parameter, on the other hand, controls the libCEED backend. Users typically do not need to provide a value for this option and can instead rely on Palace's default, which selects the most appropriate backend for the given value of config[\"Solver\"][\"Device\"].","category":"page"},{"location":"guide/parallelism/","page":"Parallelism and GPU Support","title":"Parallelism and GPU Support","text":"In order to take full advantage of the performance benefits made available by GPU- acceleration, it is recommended to make use of operator partial assembly, activated when the value of config[\"Solver\"][\"PartialAssemblyOrder\"] is less than config[\"Solver\"][\"Order\"]. This feature avoids assembling a global sparse matrix and instead makes use of data structures for operators which lend themselves to more efficient asymptotic storage and application costs. See also https://libceed.org/en/latest/intro/ for more details. Partial assembly in Palace supports mixed meshes including both tensor product elements (hexahedra and quadrilaterals) as well as non-tensor product elements (tetrahedra, prisms, pyramids, and triangles).","category":"page"},{"location":"guide/guide/","page":"Overview","title":"Overview","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"guide/guide/#Overview","page":"Overview","title":"Overview","text":"","category":"section"},{"location":"guide/guide/","page":"Overview","title":"Overview","text":"This user guide provides an overview of the different types of electromagnetic simulations which can be performed with Palace and the various features available in the solver.","category":"page"},{"location":"guide/guide/#Contents","page":"Overview","title":"Contents","text":"","category":"section"},{"location":"guide/guide/","page":"Overview","title":"Overview","text":"Problem Types\nSimulation Models\nBoundary Conditions\nPostprocessing and Visualization\nParallelism and GPU Support","category":"page"},{"location":"","page":"Home","title":"Home","text":"<!--- Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved. --->\n<!--- SPDX-License-Identifier: Apache-2.0 --->","category":"page"},{"location":"#Palace:-3D-Finite-Element-Solver-for-Computational-Electromagnetics","page":"Home","title":"Palace: 3D Finite Element Solver for Computational Electromagnetics","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Palace, for PArallel LArge-scale Computational Electromagnetics, is an open-source, parallel finite element code for full-wave 3D electromagnetic simulations in the frequency or time domain, using the MFEM finite element discretization library and libCEED library for efficient exascale discretizations.","category":"page"},{"location":"#Key-features","page":"Home","title":"Key features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Eigenmode calculations with optional material or radiative loss including lumped impedance boundaries. Automatic postprocessing of energy-participation ratios (EPRs) for circuit quantization and interface or bulk participation ratios for predicting dielectric loss.\nFrequency domain driven simulations with surface current excitation and lumped or numeric wave port boundaries. Wideband frequency response calculation using uniform frequency space sampling or an adaptive fast frequency sweep algorithm.\nExplicit or fully-implicit time domain solver for transient electromagnetic analysis.\nLumped capacitance and inductance matrix extraction via electrostatic and magnetostatic problem formulations.\nSupport for a wide range of mesh file formats for structured and unstructured meshes, with built-in uniform or region-based parallel mesh refinement.\nSolution-based Adaptive Mesh Refinement (AMR) for all simulation types aside from transient. Nonconformal refinement is supported for all mesh types, and conformal refinement for simplex meshes.\nArbitrary high-order finite element spaces and curvilinear mesh support thanks to the MFEM library.\nScalable algorithms for the solution of linear systems of equations, including matrix-free p-multigrid utilizing high-order operator partial assembly, parallel sparse direct solvers, and algebraic multigrid (AMG) preconditioners, for fast performance on platforms ranging from laptops to HPC systems.\nSupport for hardware acceleration using NVIDIA or AMD GPUs, including multi-GPU parallelism, using pure CUDA and HIP code as well as MAGMA and other libraries.","category":"page"},{"location":"#Contents","page":"Home","title":"Contents","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Installation\nExecution\nUser Guide\nConfiguration File\nExamples\nReference\nDeveloper Notes","category":"page"},{"location":"#Coming-soon","page":"Home","title":"Coming soon","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Improved adaptive mesh refinement (AMR) support for transient simulations\nPerfectly matched layer (PML) boundaries\nAutomatic mesh generation and optimization","category":"page"}]
}
