var documenterSearchIndex = {"docs":
[{"location":"features/farfield/","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"features/farfield/#Extracting-Fields-in-the-Radiation-Zone","page":"Extracting Fields in the Radiation Zone","title":"Extracting Fields in the Radiation Zone","text":"When run in the Driven or Eigenmode modes, Palace can extrapolate fields from the near-field region (being simulated) to the far-field zone. This capability can be used to study the radiative properties of a system.\n\nThe mathematical details on how this is accomplished are available in the reference. The key points are as follows:\n\nComputing fields requires evaluation of surface integrals, so users must specify a surface of integration (more on this later).\nFor the result to be physically accurate, it is important to properly model the propagation of waves to infinity. This can be accomplished by enclosing the system inside a sphere or box and applying config[\"Boundaries\"][\"Absorbing\"] boundary conditions.\nThe result is provided as complex vectors r mathbfE(theta phi), where (theta phi) identify a point on sphere at infinite distance and the result is defined up to a global phase.\n\nPalace outputs rmathbfE because this is a well-defined, finite quantity (mathbfE itself goes to zero at infinity as 1/r). You can also think of this as the electric field measured at a distance of one unit of length. With this output, you can immediately compute various quantities of interest. For instance, rmathbfE^2 gives the relative radiative power.\n\nwarning: Limitations\nPalace only supports propagation of fields to infinity when the integration surfaceis an external boundary\ndoes not cross anisotropic materials","category":"section"},{"location":"features/farfield/#Setup","page":"Extracting Fields in the Radiation Zone","title":"Setup","text":"A typical setup consists of starting from the system under consideration and enclosing the system inside an outer boundary (typically a sphere or a box), if it is not already. Then, we set \"Absorbing\" boundary conditions on this surface and choose it as the surface for the integration. For best accuracy, it is a good idea to make sure that this outer boundary is meshed finely enough to resolve the expected wavelength.\n\nTurning on far-field extraction requires activating the feature in the configuration JSON file. To do so, we look at the \"FarField\" section under \"Postprocessing\" in \"Boundaries\". Here, we need to specify the identifier of the integration surface in \"Attributes\" and specify how we want to sample the sphere at infinity. As in many other parts of Palace, \"Attributes\" expects a vector, as it can happen the boundary is split in multiple pieces.\n\nOnce we define the surface of integration, we need to specify where we want to evaluate target far-field points. The simplest way to do this is by setting \"NSample\", so that the far-field sphere is uniformly sampled with NSample points. (Note that uniform on a sphere means that the polar angle theta of the sampled points is not uniformly distributed, to avoid bunching of points on the poles.)\n\nOften, uniform sampling on the far-field sphere might be a good first step, but not the best way to accurately capture the radiative properties (e.g., when the radiation is highly directional). In this case, you can specify at what angles theta phi you want to evaluate the fields. This is done by passing 2-vectors to the \"ThetaPhis\" array with the angular coordinates of your choosing (in degrees).\n\nThis can be combined with scripts to target specific regions. For instance, the following Python code produces the required \"ThetaPhis\" section to sample over the xy plane:\n\nimport json\ndphi = 1  # degree\nprint(json.dumps({\"ThetaPhis\": [[90.0, p] for p in range(0, 361, dphi)]}))\n\nBoth \"NSample\" and \"ThetaPhis\" can be specified simultaneously and the results will be combined and duplicates removed.","category":"section"},{"location":"features/farfield/#Output","page":"Extracting Fields in the Radiation Zone","title":"Output","text":"Once a simulation is run, Palace generates a CSV file named farfield-rE.csv in the folder specified by the config[\"Problem\"][\"Output\"] configuration.\n\nThe CSV contains a header line that describes the columns, and one row for each (theta phi) pair. The columns are:\n\nf (GHz) : Frequency\ntheta (deg.) : Polar angle in degrees\nphi (deg.) : Azimuthal angle in degrees\nr*Re{E_x} (V), r*Im{E_x} (V) : Real and imaginary parts of r E_x component\nr*Re{E_y} (V), r*Im{E_y} (V) : Real and imaginary parts of r E_y component\nr*Re{E_z} (V), r*Im{E_z} (V) : Real and imaginary parts of r E_z component\n\nAll field values are in SI units.\n\nTo obtain the magnetic fields, you can assume that propagation occurs in free space, so that\n\nr mathbfH_p(mathbfr_0) = fracmathbfr_0 times r mathbfE_p(mathbfr_0)Z_0\n\nwith Z_0 impedance of free space.\n\nThis type of output can be processed by several different packages and languages. For instance, see the antenna example for an example of a Julia script that plots antenna patterns.","category":"section"},{"location":"examples/coaxial/","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"examples/coaxial/#Signal-Propagation-in-a-Coaxial-Cable","page":"Signal Propagation in a Coaxial Cable","title":"Signal Propagation in a Coaxial Cable","text":"note: Note\nThe files for this example can be found in the examples/coaxial/ directory of the Palace source code.\n\nPalace can perform transient electromagnetic modeling, acting as a so-called finite element time domain (FETD) solver. To demonstrate this feature, we consider here the propagation of an electromagnetic pulse through a section of coaxial cable. The model is constructed based on a 50text Omega RG-401/U coaxial cable [1], with outer and inner conductor diameters of 0215text in and 00645text in, respectively. The section length is roughly 15text in. The Teflon dielectric material has varepsilon_r = 208, and we consider tandelta = 4times 10^-2, a factor of 100 above the actual value in order to exaggerate losses in the transmission line.\n\nIn this example we consider three different configurations of the model, all with a coaxial lumped port excitation at one end of the line: an open termination at the opposite end (coaxial_open.json), a shorted termination (coaxial_short.json), and a matched 50text Omega lumped port termination (coaxial_matched.json).\n\nThe mesh is generated using the Julia code in mesh/mesh.jl and consists of quadratically-curved hexahedral elements, as depicted below. Third-order shape functions are used to approximate the solution.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/coaxial-1.png\" width=\"60%\" />\n</p><br/>\n\nEach configuration file sets the simulation \"Type\" to \"Transient\". The different termination configurations are specified by using a \"LumpedPort\" with matched impedance for the matched termination, a \"PEC\" boundary for the shorted termination, leaving no boundary condition specified for the open termination. This last case applies the natural boundary condition for the finite element formulation which is a perfect magnetic conductor boundary condition, enforcing zero tangential magnetic field and thus zero surface current density.\n\nThe excitation pulse is configured under config[\"Solver\"][\"Transient\"]. Here, we use a modulated Gaussian pulse shape, with time dependence given by the expression\n\ng(t) = sinleftomega(t-t_0)right e^-frac(t-t_0)^22tau^2 \n\nFor this simulation, we use a center frequency f = omega2pi = 10text GHz and pulse width tau = 005text ns. The offset t_0 is automatically chosen by Palace in order to smoothly ramp up the excitation from the rest initial condition. Time integration uses the second-order implicit Generalized-alpha scheme with a uniform time step Delta t = 5times 10^-3text ns, and the solution is computed for the interval tin0010text ns. The electric and magnetic field solutions are sampled every 10 time steps for visualization.\n\nBelow, we plot the time histories of the port voltage at the excited coaxial lumped port for the three simulation cases.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/coaxial-2.png\" width=\"70%\" />\n</p><br/>\n\nWe can observe that as expected, the matched termination absorbs the incident waveform nearly perfectly, while it is reflected with the same polarity for the shorted termination and opposite polarity for the open termination (phase shifted by pi). Furthermore, the reflected wave is noticeably attenuated due to the material loss of the transmission line dielectric.\n\nLastly, an animation of the signal propagation for the matched (left) and shorted (right) simulations, constructed using the saved fields, is shown below.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/coaxial-3.gif\" width=\"90%\" />\n</p>","category":"section"},{"location":"examples/coaxial/#References","page":"Signal Propagation in a Coaxial Cable","title":"References","text":"[1] D. M. Pozar, Microwave Engineering, Wiley, Hoboken, NJ, 2012.","category":"section"},{"location":"config/config/","page":"Overview","title":"Overview","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"config/config/#Overview","page":"Overview","title":"Overview","text":"A configuration file written in the JSON format is used specify the runtime options for a Palace simulation. The following sections give a detailed overview of the file format and available settings.\n\nParameters are specified in the form of keyword/value pairs where the key is a string and the value may be a string, boolean, integer or floating point number, or array. Parameters are grouped into a hierarchy of objects. We support relaxed JSON formatting with C++-style comments (//, /* */). Integer arrays can be specified as comma-separated lists of integers or integer ranges, for example [1,3-5,6] is parsed as [1,3,4,5,6].\n\nIn the following sections, default values for the parameters are specified alongside the description of each keyword in square brackets. Keywords for which there is no default value listed ([None]) are required in general if specifying values for other keywords under the same top-level object.\n\nThe top-level JSON object of the configuration file has the following structure:\n\n{\n    \"Problem\":\n    {\n        ...\n    },\n    \"Model\":\n    {\n        ...\n    },\n    \"Domains\":\n    {\n        ...\n    },\n    \"Boundaries\":\n    {\n        ...\n    },\n    \"Solver\":\n    {\n        ...\n    }\n}\n\nEach property of the top-level config JSON object is detailed in its corresponding section of the documentation.","category":"section"},{"location":"config/config/#Contents","page":"Overview","title":"Contents","text":"config[\"Problem\"]\nconfig[\"Model\"]\nconfig[\"Domains\"]\nconfig[\"Boundaries\"]\nconfig[\"Solver\"]","category":"section"},{"location":"config/solver/","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"config/solver/#config[\"Solver\"]","page":"config[\"Solver\"]","title":"config[\"Solver\"]","text":"\"Solver\":\n{\n    \"Order\": <int>,\n    \"PartialAssemblyOrder\": <int>,\n    \"Device\": <string>,\n    \"Backend\": <string>,\n    \"Eigenmode\":\n    {\n        ...\n    },\n    \"Driven\":\n    {\n        ...\n    },\n    \"Transient\":\n    {\n        ...\n    },\n    \"Electrostatic\":\n    {\n        ...\n    },\n    \"Magnetostatic\":\n    {\n        ...\n    },\n    \"Linear\":\n    {\n        ...\n    }\n}\n\nwith\n\n\"Order\" [1] :  Finite element order (degree). Arbitrary high-order spaces are supported.\n\n\"PartialAssemblyOrder\" [1] :  Order at which to switch from full assembly of finite element operators to partial assembly. Setting this parameter equal to 1 will fully activate operator partial assembly on all levels, while setting it to some large number (greater than the finite element order) will result in fully assembled operators as sparse matrices.\n\n\"Device\" [\"CPU\"] :  The runtime device configuration passed to MFEM in order to activate different options specified during configuration. The available options are:\n\n\"CPU\"\n\"GPU\"\n\"Debug\"\n\nThe \"GPU\" option will automatically activate the cuda or hip device based on whether MFEM is built with CUDA (MFEM_USE_CUDA=ON) or HIP (MFEM_USE_HIP=ON) support. When Palace is built with OpenMP support (PALACE_WITH_OPENMP=ON), omp is automatically added to the list of activated MFEM devices. The \"Debug\" option for MFEM's debug device is useful for debugging issues associated with GPU-based runs of Palace.\n\n\"Backend\" [\"\"] :  Specifies the libCEED backend to use for the simulation. If no backend is specified, a suitable default backend is selected based on the given config[\"Solver\"][\"Device\"].\n\n\"Eigenmode\" :  Top-level object for configuring the eigenvalue solver for the eigenmode simulation type. Thus, this object is only relevant for config[\"Problem\"][\"Type\"]: \"Eigenmode\".\n\n\"Driven\" :  Top-level object for configuring the frequency domain driven simulation type. Thus, this object is only relevant for config[\"Problem\"][\"Type\"]: \"Driven\".\n\n\"Transient\" :  Top-level object for configuring the time domain driven simulation type. Thus, this object is only relevant for config[\"Problem\"][\"Type\"]: \"Transient\".\n\n\"Electrostatic\" :  Top-level object for configuring the electrostatic simulation type. Thus, this object is only relevant for config[\"Problem\"][\"Type\"]: \"Electrostatic\".\n\n\"Magnetostatic\" :  Top-level object for configuring the magnetostatic simulation type. Thus, this object is only relevant for config[\"Problem\"][\"Type\"]: \"Magnetostatic\".\n\n\"Linear\" :  Top-level object for configuring the linear solver employed by all simulation types.","category":"section"},{"location":"config/solver/#Advanced-solver-options","page":"config[\"Solver\"]","title":"Advanced solver options","text":"\"QuadratureOrderJacobian\" [false]\n\"ExtraQuadratureOrder\" [0]","category":"section"},{"location":"config/solver/#solver[\"Eigenmode\"]","page":"config[\"Solver\"]","title":"solver[\"Eigenmode\"]","text":"\"Eigenmode\":\n{\n    \"Target\": <float>,\n    \"Tol\": <float>,\n    \"MaxIts\": <int>,\n    \"MaxSize\": <int>,\n    \"N\": <int>,\n    \"Save\": <int>,\n    \"Type\": <string>,\n    \"NonlinearType\" : <string>,\n}\n\nwith\n\n\"Target\" [None] :  (Nonzero) frequency target above which to search for eigenvalues, GHz.\n\n\"Tol\" [1.0e-6] :  Relative convergence tolerance for the eigenvalue solver.\n\n\"MaxIts\" [0] :  Maximum number of iterations for the iterative eigenvalue solver. A value less than 1 uses the solver default.\n\n\"MaxSize\" [0] :  Maximum subspace dimension for eigenvalue solver. A value less than 1 uses the solver default.\n\n\"N\" [1] :  Number of eigenvalues to compute.\n\n\"Save\" [0] :  Number of computed field modes to save to disk for visualization with ParaView. Files are saved in the paraview/ (and/or gridfunction/) directory under the directory specified by config[\"Problem\"][\"Output\"].\n\n\"Type\" [\"Default\"] :  Specifies the eigenvalue solver to be used in computing the given number of eigenmodes of the problem. The available options are:\n\n\"SLEPc\"\n\"ARPACK\"\n\"Default\" :  Use the default eigensolver. Currently, this is the Krylov-Schur eigenvalue solver from \"SLEPc\".\n\n\"NonlinearType\" [\"Hybrid\"] : Specifies the nonlinear eigenvalue solver to be used for nonlinear problems (e.g. frequency-dependent boundary conditions). The available options are:\n\n\"Hybrid\" : Hybrid algorithm where a (quadratic) polynomial approximation of the nonlinear problem is first solved and the eigenmodes are then refined with a quasi-Newton nonlinear eigensolver.\n\"SLP\" : SLEPc's Successive Linear Problem nonlinear eigensolver.\n\n\"TargetUpper\" [3 * Target] : Upper end of the frequency target range in which to search for eigenvalues, GHz. Only used in nonlinear problems. Using an inaccurate upper bound (significantly smaller or greater than the largest eigenvalue sought) can negatively affect the convergence of the nonlinear eigensolver.","category":"section"},{"location":"config/solver/#Advanced-eigenmode-solver-options","page":"config[\"Solver\"]","title":"Advanced eigenmode solver options","text":"\"PEPLinear\" [true]\n\"Scaling\" [true]\n\"StartVector\" [true]\n\"StartVectorConstant\" [false]\n\"MassOrthogonal\" [false]\n\"RefineNonlinear\" [true]\n\"LinearTol\" [1e-3]\n\"PreconditionerLag\" [10]\n\"PreconditionerLagTol\" [1e-4]\n\"MaxRestart\" [2]","category":"section"},{"location":"config/solver/#solver[\"Driven\"]","page":"config[\"Solver\"]","title":"solver[\"Driven\"]","text":"\"Driven\":\n{\n    \"MinFreq\": <float>,\n    \"MaxFreq\": <float>,\n    \"FreqStep\": <float>,\n    \"SaveStep\": <int>,\n    \"Samples\": [ ... ],\n    \"Save\": [<float array>],\n    \"Restart\": <int>,\n    \"AdaptiveTol\": <float>,\n    \"AdaptiveMaxSamples\": <int>,\n    \"AdaptiveConvergenceMemory\": <int>,\n    \"AdaptiveGSOrthogonalization\": <string>,\n    \"AdaptiveCircuitSynthesis\": <bool>,\n    \"AdaptiveCircuitSynthesisDomainOrthogonalization\": <string>\n}\n\nwith\n\n\"MinFreq\" [None] :  Lower bound of frequency sweep interval, GHz.\n\n\"MaxFreq\" [None] :  Upper bound of frequency sweep interval, GHz.\n\n\"FreqStep\" [None] :  Frequency step size for frequency sweep, GHz.\n\n\"SaveStep\" [0] :  Controls how often, in number of frequency steps, to save computed fields to disk for visualization with ParaView. Files are saved in the paraview/ (and/or gridfunction/) directory under the directory specified by config[\"Problem\"][\"Output\"].\n\n\"Samples\" [None] : Array of sample specifications that specify how to construct frequency samples. These are all combined to form a sorted and unique collection of samples. These samples can be instead of, or in addition to, the interface provided by \"MinFreq\", \"MaxFreq\", \"FreqStep\" and \"SaveStep\". See solver[\"Driven\"][\"Samples\"] for the construction of each of these structs.\n\n\"Save\" [None] : Array of frequencies to save computed fields to disk for visualization with ParaView, in addition to those specified by \"SaveStep\" in any sample specification. Files are saved in the paraview/ (and/or gridfunction/) directory under the directory specified by config[\"Problem\"][\"Output\"].\n\n\"Restart\" [1] :  Iteration (1-based) from which to restart for a partial frequency sweep simulation. That is \"Restart\": x will start the frequency sweep from the x-th sample rather than the first sample. This indexing is from the combined set of frequency samples. Not valid for an adaptive fast frequency sweep.\n\n\"AdaptiveTol\" [0.0] :  Relative error convergence tolerance for adaptive frequency sweep. If zero, adaptive frequency sweep is disabled and the full-order model is solved at each frequency step in the specified interval. If positive, this tolerance is used to ensure the reliability of the reduced-order model relative to the full-order one in the frequency band of interest.\n\n\"AdaptiveMaxSamples\" [20] :  Maximum number of frequency samples used to construct the reduced-order model for adaptive fast frequency sweep, if the specified tolerance (\"AdaptiveTol\") is not met first. In simulations with multiple excitations, this is the maximum number of samples per excitation.\n\n\"AdaptiveConvergenceMemory\" [2] :  Memory used for assessing convergence of the adaptive sampling algorithm for constructing the reduced-order model for adaptive fast frequency sweep. For example, a memory of \"2\" requires two consecutive samples which satisfy the error tolerance.\n\n\"AdaptiveGSOrthogonalization\" [\"CGS2\"] :  Gram-Schmidt variant used to orthogonalize vectors of the reduced-order model in the adaptive driven solver. Uses same options as solver[\"Linear\"][\"GSOrthogonalization\"].\n\n\"MGS\" :  Modified Gram-Schmidt\n\"CGS\" :  Classical Gram-Schmidt\n\"CGS2\" :  Two-step classical Gram-Schmidt with reorthogonalization\n\n\"AdaptiveCircuitSynthesis\" [false] : Uses the adaptive reduced-order model to print circuit-like matrices (inverse inductance L^-1, inverse resistance R^-1, capacitance C, and basis orthogonalization matrix). These matrices are directly normalized to the conventional voltage for the external ports. This option adds the lumped port fields as a basis function to the reduced-order model. Requires:\n\nAdaptive frequency sweep (AdaptiveTol > 0.0) is turned on.\nAll LumpedPort fields are orthogonal to each other.\nOnly terms with LRC-like frequency dependence are currently supported. This means no WavePort or WavePortPEC, no Conductivity, and no second-order Farfield boundary conditions.\n\n\"AdaptiveCircuitSynthesisDomainOrthogonalization\" [\"Energy\"] : Advanced option to specify the weight matrix type for the domain (non-port) orthogonalization when building the synthesized circuit matrices.\n\n\"Energy\" : Uses the energy-based domain mass matrix for orthogonalization.\n\"FEBasisIdentity\" : Uses the identity matrix in the finite element basis; domain nodes change substantially with finite element order.\n\"SpaceOverlap\" : Uses the overlap of fields in physical space for orthogonalization.","category":"section"},{"location":"config/solver/#solver[\"Driven\"][\"Samples\"]","page":"config[\"Solver\"]","title":"solver[\"Driven\"][\"Samples\"]","text":"\"Samples\":\n{\n    \"Type\": <string>,\n    \"MinFreq\": <float>,\n    \"MaxFreq\": <float>,\n    \"FreqStep\": <float>,\n    \"NSample\": <float>,\n    \"Freq\": [<float array>],\n    \"SaveStep\": <int>,\n    \"AddToPROM\": <bool>\n}\n\n\"Type\" [None] : The type of range being specified. The list of valid options are \"Linear\", \"Point\", \"Log\". For non-ambiguous combinations of other fields, this can be inferred for convenience.\n\n\"MinFreq\" [None] :  Lower bound of frequency sweep interval, GHz. Valid for \"Linear\" and \"Log\".\n\n\"MaxFreq\" [None] :  Upper bound of frequency sweep interval, GHz. Valid for \"Linear\" and \"Log\".\n\n\"FreqStep\" [None] :  Frequency step size for frequency sweep, GHz. Valid for \"Linear\" only. Mutually exclusive with \"NSample\"\n\n\"NSample\" [None] : Number of frequency samples over the specified range. Valid for \"Linear\" and \"Log\". Mutually exclusive with \"FreqStep\".\n\n\"Freq\" [None] : Explicit frequencies to be sample, GHz. Valid for \"Point\" only.\n\n\"SaveStep\" [0] :  Controls how often, in number of frequency steps, to save computed fields to disk for visualization with ParaView. Files are saved in the paraview/ (and/or gridfunction/) directory under the directory specified by config[\"Problem\"][\"Output\"].\n\n\"AddToPROM\" [false] : Advanced option to force the inclusion of this sample into the PROM when performing an adaptive sweep. This is primarily a debugging tool as the error estimation procedure will in general make more efficient selections of sampling points, and using this mechanism can result in a significantly larger and less efficient PROM.","category":"section"},{"location":"config/solver/#solver[\"Transient\"]","page":"config[\"Solver\"]","title":"solver[\"Transient\"]","text":"\"Transient\":\n{\n    \"Type\": <string>,\n    \"Excitation\": <string>,\n    \"ExcitationFreq\": <float>,\n    \"ExcitationWidth\": <float>,\n    \"MaxTime\": <float>,\n    \"TimeStep\": <float>,\n    \"SaveStep\": <int>,\n    \"Order\": <int>,\n    \"RelTol\": <float>,\n    \"AbsTol\": <float>\n}\n\nwith\n\n\"Type\" [\"Default\"] :  Specifies the time integration scheme used for the discretization of the second-order system of differential equations. The available options are:\n\n\"GeneralizedAlpha\" :  The second-order implicit generalized-alpha method with rho_inf = 10. This scheme is unconditionally stable.\n\"ARKODE\" :  SUNDIALS ARKode implicit Runge-Kutta scheme applied to the first-order ODE system for the electric field with adaptive time-stepping. This option is only available when Palace has been built with SUNDIALS support.\n\"CVODE\" :  SUNDIALS CVODE implicit multistep method scheme applied to the first-order ODE system for the electric field with adaptive time-stepping. This option is only available when Palace has been built with SUNDIALS support.\n\"RungeKutta\" : Two stage, singly diagonal implicit Runge-Kutta (SDIRK) method. Second order and L-stable.\n\"Default\" :  Use the default \"GeneralizedAlpha\" time integration scheme.\n\n\"Excitation\" [None] :  Controls the time dependence of the source excitation. The available options are:\n\n\"Sinusoidal\" :  A sinusoidal excitation at a user specified frequency.\n\"Gaussian\" :  A Gaussian pulse with a user specified width which defines the bandwidth.\n\"DifferentiatedGaussian\" :  A differentiated Gaussian pulse with a user specified width which defines the bandwidth.\n\"ModulatedGaussian\" :  A modulated Gaussian pulse at a user specified center frequency and width used to excite the system without any DC component.\n\"Ramp\" :  A differentiable unit step function to model the ramp up to a DC signal.\n\"SmoothStep\" :  A smoother many-times differentiable unit step function to model the ramp up to a DC signal over a specified width of time.\n\n\"ExcitationFreq\" [None] :  Center frequency used for harmonic source excitations, GHz. Only relevant when \"Excitation\" is one of \"Sinusoidal\", \"Gaussian\", \"DifferentiatedGaussian\", or \"ModulatedGaussian\".\n\n\"ExcitationWidth\" [None] :  Pulse width for Gaussian-type source excitations, ns. Only relevant when \"Excitation\" is one of \"Gaussian\", \"DifferentiatedGaussian\", \"ModulatedGaussian\", or \"SmoothStep\".\n\n\"MaxTime\" [None] :  End of simulation time interval, ns. Transient simulations always start from rest at t = 00.\n\n\"TimeStep\" [None] :  Uniform time step size for time integration, ns.\n\n\"SaveStep\" [0] :  Controls how often, in number of time steps, to save computed fields to disk for visualization with ParaView. Files are saved in the paraview/ (and/or gridfunction/) directory under the directory specified by config[\"Problem\"][\"Output\"].\n\n\"Order\" [2] :  Order of the adaptive Runge-Kutta integrators or maximum order of the multistep method, must be within [2,5]. Should only be specified if \"Type\" is \"ARKODE\" or \"CVODE\".\n\n\"RelTol\" [1e-4] :  Relative tolerance used in adaptive time-stepping schemes. Should only be specified if \"Type\" is \"ARKODE\" or \"CVODE\".\n\n\"AbsTol\" [1e-9] :  Absolute tolerance used in adaptive time-stepping schemes. Should only be specified if \"Type\" is \"ARKODE\" or \"CVODE\".","category":"section"},{"location":"config/solver/#solver[\"Electrostatic\"]","page":"config[\"Solver\"]","title":"solver[\"Electrostatic\"]","text":"\"Electrostatic\":\n{\n    \"Save\": <int>\n}\n\nwith\n\n\"Save\" [0] :  Number of computed electric field solutions to save to disk for visualization with ParaView, ordered by the entries in the computed capacitance matrix. Files are saved in the paraview/ (and/or gridfunction/) directory under the directory specified by config[\"Problem\"][\"Output\"].","category":"section"},{"location":"config/solver/#solver[\"Magnetostatic\"]","page":"config[\"Solver\"]","title":"solver[\"Magnetostatic\"]","text":"\"Magnetostatic\":\n{\n    \"Save\": <int>\n}\n\nwith\n\n\"Save\" [0] :  Number of computed magnetic field solutions to save to disk for visualization with ParaView), ordered by the entries in the computed inductance matrix. Files are saved in the paraview/ (and/or gridfunction/) directory under the directory specified by config[\"Problem\"][\"Output\"].","category":"section"},{"location":"config/solver/#solver[\"Linear\"]","page":"config[\"Solver\"]","title":"solver[\"Linear\"]","text":"\"Linear\":\n{\n    \"Type\": <string>,\n    \"KSPType\": <string>,\n    \"Tol\": <float>,\n    \"MaxIts\": <int>,\n    \"MaxSize\": <int>,\n    \"MGMaxLevels\": <int>,\n    \"MGCoarsenType\": <string>,\n    \"MGCycleIts\": <int>,\n    \"MGSmoothIts\": <int>,\n    \"MGSmoothOrder\": <int>,\n    \"PCMatReal\": <bool>,\n    \"PCMatShifted\": <bool>,\n    \"ComplexCoarseSolve\": <bool>,\n    \"DropSmallEntries\": <bool>,\n    \"PCSide\": <string>,\n    \"DivFreeTol\": <float>,\n    \"DivFreeMaxIts\": <float>,\n    \"EstimatorTol\": <float>,\n    \"EstimatorMaxIts\": <float>,\n    \"EstimatorMG\": <bool>,\n    \"GSOrthogonalization\": <string>\n}\n\nwith\n\n\"Type\" [\"Default\"] :  Specifies the solver used for preconditioning the linear system of equations to be solved for each simulation type. The available options are:\n\n\"SuperLU\" :  The SuperLU_DIST sparse direct solver in real double precision is used to factorize the system matrix. For frequency domain problems this uses a real approximation to the true complex linear system matrix. This option is only available when Palace has been built with SuperLU_DIST support.\n\"STRUMPACK\" :  The STRUMPACK sparse direct solver in real double precision is used to factorize the system matrix. For frequency domain problems this uses a real approximation to the true complex linear system matrix. This option is only available when Palace has been built with STRUMPACK support.\n\"MUMPS\" :  The MUMPS sparse direct solver in real double precision is used to factorize the system matrix. For frequency domain problems this uses a real approximation to the true complex linear system matrix. This option is only available when Palace has been built with MUMPS support.\n\"AMS\" :  Hypre's Auxiliary-space Maxwell Solver (AMS), an algebraic multigrid (AMG)-based preconditioner.\n\"BoomerAMG\" :  The BoomerAMG AMG solver from Hypre.\n\"Jacobi\" :  Diagonal scaling with a simple Jacobi preconditioner (not recommended in general).\n\"Default\" :  Use the default \"AMS\" solver for simulation types involving definite or semi-definite curl-curl operators (time domain problems as well as magnetostatics). For frequency domain problems, use a sparse direct solver if available, otherwise uses \"AMS\". For electrostatic problems, uses \"BoomerAMG\".\n\n\"KSPType\" [\"Default\"] :  Specifies the iterative Krylov subspace solver type for solving linear systems of equations arising for each simulation type. The available options are:\n\n\"CG\"\n\"GMRES\"\n\"FGMRES\"\n\"Default\" :  Use the default \"GMRES\" Krylov subspace solver for frequency domain problems, that is when config[\"Problem\"][\"Type\"] is \"Eigenmode\" or \"Driven\". For the other simulation types, the linear system matrix is always real and symmetric positive definite (SPD) and the preconditioned conjugate gradient method (\"CG\") is used as the Krylov solver.\n\n\"Tol\" [1.0e-6] :  Relative residual convergence tolerance for the iterative linear solver.\n\n\"MaxIts\" [100] :  Maximum number of iterations for the iterative linear solver. Must be greater than zero.\n\n\"MaxSize\" [0] :  Maximum Krylov space size for the GMRES and FGMRES solvers. A value less than 1 defaults to the value specified by \"MaxIts\".\n\n\"MGMaxLevels\" [100] : When greater than 1, enable the geometric multigrid preconditioning, which uses p- and h-multigrid coarsening as available to construct the multigrid hierarchy. The solver specified by \"Type\" is used on the coarsest level. Relaxation on the fine levels is performed with Chebyshev smoothing.\n\n\"MGCoarsenType\" [\"Logarithmic\"] :  Coarsening to create p-multigrid levels.\n\n\"Logarithmic\"\n\"Linear\"\n\n\"MGCycleIts\" [0] : Number of V-cycle iterations per preconditioner application for multigrid preconditioners (when the geometric multigrid preconditioner is enabled, i.e. when MGMaxLevels > 1, or when \"Type\" is \"AMS\" or \"BoomerAMG\"). A value less than 1 defaults to 2 for frequency domain problems using \"AMS\" or 1 otherwise.\n\n\"MGSmoothIts\" [1] : Number of pre- and post-smooth iterations used for multigrid preconditioners (when the geometric multigrid preconditioner is enabled, i.e. when MGMaxLevels > 1, or when \"Type\" is \"AMS\" or \"BoomerAMG\").\n\n\"MGSmoothOrder\" [0] :  Order of polynomial smoothing for geometric multigrid preconditioning. A value less than 1 defaults to twice the solution order given in config[\"Solver\"][\"Order\"] or 4, whichever is larger.\n\n\"PCMatReal\" [false] :  When set to true, constructs the preconditioner for frequency domain problems using a real-valued approximation of the system matrix. This is always performed for the coarsest multigrid level regardless of the setting of \"PCMatReal\".\n\n\"PCMatShifted\" [false] :  When set to true, constructs the preconditioner for frequency domain problems using a positive definite approximation of the system matrix by flipping the sign for the mass matrix contribution, which can help performance at high frequencies (relative to the lowest nonzero eigenfrequencies of the model).\n\n\"ComplexCoarseSolve\" [false] : When set to true, the coarse-level solver uses the true complex-valued system matrix. When set to false, the real-valued approximation is used.\n\n\"DropSmallEntries\" [false] : When set to true, entries smaller than the double precision machine epsilon are dropped from the system matrix used in the sparse direct solver.\n\n\"PCSide\" [\"Default\"] :  Side for preconditioning. Not all options are available for all iterative solver choices, and the default choice depends on the iterative solver used.\n\n\"Left\"\n\"Right\"\n\"Default\"\n\n\"DivFreeTol\" [1.0e-12] :  Relative tolerance for divergence-free cleaning used in the eigenmode simulation type. Ignored if non-zero Floquet wave vector is specified in config[\"Boundaries\"][\"Periodic\"][\"FloquetWaveVector\"] or config[\"Boundaries\"][\"FloquetWaveVector\"], or non-zero config[\"Domains\"][\"Materials\"][\"LondonDepth\"] is specified.\n\n\"DivFreeMaxIts\" [1000] :  Maximum number of iterations for divergence-free cleaning use in the eigenmode simulation type. Ignored if non-zero Floquet wave vector is specified in config[\"Boundaries\"][\"Periodic\"][\"FloquetWaveVector\"] or config[\"Boundaries\"][\"FloquetWaveVector\"], or non-zero config[\"Domains\"][\"Materials\"][\"LondonDepth\"] is specified.\n\n\"EstimatorTol\" [1.0e-6] :  Relative tolerance for flux projection used in the error estimate calculation.\n\n\"EstimatorMaxIts\" [10000] :  Maximum number of iterations for flux projection use in the error estimate calculation.\n\n\"EstimatorMG\" [false] :  Set to true in order to enable multigrid preconditioner with AMG coarse solve for the error estimate linear solver, instead of just Jacobi.\n\n\"GSOrthogonalization\" [\"MGS\"] :  Gram-Schmidt variant used to explicitly orthogonalize vectors in Krylov subspace methods or other parts of the code.\n\n\"MGS\" :  Modified Gram-Schmidt\n\"CGS\" :  Classical Gram-Schmidt\n\"CGS2\" :  Two-step classical Gram-Schmidt with reorthogonalization\n\n\"AMSMaxIts\" [0] : Number of AMS iterations per preconditioner application when the geometric multigrid preconditioner is enabled (MGMaxLevels > 1) and \"Type\" is \"AMS\". A value less than 1 defaults to the solution order given in config[\"Solver\"][\"Order\"]","category":"section"},{"location":"config/solver/#Advanced-linear-solver-options","page":"config[\"Solver\"]","title":"Advanced linear solver options","text":"\"InitialGuess\" [true]\n\"MGUseMesh\" [true]\n\"MGAuxiliarySmoother\" [true]\n\"MGSmoothEigScaleMax\" [1.0]\n\"MGSmoothEigScaleMin\" [0.0]\n\"MGSmoothChebyshev4th\" [true]\n\"ReorderingReuse\" [true]\n\"ColumnOrdering\" [\"Default\"] :  \"METIS\", \"ParMETIS\",\"Scotch\", \"PTScotch\", \"PORD\", \"AMD\", \"RCM\", \"Default\"\n\"STRUMPACKCompressionType\" [\"None\"] :  \"None\", \"BLR\", \"HSS\", \"HODLR\", \"ZFP\", \"BLR-HODLR\", \"ZFP-BLR-HODLR\"\n\"STRUMPACKCompressionTol\" [1.0e-3]\n\"STRUMPACKLossyPrecision\" [16]\n\"STRUMPACKButterflyLevels\" [1]\n\"SuperLU3DCommunicator\" [false]\n\"AMSVectorInterpolation\" [false]\n\"AMSSingularOperator\" [false]\n\"AMGAggressiveCoarsening\" [false]","category":"section"},{"location":"config/domains/","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"config/domains/#config[\"Domains\"]","page":"config[\"Domains\"]","title":"config[\"Domains\"]","text":"\"Domains\":\n{\n    \"Materials\":\n    [\n        ...\n    ],\n    \"CurrentDipole\":\n    [\n        ...\n    ],\n    \"Postprocessing\":\n    {\n        \"Energy\":\n        [\n            ...\n        ],\n        \"Probe\":\n        [\n            ...\n        ]\n    }\n}\n\nwith\n\n\"Materials\" :  Array of material properties objects.\n\n\"CurrentDipole\" :  Array of objects for configuring current dipole source excitations.\n\n\"Postprocessing\" :  Top-level object for configuring domain postprocessing.\n\n\"Energy\" :  Array of objects for postprocessing domain energies.\n\n\"Probe\" :  Array of objects for postprocessing solution field values evaluated at a probe location in space.","category":"section"},{"location":"config/domains/#domains[\"Materials\"]","page":"config[\"Domains\"]","title":"domains[\"Materials\"]","text":"\"Materials\":\n[\n    // Material 1\n    {\n        \"Attributes\": [<int array>],\n        \"Permeability\": <float> or [<float array>],\n        \"Permittivity\": <float> or [<float array>],\n        \"LossTan\": <float> or [<float array>],\n        \"Conductivity\": <float> or [<float array>],\n        \"LondonDepth\": <float>,\n        \"MaterialAxes\": [[<array of float array>]]\n    },\n    // Material 2, 3, ...\n    ...\n]\n\nwith\n\n\"Attributes\" [None] :  Integer array of mesh domain attributes for this material.\n\n\"Permeability\" [1.0] :  Relative permeability for this material. Scalar or vector of 3 coefficients corresponding to each of \"MaterialAxes\".\n\n\"Permittivity\" [1.0] : Relative permittivity for this material. Scalar or vector of 3 coefficients corresponding to each of \"MaterialAxes\".\n\n\"LossTan\" [0.0] :  Loss tangent for this material. Scalar or vector of 3 coefficients corresponding to each of \"MaterialAxes\".\n\n\"Conductivity\" [0.0] :  Electrical conductivity for this material, S/m. Activates Ohmic loss model in the material domain. Scalar or vector of 3 coefficients corresponding to each of \"MaterialAxes\".\n\n\"LondonDepth\" [0.0] :  London penetration depth for this material, specified in mesh length units. Activates London equations-based model relating superconducting current and electromagnetic fields in the material domain.\n\n\"MaterialAxes\" [[1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0]] : Axes directions for specification of anisotropic material properties. Required to be unit length and orthogonal.","category":"section"},{"location":"config/domains/#domains[\"CurrentDipole\"]","page":"config[\"Domains\"]","title":"domains[\"CurrentDipole\"]","text":"\"CurrentDipole\":\n[\n    {\n        \"Index\": <int>,\n        \"Direction\": [<float array>],\n        \"Moment\": <float>,\n        \"Center\": [<float array>]\n    },\n    ...\n]\n\nwith\n\n\"Index\" [None] :  Index of this current dipole source, used in postprocessing output files.\n\n\"Direction\" [None] :  Direction of the Dirac current source specifying the dipole. Axis aligned directions can be specified using keywords: \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\". The direction can alternatively be specified as a normalized array of three values, for example [0.0, 1.0, 0.0].\n\n\"Moment\" [None] :  Current dipole moment magnitude, specified in A·m.\n\n\"Center\" [None] :  Floating point array of length equal to the model spatial dimension specifying the coordinates of the current dipole center position in mesh length units.","category":"section"},{"location":"config/domains/#domains[\"Postprocessing\"][\"Energy\"]","page":"config[\"Domains\"]","title":"domains[\"Postprocessing\"][\"Energy\"]","text":"\"Postprocessing\":\n{\n    \"Energy\":\n    [\n        {\n            \"Index\": <int>,\n            \"Attributes\": [<int array>]\n        },\n        ...\n    ]\n}\n\nwith\n\n\"Index\" [None] :  Index of this energy postprocessing domain, used in postprocessing output files.\n\n\"Attributes\" [None] :  Integer array of mesh domain attributes for this energy postprocessing domain.","category":"section"},{"location":"config/domains/#domains[\"Postprocessing\"][\"Probe\"]","page":"config[\"Domains\"]","title":"domains[\"Postprocessing\"][\"Probe\"]","text":"\"Postprocessing\":\n{\n    \"Probe\":\n    [\n        {\n            \"Index\": <int>,\n            \"Center\": [<float array>]\n        },\n        ...\n    ]\n}\n\nwith\n\n\"Index\" [None] :  Index of this probe, used in postprocessing output files.\n\n\"Center\" [None] :  Floating point array of length equal to the model spatial dimension specifying the coordinates of this probe in mesh length units.","category":"section"},{"location":"examples/examples/","page":"Overview","title":"Overview","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"examples/examples/#Overview","page":"Overview","title":"Overview","text":"Some examples of using Palace, including configuration and mesh files, can be found in the examples/ directory of the source code. The following sections provide complete tutorials for each of the available example applications.\n\nThese examples are also used by Palace's regression testing suite. See the test/examples/ directory for more details.","category":"section"},{"location":"examples/examples/#Contents","page":"Overview","title":"Contents","text":"Capacitance Matrix for Two Spheres\nInductance Matrix for a Pair of Concentric Rings\nDipole Antenna and Radiation Fields\nEigenmodes of a Cylinder\nSignal Propagation in a Coaxial Cable\nCrosstalk Between Coplanar Waveguides","category":"section"},{"location":"examples/cylinder/","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"examples/cylinder/#Eigenmodes-of-a-Cylinder","page":"Eigenmodes of a Cylinder","title":"Eigenmodes of a Cylinder","text":"note: Note\nThe files for this example can be found in the examples/cylinder/ directory of the Palace source code.","category":"section"},{"location":"examples/cylinder/#Cavity","page":"Eigenmodes of a Cylinder","title":"Cavity","text":"This example demonstrates Palace's eigenmode simulation type to solve for the lowest frequency modes of a cylindrical cavity resonator. In particular, we consider a cylindrical cavity filled with Teflon (varepsilon_r = 208, tandelta = 4times 10^-4), with radius a = 274text cm and height d = 2a. From [1], the frequencies of the textTE_nml and textTM_nml modes are given by\n\nbeginaligned\nf_textTEnml = frac12pisqrtmuvarepsilon\n    sqrtleft(fracp_nmaright)^2 +\n    left(fraclpidright)^2 \nf_textTMnml = frac12pisqrtmuvarepsilon\n    sqrtleft(fracp_nmaright)^2 +\n    left(fraclpidright)^2 \nendaligned\n\nwhere  p_nm and p_nm denote the m-th root (mgeq 1) of the n-th order Bessel function (ngeq 0) of the first kind, J_n, and its derivative, J_n, respectively.\n\nIn addition, we have analytic expressions for the unloaded quality factors due to dielectric loss, Q_d, and imperfectly conducting walls, Q_c. In particular,\n\nQ_d = frac1tandelta\n\nand, for a surface resistance R_s,\n\nQ_c = frac(ka)^3eta ad4(p_nm)^2 R_s\n    left1-left(fracnp_nmright)^2right\n    leftfracad2\n        left1+left(fracbeta an(p_nm)^2right)^2right +\n        left(fracbeta a^2p_nmright)^2\n        left(1-fracn^2(p_nm)^2right)right^-1\n\nwhere k=omegasqrtmuvarepsilon, eta=sqrtmuvarepsilon, and beta=lpid.\n\nThe initial Gmsh mesh for this problem, from mesh/cavity_prism.msh, is shown below. We use quadratic triangular prism elements. There are also two other included mesh files, mesh/cavity_tet.msh and mesh/cavity_hex.msh, which use curved tetrahedral and hexahedral elements, respectively.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/cavity-1.png\" width=\"60%\" />\n</p><br/>\n\nThere are two configuration files for this problem, cavity_pec.json and cavity_impedance.json.\n\nIn both, the config[\"Problem\"][\"Type\"] field is set to \"Eigenmode\", and we use the mesh shown above. The material properties for Teflon are entered under config[\"Domains\"][\"Materials\"]. The config[\"Domains\"][\"Postprocessing\"][\"Energy]\" object is used to extract the quality factor due to bulk dielectric loss; in this problem since there is only one domain this is trivial, but in problems with multiple material domains this feature can be used to isolate the energy-participation ratio (EPR) and associated quality factor due to different domains in the model.\n\nThe only difference between the two configuration files is in the \"Boundaries\" object: cavity_pec.json prescribes a perfect electric conductor (\"PEC\") boundary condition to the cavity boundary surfaces, while cavity_impedance.json prescribes a surface impedance condition with the surface resistance R_s = 00184text Omegatextsq, for copper at 5text GHz.\n\nIn both cases, we configure the eigenvalue solver to solve for the 15 lowest frequency modes above 20text GHz (the dominant mode frequencies for both the textTE and textTM cases fall around 29text GHz frequency for this problem). A sparse direct solver is used for the solutions of the linear system resulting from the spatial discretization of the governing equations, using in this case a fourth-order finite element space.\n\nThe frequencies for the lowest-order textTE and textTM modes computed using the above formula for this problem are listed in the table below.\n\n(nml) f_textTE f_textTM\n(010) –– 2903605text GHz\n(110) –– 4626474text GHz\n(210) –– 6200829text GHz\n(011) 5000140text GHz 3468149text GHz\n(111) 2922212text GHz 5000140text GHz\n(211) 4146842text GHz 6484398text GHz\n(012) 5982709text GHz 4776973text GHz\n(112) 4396673text GHz 5982709text GHz\n(212) 5290341text GHz 7269033text GHz\n\nFirst, we examine the output of the cavity_pec.json simulation. The file postpro/cavity_pec/eig.csv contains information about the computed eigenfrequencies and associated quality factors:\n\ninclude_example_file(\"cylinder/cavity_pec\", \"eig.csv\") # hide\n\nIndeed we can find a correspondence between the analytic modes predicted and the solutions obtained by Palace. Since the only source of loss in the simulation is the nonzero dielectric loss tangent, we have Q = Q_d = 100004 = 250times 10^3 in all cases.\n\nNext, we run cavity_impedance.json, which  adds the surface impedance boundary condition. Examining postpro/cavity_impedance/eig.csv we see that the mode frequencies are roughly unchanged but the quality factors have fallen due to the addition of imperfectly conducting walls to the model:\n\ninclude_example_file(\"cylinder/cavity_impedance\", \"eig.csv\") # hide\n\nHowever, the bulk dielectric loss postprocessing results, computed from the energies written to postpro/cavity_impedance/domain-E.csv, still give Q_d = 10004 = 250times 10^3 for every mode as expected.\n\nFocusing on the textTE_011 mode with f_textTE010 = 500text GHz, we can read the mode quality factor Q = 230times 10^3. Subtracting out the contribution of dielectric losses, we have\n\nQ_c = left(frac1Q-frac1Q_dright)^-1 = 294times 10^4\n\nwhich is the same as the analytical result given in Example 6.4 from [1] for this geometry.\n\nFinally, a clipped view of the electric field (left) and magnetic flux density magnitudes for the textTE_011 mode is shown below.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/cavity-2a.png\" width=\"45%\" />\n  <img src=\"../../assets/examples/cavity-2b.png\" width=\"45%\" />\n</p>","category":"section"},{"location":"examples/cylinder/#Mesh-convergence","page":"Eigenmodes of a Cylinder","title":"Mesh convergence","text":"The effect of mesh size can be investigated for the cylindrical cavity resonator using convergence_study.jl. For a polynomial order of solution and refinement level, a mesh is generated using Gmsh using polynomials of the same order to resolve the boundary geometry. The eigenvalue problem is then solved for f_textTM010 and f_textTE111, and the relative error, fracf-f_texttruef_texttrue, of each mode plotted against textDOF^-frac13, a notional mesh size. Three different element types are considered: tetrahedra, prisms and hexahedra, and the results are plotted below. The x-axis is a notional measure of the overall cost of the solve, accounting for polynomial order.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/cavity-3a.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cavity-3b.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cavity-3c.png\" width=\"70%\" />\n</p><br/>\n\nThe observed rate of convergence for the eigenvalues are p+1 for odd polynomials and p+2 for even polynomials. Given the eigenmodes are analytic functions, the theoretical maximum convergence rate is 2p [2]. The figures demonstrate that increasing the polynomial order of the solution will give reduced error, however the effect may only become significant on sufficiently refined meshes.","category":"section"},{"location":"examples/cylinder/#Waveguide","page":"Eigenmodes of a Cylinder","title":"Waveguide","text":"This example demonstrates the eigenmode simulation type in  Palace to solve for the cutoff-frequencies of a circular waveguide. As with the cavity the interior material to be Silicon (varepsilon_r = 208, tandelta = 4times 10^-4), with cylindrical domain radius a = 274text cm, and length d=2a = 548text cm, however now periodic boundary conditions are applied in the z-direction. According to [1], the cutoff frequencies for the transverse electric and magnetic modes are given by the formulae:\n\nbeginaligned\nf_textTEnm = frac12pisqrtmuvarepsilon fracp_nma\nf_textTMnm = frac12pisqrtmuvarepsilon fracp_nma\nendaligned\n\nwhich are identical to those for the cavity modes, in the special case of l=0.\n\nIn addition to these pure waveguide modes, there are aliasing cavity modes corresponding to a full wavelength in the computational domain (l=2). In a practical problem these can be suppressed by choosing a smaller value of d which shifts such modes to higher frequencies. The relevant modes are tabulated as\n\n(nml) f_textTE f_textTM\n(010) 4626481text GHz 2903636text GHz\n(110) 2223083text GHz 4626481text GHz\n(210) 3687749text GHz 6200856text GHz\n(310) 5072602text GHz 7703539text GHz\n(012) 5982715text GHz 4776992text GHz\n(112) 4396663text GHz 5982715text GHz\n(212) 5290372text GHz 7269056text GHz\n(312) 6334023text GHz 8586796text GHz\n\nFor this problem, we use curved tetrahedral elements from the mesh file mesh/cavity_tet.msh, and the configuration files waveguide.json and floquet.json.\n\nThe main difference between these configuration files and those used in the cavity example is in the \"Boundaries\" object: waveguide.json specifies a perfect electric conductor (\"PEC\") boundary condition for the exterior surface and a periodic boundary condition (\"Periodic\") on the cross-sections of the cylinder (in the z- direction). The periodic attribute pairs are defined by \"DonorAttributes\" and \"ReceiverAttributes\", and the distance between them is given by the \"Translation\" vector in mesh units. In floquet.json, an additional \"FloquetWaveVector\" specifies the phase delay between the donor and receiver boundaries in the X/Y/Z directions.\n\nThe file postpro/waveguide/eig.csv contains information about the computed eigenfrequencies and associated quality factors:\n\ninclude_example_file(\"cylinder/waveguide\", \"eig.csv\") # hide\n\nIn common with the PEC cavity Q = Q_d = 100004 = 250times 10^3 in all cases, and all the anticipated waveguide modes are recovered with textTE_11 having the lowest cutoff frequency followed by textTM_01 and textTE_21, while the aliasing mode textTE_112 has marginally lower frequency than the waveguide modes textTE_01 and textTM_11 (4397text GHz compared to 4627text GHz) and is thus found first.","category":"section"},{"location":"examples/cylinder/#References","page":"Eigenmodes of a Cylinder","title":"References","text":"[1] D. M. Pozar, Microwave Engineering, Wiley, Hoboken, NJ, 2012.\n[2] A. Buffa, P. Houston, I. Perugia, Discontinuous Galerkin computation of the Maxwell eigenvalues on simplicial meshes, Journal of Computational and Applied Mathematics 204 (2007) 317-333.","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"Palace can be built and installed using the Spack HPC package manager, following the instructions in the Build using Spack section. Containerized builds are possible with Singularity/Apptainer, described in Build using Singularity/Apptainer. Alternatively, compiling from source using CMake is described in Build from source.\n\nIf you are a user, we recommend you install Palace with Spack. If you intend to develop Palace, build from source instead.\n\nnote: Installation issues/questions?\nIf the steps described in the sections below do not work as expected, consult the Frequently Asked Questions page.","category":"section"},{"location":"install/#Build-using-Spack","page":"Installation","title":"Build using Spack","text":"Palace is a registered package in the built-in Spack package repository. To install the solver, follow the instructions for setting up Spack on your system. Note that Spack requires basic system utilities that may not be installed by default on certain systems (such as Ubuntu for Windows Subsystem for Linux). Consult the Spack Prerequisites page to ensure all required utilities are installed.\n\nOnce you have installed Spack, check that the version of Palace you want to install is available\n\nspack versions palace\n\nIf you do not see the latest version, your Spack package repository might be outdated. Consult the Frequently Asked Questions page.\n\nOnce you confirmed that the desired version of Palace is available, run:\n\nspack install palace\n\nThis will install the default version of Palace. Spack supports installing variants of Palace. For instance, if you want to install Palace with CUDA, MUMPS and SLEPc, call\n\nspack install palace +mumps +slepc +cuda cuda_arch=90\n\nwhere cuda_arch is determined by the generation of your GPU. More information about the available configuration options and dependencies can be found using spack info palace. See the official tutorial for an introduction.\n\nIf you are developing Palace, refer to the Working with Spack page.","category":"section"},{"location":"install/#Build-using-Singularity/Apptainer","page":"Installation","title":"Build using Singularity/Apptainer","text":"Palace can be built in a Singularity/Apptainer container for HPC environments supporting the Singularity/Apptainer container system. To build the container using the provided definition file in the singularity/ directory, first set up Singularity/Apptainer on your system and subsequently run:\n\nsingularity build palace.sif <SOURCE_DIR>/singularity/singularity.def\n\nwhere the repository source code has been cloned to <SOURCE_DIR>. For more information about Singularity/Apptainer, see the Quick Start guide in the Singularity/Apptainer documentation.","category":"section"},{"location":"install/#Build-from-source","page":"Installation","title":"Build from source","text":"A build from source requires the following prerequisites installed on your system:\n\nCMake version 3.24 or later\nC++17 compatible C++ compiler\nC and Fortran (optional) compilers for dependency builds\nMPI distribution\nBLAS, LAPACK libraries (described below in Math libraries)\nCUDA Toolkit or ROCm installation (optional, for GPU support only)\n\nIn addition, builds from source require the following system packages which are typically already installed and are available from most package managers (apt, dnf, brew, etc.):\n\nPython 3\npkg-config\nlibunwind (optional)\nzlib (optional)","category":"section"},{"location":"install/#Quick-start","page":"Installation","title":"Quick start","text":"To start, clone the code using\n\ngit clone https://github.com/awslabs/palace.git\n\nThen, a build using the default options can be performed by running the following from within the directory where the repository was cloned:\n\nmkdir build && cd build\ncmake ..\nmake -j\n\nThis installs the binary executable in build/bin/.","category":"section"},{"location":"install/#Configuration-options","page":"Installation","title":"Configuration options","text":"To configure a Palace build in <BUILD_DIR> using the source code in <SOURCE_DIR>, run:\n\nmkdir <BUILD_DIR> && cd <BUILD_DIR>\ncmake [OPTIONS] <SOURCE_DIR>\n\nHere, [OPTIONS] is a list of options passed to cmake of the form -D<VARIABLE>=<VALUE>. The Palace build respects standard CMake variables, including:\n\nCMAKE_CXX_COMPILER, CMAKE_C_COMPILER, and CMAKE_Fortran_COMPILER which define the desired compilers.\nCMAKE_CXX_FLAGS, CMAKE_C_FLAGS, and CMAKE_Fortran_FLAGS which define the corresponding compiler flags.\nCMAKE_CUDA_COMPILER, CMAKE_CUDA_FLAGS, CMAKE_CUDA_ARCHITECTURES, and the corresponding CMAKE_HIP_COMPILER, CMAKE_HIP_FLAGS, and CMAKE_HIP_ARCHITECTURES for GPU-accelerated builds with CUDA or HIP.\nCMAKE_INSTALL_PREFIX which specifies the path for installation (if none is provided, defaults to <BUILD_DIR>).\nCMAKE_BUILD_TYPE which defines the build type such as Release, Debug, RelWithDebInfo, and MinSizeRel (Release if not otherwise specified).\nBUILD_SHARED_LIBS which is a flag to create shared libraries for dependency library builds instead of static libraries (OFF by default).\nCMAKE_PREFIX_PATH which lists directories specifying installation prefixes to be searched for dependencies.\nCMAKE_INSTALL_RPATH and CMAKE_INSTALL_RPATH_USE_LINK_PATH which configure the rpath for installed library and executable targets.\n\nAdditional build options are (with default values in brackets):\n\nPALACE_WITH_64BIT_INT [OFF] :  Build with 64-bit integer support\nPALACE_WITH_OPENMP [OFF] :  Use OpenMP for shared-memory parallelism\nPALACE_WITH_CUDA [OFF] :  Use CUDA for NVIDIA GPU support\nPALACE_WITH_HIP [OFF] :  Use HIP for AMD or NVIDIA GPU support\nPALACE_WITH_GPU_AWARE_MPI [OFF] :  Option to set if MPI distribution is GPU aware\nPALACE_WITH_SUPERLU [ON] :  Build with SuperLU_DIST sparse direct solver\nPALACE_WITH_STRUMPACK [OFF] :  Build with STRUMPACK sparse direct solver\nPALACE_WITH_MUMPS [OFF] :  Build with MUMPS sparse direct solver\nPALACE_WITH_SLEPC [ON] :  Build with SLEPc eigenvalue solver\nPALACE_WITH_ARPACK [OFF] :  Build with ARPACK eigenvalue solver\nPALACE_WITH_LIBXSMM [ON] :  Build with LIBXSMM backend for libCEED\nPALACE_WITH_MAGMA [ON] :  Build with MAGMA backend for libCEED\nPALACE_WITH_GSLIB [ON] :  Build with GSLIB library for high-order field interpolation\nPALACE_WITH_SUNDIALS [ON] : Build with SUNDIALS ODE solver library\n\nThe build step is invoked by running (for example with 4 make threads)\n\nmake -j 4\n\nor\n\ncmake --build . -- -j 4\n\nwhich installs the binary executable in ${CMAKE_INSTALL_PREFIX}/bin/.","category":"section"},{"location":"install/#Math-libraries","page":"Installation","title":"Math libraries","text":"During the configure step, the build system will try to detect system installations of BLAS and LAPACK libraries depending on the system architecture according to the following procedure:\n\nFor x86_64 systems:\nIf the MKLROOT environment variable is set, looks for an Intel MKL installation.\nIf the AOCL_DIR or AOCLROOT environment variables are set, looks for an AMD Optimizing CPU Libraries (AOCL) installation of BLIS and libFLAME.\nOtherwise, tries to locate an installation of OpenBLAS which is permissively licensed and available from most package managers.\nFor aarch64/arm64 systems:\nIf the ARMPL_DIR environment variable is set, looks for an Arm Performance Libraries (PL) installation.\nOtherwise, tries to locate an installation of OpenBLAS.\n\nIf the installation path of OpenBLAS is non-standard or is not found by default, it can be set using the OPENBLAS_DIR or OPENBLASROOT environment variables, or added to CMAKE_PREFIX_PATH when calling CMake.\n\nIt is recommended in most cases to use serial BLAS and LAPACK builds (not multithreaded), as the standard parallelization approach in Palace is to use pure MPI parallelism.","category":"section"},{"location":"install/#Dependencies","page":"Installation","title":"Dependencies","text":"Palace leverages the MFEM finite element discretization library. It always configures and builds its own installation of MFEM internally in order to support the most up to date features and patches. Likewise, Palace will always build its own installation of libCEED, and GSLIB, when PALACE_WITH_GSLIB=ON.\n\nAs part of the Build from source, the CMake build will automatically build and install a small number of third-party dependencies before building Palace. The source code for these dependencies is downloaded during the build process:\n\nMETIS and ParMETIS\nHypre\nSuperLU_DIST (optional, when PALACE_WITH_SUPERLU=ON)\nSTRUMPACK (optional, when PALACE_WITH_STRUMPACK=ON), including ButterflyPACK and zfp support\nMUMPS (optional, when PALACE_WITH_MUMPS=ON)\nSLEPc (optional, when PALACE_WITH_SLEPC=ON), including PETSc\nARPACK-NG (optional, when PALACE_WITH_ARPACK=ON)\nLIBXSMM (optional, when PALACE_WITH_LIBXSMM=ON)\nMAGMA (optional, when PALACE_WITH_MAGMA=ON)\nSUNDIALS (optional, when PALACE_WITH_SUNDIALS=ON)\nnlohmann/json\nfmt\nEigen\n\nFor solving eigenvalue problems, at least one of SLEPc or ARPACK-NG must be specified. Typically only one of the SuperLU_DIST, STRUMPACK, and MUMPS dependencies is required but all can be built so the user can decide at runtime which solver to use.\n\nFor unit testing, Palace relies on the Catch2 library, which is automatically downloaded and built when building the unit-tests target. See the Developer Notes for more information.","category":"section"},{"location":"developer/tutorial_add_new_unit_test/","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"developer/tutorial_add_new_unit_test/#Tutorial:-Adding-a-New-Unit-Test","page":"Tutorial: Adding a New Unit Test","title":"Tutorial: Adding a New Unit Test","text":"This tutorial demonstrates how to add unit tests to the Palace test suite. Prerequisites: familiarity with compiling and running unit tests (see Running unit tests).","category":"section"},{"location":"developer/tutorial_add_new_unit_test/#Overview","page":"Tutorial: Adding a New Unit Test","title":"Overview","text":"As a motivating example, we'll test the Sum(MPI_Comm comm, Vector& vec) function. This function has certain characteristics that make it interesting to test:\n\nVectors may have different sizes across MPI processes\nVector data may be stored on CPU or GPU\nThe function performs MPI communication to compute global sums\n\nThese characteristics require testing across multiple configurations to ensure correctness.\n\nCreate a new file test-vector-sum.cpp in test/unit/:\n\n#include <catch2/matchers/catch_matchers_floating_point.hpp>\n#include <catch2/catch_test_macros.hpp>\n\n#include \"linalg/vector.hpp\"\n#include \"utils/communication.hpp\"\n\nnamespace palace\n{\nusing namespace Catch;\n\nTEST_CASE(\"Vector Sum - Basic\", \"[myvector][Serial]\")\n{\n  Vector v(2);\n  v(0) = 1.0;\n  v(1) = 2.0;\n\n  double sum = linalg::Sum(Mpi::World(), v);\n  REQUIRE_THAT(sum, Catch::Matchers::WithinRel(3.0));\n}\n\n}  // namespace palace\n\nThis defines a new Catch2 test case. The key components are:\n\nTest name (Vector Sum - Basic): Must be unique across the test suite\nTags: [myvector] (arbitrary, used for filtering) and [Serial] (special tag, more on this later)\nWithinRel(): Handles floating-point comparison tolerances\n\nTo compile our test, we need to add it to the list of sources in the CMakeLists.txt in test/unit:\n\nadd_executable(unit-tests\n  # ... existing files ...\n  ${CMAKE_CURRENT_SOURCE_DIR}/test-vector-sum.cpp\n)\n\nThen, build and run:\n\n# Build tests in the build directory\nmake palace-tests\n\n# Run this specific test\nbin/palace-unit-tests \"[myvector]\"\n\nWe should see that All tests passed.\n\nThe test that we wrote is a reasonable first test, but it does not check that the feature works with GPUs or with multiple processes.\n\nIn particular, the test fails with multiple MPI processes because each process has a copy of v and contributes to the sum. Similarly, if we were to run this on a GPU we would find that the test passes, but we would also observe no activity on the device.\n\nLet us extend this case so that we can write a more comprehensive test that is also meaningful on GPU and with MPI:\n\nTEST_CASE(\"MyTest Vector Sum\", \"[myvector][Serial][Parallel][GPU]\")\n{\n  Vector v(2);\n  v.UseDevice(true);\n  auto d_v = v.Write();\n\n  mfem::forall(v.Size(), [=] MFEM_HOST_DEVICE (int i){\n    d_v[i] = rank + 1.0;\n  });\n\n  double sum = linalg::Sum(Mpi::World(), v);\n  double expected = Mpi::Size(Mpi::World()) * 3.0;\n  REQUIRE_THAT(value, Catch::Matchers::WithinRel(expected))\n}\n\nWe added GPU compatibility by (see, MFEM documentation):\n\nAdding v.UseDevice(true);, which defines our intent to use v for computations on the device.\nDefining auto d_v = v.Write();, a pointer to area of memory on the device.\nUsing forall to execute the execute the function on the device.\n\nWhen we add GPU code, we need to make sure that the file is compiled with the correct compiler. To do so, we add the file to TARGET_SOURCES_DEVICE in the CMakeLists.txt file, it is not already there.\n\nset(TARGET_SOURCES_DEVICE\n  # ... existing files ...\n  ${CMAKE_CURRENT_SOURCE_DIR}/test-vector-sum.cpp\n)\n\nNote that this code still works for CPU, when the device is not a GPU, allowing us to test both devices with the same code. Note also that here we are working with a vector with only two elements and this is highly inefficient on GPUs (but we are not concerned with performance here, only correctness).\n\nTo add MPI compatibility, we changed the expected value to account for how many copies of the vector v there are.\n\nWith these additions, this test case is a meaningful and interesting test in all the possible configurations, so we we added the [Parallel] and [GPU] tags.\n\nPalace uses three special tags for execution control:\n\n[Serial]: Runs only with single MPI process\n[Parallel]: Runs only with multiple MPI processes\n[GPU]: Runs only when GPU devices are available\n\nTo understand why we need this, let us add a test that checks that the sum is correct when vectors have different lengths on different MPI processes (for simplicity let us ignore GPU compatibility):\n\nTEST_CASE(\"MyTest Vector Sum - Different Lengths\", \"[myvector][Parallel]\")\n{\n Vector v;\n\n if (Mpi::Root(Mpi::World())){\n     v.SetSize(2);\n     v(0) = 10;\n     v(1) = 20;\n } else {\n     v.SetSize(1);\n     v(0) = 3;\n }\n\n double sum = linalg::Sum(Mpi::World(), v);\n double expected = 3 * (Mpi::Size(Mpi::World()) - 1) + 30;\n REQUIRE_THAT(value, Catch::Matchers::WithinRel(expected))\n}\n\nThis test is useful because it checks that Sum is not implemented making assumptions on the length of the vector. This test is also meaningless when run with less than 2 MPI processes, so we removed the [Serial] tag.\n\nSometimes, tests need to write to the filesystem. In this case, it is often best to create temporary working directories. This can be accomplished with the PerRankTempDir fixture, which gives each MPI rank its own directory:\n\n#include \"fixtures.hpp\"\n\nTEST_CASE_METHOD(palace::test::PerRankTempDir, \"MyTest Print\", \"[myvector][Serial]\") {\n  // temp_dir is available and will be cleaned up automatically.\n  auto file_path = temp_dir / \"vector.txt\";\n  Vector v;\n  v = 1;\n  {\n     std::ofstream file(file_path);\n     v.Print(file);\n  }\n  CHECK(std::filesystem::exists(file_path));\n}\n\nFor tests where all ranks need to share the same directory, use SharedTempDir:\n\nTEST_CASE_METHOD(palace::test::SharedTempDir,\n                 \"MyTest Shared\", \"[myvector][Parallel]\") {\n  // All ranks share temp_dir.\n}\n\nSuppose you want to compare the result of some operations with some pre-existing file expected_vector.txt. To do this, we first need to save the file in test/unit/data. Then, we can access it as\n\nauto path_expected_vector = fs::path(PALACE_TEST_DATA_DIR) / \"expected_vector.txt\"\n\npath_expected_vector points to the expected_vector.txt file.","category":"section"},{"location":"guide/model/","page":"Simulation Models","title":"Simulation Models","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"guide/model/#Simulation-Models","page":"Simulation Models","title":"Simulation Models","text":"","category":"section"},{"location":"guide/model/#Supported-mesh-formats","page":"Simulation Models","title":"Supported mesh formats","text":"The config[\"Model\"] object is used to specify the mesh for the discretized computational domain. In general, inputs are expected to be dimensional nondimensionalized internally. A length scale, specified under config[\"Model\"][\"L0\"], describes the length units of the mesh relative to 1 meter (i.e. config[\"Model\"][\"L0\"]: 1.0e-6 if the mesh coordinates are in mum, this is the default value). All other entries in the configuration file which have units of length should be specified in units of config[\"Model\"][\"L0\"] m.\n\nMFEM supports a wide variety of mesh formats. In addition, Palace has built-in support for Nastran (.nas, .bdf) and COMSOL (.mphtxt, .mphbin) format mesh files, for both linear and high-order curved elements.\n\nGeometric attributes for domains and boundaries in the mesh are used to define material properties and boundary conditions on the desired model regions and surfaces (see config[\"Domains\"] and config[\"Boundaries\"]). These attribute integers correspond to tags for the domain and boundary elements in the mesh, and should be non-negative and start at 1. They do not need to be contiguous in the mesh file. Throughout the configuration file, the \"Attributes\" keyword is used to indicate which domain or boundary attributes are relevant to the material properties or boundary conditions being specified.","category":"section"},{"location":"guide/model/#Mesh-refinement","page":"Simulation Models","title":"Mesh refinement","text":"Refinement of the input mesh file can be performed using levels of global uniform refinement or region-based refinement, specified using the config[\"Model\"][\"Refinement\"] object. The user can specify any combination of uniform refinement levels as well as local refinement regions which refines the elements inside of a certain box or sphere-shaped region. For simplex meshes, the refinement maintains a conforming mesh but meshes containing hexahedra, prism, or pyramid elements will be nonconforming after local refinement (this is not supported at this time).\n\nAdaptive mesh refinement (AMR) according to error estimates calculated from the computed solution can also be specified using the config[\"Model\"][\"Refinement\"] object. Nonconformal refinement is supported for all mesh types, and additionally conformal refinement is supported for simplex meshes. AMR is available for all problem types apart from driven problems in the time domain.","category":"section"},{"location":"guide/model/#Material-models","page":"Simulation Models","title":"Material models","text":"Material properties are handled by the config[\"Domains\"][\"Materials\"] object. Palace supports linear, frequency independent constitutive laws for material modeling.\n\nMaterials with scalar or symmetric matrix-valued material properties are supported. For most simulation types, each material in the model requires a specified relative permittivity and relative permeability (for electrostatic simulations, only the permittivity is required, while for magnetostatics, only the permeability is required). For dielectric domains, a loss tangent may be specified. Alternatively, for normal conducting domains, an electrical conductivity may be specified which is used to relate the current density and electric field via Ohm's law.\n\nModeling of superconducting domains is performed using the current-field constitutive relations given by the London equations. The user can specify a London penetration depth to activate this model. It can also be used in conjunction with a material conductivity when wishing to model both superconducting and normal currents.","category":"section"},{"location":"examples/cpw/","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"examples/cpw/#Crosstalk-Between-Coplanar-Waveguides","page":"Crosstalk Between Coplanar Waveguides","title":"Crosstalk Between Coplanar Waveguides","text":"note: Note\nThe files for this example can be found in the examples/cpw/ directory of the Palace source code.\n\nIn this example, we construct a frequency domain model to analyze the wave transmission, reflection, near-end crosstalk, and far-end crosstalk for a four-port system comprised of two side-by-side coplanar waveguides (CPW). Each CPW is characterized by a trace width w = 30text μm and gap width s = 18text μm. The metal is modeled as an infinitely thin, perfectly conducting boundary surface on top of a sapphire dielectric substrate (parallel to C-axis: varepsilon_r = 115, tandelta = 86times 10^-5, perpendicular to C-axis: varepsilon_r = 93, tandelta = 30times 10^-5) of 500text μm thickness with the C-axis in the z-direction. This yields a characteristic impedance Z_0 = 5602text Omega for each of the lines [1]. The center-to-center separating distance between the transmission lines on the substrate is 266text μm, which means there is exactly 200text μm of ground plane between them.\n\nA visualization of the computational domain is shown below.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/cpw-1.png\" width=\"60%\" />\n</p><br/>\n\nThere are two different options for modeling the termination at the ends of the CPW:\n\nLumped port: A multielement uniform lumped port can be used to terminate the CPW by connecting the center conductor to the ground plane on each side with impedance Z = 2Z_0.\nWave port: We can solve a 2D boundary eigenvalue problem for the mode shape and propagation constants for the characteristic CPW mode, and use this to terminate the transmission line.\n\nViews of the mesh boundaries for these two configurations are shown below. In both cases the computational domain is discretized using an unstructured tetrahedral mesh. The mesh files are mesh/cpw_wave_0.msh and mesh/cpw_lumped_0.msh, respectively. In addition, this example includes two mesh files which include the thickness of the metal trace: mesh/cpw_wave.msh and mesh/cpw_lumped.msh.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/cpw-2.png\" width=\"45%\" />\n  <img src=\"../../assets/examples/cpw-3.png\" width=\"45%\" />\n</p><br/>\n\nLikewise, there are two different options for how the system response is calculated over the desired frequency band:\n\nUniform: Sample the frequency band with the full-fidelity model at equally spaced frequencies over the desired range.\nAdaptive: Use the full-fidelity model to sample the solution at a few adaptively selected frequency points in the desired band, and then construct a low-cost surrogate model which is used to compute the response over the entire band.\n\nThis leads to four possible configurations, for which there are four configuration files in the example directory: cpw_lumped_uniform.json, cpw_lumped_adaptive.json, cpw_wave_uniform.json, and cpw_wave_adaptive.json.\n\nThe frequency response is computed for the band fin20320text GHz. For the uniform sweep, a step size of Delta f=60text GHz is used, while the adaptive sweep employs a much finer step size Delta f=01text GHz. Additionally both sweeps have an explicit sample placed at 170text GHz. The adaptive fast frequency sweep algorithm is given a tolerance of 1times10^-3 for choosing the sampling points; the simulation with uniform ports uses 9 frequency samples and that with wave ports uses 10. Despite the much finer frequency resolution, the adaptive frequency sweep simulations take roughly the same amount of time as the uniform ones where the resulting resolution is worse by a factor of 20. Lastly, for all simulations, a second-order finite element approximation for the solution is used.\n\nThe results from the four different simulations are presented in the plots below. Note that here, textdB means 20log_10(S_ij):\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/cpw-p2-11.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cpw-p2-21.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cpw-p2-31.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cpw-p2-41.png\" width=\"70%\" />\n</p><br/>\n\nThe first remark is that in both the lumped port and wave port cases, the adaptive fast frequency sweep results are very close to the true solutions sampled by the uniform sweeps.\n\nSecond, there is a discrepancy between the results using lumped ports and those with wave ports, namely the lumped port excitation exhibits much higher reflection than for wave ports. This is expected when using a lumped port to approximate the termination of a CPW, and refining the mesh or increasing the order of the solution approximation leads to less reflection. See below for the results with again p = 4 for the order of the solution space, effectively doubling the spatial resolution from p = 2. For the adaptive solver in these plots, we have also reduced the adaptive tolerance to 1times10^-5 due to the small value of S_41.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/cpw-p4-11.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cpw-p4-21.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cpw-p4-31.png\" width=\"70%\" />\n  <img src=\"../../assets/examples/cpw-p4-41.png\" width=\"70%\" />\n</p><br/>\n\nnote: Note\nThe examples files for uniform sampling in examples/cpw actually specify excitations on two ports (\"multi-excitation\"). The two excitation are run in sequence during a single palace simulation.","category":"section"},{"location":"examples/cpw/#References","page":"Crosstalk Between Coplanar Waveguides","title":"References","text":"[1] H. J. Visser, Antenna Theory and Applications, Wiley, Hoboken, NJ, 2012.","category":"section"},{"location":"guide/postprocessing/","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"guide/postprocessing/#Postprocessing-and-Visualization","page":"Postprocessing and Visualization","title":"Postprocessing and Visualization","text":"As described in the section Problem Types, each simulation type writes relevant postprocessed scalar quantities to disk in the directory specified by config[\"Problem\"][\"Output\"], including but not limited to computed values like eigenfrequencies, scattering parameters, or lumped element parameters. In addition, each simulation type will write a file called domain-E.csv, which includes information about the electric and magnetic field energies, as well as lumped element energies, for each step of the simulation (eigenmode, frequency, or time step, for examples).\n\nModels containing lumped or wave port boundaries or surface current excitations will automatically postprocess quantities related to those boundaries. This is described in Ports and surface currents.\n\nThe participation ratios for bulk dielectrics and interface dielectric layers can be computed for simulations involving the electric field. For model boundaries, the integrated surface charge or magnetic flux can also be postprocessed. These features are described in Domain postprocessing and in Boundary postprocessing.\n\nAdditionally, the computed fields can be automatically probed for their vector values at one or more points in space. This probe functionality is also described in Domain postprocessing.\n\nFinally, as described further in Visualization, various field quantities on the 3D computational domain as well as 2D domain boundaries and material interfaces are written to disk when requested using the relevant parameters under config[\"Solver\"]. These fields are meant to be visualized with ParaView or GLVis.","category":"section"},{"location":"guide/postprocessing/#Ports-and-surface-currents","page":"Postprocessing and Visualization","title":"Ports and surface currents","text":"When lumped ports are present in a model, the lumped port voltages and currents computed for each step of the simulation (eigenmode, frequency, or time step) are written to ASCII files named port-V.csv and port-I.csv, respectively. These files also include the excitation voltage and current corresponding to the incident wave on excited port boundaries.\n\nAdditionally, when surface current excitations are present, the excitations are written to surface-I.csv.\n\nFor frequency domain problems, the values output are the complex-valued peak voltages and currents, computed from the field phasors.","category":"section"},{"location":"guide/postprocessing/#Domain-postprocessing","page":"Postprocessing and Visualization","title":"Domain postprocessing","text":"Domain postprocessing capabilities are enabled by including objects under config[\"Domains\"][\"Postprocessing\"] in the configuration file. These include:\n\nconfig[\"Domains\"][\"Postprocessing\"][\"Energy\"] : Postprocessess the electric and magnetic field energy inside of a given domain (associated with the specified domain attributes and indexed by the specified integer \"Index\"). These are from the electric and magnetic field solutions and written to the same domain-E.csv file in the specified postprocessing output directory used for the global energies (described above).\nconfig[\"Domains\"][\"Postprocessing\"][\"Probe\"] : Probe the values of the computed electric field and magnetic flux density solutions at specified locations in the computational domain. The availability of the bmE and bmB fields depends on the problem type (for example, for magnetostatic problems, only bmB is output and bmE is not computed, whereas the inverse is true for electrostatics). For each computed field, the postprocessed values are written to probe-E.csv and probe-B.csv in the specified output directory.","category":"section"},{"location":"guide/postprocessing/#Boundary-postprocessing","page":"Postprocessing and Visualization","title":"Boundary postprocessing","text":"Boundary postprocessing capabilities are enabled by including objects under config[\"Boundaries\"][\"Postprocessing\"] in the configuration file. These include:\n\nconfig[\"Boundaries\"][\"Postprocessing\"][\"SurfaceFlux\"] : Postprocess the integrated flux through a surface defined by a list of boundary attributes. Electric, magnetic, and power flux are all supported. Surface capacitance can be computed by dividing the computed electric flux by the excitation voltage, while inductance can be computed by dividing the computed magnetic flux by the excitation current. The resulting fluxes are written to surface-F.csv in the specified output directory.\nconfig[\"Boundaries\"][\"Postprocessing\"][\"Dielectric\"] : Postprocesses interface dielectric loss at surfaces of the model by specifying the interface thickness, permittivity, and loss tangent. See the Bulk and interface dielectric loss section of the reference, or https://arxiv.org/pdf/1509.01854.pdf or https://aip.scitation.org/doi/10.1063/1.3637047 for more information. The participation ratios and associated quality factors are written to the file surface-Q.csv in the specified output directory.","category":"section"},{"location":"guide/postprocessing/#Visualization","page":"Postprocessing and Visualization","title":"Visualization","text":"When specified in the configuration file, the electric field and magnetic flux density solutions are written to disk for 3D visualization with ParaView or GLVis. Various other postprocessed fields are also written to the ParaView or grid function (GLVis) database as available, including electric and magnetic energy density, surface currents, and charge density. These files are found in the paraview/ or gridfunction/ directories located in the output directory specified under config[\"Problem\"][\"Output\"]. The output formats are specified in config[\"Problem\"][\"OutputFormats\"].\n\nParaView is recommended to visualize large simulations in parallel. The grid function (GLVis) format can be useful to embed visualizations in webpages with its Javascript version.\n\nAll fields are written out in SI units and the post-processing mesh has the same units of config[\"Model\"][\"L0\"] m as the input mesh. The specific quantities available vary by simulation type, but the variable names and corresponding units for various possible postprocessed scalar and vector are:\n\nElectric field: E, E_real, and E_imag (V/m)\nMagnetic flux density: B, B_real, and B_imag (Wb/m²)\nElectric potential: V (V)\nMagnetic vector potential : A, A_real, and A_imag (A)\nElectric energy density : U_e (J/m³)\nMagnetic energy density : U_m (J/m³)\nPoynting vector: S (W/m²)\n\nAlso, at the final step of the simulation the following element-wise quantities are written for visualization:\n\nMesh partitioning (1-based): Rank\nError indicator: Indicator\n\nWhen saving fields in the grid function (GLVis) format, the file names have the format Field_xxxxxx.gf.yyyyyy where Field is the variable name of the postprocessed scalar or vector field, xxxxxx is the six-digit index of the terminal index (electrostatic or magnetostatic), time step index (transient), or frequency index (driven or eigenmode), and yyyyyy is the six-digit index of the rank of the corresponding MPI process.\n\nIn addition to the full 3D fields, a ParaView data collection for the boundary mesh and fields is also written to disk. The boundary mesh includes all surfaces with prescribed boundary conditions as well as any material interfaces in the computational domain. It is located in the same paraview/ directory, with suffix _boundary. The boundary data collection is only available for the ParaView output format.\n\nThe boundary data collection includes the 3D field values sampled on the boundary mesh as well as:\n\nSurface charge density: Q_s, Q_s_real, Q_s_imag (Wb/m²)\nSurface current density: J_s, J_s_real, J_s_imag (A/m)\nWave port boundary mode electric field: E0_real, E0_imag (V/m)","category":"section"},{"location":"guide/postprocessing/#Adaptive-mesh-refinement","page":"Postprocessing and Visualization","title":"Adaptive mesh refinement","text":"At the start of an adaptive mesh refinement (AMR) iteration, if config[\"Model\"][\"Refinement\"][\"SaveAdaptIterations\"] is enabled, the postprocessing results from the solve on the previous mesh will be saved off within a subdirectory denoted iterationX, where X is the (1-based) iteration number. The results in the top level directory will always be those from the most recent successful solve.","category":"section"},{"location":"run/","page":"Running Palace","title":"Running Palace","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"run/#Running-*Palace*","page":"Running Palace","title":"Running Palace","text":"Once installed into a directory <INSTALL_DIR>, a parallel simulation using Palace can be started with the following command:\n\n<INSTALL_DIR>/bin/palace -np <NUM_PROCS> config.json\n\nwhere\n\nThe installed palace script wraps a call to the desired MPI launcher (mpirun by default).\n<NUM_PROCS> is the number of MPI processes to use for the simulation.\nconfig.json is the JSON format configuration file used to specify the simulation parameters. The structure of this configuration file is outlined in detail in the section Configuration File.\n\nA full list of available script options is available using the -h or --help flag.\n\nDuring the course of a simulation, the solver will write a number of useful statistics and logging information to standard output. It is often helpful to save this information to a file, for example with:\n\n<INSTALL_DIR>/bin/palace ... | tee log.out\n\nOf course, the interested user can explicitly run the Palace binary in parallel, supplying options directly to their MPI launcher of choice, as:\n\n<MPI_RUN> [OPTIONS] <INSTALL_DIR>/bin/palace-<ARCH>.bin config.json\n\nwhere <MPI_RUN> is the MPI launcher command, [OPTIONS] is a list of command line options passed to the MPI launcher, and <ARCH> is the machine architecture (x86_64 or arm64).","category":"section"},{"location":"run/#Singularity/Apptainer","page":"Running Palace","title":"Singularity/Apptainer","text":"Assuming Palace was built using Singularity/Apptainer to palace.sif, running:\n\nsingularity run palace.sif <ARGS...>\n\ncorresponds to running a Palace simulation with command line arguments <ARGS...> using:\n\n<INSTALL_DIR>/bin/palace <ARGS...>\n\nas described above.","category":"section"},{"location":"guide/problem/","page":"Problem Types","title":"Problem Types","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"guide/problem/#Problem-Types","page":"Problem Types","title":"Problem Types","text":"","category":"section"},{"location":"guide/problem/#Eigenmode-problems","page":"Problem Types","title":"Eigenmode problems","text":"For eigenmode simulations, config[\"Problem\"][\"Type\"]: \"Eigenmode\", the user should specify a nonzero (but arbitrarily small) frequency above which to search for eigenmodes. The computed eigenvalues are written to an ASCII file named eig.csv, in the directory specified by config[\"Problem\"][\"Output\"]. Also in this file are the mode quality factors and errors (absolute and backward) computed for each eigenpair.\n\nCalculations related to energy-participation ratio (EPR) quantization can be performed with Palace when the user specifies lumped ports corresponding to the linearized lumped circuit elements in the model. In this case, the participation matrix for inductive elements is automatically generated for the specified number of modes and number of inductive lumped ports. The participation matrix is output in an ASCII file named port-EPR.csv.\n\nThe EPR framework can be used to characterize the dissipative elements in the model as well. In particular, lumped ports with nonzero resistance in the model will trigger coupling rate and quality factor calculations based on input-output (I-O) line coupling loss: By specifying resistive lumped ports in the model, the mode coupling quality factors will be computed as Q_ml = omega_mkappa_ml. The output file port-Q.csv will be created in the output directory containing these mode quality factor contributions. For bulk and interface dielectric loss calculations, which are not unique to the eigenmode simulation type, see the sections Domain postprocessing and Boundary postprocessing of this guide.","category":"section"},{"location":"guide/problem/#Driven-problems-in-the-frequency-domain","page":"Problem Types","title":"Driven problems in the frequency domain","text":"For frequency domain driven simulations, config[\"Problem\"][\"Type\"]: \"Driven\", the model is excited by a time harmonic incident field (port boundary) or surface current. The user can specify a port excitation using lumped ports or numeric wave ports.\n\nThe default frequency sweep behavior for frequency domain driven simulations is to perform a uniform sampling from the minimum to the maximum specified frequency of interest, using the user specified step size. An adaptive fast frequency sweep strategy can also be used, activated by specifying a nonzero value for \"AdaptiveTol\" under the config[\"Solver\"][\"Driven\"] object. In this case, using the high-dimensional model solution computed at a few automatically selected frequency samples, a low-cost model is constructed and used to compute the frequency response over the entire frequency range of interest. The specified error tolerance ensures that the approximate low-cost model is reliably accurate relative to the high-dimensional model within the frequency band of interest. This is particularly useful for fine-resolution sweeps containing many sample points, where it can yield a significant speedup over the default strategy.\n\nPort scattering parameters, or S-parameters, are postprocessed for the column of the scattering matrix corresponding to the driven port index automatically for this simulation type and stored in an ASCII file named port-S.csv, in the directory specified by config[\"Problem\"][\"Output\"]. Both the textdB magnitude (20log_10(S_ij)) and the phase angle(S_ij) (in degrees) are written to the file. In the case that more than a single lumped or wave port is excited or surface current excitations are used, scattering parameter output will be disabled for the simulation (though other quantities of interest are still postprocessed). When lumped ports are present, the peak complex lumped port voltages and currents computed for each excitation frequency are written to ASCII files named port-V.csv and port-I.csv, respectively, Additionally, the surface current excitations are written to surface-I.csv.\n\nIt is often the case that a user wants to compute the entire scattering matrix rather than just a single column. In this case, each column can be computed in parallel by running Palace multiple times. For example, consider the following short Python code which modifies a base configuration file config.json to generate a complete 4x4 scattering matrix by running 4 Palace simulations, each with 2 MPI processes:\n\nimport json\nimport os\nimport subprocess\n\n# Base configuration file\nconfig_path = \"config.json\"\n\nfor i in range(4):\n    # Prepare configuration file for simulation\n    with open(config_path, \"r\") as f:\n        config_json = json.loads(f.read())\n    for port in config_json[\"Boundaries\"][\"LumpedPort\"]:\n        port[\"Excitation\"] = (1+i == port[\"Index\"])\n\n    # Write new config file\n    config_path_i = os.path.splitext(config_path)[0] + f\"-{1+i}.json\"\n    with open(config_path_i, \"w\") as f:\n        f.write(json.dumps(config_json))\n\n    # Run Palace simulation (alternatively, use Popen and wait)\n    subprocess.run([\"palace\", \"-np\", 2, config_path_i])","category":"section"},{"location":"guide/problem/#Driven-problems-in-the-time-domain","page":"Problem Types","title":"Driven problems in the time domain","text":"The previous simulation types describe simulations based on frequency domain formulations of Maxwell's equations. Time domain simulations are also possible through the transient simulation type: config[\"Problem\"][\"Type\"]: \"Transient\".\n\nSimilar to the driven simulation type in the frequency domain, transient simulations involve simulating the response of the system to a time-dependent excitation field specified at lumped ports or surface current excitations in the model. The system is always started from rest with zero initial conditions and time-integrated for a user specified duration, given in nanoseconds. There are several available excitation types which define the time dependence of the pulse or excitation waveform. These are specified under the config[\"Solver\"][\"Transient\"] object using the \"Excitation\" keyword.\n\nThe time histories of the lumped port voltages and currents are postprocessed and automatically written to ASCII files named port-V.csv and port-I.csv, respectively, in the directory specified by config[\"Problem\"][\"Output\"]. Additionally, surface current excitation time histories are written to surface-I.csv.","category":"section"},{"location":"guide/problem/#Electrostatic-problems","page":"Problem Types","title":"Electrostatic problems","text":"For electrostatic simulations, (config[\"Problem\"][\"Type\"]: \"Electrostatic\", the user should specify a number of terminal boundaries (config[\"Boundaries\"][\"Terminal\"]) as well as boundaries which are grounded (config[\"Boundaries\"][\"Ground\"]). For each terminal, an electrostatic field is computed by assigning the terminal of interest a positive unit voltage and all other terminals and grounded boundaries a zero voltage. The resulting fields are then used to compute the Maxwell capacitance matrix and its inverse, which are written to an ASCII file named terminal-C.csv and terminal-Cinv.csv, respectively, in the directory specified by config[\"Problem\"][\"Output\"]. The mutual capacitance matrix is also computed and written to terminal-Cm.csv in the same directory.","category":"section"},{"location":"guide/problem/#Magnetostatic-problems","page":"Problem Types","title":"Magnetostatic problems","text":"For magnetostatic simulations, (config[\"Problem\"][\"Type\"]: \"Magnetostatic\", the user should specify a number of source current boundaries. For each current source, a magnetostatic field is computed by applying a unit current to the source index of interest, leaving all other sources open with no excitation. Surfaces which are expected to carry current should be labeled as perfectly conducting, which prescribes a zero magnetic flux, or magnetic insulation, boundary condition. The resulting fields are used to compute the inductance matrix and its inverse, which are written to an ASCII file named terminal-M.csv and terminal-Minv.csv, respectively, in the directory specified by config[\"Problem\"][\"Output\"]. A \"mutual\" inductance matrix which has the same form as the mutual capacitance matrix (its entries are based on current differences between ports rather than absolute currents) is computed and written to terminal-Mm.csv in the same directory.","category":"section"},{"location":"developer/notes/","page":"Developer Notes","title":"Developer Notes","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"developer/notes/#Developer-Notes","page":"Developer Notes","title":"Developer Notes","text":"","category":"section"},{"location":"developer/notes/#Units","page":"Developer Notes","title":"Units","text":"For interactions with users (inputs and outputs), Palace mostly uses SI units, and where it doesn't it uses metric units (SI with prefix modifiers e.g. km, um, nJ). However, internally, there are three unit systems that are used within any given Palace simulation.\n\nFirst, the mesh comes with its own unit of length. Users specify the conversion between one unit of length on the mesh to meters through the config[\"Model\"][\"L0\"] parameter.\n\nSecond, Palace defines a system of non-dimensional units where the actual solver operates.\n\nThird, postprocessing occurs in a custom variant of SI units where the unit of time is nanoseconds instead of seconds. This is more suitable for the problems Palace is designed to solve.\n\nThe second and third systems are described by the Units class defined in units.hpp.","category":"section"},{"location":"developer/notes/#Non-dimensional-unit-system","page":"Developer Notes","title":"Non-dimensional unit system","text":"The non-dimensional unit system is constructed as follows:\n\nLength: Lengths are measured in units of the characteristic length Lc, which is the mesh size in mesh units, unless Lc is manually specified in config[\"Model\"][\"Lc\"]. The extent of the mesh is 1 in these units, with extent defined as the largest single dimension (e.g., for a cuboid of size 10m x 20m x 40m, this would be 40m).\n\nTime: One unit of non-dimensional time is the time it takes light to travel one Lc (equivalently, the speed of light is 1 in these units).\n\nElectromagnetic quantities: Palace uses Heaviside-Lorentz units, essentially meaning that ε₀ = μ₀ = 1 (so that in addition to setting c = 1, the impedance of free space Z₀ is also 1).\n\nThe final unit in the system is chosen so that the power flowing through a surface of area Lc² perpendicular to the direction of propagation in vacuum with a uniform magnetic field of strength 1 is exactly 1 (P = H^2 * Z * L^2, with Z impedance). This choice is related to the normalization of power across ports.\n\nAn equivalent mental model about non-dimensional quantities in Palace is to think in terms of characteristic values instead of units: the non-dimensional quantities are physical quantities normalized by reference values. These reference values are effectively chosen to satisfy the constraints on space, time and power given above. For example, the magnetic field strength H solved for is actually H/Hc, where Hc satisfies Hc² × Z₀ × Lc² = 1 W, with Z₀ impedance of free space. Similarly, the non-dimensional electric field E is E/Ec with Ec = Z₀ × Hc.\n\nnote: Example: converting times and distances\nConsider a spherical mesh with L0 of 1 micron and radius of 3 in mesh units. Then:Mesh size in mesh units: 6\nMesh size in non-dimensional units: 1\nMesh size in dimensional units: 6e-6\nMesh size in SI: 6e-6 meters\nSpeed of light in non-dimensional units: 1\nSpeed of light in dimensional units: 0.3\nSpeed of light in SI: 3e8 meters/seconds\nTime for light to cross the sphere in non-dimensional units: 1\nTime for light to cross the sphere in dimensional units: 2e-5\nTime for light to cross the sphere in SI: 2e-14 seconds\n\nwarning: Non-SI time units\nThe dimensional unit system uses nanoseconds for time, not seconds. This affects unit combinations: units::POWER * units::TIME is not equivalent to units::ENERGY. This choice of nanoseconds reflects a prioritization of the microwave engineering domain within Palace, as the typical frequencies in GHz (which correspond to time scales of nanoseconds).\n\nwarning: Omega instead of Frequency\nInternally, Palace uses the angular frequency omega instead of the regular frequency, with both names omega and freq being used.\n\nwarning: Finite element considerations\nChanging mesh units requires additional rescaling for fields defined on H(curl) and H(div) spaces to convert them to proper physical units. This is a function of the length scales inherent to the reference element transformations for Nédélec and Raviart Thomas spaces, used for H(curl) and H(div) respectively. See the ScaleGridFunctions function in PostOperator for details.","category":"section"},{"location":"developer/notes/#Style-guide","page":"Developer Notes","title":"Style guide","text":"Automated source code formatting is performed using clang-format. Run:\n\n./scripts/format_source\n\nin the repository root directory to automatically use clang-format to format C++ source as well as JuliaFormatter.jl for Julia and Markdown files. The script can be viewed in the repository.\n\nThe following conventions also apply:\n\nPascalCase for classes and function names.\nFollow 'include what you use' (IWYU), with the include order dictated by the Google C++ Style Guide. This order should be automatically enforced by the clang-format style file.\nCode comments should be full sentences, with punctuation. At this time, no Doxygen API reference is generated and so comments generally do not need to conform to Doxygen syntax.","category":"section"},{"location":"developer/notes/#Static-analysis","page":"Developer Notes","title":"Static analysis","text":"During the cmake configuration step, defining the variables ANALYZE_SOURCES_CLANG_TIDY and ANALYZE_SOURCES_CPPCHECK to ON will turn on static analysis using clang-tidy and cppcheck, respectively, during the build step. This requires the executables to be installed and findable by CMake on your system.","category":"section"},{"location":"developer/notes/#Extending-GPU-code-in-*Palace*","page":"Developer Notes","title":"Extending GPU code in Palace","text":"Palace supports GPU parallelization, but not all the files in Palace are compiled with a GPU-compatible compiler (e.g., nvcc). The reason for this is that such compilers might not support all the features Palace needs (e.g., support for constexpr std::sqrt), and also because they tend to be slower. The list of files that contains code that has to run on the device is defined by the TARGET_SOURCES_DEVICE CMake variable.","category":"section"},{"location":"developer/notes/#JSON-Schema-for-configuration-files","page":"Developer Notes","title":"JSON Schema for configuration files","text":"A JSON format configuration file, for example named config.json, can be validated against the provided Schema using:\n\n./scripts/validate_config config.json\n\nThis script uses Julia's JSONSchema.jl and the Schema provided in scripts/schema/ to parse the configuration file and check that the fields are correctly specified. This script and the associated Schema are also installed and can be accessed in <INSTALL_DIR>/bin.","category":"section"},{"location":"developer/notes/#Timing","page":"Developer Notes","title":"Timing","text":"Timing facilities are provided by the Timer and BlockTimer classes.\n\nCreating a block as BlockTimer b(idx) where idx is a category like CONSTRUCT, SOLVE, etc. will record time so long as b is in scope; however, timing may be interrupted by creation of another BlockTimer object. It will resume whenever the new block is destroyed. Only one category is timed at once. This enables functions to declare how calls within them are timed without needing to know how timing may be done by the calling function.\n\nThe BlockTimer implementation relies upon a static member object of the Timer class, which behaves as a stopwatch with some memory functions. It is the responsibility of this BlockTimer::timer object to record time spent in each recorded category. Other Timer objects may be created for local timing purposes, but these will not count toward time reported at the end of a log file or in the metadata JSON.\n\nFor each Palace simulation, a table of timing statistics is printed out before the program terminates. The minimum, maximum, and average times across all MPI processes are included in the table. Timer categories are exclusive, they do not overlap. The categories for breaking down the total simulation time are:\n\nInitialization                  // < Time spent parsing the configuration file,\n                                //   preprocessing and partitioning the mesh\nOperator Construction           // < Time spent constructing finite element spaces and\n                                //   setting up linear and bilinear forms on those spaces\n  Wave Ports                    // < Time spent configuring and computing the modes\n                                //   associated with wave port boundaries\nLinear Solve                    // < Linear solver time\n  Setup                         // < Setup time for linear solver and preconditioner\n  Preconditioner                // < Preconditioner application time for linear solve\n  Coarse Solve                  // < Coarse solve time for geometric multigrid\n                                //   preconditioners\nTime Stepping                   // < Time spent in the time integrator for transient\n                                //   simulation types\nEigenvalue Solve                // < Time spent in the eigenvalue solver (not including\n                                //   linear solves for the spectral transformation, or\n                                //   divergence-free projection)\nDiv.-Free Projection            // < Time spent performing divergence-free projection (used\n                                //   for eigenmode simulations)\nPROM Construction               // < Offline PROM construction time for adaptive fast\n                                //   frequency sweep\nPROM Solve                      // < Online PROM solve and solution prolongation time for\n                                //   adaptive fast frequency sweep\nEstimation                      // < Time spent computing element-wise error estimates\n  Construction                  // < Construction time for error estimation global linear\n                                //   solve\n  Solve                         // < Solve time for error estimation global linear solve\nAdaptation                      // < Time spent performing adaptive mesh refinement (AMR)\n  Rebalancing                   // < Rebalancing time for AMR simulations with rebalancing\nPostprocessing                  // < Time spent in postprocessing once the field solution\n                                //   has been computed\n  Far Fields                    // < Time spent computing surface integrals to extrapolate\n                                //   near fields to far fields\n  Paraview                      // < Processing and writing Paraview fields for visualization\n  Grid function                 // < Processing and writing grid function fields for visualization\nDisk IO                         // < Disk read/write time for loading the mesh file and\n                                //   writing CSV fields\n-----------------------\nTotal                           // < Total simulation time","category":"section"},{"location":"developer/notes/#Profiling-*Palace*-on-CPUs","page":"Developer Notes","title":"Profiling Palace on CPUs","text":"A typical Palace simulation spends most of its time in libCEED kernels, which, in turn, executed libsxmm code on CPUs. Libsxmm generates code just-in-time to ensure it is the most performant on the given architecture and for the given problem. This code generation confuses most profilers. Luckily, libsxmm can integrate with the VTune APIs to enable profiling of jitted functions as well.\n\nnote: Using a different libCEED backend?\nThe following notes assume that you are using the libxsmm backend for libCEED. If this is not the case and you have a preference for other profilers, such as perf or HPCToolkit, you can consider using them as well.","category":"section"},{"location":"developer/notes/#Requirements","page":"Developer Notes","title":"Requirements","text":"Verify your system meets the VTune system requirements\nInstall VTune Profiler\nSet VTune's root directory during Palace build (see below)\nUse RelWithDebInfo build type for optimal profiling results","category":"section"},{"location":"developer/notes/#Building-*Palace*-with-VTune-Support","page":"Developer Notes","title":"Building Palace with VTune Support","text":"From the Palace root directory:\n\n$ source /path/to/vtune-vars.sh # Replace with your VTune installation path\n$ mkdir build && cd build\n$ cmake .. -DCMAKE_BUILD_TYPE=RelWithDebInfo\n$ make -j $(nproc)","category":"section"},{"location":"developer/notes/#Running-a-Basic-Profile","page":"Developer Notes","title":"Running a Basic Profile","text":"A flamegraph can be created using either:\n\nThe VTune graphical user interface\nThe command line interface\n\nFollow Intel's official instructions for detailed usage information.\n\nBelow is a sample flamegraph resulted from profiling the rings example located at /examples/rings/rings.json with polynomial order P=6 (Solver[\"Order\"]: 6).\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/profiling/vtune-flamegraph.png\" width=\"100%\" />\n</p><br/>\n\nNote: Set Verbose: 0 in the JSON file to reduce terminal output. For profiling, use the binary executable (build/bin/palace-*.bin) rather than the build/bin/palace wrapper script.\n\nFor MPI profiling with multiple processes:\n\n# Run with 10 MPI processes\n$ cd /path/to/palace/examples/rings\n$ mpirun -n 10 -gtool \"vtune -collect hpc-performance --app-working-dir=$(pwd) -result-dir $(pwd)/vtune-mpi:0-9\" /path/to/palace/build/bin/palace-x86_64.bin rings.json\n\n# Open the results from VTune GUI\n$ vtune-gui vtune-mpi.*","category":"section"},{"location":"developer/notes/#Developing-the-spack-recipe","page":"Developer Notes","title":"Developing the spack recipe","text":"To use the local Spack recipe (make sure you have Spack installed)\n\nspack repo add /path/to/palace/spack_repo/local\n\nVerify that the repo is there:\n\nspack repo list\n\nNow, you can refer to the development spack palace with local.palace. For example,\n\nspack spec local.palace@develop\n\nwill show you the spec for your most recent palace package, which you can compare with the one for builtin.palace@develop.","category":"section"},{"location":"developer/notes/#Changelog","page":"Developer Notes","title":"Changelog","text":"Code contributions should generally be accompanied by an entry in the changelog.","category":"section"},{"location":"examples/antenna/","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"examples/antenna/#Dipole-Antenna-and-Radiation-Fields","page":"Dipole Antenna and Radiation Fields","title":"Dipole Antenna and Radiation Fields","text":"note: Note\nThe files for this example can be found in the examples/antenna/ directory of the Palace source code. In this example, we increased the number of sampling points from 100 to 64800.\n\nIn this example, we study a half-wave dipole antenna and analyze its radiation characteristics. The dipole antenna is one of the most fundamental antenna types, consisting of two conducting elements of length L fed at the center by a sinusoidal excitation.\n\nFor an infinitely thin half-wave dipole, the problem can be solved analytically and the solution serves as our reference for validation [1]. In the wave-zone, the operating wavelength in free space lambda is twice the total length of the antenna (lambda = 2 times 2L = 4L). The normalized field pattern on the E-plane (xz-plane) is given by\n\nE(theta) = leftfraccosleft(fracpi2costhetaright)sinthetaright\n\nwhile the pattern is isotropic on the H-plane (xy-plane).\n\nWe will model a dipole antenna with arm length L and finite radius a, solve a driven problem at the resonant frequency lambda = 4L and extract the radiation pattern P(theta) with Palace's far-field extraction capabilities).","category":"section"},{"location":"examples/antenna/#Problem-Setup","page":"Dipole Antenna and Radiation Fields","title":"Problem Setup","text":"The dipole is modeled as two thin infinitely conductive cylindrical wires with length L = 1text m and radius a = L20 = 5text cm, separated by a thin cylindrical gap of height h = L100 = 1text cm. Given these geometrical characteristics, the operating wavelength is approximately lambda = 4text m, corresponding to a frequency of nu = c  lambda = 00749text GHz.\n\nThe gap serves as the excitation point for the antenna. Rather than explicitly modeling the feeding circuit, we place a flat rectangular strip on the xz-plane that connects the two arms of the antenna. This strip functions as a lumped port to excite the system.\n\nThe surrounding medium is free space. In reality, electromagnetic waves would propagate freely to infinity. We model this by enclosing the antenna in a sphere of radius r_max = 15lambda = 6text m centered at the origin and applying appropriate boundary conditions to simulate the infinite domain.\n\nThe mesh is generated using Gmsh and consists of tetrahedral elements with appropriate refinement near the antenna structure. The element size increases with distance from the antenna, but is capped to ensure the wavelength is resolved by at least a few elements per wavelength. The mesh file is mesh/antenna.msh and is generated using the Julia script mesh/mesh.jl.\n\nA visualization of the model and the resulting mesh is shown below.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/antenna-1.png\" width=\"45%\" />\n  <img src=\"../../assets/examples/antenna-2.png\" width=\"45%\" />\n</p><br/>\n\nThe left image shows the outer domain and the inner antenna structure. The right image provides a close-up view of the gap region, where the rectangular port is aligned on the xz-plane and spans the diameter of the cylindrical conductors.","category":"section"},{"location":"examples/antenna/#Configuration-File","page":"Dipole Antenna and Radiation Fields","title":"Configuration File","text":"The configuration file for the Palace simulation is found in antenna_halfwave_dipole.json. The simulation is performed in the frequency domain using the \"Driven\" solver type, operating at a single frequency of 00749text GHz.\n\nSince we assume the metallic rods are perfect conductors, we impose perfect electric conductor (PEC) boundary conditions on their surfaces. To prevent reflections of electromagnetic waves back into the computational domain, we apply \"Absorbing\" boundary conditions on the outer spherical boundary.\n\nThe antenna is driven using the rectangular strip as a lumped port. This port lies entirely in the xz-plane, and by setting \"Direction\": \"+Z\" and \"Excitation\": true, we impose an electric field aligned in the z-direction across the gap.\n\nWe use the far-field extraction feature in Palace to extract electric fields at infinity. To do so, we add a \"PostProcessing\" section under \"Boundaries\" with the same Attributes as the surface with \"Absorbing\" boundary conditions and we choose a positive value for \"NSample\". A NSample of 64800 means that the far-field sphere is uniformly discretized with resolution of one degree on the equator (to preserve the uniform distribution, the resolution changes as one moves towards the poles).\n\ntip: ComplexCoarseSolve solver optimization\nThis simulation benefits from the \"ComplexCoarseSolve\" option. This setting uses a complex preconditioner of the form P = [Ar, -Ai; Ai, Ar] rather than the default P = Ar + Ai, where A is the true system matrix with real and imaginary  parts Ar and Ai. While the resulting system is four times larger, it preserves the coupling between real and imaginary parts which can be significant for problems with strong imaginary components. For this particular problem, this approach accelerates convergence by several factors, though at the cost of increased memory usage.","category":"section"},{"location":"examples/antenna/#Analysis-and-Results","page":"Dipole Antenna and Radiation Fields","title":"Analysis and Results","text":"The simulation requires approximately 6 GBs of RAM and completes in a few minutes (depending on the hardware). The simulation produces a 160 MB postpro folder, which contains the electromagnetic fields that we will use to extract radiation patterns.\n\nFirst, let us look at the far-field output. The postpro/antenna_halfwave_dipole folder contains a file, farfield-rE.csv, with the far-field electric fields for the all the target frequencies (in this case, only 7.49000000e-02 GHz). The first few lines of this file are:\n\ninclude_example_file(\"antenna/antenna_halfwave_dipole\", \"farfield-rE.csv\") #hide\n\nThe plot_farfield.jl Julia script processes this file and produces plots polar for the E- and H- planes (xz/xy-planes) and in the 3D.\n\njulia --project plot_farfield.jl model=antenna_halfwave_dipole file=postpro/antenna_halfwave_dipole/farfield-rE.csv\n\nThe results for the polar plot are shown below.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/antenna-3.png\" width=\"100%\" />\n</p><br/>\n\nOn the H-plane, we see the expected isotropic emission pattern for any of the extracted radii. On the E-plane, we see agreement with the characteristic figure-eight pattern of a dipole antenna, with maximum radiation perpendicular to the antenna axis and nulls approximately along the antenna axis.\n\nnote: Do your results look different?\nIf you are trying to reproduce this plot, but find that your plots are not as nice as the one above, you might have a missed a note at the top of this page: the example was run with 64800 sampling points instead of the 100 that the JSON file specifies. Change NSample to 64800 and run your simulation again. Moreover, the variable n_farfield in mesh.jl was increased from 3 to 10 for creating the mesh.\n\nWe can see the same pattern rendered in 3D as well\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/antenna-4.png\" width=\"80%\" />\n</p><br/>\n\nThis plot shows the 3D relative antenna pattern representing the normalized strength of the electric field as function of the distance from the origin. Once again, we see the expected donut shape, with maximal electric field strength on the equator, and minimum along the z axis.\n\nnote: Running the Julia script\nThe plot_radiation_pattern.jl requires a number of Julia packages (including the plotting library). The simplest way to ensure that you have all the required packages is to use the Project.toml included with the examples. To install this environment, navigate to the examples folder and runjulia --project -e 'using Pkg; Pkg.instantiate();'All the subsequent times, just make sure to start Julia with --project from the examples folder or one of its subfolders.","category":"section"},{"location":"examples/antenna/#Alternative:-Short-Dipole-Using-the-Electric-Current-Dipole-Operator","page":"Dipole Antenna and Radiation Fields","title":"Alternative: Short Dipole Using the Electric Current Dipole Operator","text":"As an alternative to explicitly modeling the antenna geometry with a lumped port excitation, Palace provides an electric current dipole operator that represents an infinitesimally short current-carrying wire. This approach is particularly useful for theoretical studies or when the detailed geometry of the feeding structure is not critical to the analysis.","category":"section"},{"location":"examples/antenna/#Background","page":"Dipole Antenna and Radiation Fields","title":"Background","text":"An electrical current dipole can be thought of as the limiting case of a finite wire segment carrying current I over length Delta s as Delta s rightarrow 0. The strength of the source is characterized by its dipole moment mathbfp = I  ds, where ds is the infinitesimal length [2]. The source term in Maxwell's equations becomes\n\nmathbfJ_e^s = mathbfp  delta(x) delta(y) delta(z)\n\nwhere delta represents the Dirac delta function, indicating that the source is concentrated at a single point in space.\n\nFor a z-oriented electrical current dipole (short dipole) in free space, the far-field radiation pattern in the E-plane (xz-plane) follows\n\nmathbfE_theta^2 propto sintheta^2\n\nwith omnidirectional radiation in the H-plane (xy-plane). This differs from the half-wave dipole pattern shown earlier, which exhibits a characteristic leftfraccosleft(fracpi2costhetaright)sinthetaright^2 dependence.","category":"section"},{"location":"examples/antenna/#Configuration-and-Running-the-Example","page":"Dipole Antenna and Radiation Fields","title":"Configuration and Running the Example","text":"A complete example using the current dipole operator is provided in antenna_short_dipole.json. The configuration uses a \"CurrentDipole\" specification in the \"Domains\" section:\n\n\"Domains\":\n{\n    \"Materials\":\n    [\n        {\n            \"Attributes\": [5, 6, 7]\n        }\n    ],\n    \"CurrentDipole\": [\n        {\n            \"Index\": 1,\n            \"Moment\": 1.0,\n            \"Center\": [0.0, 0.0, 0.0],\n            \"Direction\": [0, 0, 1]\n        }\n    ]\n}\n\nThe key parameters are:\n\n\"Index\": Identifier for this current dipole source (used in postprocessing output)\n\"Moment\": Current dipole moment magnitude mathbfp in A·m\n\"Center\": Coordinates of the dipole center position in mesh length units\n\"Direction\": Direction vector of the current dipole moment (automatically normalized)\n\nwhere the material attributes 5 and 6 represent the volume of the cylindrical arms while the PEC boundary condition on the surface of these arms and the lumped port in the half-wave dipole example is removed. The outer spherical boundary with \"Absorbing\" conditions and the far-field postprocessing setup remain the same.\n\nnote: Changing dipole orientation\nOne of the key advantages of using the current dipole operator is the ease of changing the antenna orientation. By modifying the \"Direction\" parameter, you can align the dipole along any axis without needing to regenerate a mesh. For example, \"Direction\": [1, 0, 0] creates an x-oriented dipole, while \"Direction\": [0, 1, 0] creates a y-oriented dipole.\n\nThe following plots show the spatial distribution of the real part of the electric field in the yz-plane (left) and xy-plane (right), illustrating the near-field behavior of the short dipole antenna.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/antenna-5a.png\" width=\"45%\" />\n  <img src=\"../../assets/examples/antenna-5b.png\" width=\"45%\" />\n</p>\n\nThe far-field radiation pattern can be visualized using the same plotting script used for the half wave dipole, by specifying the short dipole model type:\n\njulia --project plot_farfield.jl model=antenna_short_dipole file=postpro/antenna_short_dipole/farfield-rE.csv\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/antenna-6.png\" width=\"100%\" />\n</p><br/>\n\nThe polar plots show the theoretical radiation pattern for a short dipole: the E-plane exhibits the sintheta^2 dependence decaying to zero on the dipole axis (θ = 0° and 180°) and maximum radiation perpendicular to the dipole (θ = 90°), while the H-plane shows the expected omnidirectional pattern. The 3D far-field pattern is also visualized:\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/antenna-7.png\" width=\"80%\" />\n</p><br/>\n\nnote: Do your results look different?\nIn order to generate smooth, high-resolution plots as shown above and just like the half-wave dipole example, we used NSample=64800 in the JSON file and n_farfield=10 in mesh.jl to create the mesh.","category":"section"},{"location":"examples/antenna/#References","page":"Dipole Antenna and Radiation Fields","title":"References","text":"[1] Stutzman, W. L., & Thiele, G. A., Antenna Theory and Design (3rd ed.), John Wiley & Sons, 2012.\n\n[2] Heagy, L. J., Cockett, R., Kang, S., Rosenkjaer, G. K., & Oldenburg, D. W., \"Defining the Electrical Current Dipole,\" EM GeoSci, https://em.geosci.xyz/content/maxwell1fundamentals/dipolesourcesinhomogeneousmedia/electricdipole_definition/index.html.","category":"section"},{"location":"faq/","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"faq/#Frequently-Asked-Questions","page":"Frequently Asked Questions","title":"Frequently Asked Questions","text":"Pages = [\"faq.md\"]\nDepth = 3\n\nThis page addresses common questions and issues that users encounter when working with Palace. If you don't find the answer to your question here, please check the issue tracker or consider opening a new issue.","category":"section"},{"location":"faq/#Installation","page":"Frequently Asked Questions","title":"Installation","text":"","category":"section"},{"location":"faq/#Can-I-install-Palace-on-Windows?","page":"Frequently Asked Questions","title":"Can I install Palace on Windows?","text":"We do not officially support or routinely test Palace on Windows and do not provide precompiled binaries for this platform. Users have reported success running Palace on Windows Subsystem for Linux (WSL) using an Ubuntu image. This approach essentially gives you a Linux environment within Windows, which is compatible with Palace's build system and dependencies.\n\nSupport for Palace on WSL is provided on a best-effort basis. If you encounter problems, please open an issue on our GitHub repository and we will do our best to help you resolve them (but we do not guarantee support).\n\nBefore reporting issues, we recommend searching through the issue tracker for existing discussions, known issues, and user-contributed solutions.","category":"section"},{"location":"faq/#Common-WSL-Pitfalls","page":"Frequently Asked Questions","title":"Common WSL Pitfalls","text":"When working with Palace on WSL, be aware of these two frequent issues:\n\nMissing system packages: The Ubuntu base image in WSL is minimal and lacks several packages that Palace's build process expects. You may need to install additional system packages even when using Spack, which normally handles dependencies automatically. Common missing packages include build tools, development headers, and system libraries.\nResource limitations: Windows can constrain the memory, CPU, and disk resources allocated to WSL, which may limit the size and complexity of simulations you can run. If you encounter out-of-memory errors or unusually slow performance, you may need to adjust these limits through the WSL configuration settings.","category":"section"},{"location":"faq/#I-installed-Palace-and-downloaded-the-example-files,-but-I-get-errors","page":"Frequently Asked Questions","title":"I installed Palace and downloaded the example files, but I get errors","text":"Palace is under active development with new features constantly being added and the interface being refined. At this stage, Palace versions are not fully cross-compatible, which means configuration files and examples from one version may not work correctly with another version. For this reason, it is crucial to consult the documentation that corresponds to the exact version of Palace you are using.\n\nThe official documentation includes a version selector at the bottom of the sidebar to help you choose the correct documentation version. We generally recommend using the most recent version of Palace unless you have specific reasons to use an older version.\n\nThe most common cause of errors when running examples is a mismatch between your Palace version and the example files you're using. Here's how to ensure compatibility:\n\nCheck your Palace version by running palace --version in your terminal (if --version is supported, if not, check the log of any Palace simulation)\nNavigate to the documentation for your specific version using the version selector\nDownload example files from the GitHub repository at the tag or commit corresponding to your version\n\nnote: Following GitHub links from the released documentation\nCurrently, the documentation links always point to the GitHub pages for the main branch. If you follow these links directly, you might get versions of the examples that are inconsistent with your Palace installation. To get the correct examples:Go to the Palace GitHub repository\nUse the branch/tag selector to switch to the tag corresponding to your version (e.g., v0.14.0)\nDownload the examples from that specific version","category":"section"},{"location":"faq/#Spack-does-not-have-the-most-recent-version-of-Palace","page":"Frequently Asked Questions","title":"Spack does not have the most recent version of Palace","text":"If you tried installing Palace with Spack and found that you got an outdated version, there are typically two reasons for this issue.\n\nThe most common cause is that you're using an old version of the Spack package recipes. Spack maintains a repository of package definitions that needs to be updated periodically to include new software versions.\n\nTo update your local Spack repository, run:\n\nspack repo update -b develop builtin\n\nAfter updating, you can check what versions of Palace are now available with:\n\nspack versions palace\n\nThis command will show you all the Palace versions that Spack knows about, including any newly added ones.\n\nA less common reason is that the newest version of Palace hasn't been added to Spack yet. This can happen when a new Palace release is very recent and the Spack maintainers haven't had time to update the package definition.\n\nYou can check if this is the case by:\n\nLooking at the open pull requests to the spack-packages repository\nSearching for a PR that updates Palace to the version you want\nIf such a PR exists, you can track its progress and wait for it to be merged\n\nOnce the PR is merged, run the update command shown above to pull the changes to your local copy of Spack.","category":"section"},{"location":"faq/#Installing-Development-Versions","page":"Frequently Asked Questions","title":"Installing Development Versions","text":"If you need the absolute latest version of Palace (including features not yet in a released version), you can install the development version directly from the main branch:\n\nspack install palace@develop\n\nKeep in mind that development versions may be less stable and are not recommended for production use.","category":"section"},{"location":"faq/#I-installed-Palace-with-Spack-and-a-new-version-was-released.-How-do-I-update-Palace?","page":"Frequently Asked Questions","title":"I installed Palace with Spack and a new version was released. How do I update Palace?","text":"Spack does not have a built-in mechanism to update packages in place. In fact, Spack is designed to allow multiple versions of the same package to coexist simultaneously, which is useful for reproducibility and testing different versions.\n\nWhen a new version of Palace is released, you'll need to follow these steps to get the updated version:","category":"section"},{"location":"faq/#Step-1:-Update-Your-Spack-Repository","page":"Frequently Asked Questions","title":"Step 1: Update Your Spack Repository","text":"First, update your local copy of the Spack package definitions to include the new Palace version:\n\nspack repo update -b develop builtin","category":"section"},{"location":"faq/#Step-2:-Verify-the-New-Version-is-Available","page":"Frequently Asked Questions","title":"Step 2: Verify the New Version is Available","text":"Check that the new version is now available in your Spack installation:\n\nspack versions palace\n\nThis should show the new version in the list. If it doesn't appear, the new version may not have been added to Spack yet (see the previous FAQ entry for more details).","category":"section"},{"location":"faq/#Step-3:-Remove-the-Old-Version-(Optional)","page":"Frequently Asked Questions","title":"Step 3: Remove the Old Version (Optional)","text":"If you do not have a reason to keep the older version, you can remove it first:\n\nspack uninstall palace\n\nNote that if you have multiple versions installed, Spack will ask you to specify which one to remove. You can also use spack find palace to see all installed versions first.","category":"section"},{"location":"faq/#Step-4:-Install-the-New-Version","page":"Frequently Asked Questions","title":"Step 4: Install the New Version","text":"Finally, install the new version of Palace:\n\nspack install palace\n\nBy default, this will install the newest available version. If you want to install a specific version, you can specify it explicitly:\n\nspack install palace@0.14.0","category":"section"},{"location":"faq/#Keeping-Multiple-Versions","page":"Frequently Asked Questions","title":"Keeping Multiple Versions","text":"If you prefer to keep both the old and new versions (for example, to maintain compatibility with existing projects), you can skip step 3 and just install the new version alongside the old one. You can then use spack load palace@<version> to switch between versions as needed.","category":"section"},{"location":"faq/#I-called-spack-install-palace-but-I-get-an-error-saying-that-I-need-at-least-one-solver","page":"Frequently Asked Questions","title":"I called spack install palace but I get an error saying that I need at least one solver","text":"If you followed the instructions to install Palace with Spack and found an error like the following,\n\n==> Error: failed to concretize palace for the following reasons:\n   1. palace: Need at least one sparse direct solver\n   2. palace: At least one eigenvalue solver is required\n   3. palace: Need at least one sparse direct solver\n    required because conflict is triggered when ~mumps~strumpack~superlu-dist \n     required because palace requested explicitly \n    required because conflict constraint\n     required because palace requested explicitly \n   4. palace: At least one eigenvalue solver is required\n    required because conflict is triggered when ~arpack~slepc \n     required because palace requested explicitly \n    required because conflict constraint\n     required because palace requested explicitly\n\nchances are that you do not have a Fortran compiler. This is a common occurrence on Mac's, which does not ship with a Fortran compiler by default.\n\nSome of the dependencies of Palace require a Fortran compiler, and Spack disables such dependencies when a suitable compiler is not found, leading to the error message posted above.\n\nTo check that this is the case, call\n\nspack compiler list\n\nThis lists the compiler that Spack located. Then, call\n\nspack compiler info TOOLCHAIN_NAME\n\nwhere TOOLCHAIN_NAME is the name of the compiler listed in the output of the previous command (e.g., spack compiler info gcc). This will provide extra information on the available compilers, for example:\n\n[e]  apple-clang@=17.0.0 build_system=bundle platform=darwin os=tahoe target=aarch64\n\n  prefix: /usr\n  compilers:\n    cc: /usr/bin/clang\n    cxx: /usr/bin/clang++\n    fortran: None\n\nYou have a Fortran compiler if fortran is mentioned in the output of spack compiler info with output that is not None.\n\nIf you do not have a Fortran compiler, you can install gfortran with your package manager (e.g., apt install gfortran or brew install gfortran). Then, call spack compiler find to update the list of compilers that Spack is aware of.","category":"section"},{"location":"config/model/","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"config/model/#config[\"Model\"]","page":"config[\"Model\"]","title":"config[\"Model\"]","text":"\"Model\":\n{\n    \"Mesh\": <string>\n    \"L0\": <float>,\n    \"Lc\": <float>,\n    \"Refinement\":\n    {\n        ...\n    }\n}\n\nwith\n\n\"Mesh\" [None] :  Input mesh file path, an absolute path is recommended. If the provided mesh is nonconformal, it is assumed that it comes from a previous Palace solve using AMR, and all mesh preprocessing checks and modifications (for example model[\"Refinement\"][\"CrackInternalBoundaryElements\"]), are skipped .\n\n\"L0\" [1.0e-6] :  Unit, relative to m, for mesh vertex coordinates. For example, a value of 1.0e-6 implies the mesh coordinates are in μm.\n\n\"Lc\" [0.0] :  Characteristic length scale used for nondimensionalization, specified in mesh length units. This keyword should typically not be specified by the user. A value less than or equal to zero uses an internally calculated length scale based on the bounding box of the computational domain. A value of 1.0 will disable nondimensionalization of lengths in the model and all computations will take place in the same units as the mesh.\n\n\"Refinement\" : Top-level object for configuring mesh refinement.","category":"section"},{"location":"config/model/#model[\"Refinement\"]","page":"config[\"Model\"]","title":"model[\"Refinement\"]","text":"\"Refinement\":\n{\n    \"Tol\": <float>,\n    \"MaxIts\": <int>,\n    \"MaxSize\": <int>,\n    \"Nonconformal\": <bool>,\n    \"UpdateFraction\": <float>,\n    \"UniformLevels\": <int>,\n    \"Boxes\":\n    [\n        {\n            \"Levels\": <int>,\n            \"BoundingBoxMin\": [<float array>],\n            \"BoundingBoxMax\": [<float array>]\n        },\n        ...\n    ],\n    \"Spheres\":\n    [\n        {\n            \"Levels\": <int>,\n            \"Center\": [<float array>],\n            \"Radius\": <float>\n        },\n        ...\n    ]\n}\n\nwith\n\n\"Tol\" [1.0e-2] : Relative error convergence tolerance for adaptive mesh refinement (AMR).\n\n\"MaxIts\" [0] : Maximum number of iterations of AMR to perform.\n\n\"MaxSize\" [0] : The maximum allowable number of degrees of freedom for AMR. If an adapted mesh exceeds this value no further adaptation will occur. A value less than 1 means that no maximum size constraint will be imposed.\n\n\"Nonconformal\" [true] : Chose whether the adaptation should use nonconformal refinement. Nonconformal refinement is required for non-simplex meshes.\n\n\"UpdateFraction\" [0.7] : Dörfler marking fraction used to specify which elements to refine. This marking strategy will mark the smallest number of elements that make up \"UpdateFraction\" of the total error in the mesh. A larger value will refine more elements per iteration, at the cost of the final mesh being less efficient.\n\n\"UniformLevels\" [0] :  Levels of uniform parallel mesh refinement to be performed on the input mesh. If not performing AMR, these may be used as levels within a geometric multigrid scheme. If performing AMR the most refined mesh is used as the initial mesh and the coarser meshes cannot be used in a geometric multigrid scheme.\n\n\"Boxes\" :  Array of box region refinement objects. All elements with a node inside the box region will be marked for refinement.\n\n\"Spheres\" :  Array of sphere region refinement objects. All elements with a node inside the sphere region will be marked for refinement.\n\n\"Levels\" [0] : Levels of parallel mesh refinement inside the specified refinement region.\n\n\"BoundingBoxMin\" [None] : Floating point array of length equal to the model spatial dimension specifying the minimum coordinates of the axis-aligned bounding box for this refinement region. Specified in mesh length units.\n\n\"BoundingBoxMax\" [None] : Floating point array of length equal to the model spatial dimension specifying the maximum coordinates of the axis-aligned bounding box for this refinement region. Specified in mesh length units.\n\n\"Center\" [None] : Floating point array of length equal to the model spatial dimension specifying the center coordinates of the sphere for this sphere refinement region. Specified in mesh length units.\n\n\"Radius\" [None] : The radius of the sphere for this sphere refinement region, specified in mesh length units.","category":"section"},{"location":"config/model/#Advanced-model-options","page":"config[\"Model\"]","title":"Advanced model options","text":"\"RemoveCurvature\" [false]\n\"MakeSimplex\" [false]\n\"MakeHexahedral\" [false]\n\"ReorderElements\" [false]\n\"CleanUnusedElements\" [true]\n\"CrackInternalBoundaryElements\" [true]\n\"RefineCrackElements\" [true]\n\"CrackDisplacementFactor\" [1.0e-12]\n\"AddInterfaceBoundaryElements\" [true]\n\"ExportPrerefinedMesh\" [false]\n\"ReorientTetMesh\" [false]\n\"Partitioning\" [\"\"]\n\"MaxNCLevels\" [1]\n\"MaximumImbalance\" [1.1]\n\"SaveAdaptIterations\" [true]\n\"SaveAdaptMesh\" [false]\n\"SerialUniformLevels\" [0]","category":"section"},{"location":"developer/spack/","page":"Working with Spack","title":"Working with Spack","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"developer/spack/#Working-with-Spack","page":"Working with Spack","title":"Working with Spack","text":"Spack is a multi-platform package manager designed to handle the complexity of building scientific software with multiple versions, configurations, and dependencies. While Spack is commonly used to install Palace as an end user would, it's also a powerful tool for active development. One of the main reasons you might consider doing so is that Spack makes co-development of multiple packages straightforward, e.g., allowing you to point to local copies of both Palace and MFEM simultaneously. This guide walks you through both using Spack to develop Palace itself and working on Palace's Spack package recipe.\n\nBefore diving in, this guide assumes you already have Spack installed and understand the basics of how it works. If you're completely new to Spack, you should start with their official documentation to get familiar with concepts like specs, variants, and environments. Check the official tutorials out to get started.","category":"section"},{"location":"developer/spack/#Developing-Palace-with-Spack-Environments","page":"Working with Spack","title":"Developing Palace with Spack Environments","text":"The recommended approach for developing Palace with Spack is to use Spack environments. An environment is essentially a self-contained workspace defined by a spack.yaml file that specifies exactly what you want to build and how you want to build it. This keeps your development setup isolated and reproducible.\n\nTo get started, create a dedicated directory for your environment. You might call it something like palace_spack or palace_dev. Inside this directory, create a spack.yaml file with the following content:\n\nspack:\n  specs:\n  - palace@develop\n  develop:\n    palace:\n      spec: palace@=develop\n      path: ~/repos/palace\n\nThe path field should point to wherever you've cloned the Palace repository on your system. The specs section defines what you want to install, and you can customize this with variants. For instance, if you need the test suite built, you would change the spec to palace@develop+tests. Spack's variant system is quite flexible, so you can enable or disable features as needed for your development work.\n\nBefore running the installation, it's sometimes worth taking advantage of packages that are already installed on your system. Spack calls these \"external packages,\" and finding them can significantly speed up your build times. You can scan for them by running:\n\nspack -e palace_spack external find --all\n\nThis command will modify your spack.yaml file to include references to system packages like compilers, MPI implementations, and common libraries. Spack will then use these instead of building them from scratch, which can save hours on the first build.\n\nnote: Risks of using externals\nWhile using external packages can save hours of compilation time, Spack does not always handle them correctly, and incompatibilities are possible. If you find issues, you can try removing the external packages and letting Spack compile everythin.\n\nNow you're ready to install Palace by running:\n\nspack -e palace_spack install \n\nBe prepared for this first installation to take some time, potentially a few hours depending on your system and what needs to be built. Spack is building not just Palace but all of its dependencies from source. Spack caches everything it builds, so subsequent installations will be much faster. Even if you change variants or make other modifications to your environment, Spack is smart enough to only rebuild what's actually affected by your changes.\n\nOnce the installation completes, you can activate the environment and load Palace into your shell:\n\nspack env activate palace_spack\nspack load palace\n\nAfter this, the palace command will be available in your terminal. Whenever you make changes to the Palace source code, you can rebuild by simply running spack install again from within the environment. Spack will detect what's changed and recompile only what's necessary.\n\nThe beauty of this development mode is that it extends to other packages as well. If you need to modify MFEM alongside Palace, you can add another entry to the develop section of your spack.yaml pointing to your local MFEM checkout. Spack will then manage both packages in development mode, rebuilding each as needed when you make changes.","category":"section"},{"location":"developer/spack/#Developing-Palace's-Package-Recipe","page":"Working with Spack","title":"Developing Palace's Package Recipe","text":"Beyond developing Palace itself, you might need to work on Palace's Spack package recipe (the package.py file that tells Spack how to build Palace). This is particularly relevant if you're adding new dependencies, changing build options, or preparing a new release.\n\nThe first step is to add Palace's Spack repository to your Spack configuration. Assuming your Palace checkout is in ~/repos/palace, you would run:\n\nspack repo add ~/repos/palace/spack_repo/local\n\nYou should see a confirmation message like ==> Added repo with namespace 'local'. The namespace local is significant because it allows you to distinguish between your development version of the package and the official one in Spack's built-in repository. When you refer to local.palace, you're explicitly using the recipe from your personal repository, while builtin.palace refers to the official recipe that ships with Spack.\n\nTo verify that everything is working, try making a small change to the package file. For example, you could edit spack_repo/local/packages/palace/package.py and change the docstring to all capital letters. Then run:\n\nspack info local.palace | head -n 4\n\nYou should see your modified docstring. Compare this with the output of spack info builtin.palace | head -n 4 to see the difference between your local version and the official one.\n\nA shortcut to end the package.py is calling spack edit local.palace, which will open the file with your $EDITOR.\n\nOne important detail is that the local repository takes priority over builtin. This means that if you just run spack info palace without a prefix, Spack will use your local version. While this is convenient, we'll continue using the explicit local. prefix in examples for clarity.","category":"section"},{"location":"developer/spack/#Working-Around-a-Spack-Bug-with-Patches","page":"Working with Spack","title":"Working Around a Spack Bug with Patches","text":"There's currently a known issue in Spack version <=1.2.0 that affects packages using patches when they come from non-builtin repositories (see the bug report). Since Palace uses patches, you'll run into this problem. The workaround is straightforward but a bit inelegant: you need to add a copy of the MFEM package to your local repository as well.\n\nRather than maintaining a duplicate copy of the MFEM recipe, you can create a symbolic link from Spack's built-in MFEM package to your local repository:\n\nln -s \"$(spack location --repo builtin)\"/packages/mfem ~/repos/palace/spack_repo/local/packages/\n\nThis command uses Spack's location subcommand to find where the built-in repository lives, then creates a symlink to the MFEM package directory. To verify that the symlink was created correctly, run:\n\nspack info local.mfem | head -n 4\n\nIf you see MFEM's package information, you're all set. This workaround ensures that when Spack processes patches for Palace, it can find MFEM in the same repository namespace and avoid the bug.","category":"section"},{"location":"developer/spack/#Iterating-on-Package-Changes","page":"Working with Spack","title":"Iterating on Package Changes","text":"With your local repository configured, you can now iterate on Palace's package.py file. After making changes, you can test them by installing Palace again. You can also use spack spec local.palace@develop to see how Spack would resolve dependencies without actually building anything, which is useful for catching errors early.","category":"section"},{"location":"developer/spack/#Working-with-source-code-patches","page":"Working with Spack","title":"Working with source code patches","text":"Palace requires some patches in some of the dependencies (primarily MFEM). Spack handles this, but there are a few common pitfalls.\n\nFirst, patches are evaluated at concretization. This is because patches are embedded in the hash, which is computed at concretization. If you are iterating on patches, make sure to re-concretize your environment.\n\nSecond, Palace depends on a specific commit of MFEM (defined in the package.py or in the ExternalGitTags.cmake). spack develop mfem does not respect this commit restriction. In most cases, this means that you have to manually git checkout the specific hash for mfem in the mfem folder so that patches apply cleanly.","category":"section"},{"location":"developer/spack/#Working-with-patches-for-package.py-files","page":"Working with Spack","title":"Working with patches for package.py files","text":"When working with Spack, it sometimes happens that we find problems in upstream package.py files. When this happens, we open pull requests to spack-packages to fix the issue. However, having those pull requests merged can take weeks. To ensure that our continuous integration works, we manually apply those PR as part setting Spack up in our runners (the setup-runner workflow).\n\nIf you are working with Spack and Palace locally, you might need to apply the same patches. To apply a patch in spack_repo/patches:\n\ncd $(spack location --repo builtin)\ngit apply /path/to/palace/spack_repo/patches/prNUM.diff\n\nNote that if you do so, your builtin repository will no longer be clean and you will not be able to update spack-packages as easily.\n\nInstead, if you some patches applied and need to upgrade the recipes, the easiest way is probably to remove all the patches and re-apply the ones you need:\n\ncd $(spack location --repo builtin)\ngit fetch\ngit reset --hard origin/develop\n# Apply relevant patches\n\nIt is often the case that patches are required for uncommon build configurations, so you might not need all of them.","category":"section"},{"location":"examples/transmon/","page":"Single transmon with read-out resonator from DeviceLayout.jl","title":"Single transmon with read-out resonator from DeviceLayout.jl","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"examples/transmon/#Single-transmon-with-read-out-resonator-from-[DeviceLayout.jl](https://aws-cqc.github.io/DeviceLayout.jl/)","page":"Single transmon with read-out resonator from DeviceLayout.jl","title":"Single transmon with read-out resonator from DeviceLayout.jl","text":"note: Note\nThe files for this example can be found in the examples/transmon/ directory of the Palace source code. The configuration and mesh files were generated with DeviceLayout.jl.\n\nIn this example, we simulate a superconducting transmon qubit coupled to a readout resonator, a fundamental building block of superconducting quantum processors.\n\nThe configuration and mesh for this example are generated with DeviceLayout.jl, a Julia package for computer-aided design of quantum integrated circuits. DeviceLayout.jl supports the generation of 2D layouts and 3D models using both low-level geometry interfaces and high-level schematic-driven workflows, enabling automated design and optimization of quantum devices. For a detailed tutorial on using DeviceLayout.jl to generate this geometry, see this example.","category":"section"},{"location":"examples/transmon/#Overview-and-Configuration","page":"Single transmon with read-out resonator from DeviceLayout.jl","title":"Overview and Configuration","text":"The system consists of three main components: a transmon qubit, a quarter-wave coplanar waveguide resonator, and a feedline for signal input and output. The transmon is capacitively coupled to the resonator through a \"claw\" structure that extends around the transmon cutout, while the resonator couples to the feedline to enable readout of the qubit state.\n\nThe image below shows the meshed geometry of the system. The metal structures are fabricated on a dielectric substrate and enclosed within a simulation box filled with vacuum to model the actual device environment.\n\n<!-- Plot generated with plot_transmon_mesh() in transmon/transmon.jl -->\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/transmon-1.png\" width=\"100%\" />\n</p><br/>\n\nThe metal conductors are modeled as perfect electric conductors (PEC), with three lumped ports defining the electromagnetic boundary conditions. Two resistive ports at the feedline ends represent 50-Ohm terminations to the external world, while a third port models the Josephson junction as a linearized LC circuit with both inductance and capacitance. The substrate is sapphire, chosen for its low dielectric loss and well-characterized anisotropic material properties (see, config[\"Domains\"][\"Materials\"] for more information on how to configure anisotropic materials). config[\"Boundaries\"][\"Absorbing\"] boundary conditions on the external boundaries of the simulation box capture electromagnetic radiation and prevent artificial reflections.\n\nThe JSON configuration file and mesh are generated automatically by the SingleTransmon module in DeviceLayout.jl. This module demonstrates how to programmatically assign domain and boundary attributes from a schematic design, enabling semi-automated configuration generation for electromagnetic simulations.\n\nThe system design is fully parametric, allowing customization of all geometric and material properties. Physical details can be modified by passing keyword arguments to the generate_transmon function in the transmon.jl file. To see the available design parameters, run the following command in the transmon example directory:\n\njulia --project -E 'include(\"transmon.jl\"); @doc SingleTransmon.single_transmon'\n\nThis displays the available design parameters, including geometric dimensions and processing options:\n\nsingle_transmon(\n    w_shield=2μm,\n    claw_gap=6μm,\n    w_claw=34μm,\n    l_claw=121μm,\n    cap_width=24μm,\n    cap_length=620μm,\n    cap_gap=30μm,\n    n_meander_turns=5,\n    hanger_length=500μm,\n    bend_radius=50μm,\n    save_mesh::Bool=false,\n    save_gds::Bool=false\n)\n\nBeyond the physical dimensions, the save_mesh and save_gds options enable output of a mesh file for simulation and a GDS file for fabrication, respectively. This integration between design, simulation, and fabrication workflows demonstrates the power of automated quantum device design tools.\n\nWe perform an eigenmode analysis to determine the system's resonant frequencies and quality factors. This simulation identifies the two fundamental modes corresponding to the transmon and readout resonator, providing essential information for device characterization including mode frequencies, decay rates, and electromagnetic field distributions. Such analysis is crucial in the quantum device design process, as it informs design decisions and enables optimization before fabrication. The DeviceLayout.jl example extends this approach by demonstrating an automated optimization loop that tunes device parameters to achieve target frequencies.","category":"section"},{"location":"examples/transmon/#Results","page":"Single transmon with read-out resonator from DeviceLayout.jl","title":"Results","text":"The simulation completes in approximately 10 minutes on a modern computer using 6 CPU cores.\n\nThe primary results are the eigenfrequencies and quality factors, stored in the eig.csv file:\n\ninclude_example_file(\"transmon\", \"eig.csv\") #hide\n\nThe columns represent the mode number, real and imaginary parts of the eigenfrequency, and computed quality factor, respectively. The results successfully identify two distinct eigenmodes with predominantly real frequencies and small imaginary components representing dissipation.\n\nTo verify the physical nature of these modes, we can examine the electromagnetic field distributions. Below, we embed an interactive visualization of the magnetic energy density of the second eigenmode. This visualization leverages GLVis. For a quick introduction to this tool, refer to the box below. We encourage you to play with the visualization and inspect the mesh, looking at how DeviceLayout refines certain regions of interest (e.g., the claw).\n\ntip: Quick Start to GLVis\nGLVis provides fast visualization of Palace output when config[\"Problem\"][\"Output\"][\"OutputFormats\"][\"GridFunction\"] is enabled. While less quantitative than ParaView, GLVis excels at rapid solution inspection and is particularly well-suited for interactive exploration. The interface is primarily keyboard-driven with extensive keybindings.Essential commands include:i cut through the solution\nx/X, y/Y rotate the cutting plane\nz/Z translate the cutting plane\nR cycle through 2D viewpoints\nc display the colorbar\nm show the mesh\nright click + mouse movement zoom in/out\ncenter click + mouse movement translate viewpoint\n\n<div id=\"glvis-container\" style=\"width: 100%; height: 500px;\">\n  <div id=\"glvis-div\" style=\"width: 100%; height: 100%;\"></div>\n</div>\n\n<!-- This was generated with order=1 and without mesh cracking. -->\n<!-- We disable mesh cracking because it looks glitchy otherwise. -->\n\n<!-- Note, the snippet below only works with one MPI process because we are\n    manually composing a stream file. -->\n<script type=\"text/javascript\">\n  var div = document.getElementById(\"glvis-div\");\n  require([\"../../assets/js/glvis/index.js\"], function (glvis) {\n    var glv = new glvis.State(div);\n\n    Promise.all([\n      fetch('../../assets/examples/transmon-mesh.000000').then(r => r.text()),\n      fetch('../../assets/examples/transmon-U_m_000002.gf.000000').then(r => r.text())\n    ]).then(function(results) {\n      var stream = \"solution\\n\" + results[0] + results[1] + \"keys OOOOOOOOOiXXXXXXXXXXXXXXXXXX1Lac\\n\";\n      var originalTitle = document.title;\n      glv.display(stream).then(function() {\n        document.title = originalTitle;\n        // Enable keyboard controls on click\n        div.addEventListener('click', function() {\n          this.setAttribute('tabindex', '0');\n          this.focus();\n        }, { once: true });\n      });\n    }).catch(function(e) {\n      console.error('Failed to load GLVis data:', e);\n    });\n  });\n</script>\n\nThe ParaView visualization below shows the magnetic energy density distribution, providing clear confirmation that the computed modes correspond to the expected transmon and resonator physics.\n\n<!-- Plot generated with transmon/plot_slice_docs.py -->\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/transmon-2.png\" width=\"100%\" />\n</p><br/>\n\nAdditional simulation outputs provide detailed characterization of the system. The port-Q.csv file contains port coupling rates and quality factors for the resistive terminations at the feedline ends, while port-EPR.csv reports energy participation ratios for inductive lumped elements (the Josephson junction). The domain-E.csv file provides bulk dielectric loss and participation ratios for the sapphire substrate, enabling comprehensive analysis of loss mechanisms throughout the device.","category":"section"},{"location":"examples/transmon/#Balancing-Speed-and-Accuracy:-Solver-Order-Considerations","page":"Single transmon with read-out resonator from DeviceLayout.jl","title":"Balancing Speed and Accuracy: Solver Order Considerations","text":"While this simulation provides accurate results, computational time can be significantly reduced by adjusting the finite element order. Changing from second order to first order decreases runtime by a factor of 30, though this comes at the cost of reduced accuracy. This trade-off can be controlled by modifying the solver order in the JSON configuration file or by passing the solver_order parameter to the generate_transmon function.\n\nThe error-indicators.csv file provides quantitative measures of numerical accuracy (see, the reference section on error estimation). For a second-order solution:\n\ninclude_example_file(\"transmon\", \"error-indicators.csv\") #hide\n\nThese error indicators provide metrics for estimating numerical accuracy across the computational domain, with the Norm column representing a measure related to the H(curl) seminorm of the solution error. When reducing to first order, the error norm increases by a factor of two, and the computed eigenfrequencies deviate noticeably from the converged values. While first-order simulations are valuable for rapid prototyping and debugging, second order (or higher) is generally recommended for accurate results.","category":"section"},{"location":"guide/boundaries/","page":"Boundary Conditions","title":"Boundary Conditions","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"guide/boundaries/#Boundary-Conditions","page":"Boundary Conditions","title":"Boundary Conditions","text":"","category":"section"},{"location":"guide/boundaries/#Perfect-electric-conductor-(PEC)-boundary","page":"Boundary Conditions","title":"Perfect electric conductor (PEC) boundary","text":"The perfect electric conductor (PEC) boundary condition (zero tangential electric field) is specified using the \"PEC\" boundary keyword under config[\"Boundaries\"]. It is a homogeneous Dirichlet boundary condition for the frequency or time domain finite element formulation, as well as the magnetostatic formulation.\n\nFor electrostatic simulations, the homogeneous Dirichlet boundary condition is prescribed using the \"Ground\" boundary keyword which prescribes zero voltage at the boundary.","category":"section"},{"location":"guide/boundaries/#Perfect-magnetic-conductor-(PMC)-boundary","page":"Boundary Conditions","title":"Perfect magnetic conductor (PMC) boundary","text":"The perfect magnetic conductor (PMC) boundary condition (zero tangential magnetic field) is a homogeneous Neumann boundary condition for the frequency or time domain finite element formulation, as well as the magnetostatic formulation. It is the natural boundary condition and thus it has the same effect as not specifying any additional boundary condition on external boundary surfaces. It can also be explicitly specified using the \"PMC\" boundary keyword under config[\"Boundaries\"].\n\nLikewise, for electrostatic simulations, the homogeneous Neumann boundary condition implies a zero-charge boundary, and thus zero gradient of the voltage in the direction normal to the boundary. This is specified using the \"ZeroCharge\" boundary keyword under config[\"Boundaries\"].","category":"section"},{"location":"guide/boundaries/#Impedance-boundary","page":"Boundary Conditions","title":"Impedance boundary","text":"The impedance boundary condition is a mixed (Robin) boundary condition and is available for the frequency or time domain finite element formulations and thus for eigenmode or frequency or time domain driven simulation types. It is specified using the \"Impedance\" boundary keyword. The surface impedance relating the tangential electric and magnetic fields on the boundary is computed from the parallel impedances due to the specified resistance, inductance, and capacitance per square.","category":"section"},{"location":"guide/boundaries/#Absorbing-(scattering)-boundary","page":"Boundary Conditions","title":"Absorbing (scattering) boundary","text":"Absorbing boundary conditions at farfield boundaries, also referred to as scattering boundary conditions, can be applied using the \"Absorbing\" boundary keyword under config[\"Boundaries\"]. The first-order absorbing boundary condition is a special case of the above impedance boundary and is available for eigenmode or frequency or time domain driven simulation types. The second-order absorbing boundary condition is only available for frequency domain driven and eigenmode simulations.\n\nPerfectly matched layer (PML) boundaries for frequency and time domain electromagnetic formulations are not yet implemented, but are common in solvers for computational electromagnetics and will be a useful addition.","category":"section"},{"location":"guide/boundaries/#Finite-conductivity-boundary","page":"Boundary Conditions","title":"Finite conductivity boundary","text":"A finite conductivity boundary condition can be specified using the \"Conductivity\" boundary keyword. This boundary condition models the effect of a boundary with non-infinite conductivity (an imperfect conductor) for conductors with thickness much larger than the skin depth. It is available only for frequency domain driven and eigenmode simulations. For more information see the Other boundary conditions section of the reference.","category":"section"},{"location":"guide/boundaries/#Periodic-boundary","page":"Boundary Conditions","title":"Periodic boundary","text":"Periodic boundary conditions on an existing mesh can be specified using the \"Periodic\" boundary keyword. This boundary condition enforces that the solution on the specified boundaries be exactly equal, and requires that the surface meshes on the donor and receiver boundaries be identical up to translation or rotation. Periodicity in Palace is also supported through meshes generated incorporating periodicity as part of the meshing process.\n\nPalace also supports Floquet periodic boundary conditions, where a phase shift is imposed between the fields on the donor and receiver boundaries. The phase shift is e^-i bmk_p cdot (bmx_textrmreceiver-bmx_textrmdonor), where bmk_p is the Floquet wave vector and bmx is the position vector. See Floquet periodic boundary conditions for implementation details.","category":"section"},{"location":"guide/boundaries/#Lumped-and-wave-port-excitation","page":"Boundary Conditions","title":"Lumped and wave port excitation","text":"config[\"Boundaries\"][\"LumpedPort\"] : A lumped port applies a similar boundary condition to a surface impedance boundary, but takes on a special meaning for each simulation type.\nFor frequency domain driven simulations, ports are used to provide a lumped port excitation and postprocess voltages, currents, and scattering parameters. Likewise, for transient simulations, they perform a similar purpose but for time domain computed quantities.\nFor eigenmode simulations where there is no excitation, lumped ports are used to specify properties and postprocess energy-participation ratios (EPRs) corresponding to linearized circuit elements.\nNote that a single lumped port (given by a single integer \"Index\") can be made up of multiple boundary attributes in the mesh in order to model, for example, a multielement lumped port. To use this functionality, use the \"Elements\" object under \"LumpedPort\".\nconfig[\"Boundaries\"][\"WavePort\"] : Numeric wave ports are available for frequency domain driven and eigenmode simulations. In this case, a port boundary condition is applied with an optional excitation using a modal field shape which is computed by solving a 2D boundary mode eigenproblem on each wave port boundary. This allows for more accurate scattering parameter calculations when modeling waveguides or transmission lines with arbitrary cross sections.\nThe 2D wave port eigenproblem only supports PEC and PMC boundary conditions. Boundaries that are specified as \"PEC\" or \"Conductivity\" in the full 3D model and intersect the wave port boundary will be considered as PEC in the 2D boundary mode analysis, as well as any additional boundary attributes given under \"WavePortPEC\". [config[\"Boundaries\"][\"WavePortPEC\"](../config/boundaries.md#boundaries%5B%22WavePortPEC%22%5D) allows to assign non-PEC attributes from the 3D model (e.g. impedance or absorbing boundary conditions) as a PEC boundary condition for the 2D wave port solve. In addition, boundaries of wave ports other than the wave port currently being considered, in the case wave ports are touching and share one or more edges, are also considered as PEC for the wave port boundary mode analysis. Boundaries of the wave port not labeled with a \"PEC\", \"Conductivity\", \"WavePortPEC\", or \"WavePort\" condition have the natural boundary condition of zero tangential magnetic field (PMC) prescribed for the purpose of port mode calculation.\nUnlike lumped ports, wave port boundaries cannot be defined internal to the computational domain and instead must exist only on the outer boundary of the domain (they are to be \"one-sided\" in the sense that mesh elements only exist on one side of the boundary).\n\nFor each port, the excitation is normalized to have unit incident power over the port boundary surface.\n\nThe presence of an incident excitation at a port is controlled by the settings config[\"Boundaries\"][\"LumpedPort\"][][\"Excitation\"] and config[\"WavePort\"][][\"Excitation\"]. The Excitation settings can either be specified as non-negative integers or booleans.\n\nBoolean setting: true/false indicates the presence / absence of an incident excitation. Usually, only a single port will be marked as excited. In that case, the \"Excitation\" will promoted to the port \"Index\". If there are multiple excited ports, the \"Excitation\" is 1.\nInteger setting: Here the user manually assigns excitation indices to ports. The value 0 corresponds to no excitation. A positive integer i means that port is excited during excitation i. If multiple ports share an excitation index i, they will be excited at the same time. In the special, but common, case that each excitation consists of only a single port, the port index and excitation index must be equal. This avoids ambiguity in the scattering matrix.\n\nFor frequency domain driven simulations only, it is possible to specify multiple excitations in the same simulation using different positive integers (\"multi-excitation\"). These excitations are simulated consecutively during the Palace run. The results are printed to shared csv files. When there are multiple excitations, the columns of the csv files are post-indexed by the excitation index (e.g. Φ_elec[1][5] (C) denoting the flux through surface 1 of excitation 5). Note that a port can only be part of one excitation.\n\nwarning: Indexing\nAny \"Index\" of \"LumpedPort\", \"WavePort\", \"SurfaceCurrent\", or \"Terminal\" must be unique, including between different boundary conditions types (e.g. you can not have an lumped port and wave port both with Index: 5).","category":"section"},{"location":"guide/boundaries/#Surface-current-excitation","page":"Boundary Conditions","title":"Surface current excitation","text":"An alternative source excitation to lumped or wave ports for frequency and time domain driven simulations is a surface current excitation, specified under config[\"Boundaries\"][\"SurfaceCurrent\"]. This is the excitation used for magnetostatic simulation types as well. This option prescribes a unit source surface current excitation on the given boundary in order to excite the model. It does does not prescribe any boundary condition to the model and only affects the source term on the right hand side.","category":"section"},{"location":"developer/testing/","page":"Testing","title":"Testing","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"developer/testing/#Testing","page":"Testing","title":"Testing","text":"Palace comes with two types of tests:\n\nUnit tests in test/unit/ test individual components in isolation\nRegression tests in test/examples/ compare code output against saved references\n\nBoth types of tests are run automatically as part of the project's continuous integration (CI) workflows.","category":"section"},{"location":"developer/testing/#Building-and-running-unit-tests","page":"Testing","title":"Building and running unit tests","text":"The simplest way to build unit tests is using CMake.\n\nFirst, follow the quick start to build Palace with CMake. From the Palace root directory:\n\nmkdir build && cd build\ncmake -DPALACE_MFEM_USE_EXCEPTIONS=yes ..\nmake -j palace-tests\n\nThe PALACE_MFEM_USE_EXCEPTIONS option is necessary to properly capture and test assertions. If you want to also measure test coverage, turn PALACE_BUILD_WITH_COVERAGE on. See Unit test coverage for more details on this.\n\nOnce the build completes, the palace-unit-tests executable will be installed in the same bin/ directory as the main palace executable. Run the tests with:\n\nbin/palace-unit-tests\n\nThis runs all the Serial tests. To run Parallel tests, call\n\nmpirun -np 2 bin/palace-unit-tests\n\nTo run the GPU tests (this can be combined with mpirun):\n\nbin/palace-unit-tests --device cuda\n\nIf you are interested in running only a subset of tests, you can use filters. For example, to run the tests tagged with [vector], call\n\nbin/palace-unit-tests [vector]\n\nTo run a specific test by name:\n\nbin/palace-unit-tests \"Vector Sum - Real\"","category":"section"},{"location":"developer/testing/#Benchmarks","page":"Testing","title":"Benchmarks","text":"The unit test application also includes a small number of benchmarks to compare performance between MFEM's legacy assembly backend, MFEM's partial assembly backend, and the specified libCEED backend (specified with the --backend option, use -h/--help to list all command line options for the palace-unit-tests executable). These can be run using, for example:\n\nbin/palace-unit-tests \"[Benchmark]\" --benchmark-samples 10\n\nThese benchmarks can be accelerated using MPI and/or OpenMP parallelism (when configured with PALACE_WITH_OPENMP=ON), but in all cases they are only testing the local operator assembly on each process.","category":"section"},{"location":"developer/testing/#Adding-unit-tests","page":"Testing","title":"Adding unit tests","text":"Palace uses Catch2 for unit testing. Refer to the Catch2 documentation for detailed usage information. If you have never added a test to Palace, start by reading our tutorial on adding a new unit test.\n\nThe most important Catch2 feature  in the Palace test suite is tags. When creating a test, you provide a name and a series of tags\n\nTEST_CASE(\"My name\", \"[MyFirstTag][MyOtherTag][Serial]\"){ ... }\n\nCatch2 tags are typically used for filtering tests. Palace defines three special tags that control when tests execute based on the runtime environment:\n\n[Serial] tests run only with a single MPI process. Use this for tests that verify single-process behavior.\n[Parallel] tests run only when multiple MPI processes are available. Use this for tests that verify MPI operations, distributed computations, or inter-process communication.\n[GPU] tests run only when GPU devices are available. Use this for tests that are meaningful and interesting on GPU hardware.\n\nThese tags are inclusive, meaning that a test can be marked with multiple special tags, if the test is meaningful in different contexts (e.g., if a test supports CPU and GPU implementation at the same time). For example, [Serial][Parallel][GPU] indicates a test that should run in every case.\n\nwarning: Warning\nTests without any of our special tags will never execute. Make sure to add at least one.\n\nnote: Tests should use tags for which the test is meaningful\nConsider testing this code:int a = 1, b = 2;\nAssert(a + b == 3);This test will pass if run with MPI, but this is uninteresting since every MPI process executes the same code that the Serial test would run (same with GPUs). Therefore, this test should only be marked as [Serial].\n\nFor the other tags, we recommend grouping related tests using descriptive tag names like [vector] or [materialoperator] (typically named after files or classes). This enables effective filtering, as described in Building and running unit tests.","category":"section"},{"location":"developer/testing/#Accessing-files","page":"Testing","title":"Accessing files","text":"Files required for tests (e.g., meshes or configurations) need to be saved inside the test/unit/data folder. This ensures that the files are accessible when Palace is installed in a folder that is not the source folder (e.g., with Spack). The path to the content of test/unit/data maps to PALACE_TEST_DATA_DIR. For example, if you want to access the banana.txt file in test/unit/data, refer to it as\n\nauto path_to_banana = fs::path(PALACE_TEST_DATA_DIR) / \"banana.txt\"\n\nAccessing files without using PALACE_TEST_DATA_DIR will likely result in failing tests on Spack builds (unless you know what you are doing).","category":"section"},{"location":"developer/testing/#Test-configuration","page":"Testing","title":"Test configuration","text":"The CMakeLists.txt in test/unit/ contains important settings:\n\nThe list of files compiled as part of the tests\nThe list of files that need to be compiled with a GPU compiler (TARGET_SOURCES_DEVICE)\nPath variables used in tests, such as MFEM_DATA_PATH MFEM_DATA_PATH contains 2D and 3D sample meshes for testing (these meshes come from the MFEM repository).","category":"section"},{"location":"developer/testing/#Unit-test-coverage","page":"Testing","title":"Unit test coverage","text":"When Palace is built with PALACE_BUILD_WITH_COVERAGE, running the unit tests generates coverage information that tracks which parts of the codebase are exercised by the tests. This feature uses \"source-based code coverage\" for LLVM-based compilers (Clang, AppleClang, IntelLLVM) and gcov for GNU compilers.\n\nBoth methods can produce coverage data compatible with LCOV, which provides standardized processing and HTML report generation. In the sections below, we discuss how to obtain a coverage.info that can be further processed by lcov. Before proceeding, ensure lcov is installed on your system. If not, you can obtain it from your package manager.\n\nwarning: Before continuing\nMake sure you have lcov installed. To check that it works, runlcov --versionAlso make sure that Palace was build with PALACE_BUILD_WITH_COVERAGE. If not, compile it withcmake -DPALACE_MFEM_USE_EXCEPTIONS=yes -DPALACE_BUILD_WITH_COVERAGE=yes ..\n\nTo obtain comprehensive coverage data, tests must be executed in three configurations: Serial, Parallel, and GPU (if available). Each configuration produces separate coverage files that are later merged into a unified report.\n\nPalace is a complex codebase that involves inlined and just-in-time compiled functions. This can lead to minor inconsistencies in the coverage files. These are not fatal, and ignoring them still produces good reports. For this reason, most lcov commands you will see in the following sections have the --ignore-errors inconsistent flag.","category":"section"},{"location":"developer/testing/#Coverage-with-GNU-compilers","page":"Testing","title":"Coverage with GNU compilers","text":"GNU compilers automatically generate raw coverage files during program execution. The lcov tool can directly process these files without additional conversion steps.\n\nRun the test suite in all configurations and capture coverage data:\n\n# Serial tests\nbin/palace-unit-tests\nlcov --capture --directory palace-build --ignore-errors inconsistent --output-file coverage1.info\n\n# Parallel tests\nmpirun -np 2 bin/palace-unit-tests\nlcov --capture --directory palace-build --ignore-errors inconsistent --output-file coverage2.info\n\n# GPU tests (if available)\n# (command -v nvidia-smi is for your convenience, so that you can copy this block of code\n#  and use it as-is even when a GPU is not available)\ncommand -v nvidia-smi && bin/palace-unit-tests --device cuda\ncommand -v nvidia-smi && lcov --capture --directory palace-build --ignore-errors inconsistent --output-file coverage3.info\n\n# Merge all coverage files (works whether coverage3.info exists or not)\n# The $() expands to --add-tracefile coverage1.info --add-tracefile coverage2.info --add-tracefile coverage3.info \nlcov $(for f in coverage[1-3].info; do echo \"--add-tracefile $f\"; done) --ignore-errors inconsistent --output-file coverage.info","category":"section"},{"location":"developer/testing/#Coverage-with-LLVM-based-compilers","page":"Testing","title":"Coverage with LLVM-based compilers","text":"LLVM compilers use a different coverage format that requires additional processing steps. The LLVM_PROFILE_FILE environment variable controls the naming pattern for generated coverage files.\n\nFirst, clean any existing coverage files and configure the profile naming:\n\nrm -f coverage*.profraw\nexport LLVM_PROFILE_FILE=\"coverage-%p.profraw\"\n\nExecute the test suite in all configurations:\n\n# Serial tests\nbin/palace-unit-tests\n\n# Parallel tests\nmpirun -np 2 bin/palace-unit-tests\n\n# GPU tests (if available)\n# (command -v nvidia-smi is for your convenience, so that you can copy this block of code\n#  and use it as-is even when a GPU is not available)\ncommand -v nvidia-smi && bin/palace-unit-tests --device cuda\n\nThis generates multiple coverage-<pid>.profraw files, where <pid> represents each process ID. These raw files must be merged and converted to LCOV format:\n\n# Merge raw coverage files\nllvm-profdata merge -output=coverage.profdata coverage*.profraw\n\n# Export to JSON format\nllvm-cov export -format text -instr-profile coverage.profdata bin/palace-unit-tests > coverage_llvm.json\n\n# Convert to LCOV format\nllvm2lcov --ignore-errors inconsistent --output coverage.info coverage_llvm.json\n\nnote: Why two different coverage systems?\nLLVM's source-based coverage provides more accurate instrumentation than the gcov-compatible mode, which attempts to emulate gcov behavior but has known reliability issues. The source-based approach offers better precision for complex codebases.","category":"section"},{"location":"developer/testing/#Generating-coverage-reports","page":"Testing","title":"Generating coverage reports","text":"Once you have produced coverage.info using either method, filter the data to include only Palace source code:\n\nlcov --extract coverage.info \\\n  '*/palace/drivers/*' \\\n  '*/palace/fem/*' \\\n  '*/palace/linalg/*' \\\n  '*/palace/models/*' \\\n  '*/palace/utils/*' \\\n  '*/test/unit/*' \\\n  --output-file coverage_filtered.info\n\nGenerate an HTML report for visualization:\n\ngenhtml coverage_filtered.info --output-directory coverage_html\n\nOpen coverage_html/index.html in your web browser to explore the interactive coverage report, which shows line-by-line coverage statistics and identifies untested code paths.","category":"section"},{"location":"developer/testing/#Regression-tests","page":"Testing","title":"Regression tests","text":"In addition to unit tests, Palace comes with a series of regression tests. Regression tests based on the provided example applications in the examples/ directory and verify that the code reproduces results in reference files stored in test/examples/.","category":"section"},{"location":"developer/testing/#Building-and-running-example-tests","page":"Testing","title":"Building and running example tests","text":"","category":"section"},{"location":"developer/testing/#Prerequisites","page":"Testing","title":"Prerequisites","text":"Julia\nPalace executable in PATH or specified via environment variable/command-line argument","category":"section"},{"location":"developer/testing/#Setup","page":"Testing","title":"Setup","text":"First, instantiate the Julia environment:\n\njulia --project -e \"using Pkg; Pkg.instantiate()\"\n\nYou need to do this step only the very first time.","category":"section"},{"location":"developer/testing/#Command-Line-Arguments","page":"Testing","title":"Command Line Arguments","text":"The test runner supports command line arguments for configuration. Each argument can also be set via environment variables as fallbacks.\n\nKey Options:\n\n--palace-test: Path to Palace executable and optional arguments (default: \"palace\")\n--num-proc-test: Number of MPI processes (default: number of physical cores)\n--test-cases: Space-separated list of test cases to run (default: all examples)\n\nRun julia --project runtests.jl --help to see all available options with descriptions and defaults.","category":"section"},{"location":"developer/testing/#Execution","page":"Testing","title":"Execution","text":"Run all tests:\n\njulia --project runtests.jl\n\nRun specific test cases:\n\njulia --project runtests.jl --test-cases \"spheres rings\"\n\nRun with custom Palace executable:\n\njulia --project runtests.jl --palace-test \"../../build/bin/palace\"\n\nRun with custom number of processes:\n\njulia --project runtests.jl --num-proc-test 4\n\nYou can also use environment variables as fallbacks:\n\nTEST_CASES=\"spheres rings\" julia --project runtests.jl\nPALACE_TEST=\"../../build/bin/palace\" julia --project runtests.jl\n\nEach test case runs Palace simulations and compares generated CSV files against reference data using configurable tolerances. When Palace behavior changes legitimately (e.g., algorithm improvements), reference data can be updated using the baseline script:\n\n./baseline                    # Update all reference data\n./baseline -e spheres         # Update specific example\n./baseline --dry-run          # Test without updating files\n./baseline -np 4              # Use 4 MPI processes","category":"section"},{"location":"developer/tutorial_gpu_profiling/","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"developer/tutorial_gpu_profiling/#Tutorial:-GPU-Profiling-with-NVIDIA-Nsight-Systems-and-NVTX","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","text":"This tutorial demonstrates how to profile Palace GPU execution using NVIDIA Nsight Systems with NVTX ranges for better code traceability.\n\nNVIDIA Nsight Systems is a system-wide performance analysis tool that provides timeline profiling of CPU and GPU activity, including CUDA kernels, memory transfers, and API calls. NVIDIA Nsight Compute is a kernel-level profiler for detailed analysis of individual CUDA kernels. NVTX (NVIDIA Tools Extension) provides a C-based API for annotating events and ranges in your application, making profiles much easier to interpret.\n\nGPU profiling is more complex than CPU profiling because GPU execution is asynchronous. GPU kernels launch asynchronously, so CPU timers don't capture actual GPU execution time. Performance depends heavily on memory access patterns and how well threads utilize GPU resources.\n\nThis tutorial assumes familiarity with compiling and running unit tests (see Running unit tests). You'll need Palace compiled with CUDA support (-DPALACE_WITH_CUDA=yes) and NVIDIA Nsight Systems installed.","category":"section"},{"location":"developer/tutorial_gpu_profiling/#Basic-Profiling","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Basic Profiling","text":"In this tutorial, we will profile the Vector Sum - Complex unit test.\n\nFirst, let us make the test more interesting for profiling by increasing the vector size. Find the Vector Sum - Complex test in test/unit/test-vector.cpp, and increase the size of the vector:\n\n-ComplexVector cv(2);\n+ComplexVector cv(20000);\n\nMake sure that we have a working and compiled version of Palace:\n\ncmake -DPALACE_MFEM_USE_EXCEPTIONS=yes -DPALACE_WITH_CUDA=yes ..\nmake -j $(nproc)\nbin/palace-unit-tests \"Vector Sum - Complex\" --device gpu --backend /gpu/cuda/magma\n\nThis will show something along the lines of\n\nDevice configuration: cuda,cpu\nMemory configuration: host-umpire,cuda-umpire\nUse GPU-aware MPI:    no\nlibCEED backend: /gpu/cuda/magma\nFilters: \"Vector Sum - Complex\" [GPU] [Serial]\nRandomness seeded to: 2674903133\n===============================================================================\nAll tests passed (2 assertions in 1 test case)\n\nNow, run this under nsys:\n\nnsys profile --trace=cuda,cublas --force-overwrite=true -o myprofile.nsys-rep \\\n  bin/palace-unit-tests \"Vector Sum - Complex\" --device gpu --backend /gpu/cuda/magma\n\nYou can open the report with nsys-ui myprofile.nsys-rep. You should be greeted with a window like this:\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/profiling/nsys2.png\" alt=\"NVIDIA Nsight Systems timeline\" style=\"max-width: 100%; cursor: pointer;\" onclick=\"window.open(this.src, '_blank')\" />\n  <br/><em>Click image to view full size - NVIDIA Nsight Systems timeline</em>\n</p><br/>\n\nThere's a lot to unpack here. What you are looking at is the timeline of execution of the test as seen by different components. We have the CPUs on top, the GPU on the second row, and other components below. Consult the documentation to learn more about how to read this.\n\nThe key problem here is that this timeline has no clear connection to the source code. How do we know what is really happening?\n\nWe can get some clues by moving the mouse around and zooming. In particular, we can zoom into the region around 200 milliseconds. Here, we can see that there are some CUDA memory operations (under CUDA APIs), and we can see that there's some activity on the GPU (the little bars in the CUDA HW line). We can possibly guess that this is where the test is allocating the vectors and doing the sum operations.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/profiling/nsys2.png\" alt=\"NVIDIA Nsight Systems zoomed view around 200ms showing CUDA memory operations\" style=\"max-width: 100%; cursor: pointer;\" onclick=\"window.open(this.src, '_blank')\" />\n  <br/><em>Click image to view full size - Zoomed view showing CUDA memory operations around 200ms</em>\n</p><br/>","category":"section"},{"location":"developer/tutorial_gpu_profiling/#Adding-NVTX-Ranges","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Adding NVTX Ranges","text":"With a little bit more effort, we could probably get insight directly from this report. However, it is often more convenient to use NVTX ranges to orient ourselves around the code. NVTX provides a way to mark the source code and see the markings in the Nsight report.\n\nThe most common NVTX marking is the range. As the name suggests, a range is a way to identify a block of code and give it a name.\n\nTo use NVTX, we need to include its header:\n\n#include \"nvtx3/nvtx3.hpp\"\n\nThen, we can define ranges with:\n\nnvtxRangePush(\"My first range\");\nmycode1();\nmycode2();\nmycode3();\nnvtxRangePop();\n\nAlternatively, NVTX3 provides nvtx3::scoped_range which uses RAII to automatically define a range in a given scope. The example above would become:\n\n{\n    nvtx3::scoped_range range(\"My first range\");\n    mycode1();\n    mycode2();\n    mycode3();\n}\n\nThe advantage of this approach is that it's easy to forget to close the range manually, and RAII does it automatically when the scope ends. Consult to NVTX documentation for more details.\n\nLet us follow this method and change the test to:\n\n{\n    nvtx3::scoped_range range(\"Initialize\");\n    mfem::forall(cv.Size(),\n               [=] MFEM_HOST_DEVICE(int i)\n               {\n                 // Rank 0: [(0, 1), (0, 2), ...], Rank 1: [(1, 2), (1, 3), ...], etc.\n                 d_real[i] = rank;\n                 d_imag[i] = rank + i;\n               });\n}\n\nstd::complex<double> sum;\n{\n    nvtx3::scoped_range range(\"Sum\");\n    sum = linalg::Sum(Mpi::World(), cv);\n}\n\nWe recompile Palace and run the profiler again. When we have ranges, we need to ask nsys to keep track of them, so the invocation changes slightly. We also add other useful components to track:\n\nnsys profile --trace=nvtx,cuda,cublas,mpi --nvtx-capture=range \\\n  --force-overwrite=true -o myprofile.nsys-rep \\\n  bin/palace-unit-tests \"Vector Sum - Complex\" --device gpu --backend /gpu/cuda/magma\n\nNow, if we open the new profile, we will see some differences:\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/profiling/nsys3.png\" alt=\"NVIDIA Nsight Systems with NVTX ranges showing MPI initialization and custom ranges\" style=\"max-width: 100%; cursor: pointer;\" onclick=\"window.open(this.src, '_blank')\" />\n  <br/><em>Click image to view full size - Timeline with NVTX ranges and MPI initialization visible</em>\n</p><br/>\n\nFirst, we now learn that the large idle block was due to MPI initialization. Second, we see that there's now a new NVTX line. If we zoom in where it has activity, we find our Initialize and Sum blocks:\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/profiling/nsys4.png\" alt=\"NVIDIA Nsight Systems zoomed view of Initialize and Sum NVTX blocks\" style=\"max-width: 100%; cursor: pointer;\" onclick=\"window.open(this.src, '_blank')\" />\n  <br/><em>Click image to view full size - Detailed view of Initialize and Sum NVTX ranges</em>\n</p><br/>\n\nWe can now right-click on the Initialize block and select \"Fit to screen\", then expand some sections to learn more about what is happening:\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/profiling/nsys5.png\" alt=\"NVIDIA Nsight Systems detailed view of Initialize block showing CUDA APIs and GPU kernel execution\" style=\"max-width: 100%; cursor: pointer;\" onclick=\"window.open(this.src, '_blank')\" />\n  <br/><em>Click image to view full size - Expanded view showing CUDA APIs and GPU kernel timing details</em>\n</p><br/>\n\nWhat we see is that Initialize takes 200 microseconds, but most of it is due to one-time costs (as we see under CUDA APIs). The actual kernel that runs on the GPU is highlighted and takes less than 2 microseconds.\n\nSomething worth noting is that the actual kernel executed on the GPU starts only after the CPU has completed (the CuKernel1D block). This demonstrates why CPU timers cannot accurately profile GPU code unless they force synchronization (i.e., make the CPU wait for the GPU kernel to complete).","category":"section"},{"location":"developer/tutorial_gpu_profiling/#Key-Takeaways","page":"Tutorial: GPU Profiling with NVIDIA Nsight Systems and NVTX","title":"Key Takeaways","text":"NVTX ranges provide essential context for understanding GPU profiles by connecting timeline events to source code. The asynchronous nature of GPU execution means that CPU and GPU work can overlap, making traditional CPU timing inadequate for GPU performance analysis. From here, you should be equipped to start exploring Nsight System on your own.","category":"section"},{"location":"examples/spheres/","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"examples/spheres/#Capacitance-Matrix-for-Two-Spheres","page":"Capacitance Matrix for Two Spheres","title":"Capacitance Matrix for Two Spheres","text":"note: Note\nThe files for this example can be found in the examples/spheres/ directory of the Palace source code.\n\nIn this example, we consider two conducting spheres of radii a and b, with centers separated by a distance c  a + b. The surrounding medium is vacuum. An analytic solution for the capacitance matrix of this configuration exists and is given in [1]. The Maxwell capacitance matrix entries are given by the infinite series\n\nbeginaligned\nC_aa = 4pivarepsilon_0 ab sinhusum_n=0^infty frac1asinhnu+bsinh(n+1)u \nC_bb = 4pivarepsilon_0 ab sinhusum_n=0^infty frac1bsinhnu+asinh(n+1)u \nC_ab = -4pivarepsilon_0 fracabc sinhusum_n=1^infty frac1sinhnu\nendaligned\n\nwhere the subscript a refers to the sphere with radius a and likewise for b. The parameter u is given by\n\ncoshu = fracc^2-a^2-b^22ab \n\nHere we take the values a = 1text cm, b = 2text cm, and c = 5text cm. A mesh is generated with Gmsh using the mesh.jl Julia script found in the mesh/ directory, which writes the mesh to mesh/spheres.msh. The resulting high-order mesh uses cubically-curved tetrahedral elements, and is pictured below.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/spheres-1.png\" width=\"45%\" />\n  <img src=\"../../assets/examples/spheres-2.png\" width=\"45%\" />\n</p><br/>\n\nThe configuration file for the Palace simulation is found in spheres.json. We set the simulation \"Type\" to \"Electrostatic\", and add \"Terminal\" entries for the surface boundary of each sphere, corresponding to the entries of the capacitance matrix we wish to compute. The outer boundary of the computational domain, which is sufficiently far from the spheres, is prescribed a \"Ground\" boundary condition. We set the \"Order\" of the finite element approximation to 3.\n\nThe resulting extracted Maxwell capacitance matrix is saved to disk in the CSV file postpro/terminal-C.csv:\n\ninclude_example_file(\"spheres\", \"terminal-C.csv\") # hide\n\nIn this case, the analytic solution yields\n\nbeginaligned\nC_aa = +1230518text pF \nC_bb = +2431543text pF \nC_ab = -04945668text pF\nendaligned\n\nwhich is computed using the first n=12 terms in the series after which convergence to a relative tolerance of 10^-12 is reached. Thus, the errors in the capacitance coefficients by Palace are 057, 19, and 35, respectively.\n\nThe mutual capacitance matrix can be computed from its Maxwell counterpart, and is saved in postpro/terminal-Cm.csv:\n\ninclude_example_file(\"spheres\", \"terminal-Cm.csv\") # hide\n\nAdditionally, while the typical approach used by Palace for lumped parameter extraction uses the computed field energies, the capacitance can also be calculated by directly integrating the charge on a boundary surface and dividing by the excitation voltage. The configuration file for this example contains this information under config[\"Boundaries\"][\"Postprocessing\"][\"SurfaceFlux\"]. The resulting capacitances are written to postpro/terminal-C.csv:\n\ninclude_example_file(\"spheres\", \"terminal-C.csv\") # hide\n\nFinally, the postpro/paraview directory contains files for visualizing the computed field solutions with ParaView. Below we present the electrostatic potential fields for each terminal solution.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/spheres-3.png\" width=\"45%\" />\n  <img src=\"../../assets/examples/spheres-4.png\" width=\"45%\" />\n</p>","category":"section"},{"location":"examples/spheres/#References","page":"Capacitance Matrix for Two Spheres","title":"References","text":"[1] J. Lekner, Capacitance coefficients of two spheres, Journal of Electrostatics 69 (2011) 11-14.","category":"section"},{"location":"reference/","page":"Reference","title":"Reference","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#Mathematical-background","page":"Reference","title":"Mathematical background","text":"The solver computes a finite element approximation to the three-dimensional, time-harmonic Maxwell's equations in second-order form. The nondimensionalized, source-free, boundary value problem for bmE(bmx)inmathbbC^3, bmxinOmega, partialOmega = Gamma, where bmmathscrE(bmxt) = textRebmE(bmx)e^iomega t denotes the electric field, is written as\n\nbeginaligned\nnablatimesmu_r^-1nablatimesbmE + iomegasigmabmE\n    - omega^2varepsilon_rbmE = 0  bmxinOmega \nbmntimesbmE = 0  bmxinGamma_PEC \nbmntimes(mu_r^-1nablatimesbmE) = 0  bmxinGamma_PMC \nbmntimes(mu_r^-1nablatimesbmE)\n    + gammabmntimes(bmntimesbmE) = bmU^inc  bmxinGamma_Z\nendaligned\n\nwhere the nondimensionalization has been performed with respect to a characteristic length L_0, time L_0c_0, magnetic field strength H_0, and electric field strength Z_0 H_0. Here, c_0 and Z_0 are the speed of light and impedance of free space, respectively. This nondimensionalization will be used throughout this entire reference. For more details, see [1] and [2].\n\nGiven the electric field solution, the time-harmonic magnetic flux density can be calculated as\n\nbmB = -frac1iomeganablatimesbmE \n\nThe flux density is related to the magnetic field, bmH, by the standard linear constitutive relationship bmH = mu_r^-1bmB.\n\nIn general, the material property coefficients may be scalar- or matrix-valued. In the matrix-valued (anisotropic) case, the material property coefficients should still always be symmetric.\n\nFor a general isotropic lossy dielectric, the relative permittivity varepsilon_r is a complex-valued quantity:\n\nvarepsilon_r = varepsilon_r (1-itandelta)\n\nwhere varepsilon_r is the real relative permittivity and tandelta is the loss tangent. Alternatively, conductor loss is modeled by Ohm's law bmJ = sigmabmE with electrical conductivity sigma  00. For a superconducting domain, the constitive current-field relationship given by Ohm's law is replaced by that given by the London equations:\n\nfracpartial bmJpartial t = frac1mu_rlambda_L^2bmE\n\nwhere lambda_L = sqrtmmu n_s e^2L_0 is the nondimensionalized London penetration depth. In this case, the term +iomegasigma bmE arising for a normal conductor in the time-harmonic Maxwell's equations becomes +(mu_r lambda_L^2)^-1bmE.\n\nThe domain boundary Gamma = Gamma_PECcupGamma_PMCcupGamma_Z, is separated into perfect electric conductor (PEC), perfect magnetic conductor (PMC), and impedance boundaries, respectively. The PEC boundary condition is a homogeneous Dirichlet condition, while the PMC boundary condition is the natural boundary condition for the problem and is satisfied at all exterior boundaries by the finite element formulation. Impedance boundaries are modeled using a Robin boundary condition with gamma = iomegaZ_s, in which Z_s the surface impedance of the boundary, with units of impedance per square.","category":"section"},{"location":"reference/#Floquet-periodic-boundary-conditions","page":"Reference","title":"Floquet periodic boundary conditions","text":"When applying Floquet periodic boundary conditions, the phase delay is incorporated into the time-harmonic Maxwell equations and exact periodic boundary conditions are applied. The modified Maxwell equations are obtained by substituting bmE(bmx) = bmE_p(bmx)e^-i bmk_p cdot bmx, where bmE_p is the periodic electric field and  bmk_p is the user-specified Bloch wavevector. The resulting equation is\n\nbeginaligned\nnablatimesmu_r^-1nablatimesbmE_p\n- ibmk_ptimesmu_r^-1nablatimesbmE_p\n- inablatimes(mu_r^-1bmk_ptimesbmE_p)  \n- bmk_ptimesmu_r^-1bmk_ptimesbmE_p\n+ iomegasigmabmE_p\n- omega^2varepsilon_rbmE_p = 0  bmxinOmega\nendaligned\n\nand given the electric field solution, the time-harmonic magnetic flux density can be calculated as\n\nbmB_p = -frac1iomeganablatimesbmE_p + frac1omega bmk_p times bmE_p ","category":"section"},{"location":"reference/#Time-domain-formulation","page":"Reference","title":"Time domain formulation","text":"A time-dependent formulation is also available to compute the electric field response bmE(bmxt) for a given time-dependent source excitation bmU^inc(bmxt). The governing equations in this case are\n\nnablatimesmu_r^-1nablatimesbmE + sigmafracpartialbmEpartial t\n    + varepsilon_rfracpartial^2bmEpartial t^2 = 0  bmxinOmega\n\nsubject to the same boundary conditions as the frequency-dependent case except for the Robin boundary condition which is written for a lumped resistive port boundary, for example, as\n\nbmntimes(mu_r^-1nablatimesbmE)\n    + Z_s^-1bmntimesleft(bmntimesfracpartialbmEpartial tright)\n    = bmU^inc  bmxinGamma_Z \n\nThe second-order electric field differential equation is transformed into a first-order ODE system which is solved along with the equation for the magnetic flux density\n\nleft(beginmatrix varepsilon_r  0  0  0  I  0  0  0  Iendmatrixright)\n  left(beginmatrix ddotbmE  dotbmE  dotbmBendmatrix right)\n  = left(beginmatrix -sigma  -nablatimesmu_r^-1nablatimes  0 I  0  0  0  -nablatimes  0endmatrixright)\n    left(beginmatrixdotbmE bmE  bmB endmatrixright) \n\nThe first-order ODE system formulation is chosen to take advantage of implicit adaptive time-stepping integration schemes. The 3 times 3 system can be block-eliminated to avoid an expensive coupled block system solve. It offers the additional benefit of sharing many similarities in the spatial discretization as the frequency domain formulation outlined above.","category":"section"},{"location":"reference/#Eigenmode-calculations","page":"Reference","title":"Eigenmode calculations","text":"For eigenmode problems, the source term is zero and a quadratic eigenvalue problem for the eigenvalues omega is solved:\n\n(bmK+iomegabmC-omega^2bmM)bmx = 0\n\nwhere the matrix bmK represents the discretized curl-curl operator, bmM the mass term, and bmC the port impedance boundary conditions. The damped frequency omega_d and quality factor Q are postprocessed from each of the resulting eigenvalues as\n\nomega_d = textReomega  qquad Q = fracomega2textImomega \n\nWhen wave port, surface conductivity, or second-order absorbing boundary conditions are used, a nonlinear eigenvalue problem is solved:\n\n(bmK+iomegabmC-omega^2bmM+bmA_2(omega))bmx = 0\n\nwhere the matrix bmA_2 represents the nonlinear frequency-dependent boundary conditions.\n\nThe eigenmodes are normalized such that they have unit norm and their mean phase is a positive real number.","category":"section"},{"location":"reference/#Lumped-ports-and-wave-ports","page":"Reference","title":"Lumped ports and wave ports","text":"For lumped port boundaries, the surface impedance can be related to an equivalent circuit impedance, Z. There are two common cases:\n\nRectangular ports: Z = Z_s l  w, where l and w are the length and width of the port, respectively (length here is defined as the distance between the two conductors).\nCoaxial ports: Z = Z_s ln(ba)  2pi, where a and b denote the inner and outer radii of the port, respectively.\n\nA lumped parallel RLC circuit boundary has a circuit impedance\n\nfrac1Z = frac1R+frac1iomega L+iomega C \n\nThus, the relationships between the circuit and surface element parameters for the user to specify are given by R_s = alpha R, L_s = alpha L, and C_s = Calpha, where alpha = wl for a rectangular port or alpha = 2pi  ln(ba) for a coaxial port.\n\nFor multielement lumped ports, the effective circuit impedance is given by\n\nfrac1Z = sum_k frac1Z_k \n\nThat is, the circuit impedances of each port contributing to the multielement port add in parallel. For the specific case of a two element multielement port with two identical lumped elements, we have Z = (1Z_1 + 1Z_2)^-1 = Z_k  2, where Z_k is the circuit impedance of a single port element.\n\nThe source term bmU^inc in a driven frequency-response problem is related to the incident field at an excited port boundary by\n\nbmU^inc = -2gamma(bmntimesbmE^inc)timesbmn\n\nwhere (bmntimesbmE^inc)timesbmn is just the projection of the excitation field onto the port surface. The incident fields for lumped ports depend on the port shape:\n\nRectangular ports: bmE^inc = E_0  hatbml, where E_0 is a uniform constant field strength and hatbml a unit vector defining the direction of polarization on the port (typically should be the direction between the two conductors).\nCoaxial ports: bmE^inc = fracE_0 r_0r  hatbmr, where E_0 is again a uniform constant field strength, r_0 is a characteristic length for the port, r is the distance from the port center, and hatbmr a unit vector specifying the port radial direction.\n\nIn the time domain formulation, the source term bmU^inc appears as\n\nbmU^inc = -2 Z_s^-1left(bmntimesfracpartialbmE^incpartial tright)\n    timesbmn \n\nThe incident field bmE^inc(bmxt) is\n\nbmE^inc(bmxt) = p(t)bmE^inc(bmx)\n\nwhere bmE^inc(bmx) is identical to the spatial excitation in the frequency domain formulation, and p(t) describes the temporal shape of the excitation. Possible options include a sinusoidal, Gaussian, modulated Gaussian, or step excitation.\n\nIn the frequency domain, the scattering parameters can be postprocessed from the computed electric field for each lumped port with boundary Gamma_i as\n\nS_ij = fracdisplaystyleint_Gamma_ibmEcdotbmE^inc_idS\n    displaystyleint_Gamma_ibmE^inc_icdotbmE^inc_idS - delta_ij \n\nIn the time domain, the time histories of the port voltages can be Fourier-transformed to get their frequency domain representation for scattering parameter calculation.\n\nNumeric wave ports assume a field with known normal-direction dependence bmE(bmx) = bme(bmx_t)e^ik_n x_n where k_n is the propagation constant. For each operating frequency omega, a two-dimensional eigenvalue problem is solved on the port yielding the mode shapes bme_m and associated propagation constants k_nm. These are used in the full 3D model where the Robin port boundary condition has coefficient gamma = itextRek_nmmu_r and the computed mode is used to compute the incident field in the source term bmU^inc at excited ports. Scattering parameter postprocessing takes the same form as the lumped port counterpart using the computed modal solutions. Since the propagation constants are known for each wave port, scattering parameter de-embedding can be performed by specifying an offset distance d for each port:\n\ntildeS_ij = S_ije^ik_nid_ie^ik_njd_j \n\nFor more information on the implementation of numeric wave ports, see [3].","category":"section"},{"location":"reference/#Other-boundary-conditions","page":"Reference","title":"Other boundary conditions","text":"The first-order absorbing boundary condition, also referred to as a scattering boundary condition, is a special case of the general impedance boundary condition described above:\n\nbmntimes(mu_r^-1nablatimesbmE)\n    + iomegasqrtmu_r^-1varepsilon_rbmntimes(bmntimesbmE) = 0 \n\nThis is also known as the Sommerfeld radiation condition, and one can recognize the dependence on the impedance of free space Z_0^-1 = sqrtmu_r^-1varepsilon_r. The second-order absorbing boundary condition is\n\nbmntimes(mu_r^-1nablatimesbmE)\n    + iomegasqrtmu_r^-1varepsilon_rbmntimes(bmntimesbmE)\n    - betanablatimes(nablatimesbmE)_nbmn = 0\n\nwhere assuming an infinite radius of curvature beta = mu_r^-1c_0(2iomega), and the contribution depending on (nablacdotbmE_t) has been neglected.\n\nAdditionally, while metals with finite conductivity can be modeled using an impedance boundary condition with constant impedance Z_s, a more accurate model taking into account the frequency dependence of the skin depth is\n\nZ_s = frac1+ideltasigma\n\nwhere delta = sqrt2mu_rsigmaomega is the skin depth and sigma is the conductivity of the metal. Another model, which takes into account finite thickness effects, is given by\n\nZ_s = frac1deltasigmaleft(fracsinhnu+sinnucoshnu+cosnu\n    + ifracsinhnu-sinnucoshnu+cosnuright)\n\nwhere nu = hdelta and h is the layer thickness. This model correctly produces the DC limit when hlldelta.","category":"section"},{"location":"reference/#Energy-participation-ratios","page":"Reference","title":"Energy-participation ratios","text":"The energy-participation ratio (EPR) for lumped inductive elements is computed from the electric and magnetic fields corresponding to eigenmode m, bmE_m and bmH_m, using the formula\n\np_mj = frac1mathcalE^elec_m  frac12  L_j I_mj^2\n\nwhere p_mjin-11 denotes the signed participation ratio for junction j in mode m, L_j is the provided junction circuit inductance, I_ mj is the peak junction current for mode m, and mathcalE^elec_m is the electric energy in mode m. The junction current is computed using the mean voltage across the port, overlineV_mj, as I_mj = overlineV_mjZ_mj, where Z_mj = 1(iomega_m L_j) is the impedance of the inductive branch of the lumped circuit. The mean port voltage depends on the computed electric field mode and the shape of the port:\n\nRectangular ports: overlineV_mj = frac1w_jint_Gamma_jbmE_mcdothatbml_jdS.\nCoaxial ports: overlineV_mj = frac12piint_Gamma_jfracbmE_mrcdothatbmr_jdS.\n\nFinally, the total electric energy in mode m is\n\nmathcalE^elec_m\n    = frac12  textReleftint_OmegabmD_m^*cdotbmE_mdVright\n    + sum_j frac12  C_jV_mj^2\n\nwhere bmD_m = varepsilon_rbmE_m is the electric flux density for mode m and the second term on the right-hand side accounts for any lumped capacitive boundaries with nonzero circuit capacitance C_j.\n\nThe EPR can also be used to estimate mode quality factors due to input-output (I-O) line coupling. The mode coupling quality factor due to the j-th I-O port is given by\n\nQ_mj = fracomega_mkappa_mj\n\nwhere the port coupling rate kappa_mj is calculated as\n\nkappa_mj = frac1mathcalE^elec_m  frac12R_j I_mj^2 ","category":"section"},{"location":"reference/#Bulk-and-interface-dielectric-loss","page":"Reference","title":"Bulk and interface dielectric loss","text":"The quality factor due to bulk dielectric loss resulting from an electric field bmE present in domain j with associated loss tangent tandelta_j is given by\n\nfrac1Q_j = p_j tandelta_j =\n    frac1mathcalE^elec  frac12  tandelta_j \n    textReleftint_Omega_jbmD^*cdotbmEdVright\n\nwhere, as above, mathcalE^elec is the total electric field energy in the domain, including the contributions due to capacitive lumped elements.\n\nLikewise, the quality factor due to surface interface dielectric loss for interface j is given by\n\nfrac1Q_j = p_j tandelta_j =\n    frac1mathcalE^elec  frac12  t_jtandelta_j \n    textReleftint_Gamma_jbmD^*cdotbmEdSright\n\nwhere t_j is the thickness of the layer and bmD = varepsilon_rjbmE is the electric displacement field in the layer evaluated using the relative permittivity of the interface varepsilon_rj. For an internal boundary, this integral is evaluated on a single side to resolve ambiguity due to the discontinuity of bmE across the boundary.\n\nThe above formula for interface dielectric loss can be specialized for the case of a metal-air, metal-substrate, or substrate-air interface [4]. In each case, the quality factor for interface j is given by\n\nMetal-air:\n\nfrac1Q^MA_j =\n    frac1mathcalE^elec  frac12 \n    fract_jtandelta_jvarepsilon_rj^MA \n    textReleftint_Gamma_jbmE_n^*cdotbmE_ndSright\n\nMetal-substrate:\n\nfrac1Q^MS_j =\n    frac1mathcalE^elec  frac12 \n    fract_jtandelta_j(varepsilon_rj^S)^2varepsilon_rj^MS \n    textReleftint_Gamma_jbmE_n^*cdotbmE_ndSright\n\nSubstrate-air:\n\nfrac1Q^SA_j =\n    frac1mathcalE^elec  frac12 \n    t_jtandelta_jleft(varepsilon_rj^SA \n    textReleftint_Gamma_jbmE_t^*cdotbmE_tdSright\n    + frac1varepsilon_rj^SA \n    textReleftint_Gamma_jbmE_n^*cdotbmE_ndSrightright)\n\nwhere bmE_n denotes the normal field to the interface and bmE_t = bmE-bmE_n denotes the tangential field.","category":"section"},{"location":"reference/#Lumped-parameter-extraction","page":"Reference","title":"Lumped parameter extraction","text":"For electrostatic simulations, the Maxwell capacitance matrix is computed in the following manner. First, the Laplace equation subject to Dirichlet boundary conditions is solved for each terminal with boundary Gamma_i in the model, yielding an associated voltage field V_i(bmx):\n\nbeginaligned\nnablacdot(varepsilon_rnabla V_i) = 0  bmxinOmega \nV_i = 1  bmxinGamma_i \nV_i = 0  bmxinGamma_j  jneq i \nendaligned\n\nThe energy of the electric field associated with any solution is\n\nmathcalE(V_i) = frac12int_Omegavarepsilon_rbmE_icdotbmE_idV\n\nwhere bmE_i=-nabla V_i is the electric field. Then, the entries of the Maxwell capacitance matrix, bmC, are given by\n\nbmC_ij = mathcalE(V_i+V_j)-frac12(bmC_ii+bmC_jj) \n\nMagnetostatic problems for inductance matrix extraction are based on the magnetic vector potential formulation:\n\nbeginaligned\nnablatimes(mu_r^-1nablatimesbmA_i) = 0  bmxinOmega \nbmntimes(mu_r^-1nablatimesbmA_i) =\n    bmntimesbmH_i = bmJ_s^inc  bmxinGamma_i \nbmntimes(mu_r^-1nablatimesbmA_i) = 0  bmxinGamma_j  jneq i \nendaligned\n\nFor each port with boundary Gamma_i, a unit source surface current bmJ_s^inc is applied, yielding an associated vector potential solution bmA_i(bmx). Homogeneous Dirichlet boundary conditions bmntimesbmA_i=0 are also imposed on specified surfaces of the model. The magnetic field energy associated with any solution is\n\nmathcalE(bmA_i) = frac12int_Omegamu_r^-1bmB_icdotbmB_idV\n\nwhere bmB_i = nablatimesbmA_i is the magnetic flux density. Then, the entries of the inductance matrix, bmM, are given by\n\nbmM_ij = frac1I_i I_jmathcalE(bmA_i+bmA_j)\n    - frac12left(fracI_iI_jbmM_ii+fracI_jI_ibmM_jjright)\n\nwhere I_i is the excitation current for port i, computed by integrating the source surface current bmJ_s^inc over the surface of the port.","category":"section"},{"location":"reference/#Error-estimation-and-adaptive-mesh-refinement-(AMR)","page":"Reference","title":"Error estimation and adaptive mesh refinement (AMR)","text":"Error estimation is used to provide element-wise error estimates for AMR, as well as a global error indicator used to terminate AMR iterations or provide an estimate for solution accuracy. A Zienkiewicz–Zhu (ZZ) error estimator based on [5] is implemented, which measures the error in the recovered magnetic field and electric flux density. On element K, we have\n\neta^2_K = eta_m2^2+eta_eK^2 =\n    mu_r^12bmR_ND(mu^-1bmB)\n    - (mu_r^-12bmB)_L^2(Omega_K)^2\n    + varepsilon_r^-12bmR_RT(varepsilon_rbmE)\n    - (varepsilon_r^12bmE)_L^2(Omega_K)^2\n\nwhere bmR_ND and bmR_RT are the smooth-space recovery operators which orthogonally project their argument onto H(textcurl) and H(textdiv), discretized by Nédélec and Raviart-Thomas elements, respectively.","category":"section"},{"location":"reference/#Far-field-extraction","page":"Reference","title":"Far-field extraction","text":"This feature is based upon Stratton-Chu's transformations [6] in the limit of kr gg 1 (with k wave number and r observation distance). One can show (see below) that, in this limit,\n\nr mathbfE_p(mathbfr_0) = fracik4pi mathbfr_0 times int_S mathbfn times mathbfE - Z mathbfr_0 times (mathbfn times mathbfH) exp(ikmathbfr cdot mathbfr_0) dS\n\nwhere:\n\nE_p is the electric field at the observation point\nk is the wave number\nr₀ is the unit vector from source to observation point, parameterized by (theta phi)\nn is the surface normal (to S)\nE H are the tangential fields on the surface\nZ is the impedance\n\nThe integral is over the exterior surface S.\n\nNote, we obtain r mathbfE_p because the electric field decays with exp(ikr)r, so multiplying it by r ensures that the quantity is finite. Note also that the solution is defined up to a global phase factor.\n\nThis equation relies on an analytic form for Green's function and is only valid in 3D and if S only crosses isotropic materials.\n\nFrom r mathbfE_p, one can obtain the magnetic field assuming that the waves are propagating in free space,\n\nr mathbfH_p = fracr_0 times r mathbfE_pZ_0\n\nwith Z_0 impedance of free space.\n\nWith this, one can immediately compute the far-field relative radiation pattern as r mathbfE_p.","category":"section"},{"location":"reference/#How-to-obtain-the-equation-above-from-Stratton-Chu's-original-equations","page":"Reference","title":"How to obtain the equation above from Stratton-Chu's original equations","text":"Let us start from Stratton-Chu's transformation for the electric field (we will get the magnetic field from E):\n\nmathbfE(mathbfr_0) = int_S left i omega mu (mathbfn times mathbfH) g(mathbfr mathbfr_0) +\n(mathbfn times mathbfE) times nabla g(mathbfr mathbfr_0) + (mathbfn cdot mathbfE) nabla g(mathbfr mathbfr_0) right dS\n\nwith Green's function (here is where the assumption of isotropicity comes in):\n\ng(mathbfr mathbfr_0) = frace^-i k mathbfr - mathbfr_04 pi mathbfr - mathbfr_0\n\nLet us take the limit for r to infty and define R = mathbfr - mathbfr_0 (R to infty when r to infty). For r gg r_0 (far-field approximation):\n\nR approx r - mathbfrcdotmathbfr_0\n\nwhere mathbfr_0 = mathbfrr is the unit vector in the direction of mathbfr.\n\nThe far-field approximation for Green's function becomes:\n\ng(mathbfr mathbfr_0) approx frace^-i k r4 pi r e^i k mathbfr_0cdotmathbfr\n\nFor the gradient of g, we start with the exact expression and expand phase and magnitude to reach:\n\nnabla g(mathbfr mathbfr_0) = -frace^-i k R4 pi Rleft(frac1R + i kright)hatR\n\nwhere hatR = (mathbfr - mathbfr_0)R is the unit vector pointing from mathbfr_0 to mathbfr.\n\nIn the far-field limit, R approx r and hatR approx mathbfr_0, so:\n\nnabla g(mathbfr mathbfr_0) approx -i k mathbfr_0 g(mathbfr mathbfr_0)\n\nwhere we've neglected the 1R term since k R gg 1 in the far-field.\n\nWith these ingredients, one then uses the triple vector product rule and drops the radial terms (i.e., those proportional to mathbfr_0, in the wave zone there are only transverse fields) to arrive at the equation presented in the previous section and implemented in Palace.","category":"section"},{"location":"reference/#References","page":"Reference","title":"References","text":"[1] J.-M. Jin, The Finite Element Method in Electromagnetics, Wiley-IEEE Press, Hoboken, NJ, Third edition, 2014.\n[2] P. Monk, Finite Element Methods for Maxwell's Equations, Oxford University Press, Oxford, 2003.\n[3] L. Vardapetyan and L. Demkowicz, Full-wave analysis of dielectric waveguides at a given frequency, Mathematics of Computation 72 (2003) 105-129.\n[4] J. Wenner, R. Barends, R. C. Bialczak, et al., Surface loss of superconducting coplanar waveguide resonators, Applied Physics Letters 99, 113513 (2011).\n[5] S. Nicaise, On Zienkiewicz-Zhu error estimators for Maxwell’s equations, Comptes Rendus Mathematique 340 (2005) 697-702.\n[6] J. A, Stratton and L. J. Chu, Diffraction theory of Electromagnetic Waves, Physical Review, 56, 1, (1939), 99-107.","category":"section"},{"location":"config/problem/","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"config/problem/#config[\"Problem\"]","page":"config[\"Problem\"]","title":"config[\"Problem\"]","text":"\"Problem\":\n{\n    \"Type\": <string>,\n    \"Verbose\": <int>,\n    \"Output\": <string>,\n    \"OutputFormats\":\n    {\n      ...\n    }\n}\n\nwith\n\n\"Type\" [None] :  Controls the simulation type. The available options are:\n\n\"Eigenmode\" :  Perform a undamped or damped eigenfrequency analysis.\n\"Driven\" :  Perform a frequency response simulation.\n\"Transient\" :  Perform a time domain excitation response simulation.\n\"Electrostatic\" :  Perform an electrostatic analysis to compute the capacitance matrix for a set of voltage terminals.\n\"Magnetostatic\" :  Perform a magnetostatic analysis to compute the inductance matrix for a set of current sources.\n\n\"Verbose\" [1] :  Controls the level of log file printing.\n\n\"Output\" [None] :  Directory path for saving postprocessing outputs.\n\n\"OutputFormats\" :  Top-level object for configuring the field output formats.","category":"section"},{"location":"config/problem/#problem[\"OutputFormats\"]","page":"config[\"Problem\"]","title":"problem[\"OutputFormats\"]","text":"\"OutputFormats\":\n{\n    \"Paraview\": <bool>,\n    \"GridFunction\": <bool>\n}\n\nwith\n\n\"Paraview\" [true] :  Set to true to output fields in Paraview format.\n\n\"GridFunction\" [false] :  Set to true to output fields in MFEM grid function format to visualize with GLVis.","category":"section"},{"location":"examples/rings/","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"examples/rings/#Inductance-Matrix-for-a-Pair-of-Concentric-Rings","page":"Inductance Matrix for a Pair of Concentric Rings","title":"Inductance Matrix for a Pair of Concentric Rings","text":"note: Note\nThe files for this example can be found in the examples/rings/ directory of the Palace source code.\n\nThis example seeks to compute the inductance matrix for a system of two concentric current-carrying rings of radii r_a and r_b, each with width w. As with the previous example, the permeability of the surrounding medium is assumed to be the permeability of free space. The mutual inductance, M_ab, can be easily computed for the case where r_all r_b and w = 0 using the Biot-Savart law as\n\nM_ab = fracmu_0pi r_b^22 r_a \n\nAnalytic expressions for the self inductance of this configuration can also be derived, for example from [1] we have\n\nbeginaligned\nM_aa = mu_0 r_a left(logfrac16 r_aw-175right) \nM_bb = mu_0 r_b left(logfrac16 r_bw-175right) \nendaligned\n\nWe take in this case r_a = 10 text μm, r_b = 100 text μm, and w = 1 text μm. The mesh.jl script in the mesh/ directory is used to generate an unstructured tetrahedral mesh with Gmsh, saved to mesh/rings.msh, and a depiction is shown below.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/rings-1.png\" width=\"60%\" />\n</p><br/>\n\nThe configuration file for the Palace simulation is rings.json. The simulation \"Type\" is \"Magnetostatic\", and we add \"SurfaceCurrent\" boundaries for applying a surface current to drive the inner or outer ring. The rest of the ring boundaries are labeled as \"PEC\" boundaries, which prescribes a zero magnetic flux, or magnetic insulation, boundary condition. The farfield is also prescribed the \"PEC\" boundary condition. We seek a second-order solution and use the geometric multigrid AMS solver.\n\nThe computed inductance matrix is saved to disk as postpro/terminal-M.csv, and below we show its contents:\n\ninclude_example_file(\"rings\", \"terminal-M.csv\") # hide\n\nAccording to the analytic expressions above, for this geometry we should have\n\nM_ab = 1973921text pH\n\nfor the mutual inductance, and\n\nbeginaligned\nM_aa = 4178537text pH\nM_bb = 7072050text pH\nendaligned\n\nfor the self inductances. Thus, the Palace solution has percent-level errors in the self inductances versus the analytic solutions.\n\nThe typical approach used by Palace for lumped parameter extraction uses the computed field energies, but one can also compute the inductance by explicitly integrating the magnetic flux through a surface and dividing by the excitation current. This is configured under config[\"Boundaries\"][\"Postprocessing\"][\"Inductance\"] in the configuration file. The postprocessed magnetic flux values are written to postpro/surface-F.csv:\n\ninclude_example_file(\"rings\", \"surface-F.csv\") # hide\n\nCombining with the values in postpro/terminal-I.csv we can compute the inductance matrix in this alternative fashion,\n\ninclude_example_file(\"rings\", \"terminal-I.csv\") # hide\n\nwe arrive at\n\nusing DelimitedFiles: readdlm #hide\nusing Printf #hide\npath = joinpath(@__DIR__, \"..\", \"..\", \"..\", \"test\", \"examples\", \"ref\", \"rings\") #hide\nsurface_F = readdlm(joinpath(path, \"surface-F.csv\"), ',', Float64, skipstart=1) #hide\nterminal_I = readdlm(joinpath(path, \"terminal-I.csv\"), ',', Float64, skipstart=1) #hide\nresult = copy(surface_F) #hide\nresult[:, 2] ./= terminal_I[:, 2] #hide\nresult[:, 3] ./= terminal_I[:, 2] #hide\nprintln(\"        i,                M[i][1] (H),                M[i][2] (H)\") #hide\nfor i = 1:size(result, 1) #hide\n    @printf(\n        \" %.2e,        %+.12e,        %+.12e\\n\",\n        result[i, 1],\n        result[i, 2],\n        result[i, 3]\n    ) #hide\nend #hide\n\nThe values computed using the flux integral method are in close agreement to those above, as expected. This method of calculating the inductance matrix directly from flux values is in general less accurate than using the energy method, due to convergence properties of finite element functional outputs, but serves as a validation of the energy calculation.\n\nLastly, we visualize the magnitude of the magnetic flux density field for the excitations of the inner and outer rings. The files for this visualization are again saved to the postpro/paraview directory.\n\n<br/><p align=\"center\">\n  <img src=\"../../assets/examples/rings-2.png\" width=\"45%\" />\n  <img src=\"../../assets/examples/rings-3.png\" width=\"45%\" />\n</p>","category":"section"},{"location":"examples/rings/#References","page":"Inductance Matrix for a Pair of Concentric Rings","title":"References","text":"[1] M. R. Alizadeh Pahlavani and H. A. Mohammadpour, Inductance comparison of the solenoidal coil of modular toroidal coils using the analytical and finite element method, Progress in Electromagnetics Research 20 (2010) 337-352.","category":"section"},{"location":"quick/","page":"Quick Start","title":"Quick Start","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"quick/#Run-your-first-simulation-with-Palace","page":"Quick Start","title":"Run your first simulation with Palace","text":"Welcome to your first tutorial with Palace!\n\nIn this tutorial, we will:\n\nInstall Palace using Spack\nSet up a simulation using a provided mesh\nRun the simulation and visualize results\n\nBy the end of this page, you'll understand the basic workflow of electromagnetic simulations with Palace. You will be able to follow the examples and start experimenting with setting up and running your own simulations.\n\nAs a motivating example, we'll solve for the electrostatic potential and capacitance matrix of two conducting spheres inside a larger grounded sphere. Our system consists of:\n\nTwo inner spherical conductors\nA larger outer sphere at zero potential\nVacuum in between\n\nThis is one of the examples included with Palace. For more details on the physics and comparisons against analytical results, see the full example page.","category":"section"},{"location":"quick/#A-bird's-eye-view-of-*Palace*","page":"Quick Start","title":"A bird's-eye view of Palace","text":"Palace is a finite-element code for PArallel LArge-scale Computational Electromagnetics. It is a command-line executable that runs on single or multiple nodes, supporting both CPUs and GPUs.\n\nA Palace simulation requires two main inputs:\n\nMesh file: The mesh file describes the target geometry. Palace does not construct meshes, so you must supply one. A large number of formats are supported, allowing you to use your preferred CAD or meshing software. See the supported mesh formats for more details.\nConfig file: A JSON file that defines what problem to solve and how. It specifies material properties, boundary conditions, problem type, solver parameters, and output settings. See the configuration documentation for complete details.\n\nPalace can solve Maxwell's equations under a few different set of assumptions, leading to different electromagnetic problem types:\n\nElectrostatic: Computes static electric fields and capacitance matrices (used in this tutorial)\nMagnetostatic: Computes static magnetic fields and inductance matrices\nEigenmode: Computes eigenmodes and eigenvalues in the frequency domain\nDriven: Computes frequency-domain response to harmonic excitations\nTransient: Computes time-domain response to boundary excitations\n\nPalace produces two types of primary output:\n\nCSV files with post-processed quantities (capacitance matrices, field values at probe points, etc.)\nPVD files for visualizing fields with ParaView or compatible software\nGrid function files for visualizing fields with GLVis\n\nThe full list of problem types and their outputs is available in the problem configuration guide.\n\nIn this tutorial, we'll use a mesh generated with Gmsh, create a configuration file for an Electrostatic problem, and visualize the resulting electric field with ParaView and GLVis.","category":"section"},{"location":"quick/#Installing-Palace","page":"Quick Start","title":"Installing Palace","text":"As a user, the simplest way to install Palace is with Spack, a package manager designed for high-performance computing applications.\n\nFollow the instructions on the official website to install Spack. This involves cloning a repository and sourcing a setup-env shell script. Ensure this shell environment comes with the minimal requirements as listed in the official documentation. Come back here once you are done with that.\n\nLet's check that Spack is correctly installed on your system. This can be accomplished by running:\n\nspack --version\n\nYou should see your Spack version (yours may differ, that's okay):\n\nlogrun(`spack --version`); # hide\nnothing # hide\n\nnote: spack command not found\nIf you get a command not found error, revisit the Spack instructions and ensure you've completed all steps, including sourcing the setup script (the command starting with .). Consider adding this to your shell initialization file (typically, .bashrc or .zshrc).\n\nWith Spack installed, we can now move to Palace:\n\nspack install palace\n\nThis will download and compile the latest release of Palace and its dependencies. This step may take tens of minutes depending on your system.\n\nOnce installed, load Palace and verify it works:\n\nspack load palace\npalace --help\n\nYou should see:\n\nlogrun(`palace --help`); # hide\nnothing # hide\n\ntip: Loading Palace\nYou need to load Palace with spack load palace in each new shell session. For convenience, add this command to your shell initialization file if you are a frequent Palace user.","category":"section"},{"location":"quick/#(Optional)-Install-ParaView-and-GLVis","page":"Quick Start","title":"(Optional) Install ParaView and GLVis","text":"Palace optionally saves electromagnetic field data in the PVD format, which is immediately accessible by ParaView or ParaView-compatible software, and as MFEM grid functions, which can be visualized with GLVis. You can download ParaView from the official website or using your package manager (dnf, apt, brew, ...). GLVis can be downloaded from the official website. ParaView and GLVis are not required for running simulations, but we will use it in this tutorial to visualize our simulated fields.","category":"section"},{"location":"quick/#The-mesh","page":"Quick Start","title":"The mesh","text":"The mesh describes the geometry over which we want to solve the problem. Constructing a mesh is not Palace's responsibility and we'll use a pre-made mesh from the Palace examples for this tutorial.\n\nCreate a mesh directory and download the mesh file:\n\nmkdir -p mesh\ncurl -o mesh/spheres.msh https://raw.githubusercontent.com/awslabs/palace/refs/heads/main/examples/spheres/mesh/spheres.msh\n\nThis mesh was created using the Julia interface for Gmsh. If you're interested in how it was created, see the mesh.jl file.","category":"section"},{"location":"quick/#Understanding-mesh-attributes","page":"Quick Start","title":"Understanding mesh attributes","text":"To set up a simulation, you need to identify regions in the mesh (collections of volumes or surfaces) to assign material properties and boundary conditions. The mesh formats used within Palace all support this via a notion of Attributes. An attribute is a 1-based index within a mesh that indicates a subset of elements. The particulars of how these attributes are identified are specific to each mesh format.\n\nOur mesh follows the msh2 format and contains four distinct regions:\n\ndomain (3D volume, attribute: 1) - the vacuum region between spheres\nfarfield (2D surface, attribute: 2) - the outer boundary surface\nsphere_a (2D surface, attribute: 3) - the first conductor surface\nsphere_b (2D surface, attribute: 4) - the second conductor surface\n\nWe'll reference these attributes in our configuration file to specify boundary conditions and material properties.","category":"section"},{"location":"quick/#The-config-file","page":"Quick Start","title":"The config file","text":"The configuration file defines the electromagnetic problem: what to solve for, material properties and boundary conditions, the details of the algorithm to be employed, and so on.\n\nPalace config files contain five sections:\n\nProblem: Defines the physics type and output settings\nModel: Specifies the mesh file and geometric parameters\nDomains: Defines material properties for 3D regions and related postprocessing operations\nBoundaries: Sets boundary conditions for 2D surfaces and related postprocessing operations\nSolver: Controls numerical parameters and solution methods\n\nHere's a complete configuration for our electrostatic problem:\n\n<div style=\"max-height: 300px; overflow-y: auto;\">\n\nprintln(fix_attributes_format(JSON.json(spheres_json, 4))) # hide\n\n</div>\n\nYou can save this as spheres.json or download it directly:\n\ncurl -O https://raw.githubusercontent.com/awslabs/palace/refs/heads/main/examples/spheres/spheres.json\n\nLet's examine each section in detail. For complete documentation on all available options, see the configuration reference.\n\nIf you wish to skip the explanation and jump directly to running your simulations, go to Running the simulation and inspecting the output.","category":"section"},{"location":"quick/#Section-1:-Problem-definition","page":"Quick Start","title":"Section 1: Problem definition","text":"The Problem section identifies the problem type and the output directory. In this case, we choose Electrostatic. This means that Palace solves Poisson's equation for electric potential sequentially activating all the Terminals on the mesh while setting the non-activated terminals to ground. All simulation types in Palace have some form of iteration (over frequencies, times, mode numbers, or terminals). The output is saved to the \"Output\" folder specified in the \"Problem\" section in the JSON file, postpro in this example. If the output already exists, it will be overwritten. See config[\"Problem\"] for details on all available problem types and their outputs.\n\nprint_section(spheres_json, \"Problem\") # hide","category":"section"},{"location":"quick/#Section-2:-Model-specification","page":"Quick Start","title":"Section 2: Model specification","text":"The Model section specifies the desired geometry. In addition to defining the mesh, it specifies how to convert mesh units to physical units using the L0 parameter. For example, L0 of 1e-2 means that one mesh unit corresponds to one centimeter. The Model section can also include settings for adaptive mesh refinement. See config[\"Model\"] for more information.\n\nprint_section(spheres_json, \"Model\") # hide","category":"section"},{"location":"quick/#Section-3:-Domain-properties","page":"Quick Start","title":"Section 3: Domain properties","text":"The Domains section defines properties for the 3D regions in the geometry.\n\nEach 3D region (identified by its Attribute) must have a Material definition specifying its physical properties. In our mesh, we have just one 3D region (the vacuum between the spheres and outer boundary) identified by attribute 1. While vacuum properties are applied by default, you can specify various material characteristics as detailed in config[\"Domains\"][\"Materials\"].\n\nThe Domains section also includes a Postprocessing subsection for calculating specific quantities. In this example, we add:\n\nEnergy, which activates integrated energy calculations in the 3D domain\nProbe, which requests field values at specific coordinates defined by a Center (in mesh units)\n\nWhen configuring Postprocessing, you must specify an Index that determines the suffix for column headers in the output CSV files. For example, with Index: 1, the probe output will show headers like E_x[1].\n\nnote: What is the difference between `Attributes` and `Index`?\nAttributes identify mesh regions and come from the mesh file. In our example, attributes 1-4 identify the vacuum region, outer boundary, and two spheres.Index is used only for postprocessing and defines a notation used in the output CSV files. It has no relation to mesh attributes and can be any positive integer.Note how Attributes is an array and Index an integer: multiple attributes might be needed to specify a given region in the mesh that corresponds to a single output.\n\nprint_section(spheres_json, \"Domains\") # hide","category":"section"},{"location":"quick/#Section-4:-Boundary-conditions","page":"Quick Start","title":"Section 4: Boundary conditions","text":"The Boundaries section maps 2D surfaces in your mesh to their physical boundary conditions. Palace offers numerous boundary condition types, all documented in config[\"Boundaries\"].\n\nUnlike 3D regions, which all require Material specifications, 2D surfaces have default behavior: any external surface without an explicit boundary condition is treated as a Perfect Magnetic Conductor (PMC), where the tangential component of the magnetic field is zero, and no conditions are imposed on internal surfaces (since terms from either sides cancel out on such boundaries).\n\nFor our electrostatic problem, we define:\n\nThe outer boundary as Ground (zero potential)\nTwo Terminal surfaces (one for each sphere)\n\nTerminals are particularly important for Electrostatic simulations. Palace activates each terminal sequentially (applying a unit of potential and grounding all the other ones) and solves Maxwell's equations. Each of these steps adds a new row to the output CSV files.\n\nLike the Domains section, Boundaries also includes a Postprocessing subsection for calculating quantities such as surface fluxes across 2D regions. Here, we compute the fluxes of electric fields across the spherical conductors. See config[\"Boundaries\"] for all available postprocessing options.\n\nprint_section(spheres_json, \"Boundaries\") # hide","category":"section"},{"location":"quick/#Section-5:-Solver-settings","page":"Quick Start","title":"Section 5: Solver settings","text":"Finally, the Solver section prescribes properties of the problem and the numerical algorithm, what device to use for the solution, and how much to save as PVD files. For this problem, we run on CPU, specify third-order finite elements, and save the fields for both terminal activations. The details of the linear solver parameters in \"Linear\" are not essential for this tutorial.\n\nOther problem types typically have more extensive Solver configurations, including excitation parameters and frequency sweep settings. For complete details on all solver options, see config[\"Solver\"].\n\nprint_section(spheres_json, \"Solver\") # hide","category":"section"},{"location":"quick/#Running-the-simulation-and-inspecting-the-output","page":"Quick Start","title":"Running the simulation and inspecting the output","text":"If you've followed along, you should now have two files:\n\n├── mesh\n│   └── spheres.msh\n└── spheres.json\n\nnote: Do not have the files?\nIf you need to download the files, run:mkdir -p mesh\ncurl -o mesh/spheres.msh https://raw.githubusercontent.com/awslabs/palace/refs/heads/main/examples/spheres/mesh/spheres.msh\ncurl -O https://raw.githubusercontent.com/awslabs/palace/refs/heads/main/examples/spheres/spheres.json\n\nBefore running your simulation, it's a good idea to validate the configuration:\n\npalace --dry-run spheres.json\n\nThis checks for syntax errors and basic configuration issues. The validator should return:\n\nlogrun(`palace --dry-run spheres.json`); # hide\nnothing # hide\n\nFinally, we are ready to run the simulation:\n\npalace -np 1 spheres.json\n\n-np 1 instruct Palace to run with a single MPI process.\n\nYou'll see output including mesh details, solver progress, and timing information. The amount of information can be controlled with the Verbose configuration option in the JSON file.\n\n<div style=\"max-height: 300px; overflow-y: auto;\">\n\nlogrun(`palace -np 1 spheres.json`); # hide\nnothing # hide\n\n</div>\n\nNotice that Palace ran two iterations, one for each Terminal. Different problem types will have different iteration patterns (e.g., Driven iterating over frequencies or Transient over time steps) and many of the output CSV files are organized along these iterations.","category":"section"},{"location":"quick/#Understanding-the-output","page":"Quick Start","title":"Understanding the output","text":"Once the simulation is completed, you'll find a postpro directory containing:\n\nlogrun(`ls -R postpro`); # hide\nnothing # hide\n\nIn addition to the palace.json, which contains metadata about the simulation (including timing information and counts), the output consists of CSV, PVD, and grid function files. You can safely ignore all the Cycle directories as their content is accessed through the corresponding PVD file. For more details on output files and formats, see the output documentation.","category":"section"},{"location":"quick/#CSV-files","page":"Quick Start","title":"CSV files","text":"CSV files contain post-processed quantities and depend on the specific problem type chosen. Let's look at two examples:\n\nprobe-E.csv shows electric field values at the probe point we defined in the Postprocessing section in \"Domains\":\n\nlogrun(`cat postpro/probe-E.csv`); # hide\nnothing # hide\n\nThe first column i indicates the iteration and corresponds to the Index associated to each Terminal, whereas the [1] in column headers corresponds to the Index we specified in the Probe section.\n\nOne of the key outputs of the Electrostatics problem type is the capacitance matrix, saved in terminal-C.csv:\n\nlogrun(`cat postpro/terminal-C.csv`); # hide\nnothing # hide\n\nHere, both rows and columns correspond to Terminal indices. As expected, the matrix is symmetric.","category":"section"},{"location":"quick/#Visualizing-with-ParaView","page":"Quick Start","title":"Visualizing with ParaView","text":"In this step, we'll create a visualization of our simulation results using ParaView. We'll work with both the volume field data (electrostatic.pvd) and the boundary surface data (electrostatic_boundaries.pvd) to reproduce the figures in the example page.\n\nLaunch ParaView and navigate to your postpro/paraview directory\nOpen the volume data:\nClick File → Open → Navigate to postpro/paraview/electrostatic/electrostatic.pvd, nothing should be rendered so far\nClick the Apply button in the Properties panel (left side), a sphere should appear\nIn the Coloring section, select V, the sphere should now be colored according to the potential values\nCreate a slice to see inside:\nFrom the menu bar, select Filters → Common → Slice\nIn the Properties panel (left side), set the Origin to (0, 0, 0)\nSet the Normal to (0, 1, 0) for a vertical slice along the Y-axis\nClick Apply\nUse the mouse to rotate and zoom until you can see the outlines of both inner spheres\nAdd the boundary surfaces:\nClick File → Open → Navigate to postpro/paraview/electrostatic_boundaries/electrostatic_boundaries.pvd\nClick Apply in the Properties panel\nIn the Coloring section, select V\nThe two inner spheres should now appear with their surface potentials displayed\n\nNotice the time slider at the top of the ParaView window:\n\nFrame 0: First terminal activated (first sphere at unit potential)\nFrame 1: Second terminal activated (second sphere at unit potential)\nFrame 99: Error estimates\n\nYou can save the visualization as an image with File → Save Screenshot, or save the entire ParaView state with File → Save State (allows reopening your complete setup later). The result should look more or less like the images below:\n\n<br/><p align=\"center\">\n  <img src=\"../assets/examples/spheres-3.png\" width=\"45%\" />\n  <img src=\"../assets/examples/spheres-4.png\" width=\"45%\" />\n</p>\n\nParaView offers many more advanced features for data analysis and visualization. For more details, refer to the official ParaView documentation.","category":"section"},{"location":"quick/#Visualizing-with-GLVis","page":"Quick Start","title":"Visualizing with GLVis","text":"In this optional step, we'll create a visualization of our simulation results using GLVis.\n\nThe potential field V with the first terminal activated can be visualized with\n\nglvis -m postpro/gridfunction/electrostatic/mesh -g postpro/gridfunction/electrostatic/V_000001.gf -np 1\n\nNote that -np 1 instructs GLVis that the data was generated with a single MPI process. The number must match the number of MPI processes used in Palace.\n\nTo visualize the potential field along the middle x-z plane:\n\nPress c to display the colorbar.\nPress a to display the axes.\nPress i to cut the domain.\nPress y or Y repeatedly to rotate the cutting plane until it is aligned with the x-z plane.\nPress R to cycle through 2D projections until you are viewing the x-z plane.\nPress S to take a screenshot.\n\nThe result should look more or less like what we have below, where we embed a Javascript version of GLVis (GLVis-js) that can be interacted with in almost the same way as the native GLVis. See Documentation for full list of keys.\n\n<div id=\"glvis-container\" style=\"width: 100%; height: 500px;\">\n  <div id=\"glvis-div\" style=\"width: 100%; height: 100%;\"></div>\n</div>\n\n<!-- Note, the snippet below only works with one MPI process because we are\n    manually composing a stream file. -->\n<script type=\"text/javascript\">\n  var div = document.getElementById(\"glvis-div\");\n  require([\"../assets/js/glvis/index.js\"], function (glvis) {\n    var glv = new glvis.State(div);\n\n    Promise.all([\n      fetch('../postpro/gridfunction/electrostatic/mesh.000000').then(r => r.text()),\n      fetch('../postpro/gridfunction/electrostatic/V_000001.gf.000000').then(r => r.text())\n    ]).then(function(results) {\n      var stream = \"solution\\n\" + results[0] + results[1] + \"keys OOOOOOOOOyyyyyyyyyyyyyyyyyyRRRRcai\\n\";\n      var originalTitle = document.title;\n      glv.display(stream).then(function() {\n        document.title = originalTitle;\n        // Enable keyboard controls on click\n        div.addEventListener('click', function() {\n          this.setAttribute('tabindex', '0');\n          this.focus();\n        }, { once: true });\n      });\n    }).catch(function(e) {\n      console.error('Failed to load GLVis data:', e);\n    });\n  });\n</script>","category":"section"},{"location":"quick/#Where-to-go-next","page":"Quick Start","title":"Where to go next","text":"Congratulations! You've completed your first Palace simulation. To continue learning:\n\nTry looking at the other output files in this simulation\nTry modifying this example with different materials or boundary conditions\nExplore the examples to see different problem types and more complex geometries\nRead the configuration reference to understand all available options\n\nIf you encounter any issues or have questions, please report them to our GitHub issue tracker.","category":"section"},{"location":"config/boundaries/","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"config/boundaries/#config[\"Boundaries\"]","page":"config[\"Boundaries\"]","title":"config[\"Boundaries\"]","text":"\"Boundaries\":\n{\n    \"PEC\":\n    {\n        ...\n    },\n    \"PMC\":\n    {\n        ...\n    },\n    \"Impedance\":\n    [\n        ...\n    ],\n    \"Absorbing\":\n    {\n        ...\n    },\n    \"Conductivity\":\n    [\n        ...\n    ],\n    \"LumpedPort\":\n    [\n        ...\n    ],\n    \"WavePort\":\n    [\n        ...\n    ],\n    \"WavePortPEC\":\n    {\n        ...\n    },\n    \"SurfaceCurrent\":\n    [\n        ...\n    ],\n    \"Ground\":\n    {\n        ...\n    },\n    \"ZeroCharge\":\n    {\n        ...\n    },\n    \"Terminal\":\n    [\n        ...\n    ],\n    \"Periodic\":\n    {\n        ...\n    },\n    \"Postprocessing\":\n    {\n        \"SurfaceFlux\":\n        [\n            ...\n        ],\n        \"Dielectric\":\n        [\n            ...\n        ]\n        \"FarField\":\n        {\n            ...\n        }\n    }\n}\n\nwith\n\n\"PEC\" :  Top-level object for configuring perfect electric conductor (PEC) boundary conditions (zero tangential electric field).\n\n\"PMC\" :  Top-level object for configuring perfect magnetic conductor (PMC) boundary conditions (zero tangential magnetic field). Also imposes symmetry of the electric field across the boundary surface.\n\n\"Impedance\" :  Array of objects for configuring surface impedance boundary conditions. A surface impedance boundary relates the tangential electric and magnetic fields on the boundary using a user specified surface impedance.\n\n\"Absorbing\" : Top-level object for configuring absorbing boundary conditions. These are artificial scattering boundary conditions at farfield boundaries.\n\n\"Conductivity\" :  Array of objects for configuring finite conductivity surface impedance boundary conditions. Finite conductivity boundaries are only available for frequency domain driven and eigenmode simulation types.\n\n\"LumpedPort\" :  Array of objects for configuring lumped port boundary conditions. Lumped ports can be specified on boundaries which are internal to the computational domain.\n\n\"WavePort\" :  Array of objects for configuring numeric wave port boundary conditions. Wave ports can only be specified on boundaries which are on the true boundary of the computational domain. Additionally, wave port boundaries are only available for frequency domain driven and eigenmode simulation types.\n\n\"WavePortPEC\" :  Top-level object for configuring additional PEC boundary conditions for boundary mode analysis performed on the wave port boundaries. Thus, this object is only relevant when wave port boundaries are specified under config[\"Boundaries\"][\"WavePort\"].\n\n\"SurfaceCurrent\" :  Array of objects for configuring surface current boundary conditions. This boundary prescribes a unit source surface current excitation on the given boundary in order to excite a frequency or time domain driven simulation or magnetostatic simulation. For the magnetostatic simulation type, entries of the inductance matrix are extracted corresponding to each surface current boundary.\n\n\"Ground\" :  Top-level object for specifying ground, or zero voltage, boundary conditions for for electrostatic simulations.\n\n\"ZeroCharge\" :  Top-level object for specifying zero charge boundary conditions for for electrostatic simulations. Also imposes symmetry of the electric field across the boundary surface.\n\n\"Terminal\" :  Array of objects for configuring terminal boundary conditions for electrostatic simulations. Entries of the capacitance matrix are extracted corresponding to each terminal boundary.\n\n\"Periodic\" :  Top-level object for configuring periodic boundary conditions for surfaces with meshes that are identical after translation and/or rotation.\n\n\"Postprocessing\" :  Top-level object for configuring boundary postprocessing.\n\n\"SurfaceFlux\" :  Array of objects for postprocessing surface flux.\n\n\"Dielectric\" :  Array of objects for postprocessing surface interface dielectric loss.\n\n\"FarField\" :  Top-level object for extracting electric fields in the far-field region.","category":"section"},{"location":"config/boundaries/#boundaries[\"PEC\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"PEC\"]","text":"\"PEC\":\n{\n    \"Attributes\": [<int array>]\n}\n\nwith\n\n\"Attributes\" [None] :  Integer array of mesh boundary attributes at which to apply the PEC boundary condition.","category":"section"},{"location":"config/boundaries/#boundaries[\"PMC\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"PMC\"]","text":"\"PMC\":\n{\n    \"Attributes\": [<int array>]\n}\n\nwith\n\n\"Attributes\" [None] :  Integer array of mesh boundary attributes at which to apply the PMC boundary condition.","category":"section"},{"location":"config/boundaries/#boundaries[\"Impedance\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Impedance\"]","text":"\"Impedance\":\n[\n    {\n        \"Attributes\": [<int array>],\n        \"Rs\": <float>,\n        \"Ls\": <float>,\n        \"Cs\": <float>\n    },\n    ...\n]\n\nwith\n\n\"Attributes\" [None] :  Integer array of mesh boundary attributes for this surface impedance boundary.\n\n\"Rs\" [0.0] :  Surface resistance used for computing this surface impedance boundary's impedance per square, Omega/sq.\n\n\"Ls\" [0.0] :  Surface inductance used for computing this surface impedance boundary's impedance per square, H/sq.\n\n\"Cs\" [0.0] :  Surface capacitance used computing this surface impedance boundary's impedance per square, F/sq.","category":"section"},{"location":"config/boundaries/#boundaries[\"Absorbing\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Absorbing\"]","text":"\"Absorbing\":\n{\n    \"Attributes\": [<int array>],\n    \"Order\": <int>\n}\n\nwith\n\n\"Attributes\" [None] :  Integer array of mesh boundary attributes at which to apply farfield absorbing boundary conditions.\n\n\"Order\" [1] :  Specify a first- or second-order approximation for the farfield absorbing boundary condition. Second-order absorbing boundary conditions are only available for the frequency domain driven simulation type.","category":"section"},{"location":"config/boundaries/#boundaries[\"Conductivity\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Conductivity\"]","text":"\"Conductivity\":\n[\n    {\n        \"Attributes\": [<int array>],\n        \"Conductivity\": <float>,\n        \"Permeability\": <float>,\n        \"Thickness\": <float>\n    },\n    ...\n]\n\nwith\n\n\"Attributes\" [None] :  Integer array of mesh boundary attributes for this finite conductivity boundary.\n\n\"Conductivity\" [None] :  Electrical conductivity for this finite conductivity boundary, S/m.\n\n\"Permeability\" [1.0] :  Relative permeability for this finite conductivity boundary.\n\n\"Thickness\" [None] :  Optional conductor thickness for this finite conductivity boundary specified in mesh length units. Activates a finite conductivity boundary condition which accounts for nonzero metal thickness.","category":"section"},{"location":"config/boundaries/#boundaries[\"LumpedPort\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"LumpedPort\"]","text":"\"LumpedPort\":\n[\n    {\n        \"Index\": <int>,\n        \"Attributes\": [<int array>],\n        \"Direction\": <string> or [<float array>],\n        \"CoordinateSystem\": <string>,\n        \"Excitation\": <bool>,\n        \"Active\": <bool>,\n        \"R\": <float>,\n        \"L\": <float>,\n        \"C\": <float>,\n        \"Rs\": <float>,\n        \"Ls\": <float>,\n        \"Cs\": <float>,\n        \"Elements\":\n        [\n            {\n                \"Attributes\": [<int array>],\n                \"Direction\": <string> or [<float array>],\n                \"CoordinateSystem\": <string>\n            },\n            ...\n        ]\n    },\n    ...\n]\n\nwith\n\n\"Index\" [None] :  Index of this lumped port, used in postprocessing output files.\n\n\"Attributes\" [None] :  Integer array of mesh boundary attributes for this lumped port boundary. If this port is to be a multielement lumped port with more than a single lumped element, use the \"Elements\" array described below.\n\n\"Direction\" [None] :  Direction to define the polarization direction of the port field mode on this lumped port boundary. Axis aligned lumped ports can be specified using keywords: \"+X\", \"-X\", \"+Y\", \"-Y\", \"+Z\", \"-Z\", while coaxial lumped ports can be specified using \"+R\", \"-R\". The direction can alternatively be specified as a normalized array of three values, for example [0.0, 1.0, 0.0]. If a vector direction is specified, the \"CoordinateSystem\" value specifies the coordinate system it is expressed in. If this port is to be a multielement lumped port with more than a single lumped element, use the \"Elements\" array described below.\n\n\"CoordinateSystem\" [\"Cartesian\"] : Coordinate system used to express the \"Direction\" vector, the options are \"Cartesian\" and \"Cylindrical\". If a keyword argument is used for \"Direction\" this value is ignored, and the appropriate coordinate system is used instead.\n\n\"Excitation\" [false/0] :  Turns on or off port excitation for this lumped port boundary for driven or transient simulation types. Can be specified either as a bool or as a non-negative integer — see Boundary Conditions.\n\n\"Active\" [true] :  Turns on or off damping boundary condition for this lumped port boundary for driven or transient simulation types.\n\n\"R\" [0.0] :  Circuit resistance used for computing this lumped port boundary's impedance, Omega. This option should only be used along with the corresponding \"L\" and \"C\" parameters, and not with any of the surface parameters \"Rs\", \"Ls\", or \"Cs\".\n\n\"L\" [0.0] :  Circuit inductance used for computing this lumped port boundary's impedance, H. This option should only be used along with the corresponding \"R\" and \"C\" parameters, and not with any of the surface parameters \"Rs\", \"Ls\", or \"Cs\".\n\n\"C\" [0.0] :  Circuit capacitance used for computing this lumped port boundary's impedance, F. This option should only be used along with the corresponding \"R\" and \"L\" parameters, and not with any of the surface parameters \"Rs\", \"Ls\", or \"Cs\".\n\n\"Rs\" [0.0] :  Surface resistance used for computing this lumped port boundary's impedance, Omega/sq. This option should only be used along with the corresponding \"Ls\" and \"Cs\" parameters, and not with any of the circuit parameters \"R\", \"L\", or \"C\".\n\n\"Ls\" [0.0] :  Surface inductance used for computing this lumped port boundary's impedance, H/sq. This option should only be used along with the corresponding \"Rs\" and \"Cs\" parameters, and not with any of the circuit parameters \"R\", \"L\", or \"C\".\n\n\"Cs\" [0.0] :  Surface capacitance used for computing this lumped port boundary's impedance, F/sq. This option should only be used along with the corresponding \"Rs\" and \"Ls\" parameters, and not with any of the circuit parameters \"R\", \"L\", or \"C\".\n\n\"Elements\"[][\"Attributes\"] [None] :  This option is for multielement lumped ports and should not be combined with the \"Attributes\" field described above. Each element of a multielement lumped port can be described by its own unique integer array of mesh boundary attributes, which are specified here. The elements of a multielement port add in parallel.\n\n\"Elements\"[][\"Direction\"] [None] :  This option is for multielement lumped ports and should not be combined with the \"Direction\" field described above. Each element of a multielement lumped port can be described by its own unique direction, which is specified here. The elements of a multielement port add in parallel.\n\n\"Elements\"[][\"CoordinateSystem\"] [\"Cartesian\"] :  This option is for multielement lumped ports and should not be combined with the \"CoordinateSystem\" field described above. Each element of a multielement lumped port can be described by its own unique direction, and corresponding coordinate system.","category":"section"},{"location":"config/boundaries/#boundaries[\"WavePort\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"WavePort\"]","text":"\"WavePort\":\n[\n    {\n        \"Index\": <int>,\n        \"Attributes\": [<int array>],\n        \"Excitation\": <bool>,\n        \"Active\": <bool>,\n        \"Mode\": <int>,\n        \"Offset\": <float>,\n        \"SolverType\": <string>,\n        \"MaxIts\": <int>,\n        \"KSPTol\": <float>,\n        \"EigenTol\": <float>,\n        \"Verbose\": <int>\n    },\n    ...\n]\n\nwith\n\n\"Index\" [None] :  Index of this wave port boundary, used in postprocessing output files.\n\n\"Attributes\" [None] :  Integer array of mesh boundary attributes for this wave port boundary.\n\n\"Excitation\" [false/0] :  Turns on or off port excitation for this wave port boundary for driven simulation types. Can be specified either as a bool or as a non-negative integer — see Boundary Conditions.\n\n\"Active\" [true] :  Turns on or off damping boundary condition for this wave port boundary for driven simulation types.\n\n\"Mode\" [1] :  Mode index (1-based) for the characteristic port mode of this wave port boundary. Ranked in order of decreasing wave number.\n\n\"Offset\" [0.0] :  Offset distance used for scattering parameter de-embedding for this wave port boundary, specified in mesh length units.\n\n\"SolverType\" [\"Default\"] :  Specifies the eigenvalue solver to be used in computing the boundary mode for this wave port. See config[\"Solver\"][\"Eigenmode\"][\"Type\"].\n\n\"MaxIts\" [30] :  Specifies the maximum number of iterations to be used in the GMRES solver.\n\n\"KSPTol\" [1e-8] :  Specifies the tolerance to be used in the linear solver.\n\n\"EigenTol\" [1e-6] :  Specifies the tolerance to be used in the eigenvalue solver.\n\n\"Verbose\" [0] :  Specifies the verbosity level to be used in the linear and eigensolver for the wave port problem.","category":"section"},{"location":"config/boundaries/#boundaries[\"WavePortPEC\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"WavePortPEC\"]","text":"\"WavePortPEC\":\n{\n    \"Attributes\": [<int array>]\n}\n\nwith\n\n\"Attributes\" [None] :  Integer array of mesh boundary attributes to consider as PEC when solving the 2D eigenproblem for the wave port boundary mode analysis, along with those specified under config[\"Boundaries\"][\"PEC\"][\"Attributes\"] and config[\"Boundaries\"][\"Conductivity\"][\"Attributes\"].","category":"section"},{"location":"config/boundaries/#boundaries[\"SurfaceCurrent\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"SurfaceCurrent\"]","text":"\"SurfaceCurrent\":\n[\n    {\n        \"Index\": <int>,\n        \"Attributes\": [<int array>],\n        \"Direction\": <string> or [<float array>],\n        \"CoordinateSystem\": <string>,\n        \"Elements\":\n        [\n            {\n                \"Attributes\": [<int array>],\n                \"Direction\": <string> or [<float array>],\n                \"CoordinateSystem\": <string>,\n            },\n            ...\n        ]\n    },\n    ...\n]\n\nwith\n\n\"Index\" [None] :  Index of this surface current boundary, used in postprocessing output files.\n\n\"Attributes\" [None] :  Integer array of mesh boundary attributes for this surface current boundary. If this source is to be a multielement source which distributes the source across more than a single lumped element, use the \"Elements\" array described below.\n\n\"Direction\" [None] :  Defines the source current direction for this surface current boundary. The available options are the same as under config[\"Boundaries\"][\"LumpedPort\"][\"Direction\"]. If this source is to be a multielement source which distributes the source across more than a single lumped element, use the \"Elements\" array described below.\n\n\"CoordinateSystem\" [\"Cartesian\"] :  Defines the coordinate system for the source current direction for this surface current boundary. The available options are the same as under config[\"Boundaries\"][\"LumpedPort\"][\"CoordinateSystem\"]. If this source is to be a multielement source which distributes the source across more than a single lumped element, use the \"Elements\" array described below.\n\n\"Elements\"[][\"Attributes\"] [None] :  This option is for multielement surface current boundaries should not be combined with the \"Attributes\" field described above. Each element of a multielement current source can be described by its own unique integer array of mesh boundary attributes, which are specified here. The elements of a multielement source add in parallel to give the same total current as a single-element source.\n\n\"Elements\"[][\"Direction\"] [None] :  This option is for multielement surface current boundaries and should not be combined with the \"Direction\" field described above. Each element of a multielement current source can be described by its own unique direction, which is specified here. The elements of a multielement source add in parallel to give the same total current as a single-element source.\n\n\"Elements\"[][\"CoordinateSystem\"] [\"Cartesian\"] :  This option is for multielement surface current boundaries and should not be combined with the \"CoordinateSystem\" field described above. Each element of a multielement current source can be described by its own unique direction, and corresponding coordinate system.","category":"section"},{"location":"config/boundaries/#boundaries[\"Ground\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Ground\"]","text":"\"Ground\":\n{\n    \"Attributes\": [<int array>]\n}\n\nwith\n\n\"Attributes\" [None] :  Integer array of mesh boundary attributes at which to apply the ground boundary condition.","category":"section"},{"location":"config/boundaries/#boundaries[\"ZeroCharge\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"ZeroCharge\"]","text":"\"ZeroCharge\":\n{\n    \"Attributes\": [<int array>]\n}\n\nwith\n\n\"Attributes\" [None] :  Integer array of mesh boundary attributes at which to apply the zero-charge boundary condition.","category":"section"},{"location":"config/boundaries/#boundaries[\"Terminal\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Terminal\"]","text":"\"Terminal\":\n[\n    {\n        \"Index\": <int>,\n        \"Attributes\": [<int array>],\n    },\n    ...\n]\n\nwith\n\n\"Index\" [None] :  Index of this terminal boundary, used in postprocessing output files and to index the computed capacitance matrix.\n\n\"Attributes\" [None] :  Integer array of mesh boundary attributes for this terminal boundary.","category":"section"},{"location":"config/boundaries/#boundaries[\"Periodic\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Periodic\"]","text":"\"Periodic\":\n{\n    \"FloquetWaveVector\": [<float array>],\n    \"BoundaryPairs\":\n    [\n        {\n            \"DonorAttributes\": [<int array>],\n            \"ReceiverAttributes\": [<int array>],\n            \"Translation\": [<float array>],\n            \"AffineTransformation\": [<float array>],\n        },\n        ...\n    ]\n}\n\nwith\n\n\"DonorAttributes\" [None] :  Integer array of the donor attributes of the mesh boundary attributes for this periodic boundary.\n\n\"ReceiverAttributes\" [None] :  Integer array of the receiver attributes of the mesh boundary attributes for this periodic boundary.\n\n\"Translation\" [None] :  Optional floating point array defining the distance from the donor attribute to the receiver attribute in mesh units. If neither \"Translation\" nor \"AffineTransformation\" are specified, the transformation between donor and receiver boundaries is automatically detected.\n\n\"AffineTransformation\" [None] :  Optional floating point array of size 16 defining the three-dimensional (4 x 4) affine transformation matrix (in row major format) from the donor attribute to the receiver attribute in mesh units. If neither \"Translation\" or \"AffineTransformation\" are specified, the transformation between donor and receiver boundaries is automatically detected.\n\n\"FloquetWaveVector\" [None] :  Optional floating point array defining the phase delay between the periodic boundaries in the X/Y/Z directions in radians per mesh unit.","category":"section"},{"location":"config/boundaries/#boundaries[\"Postprocessing\"][\"SurfaceFlux\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Postprocessing\"][\"SurfaceFlux\"]","text":"\"Postprocessing\":\n{\n    \"SurfaceFlux\":\n    [\n        {\n            \"Index\": <int>,\n            \"Attributes\": [<int array>],\n            \"Type\": <string>,\n            \"TwoSided\": <bool>,\n            \"Center\": [<float array>]\n        },\n        ...\n    ]\n}\n\nwith\n\n\"Index\" [None] :  Index of this surface flux postprocessing boundary, used in postprocessing output files.\n\n\"Attributes\" [None] :  Integer array of mesh boundary attributes for this surface flux postprocessing boundary.\n\n\"Type\" [None] :  Specifies the type of surface flux to calculate for this postprocessing boundary. The available options are:\n\n\"Electric\" :  Integrate the electric flux density over the boundary surface.\n\"Magnetic\" :  Integrate the magnetic flux density over the boundary surface.\n\"Power\" :  Integrate the energy flux density, given by the Poynting vector, over the boundary surface.\n\n\"TwoSided\" [false] :  Specifies how to account for internal boundary surfaces with a possible discontinuous field on either side. When set to false, the flux on either side of an internal boundary surface is averaged. When true, it is summed with an opposite normal direction.\n\n\"Center\" [None] :  Floating point array of length equal to the model spatial dimension specifying the coordinates of a central point used to compute the outward flux. The true surface normal is used in the calculation, and this point is only used to ensure the correct orientation of the normal. Specified in mesh length units, and only relevant when \"TwoSided\" is false. If not specified, the point will be computed as the centroid of the axis-aligned bounding box for all elements making up the postprocessing boundary.","category":"section"},{"location":"config/boundaries/#boundaries[\"Postprocessing\"][\"Dielectric\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Postprocessing\"][\"Dielectric\"]","text":"\"Postprocessing\":\n{\n    \"Dielectric\":\n    [\n        {\n            \"Index\": <int>,\n            \"Attributes\": [<int array>],\n            \"Type\": <string>,\n            \"Thickness\": <float>,\n            \"Permittivity\": <float>,\n            \"LossTan\": <float>\n        },\n        ...\n    ]\n}\n\nwith\n\n\"Index\" [None] :  Index of this dielectric interface, used in postprocessing output files.\n\n\"Attributes\" [None] :  Integer array of mesh boundary attributes for this dielectric interface.\n\n\"Type\" [None] :  Specifies the type of dielectric interface for this postprocessing boundary. See also this page. Available options are:\n\n\"Default\" :  Use the full electric field evaluated at the boundary to compute the energy participation ratio (EPR) of this dielectric interface and estimate loss.\n\"MA\" :  Use the boundary conditions assuming a metal-air interface to compute the EPR of this dielectric interface.\n\"MS\" :  Use the boundary conditions assuming a metal-substrate interface to compute the EPR of this dielectric interface.\n\"SA\" :  Use the boundary conditions assuming a substrate-air interface to compute the EPR of this dielectric interface.\n\n\"Thickness\" [None] :  Thickness of this dielectric interface, specified in mesh length units.\n\n\"Permittivity\" [None] :  Relative permittivity for this dielectric interface. This should be the interface layer permittivity for the specific \"Type\" of interface specified.\n\n\"LossTan\" [0.0] :  Loss tangent for this lossy dielectric interface.","category":"section"},{"location":"config/boundaries/#boundaries[\"Postprocessing\"][\"FarField\"]","page":"config[\"Boundaries\"]","title":"boundaries[\"Postprocessing\"][\"FarField\"]","text":"\"Postprocessing\":\n{\n    \"FarField\":\n    {\n        \"Attributes\": [<int array>],\n        \"NSample\": <int>,\n        \"ThetaPhis\": [<array of pairs of floats>]\n    }\n}\n\nwith\n\n\"Attributes\" [None] : Integer array of mesh boundary attributes to be used to compute the far fields. It has to be an external boundary and enclose the system.\n\n\"NSample\" [0] : Number of uniformly-spaced points to use to discretize the far-field sphere.\n\n\"ThetaPhi\" [None] : Evaluate the far-field electric field at these specific angles too (in degrees). theta in 0 180 is the polar angle and phi in 0 360 is the azimuthal angle.","category":"section"},{"location":"guide/parallelism/","page":"Parallelism and GPU Support","title":"Parallelism and GPU Support","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"guide/parallelism/#Parallelism-and-GPU-Support","page":"Parallelism and GPU Support","title":"Parallelism and GPU Support","text":"Palace employs multiple types of parallelism in an attempt to maximize performance across a wide range of deployment possibilities. The first is MPI-based distributed-memory parallelism. This is controlled using the -np command line flag as outlined in Running Palace.\n\nShared-memory parallelism using OpenMP is also available. To enable this, the -DPALACE_WITH_OPENMP=ON option should be specified at configure time. At runtime, the number of threads is configured with the -nt argument to the palace executable, or by setting the OMP_NUM_THREADS environment variable.\n\nLastly, Palace supports GPU-acceleration using NVIDIA and AMD GPUs, activated with the build options -DPALACE_WITH_CUDA=ON and -DPALACE_WITH_HIP=ON, respectively. At runtime, the config[\"Solver\"][\"Device\"] parameter in the configuration file can be set to \"CPU\" (the default) or \"GPU\" in order to configure Palace and MFEM to use the available GPU device or devices. The config[\"Solver\"][\"Backend\"] parameter, on the other hand, controls the libCEED backend. Users typically do not need to provide a value for this option and can instead rely on Palace's default, which selects the most appropriate backend for the given value of config[\"Solver\"][\"Device\"].\n\nIn order to take full advantage of the performance benefits made available by GPU- acceleration, it is recommended to make use of operator partial assembly, activated when the value of config[\"Solver\"][\"PartialAssemblyOrder\"] is less than config[\"Solver\"][\"Order\"]. This feature avoids assembling a global sparse matrix and instead makes use of data structures for operators which lend themselves to more efficient asymptotic storage and application costs. See also https://libceed.org/en/latest/intro/ for more details. Partial assembly in Palace supports mixed meshes including both tensor product elements (hexahedra and quadrilaterals) as well as non-tensor product elements (tetrahedra, prisms, pyramids, and triangles).","category":"section"},{"location":"guide/guide/","page":"Overview","title":"Overview","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"guide/guide/#Overview","page":"Overview","title":"Overview","text":"This user guide provides an overview of the different types of electromagnetic simulations which can be performed with Palace and the various features available in the solver.","category":"section"},{"location":"guide/guide/#Contents","page":"Overview","title":"Contents","text":"Problem Types\nSimulation Models\nBoundary Conditions\nPostprocessing and Visualization\nParallelism and GPU Support","category":"section"},{"location":"","page":"Home","title":"Home","text":"<!---\nCopyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\nSPDX-License-Identifier: Apache-2.0\n--->","category":"section"},{"location":"#Palace:-3D-Finite-Element-Solver-for-Computational-Electromagnetics","page":"Home","title":"Palace: 3D Finite Element Solver for Computational Electromagnetics","text":"Palace, for PArallel LArge-scale Computational Electromagnetics, is an open-source, parallel finite element code for full-wave 3D electromagnetic simulations in the frequency or time domain, using the MFEM finite element discretization library and libCEED library for efficient exascale discretizations.","category":"section"},{"location":"#Key-features","page":"Home","title":"Key features","text":"Eigenmode calculations with optional material or radiative loss including lumped impedance boundaries. Automatic postprocessing of energy-participation ratios (EPRs) for circuit quantization and interface or bulk participation ratios for predicting dielectric loss.\nFrequency domain driven simulations with surface current excitation and lumped or numeric wave port boundaries. Wideband frequency response calculation using uniform frequency space sampling or an adaptive fast frequency sweep algorithm.\nExplicit or fully-implicit time domain solver for transient electromagnetic analysis.\nLumped capacitance and inductance matrix extraction via electrostatic and magnetostatic problem formulations.\nSupport for a wide range of mesh file formats for structured and unstructured meshes, with built-in uniform or region-based parallel mesh refinement.\nSolution-based Adaptive Mesh Refinement (AMR) for all simulation types aside from transient. Nonconformal refinement is supported for all mesh types, and conformal refinement for simplex meshes.\nArbitrary high-order finite element spaces and curvilinear mesh support thanks to the MFEM library.\nScalable algorithms for the solution of linear systems of equations, including matrix-free p-multigrid utilizing high-order operator partial assembly, parallel sparse direct solvers, and algebraic multigrid (AMG) preconditioners, for fast performance on platforms ranging from laptops to HPC systems.\nSupport for hardware acceleration using NVIDIA or AMD GPUs, including multi-GPU parallelism, using pure CUDA and HIP code as well as MAGMA and other libraries.","category":"section"},{"location":"#Contents","page":"Home","title":"Contents","text":"Installation\nExecution\nUser Guide\nConfiguration File\nExamples\nReference\nDeveloper Notes","category":"section"},{"location":"#Coming-soon","page":"Home","title":"Coming soon","text":"Improved adaptive mesh refinement (AMR) support for transient simulations\nPerfectly matched layer (PML) boundaries\nAutomatic mesh generation and optimization","category":"section"}]
}
