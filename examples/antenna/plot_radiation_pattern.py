#!/usr/bin/env python3

# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

"""
Generate antenna radiation pattern polar plots from Palace farfield data.

Usage:
    python3 plot_radiation_pattern.py farfield.csv

    or

    python3 plot_radiation_pattern.py farfield_r*.csv

Input CSV files are generated by extract_farfield.py.

Requires numpy and matplotlib.
"""

import os
import re
import sys
from typing import Optional

import matplotlib.pyplot as plt
import numpy as np


def read_farfield_csv(filename: str) -> dict[str, np.ndarray]:
    """Read farfield CSV data and return a dictionary with the various columns."""
    # Read header to get column names
    with open(filename, "r") as f:
        header = f.readline().strip()
        # Split by comma, strip whitespace, and remove units in parentheses
        columns = []
        for col in header.split(","):
            col = col.strip()
            # Remove everything in parentheses (units)
            col = re.sub(r"\s*\([^)]*\)", "", col)
            columns.append(col)

    # Load all data at once, skipping the header row
    data_array = np.loadtxt(filename, delimiter=",", skiprows=1)

    # Create dictionary mapping column names to data
    return {col: data_array[:, i] for i, col in enumerate(columns)}


def compute_field_magnitude(data: dict[str, np.ndarray]) -> np.ndarray:
    """Compute total electric field magnitude"""
    return np.sqrt(
        sum(
            (data[f"r*Re{{E_{c}}}"] ** 2 + data[f"r*Im{{E_{c}}}"] ** 2)
            for c in ["x", "y", "z"]
        )
    )


def compute_db(magnitude: np.ndarray) -> np.ndarray:
    """Convert magnitude to normalized dB scale"""
    # Floor 10 orders of magnitude below maximum
    magnitude = np.maximum(magnitude, np.max(magnitude) * 1e-10)
    # Convert to dBs
    db_values = 20 * np.log10(magnitude)
    return db_values - np.max(db_values)  # Normalize to 0 dB max


def extract_radius_from_filename(filename: str) -> Optional[float]:
    """Possibly extract radius value from filename"""
    match_ = re.search(r"_r(\d+\.?\d*)", os.path.basename(filename))
    return float(match_.group(1)) if match_ else None


def generate_theoretical_dipole() -> (
    tuple[np.ndarray, np.ndarray, np.ndarray, np.ndarray]
):
    """Generate theoretical half-wave dipole pattern"""
    angles = np.linspace(0, 360, 361)

    # E-plane: [cos(pi/2 * cos(theta)) / sin(theta)]²
    eplane = np.zeros_like(angles)
    for i, theta_deg in enumerate(angles):
        theta_rad = np.radians(theta_deg)
        sin_theta = np.sin(theta_rad)
        # Prevent division for zero (keep eplane[i] = 0 in that case)
        if np.abs(sin_theta) > 1e-6:
            eplane[i] = np.abs((np.cos(np.pi / 2 * np.cos(theta_rad)) / sin_theta))

    # H-plane: omnidirectional
    hplane = np.ones_like(angles)

    return angles, eplane, angles, hplane


def extract_and_process_data(
    data: dict[str, np.ndarray],
    mask: np.ndarray,
    angle_key: str,
    angle_offset: float = 0.0,
) -> tuple[Optional[np.ndarray], Optional[np.ndarray]]:
    """Extract and process data based on a mask."""
    if not np.any(mask):
        return None, None

    # Sort by increasing angle
    indices = np.where(mask)[0]
    angles = data[angle_key][indices]
    sort_idx = np.argsort(angles)

    # Apply angle offset (needed for E-plane)
    processed_angles = (angles[sort_idx] + angle_offset) % 360
    magnitude = compute_field_magnitude(
        {k: v[indices][sort_idx] for k, v in data.items()}
    )

    return processed_angles, magnitude


def extract_eplane(
    data: dict[str, np.ndarray], tolerance_deg: float = 0.5
) -> tuple[Optional[np.ndarray], Optional[np.ndarray]]:
    """Extract the E-plane (xz-plane)"""

    # The E-plane is the xz-plane. To capture this in spherical coordinates we
    # need phi = 0 and phi = 360, but also phi = 180. When phi = 180, we need to
    # offset the thetas by 180 so that they capture the full circle.

    # Define phi values and their corresponding theta offsets
    phi_targets = [
        (0, 0),  # phi ≈ 0/360, no theta offset
        (180, 180),  # phi ≈ 180, theta offset by 180
    ]

    angles_list = []
    magnitude_list = []

    for phi_target, theta_offset in phi_targets:
        # Create mask for this phi value (handle 0/360 case)
        if phi_target == 0:
            mask = (np.abs(data["phi"]) < tolerance_deg) | (
                np.abs(data["phi"] - 360) < tolerance_deg
            )
        else:
            mask = np.abs(data["phi"] - phi_target) < tolerance_deg

        angles, magnitude = extract_and_process_data(data, mask, "theta", theta_offset)
        if angles is not None:
            angles_list.append(angles)
            magnitude_list.append(magnitude)

    if not angles_list:
        return None, None

    # Combine all data
    if len(angles_list) > 1:
        angles = np.concatenate(angles_list)
        magnitude = np.concatenate(magnitude_list)
        # Sort by angle
        sort_idx = np.argsort(angles)
        angles = angles[sort_idx]
        magnitude = magnitude[sort_idx]
    else:
        angles = angles_list[0]
        magnitude = magnitude_list[0]

    return angles, magnitude


def extract_hplane(
    data: dict[str, np.ndarray], tolerance_deg: float = 0.5
) -> tuple[Optional[np.ndarray], Optional[np.ndarray]]:
    """Extract the H-plane (xy-plane)"""
    mask = np.abs(data["theta"] - 90.0) < tolerance_deg
    angles, magnitude = extract_and_process_data(data, mask, "phi")

    if angles is None:
        return None, None

    # Close the circle by adding one extra point
    angles = np.append(angles, angles[0] + 360.0)
    magnitude = np.append(magnitude, magnitude[0])

    return angles, magnitude


def create_plots(
    datasets: list[
        tuple[
            Optional[float],
            Optional[np.ndarray],
            Optional[np.ndarray],
            Optional[np.ndarray],
            Optional[np.ndarray],
        ]
    ]
) -> plt.Figure:
    """Create polar plots"""
    fig, (ax1, ax2) = plt.subplots(
        1, 2, figsize=(16, 8), subplot_kw=dict(projection="polar")
    )

    colors = ["blue", "red", "green", "orange", "purple", "brown", "pink", "gray"]
    line_styles = ["-", "--", "-.", ":"]

    # Collect all plot data for legend
    plot_data = []

    # Add theoretical pattern
    theo_theta, theo_eplane, theo_phi, theo_hplane = generate_theoretical_dipole()
    theo_eplane_db = compute_db(theo_eplane)
    theo_hplane_db = compute_db(theo_hplane)

    line = ax1.plot(
        np.radians(theo_theta), theo_eplane_db, "k--", linewidth=1, alpha=0.7
    )[0]
    ax2.plot(np.radians(theo_phi), theo_hplane_db, "k--", linewidth=1, alpha=0.7)
    plot_data.append((line, "Theory"))

    # Add simulation data
    for i, (radius, eplane_angles, eplane_db, hplane_angles, hplane_db) in enumerate(
        datasets
    ):
        if eplane_angles is not None and eplane_db is not None:
            color = colors[i % len(colors)]
            linestyle = line_styles[i % len(line_styles)]
            label = f"r = {radius:.2f}r_max" if radius else f"FarField {i+1}"

            line = ax1.plot(
                np.radians(eplane_angles),
                eplane_db,
                color=color,
                linestyle=linestyle,
                linewidth=2,
            )[0]
            ax2.plot(
                np.radians(hplane_angles),
                hplane_db,
                color=color,
                linestyle=linestyle,
                linewidth=2,
            )

            plot_data.append((line, label))

    # Configure plots
    for ax, title in zip([ax1, ax2], ["E-plane", "H-plane"]):
        ax.set_title(title, pad=20, fontsize=20)
        ax.set_ylim(-25, 2)
        ax.set_theta_zero_location("N")
        ax.set_theta_direction(-1)
        ax.grid(True, alpha=0.3)
        ax.set_ylabel("Gain [dB]", labelpad=40, fontsize=16)
        ax.set_thetagrids(np.arange(0, 360, 30))
        ax.tick_params(labelsize=14)

    # Legend
    legend_handles, legend_labels = zip(*plot_data)
    legend = fig.legend(
        legend_handles,
        legend_labels,
        loc="upper center",
        bbox_to_anchor=(0.5, 0.92),
        ncol=1,
        fontsize=16,
        frameon=False,
    )
    legend.get_title().set_fontsize(18)

    plt.tight_layout()
    plt.subplots_adjust(top=0.8)
    return fig


def main() -> None:
    if len(sys.argv) < 2:
        print(
            "Usage: python3 plot_radiation_pattern.py <farfield_csv_file> [additional_files...]"
        )
        sys.exit(1)

    input_files = sys.argv[1:]

    # Validate files
    for file_ in input_files:
        if not os.path.exists(file_):
            print(f"Error: File '{file_}' not found")
            sys.exit(1)

    # Process files
    datasets = []
    for filename in input_files:
        try:
            data = read_farfield_csv(filename)
            radius = extract_radius_from_filename(filename)

            eplane_angles, eplane_mag = extract_eplane(data)
            hplane_angles, hplane_mag = extract_hplane(data)

            eplane_db = compute_db(eplane_mag) if eplane_mag is not None else None
            hplane_db = compute_db(hplane_mag) if hplane_mag is not None else None

            datasets.append(
                (radius, eplane_angles, eplane_db, hplane_angles, hplane_db)
            )

        except Exception as e:
            print(f"Error processing {filename}: {e}")
            continue

    if not datasets:
        print("No valid datasets found")
        sys.exit(1)

    # Sort by radius and create plots
    datasets.sort(key=lambda x: x[0] if x[0] else 0)
    fig = create_plots(datasets)

    # Save
    output_file = "radiation_pattern.png"
    fig.savefig(output_file, dpi=300, bbox_inches="tight")
    plt.close(fig)
    print(f"Saved plot to: {output_file}")


if __name__ == "__main__":
    main()
