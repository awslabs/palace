#!/usr/bin/env python3

# Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.
# SPDX-License-Identifier: Apache-2.0

"""Convert Palace farfield CSV data to VTK format using Delaunay triangulation.

Usage:
    python3 farfield_csv2pvd_delaunay.py farfield-E-*.csv

    or

    pvpython farfield_csv2pvd_delaunay.py farfield-E-*.csv

Input CSV files are generated by Palace farfield postprocessing. Creates VTU
files in farfield_vtk/ subfolder and a PVD file for all the frequencies. Open
`farfield.pvd` with ParaView to visualize.

Requires numpy and vtk.
"""

import numpy as np
import sys

try:
    import vtk
except ImportError:
    print("Error: VTK library not found. Please install it with:")
    print("  pip install vtk")
    print("Alternatively, use pvpython.")
    sys.exit(1)

import re
import os


def add_vector_field(
    grid: vtk.vtkUnstructuredGrid,
    data: np.ndarray,
    name: str,
    components: tuple[int, int, int],
) -> None:
    """Add a 3-component vector field to the grid."""
    array = vtk.vtkDoubleArray()
    array.SetName(name)
    array.SetNumberOfComponents(3)
    array.SetNumberOfTuples(len(data))

    for i in range(len(data)):
        array.SetTuple3(
            i, data[i, components[0]], data[i, components[1]], data[i, components[2]]
        )

    grid.GetPointData().AddArray(array)


def add_scalar_field(
    grid: vtk.vtkUnstructuredGrid, data: np.ndarray, name: str
) -> None:
    """Add a scalar field to the grid."""
    array = vtk.vtkDoubleArray()
    array.SetName(name)
    array.SetNumberOfTuples(len(data))
    for i in range(len(data)):
        array.SetValue(i, data[i])
    grid.GetPointData().AddArray(array)


def create_connectivity_delaunay(
    grid: vtk.vtkUnstructuredGrid, extended_data: np.ndarray
) -> None:
    """Create spherical mesh connectivity: manual pole triangles + Delaunay for
    middle regions.

    Note, the heuristics to connect the poles is not fool-proof: it connects the
    poles with the points with closest thetas. This might not be a good
    assumption.

    """
    theta_unique = np.unique(extended_data[:, 0])
    point_map = {
        (t, p): i
        for i, (t, p) in enumerate(zip(extended_data[:, 0], extended_data[:, 1]))
    }

    # North and south pole triangles.
    if any(abs(t) < 1e-8 for t in theta_unique):
        phi_next = sorted(
            [p for (t, p) in point_map.keys() if abs(t - theta_unique[1]) < 1e-8]
        )
        for j in range(len(phi_next) - 1):
            tri = vtk.vtkTriangle()
            tri.GetPointIds().SetId(0, point_map[(0.0, 0.0)])
            tri.GetPointIds().SetId(1, point_map[(theta_unique[1], phi_next[j])])
            tri.GetPointIds().SetId(2, point_map[(theta_unique[1], phi_next[j + 1])])
            grid.InsertNextCell(tri.GetCellType(), tri.GetPointIds())

    if any(abs(t - 180.0) < 1e-8 for t in theta_unique):
        phi_prev = sorted(
            [p for (t, p) in point_map.keys() if abs(t - theta_unique[-2]) < 1e-8]
        )
        for j in range(len(phi_prev) - 1):
            tri = vtk.vtkTriangle()
            tri.GetPointIds().SetId(0, point_map[(theta_unique[-2], phi_prev[j])])
            tri.GetPointIds().SetId(1, point_map[(theta_unique[-2], phi_prev[j + 1])])
            tri.GetPointIds().SetId(2, point_map[(180.0, 0.0)])
            grid.InsertNextCell(tri.GetCellType(), tri.GetPointIds())

    # Delaunay triangulation for non-pole regions.
    non_pole_indices = []
    points_2d = vtk.vtkPoints()

    # Skip pole points, project others to 2D (phi, theta) plane.
    for i in range(grid.GetNumberOfPoints()):
        theta, phi = extended_data[i, 0], extended_data[i, 1]
        if not (abs(theta) < 1e-8 or abs(theta - 180.0) < 1e-8):
            non_pole_indices.append(i)
            points_2d.InsertNextPoint(phi, theta, 0.0)

    if points_2d.GetNumberOfPoints() > 2:
        grid_2d = vtk.vtkPolyData()
        grid_2d.SetPoints(points_2d)

        # Create 2D mesh and triangulate using Delaunay algorithm.
        delaunay = vtk.vtkDelaunay2D()
        delaunay.SetInputData(grid_2d)
        delaunay.SetBoundingTriangulation(
            True
        )  # Triangluate everything, not just the convex hull.
        delaunay.Update()

        # Map triangles back to 3D.
        result = delaunay.GetOutput()
        for i in range(result.GetNumberOfCells()):
            cell = result.GetCell(i)
            if cell.GetNumberOfPoints() == 3:
                point_ids = []
                for j in range(3):
                    pt_id = cell.GetPointId(j)
                    if pt_id < len(non_pole_indices):
                        point_ids.append(non_pole_indices[pt_id])

                if len(point_ids) == 3:
                    tri = vtk.vtkTriangle()
                    for j, original_id in enumerate(point_ids):
                        tri.GetPointIds().SetId(j, original_id)
                    grid.InsertNextCell(tri.GetCellType(), tri.GetPointIds())


def process_csv_file(filename: str) -> vtk.vtkUnstructuredGrid:
    # Read and extend data with periodic boundary. This helps close the
    # connectivity on the sphere.
    data = np.loadtxt(filename, delimiter=",", skiprows=1)
    phi_0_data = data[abs(data[:, 1]) < 1e-8].copy()
    phi_0_data[:, 1] = 360.0
    extended_data = np.vstack([data, phi_0_data])

    # Convert to Cartesian coordinates on the unit sphere.
    theta_rad = np.deg2rad(extended_data[:, 0])
    phi_rad = np.deg2rad(extended_data[:, 1])
    x = np.sin(theta_rad) * np.cos(phi_rad)
    y = np.sin(theta_rad) * np.sin(phi_rad)
    z = np.cos(theta_rad)

    # Create VTK grid and points.
    grid = vtk.vtkUnstructuredGrid()
    points = vtk.vtkPoints()
    for i in range(len(x)):
        points.InsertNextPoint(x[i], y[i], z[i])
    grid.SetPoints(points)

    # Create connectivity using Delaunay triangulation.
    create_connectivity_delaunay(grid, extended_data)

    # Add field data.
    add_vector_field(grid, extended_data, "E_real", (2, 4, 6))
    add_vector_field(grid, extended_data, "E_imag", (3, 5, 7))

    # Add magnitude.
    E_mag = np.sqrt(np.sum(extended_data[:, 2:8] ** 2, axis=1))
    add_scalar_field(grid, E_mag, "E_magnitude")

    return grid


def main() -> None:
    if len(sys.argv) < 2:
        print(
            "Usage: python3 farfield_csv2pvd_delaunay.py <farfield_csv_file> [additional_files...]"
        )
        sys.exit(1)

    # Create output directory.
    os.makedirs("farfield_vtk", exist_ok=True)

    # Process files and extract frequencies.
    freq_pattern = re.compile(r"farfield-E-([+-]?\d+\.\d+e[+-]?\d+)\.csv")
    files_data: list[tuple[float, str]] = []

    for filename in sys.argv[1:]:
        match_ = freq_pattern.search(filename)
        if match_:
            frequency = float(match_.group(1))
            grid = process_csv_file(filename)

            # Write VTU file.
            vtu_filename = f"farfield_vtk/farfield_{frequency:.8e}.vtu"
            writer = vtk.vtkXMLUnstructuredGridWriter()
            writer.SetFileName(vtu_filename)
            writer.SetInputData(grid)
            writer.Write()

            files_data.append((frequency, os.path.basename(vtu_filename)))
            print(f"Processed {filename} -> {vtu_filename}")

    # Sort by frequency and create PVD file.
    files_data.sort(key=lambda x: x[0])

    with open("farfield.pvd", "w") as pvd:
        pvd.write('<?xml version="1.0"?>\n')
        pvd.write(
            '<VTKFile type="Collection" version="2.2" byte_order="LittleEndian">\n'
        )
        pvd.write("  <Collection>\n")

        for i, (freq, vtu_file) in enumerate(files_data):
            pvd.write(f'    <DataSet timestep="{i}" file="farfield_vtk/{vtu_file}"/>\n')

        pvd.write("  </Collection>\n")
        pvd.write("</VTKFile>\n")

    print(f"Created farfield.pvd with {len(files_data)} frequencies")


if __name__ == "__main__":
    main()
